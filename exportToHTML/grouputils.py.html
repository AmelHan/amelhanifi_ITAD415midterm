<html>
<head>
<title>grouputils.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
grouputils.py</font>
</center></td></tr></table>
<pre><span class="s0"># -*- coding: utf-8 -*-</span>
<span class="s2">&quot;&quot;&quot;Tools for working with groups 
 
This provides several functions to work with groups and a Group class that 
keeps track of the different representations and has methods to work more 
easily with groups. 
 
 
Author: Josef Perktold, 
Author: Nathaniel Smith, recipe for sparse_dummies on scipy user mailing list 
 
Created on Tue Nov 29 15:44:53 2011 : sparse_dummies 
Created on Wed Nov 30 14:28:24 2011 : combine_indices 
changes: add Group class 
 
Notes 
~~~~~ 
 
This reverses the class I used before, where the class was for the data and 
the group was auxiliary. Here, it is only the group, no data is kept. 
 
sparse_dummies needs checking for corner cases, e.g. 
what if a category level has zero elements? This can happen with subset 
    selection even if the original groups where defined as arange. 
 
Not all methods and options have been tried out yet after refactoring 
 
need more efficient loop if groups are sorted -&gt; see GroupSorted.group_iter 
&quot;&quot;&quot;</span>
<span class="s3">from </span><span class="s1">statsmodels.compat.python </span><span class="s3">import </span><span class="s1">lrange</span><span class="s3">, </span><span class="s1">lzip</span>
<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">import </span><span class="s1">pandas </span><span class="s3">as </span><span class="s1">pd</span>

<span class="s3">import </span><span class="s1">statsmodels.tools.data </span><span class="s3">as </span><span class="s1">data_util</span>
<span class="s3">from </span><span class="s1">pandas </span><span class="s3">import </span><span class="s1">Index</span><span class="s3">, </span><span class="s1">MultiIndex</span>


<span class="s3">def </span><span class="s1">combine_indices(groups</span><span class="s3">, </span><span class="s1">prefix=</span><span class="s4">''</span><span class="s3">, </span><span class="s1">sep=</span><span class="s4">'.'</span><span class="s3">, </span><span class="s1">return_labels=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;use np.unique to get integer group indices for product, intersection 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">isinstance(groups</span><span class="s3">, </span><span class="s1">tuple):</span>
        <span class="s1">groups = np.column_stack(groups)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">groups = np.asarray(groups)</span>

    <span class="s1">dt = groups.dtype</span>

    <span class="s1">is2d = (groups.ndim == </span><span class="s5">2</span><span class="s1">)  </span><span class="s0"># need to store</span>

    <span class="s3">if </span><span class="s1">is2d:</span>
        <span class="s1">ncols = groups.shape[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s3">if not </span><span class="s1">groups.flags.c_contiguous:</span>
            <span class="s1">groups = np.array(groups</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'C'</span><span class="s1">)</span>

        <span class="s1">groups_ = groups.view([(</span><span class="s4">''</span><span class="s3">, </span><span class="s1">groups.dtype)] * groups.shape[</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">groups_ = groups</span>

    <span class="s1">uni</span><span class="s3">, </span><span class="s1">uni_idx</span><span class="s3">, </span><span class="s1">uni_inv = np.unique(groups_</span><span class="s3">, </span><span class="s1">return_index=</span><span class="s3">True,</span>
                                      <span class="s1">return_inverse=</span><span class="s3">True</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">is2d:</span>
        <span class="s1">uni = uni.view(dt).reshape(-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">ncols)</span>

        <span class="s0"># avoiding a view would be</span>
        <span class="s0"># for t in uni.dtype.fields.values():</span>
        <span class="s0">#     assert (t[0] == dt)</span>
        <span class="s0">#</span>
        <span class="s0"># uni.dtype = dt</span>
        <span class="s0"># uni.shape = (uni.size//ncols, ncols)</span>

    <span class="s3">if </span><span class="s1">return_labels:</span>
        <span class="s1">label = [(prefix+sep.join([</span><span class="s4">'%s'</span><span class="s1">]*len(uni[</span><span class="s5">0</span><span class="s1">]))) % tuple(ii)</span>
                 <span class="s3">for </span><span class="s1">ii </span><span class="s3">in </span><span class="s1">uni]</span>
        <span class="s3">return </span><span class="s1">uni_inv</span><span class="s3">, </span><span class="s1">uni_idx</span><span class="s3">, </span><span class="s1">uni</span><span class="s3">, </span><span class="s1">label</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">uni_inv</span><span class="s3">, </span><span class="s1">uni_idx</span><span class="s3">, </span><span class="s1">uni</span>


<span class="s0"># written for and used in try_covariance_grouploop.py</span>
<span class="s3">def </span><span class="s1">group_sums(x</span><span class="s3">, </span><span class="s1">group</span><span class="s3">, </span><span class="s1">use_bincount=</span><span class="s3">True</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;simple bincount version, again 
 
    group : ndarray, integer 
        assumed to be consecutive integers 
 
    no dtype checking because I want to raise in that case 
 
    uses loop over columns of x 
 
    for comparison, simple python loop 
    &quot;&quot;&quot;</span>
    <span class="s1">x = np.asarray(x)</span>
    <span class="s3">if </span><span class="s1">x.ndim == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">x = x[:</span><span class="s3">, None</span><span class="s1">]</span>
    <span class="s3">elif </span><span class="s1">x.ndim &gt; </span><span class="s5">2 </span><span class="s3">and </span><span class="s1">use_bincount:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'not implemented yet'</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">use_bincount:</span>

        <span class="s0"># re-label groups or bincount takes too much memory</span>
        <span class="s3">if </span><span class="s1">np.max(group) &gt; </span><span class="s5">2 </span><span class="s1">* x.shape[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s1">group = pd.factorize(group)[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s3">return </span><span class="s1">np.array([np.bincount(group</span><span class="s3">, </span><span class="s1">weights=x[:</span><span class="s3">, </span><span class="s1">col])</span>
                         <span class="s3">for </span><span class="s1">col </span><span class="s3">in </span><span class="s1">range(x.shape[</span><span class="s5">1</span><span class="s1">])])</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">uniques = np.unique(group)</span>
        <span class="s1">result = np.zeros([len(uniques)] + list(x.shape[</span><span class="s5">1</span><span class="s1">:]))</span>
        <span class="s3">for </span><span class="s1">ii</span><span class="s3">, </span><span class="s1">cat </span><span class="s3">in </span><span class="s1">enumerate(uniques):</span>
            <span class="s1">result[ii] = x[group == cat].sum(</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">result</span>


<span class="s3">def </span><span class="s1">group_sums_dummy(x</span><span class="s3">, </span><span class="s1">group_dummy):</span>
    <span class="s2">&quot;&quot;&quot;sum by groups given group dummy variable 
 
    group_dummy can be either ndarray or sparse matrix 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">data_util._is_using_ndarray_type(group_dummy</span><span class="s3">, None</span><span class="s1">):</span>
        <span class="s3">return </span><span class="s1">np.dot(x.T</span><span class="s3">, </span><span class="s1">group_dummy)</span>
    <span class="s3">else</span><span class="s1">:  </span><span class="s0"># check for sparse</span>
        <span class="s3">return </span><span class="s1">x.T * group_dummy</span>


<span class="s0"># TODO: See if this can be entirely replaced by Grouping.dummy_sparse;</span>
<span class="s0">#  see GH#5687</span>
<span class="s3">def </span><span class="s1">dummy_sparse(groups):</span>
    <span class="s2">&quot;&quot;&quot;create a sparse indicator from a group array with integer labels 
 
    Parameters 
    ---------- 
    groups : ndarray, int, 1d (nobs,) 
        an array of group indicators for each observation. Group levels are 
        assumed to be defined as consecutive integers, i.e. range(n_groups) 
        where n_groups is the number of group levels. A group level with no 
        observations for it will still produce a column of zeros. 
 
    Returns 
    ------- 
    indi : ndarray, int8, 2d (nobs, n_groups) 
        an indicator array with one row per observation, that has 1 in the 
        column of the group level for that observation 
 
    Examples 
    -------- 
 
    &gt;&gt;&gt; g = np.array([0, 0, 2, 1, 1, 2, 0]) 
    &gt;&gt;&gt; indi = dummy_sparse(g) 
    &gt;&gt;&gt; indi 
    &lt;7x3 sparse matrix of type '&lt;type 'numpy.int8'&gt;' 
        with 7 stored elements in Compressed Sparse Row format&gt; 
    &gt;&gt;&gt; indi.todense() 
    matrix([[1, 0, 0], 
            [1, 0, 0], 
            [0, 0, 1], 
            [0, 1, 0], 
            [0, 1, 0], 
            [0, 0, 1], 
            [1, 0, 0]], dtype=int8) 
 
 
    current behavior with missing groups 
    &gt;&gt;&gt; g = np.array([0, 0, 2, 0, 2, 0]) 
    &gt;&gt;&gt; indi = dummy_sparse(g) 
    &gt;&gt;&gt; indi.todense() 
    matrix([[1, 0, 0], 
            [1, 0, 0], 
            [0, 0, 1], 
            [1, 0, 0], 
            [0, 0, 1], 
            [1, 0, 0]], dtype=int8) 
    &quot;&quot;&quot;</span>
    <span class="s3">from </span><span class="s1">scipy </span><span class="s3">import </span><span class="s1">sparse</span>

    <span class="s1">indptr = np.arange(len(groups)+</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">data = np.ones(len(groups)</span><span class="s3">, </span><span class="s1">dtype=np.int8)</span>
    <span class="s1">indi = sparse.csr_matrix((data</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">, </span><span class="s1">indptr))</span>

    <span class="s3">return </span><span class="s1">indi</span>


<span class="s3">class </span><span class="s1">Group:</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">group</span><span class="s3">, </span><span class="s1">name=</span><span class="s4">''</span><span class="s1">):</span>

        <span class="s0"># self.group = np.asarray(group)  # TODO: use checks in combine_indices</span>
        <span class="s1">self.name = name</span>
        <span class="s1">uni</span><span class="s3">, </span><span class="s1">uni_idx</span><span class="s3">, </span><span class="s1">uni_inv = combine_indices(group)</span>

        <span class="s0"># TODO: rename these to something easier to remember</span>
        <span class="s1">self.group_int</span><span class="s3">, </span><span class="s1">self.uni_idx</span><span class="s3">, </span><span class="s1">self.uni = uni</span><span class="s3">, </span><span class="s1">uni_idx</span><span class="s3">, </span><span class="s1">uni_inv</span>

        <span class="s1">self.n_groups = len(self.uni)</span>

        <span class="s0"># put this here so they can be overwritten before calling labels</span>
        <span class="s1">self.separator = </span><span class="s4">'.'</span>
        <span class="s1">self.prefix = self.name</span>
        <span class="s3">if </span><span class="s1">self.prefix:</span>
            <span class="s1">self.prefix = self.prefix + </span><span class="s4">'='</span>

    <span class="s0"># cache decorator</span>
    <span class="s3">def </span><span class="s1">counts(self):</span>
        <span class="s3">return </span><span class="s1">np.bincount(self.group_int)</span>

    <span class="s0"># cache_decorator</span>
    <span class="s3">def </span><span class="s1">labels(self):</span>
        <span class="s0"># is this only needed for product of groups (intersection)?</span>
        <span class="s1">prefix = self.prefix</span>
        <span class="s1">uni = self.uni</span>
        <span class="s1">sep = self.separator</span>

        <span class="s3">if </span><span class="s1">uni.ndim &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">label = [(prefix+sep.join([</span><span class="s4">'%s'</span><span class="s1">]*len(uni[</span><span class="s5">0</span><span class="s1">]))) % tuple(ii)</span>
                     <span class="s3">for </span><span class="s1">ii </span><span class="s3">in </span><span class="s1">uni]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">label = [prefix + </span><span class="s4">'%s' </span><span class="s1">% ii </span><span class="s3">for </span><span class="s1">ii </span><span class="s3">in </span><span class="s1">uni]</span>
        <span class="s3">return </span><span class="s1">label</span>

    <span class="s3">def </span><span class="s1">dummy(self</span><span class="s3">, </span><span class="s1">drop_idx=</span><span class="s3">None, </span><span class="s1">sparse=</span><span class="s3">False, </span><span class="s1">dtype=int):</span>
        <span class="s2">&quot;&quot;&quot; 
        drop_idx is only available if sparse=False 
 
        drop_idx is supposed to index into uni 
        &quot;&quot;&quot;</span>
        <span class="s1">uni = self.uni</span>
        <span class="s3">if </span><span class="s1">drop_idx </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">idx = lrange(len(uni))</span>
            <span class="s3">del </span><span class="s1">idx[drop_idx]</span>
            <span class="s1">uni = uni[idx]</span>

        <span class="s1">group = self.group</span>

        <span class="s3">if not </span><span class="s1">sparse:</span>
            <span class="s3">return </span><span class="s1">(group[:</span><span class="s3">, None</span><span class="s1">] == uni[</span><span class="s3">None, </span><span class="s1">:]).astype(dtype)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">dummy_sparse(self.group_int)</span>

    <span class="s3">def </span><span class="s1">interaction(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">self.__class__):</span>
            <span class="s1">other = other.group</span>
        <span class="s3">return </span><span class="s1">self.__class__((self</span><span class="s3">, </span><span class="s1">other))</span>

    <span class="s3">def </span><span class="s1">group_sums(self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">use_bincount=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s3">return </span><span class="s1">group_sums(x</span><span class="s3">, </span><span class="s1">self.group_int</span><span class="s3">, </span><span class="s1">use_bincount=use_bincount)</span>

    <span class="s3">def </span><span class="s1">group_demean(self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">use_bincount=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s1">nobs = float(len(x))</span>
        <span class="s1">means_g = group_sums(x / nobs</span><span class="s3">, </span><span class="s1">self.group_int</span><span class="s3">,</span>
                             <span class="s1">use_bincount=use_bincount)</span>
        <span class="s1">x_demeaned = x - means_g[self.group_int]  </span><span class="s0"># check reverse_index?</span>
        <span class="s3">return </span><span class="s1">x_demeaned</span><span class="s3">, </span><span class="s1">means_g</span>


<span class="s3">class </span><span class="s1">GroupSorted(Group):</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">group</span><span class="s3">, </span><span class="s1">name=</span><span class="s4">''</span><span class="s1">):</span>
        <span class="s1">super(self.__class__</span><span class="s3">, </span><span class="s1">self).__init__(group</span><span class="s3">, </span><span class="s1">name=name)</span>

        <span class="s1">idx = (np.nonzero(np.diff(group))[</span><span class="s5">0</span><span class="s1">]+</span><span class="s5">1</span><span class="s1">).tolist()</span>
        <span class="s1">self.groupidx = lzip([</span><span class="s5">0</span><span class="s1">] + idx</span><span class="s3">, </span><span class="s1">idx + [len(group)])</span>

    <span class="s3">def </span><span class="s1">group_iter(self):</span>
        <span class="s3">for </span><span class="s1">low</span><span class="s3">, </span><span class="s1">upp </span><span class="s3">in </span><span class="s1">self.groupidx:</span>
            <span class="s3">yield </span><span class="s1">slice(low</span><span class="s3">, </span><span class="s1">upp)</span>

    <span class="s3">def </span><span class="s1">lag_indices(self</span><span class="s3">, </span><span class="s1">lag):</span>
        <span class="s2">&quot;&quot;&quot;return the index array for lagged values 
 
        Warning: if k is larger then the number of observations for an 
        individual, then no values for that individual are returned. 
 
        TODO: for the unbalanced case, I should get the same truncation for 
        the array with lag=0. From the return of lag_idx we would not know 
        which individual is missing. 
 
        TODO: do I want the full equivalent of lagmat in tsa? 
        maxlag or lag or lags. 
 
        not tested yet 
        &quot;&quot;&quot;</span>
        <span class="s1">lag_idx = np.asarray(self.groupidx)[:</span><span class="s3">, </span><span class="s5">1</span><span class="s1">] - lag  </span><span class="s0"># asarray or already?</span>
        <span class="s1">mask_ok = (lag &lt;= lag_idx)</span>
        <span class="s0"># still an observation that belongs to the same individual</span>

        <span class="s3">return </span><span class="s1">lag_idx[mask_ok]</span>


<span class="s3">def </span><span class="s1">_is_hierarchical(x):</span>
    <span class="s2">&quot;&quot;&quot; 
    Checks if the first item of an array-like object is also array-like 
    If so, we have a MultiIndex and returns True. Else returns False. 
    &quot;&quot;&quot;</span>
    <span class="s1">item = x[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s0"># is there a better way to do this?</span>
    <span class="s3">if </span><span class="s1">isinstance(item</span><span class="s3">, </span><span class="s1">(list</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">, </span><span class="s1">np.ndarray</span><span class="s3">, </span><span class="s1">pd.Series</span><span class="s3">, </span><span class="s1">pd.DataFrame)):</span>
        <span class="s3">return True</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return False</span>


<span class="s3">def </span><span class="s1">_make_hierarchical_index(index</span><span class="s3">, </span><span class="s1">names):</span>
    <span class="s3">return </span><span class="s1">MultiIndex.from_tuples(*[index]</span><span class="s3">, </span><span class="s1">names=names)</span>


<span class="s3">def </span><span class="s1">_make_generic_names(index):</span>
    <span class="s1">n_names = len(index.names)</span>
    <span class="s1">pad = str(len(str(n_names)))  </span><span class="s0"># number of digits</span>
    <span class="s3">return </span><span class="s1">[(</span><span class="s4">&quot;group{0:0&quot;</span><span class="s1">+pad+</span><span class="s4">&quot;}&quot;</span><span class="s1">).format(i) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(n_names)]</span>


<span class="s3">class </span><span class="s1">Grouping:</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">names=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        index : index-like 
            Can be pandas MultiIndex or Index or array-like. If array-like 
            and is a MultipleIndex (more than one grouping variable), 
            groups are expected to be in each row. E.g., [('red', 1), 
            ('red', 2), ('green', 1), ('green', 2)] 
        names : list or str, optional 
            The names to use for the groups. Should be a str if only 
            one grouping variable is used. 
 
        Notes 
        ----- 
        If index is already a pandas Index then there is no copy. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">isinstance(index</span><span class="s3">, </span><span class="s1">(Index</span><span class="s3">, </span><span class="s1">MultiIndex)):</span>
            <span class="s3">if </span><span class="s1">names </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">hasattr(index</span><span class="s3">, </span><span class="s4">'set_names'</span><span class="s1">):  </span><span class="s0"># newer pandas</span>
                    <span class="s1">index.set_names(names</span><span class="s3">, </span><span class="s1">inplace=</span><span class="s3">True</span><span class="s1">)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">index.names = names</span>
            <span class="s1">self.index = index</span>
        <span class="s3">else</span><span class="s1">:  </span><span class="s0"># array_like</span>
            <span class="s3">if </span><span class="s1">_is_hierarchical(index):</span>
                <span class="s1">self.index = _make_hierarchical_index(index</span><span class="s3">, </span><span class="s1">names)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self.index = Index(index</span><span class="s3">, </span><span class="s1">name=names)</span>
            <span class="s3">if </span><span class="s1">names </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">names = _make_generic_names(self.index)</span>
                <span class="s3">if </span><span class="s1">hasattr(self.index</span><span class="s3">, </span><span class="s4">'set_names'</span><span class="s1">):</span>
                    <span class="s1">self.index.set_names(names</span><span class="s3">, </span><span class="s1">inplace=</span><span class="s3">True</span><span class="s1">)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">self.index.names = names</span>

        <span class="s1">self.nobs = len(self.index)</span>
        <span class="s1">self.nlevels = len(self.index.names)</span>
        <span class="s1">self.slices = </span><span class="s3">None</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">index_shape(self):</span>
        <span class="s3">if </span><span class="s1">hasattr(self.index</span><span class="s3">, </span><span class="s4">'levshape'</span><span class="s1">):</span>
            <span class="s3">return </span><span class="s1">self.index.levshape</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.index.shape</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">levels(self):</span>
        <span class="s3">if </span><span class="s1">hasattr(self.index</span><span class="s3">, </span><span class="s4">'levels'</span><span class="s1">):</span>
            <span class="s3">return </span><span class="s1">self.index.levels</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">pd.Categorical(self.index).levels</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">labels(self):</span>
        <span class="s0"># this was index_int, but that's not a very good name...</span>
        <span class="s1">codes = getattr(self.index</span><span class="s3">, </span><span class="s4">'codes'</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">codes </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">hasattr(self.index</span><span class="s3">, </span><span class="s4">'labels'</span><span class="s1">):</span>
                <span class="s1">codes = self.index.labels</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">codes = pd.Categorical(self.index).codes[</span><span class="s3">None</span><span class="s1">]</span>
        <span class="s3">return </span><span class="s1">codes</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">group_names(self):</span>
        <span class="s3">return </span><span class="s1">self.index.names</span>

    <span class="s3">def </span><span class="s1">reindex(self</span><span class="s3">, </span><span class="s1">index=</span><span class="s3">None, </span><span class="s1">names=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Resets the index in-place. 
        &quot;&quot;&quot;</span>
        <span class="s0"># NOTE: this is not of much use if the rest of the data does not change</span>
        <span class="s0"># This needs to reset cache</span>
        <span class="s3">if </span><span class="s1">names </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">names = self.group_names</span>
        <span class="s1">self = Grouping(index</span><span class="s3">, </span><span class="s1">names)</span>

    <span class="s3">def </span><span class="s1">get_slices(self</span><span class="s3">, </span><span class="s1">level=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Sets the slices attribute to be a list of indices of the sorted 
        groups for the first index level. I.e., self.slices[0] is the 
        index where each observation is in the first (sorted) group. 
        &quot;&quot;&quot;</span>
        <span class="s0"># TODO: refactor this</span>
        <span class="s1">groups = self.index.get_level_values(level).unique()</span>
        <span class="s1">groups = np.array(groups)</span>
        <span class="s1">groups.sort()</span>
        <span class="s3">if </span><span class="s1">isinstance(self.index</span><span class="s3">, </span><span class="s1">MultiIndex):</span>
            <span class="s1">self.slices = [self.index.get_loc_level(x</span><span class="s3">, </span><span class="s1">level=level)[</span><span class="s5">0</span><span class="s1">]</span>
                           <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">groups]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.slices = [self.index.get_loc(x) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">groups]</span>

    <span class="s3">def </span><span class="s1">count_categories(self</span><span class="s3">, </span><span class="s1">level=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Sets the attribute counts to equal the bincount of the (integer-valued) 
        labels. 
        &quot;&quot;&quot;</span>
        <span class="s0"># TODO: refactor this not to set an attribute. Why would we do this?</span>
        <span class="s1">self.counts = np.bincount(self.labels[level])</span>

    <span class="s3">def </span><span class="s1">check_index(self</span><span class="s3">, </span><span class="s1">is_sorted=</span><span class="s3">True, </span><span class="s1">unique=</span><span class="s3">True, </span><span class="s1">index=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Sanity checks&quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">index:</span>
            <span class="s1">index = self.index</span>
        <span class="s3">if </span><span class="s1">is_sorted:</span>
            <span class="s1">test = pd.DataFrame(lrange(len(index))</span><span class="s3">, </span><span class="s1">index=index)</span>
            <span class="s1">test_sorted = test.sort()</span>
            <span class="s3">if not </span><span class="s1">test.index.equals(test_sorted.index):</span>
                <span class="s3">raise </span><span class="s1">Exception(</span><span class="s4">'Data is not be sorted'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">unique:</span>
            <span class="s3">if </span><span class="s1">len(index) != len(index.unique()):</span>
                <span class="s3">raise </span><span class="s1">Exception(</span><span class="s4">'Duplicate index entries'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">sort(self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">index=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Applies a (potentially hierarchical) sort operation on a numpy array 
        or pandas series/dataframe based on the grouping index or a 
        user-supplied index.  Returns an object of the same type as the 
        original data as well as the matching (sorted) Pandas index. 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">index </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">index = self.index</span>
        <span class="s3">if </span><span class="s1">data_util._is_using_ndarray_type(data</span><span class="s3">, None</span><span class="s1">):</span>
            <span class="s3">if </span><span class="s1">data.ndim == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">out = pd.Series(data</span><span class="s3">, </span><span class="s1">index=index</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">True</span><span class="s1">)</span>
                <span class="s1">out = out.sort_index()</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">out = pd.DataFrame(data</span><span class="s3">, </span><span class="s1">index=index)</span>
                <span class="s1">out = out.sort_index(inplace=</span><span class="s3">False</span><span class="s1">)  </span><span class="s0"># copies</span>
            <span class="s3">return </span><span class="s1">np.array(out)</span><span class="s3">, </span><span class="s1">out.index</span>
        <span class="s3">elif </span><span class="s1">data_util._is_using_pandas(data</span><span class="s3">, None</span><span class="s1">):</span>
            <span class="s1">out = data</span>
            <span class="s1">out = out.reindex(index)  </span><span class="s0"># copies?</span>
            <span class="s1">out = out.sort_index()</span>
            <span class="s3">return </span><span class="s1">out</span><span class="s3">, </span><span class="s1">out.index</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s4">'data must be a Numpy array or a Pandas Series/DataFrame'</span>
            <span class="s3">raise </span><span class="s1">ValueError(msg)</span>

    <span class="s3">def </span><span class="s1">transform_dataframe(self</span><span class="s3">, </span><span class="s1">dataframe</span><span class="s3">, </span><span class="s1">function</span><span class="s3">, </span><span class="s1">level=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot;Apply function to each column, by group 
        Assumes that the dataframe already has a proper index&quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">dataframe.shape[</span><span class="s5">0</span><span class="s1">] != self.nobs:</span>
            <span class="s3">raise </span><span class="s1">Exception(</span><span class="s4">'dataframe does not have the same shape as index'</span><span class="s1">)</span>
        <span class="s1">out = dataframe.groupby(level=level).apply(function</span><span class="s3">, </span><span class="s1">**kwargs)</span>
        <span class="s3">if </span><span class="s5">1 </span><span class="s3">in </span><span class="s1">out.shape:</span>
            <span class="s3">return </span><span class="s1">np.ravel(out)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">np.array(out)</span>

    <span class="s3">def </span><span class="s1">transform_array(self</span><span class="s3">, </span><span class="s1">array</span><span class="s3">, </span><span class="s1">function</span><span class="s3">, </span><span class="s1">level=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot;Apply function to each column, by group 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">array.shape[</span><span class="s5">0</span><span class="s1">] != self.nobs:</span>
            <span class="s3">raise </span><span class="s1">Exception(</span><span class="s4">'array does not have the same shape as index'</span><span class="s1">)</span>
        <span class="s1">dataframe = pd.DataFrame(array</span><span class="s3">, </span><span class="s1">index=self.index)</span>
        <span class="s3">return </span><span class="s1">self.transform_dataframe(dataframe</span><span class="s3">, </span><span class="s1">function</span><span class="s3">, </span><span class="s1">level=level</span><span class="s3">,</span>
                                        <span class="s1">**kwargs)</span>

    <span class="s3">def </span><span class="s1">transform_slices(self</span><span class="s3">, </span><span class="s1">array</span><span class="s3">, </span><span class="s1">function</span><span class="s3">, </span><span class="s1">level=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot;Apply function to each group. Similar to transform_array but does 
        not coerce array to a DataFrame and back and only works on a 1D or 2D 
        numpy array. function is called function(group, group_idx, **kwargs). 
        &quot;&quot;&quot;</span>
        <span class="s1">array = np.asarray(array)</span>
        <span class="s3">if </span><span class="s1">array.shape[</span><span class="s5">0</span><span class="s1">] != self.nobs:</span>
            <span class="s3">raise </span><span class="s1">Exception(</span><span class="s4">'array does not have the same shape as index'</span><span class="s1">)</span>
        <span class="s0"># always reset because level is given. need to refactor this.</span>
        <span class="s1">self.get_slices(level=level)</span>
        <span class="s1">processed = []</span>
        <span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">self.slices:</span>
            <span class="s3">if </span><span class="s1">array.ndim == </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s1">subset = array[s</span><span class="s3">, </span><span class="s1">:]</span>
            <span class="s3">elif </span><span class="s1">array.ndim == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">subset = array[s]</span>
            <span class="s1">processed.append(function(subset</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">**kwargs))</span>
        <span class="s1">processed = np.array(processed)</span>
        <span class="s3">return </span><span class="s1">processed.reshape(-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">processed.shape[-</span><span class="s5">1</span><span class="s1">])</span>

    <span class="s0"># TODO: this is not general needs to be a PanelGrouping object</span>
    <span class="s3">def </span><span class="s1">dummies_time(self):</span>
        <span class="s1">self.dummy_sparse(level=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">self._dummies</span>

    <span class="s3">def </span><span class="s1">dummies_groups(self</span><span class="s3">, </span><span class="s1">level=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s1">self.dummy_sparse(level=level)</span>
        <span class="s3">return </span><span class="s1">self._dummies</span>

    <span class="s3">def </span><span class="s1">dummy_sparse(self</span><span class="s3">, </span><span class="s1">level=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;create a sparse indicator from a group array with integer labels 
 
        Parameters 
        ---------- 
        groups : ndarray, int, 1d (nobs,) 
            An array of group indicators for each observation. Group levels 
            are assumed to be defined as consecutive integers, i.e. 
            range(n_groups) where n_groups is the number of group levels. 
            A group level with no observations for it will still produce a 
            column of zeros. 
 
        Returns 
        ------- 
        indi : ndarray, int8, 2d (nobs, n_groups) 
            an indicator array with one row per observation, that has 1 in the 
            column of the group level for that observation 
 
        Examples 
        -------- 
 
        &gt;&gt;&gt; g = np.array([0, 0, 2, 1, 1, 2, 0]) 
        &gt;&gt;&gt; indi = dummy_sparse(g) 
        &gt;&gt;&gt; indi 
        &lt;7x3 sparse matrix of type '&lt;type 'numpy.int8'&gt;' 
            with 7 stored elements in Compressed Sparse Row format&gt; 
        &gt;&gt;&gt; indi.todense() 
        matrix([[1, 0, 0], 
                [1, 0, 0], 
                [0, 0, 1], 
                [0, 1, 0], 
                [0, 1, 0], 
                [0, 0, 1], 
                [1, 0, 0]], dtype=int8) 
 
 
        current behavior with missing groups 
        &gt;&gt;&gt; g = np.array([0, 0, 2, 0, 2, 0]) 
        &gt;&gt;&gt; indi = dummy_sparse(g) 
        &gt;&gt;&gt; indi.todense() 
        matrix([[1, 0, 0], 
                [1, 0, 0], 
                [0, 0, 1], 
                [1, 0, 0], 
                [0, 0, 1], 
                [1, 0, 0]], dtype=int8) 
        &quot;&quot;&quot;</span>
        <span class="s1">indi = dummy_sparse(self.labels[level])</span>
        <span class="s1">self._dummies = indi</span>
</pre>
</body>
</html>