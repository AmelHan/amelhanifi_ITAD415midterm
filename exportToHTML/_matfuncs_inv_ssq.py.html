<html>
<head>
<title>_matfuncs_inv_ssq.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_matfuncs_inv_ssq.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Matrix functions that use Pade approximation with inverse scaling and squaring. 
 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">scipy.linalg._matfuncs_sqrtm </span><span class="s2">import </span><span class="s1">SqrtmError</span><span class="s2">, </span><span class="s1">_sqrtm_triu</span>
<span class="s2">from </span><span class="s1">scipy.linalg._decomp_schur </span><span class="s2">import </span><span class="s1">schur</span><span class="s2">, </span><span class="s1">rsf2csf</span>
<span class="s2">from </span><span class="s1">scipy.linalg._matfuncs </span><span class="s2">import </span><span class="s1">funm</span>
<span class="s2">from </span><span class="s1">scipy.linalg </span><span class="s2">import </span><span class="s1">svdvals</span><span class="s2">, </span><span class="s1">solve_triangular</span>
<span class="s2">from </span><span class="s1">scipy.sparse.linalg._interface </span><span class="s2">import </span><span class="s1">LinearOperator</span>
<span class="s2">from </span><span class="s1">scipy.sparse.linalg </span><span class="s2">import </span><span class="s1">onenormest</span>
<span class="s2">import </span><span class="s1">scipy.special</span>


<span class="s2">class </span><span class="s1">LogmRankWarning(UserWarning):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">LogmExactlySingularWarning(LogmRankWarning):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">LogmNearlySingularWarning(LogmRankWarning):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">LogmError(np.linalg.LinAlgError):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">FractionalMatrixPowerError(np.linalg.LinAlgError):</span>
    <span class="s2">pass</span>


<span class="s3">#TODO renovate or move this class when scipy operators are more mature</span>
<span class="s2">class </span><span class="s1">_MatrixM1PowerOperator(LinearOperator):</span>
    <span class="s0">&quot;&quot;&quot; 
    A representation of the linear operator (A - I)^p. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">A</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s2">if </span><span class="s1">A.ndim != </span><span class="s4">2 </span><span class="s2">or </span><span class="s1">A.shape[</span><span class="s4">0</span><span class="s1">] != A.shape[</span><span class="s4">1</span><span class="s1">]:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'expected A to be like a square matrix'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">p &lt; </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">p != int(p):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'expected p to be a non-negative integer'</span><span class="s1">)</span>
        <span class="s1">self._A = A</span>
        <span class="s1">self._p = p</span>
        <span class="s1">self.ndim = A.ndim</span>
        <span class="s1">self.shape = A.shape</span>

    <span class="s2">def </span><span class="s1">_matvec(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self._p):</span>
            <span class="s1">x = self._A.dot(x) - x</span>
        <span class="s2">return </span><span class="s1">x</span>

    <span class="s2">def </span><span class="s1">_rmatvec(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self._p):</span>
            <span class="s1">x = x.dot(self._A) - x</span>
        <span class="s2">return </span><span class="s1">x</span>

    <span class="s2">def </span><span class="s1">_matmat(self</span><span class="s2">, </span><span class="s1">X):</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self._p):</span>
            <span class="s1">X = self._A.dot(X) - X</span>
        <span class="s2">return </span><span class="s1">X</span>

    <span class="s2">def </span><span class="s1">_adjoint(self):</span>
        <span class="s2">return </span><span class="s1">_MatrixM1PowerOperator(self._A.T</span><span class="s2">, </span><span class="s1">self._p)</span>


<span class="s3">#TODO renovate or move this function when SciPy operators are more mature</span>
<span class="s2">def </span><span class="s1">_onenormest_m1_power(A</span><span class="s2">, </span><span class="s1">p</span><span class="s2">,</span>
        <span class="s1">t=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">itmax=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">compute_v=</span><span class="s2">False, </span><span class="s1">compute_w=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Efficiently estimate the 1-norm of (A - I)^p. 
 
    Parameters 
    ---------- 
    A : ndarray 
        Matrix whose 1-norm of a power is to be computed. 
    p : int 
        Non-negative integer power. 
    t : int, optional 
        A positive parameter controlling the tradeoff between 
        accuracy versus time and memory usage. 
        Larger values take longer and use more memory 
        but give more accurate output. 
    itmax : int, optional 
        Use at most this many iterations. 
    compute_v : bool, optional 
        Request a norm-maximizing linear operator input vector if True. 
    compute_w : bool, optional 
        Request a norm-maximizing linear operator output vector if True. 
 
    Returns 
    ------- 
    est : float 
        An underestimate of the 1-norm of the sparse matrix. 
    v : ndarray, optional 
        The vector such that ||Av||_1 == est*||v||_1. 
        It can be thought of as an input to the linear operator 
        that gives an output with particularly large norm. 
    w : ndarray, optional 
        The vector Av which has relatively large 1-norm. 
        It can be thought of as an output of the linear operator 
        that is relatively large in norm compared to the input. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">onenormest(_MatrixM1PowerOperator(A</span><span class="s2">, </span><span class="s1">p)</span><span class="s2">,</span>
            <span class="s1">t=t</span><span class="s2">, </span><span class="s1">itmax=itmax</span><span class="s2">, </span><span class="s1">compute_v=compute_v</span><span class="s2">, </span><span class="s1">compute_w=compute_w)</span>


<span class="s2">def </span><span class="s1">_unwindk(z):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the scalar unwinding number. 
 
    Uses Eq. (5.3) in [1]_, and should be equal to (z - log(exp(z)) / (2 pi i). 
    Note that this definition differs in sign from the original definition 
    in equations (5, 6) in [2]_.  The sign convention is justified in [3]_. 
 
    Parameters 
    ---------- 
    z : complex 
        A complex number. 
 
    Returns 
    ------- 
    unwinding_number : integer 
        The scalar unwinding number of z. 
 
    References 
    ---------- 
    .. [1] Nicholas J. Higham and Lijing lin (2011) 
           &quot;A Schur-Pade Algorithm for Fractional Powers of a Matrix.&quot; 
           SIAM Journal on Matrix Analysis and Applications, 
           32 (3). pp. 1056-1078. ISSN 0895-4798 
 
    .. [2] Robert M. Corless and David J. Jeffrey, 
           &quot;The unwinding number.&quot; Newsletter ACM SIGSAM Bulletin 
           Volume 30, Issue 2, June 1996, Pages 28-35. 
 
    .. [3] Russell Bradford and Robert M. Corless and James H. Davenport and 
           David J. Jeffrey and Stephen M. Watt, 
           &quot;Reasoning about the elementary functions of complex analysis&quot; 
           Annals of Mathematics and Artificial Intelligence, 
           36: 303-318, 2002. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">int(np.ceil((z.imag - np.pi) / (</span><span class="s4">2</span><span class="s1">*np.pi)))</span>


<span class="s2">def </span><span class="s1">_briggs_helper_function(a</span><span class="s2">, </span><span class="s1">k):</span>
    <span class="s0">&quot;&quot;&quot; 
    Computes r = a^(1 / (2^k)) - 1. 
 
    This is algorithm (2) of [1]_. 
    The purpose is to avoid a danger of subtractive cancellation. 
    For more computational efficiency it should probably be cythonized. 
 
    Parameters 
    ---------- 
    a : complex 
        A complex number. 
    k : integer 
        A nonnegative integer. 
 
    Returns 
    ------- 
    r : complex 
        The value r = a^(1 / (2^k)) - 1 computed with less cancellation. 
 
    Notes 
    ----- 
    The algorithm as formulated in the reference does not handle k=0 or k=1 
    correctly, so these are special-cased in this implementation. 
    This function is intended to not allow `a` to belong to the closed 
    negative real axis, but this constraint is relaxed. 
 
    References 
    ---------- 
    .. [1] Awad H. Al-Mohy (2012) 
           &quot;A more accurate Briggs method for the logarithm&quot;, 
           Numerical Algorithms, 59 : 393--402. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">k &lt; </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">int(k) != k:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'expected a nonnegative integer k'</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">k == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">a - </span><span class="s4">1</span>
    <span class="s2">elif </span><span class="s1">k == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">np.sqrt(a) - </span><span class="s4">1</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">k_hat = k</span>
        <span class="s2">if </span><span class="s1">np.angle(a) &gt;= np.pi / </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s1">a = np.sqrt(a)</span>
            <span class="s1">k_hat = k - </span><span class="s4">1</span>
        <span class="s1">z0 = a - </span><span class="s4">1</span>
        <span class="s1">a = np.sqrt(a)</span>
        <span class="s1">r = </span><span class="s4">1 </span><span class="s1">+ a</span>
        <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">k_hat):</span>
            <span class="s1">a = np.sqrt(a)</span>
            <span class="s1">r = r * (</span><span class="s4">1 </span><span class="s1">+ a)</span>
        <span class="s1">r = z0 / r</span>
        <span class="s2">return </span><span class="s1">r</span>


<span class="s2">def </span><span class="s1">_fractional_power_superdiag_entry(l1</span><span class="s2">, </span><span class="s1">l2</span><span class="s2">, </span><span class="s1">t12</span><span class="s2">, </span><span class="s1">p):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute a superdiagonal entry of a fractional matrix power. 
 
    This is Eq. (5.6) in [1]_. 
 
    Parameters 
    ---------- 
    l1 : complex 
        A diagonal entry of the matrix. 
    l2 : complex 
        A diagonal entry of the matrix. 
    t12 : complex 
        A superdiagonal entry of the matrix. 
    p : float 
        A fractional power. 
 
    Returns 
    ------- 
    f12 : complex 
        A superdiagonal entry of the fractional matrix power. 
 
    Notes 
    ----- 
    Care has been taken to return a real number if possible when 
    all of the inputs are real numbers. 
 
    References 
    ---------- 
    .. [1] Nicholas J. Higham and Lijing lin (2011) 
           &quot;A Schur-Pade Algorithm for Fractional Powers of a Matrix.&quot; 
           SIAM Journal on Matrix Analysis and Applications, 
           32 (3). pp. 1056-1078. ISSN 0895-4798 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">l1 == l2:</span>
        <span class="s1">f12 = t12 * p * l1**(p-</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">abs(l2 - l1) &gt; abs(l1 + l2) / </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s1">f12 = t12 * ((l2**p) - (l1**p)) / (l2 - l1)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s3"># This is Eq. (5.5) in [1].</span>
        <span class="s1">z = (l2 - l1) / (l2 + l1)</span>
        <span class="s1">log_l1 = np.log(l1)</span>
        <span class="s1">log_l2 = np.log(l2)</span>
        <span class="s1">arctanh_z = np.arctanh(z)</span>
        <span class="s1">tmp_a = t12 * np.exp((p/</span><span class="s4">2</span><span class="s1">)*(log_l2 + log_l1))</span>
        <span class="s1">tmp_u = _unwindk(log_l2 - log_l1)</span>
        <span class="s2">if </span><span class="s1">tmp_u:</span>
            <span class="s1">tmp_b = p * (arctanh_z + np.pi * </span><span class="s4">1j </span><span class="s1">* tmp_u)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">tmp_b = p * arctanh_z</span>
        <span class="s1">tmp_c = </span><span class="s4">2 </span><span class="s1">* np.sinh(tmp_b) / (l2 - l1)</span>
        <span class="s1">f12 = tmp_a * tmp_c</span>
    <span class="s2">return </span><span class="s1">f12</span>


<span class="s2">def </span><span class="s1">_logm_superdiag_entry(l1</span><span class="s2">, </span><span class="s1">l2</span><span class="s2">, </span><span class="s1">t12):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute a superdiagonal entry of a matrix logarithm. 
 
    This is like Eq. (11.28) in [1]_, except the determination of whether 
    l1 and l2 are sufficiently far apart has been modified. 
 
    Parameters 
    ---------- 
    l1 : complex 
        A diagonal entry of the matrix. 
    l2 : complex 
        A diagonal entry of the matrix. 
    t12 : complex 
        A superdiagonal entry of the matrix. 
 
    Returns 
    ------- 
    f12 : complex 
        A superdiagonal entry of the matrix logarithm. 
 
    Notes 
    ----- 
    Care has been taken to return a real number if possible when 
    all of the inputs are real numbers. 
 
    References 
    ---------- 
    .. [1] Nicholas J. Higham (2008) 
           &quot;Functions of Matrices: Theory and Computation&quot; 
           ISBN 978-0-898716-46-7 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">l1 == l2:</span>
        <span class="s1">f12 = t12 / l1</span>
    <span class="s2">elif </span><span class="s1">abs(l2 - l1) &gt; abs(l1 + l2) / </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s1">f12 = t12 * (np.log(l2) - np.log(l1)) / (l2 - l1)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">z = (l2 - l1) / (l2 + l1)</span>
        <span class="s1">u = _unwindk(np.log(l2) - np.log(l1))</span>
        <span class="s2">if </span><span class="s1">u:</span>
            <span class="s1">f12 = t12 * </span><span class="s4">2 </span><span class="s1">* (np.arctanh(z) + np.pi*</span><span class="s4">1j</span><span class="s1">*u) / (l2 - l1)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">f12 = t12 * </span><span class="s4">2 </span><span class="s1">* np.arctanh(z) / (l2 - l1)</span>
    <span class="s2">return </span><span class="s1">f12</span>


<span class="s2">def </span><span class="s1">_inverse_squaring_helper(T0</span><span class="s2">, </span><span class="s1">theta):</span>
    <span class="s0">&quot;&quot;&quot; 
    A helper function for inverse scaling and squaring for Pade approximation. 
 
    Parameters 
    ---------- 
    T0 : (N, N) array_like upper triangular 
        Matrix involved in inverse scaling and squaring. 
    theta : indexable 
        The values theta[1] .. theta[7] must be available. 
        They represent bounds related to Pade approximation, and they depend 
        on the matrix function which is being computed. 
        For example, different values of theta are required for 
        matrix logarithm than for fractional matrix power. 
 
    Returns 
    ------- 
    R : (N, N) array_like upper triangular 
        Composition of zero or more matrix square roots of T0, minus I. 
    s : non-negative integer 
        Number of square roots taken. 
    m : positive integer 
        The degree of the Pade approximation. 
 
    Notes 
    ----- 
    This subroutine appears as a chunk of lines within 
    a couple of published algorithms; for example it appears 
    as lines 4--35 in algorithm (3.1) of [1]_, and 
    as lines 3--34 in algorithm (4.1) of [2]_. 
    The instances of 'goto line 38' in algorithm (3.1) of [1]_ 
    probably mean 'goto line 36' and have been intepreted accordingly. 
 
    References 
    ---------- 
    .. [1] Nicholas J. Higham and Lijing Lin (2013) 
           &quot;An Improved Schur-Pade Algorithm for Fractional Powers 
           of a Matrix and their Frechet Derivatives.&quot; 
 
    .. [2] Awad H. Al-Mohy and Nicholas J. Higham (2012) 
           &quot;Improved Inverse Scaling and Squaring Algorithms 
           for the Matrix Logarithm.&quot; 
           SIAM Journal on Scientific Computing, 34 (4). C152-C169. 
           ISSN 1095-7197 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">len(T0.shape) != </span><span class="s4">2 </span><span class="s2">or </span><span class="s1">T0.shape[</span><span class="s4">0</span><span class="s1">] != T0.shape[</span><span class="s4">1</span><span class="s1">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'expected an upper triangular square matrix'</span><span class="s1">)</span>
    <span class="s1">n</span><span class="s2">, </span><span class="s1">n = T0.shape</span>
    <span class="s1">T = T0</span>

    <span class="s3"># Find s0, the smallest s such that the spectral radius</span>
    <span class="s3"># of a certain diagonal matrix is at most theta[7].</span>
    <span class="s3"># Note that because theta[7] &lt; 1,</span>
    <span class="s3"># this search will not terminate if any diagonal entry of T is zero.</span>
    <span class="s1">s0 = </span><span class="s4">0</span>
    <span class="s1">tmp_diag = np.diag(T)</span>
    <span class="s2">if </span><span class="s1">np.count_nonzero(tmp_diag) != n:</span>
        <span class="s2">raise </span><span class="s1">Exception(</span><span class="s5">'Diagonal entries of T must be nonzero'</span><span class="s1">)</span>
    <span class="s2">while </span><span class="s1">np.max(np.absolute(tmp_diag - </span><span class="s4">1</span><span class="s1">)) &gt; theta[</span><span class="s4">7</span><span class="s1">]:</span>
        <span class="s1">tmp_diag = np.sqrt(tmp_diag)</span>
        <span class="s1">s0 += </span><span class="s4">1</span>

    <span class="s3"># Take matrix square roots of T.</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(s0):</span>
        <span class="s1">T = _sqrtm_triu(T)</span>

    <span class="s3"># Flow control in this section is a little odd.</span>
    <span class="s3"># This is because I am translating algorithm descriptions</span>
    <span class="s3"># which have GOTOs in the publication.</span>
    <span class="s1">s = s0</span>
    <span class="s1">k = </span><span class="s4">0</span>
    <span class="s1">d2 = _onenormest_m1_power(T</span><span class="s2">, </span><span class="s4">2</span><span class="s1">) ** (</span><span class="s4">1</span><span class="s1">/</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">d3 = _onenormest_m1_power(T</span><span class="s2">, </span><span class="s4">3</span><span class="s1">) ** (</span><span class="s4">1</span><span class="s1">/</span><span class="s4">3</span><span class="s1">)</span>
    <span class="s1">a2 = max(d2</span><span class="s2">, </span><span class="s1">d3)</span>
    <span class="s1">m = </span><span class="s2">None</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">a2 &lt;= theta[i]:</span>
            <span class="s1">m = i</span>
            <span class="s2">break</span>
    <span class="s2">while </span><span class="s1">m </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">s &gt; s0:</span>
            <span class="s1">d3 = _onenormest_m1_power(T</span><span class="s2">, </span><span class="s4">3</span><span class="s1">) ** (</span><span class="s4">1</span><span class="s1">/</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">d4 = _onenormest_m1_power(T</span><span class="s2">, </span><span class="s4">4</span><span class="s1">) ** (</span><span class="s4">1</span><span class="s1">/</span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">a3 = max(d3</span><span class="s2">, </span><span class="s1">d4)</span>
        <span class="s2">if </span><span class="s1">a3 &lt;= theta[</span><span class="s4">7</span><span class="s1">]:</span>
            <span class="s1">j1 = min(i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">7</span><span class="s1">) </span><span class="s2">if </span><span class="s1">a3 &lt;= theta[i])</span>
            <span class="s2">if </span><span class="s1">j1 &lt;= </span><span class="s4">6</span><span class="s1">:</span>
                <span class="s1">m = j1</span>
                <span class="s2">break</span>
            <span class="s2">elif </span><span class="s1">a3 / </span><span class="s4">2 </span><span class="s1">&lt;= theta[</span><span class="s4">5</span><span class="s1">] </span><span class="s2">and </span><span class="s1">k &lt; </span><span class="s4">2</span><span class="s1">:</span>
                <span class="s1">k += </span><span class="s4">1</span>
                <span class="s1">T = _sqrtm_triu(T)</span>
                <span class="s1">s += </span><span class="s4">1</span>
                <span class="s2">continue</span>
        <span class="s1">d5 = _onenormest_m1_power(T</span><span class="s2">, </span><span class="s4">5</span><span class="s1">) ** (</span><span class="s4">1</span><span class="s1">/</span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">a4 = max(d4</span><span class="s2">, </span><span class="s1">d5)</span>
        <span class="s1">eta = min(a3</span><span class="s2">, </span><span class="s1">a4)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">(</span><span class="s4">6</span><span class="s2">, </span><span class="s4">7</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">eta &lt;= theta[i]:</span>
                <span class="s1">m = i</span>
                <span class="s2">break</span>
        <span class="s2">if </span><span class="s1">m </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">break</span>
        <span class="s1">T = _sqrtm_triu(T)</span>
        <span class="s1">s += </span><span class="s4">1</span>

    <span class="s3"># The subtraction of the identity is redundant here,</span>
    <span class="s3"># because the diagonal will be replaced for improved numerical accuracy,</span>
    <span class="s3"># but this formulation should help clarify the meaning of R.</span>
    <span class="s1">R = T - np.identity(n)</span>

    <span class="s3"># Replace the diagonal and first superdiagonal of T0^(1/(2^s)) - I</span>
    <span class="s3"># using formulas that have less subtractive cancellation.</span>
    <span class="s3"># Skip this step if the principal branch</span>
    <span class="s3"># does not exist at T0; this happens when a diagonal entry of T0</span>
    <span class="s3"># is negative with imaginary part 0.</span>
    <span class="s1">has_principal_branch = all(x.real &gt; </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">x.imag != </span><span class="s4">0 </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">np.diag(T0))</span>
    <span class="s2">if </span><span class="s1">has_principal_branch:</span>
        <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(n):</span>
            <span class="s1">a = T0[j</span><span class="s2">, </span><span class="s1">j]</span>
            <span class="s1">r = _briggs_helper_function(a</span><span class="s2">, </span><span class="s1">s)</span>
            <span class="s1">R[j</span><span class="s2">, </span><span class="s1">j] = r</span>
        <span class="s1">p = np.exp2(-s)</span>
        <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(n-</span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">l1 = T0[j</span><span class="s2">, </span><span class="s1">j]</span>
            <span class="s1">l2 = T0[j+</span><span class="s4">1</span><span class="s2">, </span><span class="s1">j+</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">t12 = T0[j</span><span class="s2">, </span><span class="s1">j+</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">f12 = _fractional_power_superdiag_entry(l1</span><span class="s2">, </span><span class="s1">l2</span><span class="s2">, </span><span class="s1">t12</span><span class="s2">, </span><span class="s1">p)</span>
            <span class="s1">R[j</span><span class="s2">, </span><span class="s1">j+</span><span class="s4">1</span><span class="s1">] = f12</span>

    <span class="s3"># Return the T-I matrix, the number of square roots, and the Pade degree.</span>
    <span class="s2">if not </span><span class="s1">np.array_equal(R</span><span class="s2">, </span><span class="s1">np.triu(R)):</span>
        <span class="s2">raise </span><span class="s1">Exception(</span><span class="s5">'R is not upper triangular'</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">R</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">m</span>


<span class="s2">def </span><span class="s1">_fractional_power_pade_constant(i</span><span class="s2">, </span><span class="s1">t):</span>
    <span class="s3"># A helper function for matrix fractional power.</span>
    <span class="s2">if </span><span class="s1">i &lt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'expected a positive integer i'</span><span class="s1">)</span>
    <span class="s2">if not </span><span class="s1">(-</span><span class="s4">1 </span><span class="s1">&lt; t &lt; </span><span class="s4">1</span><span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'expected -1 &lt; t &lt; 1'</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">i == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">-t</span>
    <span class="s2">elif </span><span class="s1">i % </span><span class="s4">2 </span><span class="s1">== </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">j = i // </span><span class="s4">2</span>
        <span class="s2">return </span><span class="s1">(-j + t) / (</span><span class="s4">2 </span><span class="s1">* (</span><span class="s4">2</span><span class="s1">*j - </span><span class="s4">1</span><span class="s1">))</span>
    <span class="s2">elif </span><span class="s1">i % </span><span class="s4">2 </span><span class="s1">== </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">j = (i - </span><span class="s4">1</span><span class="s1">) // </span><span class="s4">2</span>
        <span class="s2">return </span><span class="s1">(-j - t) / (</span><span class="s4">2 </span><span class="s1">* (</span><span class="s4">2</span><span class="s1">*j + </span><span class="s4">1</span><span class="s1">))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">Exception(</span><span class="s5">f'unnexpected value of i, i = </span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s5">'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_fractional_power_pade(R</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">m):</span>
    <span class="s0">&quot;&quot;&quot; 
    Evaluate the Pade approximation of a fractional matrix power. 
 
    Evaluate the degree-m Pade approximation of R 
    to the fractional matrix power t using the continued fraction 
    in bottom-up fashion using algorithm (4.1) in [1]_. 
 
    Parameters 
    ---------- 
    R : (N, N) array_like 
        Upper triangular matrix whose fractional power to evaluate. 
    t : float 
        Fractional power between -1 and 1 exclusive. 
    m : positive integer 
        Degree of Pade approximation. 
 
    Returns 
    ------- 
    U : (N, N) array_like 
        The degree-m Pade approximation of R to the fractional power t. 
        This matrix will be upper triangular. 
 
    References 
    ---------- 
    .. [1] Nicholas J. Higham and Lijing lin (2011) 
           &quot;A Schur-Pade Algorithm for Fractional Powers of a Matrix.&quot; 
           SIAM Journal on Matrix Analysis and Applications, 
           32 (3). pp. 1056-1078. ISSN 0895-4798 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">m &lt; </span><span class="s4">1 </span><span class="s2">or </span><span class="s1">int(m) != m:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'expected a positive integer m'</span><span class="s1">)</span>
    <span class="s2">if not </span><span class="s1">(-</span><span class="s4">1 </span><span class="s1">&lt; t &lt; </span><span class="s4">1</span><span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'expected -1 &lt; t &lt; 1'</span><span class="s1">)</span>
    <span class="s1">R = np.asarray(R)</span>
    <span class="s2">if </span><span class="s1">len(R.shape) != </span><span class="s4">2 </span><span class="s2">or </span><span class="s1">R.shape[</span><span class="s4">0</span><span class="s1">] != R.shape[</span><span class="s4">1</span><span class="s1">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'expected an upper triangular square matrix'</span><span class="s1">)</span>
    <span class="s1">n</span><span class="s2">, </span><span class="s1">n = R.shape</span>
    <span class="s1">ident = np.identity(n)</span>
    <span class="s1">Y = R * _fractional_power_pade_constant(</span><span class="s4">2</span><span class="s1">*m</span><span class="s2">, </span><span class="s1">t)</span>
    <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">2</span><span class="s1">*m - </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s1">rhs = R * _fractional_power_pade_constant(j</span><span class="s2">, </span><span class="s1">t)</span>
        <span class="s1">Y = solve_triangular(ident + Y</span><span class="s2">, </span><span class="s1">rhs)</span>
    <span class="s1">U = ident + Y</span>
    <span class="s2">if not </span><span class="s1">np.array_equal(U</span><span class="s2">, </span><span class="s1">np.triu(U)):</span>
        <span class="s2">raise </span><span class="s1">Exception(</span><span class="s5">'U is not upper triangular'</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">U</span>


<span class="s2">def </span><span class="s1">_remainder_matrix_power_triu(T</span><span class="s2">, </span><span class="s1">t):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute a fractional power of an upper triangular matrix. 
 
    The fractional power is restricted to fractions -1 &lt; t &lt; 1. 
    This uses algorithm (3.1) of [1]_. 
    The Pade approximation itself uses algorithm (4.1) of [2]_. 
 
    Parameters 
    ---------- 
    T : (N, N) array_like 
        Upper triangular matrix whose fractional power to evaluate. 
    t : float 
        Fractional power between -1 and 1 exclusive. 
 
    Returns 
    ------- 
    X : (N, N) array_like 
        The fractional power of the matrix. 
 
    References 
    ---------- 
    .. [1] Nicholas J. Higham and Lijing Lin (2013) 
           &quot;An Improved Schur-Pade Algorithm for Fractional Powers 
           of a Matrix and their Frechet Derivatives.&quot; 
 
    .. [2] Nicholas J. Higham and Lijing lin (2011) 
           &quot;A Schur-Pade Algorithm for Fractional Powers of a Matrix.&quot; 
           SIAM Journal on Matrix Analysis and Applications, 
           32 (3). pp. 1056-1078. ISSN 0895-4798 
 
    &quot;&quot;&quot;</span>
    <span class="s1">m_to_theta = {</span>
            <span class="s4">1</span><span class="s1">: </span><span class="s4">1.51e-5</span><span class="s2">,</span>
            <span class="s4">2</span><span class="s1">: </span><span class="s4">2.24e-3</span><span class="s2">,</span>
            <span class="s4">3</span><span class="s1">: </span><span class="s4">1.88e-2</span><span class="s2">,</span>
            <span class="s4">4</span><span class="s1">: </span><span class="s4">6.04e-2</span><span class="s2">,</span>
            <span class="s4">5</span><span class="s1">: </span><span class="s4">1.24e-1</span><span class="s2">,</span>
            <span class="s4">6</span><span class="s1">: </span><span class="s4">2.00e-1</span><span class="s2">,</span>
            <span class="s4">7</span><span class="s1">: </span><span class="s4">2.79e-1</span><span class="s2">,</span>
            <span class="s1">}</span>
    <span class="s1">n</span><span class="s2">, </span><span class="s1">n = T.shape</span>
    <span class="s1">T0 = T</span>
    <span class="s1">T0_diag = np.diag(T0)</span>
    <span class="s2">if </span><span class="s1">np.array_equal(T0</span><span class="s2">, </span><span class="s1">np.diag(T0_diag)):</span>
        <span class="s1">U = np.diag(T0_diag ** t)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">R</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">m = _inverse_squaring_helper(T0</span><span class="s2">, </span><span class="s1">m_to_theta)</span>

        <span class="s3"># Evaluate the Pade approximation.</span>
        <span class="s3"># Note that this function expects the negative of the matrix</span>
        <span class="s3"># returned by the inverse squaring helper.</span>
        <span class="s1">U = _fractional_power_pade(-R</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">m)</span>

        <span class="s3"># Undo the inverse scaling and squaring.</span>
        <span class="s3"># Be less clever about this</span>
        <span class="s3"># if the principal branch does not exist at T0;</span>
        <span class="s3"># this happens when a diagonal entry of T0</span>
        <span class="s3"># is negative with imaginary part 0.</span>
        <span class="s1">eivals = np.diag(T0)</span>
        <span class="s1">has_principal_branch = all(x.real &gt; </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">x.imag != </span><span class="s4">0 </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">eivals)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(s</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">i &lt; s:</span>
                <span class="s1">U = U.dot(U)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">has_principal_branch:</span>
                    <span class="s1">p = t * np.exp2(-i)</span>
                    <span class="s1">U[np.diag_indices(n)] = T0_diag ** p</span>
                    <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(n-</span><span class="s4">1</span><span class="s1">):</span>
                        <span class="s1">l1 = T0[j</span><span class="s2">, </span><span class="s1">j]</span>
                        <span class="s1">l2 = T0[j+</span><span class="s4">1</span><span class="s2">, </span><span class="s1">j+</span><span class="s4">1</span><span class="s1">]</span>
                        <span class="s1">t12 = T0[j</span><span class="s2">, </span><span class="s1">j+</span><span class="s4">1</span><span class="s1">]</span>
                        <span class="s1">f12 = _fractional_power_superdiag_entry(l1</span><span class="s2">, </span><span class="s1">l2</span><span class="s2">, </span><span class="s1">t12</span><span class="s2">, </span><span class="s1">p)</span>
                        <span class="s1">U[j</span><span class="s2">, </span><span class="s1">j+</span><span class="s4">1</span><span class="s1">] = f12</span>
    <span class="s2">if not </span><span class="s1">np.array_equal(U</span><span class="s2">, </span><span class="s1">np.triu(U)):</span>
        <span class="s2">raise </span><span class="s1">Exception(</span><span class="s5">'U is not upper triangular'</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">U</span>


<span class="s2">def </span><span class="s1">_remainder_matrix_power(A</span><span class="s2">, </span><span class="s1">t):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the fractional power of a matrix, for fractions -1 &lt; t &lt; 1. 
 
    This uses algorithm (3.1) of [1]_. 
    The Pade approximation itself uses algorithm (4.1) of [2]_. 
 
    Parameters 
    ---------- 
    A : (N, N) array_like 
        Matrix whose fractional power to evaluate. 
    t : float 
        Fractional power between -1 and 1 exclusive. 
 
    Returns 
    ------- 
    X : (N, N) array_like 
        The fractional power of the matrix. 
 
    References 
    ---------- 
    .. [1] Nicholas J. Higham and Lijing Lin (2013) 
           &quot;An Improved Schur-Pade Algorithm for Fractional Powers 
           of a Matrix and their Frechet Derivatives.&quot; 
 
    .. [2] Nicholas J. Higham and Lijing lin (2011) 
           &quot;A Schur-Pade Algorithm for Fractional Powers of a Matrix.&quot; 
           SIAM Journal on Matrix Analysis and Applications, 
           32 (3). pp. 1056-1078. ISSN 0895-4798 
 
    &quot;&quot;&quot;</span>
    <span class="s3"># This code block is copied from numpy.matrix_power().</span>
    <span class="s1">A = np.asarray(A)</span>
    <span class="s2">if </span><span class="s1">len(A.shape) != </span><span class="s4">2 </span><span class="s2">or </span><span class="s1">A.shape[</span><span class="s4">0</span><span class="s1">] != A.shape[</span><span class="s4">1</span><span class="s1">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'input must be a square array'</span><span class="s1">)</span>

    <span class="s3"># Get the number of rows and columns.</span>
    <span class="s1">n</span><span class="s2">, </span><span class="s1">n = A.shape</span>

    <span class="s3"># Triangularize the matrix if necessary,</span>
    <span class="s3"># attempting to preserve dtype if possible.</span>
    <span class="s2">if </span><span class="s1">np.array_equal(A</span><span class="s2">, </span><span class="s1">np.triu(A)):</span>
        <span class="s1">Z = </span><span class="s2">None</span>
        <span class="s1">T = A</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">np.isrealobj(A):</span>
            <span class="s1">T</span><span class="s2">, </span><span class="s1">Z = schur(A)</span>
            <span class="s2">if not </span><span class="s1">np.array_equal(T</span><span class="s2">, </span><span class="s1">np.triu(T)):</span>
                <span class="s1">T</span><span class="s2">, </span><span class="s1">Z = rsf2csf(T</span><span class="s2">, </span><span class="s1">Z)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">T</span><span class="s2">, </span><span class="s1">Z = schur(A</span><span class="s2">, </span><span class="s1">output=</span><span class="s5">'complex'</span><span class="s1">)</span>

    <span class="s3"># Zeros on the diagonal of the triangular matrix are forbidden,</span>
    <span class="s3"># because the inverse scaling and squaring cannot deal with it.</span>
    <span class="s1">T_diag = np.diag(T)</span>
    <span class="s2">if </span><span class="s1">np.count_nonzero(T_diag) != n:</span>
        <span class="s2">raise </span><span class="s1">FractionalMatrixPowerError(</span>
                <span class="s5">'cannot use inverse scaling and squaring to find '</span>
                <span class="s5">'the fractional matrix power of a singular matrix'</span><span class="s1">)</span>

    <span class="s3"># If the triangular matrix is real and has a negative</span>
    <span class="s3"># entry on the diagonal, then force the matrix to be complex.</span>
    <span class="s2">if </span><span class="s1">np.isrealobj(T) </span><span class="s2">and </span><span class="s1">np.min(T_diag) &lt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">T = T.astype(complex)</span>

    <span class="s3"># Get the fractional power of the triangular matrix,</span>
    <span class="s3"># and de-triangularize it if necessary.</span>
    <span class="s1">U = _remainder_matrix_power_triu(T</span><span class="s2">, </span><span class="s1">t)</span>
    <span class="s2">if </span><span class="s1">Z </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">ZH = np.conjugate(Z).T</span>
        <span class="s2">return </span><span class="s1">Z.dot(U).dot(ZH)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">U</span>


<span class="s2">def </span><span class="s1">_fractional_matrix_power(A</span><span class="s2">, </span><span class="s1">p):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the fractional power of a matrix. 
 
    See the fractional_matrix_power docstring in matfuncs.py for more info. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">A = np.asarray(A)</span>
    <span class="s2">if </span><span class="s1">len(A.shape) != </span><span class="s4">2 </span><span class="s2">or </span><span class="s1">A.shape[</span><span class="s4">0</span><span class="s1">] != A.shape[</span><span class="s4">1</span><span class="s1">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'expected a square matrix'</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">p == int(p):</span>
        <span class="s2">return </span><span class="s1">np.linalg.matrix_power(A</span><span class="s2">, </span><span class="s1">int(p))</span>
    <span class="s3"># Compute singular values.</span>
    <span class="s1">s = svdvals(A)</span>
    <span class="s3"># Inverse scaling and squaring cannot deal with a singular matrix,</span>
    <span class="s3"># because the process of repeatedly taking square roots</span>
    <span class="s3"># would not converge to the identity matrix.</span>
    <span class="s2">if </span><span class="s1">s[-</span><span class="s4">1</span><span class="s1">]:</span>
        <span class="s3"># Compute the condition number relative to matrix inversion,</span>
        <span class="s3"># and use this to decide between floor(p) and ceil(p).</span>
        <span class="s1">k2 = s[</span><span class="s4">0</span><span class="s1">] / s[-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">p1 = p - np.floor(p)</span>
        <span class="s1">p2 = p - np.ceil(p)</span>
        <span class="s2">if </span><span class="s1">p1 * k2 ** (</span><span class="s4">1 </span><span class="s1">- p1) &lt;= -p2 * k2:</span>
            <span class="s1">a = int(np.floor(p))</span>
            <span class="s1">b = p1</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">a = int(np.ceil(p))</span>
            <span class="s1">b = p2</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">R = _remainder_matrix_power(A</span><span class="s2">, </span><span class="s1">b)</span>
            <span class="s1">Q = np.linalg.matrix_power(A</span><span class="s2">, </span><span class="s1">a)</span>
            <span class="s2">return </span><span class="s1">Q.dot(R)</span>
        <span class="s2">except </span><span class="s1">np.linalg.LinAlgError:</span>
            <span class="s2">pass</span>
    <span class="s3"># If p is negative then we are going to give up.</span>
    <span class="s3"># If p is non-negative then we can fall back to generic funm.</span>
    <span class="s2">if </span><span class="s1">p &lt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">X = np.empty_like(A)</span>
        <span class="s1">X.fill(np.nan)</span>
        <span class="s2">return </span><span class="s1">X</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">p1 = p - np.floor(p)</span>
        <span class="s1">a = int(np.floor(p))</span>
        <span class="s1">b = p1</span>
        <span class="s1">R</span><span class="s2">, </span><span class="s1">info = funm(A</span><span class="s2">, lambda </span><span class="s1">x: pow(x</span><span class="s2">, </span><span class="s1">b)</span><span class="s2">, </span><span class="s1">disp=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">Q = np.linalg.matrix_power(A</span><span class="s2">, </span><span class="s1">a)</span>
        <span class="s2">return </span><span class="s1">Q.dot(R)</span>


<span class="s2">def </span><span class="s1">_logm_triu(T):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute matrix logarithm of an upper triangular matrix. 
 
    The matrix logarithm is the inverse of 
    expm: expm(logm(`T`)) == `T` 
 
    Parameters 
    ---------- 
    T : (N, N) array_like 
        Upper triangular matrix whose logarithm to evaluate 
 
    Returns 
    ------- 
    logm : (N, N) ndarray 
        Matrix logarithm of `T` 
 
    References 
    ---------- 
    .. [1] Awad H. Al-Mohy and Nicholas J. Higham (2012) 
           &quot;Improved Inverse Scaling and Squaring Algorithms 
           for the Matrix Logarithm.&quot; 
           SIAM Journal on Scientific Computing, 34 (4). C152-C169. 
           ISSN 1095-7197 
 
    .. [2] Nicholas J. Higham (2008) 
           &quot;Functions of Matrices: Theory and Computation&quot; 
           ISBN 978-0-898716-46-7 
 
    .. [3] Nicholas J. Higham and Lijing lin (2011) 
           &quot;A Schur-Pade Algorithm for Fractional Powers of a Matrix.&quot; 
           SIAM Journal on Matrix Analysis and Applications, 
           32 (3). pp. 1056-1078. ISSN 0895-4798 
 
    &quot;&quot;&quot;</span>
    <span class="s1">T = np.asarray(T)</span>
    <span class="s2">if </span><span class="s1">len(T.shape) != </span><span class="s4">2 </span><span class="s2">or </span><span class="s1">T.shape[</span><span class="s4">0</span><span class="s1">] != T.shape[</span><span class="s4">1</span><span class="s1">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'expected an upper triangular square matrix'</span><span class="s1">)</span>
    <span class="s1">n</span><span class="s2">, </span><span class="s1">n = T.shape</span>

    <span class="s3"># Construct T0 with the appropriate type,</span>
    <span class="s3"># depending on the dtype and the spectrum of T.</span>
    <span class="s1">T_diag = np.diag(T)</span>
    <span class="s1">keep_it_real = np.isrealobj(T) </span><span class="s2">and </span><span class="s1">np.min(T_diag) &gt;= </span><span class="s4">0</span>
    <span class="s2">if </span><span class="s1">keep_it_real:</span>
        <span class="s1">T0 = T</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">T0 = T.astype(complex)</span>

    <span class="s3"># Define bounds given in Table (2.1).</span>
    <span class="s1">theta = (</span><span class="s2">None,</span>
            <span class="s4">1.59e-5</span><span class="s2">, </span><span class="s4">2.31e-3</span><span class="s2">, </span><span class="s4">1.94e-2</span><span class="s2">, </span><span class="s4">6.21e-2</span><span class="s2">,</span>
            <span class="s4">1.28e-1</span><span class="s2">, </span><span class="s4">2.06e-1</span><span class="s2">, </span><span class="s4">2.88e-1</span><span class="s2">, </span><span class="s4">3.67e-1</span><span class="s2">,</span>
            <span class="s4">4.39e-1</span><span class="s2">, </span><span class="s4">5.03e-1</span><span class="s2">, </span><span class="s4">5.60e-1</span><span class="s2">, </span><span class="s4">6.09e-1</span><span class="s2">,</span>
            <span class="s4">6.52e-1</span><span class="s2">, </span><span class="s4">6.89e-1</span><span class="s2">, </span><span class="s4">7.21e-1</span><span class="s2">, </span><span class="s4">7.49e-1</span><span class="s1">)</span>

    <span class="s1">R</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">m = _inverse_squaring_helper(T0</span><span class="s2">, </span><span class="s1">theta)</span>

    <span class="s3"># Evaluate U = 2**s r_m(T - I) using the partial fraction expansion (1.1).</span>
    <span class="s3"># This requires the nodes and weights</span>
    <span class="s3"># corresponding to degree-m Gauss-Legendre quadrature.</span>
    <span class="s3"># These quadrature arrays need to be transformed from the [-1, 1] interval</span>
    <span class="s3"># to the [0, 1] interval.</span>
    <span class="s1">nodes</span><span class="s2">, </span><span class="s1">weights = scipy.special.p_roots(m)</span>
    <span class="s1">nodes = nodes.real</span>
    <span class="s2">if </span><span class="s1">nodes.shape != (m</span><span class="s2">,</span><span class="s1">) </span><span class="s2">or </span><span class="s1">weights.shape != (m</span><span class="s2">,</span><span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">Exception(</span><span class="s5">'internal error'</span><span class="s1">)</span>
    <span class="s1">nodes = </span><span class="s4">0.5 </span><span class="s1">+ </span><span class="s4">0.5 </span><span class="s1">* nodes</span>
    <span class="s1">weights = </span><span class="s4">0.5 </span><span class="s1">* weights</span>
    <span class="s1">ident = np.identity(n)</span>
    <span class="s1">U = np.zeros_like(R)</span>
    <span class="s2">for </span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">beta </span><span class="s2">in </span><span class="s1">zip(weights</span><span class="s2">, </span><span class="s1">nodes):</span>
        <span class="s1">U += solve_triangular(ident + beta*R</span><span class="s2">, </span><span class="s1">alpha*R)</span>
    <span class="s1">U *= np.exp2(s)</span>

    <span class="s3"># Skip this step if the principal branch</span>
    <span class="s3"># does not exist at T0; this happens when a diagonal entry of T0</span>
    <span class="s3"># is negative with imaginary part 0.</span>
    <span class="s1">has_principal_branch = all(x.real &gt; </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">x.imag != </span><span class="s4">0 </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">np.diag(T0))</span>
    <span class="s2">if </span><span class="s1">has_principal_branch:</span>

        <span class="s3"># Recompute diagonal entries of U.</span>
        <span class="s1">U[np.diag_indices(n)] = np.log(np.diag(T0))</span>

        <span class="s3"># Recompute superdiagonal entries of U.</span>
        <span class="s3"># This indexing of this code should be renovated</span>
        <span class="s3"># when newer np.diagonal() becomes available.</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(n-</span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">l1 = T0[i</span><span class="s2">, </span><span class="s1">i]</span>
            <span class="s1">l2 = T0[i+</span><span class="s4">1</span><span class="s2">, </span><span class="s1">i+</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">t12 = T0[i</span><span class="s2">, </span><span class="s1">i+</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">U[i</span><span class="s2">, </span><span class="s1">i+</span><span class="s4">1</span><span class="s1">] = _logm_superdiag_entry(l1</span><span class="s2">, </span><span class="s1">l2</span><span class="s2">, </span><span class="s1">t12)</span>

    <span class="s3"># Return the logm of the upper triangular matrix.</span>
    <span class="s2">if not </span><span class="s1">np.array_equal(U</span><span class="s2">, </span><span class="s1">np.triu(U)):</span>
        <span class="s2">raise </span><span class="s1">Exception(</span><span class="s5">'U is not upper triangular'</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">U</span>


<span class="s2">def </span><span class="s1">_logm_force_nonsingular_triangular_matrix(T</span><span class="s2">, </span><span class="s1">inplace=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s3"># The input matrix should be upper triangular.</span>
    <span class="s3"># The eps is ad hoc and is not meant to be machine precision.</span>
    <span class="s1">tri_eps = </span><span class="s4">1e-20</span>
    <span class="s1">abs_diag = np.absolute(np.diag(T))</span>
    <span class="s2">if </span><span class="s1">np.any(abs_diag == </span><span class="s4">0</span><span class="s1">):</span>
        <span class="s1">exact_singularity_msg = </span><span class="s5">'The logm input matrix is exactly singular.'</span>
        <span class="s1">warnings.warn(exact_singularity_msg</span><span class="s2">, </span><span class="s1">LogmExactlySingularWarning)</span>
        <span class="s2">if not </span><span class="s1">inplace:</span>
            <span class="s1">T = T.copy()</span>
        <span class="s1">n = T.shape[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(n):</span>
            <span class="s2">if not </span><span class="s1">T[i</span><span class="s2">, </span><span class="s1">i]:</span>
                <span class="s1">T[i</span><span class="s2">, </span><span class="s1">i] = tri_eps</span>
    <span class="s2">elif </span><span class="s1">np.any(abs_diag &lt; tri_eps):</span>
        <span class="s1">near_singularity_msg = </span><span class="s5">'The logm input matrix may be nearly singular.'</span>
        <span class="s1">warnings.warn(near_singularity_msg</span><span class="s2">, </span><span class="s1">LogmNearlySingularWarning)</span>
    <span class="s2">return </span><span class="s1">T</span>


<span class="s2">def </span><span class="s1">_logm(A):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the matrix logarithm. 
 
    See the logm docstring in matfuncs.py for more info. 
 
    Notes 
    ----- 
    In this function we look at triangular matrices that are similar 
    to the input matrix. If any diagonal entry of such a triangular matrix 
    is exactly zero then the original matrix is singular. 
    The matrix logarithm does not exist for such matrices, 
    but in such cases we will pretend that the diagonal entries that are zero 
    are actually slightly positive by an ad-hoc amount, in the interest 
    of returning something more useful than NaN. This will cause a warning. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">A = np.asarray(A)</span>
    <span class="s2">if </span><span class="s1">len(A.shape) != </span><span class="s4">2 </span><span class="s2">or </span><span class="s1">A.shape[</span><span class="s4">0</span><span class="s1">] != A.shape[</span><span class="s4">1</span><span class="s1">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'expected a square matrix'</span><span class="s1">)</span>

    <span class="s3"># If the input matrix dtype is integer then copy to a float dtype matrix.</span>
    <span class="s2">if </span><span class="s1">issubclass(A.dtype.type</span><span class="s2">, </span><span class="s1">np.integer):</span>
        <span class="s1">A = np.asarray(A</span><span class="s2">, </span><span class="s1">dtype=float)</span>

    <span class="s1">keep_it_real = np.isrealobj(A)</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">np.array_equal(A</span><span class="s2">, </span><span class="s1">np.triu(A)):</span>
            <span class="s1">A = _logm_force_nonsingular_triangular_matrix(A)</span>
            <span class="s2">if </span><span class="s1">np.min(np.diag(A)) &lt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">A = A.astype(complex)</span>
            <span class="s2">return </span><span class="s1">_logm_triu(A)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">keep_it_real:</span>
                <span class="s1">T</span><span class="s2">, </span><span class="s1">Z = schur(A)</span>
                <span class="s2">if not </span><span class="s1">np.array_equal(T</span><span class="s2">, </span><span class="s1">np.triu(T)):</span>
                    <span class="s1">T</span><span class="s2">, </span><span class="s1">Z = rsf2csf(T</span><span class="s2">, </span><span class="s1">Z)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">T</span><span class="s2">, </span><span class="s1">Z = schur(A</span><span class="s2">, </span><span class="s1">output=</span><span class="s5">'complex'</span><span class="s1">)</span>
            <span class="s1">T = _logm_force_nonsingular_triangular_matrix(T</span><span class="s2">, </span><span class="s1">inplace=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">U = _logm_triu(T)</span>
            <span class="s1">ZH = np.conjugate(Z).T</span>
            <span class="s2">return </span><span class="s1">Z.dot(U).dot(ZH)</span>
    <span class="s2">except </span><span class="s1">(SqrtmError</span><span class="s2">, </span><span class="s1">LogmError):</span>
        <span class="s1">X = np.empty_like(A)</span>
        <span class="s1">X.fill(np.nan)</span>
        <span class="s2">return </span><span class="s1">X</span>
</pre>
</body>
</html>