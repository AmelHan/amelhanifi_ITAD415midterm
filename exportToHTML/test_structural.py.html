<html>
<head>
<title>test_structural.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_structural.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Tests for structural time series models 
 
Author: Chad Fulton 
License: Simplified-BSD 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">assert_equal</span><span class="s2">, </span><span class="s1">assert_allclose</span><span class="s2">, </span><span class="s1">assert_raises</span>
<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">from </span><span class="s1">statsmodels.datasets </span><span class="s2">import </span><span class="s1">macrodata</span>
<span class="s2">from </span><span class="s1">statsmodels.tools.sm_exceptions </span><span class="s2">import </span><span class="s1">SpecificationWarning</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace </span><span class="s2">import </span><span class="s1">structural</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace.structural </span><span class="s2">import </span><span class="s1">UnobservedComponents</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace.tests.results </span><span class="s2">import </span><span class="s1">results_structural</span>

<span class="s1">dta = macrodata.load_pandas().data</span>
<span class="s1">dta.index = pd.date_range(start=</span><span class="s3">'1959-01-01'</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2009-07-01'</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'QS'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">run_ucm(name</span><span class="s2">, </span><span class="s1">use_exact_diffuse=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s1">true = getattr(results_structural</span><span class="s2">, </span><span class="s1">name)</span>

    <span class="s2">for </span><span class="s1">model </span><span class="s2">in </span><span class="s1">true[</span><span class="s3">'models'</span><span class="s1">]:</span>
        <span class="s1">kwargs = model.copy()</span>
        <span class="s1">kwargs.update(true[</span><span class="s3">'kwargs'</span><span class="s1">])</span>
        <span class="s1">kwargs[</span><span class="s3">'use_exact_diffuse'</span><span class="s1">] = use_exact_diffuse</span>

        <span class="s4"># Make a copy of the data</span>
        <span class="s1">values = dta.copy()</span>

        <span class="s1">freq = kwargs.pop(</span><span class="s3">'freq'</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">freq </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">values.index = pd.date_range(start=</span><span class="s3">'1959-01-01'</span><span class="s2">, </span><span class="s1">periods=len(dta)</span><span class="s2">,</span>
                                         <span class="s1">freq=freq)</span>

        <span class="s4"># Test pandas exog</span>
        <span class="s2">if </span><span class="s3">'exog' </span><span class="s2">in </span><span class="s1">kwargs:</span>
            <span class="s4"># Default value here is pd.Series object</span>
            <span class="s1">exog = np.log(values[</span><span class="s3">'realgdp'</span><span class="s1">])</span>

            <span class="s4"># Also allow a check with a 1-dim numpy array</span>
            <span class="s2">if </span><span class="s1">kwargs[</span><span class="s3">'exog'</span><span class="s1">] == </span><span class="s3">'numpy'</span><span class="s1">:</span>
                <span class="s1">exog = exog.values.squeeze()</span>

            <span class="s1">kwargs[</span><span class="s3">'exog'</span><span class="s1">] = exog</span>

        <span class="s4"># Create the model</span>
        <span class="s1">mod = UnobservedComponents(values[</span><span class="s3">'unemp'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s4"># Smoke test for starting parameters, untransform, transform</span>
        <span class="s4"># Also test that transform and untransform are inverses</span>
        <span class="s1">mod.start_params</span>
        <span class="s1">roundtrip = mod.transform_params(</span>
            <span class="s1">mod.untransform_params(mod.start_params))</span>
        <span class="s1">assert_allclose(mod.start_params</span><span class="s2">, </span><span class="s1">roundtrip)</span>

        <span class="s4"># Fit the model at the true parameters</span>
        <span class="s1">res_true = mod.filter(true[</span><span class="s3">'params'</span><span class="s1">])</span>

        <span class="s4"># Check that the cycle bounds were computed correctly</span>
        <span class="s1">freqstr = freq[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">if </span><span class="s1">freq </span><span class="s2">is not None else </span><span class="s1">values.index.freqstr[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s3">'cycle_period_bounds' </span><span class="s2">in </span><span class="s1">kwargs:</span>
            <span class="s1">cycle_period_bounds = kwargs[</span><span class="s3">'cycle_period_bounds'</span><span class="s1">]</span>
        <span class="s2">elif </span><span class="s1">freqstr == </span><span class="s3">'A'</span><span class="s1">:</span>
            <span class="s1">cycle_period_bounds = (</span><span class="s5">1.5</span><span class="s2">, </span><span class="s5">12</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">freqstr == </span><span class="s3">'Q'</span><span class="s1">:</span>
            <span class="s1">cycle_period_bounds = (</span><span class="s5">1.5</span><span class="s1">*</span><span class="s5">4</span><span class="s2">, </span><span class="s5">12</span><span class="s1">*</span><span class="s5">4</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">freqstr == </span><span class="s3">'M'</span><span class="s1">:</span>
            <span class="s1">cycle_period_bounds = (</span><span class="s5">1.5</span><span class="s1">*</span><span class="s5">12</span><span class="s2">, </span><span class="s5">12</span><span class="s1">*</span><span class="s5">12</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># If we have no information on data frequency, require the</span>
            <span class="s4"># cycle frequency to be between 0 and pi</span>
            <span class="s1">cycle_period_bounds = (</span><span class="s5">2</span><span class="s2">, </span><span class="s1">np.inf)</span>

        <span class="s4"># Test that the cycle frequency bound is correct</span>
        <span class="s1">assert_equal(mod.cycle_frequency_bound</span><span class="s2">,</span>
                     <span class="s1">(</span><span class="s5">2</span><span class="s1">*np.pi / cycle_period_bounds[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s5">2</span><span class="s1">*np.pi / cycle_period_bounds[</span><span class="s5">0</span><span class="s1">]))</span>

        <span class="s4"># Test that the likelihood is correct</span>
        <span class="s1">rtol = true.get(</span><span class="s3">'rtol'</span><span class="s2">, </span><span class="s5">1e-7</span><span class="s1">)</span>
        <span class="s1">atol = true.get(</span><span class="s3">'atol'</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">use_exact_diffuse:</span>
            <span class="s4"># If we are using exact diffuse initialization, then we need to</span>
            <span class="s4"># adjust for the fact that KFAS does not include the constant in</span>
            <span class="s4"># the likelihood function for the diffuse periods</span>
            <span class="s4"># (see note to test_exact_diffuse_filtering.py for details).</span>
            <span class="s1">res_llf = (res_true.llf_obs.sum()</span>
                       <span class="s1">+ res_true.nobs_diffuse * </span><span class="s5">0.5 </span><span class="s1">* np.log(</span><span class="s5">2 </span><span class="s1">* np.pi))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># If we are using approximate diffuse initialization, then we need</span>
            <span class="s4"># to ignore the first period, and this will agree with KFAS (since</span>
            <span class="s4"># it does not include the constant in the likelihood function for</span>
            <span class="s4"># diffuse periods).</span>
            <span class="s1">res_llf = res_true.llf_obs[res_true.loglikelihood_burn:].sum()</span>

        <span class="s1">assert_allclose(res_llf</span><span class="s2">, </span><span class="s1">true[</span><span class="s3">'llf'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rtol=rtol</span><span class="s2">, </span><span class="s1">atol=atol)</span>

        <span class="s4"># Optional smoke test for plot_components</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">import </span><span class="s1">matplotlib.pyplot </span><span class="s2">as </span><span class="s1">plt</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">from </span><span class="s1">pandas.plotting </span><span class="s2">import </span><span class="s1">register_matplotlib_converters</span>
                <span class="s1">register_matplotlib_converters()</span>
            <span class="s2">except </span><span class="s1">ImportError:</span>
                <span class="s2">pass</span>
            <span class="s1">fig = plt.figure()</span>
            <span class="s1">res_true.plot_components(fig=fig)</span>
        <span class="s2">except </span><span class="s1">ImportError:</span>
            <span class="s2">pass</span>

        <span class="s4"># Now fit the model via MLE</span>
        <span class="s2">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s2">True</span><span class="s1">):</span>
            <span class="s1">fit_kwargs = {}</span>
            <span class="s2">if </span><span class="s3">'maxiter' </span><span class="s2">in </span><span class="s1">true:</span>
                <span class="s1">fit_kwargs[</span><span class="s3">'maxiter'</span><span class="s1">] = true[</span><span class="s3">'maxiter'</span><span class="s1">]</span>
            <span class="s1">res = mod.fit(start_params=true.get(</span><span class="s3">'start_params'</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">disp=-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">**fit_kwargs)</span>
            <span class="s4"># If we found a higher likelihood, no problem; otherwise check</span>
            <span class="s4"># that we're very close to that found by R</span>

            <span class="s4"># See note above about these computation</span>
            <span class="s2">if </span><span class="s1">use_exact_diffuse:</span>
                <span class="s1">res_llf = (res.llf_obs.sum()</span>
                           <span class="s1">+ res.nobs_diffuse * </span><span class="s5">0.5 </span><span class="s1">* np.log(</span><span class="s5">2 </span><span class="s1">* np.pi))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">res_llf = res.llf_obs[res_true.loglikelihood_burn:].sum()</span>

            <span class="s2">if </span><span class="s1">res_llf &lt;= true[</span><span class="s3">'llf'</span><span class="s1">]:</span>
                <span class="s1">assert_allclose(res_llf</span><span class="s2">, </span><span class="s1">true[</span><span class="s3">'llf'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-4</span><span class="s1">)</span>

            <span class="s4"># Smoke test for summary</span>
            <span class="s1">res.summary()</span>


<span class="s2">def </span><span class="s1">test_irregular(close_figures):</span>
    <span class="s1">run_ucm(</span><span class="s3">'irregular'</span><span class="s1">)</span>
    <span class="s1">run_ucm(</span><span class="s3">'irregular'</span><span class="s2">, </span><span class="s1">use_exact_diffuse=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_fixed_intercept(close_figures):</span>
    <span class="s4"># Clear warnings</span>
    <span class="s1">structural.__warningregistry__ = {}</span>
    <span class="s1">warning = SpecificationWarning</span>
    <span class="s1">match = </span><span class="s3">'Specified model does not contain'</span>
    <span class="s2">with </span><span class="s1">pytest.warns(warning</span><span class="s2">, </span><span class="s1">match=match):</span>
        <span class="s1">run_ucm(</span><span class="s3">'fixed_intercept'</span><span class="s1">)</span>
        <span class="s1">run_ucm(</span><span class="s3">'fixed_intercept'</span><span class="s2">, </span><span class="s1">use_exact_diffuse=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_deterministic_constant(close_figures):</span>
    <span class="s1">run_ucm(</span><span class="s3">'deterministic_constant'</span><span class="s1">)</span>
    <span class="s1">run_ucm(</span><span class="s3">'deterministic_constant'</span><span class="s2">, </span><span class="s1">use_exact_diffuse=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_random_walk(close_figures):</span>
    <span class="s1">run_ucm(</span><span class="s3">'random_walk'</span><span class="s1">)</span>
    <span class="s1">run_ucm(</span><span class="s3">'random_walk'</span><span class="s2">, </span><span class="s1">use_exact_diffuse=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_local_level(close_figures):</span>
    <span class="s1">run_ucm(</span><span class="s3">'local_level'</span><span class="s1">)</span>
    <span class="s1">run_ucm(</span><span class="s3">'local_level'</span><span class="s2">, </span><span class="s1">use_exact_diffuse=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_fixed_slope(close_figures):</span>
    <span class="s1">warning = SpecificationWarning</span>
    <span class="s1">match = </span><span class="s3">'irregular component added'</span>
    <span class="s2">with </span><span class="s1">pytest.warns(warning</span><span class="s2">, </span><span class="s1">match=match):</span>
        <span class="s1">run_ucm(</span><span class="s3">'fixed_slope'</span><span class="s1">)</span>
        <span class="s1">run_ucm(</span><span class="s3">'fixed_slope'</span><span class="s2">, </span><span class="s1">use_exact_diffuse=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_fixed_slope_warn(close_figures):</span>
    <span class="s4"># Clear warnings</span>
    <span class="s1">structural.__warningregistry__ = {}</span>

    <span class="s1">warning = SpecificationWarning</span>
    <span class="s1">match = </span><span class="s3">'irregular component added'</span>
    <span class="s2">with </span><span class="s1">pytest.warns(warning</span><span class="s2">, </span><span class="s1">match=match):</span>
        <span class="s1">run_ucm(</span><span class="s3">'fixed_slope'</span><span class="s1">)</span>
        <span class="s1">run_ucm(</span><span class="s3">'fixed_slope'</span><span class="s2">, </span><span class="s1">use_exact_diffuse=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_deterministic_trend(close_figures):</span>
    <span class="s1">run_ucm(</span><span class="s3">'deterministic_trend'</span><span class="s1">)</span>
    <span class="s1">run_ucm(</span><span class="s3">'deterministic_trend'</span><span class="s2">, </span><span class="s1">use_exact_diffuse=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_random_walk_with_drift(close_figures):</span>
    <span class="s1">run_ucm(</span><span class="s3">'random_walk_with_drift'</span><span class="s1">)</span>
    <span class="s1">run_ucm(</span><span class="s3">'random_walk_with_drift'</span><span class="s2">, </span><span class="s1">use_exact_diffuse=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_local_linear_deterministic_trend(close_figures):</span>
    <span class="s1">run_ucm(</span><span class="s3">'local_linear_deterministic_trend'</span><span class="s1">)</span>
    <span class="s1">run_ucm(</span><span class="s3">'local_linear_deterministic_trend'</span><span class="s2">, </span><span class="s1">use_exact_diffuse=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_local_linear_trend(close_figures):</span>
    <span class="s1">run_ucm(</span><span class="s3">'local_linear_trend'</span><span class="s1">)</span>
    <span class="s1">run_ucm(</span><span class="s3">'local_linear_trend'</span><span class="s2">, </span><span class="s1">use_exact_diffuse=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_smooth_trend(close_figures):</span>
    <span class="s1">run_ucm(</span><span class="s3">'smooth_trend'</span><span class="s1">)</span>
    <span class="s1">run_ucm(</span><span class="s3">'smooth_trend'</span><span class="s2">, </span><span class="s1">use_exact_diffuse=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_random_trend(close_figures):</span>
    <span class="s1">run_ucm(</span><span class="s3">'random_trend'</span><span class="s1">)</span>
    <span class="s1">run_ucm(</span><span class="s3">'random_trend'</span><span class="s2">, </span><span class="s1">use_exact_diffuse=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_cycle(close_figures):</span>
    <span class="s1">run_ucm(</span><span class="s3">'cycle_approx_diffuse'</span><span class="s1">)</span>
    <span class="s1">run_ucm(</span><span class="s3">'cycle'</span><span class="s2">, </span><span class="s1">use_exact_diffuse=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_seasonal(close_figures):</span>
    <span class="s1">run_ucm(</span><span class="s3">'seasonal_approx_diffuse'</span><span class="s1">)</span>
    <span class="s1">run_ucm(</span><span class="s3">'seasonal'</span><span class="s2">, </span><span class="s1">use_exact_diffuse=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_freq_seasonal(close_figures):</span>
    <span class="s1">run_ucm(</span><span class="s3">'freq_seasonal_approx_diffuse'</span><span class="s1">)</span>
    <span class="s1">run_ucm(</span><span class="s3">'freq_seasonal'</span><span class="s2">, </span><span class="s1">use_exact_diffuse=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_reg(close_figures):</span>
    <span class="s1">run_ucm(</span><span class="s3">'reg_approx_diffuse'</span><span class="s1">)</span>
    <span class="s1">run_ucm(</span><span class="s3">'reg'</span><span class="s2">, </span><span class="s1">use_exact_diffuse=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_rtrend_ar1(close_figures):</span>
    <span class="s1">run_ucm(</span><span class="s3">'rtrend_ar1'</span><span class="s1">)</span>
    <span class="s1">run_ucm(</span><span class="s3">'rtrend_ar1'</span><span class="s2">, </span><span class="s1">use_exact_diffuse=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s1">@pytest.mark.slow</span>
<span class="s2">def </span><span class="s1">test_lltrend_cycle_seasonal_reg_ar1(close_figures):</span>
    <span class="s1">run_ucm(</span><span class="s3">'lltrend_cycle_seasonal_reg_ar1_approx_diffuse'</span><span class="s1">)</span>
    <span class="s1">run_ucm(</span><span class="s3">'lltrend_cycle_seasonal_reg_ar1'</span><span class="s2">, </span><span class="s1">use_exact_diffuse=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;use_exact_diffuse&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_mle_reg(use_exact_diffuse):</span>
    <span class="s1">endog = np.arange(</span><span class="s5">100</span><span class="s1">)*</span><span class="s5">1.0</span>
    <span class="s1">exog = endog*</span><span class="s5">2</span>
    <span class="s4"># Make the fit not-quite-perfect</span>
    <span class="s1">endog[::</span><span class="s5">2</span><span class="s1">] += </span><span class="s5">0.01</span>
    <span class="s1">endog[</span><span class="s5">1</span><span class="s1">::</span><span class="s5">2</span><span class="s1">] -= </span><span class="s5">0.01</span>

    <span class="s2">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s1">mod1 = UnobservedComponents(endog</span><span class="s2">, </span><span class="s1">irregular=</span><span class="s2">True,</span>
                                    <span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">mle_regression=</span><span class="s2">False,</span>
                                    <span class="s1">use_exact_diffuse=use_exact_diffuse)</span>
        <span class="s1">res1 = mod1.fit(disp=-</span><span class="s5">1</span><span class="s1">)</span>

        <span class="s1">mod2 = UnobservedComponents(endog</span><span class="s2">, </span><span class="s1">irregular=</span><span class="s2">True,</span>
                                    <span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">mle_regression=</span><span class="s2">True,</span>
                                    <span class="s1">use_exact_diffuse=use_exact_diffuse)</span>
        <span class="s1">res2 = mod2.fit(disp=-</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s1">assert_allclose(res1.regression_coefficients.filtered[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s5">0.5</span><span class="s2">,</span>
                    <span class="s1">atol=</span><span class="s5">1e-5</span><span class="s1">)</span>
    <span class="s1">assert_allclose(res2.params[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s5">0.5</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-5</span><span class="s1">)</span>

    <span class="s4"># When the regression component is part of the state vector with exact</span>
    <span class="s4"># diffuse initialization, we have two diffuse observations</span>
    <span class="s2">if </span><span class="s1">use_exact_diffuse:</span>
        <span class="s1">print(res1.predicted_diffuse_state_cov)</span>
        <span class="s1">assert_equal(res1.nobs_diffuse</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">assert_equal(res2.nobs_diffuse</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">assert_equal(res1.loglikelihood_burn</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(res2.loglikelihood_burn</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_specifications():</span>
    <span class="s4"># Clear warnings</span>
    <span class="s1">structural.__warningregistry__ = {}</span>

    <span class="s1">endog = [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]</span>

    <span class="s4"># Test that when nothing specified, a warning is issued and the model that</span>
    <span class="s4"># is fit is one with irregular=True and nothing else.</span>
    <span class="s1">warning = SpecificationWarning</span>
    <span class="s1">match = </span><span class="s3">'irregular component added'</span>
    <span class="s2">with </span><span class="s1">pytest.warns(warning</span><span class="s2">, </span><span class="s1">match=match):</span>
        <span class="s1">mod = UnobservedComponents(endog)</span>
        <span class="s1">assert_equal(mod.trend_specification</span><span class="s2">, </span><span class="s3">'irregular'</span><span class="s1">)</span>

    <span class="s4"># Test an invalid string trend specification</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">UnobservedComponents(endog</span><span class="s2">, </span><span class="s3">'invalid spec'</span><span class="s1">)</span>

    <span class="s4"># Test that if a trend component is specified without a level component,</span>
    <span class="s4"># a warning is issued and a deterministic level component is added</span>
    <span class="s1">warning = SpecificationWarning</span>
    <span class="s1">match = </span><span class="s3">'Trend component specified without'</span>
    <span class="s2">with </span><span class="s1">pytest.warns(warning</span><span class="s2">, </span><span class="s1">match=match):</span>
        <span class="s1">mod = UnobservedComponents(endog</span><span class="s2">, </span><span class="s1">trend=</span><span class="s2">True, </span><span class="s1">irregular=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">assert_equal(mod.trend_specification</span><span class="s2">, </span><span class="s3">'deterministic trend'</span><span class="s1">)</span>

    <span class="s4"># Test that if a string specification is provided, a warning is issued if</span>
    <span class="s4"># the boolean attributes are also specified</span>
    <span class="s1">trend_attributes = [</span><span class="s3">'irregular'</span><span class="s2">, </span><span class="s3">'trend'</span><span class="s2">, </span><span class="s3">'stochastic_level'</span><span class="s2">,</span>
                        <span class="s3">'stochastic_trend'</span><span class="s1">]</span>
    <span class="s2">for </span><span class="s1">attribute </span><span class="s2">in </span><span class="s1">trend_attributes:</span>
        <span class="s1">kwargs = {attribute: </span><span class="s2">True</span><span class="s1">}</span>

        <span class="s1">warning = SpecificationWarning</span>
        <span class="s1">match = </span><span class="s3">'may be overridden when the trend'</span>
        <span class="s2">with </span><span class="s1">pytest.warns(warning</span><span class="s2">, </span><span class="s1">match=match):</span>
            <span class="s1">UnobservedComponents(endog</span><span class="s2">, </span><span class="s3">'deterministic trend'</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s4"># Test that a seasonal with period less than two is invalid</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">UnobservedComponents(endog</span><span class="s2">, </span><span class="s1">seasonal=</span><span class="s5">1</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_start_params():</span>
    <span class="s4"># Test that the behavior is correct for multiple exogenous and / or</span>
    <span class="s4"># autoregressive components</span>

    <span class="s4"># Parameters</span>
    <span class="s1">nobs = int(</span><span class="s5">1e4</span><span class="s1">)</span>
    <span class="s1">beta = np.r_[</span><span class="s5">10</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2</span><span class="s1">]</span>
    <span class="s1">phi = np.r_[</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.1</span><span class="s1">]</span>

    <span class="s4"># Generate data</span>
    <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
    <span class="s1">exog = np.c_[np.ones(nobs)</span><span class="s2">, </span><span class="s1">np.arange(nobs)*</span><span class="s5">1.0</span><span class="s1">]</span>
    <span class="s1">eps = np.random.normal(size=nobs)</span>
    <span class="s1">endog = np.zeros(nobs+</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">nobs):</span>
        <span class="s1">endog[t+</span><span class="s5">1</span><span class="s1">] = phi[</span><span class="s5">0</span><span class="s1">] * endog[t] + phi[</span><span class="s5">1</span><span class="s1">] * endog[t-</span><span class="s5">1</span><span class="s1">] + eps[t]</span>
    <span class="s1">endog = endog[</span><span class="s5">2</span><span class="s1">:]</span>
    <span class="s1">endog += np.dot(exog</span><span class="s2">, </span><span class="s1">beta)</span>

    <span class="s4"># Now just test that the starting parameters are approximately what they</span>
    <span class="s4"># ought to be (could make this arbitrarily precise by increasing nobs,</span>
    <span class="s4"># but that would slow down the test for no real gain)</span>
    <span class="s1">mod = UnobservedComponents(endog</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">autoregressive=</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">assert_allclose(mod.start_params</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-1</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_forecast():</span>
    <span class="s1">endog = np.arange(</span><span class="s5">50</span><span class="s1">) + </span><span class="s5">10</span>
    <span class="s1">exog = np.arange(</span><span class="s5">50</span><span class="s1">)</span>

    <span class="s1">mod = UnobservedComponents(endog</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">level=</span><span class="s3">'dconstant'</span><span class="s2">, </span><span class="s1">seasonal=</span><span class="s5">4</span><span class="s1">)</span>
    <span class="s1">res = mod.smooth([</span><span class="s5">1e-15</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span>

    <span class="s1">actual = res.forecast(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">exog=np.arange(</span><span class="s5">50</span><span class="s2">, </span><span class="s5">60</span><span class="s1">)[:</span><span class="s2">, </span><span class="s1">np.newaxis])</span>
    <span class="s1">desired = np.arange(</span><span class="s5">50</span><span class="s2">, </span><span class="s5">60</span><span class="s1">) + </span><span class="s5">10</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>


<span class="s2">def </span><span class="s1">test_misc_exog():</span>
    <span class="s4"># Tests for missing data</span>
    <span class="s1">nobs = </span><span class="s5">20</span>
    <span class="s1">k_endog = </span><span class="s5">1</span>
    <span class="s1">np.random.seed(</span><span class="s5">1208</span><span class="s1">)</span>
    <span class="s1">endog = np.random.normal(size=(nobs</span><span class="s2">, </span><span class="s1">k_endog))</span>
    <span class="s1">endog[:</span><span class="s5">4</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = np.nan</span>
    <span class="s1">exog1 = np.random.normal(size=(nobs</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>
    <span class="s1">exog2 = np.random.normal(size=(nobs</span><span class="s2">, </span><span class="s5">2</span><span class="s1">))</span>

    <span class="s1">index = pd.date_range(</span><span class="s3">'1970-01-01'</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'QS'</span><span class="s2">, </span><span class="s1">periods=nobs)</span>
    <span class="s1">endog_pd = pd.DataFrame(endog</span><span class="s2">, </span><span class="s1">index=index)</span>
    <span class="s1">exog1_pd = pd.Series(exog1.squeeze()</span><span class="s2">, </span><span class="s1">index=index)</span>
    <span class="s1">exog2_pd = pd.DataFrame(exog2</span><span class="s2">, </span><span class="s1">index=index)</span>

    <span class="s1">models = [</span>
        <span class="s1">UnobservedComponents(endog</span><span class="s2">, </span><span class="s3">'llevel'</span><span class="s2">, </span><span class="s1">exog=exog1)</span><span class="s2">,</span>
        <span class="s1">UnobservedComponents(endog</span><span class="s2">, </span><span class="s3">'llevel'</span><span class="s2">, </span><span class="s1">exog=exog2)</span><span class="s2">,</span>
        <span class="s1">UnobservedComponents(endog</span><span class="s2">, </span><span class="s3">'llevel'</span><span class="s2">, </span><span class="s1">exog=exog2)</span><span class="s2">,</span>
        <span class="s1">UnobservedComponents(endog_pd</span><span class="s2">, </span><span class="s3">'llevel'</span><span class="s2">, </span><span class="s1">exog=exog1_pd)</span><span class="s2">,</span>
        <span class="s1">UnobservedComponents(endog_pd</span><span class="s2">, </span><span class="s3">'llevel'</span><span class="s2">, </span><span class="s1">exog=exog2_pd)</span><span class="s2">,</span>
        <span class="s1">UnobservedComponents(endog_pd</span><span class="s2">, </span><span class="s3">'llevel'</span><span class="s2">, </span><span class="s1">exog=exog2_pd)</span><span class="s2">,</span>
    <span class="s1">]</span>

    <span class="s2">for </span><span class="s1">mod </span><span class="s2">in </span><span class="s1">models:</span>
        <span class="s4"># Smoke tests</span>
        <span class="s1">mod.start_params</span>
        <span class="s1">res = mod.fit(disp=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">res.summary()</span>
        <span class="s1">res.predict()</span>
        <span class="s1">res.predict(dynamic=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">res.get_prediction()</span>

        <span class="s1">oos_exog = np.random.normal(size=(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">mod.k_exog))</span>
        <span class="s1">res.forecast(steps=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">exog=oos_exog)</span>
        <span class="s1">res.get_forecast(steps=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">exog=oos_exog)</span>

        <span class="s4"># Smoke tests for invalid exog</span>
        <span class="s1">oos_exog = np.random.normal(size=(</span><span class="s5">2</span><span class="s2">, </span><span class="s1">mod.k_exog))</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">res.forecast(steps=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">exog=oos_exog)</span>

        <span class="s1">oos_exog = np.random.normal(size=(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">mod.k_exog + </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">res.forecast(steps=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">exog=oos_exog)</span>

    <span class="s4"># Test invalid model specifications</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">UnobservedComponents(endog</span><span class="s2">, </span><span class="s3">'llevel'</span><span class="s2">, </span><span class="s1">exog=np.zeros((</span><span class="s5">10</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)))</span>


<span class="s2">def </span><span class="s1">test_predict_custom_index():</span>
    <span class="s1">np.random.seed(</span><span class="s5">328423</span><span class="s1">)</span>
    <span class="s1">endog = pd.DataFrame(np.random.normal(size=</span><span class="s5">50</span><span class="s1">))</span>
    <span class="s1">mod = structural.UnobservedComponents(endog</span><span class="s2">, </span><span class="s3">'llevel'</span><span class="s1">)</span>
    <span class="s1">res = mod.smooth(mod.start_params)</span>
    <span class="s1">out = res.predict(start=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">end=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">index=[</span><span class="s3">'a'</span><span class="s1">])</span>
    <span class="s1">assert_equal(out.index.equals(pd.Index([</span><span class="s3">'a'</span><span class="s1">]))</span><span class="s2">, True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_matrices_somewhat_complicated_model():</span>
    <span class="s1">values = dta.copy()</span>

    <span class="s1">model = UnobservedComponents(values[</span><span class="s3">'unemp'</span><span class="s1">]</span><span class="s2">,</span>
                                 <span class="s1">level=</span><span class="s3">'lltrend'</span><span class="s2">,</span>
                                 <span class="s1">freq_seasonal=[{</span><span class="s3">'period'</span><span class="s1">: </span><span class="s5">4</span><span class="s1">}</span><span class="s2">,</span>
                                                <span class="s1">{</span><span class="s3">'period'</span><span class="s1">: </span><span class="s5">9</span><span class="s2">, </span><span class="s3">'harmonics'</span><span class="s1">: </span><span class="s5">3</span><span class="s1">}]</span><span class="s2">,</span>
                                 <span class="s1">cycle=</span><span class="s2">True,</span>
                                 <span class="s1">cycle_period_bounds=[</span><span class="s5">2</span><span class="s2">, </span><span class="s5">30</span><span class="s1">]</span><span class="s2">,</span>
                                 <span class="s1">damped_cycle=</span><span class="s2">True,</span>
                                 <span class="s1">stochastic_freq_seasonal=[</span><span class="s2">True, False</span><span class="s1">]</span><span class="s2">,</span>
                                 <span class="s1">stochastic_cycle=</span><span class="s2">True</span>
                                 <span class="s1">)</span>
    <span class="s4"># Selected parameters</span>
    <span class="s1">params = [</span><span class="s5">1</span><span class="s2">,  </span><span class="s4"># irregular_var</span>
              <span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s2">,  </span><span class="s4"># lltrend parameters:  level_var, trend_var</span>
              <span class="s5">5</span><span class="s2">,   </span><span class="s4"># freq_seasonal parameters: freq_seasonal_var_0</span>
              <span class="s4"># cycle parameters: cycle_var, cycle_freq, cycle_damp</span>
              <span class="s5">6</span><span class="s2">, </span><span class="s5">2</span><span class="s1">*np.pi/</span><span class="s5">30.</span><span class="s2">, </span><span class="s5">.9</span>
              <span class="s1">]</span>
    <span class="s1">model.update(params)</span>

    <span class="s4"># Check scalar properties</span>
    <span class="s1">assert_equal(model.k_states</span><span class="s2">, </span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">4 </span><span class="s1">+ </span><span class="s5">6 </span><span class="s1">+ </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">assert_equal(model.k_state_cov</span><span class="s2">, </span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">1 </span><span class="s1">+ </span><span class="s5">0 </span><span class="s1">+ </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(model.loglikelihood_burn</span><span class="s2">, </span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">4 </span><span class="s1">+ </span><span class="s5">6 </span><span class="s1">+ </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">assert_allclose(model.ssm.k_posdef</span><span class="s2">, </span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">4 </span><span class="s1">+ </span><span class="s5">0 </span><span class="s1">+ </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">assert_equal(model.k_params</span><span class="s2">, </span><span class="s1">len(params))</span>

    <span class="s4"># Check the statespace model matrices against hand-constructed answers</span>
    <span class="s4"># We group the terms by the component</span>
    <span class="s1">expected_design = np.r_[[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]].reshape(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">14</span><span class="s1">)</span>
    <span class="s1">assert_allclose(model.ssm.design[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">expected_design)</span>

    <span class="s1">expected_transition = __direct_sum([</span>
        <span class="s1">np.array([[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]])</span><span class="s2">,</span>
        <span class="s1">np.array([[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s1">[-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">,  </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">,  </span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]])</span><span class="s2">,</span>
        <span class="s1">np.array([[np.cos(</span><span class="s5">2</span><span class="s1">*np.pi*</span><span class="s5">1</span><span class="s1">/</span><span class="s5">9.</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.sin(</span><span class="s5">2</span><span class="s1">*np.pi*</span><span class="s5">1</span><span class="s1">/</span><span class="s5">9.</span><span class="s1">)</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s1">[-np.sin(</span><span class="s5">2</span><span class="s1">*np.pi*</span><span class="s5">1</span><span class="s1">/</span><span class="s5">9.</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.cos(</span><span class="s5">2</span><span class="s1">*np.pi*</span><span class="s5">1</span><span class="s1">/</span><span class="s5">9.</span><span class="s1">)</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">,  </span><span class="s1">np.cos(</span><span class="s5">2</span><span class="s1">*np.pi*</span><span class="s5">2</span><span class="s1">/</span><span class="s5">9.</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.sin(</span><span class="s5">2</span><span class="s1">*np.pi*</span><span class="s5">2</span><span class="s1">/</span><span class="s5">9.</span><span class="s1">)</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">-np.sin(</span><span class="s5">2</span><span class="s1">*np.pi*</span><span class="s5">2</span><span class="s1">/</span><span class="s5">9.</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.cos(</span><span class="s5">2</span><span class="s1">*np.pi*</span><span class="s5">2</span><span class="s1">/</span><span class="s5">9.</span><span class="s1">)</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">,  </span><span class="s1">np.cos(</span><span class="s5">2</span><span class="s1">*np.pi/</span><span class="s5">3.</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.sin(</span><span class="s5">2</span><span class="s1">*np.pi/</span><span class="s5">3.</span><span class="s1">)]</span><span class="s2">,</span>
                  <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">-np.sin(</span><span class="s5">2</span><span class="s1">*np.pi/</span><span class="s5">3.</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.cos(</span><span class="s5">2</span><span class="s1">*np.pi/</span><span class="s5">3.</span><span class="s1">)]])</span><span class="s2">,</span>
        <span class="s1">np.array([[</span><span class="s5">.9</span><span class="s1">*np.cos(</span><span class="s5">2</span><span class="s1">*np.pi/</span><span class="s5">30.</span><span class="s1">)</span><span class="s2">, </span><span class="s5">.9</span><span class="s1">*np.sin(</span><span class="s5">2</span><span class="s1">*np.pi/</span><span class="s5">30.</span><span class="s1">)]</span><span class="s2">,</span>
                 <span class="s1">[-</span><span class="s5">.9</span><span class="s1">*np.sin(</span><span class="s5">2</span><span class="s1">*np.pi/</span><span class="s5">30.</span><span class="s1">)</span><span class="s2">, </span><span class="s5">.9</span><span class="s1">*np.cos(</span><span class="s5">2</span><span class="s1">*np.pi/</span><span class="s5">30.</span><span class="s1">)]])</span>
    <span class="s1">])</span>
    <span class="s1">assert_allclose(</span>
        <span class="s1">model.ssm.transition[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">expected_transition</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-7</span><span class="s1">)</span>

    <span class="s4"># Since the second seasonal term is not stochastic,</span>
    <span class="s4"># the dimensionality of the state disturbance is 14 - 6 = 8</span>
    <span class="s1">expected_selection = np.zeros((</span><span class="s5">14</span><span class="s2">, </span><span class="s5">14 </span><span class="s1">- </span><span class="s5">6</span><span class="s1">))</span>
    <span class="s1">expected_selection[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">2</span><span class="s2">, </span><span class="s5">0</span><span class="s1">:</span><span class="s5">2</span><span class="s1">] = np.eye(</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">expected_selection[</span><span class="s5">2</span><span class="s1">:</span><span class="s5">6</span><span class="s2">, </span><span class="s5">2</span><span class="s1">:</span><span class="s5">6</span><span class="s1">] = np.eye(</span><span class="s5">4</span><span class="s1">)</span>
    <span class="s1">expected_selection[-</span><span class="s5">2</span><span class="s1">:</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2</span><span class="s1">:] = np.eye(</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">assert_allclose(model.ssm.selection[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">expected_selection)</span>

    <span class="s1">expected_state_cov = __direct_sum([</span>
        <span class="s1">np.diag(params[</span><span class="s5">1</span><span class="s1">:</span><span class="s5">3</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">np.eye(</span><span class="s5">4</span><span class="s1">)*params[</span><span class="s5">3</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">np.eye(</span><span class="s5">2</span><span class="s1">)*params[</span><span class="s5">4</span><span class="s1">]</span>
    <span class="s1">])</span>
    <span class="s1">assert_allclose(model.ssm.state_cov[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">expected_state_cov)</span>


<span class="s2">def </span><span class="s1">__direct_sum(square_matrices):</span>
    <span class="s0">&quot;&quot;&quot;Compute the matrix direct sum of an iterable of square numpy 2-d arrays 
    &quot;&quot;&quot;</span>
    <span class="s1">new_shape = np.sum([m.shape </span><span class="s2">for </span><span class="s1">m </span><span class="s2">in </span><span class="s1">square_matrices]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">new_array = np.zeros(new_shape)</span>
    <span class="s1">offset = </span><span class="s5">0</span>
    <span class="s2">for </span><span class="s1">m </span><span class="s2">in </span><span class="s1">square_matrices:</span>
        <span class="s1">rows</span><span class="s2">, </span><span class="s1">cols = m.shape</span>
        <span class="s2">assert </span><span class="s1">rows == cols</span>
        <span class="s1">new_array[offset:offset + rows</span><span class="s2">, </span><span class="s1">offset:offset + rows] = m</span>
        <span class="s1">offset += rows</span>
    <span class="s2">return </span><span class="s1">new_array</span>


<span class="s2">def </span><span class="s1">test_forecast_exog():</span>
    <span class="s4"># Test forecasting with various shapes of `exog`</span>
    <span class="s1">nobs = </span><span class="s5">100</span>
    <span class="s1">endog = np.ones(nobs) * </span><span class="s5">2.0</span>
    <span class="s1">exog = np.ones(nobs)</span>

    <span class="s1">mod = UnobservedComponents(endog</span><span class="s2">, </span><span class="s3">'irregular'</span><span class="s2">, </span><span class="s1">exog=exog)</span>
    <span class="s1">res = mod.smooth([</span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">2.0</span><span class="s1">])</span>

    <span class="s4"># 1-step-ahead, valid</span>
    <span class="s1">exog_fcast_scalar = </span><span class="s5">1.</span>
    <span class="s1">exog_fcast_1dim = np.ones(</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">exog_fcast_2dim = np.ones((</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>

    <span class="s1">assert_allclose(res.forecast(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">exog=exog_fcast_scalar)</span><span class="s2">, </span><span class="s5">2.</span><span class="s1">)</span>
    <span class="s1">assert_allclose(res.forecast(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">exog=exog_fcast_1dim)</span><span class="s2">, </span><span class="s5">2.</span><span class="s1">)</span>
    <span class="s1">assert_allclose(res.forecast(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">exog=exog_fcast_2dim)</span><span class="s2">, </span><span class="s5">2.</span><span class="s1">)</span>

    <span class="s4"># h-steps-ahead, valid</span>
    <span class="s1">h = </span><span class="s5">10</span>
    <span class="s1">exog_fcast_1dim = np.ones(h)</span>
    <span class="s1">exog_fcast_2dim = np.ones((h</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>

    <span class="s1">assert_allclose(res.forecast(h</span><span class="s2">, </span><span class="s1">exog=exog_fcast_1dim)</span><span class="s2">, </span><span class="s5">2.</span><span class="s1">)</span>
    <span class="s1">assert_allclose(res.forecast(h</span><span class="s2">, </span><span class="s1">exog=exog_fcast_2dim)</span><span class="s2">, </span><span class="s5">2.</span><span class="s1">)</span>

    <span class="s4"># h-steps-ahead, invalid</span>
    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">res.forecast</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">exog=</span><span class="s5">1.</span><span class="s1">)</span>
    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">res.forecast</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">exog=[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">])</span>
    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">res.forecast</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">exog=np.ones((h</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)))</span>


<span class="s2">def </span><span class="s1">check_equivalent_models(mod</span><span class="s2">, </span><span class="s1">mod2):</span>
    <span class="s1">attrs = [</span>
        <span class="s3">'level'</span><span class="s2">, </span><span class="s3">'trend'</span><span class="s2">, </span><span class="s3">'seasonal_periods'</span><span class="s2">, </span><span class="s3">'seasonal'</span><span class="s2">,</span>
        <span class="s3">'freq_seasonal_periods'</span><span class="s2">, </span><span class="s3">'freq_seasonal_harmonics'</span><span class="s2">, </span><span class="s3">'freq_seasonal'</span><span class="s2">,</span>
        <span class="s3">'cycle'</span><span class="s2">, </span><span class="s3">'ar_order'</span><span class="s2">, </span><span class="s3">'autoregressive'</span><span class="s2">, </span><span class="s3">'irregular'</span><span class="s2">, </span><span class="s3">'stochastic_level'</span><span class="s2">,</span>
        <span class="s3">'stochastic_trend'</span><span class="s2">, </span><span class="s3">'stochastic_seasonal'</span><span class="s2">, </span><span class="s3">'stochastic_freq_seasonal'</span><span class="s2">,</span>
        <span class="s3">'stochastic_cycle'</span><span class="s2">, </span><span class="s3">'damped_cycle'</span><span class="s2">, </span><span class="s3">'mle_regression'</span><span class="s2">,</span>
        <span class="s3">'trend_specification'</span><span class="s2">, </span><span class="s3">'trend_mask'</span><span class="s2">, </span><span class="s3">'regression'</span><span class="s2">,</span>
        <span class="s3">'cycle_frequency_bound'</span><span class="s1">]</span>

    <span class="s1">ssm_attrs = [</span>
        <span class="s3">'nobs'</span><span class="s2">, </span><span class="s3">'k_endog'</span><span class="s2">, </span><span class="s3">'k_states'</span><span class="s2">, </span><span class="s3">'k_posdef'</span><span class="s2">, </span><span class="s3">'obs_intercept'</span><span class="s2">, </span><span class="s3">'design'</span><span class="s2">,</span>
        <span class="s3">'obs_cov'</span><span class="s2">, </span><span class="s3">'state_intercept'</span><span class="s2">, </span><span class="s3">'transition'</span><span class="s2">, </span><span class="s3">'selection'</span><span class="s2">, </span><span class="s3">'state_cov'</span><span class="s1">]</span>

    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">attrs:</span>
        <span class="s1">assert_equal(getattr(mod2</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">, </span><span class="s1">getattr(mod</span><span class="s2">, </span><span class="s1">attr))</span>

    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">ssm_attrs:</span>
        <span class="s1">assert_equal(getattr(mod2.ssm</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">, </span><span class="s1">getattr(mod.ssm</span><span class="s2">, </span><span class="s1">attr))</span>

    <span class="s1">assert_equal(mod2._get_init_kwds()</span><span class="s2">, </span><span class="s1">mod._get_init_kwds())</span>


<span class="s2">def </span><span class="s1">test_recreate_model():</span>
    <span class="s1">nobs = </span><span class="s5">100</span>
    <span class="s1">endog = np.ones(nobs) * </span><span class="s5">2.0</span>
    <span class="s1">exog = np.ones(nobs)</span>

    <span class="s1">levels = [</span>
        <span class="s3">'irregular'</span><span class="s2">, </span><span class="s3">'ntrend'</span><span class="s2">, </span><span class="s3">'fixed intercept'</span><span class="s2">, </span><span class="s3">'deterministic constant'</span><span class="s2">,</span>
        <span class="s3">'dconstant'</span><span class="s2">, </span><span class="s3">'local level'</span><span class="s2">, </span><span class="s3">'llevel'</span><span class="s2">, </span><span class="s3">'random walk'</span><span class="s2">, </span><span class="s3">'rwalk'</span><span class="s2">,</span>
        <span class="s3">'fixed slope'</span><span class="s2">, </span><span class="s3">'deterministic trend'</span><span class="s2">, </span><span class="s3">'dtrend'</span><span class="s2">,</span>
        <span class="s3">'local linear deterministic trend'</span><span class="s2">, </span><span class="s3">'lldtrend'</span><span class="s2">,</span>
        <span class="s3">'random walk with drift'</span><span class="s2">, </span><span class="s3">'rwdrift'</span><span class="s2">, </span><span class="s3">'local linear trend'</span><span class="s2">,</span>
        <span class="s3">'lltrend'</span><span class="s2">, </span><span class="s3">'smooth trend'</span><span class="s2">, </span><span class="s3">'strend'</span><span class="s2">, </span><span class="s3">'random trend'</span><span class="s2">, </span><span class="s3">'rtrend'</span><span class="s1">]</span>

    <span class="s2">for </span><span class="s1">level </span><span class="s2">in </span><span class="s1">levels:</span>
        <span class="s4"># Note: have to add in some stochastic component, otherwise we have</span>
        <span class="s4"># problems with entirely deterministic models</span>

        <span class="s4"># level + stochastic seasonal</span>
        <span class="s1">mod = UnobservedComponents(endog</span><span class="s2">, </span><span class="s1">level=level</span><span class="s2">, </span><span class="s1">seasonal=</span><span class="s5">2</span><span class="s2">,</span>
                                   <span class="s1">stochastic_seasonal=</span><span class="s2">True, </span><span class="s1">exog=exog)</span>
        <span class="s1">mod2 = UnobservedComponents(endog</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">**mod._get_init_kwds())</span>
        <span class="s1">check_equivalent_models(mod</span><span class="s2">, </span><span class="s1">mod2)</span>

        <span class="s4"># level + autoregressive</span>
        <span class="s1">mod = UnobservedComponents(endog</span><span class="s2">, </span><span class="s1">level=level</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">,</span>
                                   <span class="s1">autoregressive=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">mod2 = UnobservedComponents(endog</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">**mod._get_init_kwds())</span>
        <span class="s1">check_equivalent_models(mod</span><span class="s2">, </span><span class="s1">mod2)</span>

        <span class="s4"># level + stochastic cycle</span>
        <span class="s1">mod = UnobservedComponents(endog</span><span class="s2">, </span><span class="s1">level=level</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">,</span>
                                   <span class="s1">cycle=</span><span class="s2">True, </span><span class="s1">stochastic_cycle=</span><span class="s2">True,</span>
                                   <span class="s1">damped_cycle=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">mod2 = UnobservedComponents(endog</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">**mod._get_init_kwds())</span>
        <span class="s1">check_equivalent_models(mod</span><span class="s2">, </span><span class="s1">mod2)</span>


<span class="s2">def </span><span class="s1">test_append_results():</span>
    <span class="s1">endog = np.arange(</span><span class="s5">100</span><span class="s1">)</span>
    <span class="s1">exog = np.ones_like(endog)</span>
    <span class="s1">params = [</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">1.</span><span class="s1">]</span>

    <span class="s1">mod1 = UnobservedComponents(endog</span><span class="s2">, </span><span class="s3">'llevel'</span><span class="s2">, </span><span class="s1">exog=exog)</span>
    <span class="s1">res1 = mod1.smooth(params)</span>

    <span class="s1">mod2 = UnobservedComponents(endog[:</span><span class="s5">50</span><span class="s1">]</span><span class="s2">, </span><span class="s3">'llevel'</span><span class="s2">, </span><span class="s1">exog=exog[:</span><span class="s5">50</span><span class="s1">])</span>
    <span class="s1">res2 = mod2.smooth(params)</span>
    <span class="s1">res3 = res2.append(endog[</span><span class="s5">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s5">50</span><span class="s1">:])</span>

    <span class="s1">assert_equal(res1.specification</span><span class="s2">, </span><span class="s1">res3.specification)</span>

    <span class="s1">assert_allclose(res3.cov_params_default</span><span class="s2">, </span><span class="s1">res2.cov_params_default)</span>
    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'nobs'</span><span class="s2">, </span><span class="s3">'llf'</span><span class="s2">, </span><span class="s3">'llf_obs'</span><span class="s2">, </span><span class="s3">'loglikelihood_burn'</span><span class="s1">]:</span>
        <span class="s1">assert_equal(getattr(res3</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">, </span><span class="s1">getattr(res1</span><span class="s2">, </span><span class="s1">attr))</span>

    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">[</span>
            <span class="s3">'filtered_state'</span><span class="s2">, </span><span class="s3">'filtered_state_cov'</span><span class="s2">, </span><span class="s3">'predicted_state'</span><span class="s2">,</span>
            <span class="s3">'predicted_state_cov'</span><span class="s2">, </span><span class="s3">'forecasts'</span><span class="s2">, </span><span class="s3">'forecasts_error'</span><span class="s2">,</span>
            <span class="s3">'forecasts_error_cov'</span><span class="s2">, </span><span class="s3">'standardized_forecasts_error'</span><span class="s2">,</span>
            <span class="s3">'forecasts_error_diffuse_cov'</span><span class="s2">, </span><span class="s3">'predicted_diffuse_state_cov'</span><span class="s2">,</span>
            <span class="s3">'scaled_smoothed_estimator'</span><span class="s2">,</span>
            <span class="s3">'scaled_smoothed_estimator_cov'</span><span class="s2">, </span><span class="s3">'smoothing_error'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_cov'</span><span class="s2">, </span><span class="s3">'smoothed_state_autocov'</span><span class="s2">,</span>
            <span class="s3">'smoothed_measurement_disturbance'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_disturbance'</span><span class="s2">,</span>
            <span class="s3">'smoothed_measurement_disturbance_cov'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_disturbance_cov'</span><span class="s1">]:</span>
        <span class="s1">assert_equal(getattr(res3</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">, </span><span class="s1">getattr(res1</span><span class="s2">, </span><span class="s1">attr))</span>

    <span class="s1">assert_allclose(res3.forecast(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">exog=np.ones(</span><span class="s5">10</span><span class="s1">))</span><span class="s2">,</span>
                    <span class="s1">res1.forecast(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">exog=np.ones(</span><span class="s5">10</span><span class="s1">)))</span>


<span class="s2">def </span><span class="s1">test_extend_results():</span>
    <span class="s1">endog = np.arange(</span><span class="s5">100</span><span class="s1">)</span>
    <span class="s1">exog = np.ones_like(endog)</span>
    <span class="s1">params = [</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">1.</span><span class="s1">]</span>

    <span class="s1">mod1 = UnobservedComponents(endog</span><span class="s2">, </span><span class="s3">'llevel'</span><span class="s2">, </span><span class="s1">exog=exog)</span>
    <span class="s1">res1 = mod1.smooth(params)</span>

    <span class="s1">mod2 = UnobservedComponents(endog[:</span><span class="s5">50</span><span class="s1">]</span><span class="s2">, </span><span class="s3">'llevel'</span><span class="s2">, </span><span class="s1">exog=exog[:</span><span class="s5">50</span><span class="s1">])</span>
    <span class="s1">res2 = mod2.smooth(params)</span>

    <span class="s1">res3 = res2.extend(endog[</span><span class="s5">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s5">50</span><span class="s1">:])</span>

    <span class="s1">assert_allclose(res3.llf_obs</span><span class="s2">, </span><span class="s1">res1.llf_obs[</span><span class="s5">50</span><span class="s1">:])</span>

    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">[</span>
            <span class="s3">'filtered_state'</span><span class="s2">, </span><span class="s3">'filtered_state_cov'</span><span class="s2">, </span><span class="s3">'predicted_state'</span><span class="s2">,</span>
            <span class="s3">'predicted_state_cov'</span><span class="s2">, </span><span class="s3">'forecasts'</span><span class="s2">, </span><span class="s3">'forecasts_error'</span><span class="s2">,</span>
            <span class="s3">'forecasts_error_cov'</span><span class="s2">, </span><span class="s3">'standardized_forecasts_error'</span><span class="s2">,</span>
            <span class="s3">'forecasts_error_diffuse_cov'</span><span class="s2">, </span><span class="s3">'predicted_diffuse_state_cov'</span><span class="s2">,</span>
            <span class="s3">'scaled_smoothed_estimator'</span><span class="s2">,</span>
            <span class="s3">'scaled_smoothed_estimator_cov'</span><span class="s2">, </span><span class="s3">'smoothing_error'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_cov'</span><span class="s2">, </span><span class="s3">'smoothed_state_autocov'</span><span class="s2">,</span>
            <span class="s3">'smoothed_measurement_disturbance'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_disturbance'</span><span class="s2">,</span>
            <span class="s3">'smoothed_measurement_disturbance_cov'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_disturbance_cov'</span><span class="s1">]:</span>
        <span class="s1">desired = getattr(res1</span><span class="s2">, </span><span class="s1">attr)</span>
        <span class="s2">if </span><span class="s1">desired </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">desired = desired[...</span><span class="s2">, </span><span class="s5">50</span><span class="s1">:]</span>
        <span class="s1">assert_equal(getattr(res3</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s1">assert_allclose(res3.forecast(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">exog=np.ones(</span><span class="s5">10</span><span class="s1">))</span><span class="s2">,</span>
                    <span class="s1">res1.forecast(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">exog=np.ones(</span><span class="s5">10</span><span class="s1">)))</span>


<span class="s2">def </span><span class="s1">test_apply_results():</span>
    <span class="s1">endog = np.arange(</span><span class="s5">100</span><span class="s1">)</span>
    <span class="s1">exog = np.ones_like(endog)</span>
    <span class="s1">params = [</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">1.</span><span class="s1">]</span>

    <span class="s1">mod1 = UnobservedComponents(endog[:</span><span class="s5">50</span><span class="s1">]</span><span class="s2">, </span><span class="s3">'llevel'</span><span class="s2">, </span><span class="s1">exog=exog[:</span><span class="s5">50</span><span class="s1">])</span>
    <span class="s1">res1 = mod1.smooth(params)</span>

    <span class="s1">mod2 = UnobservedComponents(endog[</span><span class="s5">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s3">'llevel'</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s5">50</span><span class="s1">:])</span>
    <span class="s1">res2 = mod2.smooth(params)</span>

    <span class="s1">res3 = res2.apply(endog[:</span><span class="s5">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">exog=exog[:</span><span class="s5">50</span><span class="s1">])</span>

    <span class="s1">assert_equal(res1.specification</span><span class="s2">, </span><span class="s1">res3.specification)</span>

    <span class="s1">assert_allclose(res3.cov_params_default</span><span class="s2">, </span><span class="s1">res2.cov_params_default)</span>
    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'nobs'</span><span class="s2">, </span><span class="s3">'llf'</span><span class="s2">, </span><span class="s3">'llf_obs'</span><span class="s2">, </span><span class="s3">'loglikelihood_burn'</span><span class="s1">]:</span>
        <span class="s1">assert_equal(getattr(res3</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">, </span><span class="s1">getattr(res1</span><span class="s2">, </span><span class="s1">attr))</span>

    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">[</span>
            <span class="s3">'filtered_state'</span><span class="s2">, </span><span class="s3">'filtered_state_cov'</span><span class="s2">, </span><span class="s3">'predicted_state'</span><span class="s2">,</span>
            <span class="s3">'predicted_state_cov'</span><span class="s2">, </span><span class="s3">'forecasts'</span><span class="s2">, </span><span class="s3">'forecasts_error'</span><span class="s2">,</span>
            <span class="s3">'forecasts_error_cov'</span><span class="s2">, </span><span class="s3">'standardized_forecasts_error'</span><span class="s2">,</span>
            <span class="s3">'forecasts_error_diffuse_cov'</span><span class="s2">, </span><span class="s3">'predicted_diffuse_state_cov'</span><span class="s2">,</span>
            <span class="s3">'scaled_smoothed_estimator'</span><span class="s2">,</span>
            <span class="s3">'scaled_smoothed_estimator_cov'</span><span class="s2">, </span><span class="s3">'smoothing_error'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_cov'</span><span class="s2">, </span><span class="s3">'smoothed_state_autocov'</span><span class="s2">,</span>
            <span class="s3">'smoothed_measurement_disturbance'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_disturbance'</span><span class="s2">,</span>
            <span class="s3">'smoothed_measurement_disturbance_cov'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_disturbance_cov'</span><span class="s1">]:</span>
        <span class="s1">assert_equal(getattr(res3</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">, </span><span class="s1">getattr(res1</span><span class="s2">, </span><span class="s1">attr))</span>

    <span class="s1">assert_allclose(res3.forecast(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">exog=np.ones(</span><span class="s5">10</span><span class="s1">))</span><span class="s2">,</span>
                    <span class="s1">res1.forecast(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">exog=np.ones(</span><span class="s5">10</span><span class="s1">)))</span>
</pre>
</body>
</html>