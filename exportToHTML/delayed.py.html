<html>
<head>
<title>delayed.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
delayed.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">operator</span>
<span class="s0">import </span><span class="s1">types</span>
<span class="s0">import </span><span class="s1">uuid</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">from </span><span class="s1">collections.abc </span><span class="s0">import </span><span class="s1">Sequence</span>
<span class="s0">from </span><span class="s1">dataclasses </span><span class="s0">import </span><span class="s1">fields</span><span class="s0">, </span><span class="s1">is_dataclass</span><span class="s0">, </span><span class="s1">replace</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">partial</span>

<span class="s0">from </span><span class="s1">tlz </span><span class="s0">import </span><span class="s1">concat</span><span class="s0">, </span><span class="s1">curry</span><span class="s0">, </span><span class="s1">merge</span><span class="s0">, </span><span class="s1">unique</span>

<span class="s0">from </span><span class="s1">dask </span><span class="s0">import </span><span class="s1">config</span>
<span class="s0">from </span><span class="s1">dask.base </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">DaskMethodsMixin</span><span class="s0">,</span>
    <span class="s1">dont_optimize</span><span class="s0">,</span>
    <span class="s1">is_dask_collection</span><span class="s0">,</span>
    <span class="s1">named_schedulers</span><span class="s0">,</span>
    <span class="s1">replace_name_in_key</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">dask.base </span><span class="s0">import </span><span class="s1">tokenize </span><span class="s0">as </span><span class="s1">_tokenize</span>
<span class="s0">from </span><span class="s1">dask.context </span><span class="s0">import </span><span class="s1">globalmethod</span>
<span class="s0">from </span><span class="s1">dask.core </span><span class="s0">import </span><span class="s1">flatten</span><span class="s0">, </span><span class="s1">quote</span>
<span class="s0">from </span><span class="s1">dask.highlevelgraph </span><span class="s0">import </span><span class="s1">HighLevelGraph</span>
<span class="s0">from </span><span class="s1">dask.typing </span><span class="s0">import </span><span class="s1">Graph</span><span class="s0">, </span><span class="s1">NestedKeys</span>
<span class="s0">from </span><span class="s1">dask.utils </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">OperatorMethodMixin</span><span class="s0">,</span>
    <span class="s1">apply</span><span class="s0">,</span>
    <span class="s1">funcname</span><span class="s0">,</span>
    <span class="s1">is_namedtuple_instance</span><span class="s0">,</span>
    <span class="s1">methodcaller</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s1">__all__ = [</span><span class="s2">&quot;Delayed&quot;</span><span class="s0">, </span><span class="s2">&quot;delayed&quot;</span><span class="s1">]</span>


<span class="s1">DEFAULT_GET = named_schedulers.get(</span><span class="s2">&quot;threads&quot;</span><span class="s0">, </span><span class="s1">named_schedulers[</span><span class="s2">&quot;sync&quot;</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">unzip(ls</span><span class="s0">, </span><span class="s1">nout):</span>
    <span class="s3">&quot;&quot;&quot;Unzip a list of lists into ``nout`` outputs.&quot;&quot;&quot;</span>
    <span class="s1">out = list(zip(*ls))</span>
    <span class="s0">if not </span><span class="s1">out:</span>
        <span class="s1">out = [()] * nout</span>
    <span class="s0">return </span><span class="s1">out</span>


<span class="s0">def </span><span class="s1">finalize(collection):</span>
    <span class="s0">assert </span><span class="s1">is_dask_collection(collection)</span>

    <span class="s1">name = </span><span class="s2">&quot;finalize-&quot; </span><span class="s1">+ tokenize(collection)</span>
    <span class="s1">keys = collection.__dask_keys__()</span>
    <span class="s1">finalize</span><span class="s0">, </span><span class="s1">args = collection.__dask_postcompute__()</span>
    <span class="s1">layer = {name: (finalize</span><span class="s0">, </span><span class="s1">keys) + args}</span>
    <span class="s1">graph = HighLevelGraph.from_collections(name</span><span class="s0">, </span><span class="s1">layer</span><span class="s0">, </span><span class="s1">dependencies=[collection])</span>
    <span class="s0">return </span><span class="s1">Delayed(name</span><span class="s0">, </span><span class="s1">graph)</span>


<span class="s0">def </span><span class="s1">unpack_collections(expr):</span>
    <span class="s3">&quot;&quot;&quot;Normalize a python object and merge all sub-graphs. 
 
    - Replace ``Delayed`` with their keys 
    - Convert literals to things the schedulers can handle 
    - Extract dask graphs from all enclosed values 
 
    Parameters 
    ---------- 
    expr : object 
        The object to be normalized. This function knows how to handle 
        dask collections, as well as most builtin python types. 
 
    Returns 
    ------- 
    task : normalized task to be run 
    collections : a tuple of collections 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import dask 
    &gt;&gt;&gt; a = delayed(1, 'a') 
    &gt;&gt;&gt; b = delayed(2, 'b') 
    &gt;&gt;&gt; task, collections = unpack_collections([a, b, 3]) 
    &gt;&gt;&gt; task 
    ['a', 'b', 3] 
    &gt;&gt;&gt; collections 
    (Delayed('a'), Delayed('b')) 
 
    &gt;&gt;&gt; task, collections = unpack_collections({a: 1, b: 2}) 
    &gt;&gt;&gt; task 
    (&lt;class 'dict'&gt;, [['a', 1], ['b', 2]]) 
    &gt;&gt;&gt; collections 
    (Delayed('a'), Delayed('b')) 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance(expr</span><span class="s0">, </span><span class="s1">Delayed):</span>
        <span class="s0">return </span><span class="s1">expr._key</span><span class="s0">, </span><span class="s1">(expr</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">is_dask_collection(expr):</span>
        <span class="s1">finalized = finalize(expr)</span>
        <span class="s0">return </span><span class="s1">finalized._key</span><span class="s0">, </span><span class="s1">(finalized</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">type(expr) </span><span class="s0">is </span><span class="s1">type(iter(list())):</span>
        <span class="s1">expr = list(expr)</span>
    <span class="s0">elif </span><span class="s1">type(expr) </span><span class="s0">is </span><span class="s1">type(iter(tuple())):</span>
        <span class="s1">expr = tuple(expr)</span>
    <span class="s0">elif </span><span class="s1">type(expr) </span><span class="s0">is </span><span class="s1">type(iter(set())):</span>
        <span class="s1">expr = set(expr)</span>

    <span class="s1">typ = type(expr)</span>

    <span class="s0">if </span><span class="s1">typ </span><span class="s0">in </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">tuple</span><span class="s0">, </span><span class="s1">set):</span>
        <span class="s1">args</span><span class="s0">, </span><span class="s1">collections = unzip((unpack_collections(e) </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">expr)</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">args = list(args)</span>
        <span class="s1">collections = tuple(unique(concat(collections)</span><span class="s0">, </span><span class="s1">key=id))</span>
        <span class="s5"># Ensure output type matches input type</span>
        <span class="s0">if </span><span class="s1">typ </span><span class="s0">is not </span><span class="s1">list:</span>
            <span class="s1">args = (typ</span><span class="s0">, </span><span class="s1">args)</span>
        <span class="s0">return </span><span class="s1">args</span><span class="s0">, </span><span class="s1">collections</span>

    <span class="s0">if </span><span class="s1">typ </span><span class="s0">is </span><span class="s1">dict:</span>
        <span class="s1">args</span><span class="s0">, </span><span class="s1">collections = unpack_collections([[k</span><span class="s0">, </span><span class="s1">v] </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">expr.items()])</span>
        <span class="s0">return </span><span class="s1">(dict</span><span class="s0">, </span><span class="s1">args)</span><span class="s0">, </span><span class="s1">collections</span>

    <span class="s0">if </span><span class="s1">typ </span><span class="s0">is </span><span class="s1">slice:</span>
        <span class="s1">args</span><span class="s0">, </span><span class="s1">collections = unpack_collections([expr.start</span><span class="s0">, </span><span class="s1">expr.stop</span><span class="s0">, </span><span class="s1">expr.step])</span>
        <span class="s0">return </span><span class="s1">(slice</span><span class="s0">, </span><span class="s1">*args)</span><span class="s0">, </span><span class="s1">collections</span>

    <span class="s0">if </span><span class="s1">is_dataclass(expr):</span>
        <span class="s1">args</span><span class="s0">, </span><span class="s1">collections = unpack_collections(</span>
            <span class="s1">[</span>
                <span class="s1">[f.name</span><span class="s0">, </span><span class="s1">getattr(expr</span><span class="s0">, </span><span class="s1">f.name)]</span>
                <span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">fields(expr)</span>
                <span class="s0">if </span><span class="s1">hasattr(expr</span><span class="s0">, </span><span class="s1">f.name)  </span><span class="s5"># if init=False, field might not exist</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s0">if not </span><span class="s1">collections:</span>
            <span class="s0">return </span><span class="s1">expr</span><span class="s0">, </span><span class="s1">()</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">_fields = {</span>
                <span class="s1">f.name: getattr(expr</span><span class="s0">, </span><span class="s1">f.name)</span>
                <span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">fields(expr)</span>
                <span class="s0">if </span><span class="s1">hasattr(expr</span><span class="s0">, </span><span class="s1">f.name)</span>
            <span class="s1">}</span>
            <span class="s1">replace(expr</span><span class="s0">, </span><span class="s1">**_fields)</span>
        <span class="s0">except </span><span class="s1">TypeError </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s2">f&quot;Failed to unpack </span><span class="s0">{</span><span class="s1">typ</span><span class="s0">} </span><span class="s2">instance. &quot;</span>
                <span class="s2">&quot;Note that using a custom __init__ is not supported.&quot;</span>
            <span class="s1">) </span><span class="s0">from </span><span class="s1">e</span>
        <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">f&quot;Failed to unpack </span><span class="s0">{</span><span class="s1">typ</span><span class="s0">} </span><span class="s2">instance. &quot;</span>
                <span class="s2">&quot;Note that using fields with `init=False` are not supported.&quot;</span>
            <span class="s1">) </span><span class="s0">from </span><span class="s1">e</span>
        <span class="s0">return </span><span class="s1">(apply</span><span class="s0">, </span><span class="s1">typ</span><span class="s0">, </span><span class="s1">()</span><span class="s0">, </span><span class="s1">(dict</span><span class="s0">, </span><span class="s1">args))</span><span class="s0">, </span><span class="s1">collections</span>

    <span class="s0">if </span><span class="s1">is_namedtuple_instance(expr):</span>
        <span class="s1">args</span><span class="s0">, </span><span class="s1">collections = unpack_collections([v </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">expr])</span>
        <span class="s0">return </span><span class="s1">(typ</span><span class="s0">, </span><span class="s1">*args)</span><span class="s0">, </span><span class="s1">collections</span>

    <span class="s0">return </span><span class="s1">expr</span><span class="s0">, </span><span class="s1">()</span>


<span class="s0">def </span><span class="s1">to_task_dask(expr):</span>
    <span class="s3">&quot;&quot;&quot;Normalize a python object and merge all sub-graphs. 
 
    - Replace ``Delayed`` with their keys 
    - Convert literals to things the schedulers can handle 
    - Extract dask graphs from all enclosed values 
 
    Parameters 
    ---------- 
    expr : object 
        The object to be normalized. This function knows how to handle 
        ``Delayed``s, as well as most builtin python types. 
 
    Returns 
    ------- 
    task : normalized task to be run 
    dask : a merged dask graph that forms the dag for this task 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import dask 
    &gt;&gt;&gt; a = delayed(1, 'a') 
    &gt;&gt;&gt; b = delayed(2, 'b') 
    &gt;&gt;&gt; task, dask = to_task_dask([a, b, 3])  # doctest: +SKIP 
    &gt;&gt;&gt; task  # doctest: +SKIP 
    ['a', 'b', 3] 
    &gt;&gt;&gt; dict(dask)  # doctest: +SKIP 
    {'a': 1, 'b': 2} 
 
    &gt;&gt;&gt; task, dasks = to_task_dask({a: 1, b: 2})  # doctest: +SKIP 
    &gt;&gt;&gt; task  # doctest: +SKIP 
    (dict, [['a', 1], ['b', 2]]) 
    &gt;&gt;&gt; dict(dask)  # doctest: +SKIP 
    {'a': 1, 'b': 2} 
    &quot;&quot;&quot;</span>
    <span class="s1">warnings.warn(</span>
        <span class="s2">&quot;The dask.delayed.to_dask_dask function has been &quot;</span>
        <span class="s2">&quot;Deprecated in favor of unpack_collections&quot;</span><span class="s0">,</span>
        <span class="s1">stacklevel=</span><span class="s4">2</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">isinstance(expr</span><span class="s0">, </span><span class="s1">Delayed):</span>
        <span class="s0">return </span><span class="s1">expr.key</span><span class="s0">, </span><span class="s1">expr.dask</span>

    <span class="s0">if </span><span class="s1">is_dask_collection(expr):</span>
        <span class="s1">name = </span><span class="s2">&quot;finalize-&quot; </span><span class="s1">+ tokenize(expr</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">keys = expr.__dask_keys__()</span>
        <span class="s1">opt = getattr(expr</span><span class="s0">, </span><span class="s2">&quot;__dask_optimize__&quot;</span><span class="s0">, </span><span class="s1">dont_optimize)</span>
        <span class="s1">finalize</span><span class="s0">, </span><span class="s1">args = expr.__dask_postcompute__()</span>
        <span class="s1">dsk = {name: (finalize</span><span class="s0">, </span><span class="s1">keys) + args}</span>
        <span class="s1">dsk.update(opt(expr.__dask_graph__()</span><span class="s0">, </span><span class="s1">keys))</span>
        <span class="s0">return </span><span class="s1">name</span><span class="s0">, </span><span class="s1">dsk</span>

    <span class="s0">if </span><span class="s1">type(expr) </span><span class="s0">is </span><span class="s1">type(iter(list())):</span>
        <span class="s1">expr = list(expr)</span>
    <span class="s0">elif </span><span class="s1">type(expr) </span><span class="s0">is </span><span class="s1">type(iter(tuple())):</span>
        <span class="s1">expr = tuple(expr)</span>
    <span class="s0">elif </span><span class="s1">type(expr) </span><span class="s0">is </span><span class="s1">type(iter(set())):</span>
        <span class="s1">expr = set(expr)</span>
    <span class="s1">typ = type(expr)</span>

    <span class="s0">if </span><span class="s1">typ </span><span class="s0">in </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">tuple</span><span class="s0">, </span><span class="s1">set):</span>
        <span class="s1">args</span><span class="s0">, </span><span class="s1">dasks = unzip((to_task_dask(e) </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">expr)</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">args = list(args)</span>
        <span class="s1">dsk = merge(dasks)</span>
        <span class="s5"># Ensure output type matches input type</span>
        <span class="s0">return </span><span class="s1">(args</span><span class="s0">, </span><span class="s1">dsk) </span><span class="s0">if </span><span class="s1">typ </span><span class="s0">is </span><span class="s1">list </span><span class="s0">else </span><span class="s1">((typ</span><span class="s0">, </span><span class="s1">args)</span><span class="s0">, </span><span class="s1">dsk)</span>

    <span class="s0">if </span><span class="s1">typ </span><span class="s0">is </span><span class="s1">dict:</span>
        <span class="s1">args</span><span class="s0">, </span><span class="s1">dsk = to_task_dask([[k</span><span class="s0">, </span><span class="s1">v] </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">expr.items()])</span>
        <span class="s0">return </span><span class="s1">(dict</span><span class="s0">, </span><span class="s1">args)</span><span class="s0">, </span><span class="s1">dsk</span>

    <span class="s0">if </span><span class="s1">is_dataclass(expr):</span>
        <span class="s1">args</span><span class="s0">, </span><span class="s1">dsk = to_task_dask(</span>
            <span class="s1">[</span>
                <span class="s1">[f.name</span><span class="s0">, </span><span class="s1">getattr(expr</span><span class="s0">, </span><span class="s1">f.name)]</span>
                <span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">fields(expr)</span>
                <span class="s0">if </span><span class="s1">hasattr(expr</span><span class="s0">, </span><span class="s1">f.name)  </span><span class="s5"># if init=False, field might not exist</span>
            <span class="s1">]</span>
        <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">(apply</span><span class="s0">, </span><span class="s1">typ</span><span class="s0">, </span><span class="s1">()</span><span class="s0">, </span><span class="s1">(dict</span><span class="s0">, </span><span class="s1">args))</span><span class="s0">, </span><span class="s1">dsk</span>

    <span class="s0">if </span><span class="s1">is_namedtuple_instance(expr):</span>
        <span class="s1">args</span><span class="s0">, </span><span class="s1">dsk = to_task_dask([v </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">expr])</span>
        <span class="s0">return </span><span class="s1">(typ</span><span class="s0">, </span><span class="s1">*args)</span><span class="s0">, </span><span class="s1">dsk</span>

    <span class="s0">if </span><span class="s1">typ </span><span class="s0">is </span><span class="s1">slice:</span>
        <span class="s1">args</span><span class="s0">, </span><span class="s1">dsk = to_task_dask([expr.start</span><span class="s0">, </span><span class="s1">expr.stop</span><span class="s0">, </span><span class="s1">expr.step])</span>
        <span class="s0">return </span><span class="s1">(slice</span><span class="s0">,</span><span class="s1">) + tuple(args)</span><span class="s0">, </span><span class="s1">dsk</span>

    <span class="s0">return </span><span class="s1">expr</span><span class="s0">, </span><span class="s1">{}</span>


<span class="s0">def </span><span class="s1">tokenize(*args</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
    <span class="s3">&quot;&quot;&quot;Mapping function from task -&gt; consistent name. 
 
    Parameters 
    ---------- 
    args : object 
        Python objects that summarize the task. 
    pure : boolean, optional 
        If True, a consistent hash function is tried on the input. If this 
        fails, then a unique identifier is used. If False (default), then a 
        unique identifier is always used. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">pure </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">pure = config.get(</span><span class="s2">&quot;delayed_pure&quot;</span><span class="s0">, False</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">pure:</span>
        <span class="s0">return </span><span class="s1">_tokenize(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">str(uuid.uuid4())</span>


<span class="s1">@curry</span>
<span class="s0">def </span><span class="s1">delayed(obj</span><span class="s0">, </span><span class="s1">name=</span><span class="s0">None, </span><span class="s1">pure=</span><span class="s0">None, </span><span class="s1">nout=</span><span class="s0">None, </span><span class="s1">traverse=</span><span class="s0">True</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Wraps a function or object to produce a ``Delayed``. 
 
    ``Delayed`` objects act as proxies for the object they wrap, but all 
    operations on them are done lazily by building up a dask graph internally. 
 
    Parameters 
    ---------- 
    obj : object 
        The function or object to wrap 
    name : Dask key, optional 
        The key to use in the underlying graph for the wrapped object. Defaults 
        to hashing content. Note that this only affects the name of the object 
        wrapped by this call to delayed, and *not* the output of delayed 
        function calls - for that use ``dask_key_name=`` as described below. 
 
        .. note:: 
 
           Because this ``name`` is used as the key in task graphs, you should 
           ensure that it uniquely identifies ``obj``. If you'd like to provide 
           a descriptive name that is still unique, combine the descriptive name 
           with :func:`dask.base.tokenize` of the ``array_like``. See 
           :ref:`graphs` for more. 
 
    pure : bool, optional 
        Indicates whether calling the resulting ``Delayed`` object is a pure 
        operation. If True, arguments to the call are hashed to produce 
        deterministic keys. If not provided, the default is to check the global 
        ``delayed_pure`` setting, and fallback to ``False`` if unset. 
    nout : int, optional 
        The number of outputs returned from calling the resulting ``Delayed`` 
        object. If provided, the ``Delayed`` output of the call can be iterated 
        into ``nout`` objects, allowing for unpacking of results. By default 
        iteration over ``Delayed`` objects will error. Note, that ``nout=1`` 
        expects ``obj`` to return a tuple of length 1, and consequently for 
        ``nout=0``, ``obj`` should return an empty tuple. 
    traverse : bool, optional 
        By default dask traverses builtin python collections looking for dask 
        objects passed to ``delayed``. For large collections this can be 
        expensive. If ``obj`` doesn't contain any dask objects, set 
        ``traverse=False`` to avoid doing this traversal. 
 
    Examples 
    -------- 
    Apply to functions to delay execution: 
 
    &gt;&gt;&gt; from dask import delayed 
    &gt;&gt;&gt; def inc(x): 
    ...     return x + 1 
 
    &gt;&gt;&gt; inc(10) 
    11 
 
    &gt;&gt;&gt; x = delayed(inc, pure=True)(10) 
    &gt;&gt;&gt; type(x) == Delayed 
    True 
    &gt;&gt;&gt; x.compute() 
    11 
 
    Can be used as a decorator: 
 
    &gt;&gt;&gt; @delayed(pure=True) 
    ... def add(a, b): 
    ...     return a + b 
    &gt;&gt;&gt; add(1, 2).compute() 
    3 
 
    ``delayed`` also accepts an optional keyword ``pure``. If False, then 
    subsequent calls will always produce a different ``Delayed``. This is 
    useful for non-pure functions (such as ``time`` or ``random``). 
 
    &gt;&gt;&gt; from random import random 
    &gt;&gt;&gt; out1 = delayed(random, pure=False)() 
    &gt;&gt;&gt; out2 = delayed(random, pure=False)() 
    &gt;&gt;&gt; out1.key == out2.key 
    False 
 
    If you know a function is pure (output only depends on the input, with no 
    global state), then you can set ``pure=True``. This will attempt to apply a 
    consistent name to the output, but will fallback on the same behavior of 
    ``pure=False`` if this fails. 
 
    &gt;&gt;&gt; @delayed(pure=True) 
    ... def add(a, b): 
    ...     return a + b 
    &gt;&gt;&gt; out1 = add(1, 2) 
    &gt;&gt;&gt; out2 = add(1, 2) 
    &gt;&gt;&gt; out1.key == out2.key 
    True 
 
    Instead of setting ``pure`` as a property of the callable, you can also set 
    it contextually using the ``delayed_pure`` setting. Note that this 
    influences the *call* and not the *creation* of the callable: 
 
    &gt;&gt;&gt; @delayed 
    ... def mul(a, b): 
    ...     return a * b 
    &gt;&gt;&gt; import dask 
    &gt;&gt;&gt; with dask.config.set(delayed_pure=True): 
    ...     print(mul(1, 2).key == mul(1, 2).key) 
    True 
    &gt;&gt;&gt; with dask.config.set(delayed_pure=False): 
    ...     print(mul(1, 2).key == mul(1, 2).key) 
    False 
 
    The key name of the result of calling a delayed object is determined by 
    hashing the arguments by default. To explicitly set the name, you can use 
    the ``dask_key_name`` keyword when calling the function: 
 
    &gt;&gt;&gt; add(1, 2)   # doctest: +SKIP 
    Delayed('add-3dce7c56edd1ac2614add714086e950f') 
    &gt;&gt;&gt; add(1, 2, dask_key_name='three') 
    Delayed('three') 
 
    Note that objects with the same key name are assumed to have the same 
    result. If you set the names explicitly you should make sure your key names 
    are different for different results. 
 
    &gt;&gt;&gt; add(1, 2, dask_key_name='three') 
    Delayed('three') 
    &gt;&gt;&gt; add(2, 1, dask_key_name='three') 
    Delayed('three') 
    &gt;&gt;&gt; add(2, 2, dask_key_name='four') 
    Delayed('four') 
 
    ``delayed`` can also be applied to objects to make operations on them lazy: 
 
    &gt;&gt;&gt; a = delayed([1, 2, 3]) 
    &gt;&gt;&gt; isinstance(a, Delayed) 
    True 
    &gt;&gt;&gt; a.compute() 
    [1, 2, 3] 
 
    The key name of a delayed object is hashed by default if ``pure=True`` or 
    is generated randomly if ``pure=False`` (default).  To explicitly set the 
    name, you can use the ``name`` keyword. To ensure that the key is unique 
    you should include the tokenized value as well, or otherwise ensure that 
    it's unique: 
 
    &gt;&gt;&gt; from dask.base import tokenize 
    &gt;&gt;&gt; data = [1, 2, 3] 
    &gt;&gt;&gt; a = delayed(data, name='mylist-' + tokenize(data)) 
    &gt;&gt;&gt; a  # doctest: +SKIP 
    Delayed('mylist-55af65871cb378a4fa6de1660c3e8fb7') 
 
    Delayed results act as a proxy to the underlying object. Many operators 
    are supported: 
 
    &gt;&gt;&gt; (a + [1, 2]).compute() 
    [1, 2, 3, 1, 2] 
    &gt;&gt;&gt; a[1].compute() 
    2 
 
    Method and attribute access also works: 
 
    &gt;&gt;&gt; a.count(2).compute() 
    1 
 
    Note that if a method doesn't exist, no error will be thrown until runtime: 
 
    &gt;&gt;&gt; res = a.not_a_real_method() # doctest: +SKIP 
    &gt;&gt;&gt; res.compute()  # doctest: +SKIP 
    AttributeError(&quot;'list' object has no attribute 'not_a_real_method'&quot;) 
 
    &quot;Magic&quot; methods (e.g. operators and attribute access) are assumed to be 
    pure, meaning that subsequent calls must return the same results. This 
    behavior is not overrideable through the ``delayed`` call, but can be 
    modified using other ways as described below. 
 
    To invoke an impure attribute or operator, you'd need to use it in a 
    delayed function with ``pure=False``: 
 
    &gt;&gt;&gt; class Incrementer: 
    ...     def __init__(self): 
    ...         self._n = 0 
    ...     @property 
    ...     def n(self): 
    ...         self._n += 1 
    ...         return self._n 
    ... 
    &gt;&gt;&gt; x = delayed(Incrementer()) 
    &gt;&gt;&gt; x.n.key == x.n.key 
    True 
    &gt;&gt;&gt; get_n = delayed(lambda x: x.n, pure=False) 
    &gt;&gt;&gt; get_n(x).key == get_n(x).key 
    False 
 
    In contrast, methods are assumed to be impure by default, meaning that 
    subsequent calls may return different results. To assume purity, set 
    ``pure=True``. This allows sharing of any intermediate values. 
 
    &gt;&gt;&gt; a.count(2, pure=True).key == a.count(2, pure=True).key 
    True 
 
    As with function calls, method calls also respect the global 
    ``delayed_pure`` setting and support the ``dask_key_name`` keyword: 
 
    &gt;&gt;&gt; a.count(2, dask_key_name=&quot;count_2&quot;) 
    Delayed('count_2') 
    &gt;&gt;&gt; import dask 
    &gt;&gt;&gt; with dask.config.set(delayed_pure=True): 
    ...     print(a.count(2).key == a.count(2).key) 
    True 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">Delayed):</span>
        <span class="s0">return </span><span class="s1">obj</span>

    <span class="s0">if </span><span class="s1">is_dask_collection(obj) </span><span class="s0">or </span><span class="s1">traverse:</span>
        <span class="s1">task</span><span class="s0">, </span><span class="s1">collections = unpack_collections(obj)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">task = quote(obj)</span>
        <span class="s1">collections = set()</span>

    <span class="s0">if not </span><span class="s1">(nout </span><span class="s0">is None or </span><span class="s1">(type(nout) </span><span class="s0">is </span><span class="s1">int </span><span class="s0">and </span><span class="s1">nout &gt;= </span><span class="s4">0</span><span class="s1">)):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;nout must be None or a non-negative integer, got %s&quot; </span><span class="s1">% nout)</span>
    <span class="s0">if </span><span class="s1">task </span><span class="s0">is </span><span class="s1">obj:</span>
        <span class="s0">if not </span><span class="s1">name:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">prefix = obj.__name__</span>
            <span class="s0">except </span><span class="s1">AttributeError:</span>
                <span class="s1">prefix = type(obj).__name__</span>
            <span class="s1">token = tokenize(obj</span><span class="s0">, </span><span class="s1">nout</span><span class="s0">, </span><span class="s1">pure=pure)</span>
            <span class="s1">name = </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">prefix</span><span class="s0">}</span><span class="s2">-</span><span class="s0">{</span><span class="s1">token</span><span class="s0">}</span><span class="s2">&quot;</span>
        <span class="s0">return </span><span class="s1">DelayedLeaf(obj</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">pure=pure</span><span class="s0">, </span><span class="s1">nout=nout)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">if not </span><span class="s1">name:</span>
            <span class="s1">name = </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">type(obj).__name__</span><span class="s0">}</span><span class="s2">-</span><span class="s0">{</span><span class="s1">tokenize(task</span><span class="s0">, </span><span class="s1">pure=pure)</span><span class="s0">}</span><span class="s2">&quot;</span>
        <span class="s1">layer = {name: task}</span>
        <span class="s1">graph = HighLevelGraph.from_collections(name</span><span class="s0">, </span><span class="s1">layer</span><span class="s0">, </span><span class="s1">dependencies=collections)</span>
        <span class="s0">return </span><span class="s1">Delayed(name</span><span class="s0">, </span><span class="s1">graph</span><span class="s0">, </span><span class="s1">nout)</span>


<span class="s0">def </span><span class="s1">_swap(method</span><span class="s0">, </span><span class="s1">self</span><span class="s0">, </span><span class="s1">other):</span>
    <span class="s0">return </span><span class="s1">method(other</span><span class="s0">, </span><span class="s1">self)</span>


<span class="s0">def </span><span class="s1">right(method):</span>
    <span class="s3">&quot;&quot;&quot;Wrapper to create 'right' version of operator given left version&quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">partial(_swap</span><span class="s0">, </span><span class="s1">method)</span>


<span class="s0">def </span><span class="s1">optimize(dsk</span><span class="s0">, </span><span class="s1">keys</span><span class="s0">, </span><span class="s1">**kwargs):</span>
    <span class="s0">if not </span><span class="s1">isinstance(keys</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">set)):</span>
        <span class="s1">keys = [keys]</span>
    <span class="s0">if not </span><span class="s1">isinstance(dsk</span><span class="s0">, </span><span class="s1">HighLevelGraph):</span>
        <span class="s1">dsk = HighLevelGraph.from_collections(id(dsk)</span><span class="s0">, </span><span class="s1">dsk</span><span class="s0">, </span><span class="s1">dependencies=())</span>
    <span class="s1">dsk = dsk.cull(set(flatten(keys)))</span>
    <span class="s0">return </span><span class="s1">dsk</span>


<span class="s0">class </span><span class="s1">Delayed(DaskMethodsMixin</span><span class="s0">, </span><span class="s1">OperatorMethodMixin):</span>
    <span class="s3">&quot;&quot;&quot;Represents a value to be computed by dask. 
 
    Equivalent to the output from a single key in a dask graph. 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = (</span><span class="s2">&quot;_key&quot;</span><span class="s0">, </span><span class="s2">&quot;_dask&quot;</span><span class="s0">, </span><span class="s2">&quot;_length&quot;</span><span class="s0">, </span><span class="s2">&quot;_layer&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">dsk</span><span class="s0">, </span><span class="s1">length=</span><span class="s0">None, </span><span class="s1">layer=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">self._key = key</span>
        <span class="s1">self._dask = dsk</span>
        <span class="s1">self._length = length</span>

        <span class="s5"># NOTE: Layer is used by `to_delayed` in other collections, but not in normal Delayed use</span>
        <span class="s1">self._layer = layer </span><span class="s0">or </span><span class="s1">key</span>
        <span class="s0">if </span><span class="s1">isinstance(dsk</span><span class="s0">, </span><span class="s1">HighLevelGraph) </span><span class="s0">and </span><span class="s1">self._layer </span><span class="s0">not in </span><span class="s1">dsk.layers:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">f&quot;Layer </span><span class="s0">{</span><span class="s1">self._layer</span><span class="s0">} </span><span class="s2">not in the HighLevelGraph's layers: </span><span class="s0">{</span><span class="s1">list(dsk.layers)</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">key(self):</span>
        <span class="s0">return </span><span class="s1">self._key</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">dask(self):</span>
        <span class="s0">return </span><span class="s1">self._dask</span>

    <span class="s0">def </span><span class="s1">__dask_graph__(self) -&gt; Graph:</span>
        <span class="s0">return </span><span class="s1">self.dask</span>

    <span class="s0">def </span><span class="s1">__dask_keys__(self) -&gt; NestedKeys:</span>
        <span class="s0">return </span><span class="s1">[self.key]</span>

    <span class="s0">def </span><span class="s1">__dask_layers__(self) -&gt; Sequence[str]:</span>
        <span class="s0">return </span><span class="s1">(self._layer</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__dask_tokenize__(self):</span>
        <span class="s0">return </span><span class="s1">self.key</span>

    <span class="s1">__dask_scheduler__ = staticmethod(DEFAULT_GET)</span>
    <span class="s1">__dask_optimize__ = globalmethod(optimize</span><span class="s0">, </span><span class="s1">key=</span><span class="s2">&quot;delayed_optimize&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__dask_postcompute__(self):</span>
        <span class="s0">return </span><span class="s1">single_key</span><span class="s0">, </span><span class="s1">()</span>

    <span class="s0">def </span><span class="s1">__dask_postpersist__(self):</span>
        <span class="s0">return </span><span class="s1">self._rebuild</span><span class="s0">, </span><span class="s1">()</span>

    <span class="s0">def </span><span class="s1">_rebuild(self</span><span class="s0">, </span><span class="s1">dsk</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">rename=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">key = replace_name_in_key(self.key</span><span class="s0">, </span><span class="s1">rename) </span><span class="s0">if </span><span class="s1">rename </span><span class="s0">else </span><span class="s1">self.key</span>
        <span class="s0">if </span><span class="s1">isinstance(dsk</span><span class="s0">, </span><span class="s1">HighLevelGraph) </span><span class="s0">and </span><span class="s1">len(dsk.layers) == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s5"># FIXME Delayed is currently the only collection type that supports both high- and low-level graphs.</span>
            <span class="s5"># The HLG output of `optimize` will have a layer name that doesn't match `key`.</span>
            <span class="s5"># Remove this when Delayed is HLG-only (because `optimize` will only be passed HLGs, so it won't have</span>
            <span class="s5"># to generate random layer names).</span>
            <span class="s1">layer = next(iter(dsk.layers))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">layer = </span><span class="s0">None</span>
        <span class="s0">return </span><span class="s1">Delayed(key</span><span class="s0">, </span><span class="s1">dsk</span><span class="s0">, </span><span class="s1">self._length</span><span class="s0">, </span><span class="s1">layer=layer)</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s2">f&quot;Delayed(</span><span class="s0">{</span><span class="s1">repr(self.key)</span><span class="s0">}</span><span class="s2">)&quot;</span>

    <span class="s0">def </span><span class="s1">__hash__(self):</span>
        <span class="s0">return </span><span class="s1">hash(self.key)</span>

    <span class="s0">def </span><span class="s1">__dir__(self):</span>
        <span class="s0">return </span><span class="s1">dir(type(self))</span>

    <span class="s0">def </span><span class="s1">__getattr__(self</span><span class="s0">, </span><span class="s1">attr):</span>
        <span class="s0">if </span><span class="s1">attr.startswith(</span><span class="s2">&quot;_&quot;</span><span class="s1">):</span>
            <span class="s0">raise </span><span class="s1">AttributeError(</span><span class="s2">f&quot;Attribute </span><span class="s0">{</span><span class="s1">attr</span><span class="s0">} </span><span class="s2">not found&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">attr == </span><span class="s2">&quot;visualise&quot;</span><span class="s1">:</span>
            <span class="s5"># added to warn users in case of spelling error</span>
            <span class="s5"># for more details: https://github.com/dask/dask/issues/5721</span>
            <span class="s1">warnings.warn(</span>
                <span class="s2">&quot;dask.delayed objects have no `visualise` method. &quot;</span>
                <span class="s2">&quot;Perhaps you meant `visualize`?&quot;</span>
            <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">DelayedAttr(self</span><span class="s0">, </span><span class="s1">attr)</span>

    <span class="s0">def </span><span class="s1">__setattr__(self</span><span class="s0">, </span><span class="s1">attr</span><span class="s0">, </span><span class="s1">val):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">object.__setattr__(self</span><span class="s0">, </span><span class="s1">attr</span><span class="s0">, </span><span class="s1">val)</span>
        <span class="s0">except </span><span class="s1">AttributeError:</span>
            <span class="s5"># attr is neither in type(self).__slots__ nor in the __slots__ of any of its</span>
            <span class="s5"># parent classes, and all the parent classes define __slots__ too.</span>
            <span class="s5"># This last bit needs to be unit tested: if any of the parent classes omit</span>
            <span class="s5"># the __slots__ declaration, self will gain a __dict__ and this branch will</span>
            <span class="s5"># become unreachable.</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Delayed objects are immutable&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__setitem__(self</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">val):</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Delayed objects are immutable&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__iter__(self):</span>
        <span class="s0">if </span><span class="s1">self._length </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Delayed objects of unspecified length are not iterable&quot;</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(self._length):</span>
            <span class="s0">yield </span><span class="s1">self[i]</span>

    <span class="s0">def </span><span class="s1">__len__(self):</span>
        <span class="s0">if </span><span class="s1">self._length </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Delayed objects of unspecified length have no len()&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self._length</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">None, </span><span class="s1">dask_key_name=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
        <span class="s1">func = delayed(apply</span><span class="s0">, </span><span class="s1">pure=pure)</span>
        <span class="s0">if </span><span class="s1">dask_key_name </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">func(self</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">kwargs</span><span class="s0">, </span><span class="s1">dask_key_name=dask_key_name)</span>
        <span class="s0">return </span><span class="s1">func(self</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">kwargs)</span>

    <span class="s0">def </span><span class="s1">__bool__(self):</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Truth of Delayed objects is not supported&quot;</span><span class="s1">)</span>

    <span class="s1">__nonzero__ = __bool__</span>

    <span class="s0">def </span><span class="s1">__get__(self</span><span class="s0">, </span><span class="s1">instance</span><span class="s0">, </span><span class="s1">cls):</span>
        <span class="s0">if </span><span class="s1">instance </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self</span>
        <span class="s0">return </span><span class="s1">types.MethodType(self</span><span class="s0">, </span><span class="s1">instance)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">_get_binary_operator(cls</span><span class="s0">, </span><span class="s1">op</span><span class="s0">, </span><span class="s1">inv=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s1">method = delayed(right(op) </span><span class="s0">if </span><span class="s1">inv </span><span class="s0">else </span><span class="s1">op</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">return lambda </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs: method(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s1">_get_unary_operator = _get_binary_operator</span>


<span class="s0">def </span><span class="s1">call_function(func</span><span class="s0">, </span><span class="s1">func_token</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">kwargs</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">None, </span><span class="s1">nout=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s1">dask_key_name = kwargs.pop(</span><span class="s2">&quot;dask_key_name&quot;</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s1">pure = kwargs.pop(</span><span class="s2">&quot;pure&quot;</span><span class="s0">, </span><span class="s1">pure)</span>

    <span class="s0">if </span><span class="s1">dask_key_name </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">name = </span><span class="s2">&quot;{}-{}&quot;</span><span class="s1">.format(</span>
            <span class="s1">funcname(func)</span><span class="s0">,</span>
            <span class="s1">tokenize(func_token</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">pure=pure</span><span class="s0">, </span><span class="s1">**kwargs)</span><span class="s0">,</span>
        <span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">name = dask_key_name</span>

    <span class="s1">args2</span><span class="s0">, </span><span class="s1">collections = unzip(map(unpack_collections</span><span class="s0">, </span><span class="s1">args)</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">collections = list(concat(collections))</span>

    <span class="s0">if </span><span class="s1">kwargs:</span>
        <span class="s1">dask_kwargs</span><span class="s0">, </span><span class="s1">collections2 = unpack_collections(kwargs)</span>
        <span class="s1">collections.extend(collections2)</span>
        <span class="s1">task = (apply</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">list(args2)</span><span class="s0">, </span><span class="s1">dask_kwargs)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">task = (func</span><span class="s0">,</span><span class="s1">) + args2</span>

    <span class="s1">graph = HighLevelGraph.from_collections(</span>
        <span class="s1">name</span><span class="s0">, </span><span class="s1">{name: task}</span><span class="s0">, </span><span class="s1">dependencies=collections</span>
    <span class="s1">)</span>
    <span class="s1">nout = nout </span><span class="s0">if </span><span class="s1">nout </span><span class="s0">is not None else None</span>
    <span class="s0">return </span><span class="s1">Delayed(name</span><span class="s0">, </span><span class="s1">graph</span><span class="s0">, </span><span class="s1">length=nout)</span>


<span class="s0">class </span><span class="s1">DelayedLeaf(Delayed):</span>
    <span class="s1">__slots__ = (</span><span class="s2">&quot;_obj&quot;</span><span class="s0">, </span><span class="s2">&quot;_pure&quot;</span><span class="s0">, </span><span class="s2">&quot;_nout&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">obj</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">None, </span><span class="s1">nout=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">super().__init__(key</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">self._obj = obj</span>
        <span class="s1">self._pure = pure</span>
        <span class="s1">self._nout = nout</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">dask(self):</span>
        <span class="s0">return </span><span class="s1">HighLevelGraph.from_collections(</span>
            <span class="s1">self._key</span><span class="s0">, </span><span class="s1">{self._key: self._obj}</span><span class="s0">, </span><span class="s1">dependencies=()</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">return </span><span class="s1">call_function(</span>
            <span class="s1">self._obj</span><span class="s0">, </span><span class="s1">self._key</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">kwargs</span><span class="s0">, </span><span class="s1">pure=self._pure</span><span class="s0">, </span><span class="s1">nout=self._nout</span>
        <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">__name__(self):</span>
        <span class="s0">return </span><span class="s1">self._obj.__name__</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">__doc__(self):</span>
        <span class="s0">return </span><span class="s1">self._obj.__doc__</span>


<span class="s0">class </span><span class="s1">DelayedAttr(Delayed):</span>
    <span class="s1">__slots__ = (</span><span class="s2">&quot;_obj&quot;</span><span class="s0">, </span><span class="s2">&quot;_attr&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">obj</span><span class="s0">, </span><span class="s1">attr):</span>
        <span class="s1">key = </span><span class="s2">&quot;getattr-%s&quot; </span><span class="s1">% tokenize(obj</span><span class="s0">, </span><span class="s1">attr</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">super().__init__(key</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">self._obj = obj</span>
        <span class="s1">self._attr = attr</span>

    <span class="s0">def </span><span class="s1">__getattr__(self</span><span class="s0">, </span><span class="s1">attr):</span>
        <span class="s5"># Calling np.dtype(dask.delayed(...)) used to result in a segfault, as</span>
        <span class="s5"># numpy recursively tries to get `dtype` from the object. This is</span>
        <span class="s5"># likely a bug in numpy. For now, we can do a dumb for if</span>
        <span class="s5"># `x.dtype().dtype()` is called (which shouldn't ever show up in real</span>
        <span class="s5"># code). See https://github.com/dask/dask/pull/4374#issuecomment-454381465</span>
        <span class="s0">if </span><span class="s1">attr == </span><span class="s2">&quot;dtype&quot; </span><span class="s0">and </span><span class="s1">self._attr == </span><span class="s2">&quot;dtype&quot;</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">AttributeError(</span><span class="s2">&quot;Attribute dtype not found&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">super().__getattr__(attr)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">dask(self):</span>
        <span class="s1">layer = {self._key: (getattr</span><span class="s0">, </span><span class="s1">self._obj._key</span><span class="s0">, </span><span class="s1">self._attr)}</span>
        <span class="s0">return </span><span class="s1">HighLevelGraph.from_collections(</span>
            <span class="s1">self._key</span><span class="s0">, </span><span class="s1">layer</span><span class="s0">, </span><span class="s1">dependencies=[self._obj]</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">return </span><span class="s1">call_function(</span>
            <span class="s1">methodcaller(self._attr)</span><span class="s0">, </span><span class="s1">self._attr</span><span class="s0">, </span><span class="s1">(self._obj</span><span class="s0">,</span><span class="s1">) + args</span><span class="s0">, </span><span class="s1">kwargs</span>
        <span class="s1">)</span>


<span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">[</span>
    <span class="s1">operator.abs</span><span class="s0">,</span>
    <span class="s1">operator.neg</span><span class="s0">,</span>
    <span class="s1">operator.pos</span><span class="s0">,</span>
    <span class="s1">operator.invert</span><span class="s0">,</span>
    <span class="s1">operator.add</span><span class="s0">,</span>
    <span class="s1">operator.sub</span><span class="s0">,</span>
    <span class="s1">operator.mul</span><span class="s0">,</span>
    <span class="s1">operator.floordiv</span><span class="s0">,</span>
    <span class="s1">operator.truediv</span><span class="s0">,</span>
    <span class="s1">operator.mod</span><span class="s0">,</span>
    <span class="s1">operator.pow</span><span class="s0">,</span>
    <span class="s1">operator.and_</span><span class="s0">,</span>
    <span class="s1">operator.or_</span><span class="s0">,</span>
    <span class="s1">operator.xor</span><span class="s0">,</span>
    <span class="s1">operator.lshift</span><span class="s0">,</span>
    <span class="s1">operator.rshift</span><span class="s0">,</span>
    <span class="s1">operator.eq</span><span class="s0">,</span>
    <span class="s1">operator.ge</span><span class="s0">,</span>
    <span class="s1">operator.gt</span><span class="s0">,</span>
    <span class="s1">operator.ne</span><span class="s0">,</span>
    <span class="s1">operator.le</span><span class="s0">,</span>
    <span class="s1">operator.lt</span><span class="s0">,</span>
    <span class="s1">operator.getitem</span><span class="s0">,</span>
<span class="s1">]:</span>
    <span class="s1">Delayed._bind_operator(op)</span>


<span class="s0">try</span><span class="s1">:</span>
    <span class="s1">Delayed._bind_operator(operator.matmul)</span>
<span class="s0">except </span><span class="s1">AttributeError:</span>
    <span class="s0">pass</span>


<span class="s0">def </span><span class="s1">single_key(seq):</span>
    <span class="s3">&quot;&quot;&quot;Pick out the only element of this list, a list of keys&quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">seq[</span><span class="s4">0</span><span class="s1">]</span>
</pre>
</body>
</html>