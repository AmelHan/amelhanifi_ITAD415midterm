<html>
<head>
<title>_mathtext.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_mathtext.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Implementation details for :mod:`.mathtext`. 
&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">import </span><span class="s1">abc</span>
<span class="s2">import </span><span class="s1">copy</span>
<span class="s2">import </span><span class="s1">enum</span>
<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">types</span>
<span class="s2">import </span><span class="s1">unicodedata</span>
<span class="s2">import </span><span class="s1">string</span>
<span class="s2">import </span><span class="s1">typing </span><span class="s2">as </span><span class="s1">T</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">NamedTuple</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">pyparsing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Empty</span><span class="s2">, </span><span class="s1">Forward</span><span class="s2">, </span><span class="s1">Literal</span><span class="s2">, </span><span class="s1">NotAny</span><span class="s2">, </span><span class="s1">oneOf</span><span class="s2">, </span><span class="s1">OneOrMore</span><span class="s2">, </span><span class="s1">Optional</span><span class="s2">,</span>
    <span class="s1">ParseBaseException</span><span class="s2">, </span><span class="s1">ParseException</span><span class="s2">, </span><span class="s1">ParseExpression</span><span class="s2">, </span><span class="s1">ParseFatalException</span><span class="s2">,</span>
    <span class="s1">ParserElement</span><span class="s2">, </span><span class="s1">ParseResults</span><span class="s2">, </span><span class="s1">QuotedString</span><span class="s2">, </span><span class="s1">Regex</span><span class="s2">, </span><span class="s1">StringEnd</span><span class="s2">, </span><span class="s1">ZeroOrMore</span><span class="s2">,</span>
    <span class="s1">pyparsing_common</span><span class="s2">, </span><span class="s1">Group)</span>

<span class="s2">import </span><span class="s1">matplotlib </span><span class="s2">as </span><span class="s1">mpl</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">cbook</span>
<span class="s2">from </span><span class="s1">._mathtext_data </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">latex_to_bakoma</span><span class="s2">, </span><span class="s1">stix_glyph_fixes</span><span class="s2">, </span><span class="s1">stix_virtual_fonts</span><span class="s2">, </span><span class="s1">tex2uni)</span>
<span class="s2">from </span><span class="s1">.font_manager </span><span class="s2">import </span><span class="s1">FontProperties</span><span class="s2">, </span><span class="s1">findfont</span><span class="s2">, </span><span class="s1">get_font</span>
<span class="s2">from </span><span class="s1">.ft2font </span><span class="s2">import </span><span class="s1">FT2Font</span><span class="s2">, </span><span class="s1">FT2Image</span><span class="s2">, </span><span class="s1">KERNING_DEFAULT</span>

<span class="s2">from </span><span class="s1">packaging.version </span><span class="s2">import </span><span class="s1">parse </span><span class="s2">as </span><span class="s1">parse_version</span>
<span class="s2">from </span><span class="s1">pyparsing </span><span class="s2">import </span><span class="s1">__version__ </span><span class="s2">as </span><span class="s1">pyparsing_version</span>
<span class="s2">if </span><span class="s1">parse_version(pyparsing_version).major &lt; </span><span class="s3">3</span><span class="s1">:</span>
    <span class="s2">from </span><span class="s1">pyparsing </span><span class="s2">import </span><span class="s1">nestedExpr </span><span class="s2">as </span><span class="s1">nested_expr</span>
<span class="s2">else</span><span class="s1">:</span>
    <span class="s2">from </span><span class="s1">pyparsing </span><span class="s2">import </span><span class="s1">nested_expr</span>

<span class="s2">if </span><span class="s1">T.TYPE_CHECKING:</span>
    <span class="s2">from </span><span class="s1">collections.abc </span><span class="s2">import </span><span class="s1">Iterable</span>
    <span class="s2">from </span><span class="s1">.ft2font </span><span class="s2">import </span><span class="s1">Glyph</span>

<span class="s1">ParserElement.enablePackrat()</span>
<span class="s1">_log = logging.getLogger(</span><span class="s4">&quot;matplotlib.mathtext&quot;</span><span class="s1">)</span>


<span class="s5">##############################################################################</span>
<span class="s5"># FONTS</span>


<span class="s2">def </span><span class="s1">get_unicode_index(symbol: str) -&gt; int:  </span><span class="s5"># Publicly exported.</span>
    <span class="s0">r&quot;&quot;&quot; 
    Return the integer index (from the Unicode table) of *symbol*. 
 
    Parameters 
    ---------- 
    symbol : str 
        A single (Unicode) character, a TeX command (e.g. r'\pi') or a Type1 
        symbol name (e.g. 'phi'). 
    &quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s1">:  </span><span class="s5"># This will succeed if symbol is a single Unicode char</span>
        <span class="s2">return </span><span class="s1">ord(symbol)</span>
    <span class="s2">except </span><span class="s1">TypeError:</span>
        <span class="s2">pass</span>
    <span class="s2">try</span><span class="s1">:  </span><span class="s5"># Is symbol a TeX symbol (i.e. \alpha)</span>
        <span class="s2">return </span><span class="s1">tex2uni[symbol.strip(</span><span class="s4">&quot;</span><span class="s2">\\</span><span class="s4">&quot;</span><span class="s1">)]</span>
    <span class="s2">except </span><span class="s1">KeyError </span><span class="s2">as </span><span class="s1">err:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">symbol</span><span class="s2">!r} </span><span class="s4">is not a valid Unicode character or TeX/Type1 symbol&quot;</span>
            <span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>


<span class="s2">class </span><span class="s1">VectorParse(NamedTuple):</span>
    <span class="s0">&quot;&quot;&quot; 
    The namedtuple type returned by ``MathTextParser(&quot;path&quot;).parse(...)``. 
 
    Attributes 
    ---------- 
    width, height, depth : float 
        The global metrics. 
    glyphs : list 
        The glyphs including their positions. 
    rect : list 
        The list of rectangles. 
    &quot;&quot;&quot;</span>
    <span class="s1">width: float</span>
    <span class="s1">height: float</span>
    <span class="s1">depth: float</span>
    <span class="s1">glyphs: list[tuple[FT2Font</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">float]]</span>
    <span class="s1">rects: list[tuple[float</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">float]]</span>

<span class="s1">VectorParse.__module__ = </span><span class="s4">&quot;matplotlib.mathtext&quot;</span>


<span class="s2">class </span><span class="s1">RasterParse(NamedTuple):</span>
    <span class="s0">&quot;&quot;&quot; 
    The namedtuple type returned by ``MathTextParser(&quot;agg&quot;).parse(...)``. 
 
    Attributes 
    ---------- 
    ox, oy : float 
        The offsets are always zero. 
    width, height, depth : float 
        The global metrics. 
    image : FT2Image 
        A raster image. 
    &quot;&quot;&quot;</span>
    <span class="s1">ox: float</span>
    <span class="s1">oy: float</span>
    <span class="s1">width: float</span>
    <span class="s1">height: float</span>
    <span class="s1">depth: float</span>
    <span class="s1">image: FT2Image</span>

<span class="s1">RasterParse.__module__ = </span><span class="s4">&quot;matplotlib.mathtext&quot;</span>


<span class="s2">class </span><span class="s1">Output:</span>
    <span class="s0">r&quot;&quot;&quot; 
    Result of `ship`\ping a box: lists of positioned glyphs and rectangles. 
 
    This class is not exposed to end users, but converted to a `VectorParse` or 
    a `RasterParse` by `.MathTextParser.parse`. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">box: Box):</span>
        <span class="s1">self.box = box</span>
        <span class="s1">self.glyphs: list[tuple[float</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">FontInfo]] = []  </span><span class="s5"># (ox, oy, info)</span>
        <span class="s1">self.rects: list[tuple[float</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">float]] = []  </span><span class="s5"># (x1, y1, x2, y2)</span>

    <span class="s2">def </span><span class="s1">to_vector(self) -&gt; VectorParse:</span>
        <span class="s1">w</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">d = map(</span>
            <span class="s1">np.ceil</span><span class="s2">, </span><span class="s1">[self.box.width</span><span class="s2">, </span><span class="s1">self.box.height</span><span class="s2">, </span><span class="s1">self.box.depth])</span>
        <span class="s1">gs = [(info.font</span><span class="s2">, </span><span class="s1">info.fontsize</span><span class="s2">, </span><span class="s1">info.num</span><span class="s2">, </span><span class="s1">ox</span><span class="s2">, </span><span class="s1">h - oy + info.offset)</span>
              <span class="s2">for </span><span class="s1">ox</span><span class="s2">, </span><span class="s1">oy</span><span class="s2">, </span><span class="s1">info </span><span class="s2">in </span><span class="s1">self.glyphs]</span>
        <span class="s1">rs = [(x1</span><span class="s2">, </span><span class="s1">h - y2</span><span class="s2">, </span><span class="s1">x2 - x1</span><span class="s2">, </span><span class="s1">y2 - y1)</span>
              <span class="s2">for </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">y2 </span><span class="s2">in </span><span class="s1">self.rects]</span>
        <span class="s2">return </span><span class="s1">VectorParse(w</span><span class="s2">, </span><span class="s1">h + d</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">gs</span><span class="s2">, </span><span class="s1">rs)</span>

    <span class="s2">def </span><span class="s1">to_raster(self</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">antialiased: bool) -&gt; RasterParse:</span>
        <span class="s5"># Metrics y's and mathtext y's are oriented in opposite directions,</span>
        <span class="s5"># hence the switch between ymin and ymax.</span>
        <span class="s1">xmin = min([*[ox + info.metrics.xmin </span><span class="s2">for </span><span class="s1">ox</span><span class="s2">, </span><span class="s1">oy</span><span class="s2">, </span><span class="s1">info </span><span class="s2">in </span><span class="s1">self.glyphs]</span><span class="s2">,</span>
                    <span class="s1">*[x1 </span><span class="s2">for </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">y2 </span><span class="s2">in </span><span class="s1">self.rects]</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]) - </span><span class="s3">1</span>
        <span class="s1">ymin = min([*[oy - info.metrics.ymax </span><span class="s2">for </span><span class="s1">ox</span><span class="s2">, </span><span class="s1">oy</span><span class="s2">, </span><span class="s1">info </span><span class="s2">in </span><span class="s1">self.glyphs]</span><span class="s2">,</span>
                    <span class="s1">*[y1 </span><span class="s2">for </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">y2 </span><span class="s2">in </span><span class="s1">self.rects]</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]) - </span><span class="s3">1</span>
        <span class="s1">xmax = max([*[ox + info.metrics.xmax </span><span class="s2">for </span><span class="s1">ox</span><span class="s2">, </span><span class="s1">oy</span><span class="s2">, </span><span class="s1">info </span><span class="s2">in </span><span class="s1">self.glyphs]</span><span class="s2">,</span>
                    <span class="s1">*[x2 </span><span class="s2">for </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">y2 </span><span class="s2">in </span><span class="s1">self.rects]</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]) + </span><span class="s3">1</span>
        <span class="s1">ymax = max([*[oy - info.metrics.ymin </span><span class="s2">for </span><span class="s1">ox</span><span class="s2">, </span><span class="s1">oy</span><span class="s2">, </span><span class="s1">info </span><span class="s2">in </span><span class="s1">self.glyphs]</span><span class="s2">,</span>
                    <span class="s1">*[y2 </span><span class="s2">for </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">y2 </span><span class="s2">in </span><span class="s1">self.rects]</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]) + </span><span class="s3">1</span>
        <span class="s1">w = xmax - xmin</span>
        <span class="s1">h = ymax - ymin - self.box.depth</span>
        <span class="s1">d = ymax - ymin - self.box.height</span>
        <span class="s1">image = FT2Image(np.ceil(w)</span><span class="s2">, </span><span class="s1">np.ceil(h + max(d</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)))</span>

        <span class="s5"># Ideally, we could just use self.glyphs and self.rects here, shifting</span>
        <span class="s5"># their coordinates by (-xmin, -ymin), but this yields slightly</span>
        <span class="s5"># different results due to floating point slop; shipping twice is the</span>
        <span class="s5"># old approach and keeps baseline images backcompat.</span>
        <span class="s1">shifted = ship(self.box</span><span class="s2">, </span><span class="s1">(-xmin</span><span class="s2">, </span><span class="s1">-ymin))</span>

        <span class="s2">for </span><span class="s1">ox</span><span class="s2">, </span><span class="s1">oy</span><span class="s2">, </span><span class="s1">info </span><span class="s2">in </span><span class="s1">shifted.glyphs:</span>
            <span class="s1">info.font.draw_glyph_to_bitmap(</span>
                <span class="s1">image</span><span class="s2">, </span><span class="s1">ox</span><span class="s2">, </span><span class="s1">oy - info.metrics.iceberg</span><span class="s2">, </span><span class="s1">info.glyph</span><span class="s2">,</span>
                <span class="s1">antialiased=antialiased)</span>
        <span class="s2">for </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">y2 </span><span class="s2">in </span><span class="s1">shifted.rects:</span>
            <span class="s1">height = max(int(y2 - y1) - </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">height == </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s1">center = (y2 + y1) / </span><span class="s3">2</span>
                <span class="s1">y = int(center - (height + </span><span class="s3">1</span><span class="s1">) / </span><span class="s3">2</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">y = int(y1)</span>
            <span class="s1">image.draw_rect_filled(int(x1)</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">np.ceil(x2)</span><span class="s2">, </span><span class="s1">y + height)</span>
        <span class="s2">return </span><span class="s1">RasterParse(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">w</span><span class="s2">, </span><span class="s1">h + d</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">image)</span>


<span class="s2">class </span><span class="s1">FontMetrics(NamedTuple):</span>
    <span class="s0">&quot;&quot;&quot; 
    Metrics of a font. 
 
    Attributes 
    ---------- 
    advance : float 
        The advance distance (in points) of the glyph. 
    height : float 
        The height of the glyph in points. 
    width : float 
        The width of the glyph in points. 
    xmin, xmax, ymin, ymax : float 
        The ink rectangle of the glyph. 
    iceberg : float 
        The distance from the baseline to the top of the glyph. (This corresponds to 
        TeX's definition of &quot;height&quot;.) 
    slanted : bool 
        Whether the glyph should be considered as &quot;slanted&quot; (currently used for kerning 
        sub/superscripts). 
    &quot;&quot;&quot;</span>
    <span class="s1">advance: float</span>
    <span class="s1">height: float</span>
    <span class="s1">width: float</span>
    <span class="s1">xmin: float</span>
    <span class="s1">xmax: float</span>
    <span class="s1">ymin: float</span>
    <span class="s1">ymax: float</span>
    <span class="s1">iceberg: float</span>
    <span class="s1">slanted: bool</span>


<span class="s2">class </span><span class="s1">FontInfo(NamedTuple):</span>
    <span class="s1">font: FT2Font</span>
    <span class="s1">fontsize: float</span>
    <span class="s1">postscript_name: str</span>
    <span class="s1">metrics: FontMetrics</span>
    <span class="s1">num: int</span>
    <span class="s1">glyph: Glyph</span>
    <span class="s1">offset: float</span>


<span class="s2">class </span><span class="s1">Fonts(abc.ABC):</span>
    <span class="s0">&quot;&quot;&quot; 
    An abstract base class for a system of fonts to use for mathtext. 
 
    The class must be able to take symbol keys and font file names and 
    return the character metrics.  It also delegates to a backend class 
    to do the actual drawing. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">default_font_prop: FontProperties</span><span class="s2">, </span><span class="s1">load_glyph_flags: int):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        default_font_prop : `~.font_manager.FontProperties` 
            The default non-math font, or the base font for Unicode (generic) 
            font rendering. 
        load_glyph_flags : int 
            Flags passed to the glyph loader (e.g. ``FT_Load_Glyph`` and 
            ``FT_Load_Char`` for FreeType-based fonts). 
        &quot;&quot;&quot;</span>
        <span class="s1">self.default_font_prop = default_font_prop</span>
        <span class="s1">self.load_glyph_flags = load_glyph_flags</span>

    <span class="s2">def </span><span class="s1">get_kern(self</span><span class="s2">, </span><span class="s1">font1: str</span><span class="s2">, </span><span class="s1">fontclass1: str</span><span class="s2">, </span><span class="s1">sym1: str</span><span class="s2">, </span><span class="s1">fontsize1: float</span><span class="s2">,</span>
                 <span class="s1">font2: str</span><span class="s2">, </span><span class="s1">fontclass2: str</span><span class="s2">, </span><span class="s1">sym2: str</span><span class="s2">, </span><span class="s1">fontsize2: float</span><span class="s2">,</span>
                 <span class="s1">dpi: float) -&gt; float:</span>
        <span class="s0">&quot;&quot;&quot; 
        Get the kerning distance for font between *sym1* and *sym2*. 
 
        See `~.Fonts.get_metrics` for a detailed description of the parameters. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s3">0.</span>

    <span class="s2">def </span><span class="s1">_get_font(self</span><span class="s2">, </span><span class="s1">font: str) -&gt; FT2Font:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">_get_info(self</span><span class="s2">, </span><span class="s1">font: str</span><span class="s2">, </span><span class="s1">font_class: str</span><span class="s2">, </span><span class="s1">sym: str</span><span class="s2">, </span><span class="s1">fontsize: float</span><span class="s2">,</span>
                  <span class="s1">dpi: float) -&gt; FontInfo:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">get_metrics(self</span><span class="s2">, </span><span class="s1">font: str</span><span class="s2">, </span><span class="s1">font_class: str</span><span class="s2">, </span><span class="s1">sym: str</span><span class="s2">, </span><span class="s1">fontsize: float</span><span class="s2">,</span>
                    <span class="s1">dpi: float) -&gt; FontMetrics:</span>
        <span class="s0">r&quot;&quot;&quot; 
        Parameters 
        ---------- 
        font : str 
            One of the TeX font names: &quot;tt&quot;, &quot;it&quot;, &quot;rm&quot;, &quot;cal&quot;, &quot;sf&quot;, &quot;bf&quot;, 
            &quot;default&quot;, &quot;regular&quot;, &quot;bb&quot;, &quot;frak&quot;, &quot;scr&quot;.  &quot;default&quot; and &quot;regular&quot; 
            are synonyms and use the non-math font. 
        font_class : str 
            One of the TeX font names (as for *font*), but **not** &quot;bb&quot;, 
            &quot;frak&quot;, or &quot;scr&quot;.  This is used to combine two font classes.  The 
            only supported combination currently is ``get_metrics(&quot;frak&quot;, &quot;bf&quot;, 
            ...)``. 
        sym : str 
            A symbol in raw TeX form, e.g., &quot;1&quot;, &quot;x&quot;, or &quot;\sigma&quot;. 
        fontsize : float 
            Font size in points. 
        dpi : float 
            Rendering dots-per-inch. 
 
        Returns 
        ------- 
        FontMetrics 
        &quot;&quot;&quot;</span>
        <span class="s1">info = self._get_info(font</span><span class="s2">, </span><span class="s1">font_class</span><span class="s2">, </span><span class="s1">sym</span><span class="s2">, </span><span class="s1">fontsize</span><span class="s2">, </span><span class="s1">dpi)</span>
        <span class="s2">return </span><span class="s1">info.metrics</span>

    <span class="s2">def </span><span class="s1">render_glyph(self</span><span class="s2">, </span><span class="s1">output: Output</span><span class="s2">, </span><span class="s1">ox: float</span><span class="s2">, </span><span class="s1">oy: float</span><span class="s2">, </span><span class="s1">font: str</span><span class="s2">,</span>
                     <span class="s1">font_class: str</span><span class="s2">, </span><span class="s1">sym: str</span><span class="s2">, </span><span class="s1">fontsize: float</span><span class="s2">, </span><span class="s1">dpi: float) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        At position (*ox*, *oy*), draw the glyph specified by the remaining 
        parameters (see `get_metrics` for their detailed description). 
        &quot;&quot;&quot;</span>
        <span class="s1">info = self._get_info(font</span><span class="s2">, </span><span class="s1">font_class</span><span class="s2">, </span><span class="s1">sym</span><span class="s2">, </span><span class="s1">fontsize</span><span class="s2">, </span><span class="s1">dpi)</span>
        <span class="s1">output.glyphs.append((ox</span><span class="s2">, </span><span class="s1">oy</span><span class="s2">, </span><span class="s1">info))</span>

    <span class="s2">def </span><span class="s1">render_rect_filled(self</span><span class="s2">, </span><span class="s1">output: Output</span><span class="s2">,</span>
                           <span class="s1">x1: float</span><span class="s2">, </span><span class="s1">y1: float</span><span class="s2">, </span><span class="s1">x2: float</span><span class="s2">, </span><span class="s1">y2: float) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Draw a filled rectangle from (*x1*, *y1*) to (*x2*, *y2*). 
        &quot;&quot;&quot;</span>
        <span class="s1">output.rects.append((x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">y2))</span>

    <span class="s2">def </span><span class="s1">get_xheight(self</span><span class="s2">, </span><span class="s1">font: str</span><span class="s2">, </span><span class="s1">fontsize: float</span><span class="s2">, </span><span class="s1">dpi: float) -&gt; float:</span>
        <span class="s0">&quot;&quot;&quot; 
        Get the xheight for the given *font* and *fontsize*. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s2">def </span><span class="s1">get_underline_thickness(self</span><span class="s2">, </span><span class="s1">font: str</span><span class="s2">, </span><span class="s1">fontsize: float</span><span class="s2">, </span><span class="s1">dpi: float) -&gt; float:</span>
        <span class="s0">&quot;&quot;&quot; 
        Get the line thickness that matches the given font.  Used as a 
        base unit for drawing lines such as in a fraction or radical. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s2">def </span><span class="s1">get_sized_alternatives_for_symbol(self</span><span class="s2">, </span><span class="s1">fontname: str</span><span class="s2">,</span>
                                          <span class="s1">sym: str) -&gt; list[tuple[str</span><span class="s2">, </span><span class="s1">str]]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Override if your font provides multiple sizes of the same 
        symbol.  Should return a list of symbols matching *sym* in 
        various sizes.  The expression renderer will select the most 
        appropriate size for a given situation from this list. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">[(fontname</span><span class="s2">, </span><span class="s1">sym)]</span>


<span class="s2">class </span><span class="s1">TruetypeFonts(Fonts</span><span class="s2">, </span><span class="s1">metaclass=abc.ABCMeta):</span>
    <span class="s0">&quot;&quot;&quot; 
    A generic base class for all font setups that use Truetype fonts 
    (through FT2Font). 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">default_font_prop: FontProperties</span><span class="s2">, </span><span class="s1">load_glyph_flags: int):</span>
        <span class="s1">super().__init__(default_font_prop</span><span class="s2">, </span><span class="s1">load_glyph_flags)</span>
        <span class="s5"># Per-instance cache.</span>
        <span class="s1">self._get_info = functools.cache(self._get_info)  </span><span class="s5"># type: ignore[method-assign]</span>
        <span class="s1">self._fonts = {}</span>
        <span class="s1">self.fontmap: dict[str | int</span><span class="s2">, </span><span class="s1">str] = {}</span>

        <span class="s1">filename = findfont(self.default_font_prop)</span>
        <span class="s1">default_font = get_font(filename)</span>
        <span class="s1">self._fonts[</span><span class="s4">'default'</span><span class="s1">] = default_font</span>
        <span class="s1">self._fonts[</span><span class="s4">'regular'</span><span class="s1">] = default_font</span>

    <span class="s2">def </span><span class="s1">_get_font(self</span><span class="s2">, </span><span class="s1">font: str | int) -&gt; FT2Font:</span>
        <span class="s2">if </span><span class="s1">font </span><span class="s2">in </span><span class="s1">self.fontmap:</span>
            <span class="s1">basename = self.fontmap[font]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># NOTE: An int is only passed by subclasses which have placed int keys into</span>
            <span class="s5"># `self.fontmap`, so we must cast this to confirm it to typing.</span>
            <span class="s1">basename = T.cast(str</span><span class="s2">, </span><span class="s1">font)</span>
        <span class="s1">cached_font = self._fonts.get(basename)</span>
        <span class="s2">if </span><span class="s1">cached_font </span><span class="s2">is None and </span><span class="s1">os.path.exists(basename):</span>
            <span class="s1">cached_font = get_font(basename)</span>
            <span class="s1">self._fonts[basename] = cached_font</span>
            <span class="s1">self._fonts[cached_font.postscript_name] = cached_font</span>
            <span class="s1">self._fonts[cached_font.postscript_name.lower()] = cached_font</span>
        <span class="s2">return </span><span class="s1">T.cast(FT2Font</span><span class="s2">, </span><span class="s1">cached_font)  </span><span class="s5"># FIXME: Not sure this is guaranteed.</span>

    <span class="s2">def </span><span class="s1">_get_offset(self</span><span class="s2">, </span><span class="s1">font: FT2Font</span><span class="s2">, </span><span class="s1">glyph: Glyph</span><span class="s2">, </span><span class="s1">fontsize: float</span><span class="s2">,</span>
                    <span class="s1">dpi: float) -&gt; float:</span>
        <span class="s2">if </span><span class="s1">font.postscript_name == </span><span class="s4">'Cmex10'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">(glyph.height / </span><span class="s3">64 </span><span class="s1">/ </span><span class="s3">2</span><span class="s1">) + (fontsize/</span><span class="s3">3 </span><span class="s1">* dpi/</span><span class="s3">72</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s3">0.</span>

    <span class="s2">def </span><span class="s1">_get_glyph(self</span><span class="s2">, </span><span class="s1">fontname: str</span><span class="s2">, </span><span class="s1">font_class: str</span><span class="s2">,</span>
                   <span class="s1">sym: str) -&gt; tuple[FT2Font</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">bool]:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s5"># The return value of _get_info is cached per-instance.</span>
    <span class="s2">def </span><span class="s1">_get_info(self</span><span class="s2">, </span><span class="s1">fontname: str</span><span class="s2">, </span><span class="s1">font_class: str</span><span class="s2">, </span><span class="s1">sym: str</span><span class="s2">, </span><span class="s1">fontsize: float</span><span class="s2">,</span>
                  <span class="s1">dpi: float) -&gt; FontInfo:</span>
        <span class="s1">font</span><span class="s2">, </span><span class="s1">num</span><span class="s2">, </span><span class="s1">slanted = self._get_glyph(fontname</span><span class="s2">, </span><span class="s1">font_class</span><span class="s2">, </span><span class="s1">sym)</span>
        <span class="s1">font.set_size(fontsize</span><span class="s2">, </span><span class="s1">dpi)</span>
        <span class="s1">glyph = font.load_char(num</span><span class="s2">, </span><span class="s1">flags=self.load_glyph_flags)</span>

        <span class="s1">xmin</span><span class="s2">, </span><span class="s1">ymin</span><span class="s2">, </span><span class="s1">xmax</span><span class="s2">, </span><span class="s1">ymax = [val/</span><span class="s3">64.0 </span><span class="s2">for </span><span class="s1">val </span><span class="s2">in </span><span class="s1">glyph.bbox]</span>
        <span class="s1">offset = self._get_offset(font</span><span class="s2">, </span><span class="s1">glyph</span><span class="s2">, </span><span class="s1">fontsize</span><span class="s2">, </span><span class="s1">dpi)</span>
        <span class="s1">metrics = FontMetrics(</span>
            <span class="s1">advance = glyph.linearHoriAdvance/</span><span class="s3">65536.0</span><span class="s2">,</span>
            <span class="s1">height  = glyph.height/</span><span class="s3">64.0</span><span class="s2">,</span>
            <span class="s1">width   = glyph.width/</span><span class="s3">64.0</span><span class="s2">,</span>
            <span class="s1">xmin    = xmin</span><span class="s2">,</span>
            <span class="s1">xmax    = xmax</span><span class="s2">,</span>
            <span class="s1">ymin    = ymin+offset</span><span class="s2">,</span>
            <span class="s1">ymax    = ymax+offset</span><span class="s2">,</span>
            <span class="s5"># iceberg is the equivalent of TeX's &quot;height&quot;</span>
            <span class="s1">iceberg = glyph.horiBearingY/</span><span class="s3">64.0 </span><span class="s1">+ offset</span><span class="s2">,</span>
            <span class="s1">slanted = slanted</span>
            <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">FontInfo(</span>
            <span class="s1">font            = font</span><span class="s2">,</span>
            <span class="s1">fontsize        = fontsize</span><span class="s2">,</span>
            <span class="s1">postscript_name = font.postscript_name</span><span class="s2">,</span>
            <span class="s1">metrics         = metrics</span><span class="s2">,</span>
            <span class="s1">num             = num</span><span class="s2">,</span>
            <span class="s1">glyph           = glyph</span><span class="s2">,</span>
            <span class="s1">offset          = offset</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_xheight(self</span><span class="s2">, </span><span class="s1">fontname: str</span><span class="s2">, </span><span class="s1">fontsize: float</span><span class="s2">, </span><span class="s1">dpi: float) -&gt; float:</span>
        <span class="s1">font = self._get_font(fontname)</span>
        <span class="s1">font.set_size(fontsize</span><span class="s2">, </span><span class="s1">dpi)</span>
        <span class="s1">pclt = font.get_sfnt_table(</span><span class="s4">'pclt'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">pclt </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s5"># Some fonts don't store the xHeight, so we do a poor man's xHeight</span>
            <span class="s1">metrics = self.get_metrics(</span>
                <span class="s1">fontname</span><span class="s2">, </span><span class="s1">mpl.rcParams[</span><span class="s4">'mathtext.default'</span><span class="s1">]</span><span class="s2">, </span><span class="s4">'x'</span><span class="s2">, </span><span class="s1">fontsize</span><span class="s2">, </span><span class="s1">dpi)</span>
            <span class="s2">return </span><span class="s1">metrics.iceberg</span>
        <span class="s1">xHeight = (pclt[</span><span class="s4">'xHeight'</span><span class="s1">] / </span><span class="s3">64.0</span><span class="s1">) * (fontsize / </span><span class="s3">12.0</span><span class="s1">) * (dpi / </span><span class="s3">100.0</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">xHeight</span>

    <span class="s2">def </span><span class="s1">get_underline_thickness(self</span><span class="s2">, </span><span class="s1">font: str</span><span class="s2">, </span><span class="s1">fontsize: float</span><span class="s2">, </span><span class="s1">dpi: float) -&gt; float:</span>
        <span class="s5"># This function used to grab underline thickness from the font</span>
        <span class="s5"># metrics, but that information is just too un-reliable, so it</span>
        <span class="s5"># is now hardcoded.</span>
        <span class="s2">return </span><span class="s1">((</span><span class="s3">0.75 </span><span class="s1">/ </span><span class="s3">12.0</span><span class="s1">) * fontsize * dpi) / </span><span class="s3">72.0</span>

    <span class="s2">def </span><span class="s1">get_kern(self</span><span class="s2">, </span><span class="s1">font1: str</span><span class="s2">, </span><span class="s1">fontclass1: str</span><span class="s2">, </span><span class="s1">sym1: str</span><span class="s2">, </span><span class="s1">fontsize1: float</span><span class="s2">,</span>
                 <span class="s1">font2: str</span><span class="s2">, </span><span class="s1">fontclass2: str</span><span class="s2">, </span><span class="s1">sym2: str</span><span class="s2">, </span><span class="s1">fontsize2: float</span><span class="s2">,</span>
                 <span class="s1">dpi: float) -&gt; float:</span>
        <span class="s2">if </span><span class="s1">font1 == font2 </span><span class="s2">and </span><span class="s1">fontsize1 == fontsize2:</span>
            <span class="s1">info1 = self._get_info(font1</span><span class="s2">, </span><span class="s1">fontclass1</span><span class="s2">, </span><span class="s1">sym1</span><span class="s2">, </span><span class="s1">fontsize1</span><span class="s2">, </span><span class="s1">dpi)</span>
            <span class="s1">info2 = self._get_info(font2</span><span class="s2">, </span><span class="s1">fontclass2</span><span class="s2">, </span><span class="s1">sym2</span><span class="s2">, </span><span class="s1">fontsize2</span><span class="s2">, </span><span class="s1">dpi)</span>
            <span class="s1">font = info1.font</span>
            <span class="s2">return </span><span class="s1">font.get_kerning(info1.num</span><span class="s2">, </span><span class="s1">info2.num</span><span class="s2">, </span><span class="s1">KERNING_DEFAULT) / </span><span class="s3">64</span>
        <span class="s2">return </span><span class="s1">super().get_kern(font1</span><span class="s2">, </span><span class="s1">fontclass1</span><span class="s2">, </span><span class="s1">sym1</span><span class="s2">, </span><span class="s1">fontsize1</span><span class="s2">,</span>
                                <span class="s1">font2</span><span class="s2">, </span><span class="s1">fontclass2</span><span class="s2">, </span><span class="s1">sym2</span><span class="s2">, </span><span class="s1">fontsize2</span><span class="s2">, </span><span class="s1">dpi)</span>


<span class="s2">class </span><span class="s1">BakomaFonts(TruetypeFonts):</span>
    <span class="s0">&quot;&quot;&quot; 
    Use the Bakoma TrueType fonts for rendering. 
 
    Symbols are strewn about a number of font files, each of which has 
    its own proprietary 8-bit encoding. 
    &quot;&quot;&quot;</span>
    <span class="s1">_fontmap = {</span>
        <span class="s4">'cal'</span><span class="s1">: </span><span class="s4">'cmsy10'</span><span class="s2">,</span>
        <span class="s4">'rm'</span><span class="s1">:  </span><span class="s4">'cmr10'</span><span class="s2">,</span>
        <span class="s4">'tt'</span><span class="s1">:  </span><span class="s4">'cmtt10'</span><span class="s2">,</span>
        <span class="s4">'it'</span><span class="s1">:  </span><span class="s4">'cmmi10'</span><span class="s2">,</span>
        <span class="s4">'bf'</span><span class="s1">:  </span><span class="s4">'cmb10'</span><span class="s2">,</span>
        <span class="s4">'sf'</span><span class="s1">:  </span><span class="s4">'cmss10'</span><span class="s2">,</span>
        <span class="s4">'ex'</span><span class="s1">:  </span><span class="s4">'cmex10'</span><span class="s2">,</span>
    <span class="s1">}</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">default_font_prop: FontProperties</span><span class="s2">, </span><span class="s1">load_glyph_flags: int):</span>
        <span class="s1">self._stix_fallback = StixFonts(default_font_prop</span><span class="s2">, </span><span class="s1">load_glyph_flags)</span>

        <span class="s1">super().__init__(default_font_prop</span><span class="s2">, </span><span class="s1">load_glyph_flags)</span>
        <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">self._fontmap.items():</span>
            <span class="s1">fullpath = findfont(val)</span>
            <span class="s1">self.fontmap[key] = fullpath</span>
            <span class="s1">self.fontmap[val] = fullpath</span>

    <span class="s1">_slanted_symbols = set(</span><span class="s4">r&quot;\int \oint&quot;</span><span class="s1">.split())</span>

    <span class="s2">def </span><span class="s1">_get_glyph(self</span><span class="s2">, </span><span class="s1">fontname: str</span><span class="s2">, </span><span class="s1">font_class: str</span><span class="s2">,</span>
                   <span class="s1">sym: str) -&gt; tuple[FT2Font</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">bool]:</span>
        <span class="s1">font = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">fontname </span><span class="s2">in </span><span class="s1">self.fontmap </span><span class="s2">and </span><span class="s1">sym </span><span class="s2">in </span><span class="s1">latex_to_bakoma:</span>
            <span class="s1">basename</span><span class="s2">, </span><span class="s1">num = latex_to_bakoma[sym]</span>
            <span class="s1">slanted = (basename == </span><span class="s4">&quot;cmmi10&quot;</span><span class="s1">) </span><span class="s2">or </span><span class="s1">sym </span><span class="s2">in </span><span class="s1">self._slanted_symbols</span>
            <span class="s1">font = self._get_font(basename)</span>
        <span class="s2">elif </span><span class="s1">len(sym) == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">slanted = (fontname == </span><span class="s4">&quot;it&quot;</span><span class="s1">)</span>
            <span class="s1">font = self._get_font(fontname)</span>
            <span class="s2">if </span><span class="s1">font </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">num = ord(sym)</span>
        <span class="s2">if </span><span class="s1">font </span><span class="s2">is not None and </span><span class="s1">font.get_char_index(num) != </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">font</span><span class="s2">, </span><span class="s1">num</span><span class="s2">, </span><span class="s1">slanted</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._stix_fallback._get_glyph(fontname</span><span class="s2">, </span><span class="s1">font_class</span><span class="s2">, </span><span class="s1">sym)</span>

    <span class="s5"># The Bakoma fonts contain many pre-sized alternatives for the</span>
    <span class="s5"># delimiters.  The AutoSizedChar class will use these alternatives</span>
    <span class="s5"># and select the best (closest sized) glyph.</span>
    <span class="s1">_size_alternatives = {</span>
        <span class="s4">'('</span><span class="s1">:           [(</span><span class="s4">'rm'</span><span class="s2">, </span><span class="s4">'('</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\xa1</span><span class="s4">'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\xb3</span><span class="s4">'</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\xb5</span><span class="s4">'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\xc3</span><span class="s4">'</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s4">')'</span><span class="s1">:           [(</span><span class="s4">'rm'</span><span class="s2">, </span><span class="s4">')'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\xa2</span><span class="s4">'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\xb4</span><span class="s4">'</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\xb6</span><span class="s4">'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x21</span><span class="s4">'</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s4">'{'</span><span class="s1">:           [(</span><span class="s4">'cal'</span><span class="s2">, </span><span class="s4">'{'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\xa9</span><span class="s4">'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x6e</span><span class="s4">'</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\xbd</span><span class="s4">'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x28</span><span class="s4">'</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s4">'}'</span><span class="s1">:           [(</span><span class="s4">'cal'</span><span class="s2">, </span><span class="s4">'}'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\xaa</span><span class="s4">'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x6f</span><span class="s4">'</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\xbe</span><span class="s4">'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x29</span><span class="s4">'</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s5"># The fourth size of '[' is mysteriously missing from the BaKoMa</span>
        <span class="s5"># font, so I've omitted it for both '[' and ']'</span>
        <span class="s4">'['</span><span class="s1">:           [(</span><span class="s4">'rm'</span><span class="s2">, </span><span class="s4">'['</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\xa3</span><span class="s4">'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x68</span><span class="s4">'</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x22</span><span class="s4">'</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s4">']'</span><span class="s1">:           [(</span><span class="s4">'rm'</span><span class="s2">, </span><span class="s4">']'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\xa4</span><span class="s4">'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x69</span><span class="s4">'</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x23</span><span class="s4">'</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s4">r'\lfloor'</span><span class="s1">:    [(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\xa5</span><span class="s4">'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x6a</span><span class="s4">'</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\xb9</span><span class="s4">'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x24</span><span class="s4">'</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s4">r'\rfloor'</span><span class="s1">:    [(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\xa6</span><span class="s4">'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x6b</span><span class="s4">'</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\xba</span><span class="s4">'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x25</span><span class="s4">'</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s4">r'\lceil'</span><span class="s1">:     [(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\xa7</span><span class="s4">'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x6c</span><span class="s4">'</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\xbb</span><span class="s4">'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x26</span><span class="s4">'</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s4">r'\rceil'</span><span class="s1">:     [(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\xa8</span><span class="s4">'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x6d</span><span class="s4">'</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\xbc</span><span class="s4">'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x27</span><span class="s4">'</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s4">r'\langle'</span><span class="s1">:    [(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\xad</span><span class="s4">'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x44</span><span class="s4">'</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\xbf</span><span class="s4">'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x2a</span><span class="s4">'</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s4">r'\rangle'</span><span class="s1">:    [(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\xae</span><span class="s4">'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x45</span><span class="s4">'</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\xc0</span><span class="s4">'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x2b</span><span class="s4">'</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s4">r'\__sqrt__'</span><span class="s1">:  [(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x70</span><span class="s4">'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x71</span><span class="s4">'</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x72</span><span class="s4">'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x73</span><span class="s4">'</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s4">r'\backslash'</span><span class="s1">: [(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\xb2</span><span class="s4">'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x2f</span><span class="s4">'</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\xc2</span><span class="s4">'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x2d</span><span class="s4">'</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s4">r'/'</span><span class="s1">:          [(</span><span class="s4">'rm'</span><span class="s2">, </span><span class="s4">'/'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\xb1</span><span class="s4">'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x2e</span><span class="s4">'</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\xcb</span><span class="s4">'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x2c</span><span class="s4">'</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s4">r'\widehat'</span><span class="s1">:   [(</span><span class="s4">'rm'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x5e</span><span class="s4">'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x62</span><span class="s4">'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x63</span><span class="s4">'</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x64</span><span class="s4">'</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s4">r'\widetilde'</span><span class="s1">: [(</span><span class="s4">'rm'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x7e</span><span class="s4">'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x65</span><span class="s4">'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x66</span><span class="s4">'</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\x67</span><span class="s4">'</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s4">r'&lt;'</span><span class="s1">:          [(</span><span class="s4">'cal'</span><span class="s2">, </span><span class="s4">'h'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'D'</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s4">r'&gt;'</span><span class="s1">:          [(</span><span class="s4">'cal'</span><span class="s2">, </span><span class="s4">'i'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s4">'E'</span><span class="s1">)]</span>
        <span class="s1">}</span>

    <span class="s2">for </span><span class="s1">alias</span><span class="s2">, </span><span class="s1">target </span><span class="s2">in </span><span class="s1">[(</span><span class="s4">r'\leftparen'</span><span class="s2">, </span><span class="s4">'('</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">r'\rightparent'</span><span class="s2">, </span><span class="s4">')'</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">r'\leftbrace'</span><span class="s2">, </span><span class="s4">'{'</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">r'\rightbrace'</span><span class="s2">, </span><span class="s4">'}'</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">r'\leftbracket'</span><span class="s2">, </span><span class="s4">'['</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">r'\rightbracket'</span><span class="s2">, </span><span class="s4">']'</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">r'\{'</span><span class="s2">, </span><span class="s4">'{'</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">r'\}'</span><span class="s2">, </span><span class="s4">'}'</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">r'\['</span><span class="s2">, </span><span class="s4">'['</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">r'\]'</span><span class="s2">, </span><span class="s4">']'</span><span class="s1">)]:</span>
        <span class="s1">_size_alternatives[alias] = _size_alternatives[target]</span>

    <span class="s2">def </span><span class="s1">get_sized_alternatives_for_symbol(self</span><span class="s2">, </span><span class="s1">fontname: str</span><span class="s2">,</span>
                                          <span class="s1">sym: str) -&gt; list[tuple[str</span><span class="s2">, </span><span class="s1">str]]:</span>
        <span class="s2">return </span><span class="s1">self._size_alternatives.get(sym</span><span class="s2">, </span><span class="s1">[(fontname</span><span class="s2">, </span><span class="s1">sym)])</span>


<span class="s2">class </span><span class="s1">UnicodeFonts(TruetypeFonts):</span>
    <span class="s0">&quot;&quot;&quot; 
    An abstract base class for handling Unicode fonts. 
 
    While some reasonably complete Unicode fonts (such as DejaVu) may 
    work in some situations, the only Unicode font I'm aware of with a 
    complete set of math symbols is STIX. 
 
    This class will &quot;fallback&quot; on the Bakoma fonts when a required 
    symbol cannot be found in the font. 
    &quot;&quot;&quot;</span>

    <span class="s5"># Some glyphs are not present in the `cmr10` font, and must be brought in</span>
    <span class="s5"># from `cmsy10`. Map the Unicode indices of those glyphs to the indices at</span>
    <span class="s5"># which they are found in `cmsy10`.</span>
    <span class="s1">_cmr10_substitutions = {</span>
        <span class="s3">0x00D7</span><span class="s1">: </span><span class="s3">0x00A3</span><span class="s2">,  </span><span class="s5"># Multiplication sign.</span>
        <span class="s3">0x2212</span><span class="s1">: </span><span class="s3">0x00A1</span><span class="s2">,  </span><span class="s5"># Minus sign.</span>
    <span class="s1">}</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">default_font_prop: FontProperties</span><span class="s2">, </span><span class="s1">load_glyph_flags: int):</span>
        <span class="s5"># This must come first so the backend's owner is set correctly</span>
        <span class="s1">fallback_rc = mpl.rcParams[</span><span class="s4">'mathtext.fallback'</span><span class="s1">]</span>
        <span class="s1">font_cls: type[TruetypeFonts] | </span><span class="s2">None </span><span class="s1">= {</span>
            <span class="s4">'stix'</span><span class="s1">: StixFonts</span><span class="s2">,</span>
            <span class="s4">'stixsans'</span><span class="s1">: StixSansFonts</span><span class="s2">,</span>
            <span class="s4">'cm'</span><span class="s1">: BakomaFonts</span>
        <span class="s1">}.get(fallback_rc)</span>
        <span class="s1">self._fallback_font = (font_cls(default_font_prop</span><span class="s2">, </span><span class="s1">load_glyph_flags)</span>
                               <span class="s2">if </span><span class="s1">font_cls </span><span class="s2">else None</span><span class="s1">)</span>

        <span class="s1">super().__init__(default_font_prop</span><span class="s2">, </span><span class="s1">load_glyph_flags)</span>
        <span class="s2">for </span><span class="s1">texfont </span><span class="s2">in </span><span class="s4">&quot;cal rm tt it bf sf bfit&quot;</span><span class="s1">.split():</span>
            <span class="s1">prop = mpl.rcParams[</span><span class="s4">'mathtext.' </span><span class="s1">+ texfont]</span>
            <span class="s1">font = findfont(prop)</span>
            <span class="s1">self.fontmap[texfont] = font</span>
        <span class="s1">prop = FontProperties(</span><span class="s4">'cmex10'</span><span class="s1">)</span>
        <span class="s1">font = findfont(prop)</span>
        <span class="s1">self.fontmap[</span><span class="s4">'ex'</span><span class="s1">] = font</span>

        <span class="s5"># include STIX sized alternatives for glyphs if fallback is STIX</span>
        <span class="s2">if </span><span class="s1">isinstance(self._fallback_font</span><span class="s2">, </span><span class="s1">StixFonts):</span>
            <span class="s1">stixsizedaltfonts = {</span>
                 <span class="s3">0</span><span class="s1">: </span><span class="s4">'STIXGeneral'</span><span class="s2">,</span>
                 <span class="s3">1</span><span class="s1">: </span><span class="s4">'STIXSizeOneSym'</span><span class="s2">,</span>
                 <span class="s3">2</span><span class="s1">: </span><span class="s4">'STIXSizeTwoSym'</span><span class="s2">,</span>
                 <span class="s3">3</span><span class="s1">: </span><span class="s4">'STIXSizeThreeSym'</span><span class="s2">,</span>
                 <span class="s3">4</span><span class="s1">: </span><span class="s4">'STIXSizeFourSym'</span><span class="s2">,</span>
                 <span class="s3">5</span><span class="s1">: </span><span class="s4">'STIXSizeFiveSym'</span><span class="s1">}</span>

            <span class="s2">for </span><span class="s1">size</span><span class="s2">, </span><span class="s1">name </span><span class="s2">in </span><span class="s1">stixsizedaltfonts.items():</span>
                <span class="s1">fullpath = findfont(name)</span>
                <span class="s1">self.fontmap[size] = fullpath</span>
                <span class="s1">self.fontmap[name] = fullpath</span>

    <span class="s1">_slanted_symbols = set(</span><span class="s4">r&quot;\int \oint&quot;</span><span class="s1">.split())</span>

    <span class="s2">def </span><span class="s1">_map_virtual_font(self</span><span class="s2">, </span><span class="s1">fontname: str</span><span class="s2">, </span><span class="s1">font_class: str</span><span class="s2">,</span>
                          <span class="s1">uniindex: int) -&gt; tuple[str</span><span class="s2">, </span><span class="s1">int]:</span>
        <span class="s2">return </span><span class="s1">fontname</span><span class="s2">, </span><span class="s1">uniindex</span>

    <span class="s2">def </span><span class="s1">_get_glyph(self</span><span class="s2">, </span><span class="s1">fontname: str</span><span class="s2">, </span><span class="s1">font_class: str</span><span class="s2">,</span>
                   <span class="s1">sym: str) -&gt; tuple[FT2Font</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">bool]:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">uniindex = get_unicode_index(sym)</span>
            <span class="s1">found_symbol = </span><span class="s2">True</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s1">uniindex = ord(</span><span class="s4">'?'</span><span class="s1">)</span>
            <span class="s1">found_symbol = </span><span class="s2">False</span>
            <span class="s1">_log.warning(</span><span class="s4">&quot;No TeX to Unicode mapping for %a.&quot;</span><span class="s2">, </span><span class="s1">sym)</span>

        <span class="s1">fontname</span><span class="s2">, </span><span class="s1">uniindex = self._map_virtual_font(</span>
            <span class="s1">fontname</span><span class="s2">, </span><span class="s1">font_class</span><span class="s2">, </span><span class="s1">uniindex)</span>

        <span class="s1">new_fontname = fontname</span>

        <span class="s5"># Only characters in the &quot;Letter&quot; class should be italicized in 'it'</span>
        <span class="s5"># mode.  Greek capital letters should be Roman.</span>
        <span class="s2">if </span><span class="s1">found_symbol:</span>
            <span class="s2">if </span><span class="s1">fontname == </span><span class="s4">'it' </span><span class="s2">and </span><span class="s1">uniindex &lt; </span><span class="s3">0x10000</span><span class="s1">:</span>
                <span class="s1">char = chr(uniindex)</span>
                <span class="s2">if </span><span class="s1">(unicodedata.category(char)[</span><span class="s3">0</span><span class="s1">] != </span><span class="s4">&quot;L&quot;</span>
                        <span class="s2">or </span><span class="s1">unicodedata.name(char).startswith(</span><span class="s4">&quot;GREEK CAPITAL&quot;</span><span class="s1">)):</span>
                    <span class="s1">new_fontname = </span><span class="s4">'rm'</span>

            <span class="s1">slanted = (new_fontname == </span><span class="s4">'it'</span><span class="s1">) </span><span class="s2">or </span><span class="s1">sym </span><span class="s2">in </span><span class="s1">self._slanted_symbols</span>
            <span class="s1">found_symbol = </span><span class="s2">False</span>
            <span class="s1">font = self._get_font(new_fontname)</span>
            <span class="s2">if </span><span class="s1">font </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">(uniindex </span><span class="s2">in </span><span class="s1">self._cmr10_substitutions</span>
                        <span class="s2">and </span><span class="s1">font.family_name == </span><span class="s4">&quot;cmr10&quot;</span><span class="s1">):</span>
                    <span class="s1">font = get_font(</span>
                        <span class="s1">cbook._get_data_path(</span><span class="s4">&quot;fonts/ttf/cmsy10.ttf&quot;</span><span class="s1">))</span>
                    <span class="s1">uniindex = self._cmr10_substitutions[uniindex]</span>
                <span class="s1">glyphindex = font.get_char_index(uniindex)</span>
                <span class="s2">if </span><span class="s1">glyphindex != </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s1">found_symbol = </span><span class="s2">True</span>

        <span class="s2">if not </span><span class="s1">found_symbol:</span>
            <span class="s2">if </span><span class="s1">self._fallback_font:</span>
                <span class="s2">if </span><span class="s1">(fontname </span><span class="s2">in </span><span class="s1">(</span><span class="s4">'it'</span><span class="s2">, </span><span class="s4">'regular'</span><span class="s1">)</span>
                        <span class="s2">and </span><span class="s1">isinstance(self._fallback_font</span><span class="s2">, </span><span class="s1">StixFonts)):</span>
                    <span class="s1">fontname = </span><span class="s4">'rm'</span>

                <span class="s1">g = self._fallback_font._get_glyph(fontname</span><span class="s2">, </span><span class="s1">font_class</span><span class="s2">, </span><span class="s1">sym)</span>
                <span class="s1">family = g[</span><span class="s3">0</span><span class="s1">].family_name</span>
                <span class="s2">if </span><span class="s1">family </span><span class="s2">in </span><span class="s1">list(BakomaFonts._fontmap.values()):</span>
                    <span class="s1">family = </span><span class="s4">&quot;Computer Modern&quot;</span>
                <span class="s1">_log.info(</span><span class="s4">&quot;Substituting symbol %s from %s&quot;</span><span class="s2">, </span><span class="s1">sym</span><span class="s2">, </span><span class="s1">family)</span>
                <span class="s2">return </span><span class="s1">g</span>

            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">(fontname </span><span class="s2">in </span><span class="s1">(</span><span class="s4">'it'</span><span class="s2">, </span><span class="s4">'regular'</span><span class="s1">)</span>
                        <span class="s2">and </span><span class="s1">isinstance(self</span><span class="s2">, </span><span class="s1">StixFonts)):</span>
                    <span class="s2">return </span><span class="s1">self._get_glyph(</span><span class="s4">'rm'</span><span class="s2">, </span><span class="s1">font_class</span><span class="s2">, </span><span class="s1">sym)</span>
                <span class="s1">_log.warning(</span><span class="s4">&quot;Font %r does not have a glyph for %a [U+%x], &quot;</span>
                             <span class="s4">&quot;substituting with a dummy symbol.&quot;</span><span class="s2">,</span>
                             <span class="s1">new_fontname</span><span class="s2">, </span><span class="s1">sym</span><span class="s2">, </span><span class="s1">uniindex)</span>
                <span class="s1">font = self._get_font(</span><span class="s4">'rm'</span><span class="s1">)</span>
                <span class="s1">uniindex = </span><span class="s3">0xA4  </span><span class="s5"># currency char, for lack of anything better</span>
                <span class="s1">slanted = </span><span class="s2">False</span>

        <span class="s2">return </span><span class="s1">font</span><span class="s2">, </span><span class="s1">uniindex</span><span class="s2">, </span><span class="s1">slanted</span>

    <span class="s2">def </span><span class="s1">get_sized_alternatives_for_symbol(self</span><span class="s2">, </span><span class="s1">fontname: str</span><span class="s2">,</span>
                                          <span class="s1">sym: str) -&gt; list[tuple[str</span><span class="s2">, </span><span class="s1">str]]:</span>
        <span class="s2">if </span><span class="s1">self._fallback_font:</span>
            <span class="s2">return </span><span class="s1">self._fallback_font.get_sized_alternatives_for_symbol(</span>
                <span class="s1">fontname</span><span class="s2">, </span><span class="s1">sym)</span>
        <span class="s2">return </span><span class="s1">[(fontname</span><span class="s2">, </span><span class="s1">sym)]</span>


<span class="s2">class </span><span class="s1">DejaVuFonts(UnicodeFonts</span><span class="s2">, </span><span class="s1">metaclass=abc.ABCMeta):</span>
    <span class="s1">_fontmap: dict[str | int</span><span class="s2">, </span><span class="s1">str] = {}</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">default_font_prop: FontProperties</span><span class="s2">, </span><span class="s1">load_glyph_flags: int):</span>
        <span class="s5"># This must come first so the backend's owner is set correctly</span>
        <span class="s2">if </span><span class="s1">isinstance(self</span><span class="s2">, </span><span class="s1">DejaVuSerifFonts):</span>
            <span class="s1">self._fallback_font = StixFonts(default_font_prop</span><span class="s2">, </span><span class="s1">load_glyph_flags)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._fallback_font = StixSansFonts(default_font_prop</span><span class="s2">, </span><span class="s1">load_glyph_flags)</span>
        <span class="s1">self.bakoma = BakomaFonts(default_font_prop</span><span class="s2">, </span><span class="s1">load_glyph_flags)</span>
        <span class="s1">TruetypeFonts.__init__(self</span><span class="s2">, </span><span class="s1">default_font_prop</span><span class="s2">, </span><span class="s1">load_glyph_flags)</span>
        <span class="s5"># Include Stix sized alternatives for glyphs</span>
        <span class="s1">self._fontmap.update({</span>
            <span class="s3">1</span><span class="s1">: </span><span class="s4">'STIXSizeOneSym'</span><span class="s2">,</span>
            <span class="s3">2</span><span class="s1">: </span><span class="s4">'STIXSizeTwoSym'</span><span class="s2">,</span>
            <span class="s3">3</span><span class="s1">: </span><span class="s4">'STIXSizeThreeSym'</span><span class="s2">,</span>
            <span class="s3">4</span><span class="s1">: </span><span class="s4">'STIXSizeFourSym'</span><span class="s2">,</span>
            <span class="s3">5</span><span class="s1">: </span><span class="s4">'STIXSizeFiveSym'</span><span class="s2">,</span>
        <span class="s1">})</span>
        <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self._fontmap.items():</span>
            <span class="s1">fullpath = findfont(name)</span>
            <span class="s1">self.fontmap[key] = fullpath</span>
            <span class="s1">self.fontmap[name] = fullpath</span>

    <span class="s2">def </span><span class="s1">_get_glyph(self</span><span class="s2">, </span><span class="s1">fontname: str</span><span class="s2">, </span><span class="s1">font_class: str</span><span class="s2">,</span>
                   <span class="s1">sym: str) -&gt; tuple[FT2Font</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">bool]:</span>
        <span class="s5"># Override prime symbol to use Bakoma.</span>
        <span class="s2">if </span><span class="s1">sym == </span><span class="s4">r'\prime'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.bakoma._get_glyph(fontname</span><span class="s2">, </span><span class="s1">font_class</span><span class="s2">, </span><span class="s1">sym)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># check whether the glyph is available in the display font</span>
            <span class="s1">uniindex = get_unicode_index(sym)</span>
            <span class="s1">font = self._get_font(</span><span class="s4">'ex'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">font </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">glyphindex = font.get_char_index(uniindex)</span>
                <span class="s2">if </span><span class="s1">glyphindex != </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">super()._get_glyph(</span><span class="s4">'ex'</span><span class="s2">, </span><span class="s1">font_class</span><span class="s2">, </span><span class="s1">sym)</span>
            <span class="s5"># otherwise return regular glyph</span>
            <span class="s2">return </span><span class="s1">super()._get_glyph(fontname</span><span class="s2">, </span><span class="s1">font_class</span><span class="s2">, </span><span class="s1">sym)</span>


<span class="s2">class </span><span class="s1">DejaVuSerifFonts(DejaVuFonts):</span>
    <span class="s0">&quot;&quot;&quot; 
    A font handling class for the DejaVu Serif fonts 
 
    If a glyph is not found it will fallback to Stix Serif 
    &quot;&quot;&quot;</span>
    <span class="s1">_fontmap = {</span>
        <span class="s4">'rm'</span><span class="s1">: </span><span class="s4">'DejaVu Serif'</span><span class="s2">,</span>
        <span class="s4">'it'</span><span class="s1">: </span><span class="s4">'DejaVu Serif:italic'</span><span class="s2">,</span>
        <span class="s4">'bf'</span><span class="s1">: </span><span class="s4">'DejaVu Serif:weight=bold'</span><span class="s2">,</span>
        <span class="s4">'bfit'</span><span class="s1">: </span><span class="s4">'DejaVu Serif:italic:bold'</span><span class="s2">,</span>
        <span class="s4">'sf'</span><span class="s1">: </span><span class="s4">'DejaVu Sans'</span><span class="s2">,</span>
        <span class="s4">'tt'</span><span class="s1">: </span><span class="s4">'DejaVu Sans Mono'</span><span class="s2">,</span>
        <span class="s4">'ex'</span><span class="s1">: </span><span class="s4">'DejaVu Serif Display'</span><span class="s2">,</span>
        <span class="s3">0</span><span class="s1">:    </span><span class="s4">'DejaVu Serif'</span><span class="s2">,</span>
    <span class="s1">}</span>


<span class="s2">class </span><span class="s1">DejaVuSansFonts(DejaVuFonts):</span>
    <span class="s0">&quot;&quot;&quot; 
    A font handling class for the DejaVu Sans fonts 
 
    If a glyph is not found it will fallback to Stix Sans 
    &quot;&quot;&quot;</span>
    <span class="s1">_fontmap = {</span>
        <span class="s4">'rm'</span><span class="s1">: </span><span class="s4">'DejaVu Sans'</span><span class="s2">,</span>
        <span class="s4">'it'</span><span class="s1">: </span><span class="s4">'DejaVu Sans:italic'</span><span class="s2">,</span>
        <span class="s4">'bf'</span><span class="s1">: </span><span class="s4">'DejaVu Sans:weight=bold'</span><span class="s2">,</span>
        <span class="s4">'bfit'</span><span class="s1">: </span><span class="s4">'DejaVu Sans:italic:bold'</span><span class="s2">,</span>
        <span class="s4">'sf'</span><span class="s1">: </span><span class="s4">'DejaVu Sans'</span><span class="s2">,</span>
        <span class="s4">'tt'</span><span class="s1">: </span><span class="s4">'DejaVu Sans Mono'</span><span class="s2">,</span>
        <span class="s4">'ex'</span><span class="s1">: </span><span class="s4">'DejaVu Sans Display'</span><span class="s2">,</span>
        <span class="s3">0</span><span class="s1">:    </span><span class="s4">'DejaVu Sans'</span><span class="s2">,</span>
    <span class="s1">}</span>


<span class="s2">class </span><span class="s1">StixFonts(UnicodeFonts):</span>
    <span class="s0">&quot;&quot;&quot; 
    A font handling class for the STIX fonts. 
 
    In addition to what UnicodeFonts provides, this class: 
 
    - supports &quot;virtual fonts&quot; which are complete alpha numeric 
      character sets with different font styles at special Unicode 
      code points, such as &quot;Blackboard&quot;. 
 
    - handles sized alternative characters for the STIXSizeX fonts. 
    &quot;&quot;&quot;</span>
    <span class="s1">_fontmap: dict[str | int</span><span class="s2">, </span><span class="s1">str] = {</span>
        <span class="s4">'rm'</span><span class="s1">: </span><span class="s4">'STIXGeneral'</span><span class="s2">,</span>
        <span class="s4">'it'</span><span class="s1">: </span><span class="s4">'STIXGeneral:italic'</span><span class="s2">,</span>
        <span class="s4">'bf'</span><span class="s1">: </span><span class="s4">'STIXGeneral:weight=bold'</span><span class="s2">,</span>
        <span class="s4">'bfit'</span><span class="s1">: </span><span class="s4">'STIXGeneral:italic:bold'</span><span class="s2">,</span>
        <span class="s4">'nonunirm'</span><span class="s1">: </span><span class="s4">'STIXNonUnicode'</span><span class="s2">,</span>
        <span class="s4">'nonuniit'</span><span class="s1">: </span><span class="s4">'STIXNonUnicode:italic'</span><span class="s2">,</span>
        <span class="s4">'nonunibf'</span><span class="s1">: </span><span class="s4">'STIXNonUnicode:weight=bold'</span><span class="s2">,</span>
        <span class="s3">0</span><span class="s1">: </span><span class="s4">'STIXGeneral'</span><span class="s2">,</span>
        <span class="s3">1</span><span class="s1">: </span><span class="s4">'STIXSizeOneSym'</span><span class="s2">,</span>
        <span class="s3">2</span><span class="s1">: </span><span class="s4">'STIXSizeTwoSym'</span><span class="s2">,</span>
        <span class="s3">3</span><span class="s1">: </span><span class="s4">'STIXSizeThreeSym'</span><span class="s2">,</span>
        <span class="s3">4</span><span class="s1">: </span><span class="s4">'STIXSizeFourSym'</span><span class="s2">,</span>
        <span class="s3">5</span><span class="s1">: </span><span class="s4">'STIXSizeFiveSym'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">_fallback_font = </span><span class="s2">None</span>
    <span class="s1">_sans = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">default_font_prop: FontProperties</span><span class="s2">, </span><span class="s1">load_glyph_flags: int):</span>
        <span class="s1">TruetypeFonts.__init__(self</span><span class="s2">, </span><span class="s1">default_font_prop</span><span class="s2">, </span><span class="s1">load_glyph_flags)</span>
        <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self._fontmap.items():</span>
            <span class="s1">fullpath = findfont(name)</span>
            <span class="s1">self.fontmap[key] = fullpath</span>
            <span class="s1">self.fontmap[name] = fullpath</span>

    <span class="s2">def </span><span class="s1">_map_virtual_font(self</span><span class="s2">, </span><span class="s1">fontname: str</span><span class="s2">, </span><span class="s1">font_class: str</span><span class="s2">,</span>
                          <span class="s1">uniindex: int) -&gt; tuple[str</span><span class="s2">, </span><span class="s1">int]:</span>
        <span class="s5"># Handle these &quot;fonts&quot; that are actually embedded in</span>
        <span class="s5"># other fonts.</span>
        <span class="s1">font_mapping = stix_virtual_fonts.get(fontname)</span>
        <span class="s2">if </span><span class="s1">(self._sans </span><span class="s2">and </span><span class="s1">font_mapping </span><span class="s2">is None</span>
                <span class="s2">and </span><span class="s1">fontname </span><span class="s2">not in </span><span class="s1">(</span><span class="s4">'regular'</span><span class="s2">, </span><span class="s4">'default'</span><span class="s1">)):</span>
            <span class="s1">font_mapping = stix_virtual_fonts[</span><span class="s4">'sf'</span><span class="s1">]</span>
            <span class="s1">doing_sans_conversion = </span><span class="s2">True</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">doing_sans_conversion = </span><span class="s2">False</span>

        <span class="s2">if </span><span class="s1">isinstance(font_mapping</span><span class="s2">, </span><span class="s1">dict):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">mapping = font_mapping[font_class]</span>
            <span class="s2">except </span><span class="s1">KeyError:</span>
                <span class="s1">mapping = font_mapping[</span><span class="s4">'rm'</span><span class="s1">]</span>
        <span class="s2">elif </span><span class="s1">isinstance(font_mapping</span><span class="s2">, </span><span class="s1">list):</span>
            <span class="s1">mapping = font_mapping</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">mapping = </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">mapping </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s5"># Binary search for the source glyph</span>
            <span class="s1">lo = </span><span class="s3">0</span>
            <span class="s1">hi = len(mapping)</span>
            <span class="s2">while </span><span class="s1">lo &lt; hi:</span>
                <span class="s1">mid = (lo+hi)//</span><span class="s3">2</span>
                <span class="s1">range = mapping[mid]</span>
                <span class="s2">if </span><span class="s1">uniindex &lt; range[</span><span class="s3">0</span><span class="s1">]:</span>
                    <span class="s1">hi = mid</span>
                <span class="s2">elif </span><span class="s1">uniindex &lt;= range[</span><span class="s3">1</span><span class="s1">]:</span>
                    <span class="s2">break</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">lo = mid + </span><span class="s3">1</span>

            <span class="s2">if </span><span class="s1">range[</span><span class="s3">0</span><span class="s1">] &lt;= uniindex &lt;= range[</span><span class="s3">1</span><span class="s1">]:</span>
                <span class="s1">uniindex = uniindex - range[</span><span class="s3">0</span><span class="s1">] + range[</span><span class="s3">3</span><span class="s1">]</span>
                <span class="s1">fontname = range[</span><span class="s3">2</span><span class="s1">]</span>
            <span class="s2">elif not </span><span class="s1">doing_sans_conversion:</span>
                <span class="s5"># This will generate a dummy character</span>
                <span class="s1">uniindex = </span><span class="s3">0x1</span>
                <span class="s1">fontname = mpl.rcParams[</span><span class="s4">'mathtext.default'</span><span class="s1">]</span>

        <span class="s5"># Fix some incorrect glyphs.</span>
        <span class="s2">if </span><span class="s1">fontname </span><span class="s2">in </span><span class="s1">(</span><span class="s4">'rm'</span><span class="s2">, </span><span class="s4">'it'</span><span class="s1">):</span>
            <span class="s1">uniindex = stix_glyph_fixes.get(uniindex</span><span class="s2">, </span><span class="s1">uniindex)</span>

        <span class="s5"># Handle private use area glyphs</span>
        <span class="s2">if </span><span class="s1">fontname </span><span class="s2">in </span><span class="s1">(</span><span class="s4">'it'</span><span class="s2">, </span><span class="s4">'rm'</span><span class="s2">, </span><span class="s4">'bf'</span><span class="s2">, </span><span class="s4">'bfit'</span><span class="s1">) </span><span class="s2">and </span><span class="s3">0xe000 </span><span class="s1">&lt;= uniindex &lt;= </span><span class="s3">0xf8ff</span><span class="s1">:</span>
            <span class="s1">fontname = </span><span class="s4">'nonuni' </span><span class="s1">+ fontname</span>

        <span class="s2">return </span><span class="s1">fontname</span><span class="s2">, </span><span class="s1">uniindex</span>

    <span class="s1">@functools.cache</span>
    <span class="s2">def </span><span class="s1">get_sized_alternatives_for_symbol(  </span><span class="s5"># type: ignore[override]</span>
            <span class="s1">self</span><span class="s2">,</span>
            <span class="s1">fontname: str</span><span class="s2">,</span>
            <span class="s1">sym: str) -&gt; list[tuple[str</span><span class="s2">, </span><span class="s1">str]] | list[tuple[int</span><span class="s2">, </span><span class="s1">str]]:</span>
        <span class="s1">fixes = {</span>
            <span class="s4">'</span><span class="s2">\\</span><span class="s4">{'</span><span class="s1">: </span><span class="s4">'{'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\\</span><span class="s4">}'</span><span class="s1">: </span><span class="s4">'}'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\\</span><span class="s4">['</span><span class="s1">: </span><span class="s4">'['</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\\</span><span class="s4">]'</span><span class="s1">: </span><span class="s4">']'</span><span class="s2">,</span>
            <span class="s4">'&lt;'</span><span class="s1">: </span><span class="s4">'</span><span class="s2">\N{MATHEMATICAL LEFT ANGLE BRACKET}</span><span class="s4">'</span><span class="s2">,</span>
            <span class="s4">'&gt;'</span><span class="s1">: </span><span class="s4">'</span><span class="s2">\N{MATHEMATICAL RIGHT ANGLE BRACKET}</span><span class="s4">'</span><span class="s2">,</span>
        <span class="s1">}</span>
        <span class="s1">sym = fixes.get(sym</span><span class="s2">, </span><span class="s1">sym)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">uniindex = get_unicode_index(sym)</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s2">return </span><span class="s1">[(fontname</span><span class="s2">, </span><span class="s1">sym)]</span>
        <span class="s1">alternatives = [(i</span><span class="s2">, </span><span class="s1">chr(uniindex)) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">6</span><span class="s1">)</span>
                        <span class="s2">if </span><span class="s1">self._get_font(i).get_char_index(uniindex) != </span><span class="s3">0</span><span class="s1">]</span>
        <span class="s5"># The largest size of the radical symbol in STIX has incorrect</span>
        <span class="s5"># metrics that cause it to be disconnected from the stem.</span>
        <span class="s2">if </span><span class="s1">sym == </span><span class="s4">r'\__sqrt__'</span><span class="s1">:</span>
            <span class="s1">alternatives = alternatives[:-</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">alternatives</span>


<span class="s2">class </span><span class="s1">StixSansFonts(StixFonts):</span>
    <span class="s0">&quot;&quot;&quot; 
    A font handling class for the STIX fonts (that uses sans-serif 
    characters by default). 
    &quot;&quot;&quot;</span>
    <span class="s1">_sans = </span><span class="s2">True</span>


<span class="s5">##############################################################################</span>
<span class="s5"># TeX-LIKE BOX MODEL</span>

<span class="s5"># The following is based directly on the document 'woven' from the</span>
<span class="s5"># TeX82 source code.  This information is also available in printed</span>
<span class="s5"># form:</span>
<span class="s5">#</span>
<span class="s5">#    Knuth, Donald E.. 1986.  Computers and Typesetting, Volume B:</span>
<span class="s5">#    TeX: The Program.  Addison-Wesley Professional.</span>
<span class="s5">#</span>
<span class="s5"># The most relevant &quot;chapters&quot; are:</span>
<span class="s5">#    Data structures for boxes and their friends</span>
<span class="s5">#    Shipping pages out (ship())</span>
<span class="s5">#    Packaging (hpack() and vpack())</span>
<span class="s5">#    Data structures for math mode</span>
<span class="s5">#    Subroutines for math mode</span>
<span class="s5">#    Typesetting math formulas</span>
<span class="s5">#</span>
<span class="s5"># Many of the docstrings below refer to a numbered &quot;node&quot; in that</span>
<span class="s5"># book, e.g., node123</span>
<span class="s5">#</span>
<span class="s5"># Note that (as TeX) y increases downward, unlike many other parts of</span>
<span class="s5"># matplotlib.</span>

<span class="s5"># How much text shrinks when going to the next-smallest level.</span>
<span class="s1">SHRINK_FACTOR   = </span><span class="s3">0.7</span>
<span class="s5"># The number of different sizes of chars to use, beyond which they will not</span>
<span class="s5"># get any smaller</span>
<span class="s1">NUM_SIZE_LEVELS = </span><span class="s3">6</span>


<span class="s2">class </span><span class="s1">FontConstantsBase:</span>
    <span class="s0">&quot;&quot;&quot; 
    A set of constants that controls how certain things, such as sub- 
    and superscripts are laid out.  These are all metrics that can't 
    be reliably retrieved from the font metrics in the font itself. 
    &quot;&quot;&quot;</span>
    <span class="s5"># Percentage of x-height of additional horiz. space after sub/superscripts</span>
    <span class="s1">script_space: T.ClassVar[float] = </span><span class="s3">0.05</span>

    <span class="s5"># Percentage of x-height that sub/superscripts drop below the baseline</span>
    <span class="s1">subdrop: T.ClassVar[float] = </span><span class="s3">0.4</span>

    <span class="s5"># Percentage of x-height that superscripts are raised from the baseline</span>
    <span class="s1">sup1: T.ClassVar[float] = </span><span class="s3">0.7</span>

    <span class="s5"># Percentage of x-height that subscripts drop below the baseline</span>
    <span class="s1">sub1: T.ClassVar[float] = </span><span class="s3">0.3</span>

    <span class="s5"># Percentage of x-height that subscripts drop below the baseline when a</span>
    <span class="s5"># superscript is present</span>
    <span class="s1">sub2: T.ClassVar[float] = </span><span class="s3">0.5</span>

    <span class="s5"># Percentage of x-height that sub/superscripts are offset relative to the</span>
    <span class="s5"># nucleus edge for non-slanted nuclei</span>
    <span class="s1">delta: T.ClassVar[float] = </span><span class="s3">0.025</span>

    <span class="s5"># Additional percentage of last character height above 2/3 of the</span>
    <span class="s5"># x-height that superscripts are offset relative to the subscript</span>
    <span class="s5"># for slanted nuclei</span>
    <span class="s1">delta_slanted: T.ClassVar[float] = </span><span class="s3">0.2</span>

    <span class="s5"># Percentage of x-height that superscripts and subscripts are offset for</span>
    <span class="s5"># integrals</span>
    <span class="s1">delta_integral: T.ClassVar[float] = </span><span class="s3">0.1</span>


<span class="s2">class </span><span class="s1">ComputerModernFontConstants(FontConstantsBase):</span>
    <span class="s1">script_space = </span><span class="s3">0.075</span>
    <span class="s1">subdrop = </span><span class="s3">0.2</span>
    <span class="s1">sup1 = </span><span class="s3">0.45</span>
    <span class="s1">sub1 = </span><span class="s3">0.2</span>
    <span class="s1">sub2 = </span><span class="s3">0.3</span>
    <span class="s1">delta = </span><span class="s3">0.075</span>
    <span class="s1">delta_slanted = </span><span class="s3">0.3</span>
    <span class="s1">delta_integral = </span><span class="s3">0.3</span>


<span class="s2">class </span><span class="s1">STIXFontConstants(FontConstantsBase):</span>
    <span class="s1">script_space = </span><span class="s3">0.1</span>
    <span class="s1">sup1 = </span><span class="s3">0.8</span>
    <span class="s1">sub2 = </span><span class="s3">0.6</span>
    <span class="s1">delta = </span><span class="s3">0.05</span>
    <span class="s1">delta_slanted = </span><span class="s3">0.3</span>
    <span class="s1">delta_integral = </span><span class="s3">0.3</span>


<span class="s2">class </span><span class="s1">STIXSansFontConstants(FontConstantsBase):</span>
    <span class="s1">script_space = </span><span class="s3">0.05</span>
    <span class="s1">sup1 = </span><span class="s3">0.8</span>
    <span class="s1">delta_slanted = </span><span class="s3">0.6</span>
    <span class="s1">delta_integral = </span><span class="s3">0.3</span>


<span class="s2">class </span><span class="s1">DejaVuSerifFontConstants(FontConstantsBase):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">DejaVuSansFontConstants(FontConstantsBase):</span>
    <span class="s2">pass</span>


<span class="s5"># Maps font family names to the FontConstantBase subclass to use</span>
<span class="s1">_font_constant_mapping = {</span>
    <span class="s4">'DejaVu Sans'</span><span class="s1">: DejaVuSansFontConstants</span><span class="s2">,</span>
    <span class="s4">'DejaVu Sans Mono'</span><span class="s1">: DejaVuSansFontConstants</span><span class="s2">,</span>
    <span class="s4">'DejaVu Serif'</span><span class="s1">: DejaVuSerifFontConstants</span><span class="s2">,</span>
    <span class="s4">'cmb10'</span><span class="s1">: ComputerModernFontConstants</span><span class="s2">,</span>
    <span class="s4">'cmex10'</span><span class="s1">: ComputerModernFontConstants</span><span class="s2">,</span>
    <span class="s4">'cmmi10'</span><span class="s1">: ComputerModernFontConstants</span><span class="s2">,</span>
    <span class="s4">'cmr10'</span><span class="s1">: ComputerModernFontConstants</span><span class="s2">,</span>
    <span class="s4">'cmss10'</span><span class="s1">: ComputerModernFontConstants</span><span class="s2">,</span>
    <span class="s4">'cmsy10'</span><span class="s1">: ComputerModernFontConstants</span><span class="s2">,</span>
    <span class="s4">'cmtt10'</span><span class="s1">: ComputerModernFontConstants</span><span class="s2">,</span>
    <span class="s4">'STIXGeneral'</span><span class="s1">: STIXFontConstants</span><span class="s2">,</span>
    <span class="s4">'STIXNonUnicode'</span><span class="s1">: STIXFontConstants</span><span class="s2">,</span>
    <span class="s4">'STIXSizeFiveSym'</span><span class="s1">: STIXFontConstants</span><span class="s2">,</span>
    <span class="s4">'STIXSizeFourSym'</span><span class="s1">: STIXFontConstants</span><span class="s2">,</span>
    <span class="s4">'STIXSizeThreeSym'</span><span class="s1">: STIXFontConstants</span><span class="s2">,</span>
    <span class="s4">'STIXSizeTwoSym'</span><span class="s1">: STIXFontConstants</span><span class="s2">,</span>
    <span class="s4">'STIXSizeOneSym'</span><span class="s1">: STIXFontConstants</span><span class="s2">,</span>
    <span class="s5"># Map the fonts we used to ship, just for good measure</span>
    <span class="s4">'Bitstream Vera Sans'</span><span class="s1">: DejaVuSansFontConstants</span><span class="s2">,</span>
    <span class="s4">'Bitstream Vera'</span><span class="s1">: DejaVuSansFontConstants</span><span class="s2">,</span>
    <span class="s1">}</span>


<span class="s2">def </span><span class="s1">_get_font_constant_set(state: ParserState) -&gt; type[FontConstantsBase]:</span>
    <span class="s1">constants = _font_constant_mapping.get(</span>
        <span class="s1">state.fontset._get_font(state.font).family_name</span><span class="s2">, </span><span class="s1">FontConstantsBase)</span>
    <span class="s5"># STIX sans isn't really its own fonts, just different code points</span>
    <span class="s5"># in the STIX fonts, so we have to detect this one separately.</span>
    <span class="s2">if </span><span class="s1">(constants </span><span class="s2">is </span><span class="s1">STIXFontConstants </span><span class="s2">and</span>
            <span class="s1">isinstance(state.fontset</span><span class="s2">, </span><span class="s1">StixSansFonts)):</span>
        <span class="s2">return </span><span class="s1">STIXSansFontConstants</span>
    <span class="s2">return </span><span class="s1">constants</span>


<span class="s2">class </span><span class="s1">Node:</span>
    <span class="s0">&quot;&quot;&quot;A node in the TeX box model.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.size = </span><span class="s3">0</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">type(self).__name__</span>

    <span class="s2">def </span><span class="s1">get_kerning(self</span><span class="s2">, </span><span class="s1">next: Node | </span><span class="s2">None</span><span class="s1">) -&gt; float:</span>
        <span class="s2">return </span><span class="s3">0.0</span>

    <span class="s2">def </span><span class="s1">shrink(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Shrinks one level smaller.  There are only three levels of 
        sizes, after which things will no longer get smaller. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.size += </span><span class="s3">1</span>

    <span class="s2">def </span><span class="s1">render(self</span><span class="s2">, </span><span class="s1">output: Output</span><span class="s2">, </span><span class="s1">x: float</span><span class="s2">, </span><span class="s1">y: float) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Render this node.&quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">Box(Node):</span>
    <span class="s0">&quot;&quot;&quot;A node with a physical location.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">width: float</span><span class="s2">, </span><span class="s1">height: float</span><span class="s2">, </span><span class="s1">depth: float) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.width  = width</span>
        <span class="s1">self.height = height</span>
        <span class="s1">self.depth  = depth</span>

    <span class="s2">def </span><span class="s1">shrink(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">super().shrink()</span>
        <span class="s2">if </span><span class="s1">self.size &lt; NUM_SIZE_LEVELS:</span>
            <span class="s1">self.width  *= SHRINK_FACTOR</span>
            <span class="s1">self.height *= SHRINK_FACTOR</span>
            <span class="s1">self.depth  *= SHRINK_FACTOR</span>

    <span class="s2">def </span><span class="s1">render(self</span><span class="s2">, </span><span class="s1">output: Output</span><span class="s2">,  </span><span class="s5"># type: ignore[override]</span>
               <span class="s1">x1: float</span><span class="s2">, </span><span class="s1">y1: float</span><span class="s2">, </span><span class="s1">x2: float</span><span class="s2">, </span><span class="s1">y2: float) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">Vbox(Box):</span>
    <span class="s0">&quot;&quot;&quot;A box with only height (zero width).&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">height: float</span><span class="s2">, </span><span class="s1">depth: float):</span>
        <span class="s1">super().__init__(</span><span class="s3">0.</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">depth)</span>


<span class="s2">class </span><span class="s1">Hbox(Box):</span>
    <span class="s0">&quot;&quot;&quot;A box with only width (zero height and depth).&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">width: float):</span>
        <span class="s1">super().__init__(width</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0.</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">Char(Node):</span>
    <span class="s0">&quot;&quot;&quot; 
    A single character. 
 
    Unlike TeX, the font information and metrics are stored with each `Char` 
    to make it easier to lookup the font metrics when needed.  Note that TeX 
    boxes have a width, height, and depth, unlike Type1 and TrueType which use 
    a full bounding box and an advance in the x-direction.  The metrics must 
    be converted to the TeX model, and the advance (if different from width) 
    must be converted into a `Kern` node when the `Char` is added to its parent 
    `Hlist`. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">c: str</span><span class="s2">, </span><span class="s1">state: ParserState):</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.c = c</span>
        <span class="s1">self.fontset = state.fontset</span>
        <span class="s1">self.font = state.font</span>
        <span class="s1">self.font_class = state.font_class</span>
        <span class="s1">self.fontsize = state.fontsize</span>
        <span class="s1">self.dpi = state.dpi</span>
        <span class="s5"># The real width, height and depth will be set during the</span>
        <span class="s5"># pack phase, after we know the real fontsize</span>
        <span class="s1">self._update_metrics()</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s4">'`%s`' </span><span class="s1">% self.c</span>

    <span class="s2">def </span><span class="s1">_update_metrics(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">metrics = self._metrics = self.fontset.get_metrics(</span>
            <span class="s1">self.font</span><span class="s2">, </span><span class="s1">self.font_class</span><span class="s2">, </span><span class="s1">self.c</span><span class="s2">, </span><span class="s1">self.fontsize</span><span class="s2">, </span><span class="s1">self.dpi)</span>
        <span class="s2">if </span><span class="s1">self.c == </span><span class="s4">' '</span><span class="s1">:</span>
            <span class="s1">self.width = metrics.advance</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.width = metrics.width</span>
        <span class="s1">self.height = metrics.iceberg</span>
        <span class="s1">self.depth = -(metrics.iceberg - metrics.height)</span>

    <span class="s2">def </span><span class="s1">is_slanted(self) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">self._metrics.slanted</span>

    <span class="s2">def </span><span class="s1">get_kerning(self</span><span class="s2">, </span><span class="s1">next: Node | </span><span class="s2">None</span><span class="s1">) -&gt; float:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the amount of kerning between this and the given character. 
 
        This method is called when characters are strung together into `Hlist` 
        to create `Kern` nodes. 
        &quot;&quot;&quot;</span>
        <span class="s1">advance = self._metrics.advance - self.width</span>
        <span class="s1">kern = </span><span class="s3">0.</span>
        <span class="s2">if </span><span class="s1">isinstance(next</span><span class="s2">, </span><span class="s1">Char):</span>
            <span class="s1">kern = self.fontset.get_kern(</span>
                <span class="s1">self.font</span><span class="s2">, </span><span class="s1">self.font_class</span><span class="s2">, </span><span class="s1">self.c</span><span class="s2">, </span><span class="s1">self.fontsize</span><span class="s2">,</span>
                <span class="s1">next.font</span><span class="s2">, </span><span class="s1">next.font_class</span><span class="s2">, </span><span class="s1">next.c</span><span class="s2">, </span><span class="s1">next.fontsize</span><span class="s2">,</span>
                <span class="s1">self.dpi)</span>
        <span class="s2">return </span><span class="s1">advance + kern</span>

    <span class="s2">def </span><span class="s1">render(self</span><span class="s2">, </span><span class="s1">output: Output</span><span class="s2">, </span><span class="s1">x: float</span><span class="s2">, </span><span class="s1">y: float) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.fontset.render_glyph(</span>
            <span class="s1">output</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">,</span>
            <span class="s1">self.font</span><span class="s2">, </span><span class="s1">self.font_class</span><span class="s2">, </span><span class="s1">self.c</span><span class="s2">, </span><span class="s1">self.fontsize</span><span class="s2">, </span><span class="s1">self.dpi)</span>

    <span class="s2">def </span><span class="s1">shrink(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">super().shrink()</span>
        <span class="s2">if </span><span class="s1">self.size &lt; NUM_SIZE_LEVELS:</span>
            <span class="s1">self.fontsize *= SHRINK_FACTOR</span>
            <span class="s1">self.width    *= SHRINK_FACTOR</span>
            <span class="s1">self.height   *= SHRINK_FACTOR</span>
            <span class="s1">self.depth    *= SHRINK_FACTOR</span>


<span class="s2">class </span><span class="s1">Accent(Char):</span>
    <span class="s0">&quot;&quot;&quot; 
    The font metrics need to be dealt with differently for accents, 
    since they are already offset correctly from the baseline in 
    TrueType fonts. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">_update_metrics(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">metrics = self._metrics = self.fontset.get_metrics(</span>
            <span class="s1">self.font</span><span class="s2">, </span><span class="s1">self.font_class</span><span class="s2">, </span><span class="s1">self.c</span><span class="s2">, </span><span class="s1">self.fontsize</span><span class="s2">, </span><span class="s1">self.dpi)</span>
        <span class="s1">self.width = metrics.xmax - metrics.xmin</span>
        <span class="s1">self.height = metrics.ymax - metrics.ymin</span>
        <span class="s1">self.depth = </span><span class="s3">0</span>

    <span class="s2">def </span><span class="s1">shrink(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">super().shrink()</span>
        <span class="s1">self._update_metrics()</span>

    <span class="s2">def </span><span class="s1">render(self</span><span class="s2">, </span><span class="s1">output: Output</span><span class="s2">, </span><span class="s1">x: float</span><span class="s2">, </span><span class="s1">y: float) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.fontset.render_glyph(</span>
            <span class="s1">output</span><span class="s2">, </span><span class="s1">x - self._metrics.xmin</span><span class="s2">, </span><span class="s1">y + self._metrics.ymin</span><span class="s2">,</span>
            <span class="s1">self.font</span><span class="s2">, </span><span class="s1">self.font_class</span><span class="s2">, </span><span class="s1">self.c</span><span class="s2">, </span><span class="s1">self.fontsize</span><span class="s2">, </span><span class="s1">self.dpi)</span>


<span class="s2">class </span><span class="s1">List(Box):</span>
    <span class="s0">&quot;&quot;&quot;A list of nodes (either horizontal or vertical).&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">elements: T.Sequence[Node]):</span>
        <span class="s1">super().__init__(</span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0.</span><span class="s1">)</span>
        <span class="s1">self.shift_amount = </span><span class="s3">0.   </span><span class="s5"># An arbitrary offset</span>
        <span class="s1">self.children = [*elements]  </span><span class="s5"># The child nodes of this list</span>
        <span class="s5"># The following parameters are set in the vpack and hpack functions</span>
        <span class="s1">self.glue_set     = </span><span class="s3">0.   </span><span class="s5"># The glue setting of this list</span>
        <span class="s1">self.glue_sign    = </span><span class="s3">0    </span><span class="s5"># 0: normal, -1: shrinking, 1: stretching</span>
        <span class="s1">self.glue_order   = </span><span class="s3">0    </span><span class="s5"># The order of infinity (0 - 3) for the glue</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s4">'{}&lt;w={:.02f} h={:.02f} d={:.02f} s={:.02f}&gt;[{}]'</span><span class="s1">.format(</span>
            <span class="s1">super().__repr__()</span><span class="s2">,</span>
            <span class="s1">self.width</span><span class="s2">, </span><span class="s1">self.height</span><span class="s2">,</span>
            <span class="s1">self.depth</span><span class="s2">, </span><span class="s1">self.shift_amount</span><span class="s2">,</span>
            <span class="s4">', '</span><span class="s1">.join([repr(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self.children]))</span>

    <span class="s2">def </span><span class="s1">_set_glue(self</span><span class="s2">, </span><span class="s1">x: float</span><span class="s2">, </span><span class="s1">sign: int</span><span class="s2">, </span><span class="s1">totals: list[float]</span><span class="s2">,</span>
                  <span class="s1">error_type: str) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.glue_order = o = next(</span>
            <span class="s5"># Highest order of glue used by the members of this list.</span>
            <span class="s1">(i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(totals))[::-</span><span class="s3">1</span><span class="s1">] </span><span class="s2">if </span><span class="s1">totals[i] != </span><span class="s3">0</span><span class="s1">)</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">self.glue_sign = sign</span>
        <span class="s2">if </span><span class="s1">totals[o] != </span><span class="s3">0.</span><span class="s1">:</span>
            <span class="s1">self.glue_set = x / totals[o]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.glue_sign = </span><span class="s3">0</span>
            <span class="s1">self.glue_ratio = </span><span class="s3">0.</span>
        <span class="s2">if </span><span class="s1">o == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">len(self.children):</span>
                <span class="s1">_log.warning(</span><span class="s4">&quot;%s %s: %r&quot;</span><span class="s2">,</span>
                             <span class="s1">error_type</span><span class="s2">, </span><span class="s1">type(self).__name__</span><span class="s2">, </span><span class="s1">self)</span>

    <span class="s2">def </span><span class="s1">shrink(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">for </span><span class="s1">child </span><span class="s2">in </span><span class="s1">self.children:</span>
            <span class="s1">child.shrink()</span>
        <span class="s1">super().shrink()</span>
        <span class="s2">if </span><span class="s1">self.size &lt; NUM_SIZE_LEVELS:</span>
            <span class="s1">self.shift_amount *= SHRINK_FACTOR</span>
            <span class="s1">self.glue_set     *= SHRINK_FACTOR</span>


<span class="s2">class </span><span class="s1">Hlist(List):</span>
    <span class="s0">&quot;&quot;&quot;A horizontal list of boxes.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">elements: T.Sequence[Node]</span><span class="s2">, </span><span class="s1">w: float = </span><span class="s3">0.0</span><span class="s2">,</span>
                 <span class="s1">m: T.Literal[</span><span class="s4">'additional'</span><span class="s2">, </span><span class="s4">'exactly'</span><span class="s1">] = </span><span class="s4">'additional'</span><span class="s2">,</span>
                 <span class="s1">do_kern: bool = </span><span class="s2">True</span><span class="s1">):</span>
        <span class="s1">super().__init__(elements)</span>
        <span class="s2">if </span><span class="s1">do_kern:</span>
            <span class="s1">self.kern()</span>
        <span class="s1">self.hpack(w=w</span><span class="s2">, </span><span class="s1">m=m)</span>

    <span class="s2">def </span><span class="s1">kern(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Insert `Kern` nodes between `Char` nodes to set kerning. 
 
        The `Char` nodes themselves determine the amount of kerning they need 
        (in `~Char.get_kerning`), and this function just creates the correct 
        linked list. 
        &quot;&quot;&quot;</span>
        <span class="s1">new_children = []</span>
        <span class="s1">num_children = len(self.children)</span>
        <span class="s2">if </span><span class="s1">num_children:</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(num_children):</span>
                <span class="s1">elem = self.children[i]</span>
                <span class="s2">if </span><span class="s1">i &lt; num_children - </span><span class="s3">1</span><span class="s1">:</span>
                    <span class="s1">next = self.children[i + </span><span class="s3">1</span><span class="s1">]</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">next = </span><span class="s2">None</span>

                <span class="s1">new_children.append(elem)</span>
                <span class="s1">kerning_distance = elem.get_kerning(next)</span>
                <span class="s2">if </span><span class="s1">kerning_distance != </span><span class="s3">0.</span><span class="s1">:</span>
                    <span class="s1">kern = Kern(kerning_distance)</span>
                    <span class="s1">new_children.append(kern)</span>
            <span class="s1">self.children = new_children</span>

    <span class="s2">def </span><span class="s1">hpack(self</span><span class="s2">, </span><span class="s1">w: float = </span><span class="s3">0.0</span><span class="s2">,</span>
              <span class="s1">m: T.Literal[</span><span class="s4">'additional'</span><span class="s2">, </span><span class="s4">'exactly'</span><span class="s1">] = </span><span class="s4">'additional'</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">r&quot;&quot;&quot; 
        Compute the dimensions of the resulting boxes, and adjust the glue if 
        one of those dimensions is pre-specified.  The computed sizes normally 
        enclose all of the material inside the new box; but some items may 
        stick out if negative glue is used, if the box is overfull, or if a 
        ``\vbox`` includes other boxes that have been shifted left. 
 
        Parameters 
        ---------- 
        w : float, default: 0 
            A width. 
        m : {'exactly', 'additional'}, default: 'additional' 
            Whether to produce a box whose width is 'exactly' *w*; or a box 
            with the natural width of the contents, plus *w* ('additional'). 
 
        Notes 
        ----- 
        The defaults produce a box with the natural width of the contents. 
        &quot;&quot;&quot;</span>
        <span class="s5"># I don't know why these get reset in TeX.  Shift_amount is pretty</span>
        <span class="s5"># much useless if we do.</span>
        <span class="s5"># self.shift_amount = 0.</span>
        <span class="s1">h = </span><span class="s3">0.</span>
        <span class="s1">d = </span><span class="s3">0.</span>
        <span class="s1">x = </span><span class="s3">0.</span>
        <span class="s1">total_stretch = [</span><span class="s3">0.</span><span class="s1">] * </span><span class="s3">4</span>
        <span class="s1">total_shrink = [</span><span class="s3">0.</span><span class="s1">] * </span><span class="s3">4</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self.children:</span>
            <span class="s2">if </span><span class="s1">isinstance(p</span><span class="s2">, </span><span class="s1">Char):</span>
                <span class="s1">x += p.width</span>
                <span class="s1">h = max(h</span><span class="s2">, </span><span class="s1">p.height)</span>
                <span class="s1">d = max(d</span><span class="s2">, </span><span class="s1">p.depth)</span>
            <span class="s2">elif </span><span class="s1">isinstance(p</span><span class="s2">, </span><span class="s1">Box):</span>
                <span class="s1">x += p.width</span>
                <span class="s2">if not </span><span class="s1">np.isinf(p.height) </span><span class="s2">and not </span><span class="s1">np.isinf(p.depth):</span>
                    <span class="s1">s = getattr(p</span><span class="s2">, </span><span class="s4">'shift_amount'</span><span class="s2">, </span><span class="s3">0.</span><span class="s1">)</span>
                    <span class="s1">h = max(h</span><span class="s2">, </span><span class="s1">p.height - s)</span>
                    <span class="s1">d = max(d</span><span class="s2">, </span><span class="s1">p.depth + s)</span>
            <span class="s2">elif </span><span class="s1">isinstance(p</span><span class="s2">, </span><span class="s1">Glue):</span>
                <span class="s1">glue_spec = p.glue_spec</span>
                <span class="s1">x += glue_spec.width</span>
                <span class="s1">total_stretch[glue_spec.stretch_order] += glue_spec.stretch</span>
                <span class="s1">total_shrink[glue_spec.shrink_order] += glue_spec.shrink</span>
            <span class="s2">elif </span><span class="s1">isinstance(p</span><span class="s2">, </span><span class="s1">Kern):</span>
                <span class="s1">x += p.width</span>
        <span class="s1">self.height = h</span>
        <span class="s1">self.depth = d</span>

        <span class="s2">if </span><span class="s1">m == </span><span class="s4">'additional'</span><span class="s1">:</span>
            <span class="s1">w += x</span>
        <span class="s1">self.width = w</span>
        <span class="s1">x = w - x</span>

        <span class="s2">if </span><span class="s1">x == </span><span class="s3">0.</span><span class="s1">:</span>
            <span class="s1">self.glue_sign = </span><span class="s3">0</span>
            <span class="s1">self.glue_order = </span><span class="s3">0</span>
            <span class="s1">self.glue_ratio = </span><span class="s3">0.</span>
            <span class="s2">return</span>
        <span class="s2">if </span><span class="s1">x &gt; </span><span class="s3">0.</span><span class="s1">:</span>
            <span class="s1">self._set_glue(x</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">total_stretch</span><span class="s2">, </span><span class="s4">&quot;Overful&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._set_glue(x</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s2">, </span><span class="s1">total_shrink</span><span class="s2">, </span><span class="s4">&quot;Underful&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">Vlist(List):</span>
    <span class="s0">&quot;&quot;&quot;A vertical list of boxes.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">elements: T.Sequence[Node]</span><span class="s2">, </span><span class="s1">h: float = </span><span class="s3">0.0</span><span class="s2">,</span>
                 <span class="s1">m: T.Literal[</span><span class="s4">'additional'</span><span class="s2">, </span><span class="s4">'exactly'</span><span class="s1">] = </span><span class="s4">'additional'</span><span class="s1">):</span>
        <span class="s1">super().__init__(elements)</span>
        <span class="s1">self.vpack(h=h</span><span class="s2">, </span><span class="s1">m=m)</span>

    <span class="s2">def </span><span class="s1">vpack(self</span><span class="s2">, </span><span class="s1">h: float = </span><span class="s3">0.0</span><span class="s2">,</span>
              <span class="s1">m: T.Literal[</span><span class="s4">'additional'</span><span class="s2">, </span><span class="s4">'exactly'</span><span class="s1">] = </span><span class="s4">'additional'</span><span class="s2">,</span>
              <span class="s1">l: float = np.inf) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Compute the dimensions of the resulting boxes, and to adjust the glue 
        if one of those dimensions is pre-specified. 
 
        Parameters 
        ---------- 
        h : float, default: 0 
            A height. 
        m : {'exactly', 'additional'}, default: 'additional' 
            Whether to produce a box whose height is 'exactly' *h*; or a box 
            with the natural height of the contents, plus *h* ('additional'). 
        l : float, default: np.inf 
            The maximum height. 
 
        Notes 
        ----- 
        The defaults produce a box with the natural height of the contents. 
        &quot;&quot;&quot;</span>
        <span class="s5"># I don't know why these get reset in TeX.  Shift_amount is pretty</span>
        <span class="s5"># much useless if we do.</span>
        <span class="s5"># self.shift_amount = 0.</span>
        <span class="s1">w = </span><span class="s3">0.</span>
        <span class="s1">d = </span><span class="s3">0.</span>
        <span class="s1">x = </span><span class="s3">0.</span>
        <span class="s1">total_stretch = [</span><span class="s3">0.</span><span class="s1">] * </span><span class="s3">4</span>
        <span class="s1">total_shrink = [</span><span class="s3">0.</span><span class="s1">] * </span><span class="s3">4</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self.children:</span>
            <span class="s2">if </span><span class="s1">isinstance(p</span><span class="s2">, </span><span class="s1">Box):</span>
                <span class="s1">x += d + p.height</span>
                <span class="s1">d = p.depth</span>
                <span class="s2">if not </span><span class="s1">np.isinf(p.width):</span>
                    <span class="s1">s = getattr(p</span><span class="s2">, </span><span class="s4">'shift_amount'</span><span class="s2">, </span><span class="s3">0.</span><span class="s1">)</span>
                    <span class="s1">w = max(w</span><span class="s2">, </span><span class="s1">p.width + s)</span>
            <span class="s2">elif </span><span class="s1">isinstance(p</span><span class="s2">, </span><span class="s1">Glue):</span>
                <span class="s1">x += d</span>
                <span class="s1">d = </span><span class="s3">0.</span>
                <span class="s1">glue_spec = p.glue_spec</span>
                <span class="s1">x += glue_spec.width</span>
                <span class="s1">total_stretch[glue_spec.stretch_order] += glue_spec.stretch</span>
                <span class="s1">total_shrink[glue_spec.shrink_order] += glue_spec.shrink</span>
            <span class="s2">elif </span><span class="s1">isinstance(p</span><span class="s2">, </span><span class="s1">Kern):</span>
                <span class="s1">x += d + p.width</span>
                <span class="s1">d = </span><span class="s3">0.</span>
            <span class="s2">elif </span><span class="s1">isinstance(p</span><span class="s2">, </span><span class="s1">Char):</span>
                <span class="s2">raise </span><span class="s1">RuntimeError(</span>
                    <span class="s4">&quot;Internal mathtext error: Char node found in Vlist&quot;</span><span class="s1">)</span>

        <span class="s1">self.width = w</span>
        <span class="s2">if </span><span class="s1">d &gt; l:</span>
            <span class="s1">x += d - l</span>
            <span class="s1">self.depth = l</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.depth = d</span>

        <span class="s2">if </span><span class="s1">m == </span><span class="s4">'additional'</span><span class="s1">:</span>
            <span class="s1">h += x</span>
        <span class="s1">self.height = h</span>
        <span class="s1">x = h - x</span>

        <span class="s2">if </span><span class="s1">x == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">self.glue_sign = </span><span class="s3">0</span>
            <span class="s1">self.glue_order = </span><span class="s3">0</span>
            <span class="s1">self.glue_ratio = </span><span class="s3">0.</span>
            <span class="s2">return</span>

        <span class="s2">if </span><span class="s1">x &gt; </span><span class="s3">0.</span><span class="s1">:</span>
            <span class="s1">self._set_glue(x</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">total_stretch</span><span class="s2">, </span><span class="s4">&quot;Overful&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._set_glue(x</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s2">, </span><span class="s1">total_shrink</span><span class="s2">, </span><span class="s4">&quot;Underful&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">Rule(Box):</span>
    <span class="s0">&quot;&quot;&quot; 
    A solid black rectangle. 
 
    It has *width*, *depth*, and *height* fields just as in an `Hlist`. 
    However, if any of these dimensions is inf, the actual value will be 
    determined by running the rule up to the boundary of the innermost 
    enclosing box.  This is called a &quot;running dimension&quot;.  The width is never 
    running in an `Hlist`; the height and depth are never running in a `Vlist`. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">width: float</span><span class="s2">, </span><span class="s1">height: float</span><span class="s2">, </span><span class="s1">depth: float</span><span class="s2">, </span><span class="s1">state: ParserState):</span>
        <span class="s1">super().__init__(width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">depth)</span>
        <span class="s1">self.fontset = state.fontset</span>

    <span class="s2">def </span><span class="s1">render(self</span><span class="s2">, </span><span class="s1">output: Output</span><span class="s2">,  </span><span class="s5"># type: ignore[override]</span>
               <span class="s1">x: float</span><span class="s2">, </span><span class="s1">y: float</span><span class="s2">, </span><span class="s1">w: float</span><span class="s2">, </span><span class="s1">h: float) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.fontset.render_rect_filled(output</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">x + w</span><span class="s2">, </span><span class="s1">y + h)</span>


<span class="s2">class </span><span class="s1">Hrule(Rule):</span>
    <span class="s0">&quot;&quot;&quot;Convenience class to create a horizontal rule.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">state: ParserState</span><span class="s2">, </span><span class="s1">thickness: float | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">thickness </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">thickness = state.get_current_underline_thickness()</span>
        <span class="s1">height = depth = thickness * </span><span class="s3">0.5</span>
        <span class="s1">super().__init__(np.inf</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">depth</span><span class="s2">, </span><span class="s1">state)</span>


<span class="s2">class </span><span class="s1">Vrule(Rule):</span>
    <span class="s0">&quot;&quot;&quot;Convenience class to create a vertical rule.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">state: ParserState):</span>
        <span class="s1">thickness = state.get_current_underline_thickness()</span>
        <span class="s1">super().__init__(thickness</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">state)</span>


<span class="s2">class </span><span class="s1">_GlueSpec(NamedTuple):</span>
    <span class="s1">width: float</span>
    <span class="s1">stretch: float</span>
    <span class="s1">stretch_order: int</span>
    <span class="s1">shrink: float</span>
    <span class="s1">shrink_order: int</span>


<span class="s1">_GlueSpec._named = {  </span><span class="s5"># type: ignore[attr-defined]</span>
    <span class="s4">'fil'</span><span class="s1">:         _GlueSpec(</span><span class="s3">0.</span><span class="s2">, </span><span class="s3">1.</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s4">'fill'</span><span class="s1">:        _GlueSpec(</span><span class="s3">0.</span><span class="s2">, </span><span class="s3">1.</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s4">'filll'</span><span class="s1">:       _GlueSpec(</span><span class="s3">0.</span><span class="s2">, </span><span class="s3">1.</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s4">'neg_fil'</span><span class="s1">:     _GlueSpec(</span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1.</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s4">'neg_fill'</span><span class="s1">:    _GlueSpec(</span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1.</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s4">'neg_filll'</span><span class="s1">:   _GlueSpec(</span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1.</span><span class="s2">, </span><span class="s3">3</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s4">'empty'</span><span class="s1">:       _GlueSpec(</span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s4">'ss'</span><span class="s1">:          _GlueSpec(</span><span class="s3">0.</span><span class="s2">, </span><span class="s3">1.</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1.</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span><span class="s2">,</span>
<span class="s1">}</span>


<span class="s2">class </span><span class="s1">Glue(Node):</span>
    <span class="s0">&quot;&quot;&quot; 
    Most of the information in this object is stored in the underlying 
    ``_GlueSpec`` class, which is shared between multiple glue objects. 
    (This is a memory optimization which probably doesn't matter anymore, but 
    it's easier to stick to what TeX does.) 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">,</span>
                 <span class="s1">glue_type: _GlueSpec | T.Literal[</span><span class="s4">&quot;fil&quot;</span><span class="s2">, </span><span class="s4">&quot;fill&quot;</span><span class="s2">, </span><span class="s4">&quot;filll&quot;</span><span class="s2">,</span>
                                                  <span class="s4">&quot;neg_fil&quot;</span><span class="s2">, </span><span class="s4">&quot;neg_fill&quot;</span><span class="s2">, </span><span class="s4">&quot;neg_filll&quot;</span><span class="s2">,</span>
                                                  <span class="s4">&quot;empty&quot;</span><span class="s2">, </span><span class="s4">&quot;ss&quot;</span><span class="s1">]):</span>
        <span class="s1">super().__init__()</span>
        <span class="s2">if </span><span class="s1">isinstance(glue_type</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">glue_spec = _GlueSpec._named[glue_type]  </span><span class="s5"># type: ignore[attr-defined]</span>
        <span class="s2">elif </span><span class="s1">isinstance(glue_type</span><span class="s2">, </span><span class="s1">_GlueSpec):</span>
            <span class="s1">glue_spec = glue_type</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;glue_type must be a glue spec name or instance&quot;</span><span class="s1">)</span>
        <span class="s1">self.glue_spec = glue_spec</span>

    <span class="s2">def </span><span class="s1">shrink(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">super().shrink()</span>
        <span class="s2">if </span><span class="s1">self.size &lt; NUM_SIZE_LEVELS:</span>
            <span class="s1">g = self.glue_spec</span>
            <span class="s1">self.glue_spec = g._replace(width=g.width * SHRINK_FACTOR)</span>


<span class="s2">class </span><span class="s1">HCentered(Hlist):</span>
    <span class="s0">&quot;&quot;&quot; 
    A convenience class to create an `Hlist` whose contents are 
    centered within its enclosing box. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">elements: list[Node]):</span>
        <span class="s1">super().__init__([Glue(</span><span class="s4">'ss'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">*elements</span><span class="s2">, </span><span class="s1">Glue(</span><span class="s4">'ss'</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">do_kern=</span><span class="s2">False</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">VCentered(Vlist):</span>
    <span class="s0">&quot;&quot;&quot; 
    A convenience class to create a `Vlist` whose contents are 
    centered within its enclosing box. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">elements: list[Node]):</span>
        <span class="s1">super().__init__([Glue(</span><span class="s4">'ss'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">*elements</span><span class="s2">, </span><span class="s1">Glue(</span><span class="s4">'ss'</span><span class="s1">)])</span>


<span class="s2">class </span><span class="s1">Kern(Node):</span>
    <span class="s0">&quot;&quot;&quot; 
    A `Kern` node has a width field to specify a (normally 
    negative) amount of spacing. This spacing correction appears in 
    horizontal lists between letters like A and V when the font 
    designer said that it looks better to move them closer together or 
    further apart. A kern node can also appear in a vertical list, 
    when its *width* denotes additional spacing in the vertical 
    direction. 
    &quot;&quot;&quot;</span>

    <span class="s1">height = </span><span class="s3">0</span>
    <span class="s1">depth = </span><span class="s3">0</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">width: float):</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.width = width</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s4">&quot;k%.02f&quot; </span><span class="s1">% self.width</span>

    <span class="s2">def </span><span class="s1">shrink(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">super().shrink()</span>
        <span class="s2">if </span><span class="s1">self.size &lt; NUM_SIZE_LEVELS:</span>
            <span class="s1">self.width *= SHRINK_FACTOR</span>


<span class="s2">class </span><span class="s1">AutoHeightChar(Hlist):</span>
    <span class="s0">&quot;&quot;&quot; 
    A character as close to the given height and depth as possible. 
 
    When using a font with multiple height versions of some characters (such as 
    the BaKoMa fonts), the correct glyph will be selected, otherwise this will 
    always just return a scaled version of the glyph. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">c: str</span><span class="s2">, </span><span class="s1">height: float</span><span class="s2">, </span><span class="s1">depth: float</span><span class="s2">, </span><span class="s1">state: ParserState</span><span class="s2">,</span>
                 <span class="s1">always: bool = </span><span class="s2">False, </span><span class="s1">factor: float | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">alternatives = state.fontset.get_sized_alternatives_for_symbol(</span>
            <span class="s1">state.font</span><span class="s2">, </span><span class="s1">c)</span>

        <span class="s1">xHeight = state.fontset.get_xheight(</span>
            <span class="s1">state.font</span><span class="s2">, </span><span class="s1">state.fontsize</span><span class="s2">, </span><span class="s1">state.dpi)</span>

        <span class="s1">state = state.copy()</span>
        <span class="s1">target_total = height + depth</span>
        <span class="s2">for </span><span class="s1">fontname</span><span class="s2">, </span><span class="s1">sym </span><span class="s2">in </span><span class="s1">alternatives:</span>
            <span class="s1">state.font = fontname</span>
            <span class="s1">char = Char(sym</span><span class="s2">, </span><span class="s1">state)</span>
            <span class="s5"># Ensure that size 0 is chosen when the text is regular sized but</span>
            <span class="s5"># with descender glyphs by subtracting 0.2 * xHeight</span>
            <span class="s2">if </span><span class="s1">char.height + char.depth &gt;= target_total - </span><span class="s3">0.2 </span><span class="s1">* xHeight:</span>
                <span class="s2">break</span>

        <span class="s1">shift = </span><span class="s3">0.0</span>
        <span class="s2">if </span><span class="s1">state.font != </span><span class="s3">0 </span><span class="s2">or </span><span class="s1">len(alternatives) == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">factor </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">factor = target_total / (char.height + char.depth)</span>
            <span class="s1">state.fontsize *= factor</span>
            <span class="s1">char = Char(sym</span><span class="s2">, </span><span class="s1">state)</span>

            <span class="s1">shift = (depth - char.depth)</span>

        <span class="s1">super().__init__([char])</span>
        <span class="s1">self.shift_amount = shift</span>


<span class="s2">class </span><span class="s1">AutoWidthChar(Hlist):</span>
    <span class="s0">&quot;&quot;&quot; 
    A character as close to the given width as possible. 
 
    When using a font with multiple width versions of some characters (such as 
    the BaKoMa fonts), the correct glyph will be selected, otherwise this will 
    always just return a scaled version of the glyph. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">c: str</span><span class="s2">, </span><span class="s1">width: float</span><span class="s2">, </span><span class="s1">state: ParserState</span><span class="s2">, </span><span class="s1">always: bool = </span><span class="s2">False,</span>
                 <span class="s1">char_class: type[Char] = Char):</span>
        <span class="s1">alternatives = state.fontset.get_sized_alternatives_for_symbol(</span>
            <span class="s1">state.font</span><span class="s2">, </span><span class="s1">c)</span>

        <span class="s1">state = state.copy()</span>
        <span class="s2">for </span><span class="s1">fontname</span><span class="s2">, </span><span class="s1">sym </span><span class="s2">in </span><span class="s1">alternatives:</span>
            <span class="s1">state.font = fontname</span>
            <span class="s1">char = char_class(sym</span><span class="s2">, </span><span class="s1">state)</span>
            <span class="s2">if </span><span class="s1">char.width &gt;= width:</span>
                <span class="s2">break</span>

        <span class="s1">factor = width / char.width</span>
        <span class="s1">state.fontsize *= factor</span>
        <span class="s1">char = char_class(sym</span><span class="s2">, </span><span class="s1">state)</span>

        <span class="s1">super().__init__([char])</span>
        <span class="s1">self.width = char.width</span>


<span class="s2">def </span><span class="s1">ship(box: Box</span><span class="s2">, </span><span class="s1">xy: tuple[float</span><span class="s2">, </span><span class="s1">float] = (</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)) -&gt; Output:</span>
    <span class="s0">&quot;&quot;&quot; 
    Ship out *box* at offset *xy*, converting it to an `Output`. 
 
    Since boxes can be inside of boxes inside of boxes, the main work of `ship` 
    is done by two mutually recursive routines, `hlist_out` and `vlist_out`, 
    which traverse the `Hlist` nodes and `Vlist` nodes inside of horizontal 
    and vertical boxes.  The global variables used in TeX to store state as it 
    processes have become local variables here. 
    &quot;&quot;&quot;</span>
    <span class="s1">ox</span><span class="s2">, </span><span class="s1">oy = xy</span>
    <span class="s1">cur_v = </span><span class="s3">0.</span>
    <span class="s1">cur_h = </span><span class="s3">0.</span>
    <span class="s1">off_h = ox</span>
    <span class="s1">off_v = oy + box.height</span>
    <span class="s1">output = Output(box)</span>

    <span class="s2">def </span><span class="s1">clamp(value: float) -&gt; float:</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s3">1e9 </span><span class="s2">if </span><span class="s1">value &lt; -</span><span class="s3">1e9 </span><span class="s2">else </span><span class="s1">+</span><span class="s3">1e9 </span><span class="s2">if </span><span class="s1">value &gt; +</span><span class="s3">1e9 </span><span class="s2">else </span><span class="s1">value</span>

    <span class="s2">def </span><span class="s1">hlist_out(box: Hlist) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">nonlocal </span><span class="s1">cur_v</span><span class="s2">, </span><span class="s1">cur_h</span><span class="s2">, </span><span class="s1">off_h</span><span class="s2">, </span><span class="s1">off_v</span>

        <span class="s1">cur_g = </span><span class="s3">0</span>
        <span class="s1">cur_glue = </span><span class="s3">0.</span>
        <span class="s1">glue_order = box.glue_order</span>
        <span class="s1">glue_sign = box.glue_sign</span>
        <span class="s1">base_line = cur_v</span>
        <span class="s1">left_edge = cur_h</span>

        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">box.children:</span>
            <span class="s2">if </span><span class="s1">isinstance(p</span><span class="s2">, </span><span class="s1">Char):</span>
                <span class="s1">p.render(output</span><span class="s2">, </span><span class="s1">cur_h + off_h</span><span class="s2">, </span><span class="s1">cur_v + off_v)</span>
                <span class="s1">cur_h += p.width</span>
            <span class="s2">elif </span><span class="s1">isinstance(p</span><span class="s2">, </span><span class="s1">Kern):</span>
                <span class="s1">cur_h += p.width</span>
            <span class="s2">elif </span><span class="s1">isinstance(p</span><span class="s2">, </span><span class="s1">List):</span>
                <span class="s5"># node623</span>
                <span class="s2">if </span><span class="s1">len(p.children) == </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s1">cur_h += p.width</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">edge = cur_h</span>
                    <span class="s1">cur_v = base_line + p.shift_amount</span>
                    <span class="s2">if </span><span class="s1">isinstance(p</span><span class="s2">, </span><span class="s1">Hlist):</span>
                        <span class="s1">hlist_out(p)</span>
                    <span class="s2">elif </span><span class="s1">isinstance(p</span><span class="s2">, </span><span class="s1">Vlist):</span>
                        <span class="s5"># p.vpack(box.height + box.depth, 'exactly')</span>
                        <span class="s1">vlist_out(p)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s2">assert False, </span><span class="s4">&quot;unreachable code&quot;</span>
                    <span class="s1">cur_h = edge + p.width</span>
                    <span class="s1">cur_v = base_line</span>
            <span class="s2">elif </span><span class="s1">isinstance(p</span><span class="s2">, </span><span class="s1">Box):</span>
                <span class="s5"># node624</span>
                <span class="s1">rule_height = p.height</span>
                <span class="s1">rule_depth = p.depth</span>
                <span class="s1">rule_width = p.width</span>
                <span class="s2">if </span><span class="s1">np.isinf(rule_height):</span>
                    <span class="s1">rule_height = box.height</span>
                <span class="s2">if </span><span class="s1">np.isinf(rule_depth):</span>
                    <span class="s1">rule_depth = box.depth</span>
                <span class="s2">if </span><span class="s1">rule_height &gt; </span><span class="s3">0 </span><span class="s2">and </span><span class="s1">rule_width &gt; </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s1">cur_v = base_line + rule_depth</span>
                    <span class="s1">p.render(output</span><span class="s2">,</span>
                             <span class="s1">cur_h + off_h</span><span class="s2">, </span><span class="s1">cur_v + off_v</span><span class="s2">,</span>
                             <span class="s1">rule_width</span><span class="s2">, </span><span class="s1">rule_height)</span>
                    <span class="s1">cur_v = base_line</span>
                <span class="s1">cur_h += rule_width</span>
            <span class="s2">elif </span><span class="s1">isinstance(p</span><span class="s2">, </span><span class="s1">Glue):</span>
                <span class="s5"># node625</span>
                <span class="s1">glue_spec = p.glue_spec</span>
                <span class="s1">rule_width = glue_spec.width - cur_g</span>
                <span class="s2">if </span><span class="s1">glue_sign != </span><span class="s3">0</span><span class="s1">:  </span><span class="s5"># normal</span>
                    <span class="s2">if </span><span class="s1">glue_sign == </span><span class="s3">1</span><span class="s1">:  </span><span class="s5"># stretching</span>
                        <span class="s2">if </span><span class="s1">glue_spec.stretch_order == glue_order:</span>
                            <span class="s1">cur_glue += glue_spec.stretch</span>
                            <span class="s1">cur_g = round(clamp(box.glue_set * cur_glue))</span>
                    <span class="s2">elif </span><span class="s1">glue_spec.shrink_order == glue_order:</span>
                        <span class="s1">cur_glue += glue_spec.shrink</span>
                        <span class="s1">cur_g = round(clamp(box.glue_set * cur_glue))</span>
                <span class="s1">rule_width += cur_g</span>
                <span class="s1">cur_h += rule_width</span>

    <span class="s2">def </span><span class="s1">vlist_out(box: Vlist) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">nonlocal </span><span class="s1">cur_v</span><span class="s2">, </span><span class="s1">cur_h</span><span class="s2">, </span><span class="s1">off_h</span><span class="s2">, </span><span class="s1">off_v</span>

        <span class="s1">cur_g = </span><span class="s3">0</span>
        <span class="s1">cur_glue = </span><span class="s3">0.</span>
        <span class="s1">glue_order = box.glue_order</span>
        <span class="s1">glue_sign = box.glue_sign</span>
        <span class="s1">left_edge = cur_h</span>
        <span class="s1">cur_v -= box.height</span>
        <span class="s1">top_edge = cur_v</span>

        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">box.children:</span>
            <span class="s2">if </span><span class="s1">isinstance(p</span><span class="s2">, </span><span class="s1">Kern):</span>
                <span class="s1">cur_v += p.width</span>
            <span class="s2">elif </span><span class="s1">isinstance(p</span><span class="s2">, </span><span class="s1">List):</span>
                <span class="s2">if </span><span class="s1">len(p.children) == </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s1">cur_v += p.height + p.depth</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">cur_v += p.height</span>
                    <span class="s1">cur_h = left_edge + p.shift_amount</span>
                    <span class="s1">save_v = cur_v</span>
                    <span class="s1">p.width = box.width</span>
                    <span class="s2">if </span><span class="s1">isinstance(p</span><span class="s2">, </span><span class="s1">Hlist):</span>
                        <span class="s1">hlist_out(p)</span>
                    <span class="s2">elif </span><span class="s1">isinstance(p</span><span class="s2">, </span><span class="s1">Vlist):</span>
                        <span class="s1">vlist_out(p)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s2">assert False, </span><span class="s4">&quot;unreachable code&quot;</span>
                    <span class="s1">cur_v = save_v + p.depth</span>
                    <span class="s1">cur_h = left_edge</span>
            <span class="s2">elif </span><span class="s1">isinstance(p</span><span class="s2">, </span><span class="s1">Box):</span>
                <span class="s1">rule_height = p.height</span>
                <span class="s1">rule_depth = p.depth</span>
                <span class="s1">rule_width = p.width</span>
                <span class="s2">if </span><span class="s1">np.isinf(rule_width):</span>
                    <span class="s1">rule_width = box.width</span>
                <span class="s1">rule_height += rule_depth</span>
                <span class="s2">if </span><span class="s1">rule_height &gt; </span><span class="s3">0 </span><span class="s2">and </span><span class="s1">rule_depth &gt; </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s1">cur_v += rule_height</span>
                    <span class="s1">p.render(output</span><span class="s2">,</span>
                             <span class="s1">cur_h + off_h</span><span class="s2">, </span><span class="s1">cur_v + off_v</span><span class="s2">,</span>
                             <span class="s1">rule_width</span><span class="s2">, </span><span class="s1">rule_height)</span>
            <span class="s2">elif </span><span class="s1">isinstance(p</span><span class="s2">, </span><span class="s1">Glue):</span>
                <span class="s1">glue_spec = p.glue_spec</span>
                <span class="s1">rule_height = glue_spec.width - cur_g</span>
                <span class="s2">if </span><span class="s1">glue_sign != </span><span class="s3">0</span><span class="s1">:  </span><span class="s5"># normal</span>
                    <span class="s2">if </span><span class="s1">glue_sign == </span><span class="s3">1</span><span class="s1">:  </span><span class="s5"># stretching</span>
                        <span class="s2">if </span><span class="s1">glue_spec.stretch_order == glue_order:</span>
                            <span class="s1">cur_glue += glue_spec.stretch</span>
                            <span class="s1">cur_g = round(clamp(box.glue_set * cur_glue))</span>
                    <span class="s2">elif </span><span class="s1">glue_spec.shrink_order == glue_order:  </span><span class="s5"># shrinking</span>
                        <span class="s1">cur_glue += glue_spec.shrink</span>
                        <span class="s1">cur_g = round(clamp(box.glue_set * cur_glue))</span>
                <span class="s1">rule_height += cur_g</span>
                <span class="s1">cur_v += rule_height</span>
            <span class="s2">elif </span><span class="s1">isinstance(p</span><span class="s2">, </span><span class="s1">Char):</span>
                <span class="s2">raise </span><span class="s1">RuntimeError(</span>
                    <span class="s4">&quot;Internal mathtext error: Char node found in vlist&quot;</span><span class="s1">)</span>

    <span class="s2">assert </span><span class="s1">isinstance(box</span><span class="s2">, </span><span class="s1">Hlist)</span>
    <span class="s1">hlist_out(box)</span>
    <span class="s2">return </span><span class="s1">output</span>


<span class="s5">##############################################################################</span>
<span class="s5"># PARSER</span>


<span class="s2">def </span><span class="s1">Error(msg: str) -&gt; ParserElement:</span>
    <span class="s0">&quot;&quot;&quot;Helper class to raise parser errors.&quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">raise_error(s: str</span><span class="s2">, </span><span class="s1">loc: int</span><span class="s2">, </span><span class="s1">toks: ParseResults) -&gt; T.Any:</span>
        <span class="s2">raise </span><span class="s1">ParseFatalException(s</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">msg)</span>

    <span class="s2">return </span><span class="s1">Empty().setParseAction(raise_error)</span>


<span class="s2">class </span><span class="s1">ParserState:</span>
    <span class="s0">&quot;&quot;&quot; 
    Parser state. 
 
    States are pushed and popped from a stack as necessary, and the &quot;current&quot; 
    state is always at the top of the stack. 
 
    Upon entering and leaving a group { } or math/non-math, the stack is pushed 
    and popped accordingly. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">fontset: Fonts</span><span class="s2">, </span><span class="s1">font: str</span><span class="s2">, </span><span class="s1">font_class: str</span><span class="s2">, </span><span class="s1">fontsize: float</span><span class="s2">,</span>
                 <span class="s1">dpi: float):</span>
        <span class="s1">self.fontset = fontset</span>
        <span class="s1">self._font = font</span>
        <span class="s1">self.font_class = font_class</span>
        <span class="s1">self.fontsize = fontsize</span>
        <span class="s1">self.dpi = dpi</span>

    <span class="s2">def </span><span class="s1">copy(self) -&gt; ParserState:</span>
        <span class="s2">return </span><span class="s1">copy.copy(self)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">font(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">self._font</span>

    <span class="s1">@font.setter</span>
    <span class="s2">def </span><span class="s1">font(self</span><span class="s2">, </span><span class="s1">name: str) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">(</span><span class="s4">'rm'</span><span class="s2">, </span><span class="s4">'it'</span><span class="s2">, </span><span class="s4">'bf'</span><span class="s2">, </span><span class="s4">'bfit'</span><span class="s1">):</span>
            <span class="s1">self.font_class = name</span>
        <span class="s1">self._font = name</span>

    <span class="s2">def </span><span class="s1">get_current_underline_thickness(self) -&gt; float:</span>
        <span class="s0">&quot;&quot;&quot;Return the underline thickness for this state.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.fontset.get_underline_thickness(</span>
            <span class="s1">self.font</span><span class="s2">, </span><span class="s1">self.fontsize</span><span class="s2">, </span><span class="s1">self.dpi)</span>


<span class="s2">def </span><span class="s1">cmd(expr: str</span><span class="s2">, </span><span class="s1">args: ParserElement) -&gt; ParserElement:</span>
    <span class="s0">r&quot;&quot;&quot; 
    Helper to define TeX commands. 
 
    ``cmd(&quot;\cmd&quot;, args)`` is equivalent to 
    ``&quot;\cmd&quot; - (args | Error(&quot;Expected \cmd{arg}{...}&quot;))`` where the names in 
    the error message are taken from element names in *args*.  If *expr* 
    already includes arguments (e.g. &quot;\cmd{arg}{...}&quot;), then they are stripped 
    when constructing the parse element, but kept (and *expr* is used as is) in 
    the error message. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">names(elt: ParserElement) -&gt; T.Generator[str</span><span class="s2">, None, None</span><span class="s1">]:</span>
        <span class="s2">if </span><span class="s1">isinstance(elt</span><span class="s2">, </span><span class="s1">ParseExpression):</span>
            <span class="s2">for </span><span class="s1">expr </span><span class="s2">in </span><span class="s1">elt.exprs:</span>
                <span class="s2">yield from </span><span class="s1">names(expr)</span>
        <span class="s2">elif </span><span class="s1">elt.resultsName:</span>
            <span class="s2">yield </span><span class="s1">elt.resultsName</span>

    <span class="s1">csname = expr.split(</span><span class="s4">&quot;{&quot;</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">err = (csname + </span><span class="s4">&quot;&quot;</span><span class="s1">.join(</span><span class="s4">&quot;{%s}&quot; </span><span class="s1">% name </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">names(args))</span>
           <span class="s2">if </span><span class="s1">expr == csname </span><span class="s2">else </span><span class="s1">expr)</span>
    <span class="s2">return </span><span class="s1">csname - (args | Error(</span><span class="s4">f&quot;Expected </span><span class="s2">{</span><span class="s1">err</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">))</span>


<span class="s2">class </span><span class="s1">Parser:</span>
    <span class="s0">&quot;&quot;&quot; 
    A pyparsing-based parser for strings containing math expressions. 
 
    Raw text may also appear outside of pairs of ``$``. 
 
    The grammar is based directly on that in TeX, though it cuts a few corners. 
    &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">_MathStyle(enum.Enum):</span>
        <span class="s1">DISPLAYSTYLE = </span><span class="s3">0</span>
        <span class="s1">TEXTSTYLE = </span><span class="s3">1</span>
        <span class="s1">SCRIPTSTYLE = </span><span class="s3">2</span>
        <span class="s1">SCRIPTSCRIPTSTYLE = </span><span class="s3">3</span>

    <span class="s1">_binary_operators = set(</span>
      <span class="s4">'+ * - </span><span class="s2">\N{MINUS SIGN}</span><span class="s4">'</span>
      <span class="s4">r''' 
      \pm             \sqcap                   \rhd 
      \mp             \sqcup                   \unlhd 
      \times          \vee                     \unrhd 
      \div            \wedge                   \oplus 
      \ast            \setminus                \ominus 
      \star           \wr                      \otimes 
      \circ           \diamond                 \oslash 
      \bullet         \bigtriangleup           \odot 
      \cdot           \bigtriangledown         \bigcirc 
      \cap            \triangleleft            \dagger 
      \cup            \triangleright           \ddagger 
      \uplus          \lhd                     \amalg 
      \dotplus        \dotminus                \Cap 
      \Cup            \barwedge                \boxdot 
      \boxminus       \boxplus                 \boxtimes 
      \curlyvee       \curlywedge              \divideontimes 
      \doublebarwedge \leftthreetimes          \rightthreetimes 
      \slash          \veebar                  \barvee 
      \cupdot         \intercal                \amalg 
      \circledcirc    \circleddash             \circledast 
      \boxbar         \obar                    \merge 
      \minuscolon     \dotsminusdots 
      '''</span><span class="s1">.split())</span>

    <span class="s1">_relation_symbols = set(</span><span class="s4">r''' 
      = &lt; &gt; : 
      \leq          \geq          \equiv       \models 
      \prec         \succ         \sim         \perp 
      \preceq       \succeq       \simeq       \mid 
      \ll           \gg           \asymp       \parallel 
      \subset       \supset       \approx      \bowtie 
      \subseteq     \supseteq     \cong        \Join 
      \sqsubset     \sqsupset     \neq         \smile 
      \sqsubseteq   \sqsupseteq   \doteq       \frown 
      \in           \ni           \propto      \vdash 
      \dashv        \dots         \doteqdot    \leqq 
      \geqq         \lneqq        \gneqq       \lessgtr 
      \leqslant     \geqslant     \eqgtr       \eqless 
      \eqslantless  \eqslantgtr   \lesseqgtr   \backsim 
      \backsimeq    \lesssim      \gtrsim      \precsim 
      \precnsim     \gnsim        \lnsim       \succsim 
      \succnsim     \nsim         \lesseqqgtr  \gtreqqless 
      \gtreqless    \subseteqq    \supseteqq   \subsetneqq 
      \supsetneqq   \lessapprox   \approxeq    \gtrapprox 
      \precapprox   \succapprox   \precnapprox \succnapprox 
      \npreccurlyeq \nsucccurlyeq \nsqsubseteq \nsqsupseteq 
      \sqsubsetneq  \sqsupsetneq  \nlesssim    \ngtrsim 
      \nlessgtr     \ngtrless     \lnapprox    \gnapprox 
      \napprox      \approxeq     \approxident \lll 
      \ggg          \nparallel    \Vdash       \Vvdash 
      \nVdash       \nvdash       \vDash       \nvDash 
      \nVDash       \oequal       \simneqq     \triangle 
      \triangleq         \triangleeq         \triangleleft 
      \triangleright     \ntriangleleft      \ntriangleright 
      \trianglelefteq    \ntrianglelefteq    \trianglerighteq 
      \ntrianglerighteq  \blacktriangleleft  \blacktriangleright 
      \equalparallel     \measuredrightangle \varlrtriangle 
      \Doteq        \Bumpeq       \Subset      \Supset 
      \backepsilon  \because      \therefore   \bot 
      \top          \bumpeq       \circeq      \coloneq 
      \curlyeqprec  \curlyeqsucc  \eqcirc      \eqcolon 
      \eqsim        \fallingdotseq \gtrdot     \gtrless 
      \ltimes       \rtimes       \lessdot     \ne 
      \ncong        \nequiv       \ngeq        \ngtr 
      \nleq         \nless        \nmid        \notin 
      \nprec        \nsubset      \nsubseteq   \nsucc 
      \nsupset      \nsupseteq    \pitchfork   \preccurlyeq 
      \risingdotseq \subsetneq    \succcurlyeq \supsetneq 
      \varpropto    \vartriangleleft \scurel 
      \vartriangleright \rightangle \equal     \backcong 
      \eqdef        \wedgeq       \questeq     \between 
      \veeeq        \disin        \varisins    \isins 
      \isindot      \varisinobar  \isinobar    \isinvb 
      \isinE        \nisd         \varnis      \nis 
      \varniobar    \niobar       \bagmember   \ratio 
      \Equiv        \stareq       \measeq      \arceq 
      \rightassert  \rightModels  \smallin     \smallowns 
      \notsmallowns \nsimeq'''</span><span class="s1">.split())</span>

    <span class="s1">_arrow_symbols = set(</span><span class="s4">r&quot;&quot;&quot; 
     \leftarrow \longleftarrow \uparrow \Leftarrow \Longleftarrow 
     \Uparrow \rightarrow \longrightarrow \downarrow \Rightarrow 
     \Longrightarrow \Downarrow \leftrightarrow \updownarrow 
     \longleftrightarrow \updownarrow \Leftrightarrow 
     \Longleftrightarrow \Updownarrow \mapsto \longmapsto \nearrow 
     \hookleftarrow \hookrightarrow \searrow \leftharpoonup 
     \rightharpoonup \swarrow \leftharpoondown \rightharpoondown 
     \nwarrow \rightleftharpoons \leadsto \dashrightarrow 
     \dashleftarrow \leftleftarrows \leftrightarrows \Lleftarrow 
     \Rrightarrow \twoheadleftarrow \leftarrowtail \looparrowleft 
     \leftrightharpoons \curvearrowleft \circlearrowleft \Lsh 
     \upuparrows \upharpoonleft \downharpoonleft \multimap 
     \leftrightsquigarrow \rightrightarrows \rightleftarrows 
     \rightrightarrows \rightleftarrows \twoheadrightarrow 
     \rightarrowtail \looparrowright \rightleftharpoons 
     \curvearrowright \circlearrowright \Rsh \downdownarrows 
     \upharpoonright \downharpoonright \rightsquigarrow \nleftarrow 
     \nrightarrow \nLeftarrow \nRightarrow \nleftrightarrow 
     \nLeftrightarrow \to \Swarrow \Searrow \Nwarrow \Nearrow 
     \leftsquigarrow \overleftarrow \overleftrightarrow \cwopencirclearrow 
     \downzigzagarrow \cupleftarrow \rightzigzagarrow \twoheaddownarrow 
     \updownarrowbar \twoheaduparrow \rightarrowbar \updownarrows 
     \barleftarrow \mapsfrom \mapsdown \mapsup \Ldsh \Rdsh 
     &quot;&quot;&quot;</span><span class="s1">.split())</span>

    <span class="s1">_spaced_symbols = _binary_operators | _relation_symbols | _arrow_symbols</span>

    <span class="s1">_punctuation_symbols = set(</span><span class="s4">r', ; . ! \ldotp \cdotp'</span><span class="s1">.split())</span>

    <span class="s1">_overunder_symbols = set(</span><span class="s4">r''' 
       \sum \prod \coprod \bigcap \bigcup \bigsqcup \bigvee 
       \bigwedge \bigodot \bigotimes \bigoplus \biguplus 
       '''</span><span class="s1">.split())</span>

    <span class="s1">_overunder_functions = set(</span><span class="s4">&quot;lim liminf limsup sup max min&quot;</span><span class="s1">.split())</span>

    <span class="s1">_dropsub_symbols = set(</span><span class="s4">r'\int \oint \iint \oiint \iiint \oiiint \iiiint'</span><span class="s1">.split())</span>

    <span class="s1">_fontnames = set(</span><span class="s4">&quot;rm cal it tt sf bf bfit &quot;</span>
                     <span class="s4">&quot;default bb frak scr regular&quot;</span><span class="s1">.split())</span>

    <span class="s1">_function_names = set(</span><span class="s4">&quot;&quot;&quot; 
      arccos csc ker min arcsin deg lg Pr arctan det lim sec arg dim 
      liminf sin cos exp limsup sinh cosh gcd ln sup cot hom log tan 
      coth inf max tanh&quot;&quot;&quot;</span><span class="s1">.split())</span>

    <span class="s1">_ambi_delims = set(</span><span class="s4">r&quot;&quot;&quot; 
      | \| / \backslash \uparrow \downarrow \updownarrow \Uparrow 
      \Downarrow \Updownarrow . \vert \Vert&quot;&quot;&quot;</span><span class="s1">.split())</span>
    <span class="s1">_left_delims = set(</span><span class="s4">r&quot;&quot;&quot; 
      ( [ \{ &lt; \lfloor \langle \lceil \lbrace \leftbrace \lbrack \leftparen \lgroup 
      &quot;&quot;&quot;</span><span class="s1">.split())</span>
    <span class="s1">_right_delims = set(</span><span class="s4">r&quot;&quot;&quot; 
      ) ] \} &gt; \rfloor \rangle \rceil \rbrace \rightbrace \rbrack \rightparen \rgroup 
      &quot;&quot;&quot;</span><span class="s1">.split())</span>
    <span class="s1">_delims = _left_delims | _right_delims | _ambi_delims</span>

    <span class="s1">_small_greek = set([unicodedata.name(chr(i)).split()[-</span><span class="s3">1</span><span class="s1">].lower() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in</span>
                       <span class="s1">range(ord(</span><span class="s4">'</span><span class="s2">\N{GREEK SMALL LETTER ALPHA}</span><span class="s4">'</span><span class="s1">)</span><span class="s2">,</span>
                             <span class="s1">ord(</span><span class="s4">'</span><span class="s2">\N{GREEK SMALL LETTER OMEGA}</span><span class="s4">'</span><span class="s1">) + </span><span class="s3">1</span><span class="s1">)])</span>
    <span class="s1">_latin_alphabets = set(string.ascii_letters)</span>

    <span class="s2">def </span><span class="s1">__init__(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">p = types.SimpleNamespace()</span>

        <span class="s2">def </span><span class="s1">set_names_and_parse_actions() -&gt; </span><span class="s2">None</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">vars(p).items():</span>
                <span class="s2">if not </span><span class="s1">key.startswith(</span><span class="s4">'_'</span><span class="s1">):</span>
                    <span class="s5"># Set names on (almost) everything -- very useful for debugging</span>
                    <span class="s5"># token, placeable, and auto_delim are forward references which</span>
                    <span class="s5"># are left without names to ensure useful error messages</span>
                    <span class="s2">if </span><span class="s1">key </span><span class="s2">not in </span><span class="s1">(</span><span class="s4">&quot;token&quot;</span><span class="s2">, </span><span class="s4">&quot;placeable&quot;</span><span class="s2">, </span><span class="s4">&quot;auto_delim&quot;</span><span class="s1">):</span>
                        <span class="s1">val.setName(key)</span>
                    <span class="s5"># Set actions</span>
                    <span class="s2">if </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s1">key):</span>
                        <span class="s1">val.setParseAction(getattr(self</span><span class="s2">, </span><span class="s1">key))</span>

        <span class="s5"># Root definitions.</span>

        <span class="s5"># In TeX parlance, a csname is a control sequence name (a &quot;\foo&quot;).</span>
        <span class="s2">def </span><span class="s1">csnames(group: str</span><span class="s2">, </span><span class="s1">names: Iterable[str]) -&gt; Regex:</span>
            <span class="s1">ends_with_alpha = []</span>
            <span class="s1">ends_with_nonalpha = []</span>
            <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">names:</span>
                <span class="s2">if </span><span class="s1">name[-</span><span class="s3">1</span><span class="s1">].isalpha():</span>
                    <span class="s1">ends_with_alpha.append(name)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">ends_with_nonalpha.append(name)</span>
            <span class="s2">return </span><span class="s1">Regex(</span>
                <span class="s4">r&quot;\\(?P&lt;{group}&gt;(?:{alpha})(?![A-Za-z]){additional}{nonalpha})&quot;</span><span class="s1">.format(</span>
                    <span class="s1">group=group</span><span class="s2">,</span>
                    <span class="s1">alpha=</span><span class="s4">&quot;|&quot;</span><span class="s1">.join(map(re.escape</span><span class="s2">, </span><span class="s1">ends_with_alpha))</span><span class="s2">,</span>
                    <span class="s1">additional=</span><span class="s4">&quot;|&quot; </span><span class="s2">if </span><span class="s1">ends_with_nonalpha </span><span class="s2">else </span><span class="s4">&quot;&quot;</span><span class="s2">,</span>
                    <span class="s1">nonalpha=</span><span class="s4">&quot;|&quot;</span><span class="s1">.join(map(re.escape</span><span class="s2">, </span><span class="s1">ends_with_nonalpha))</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s1">p.float_literal  = Regex(</span><span class="s4">r&quot;[-+]?([0-9]+\.?[0-9]*|\.[0-9]+)&quot;</span><span class="s1">)</span>
        <span class="s1">p.space          = oneOf(self._space_widths)(</span><span class="s4">&quot;space&quot;</span><span class="s1">)</span>

        <span class="s1">p.style_literal  = oneOf(</span>
            <span class="s1">[str(e.value) </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">self._MathStyle])(</span><span class="s4">&quot;style_literal&quot;</span><span class="s1">)</span>

        <span class="s1">p.symbol         = Regex(</span>
            <span class="s4">r&quot;[a-zA-Z0-9 +\-*/&lt;&gt;=:,.;!\?&amp;'@()\[\]|\U00000080-\U0001ffff]&quot;</span>
            <span class="s4">r&quot;|\\[%${}\[\]_|]&quot;</span>
            <span class="s1">+ </span><span class="s4">r&quot;|\\(?:{})(?![A-Za-z])&quot;</span><span class="s1">.format(</span>
                <span class="s4">&quot;|&quot;</span><span class="s1">.join(map(re.escape</span><span class="s2">, </span><span class="s1">tex2uni)))</span>
        <span class="s1">)(</span><span class="s4">&quot;sym&quot;</span><span class="s1">).leaveWhitespace()</span>
        <span class="s1">p.unknown_symbol = Regex(</span><span class="s4">r&quot;\\[A-Za-z]+&quot;</span><span class="s1">)(</span><span class="s4">&quot;name&quot;</span><span class="s1">)</span>

        <span class="s1">p.font           = csnames(</span><span class="s4">&quot;font&quot;</span><span class="s2">, </span><span class="s1">self._fontnames)</span>
        <span class="s1">p.start_group    = Optional(</span><span class="s4">r&quot;\math&quot; </span><span class="s1">+ oneOf(self._fontnames)(</span><span class="s4">&quot;font&quot;</span><span class="s1">)) + </span><span class="s4">&quot;{&quot;</span>
        <span class="s1">p.end_group      = Literal(</span><span class="s4">&quot;}&quot;</span><span class="s1">)</span>

        <span class="s1">p.delim          = oneOf(self._delims)</span>

        <span class="s5"># Mutually recursive definitions.  (Minimizing the number of Forward</span>
        <span class="s5"># elements is important for speed.)</span>
        <span class="s1">p.auto_delim       = Forward()</span>
        <span class="s1">p.placeable        = Forward()</span>
        <span class="s1">p.required_group   = Forward()</span>
        <span class="s1">p.optional_group   = Forward()</span>
        <span class="s1">p.token            = Forward()</span>

        <span class="s1">set_names_and_parse_actions()  </span><span class="s5"># for mutually recursive definitions.</span>

        <span class="s1">p.optional_group &lt;&lt;= </span><span class="s4">&quot;{&quot; </span><span class="s1">+ ZeroOrMore(p.token)(</span><span class="s4">&quot;group&quot;</span><span class="s1">) + </span><span class="s4">&quot;}&quot;</span>
        <span class="s1">p.required_group &lt;&lt;= </span><span class="s4">&quot;{&quot; </span><span class="s1">+ OneOrMore(p.token)(</span><span class="s4">&quot;group&quot;</span><span class="s1">) + </span><span class="s4">&quot;}&quot;</span>

        <span class="s1">p.customspace = cmd(</span><span class="s4">r&quot;\hspace&quot;</span><span class="s2">, </span><span class="s4">&quot;{&quot; </span><span class="s1">+ p.float_literal(</span><span class="s4">&quot;space&quot;</span><span class="s1">) + </span><span class="s4">&quot;}&quot;</span><span class="s1">)</span>

        <span class="s1">p.accent = (</span>
            <span class="s1">csnames(</span><span class="s4">&quot;accent&quot;</span><span class="s2">, </span><span class="s1">[*self._accent_map</span><span class="s2">, </span><span class="s1">*self._wide_accents])</span>
            <span class="s1">- p.placeable(</span><span class="s4">&quot;sym&quot;</span><span class="s1">))</span>

        <span class="s1">p.function = csnames(</span><span class="s4">&quot;name&quot;</span><span class="s2">, </span><span class="s1">self._function_names)</span>

        <span class="s1">p.group = p.start_group + ZeroOrMore(p.token)(</span><span class="s4">&quot;group&quot;</span><span class="s1">) + p.end_group</span>
        <span class="s1">p.unclosed_group = (p.start_group + ZeroOrMore(p.token)(</span><span class="s4">&quot;group&quot;</span><span class="s1">) + StringEnd())</span>

        <span class="s1">p.frac  = cmd(</span><span class="s4">r&quot;\frac&quot;</span><span class="s2">, </span><span class="s1">p.required_group(</span><span class="s4">&quot;num&quot;</span><span class="s1">) + p.required_group(</span><span class="s4">&quot;den&quot;</span><span class="s1">))</span>
        <span class="s1">p.dfrac = cmd(</span><span class="s4">r&quot;\dfrac&quot;</span><span class="s2">, </span><span class="s1">p.required_group(</span><span class="s4">&quot;num&quot;</span><span class="s1">) + p.required_group(</span><span class="s4">&quot;den&quot;</span><span class="s1">))</span>
        <span class="s1">p.binom = cmd(</span><span class="s4">r&quot;\binom&quot;</span><span class="s2">, </span><span class="s1">p.required_group(</span><span class="s4">&quot;num&quot;</span><span class="s1">) + p.required_group(</span><span class="s4">&quot;den&quot;</span><span class="s1">))</span>

        <span class="s1">p.genfrac = cmd(</span>
            <span class="s4">r&quot;\genfrac&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;{&quot; </span><span class="s1">+ Optional(p.delim)(</span><span class="s4">&quot;ldelim&quot;</span><span class="s1">) + </span><span class="s4">&quot;}&quot;</span>
            <span class="s1">+ </span><span class="s4">&quot;{&quot; </span><span class="s1">+ Optional(p.delim)(</span><span class="s4">&quot;rdelim&quot;</span><span class="s1">) + </span><span class="s4">&quot;}&quot;</span>
            <span class="s1">+ </span><span class="s4">&quot;{&quot; </span><span class="s1">+ p.float_literal(</span><span class="s4">&quot;rulesize&quot;</span><span class="s1">) + </span><span class="s4">&quot;}&quot;</span>
            <span class="s1">+ </span><span class="s4">&quot;{&quot; </span><span class="s1">+ Optional(p.style_literal)(</span><span class="s4">&quot;style&quot;</span><span class="s1">) + </span><span class="s4">&quot;}&quot;</span>
            <span class="s1">+ p.required_group(</span><span class="s4">&quot;num&quot;</span><span class="s1">)</span>
            <span class="s1">+ p.required_group(</span><span class="s4">&quot;den&quot;</span><span class="s1">))</span>

        <span class="s1">p.sqrt = cmd(</span>
            <span class="s4">r&quot;\sqrt{value}&quot;</span><span class="s2">,</span>
            <span class="s1">Optional(</span><span class="s4">&quot;[&quot; </span><span class="s1">+ OneOrMore(NotAny(</span><span class="s4">&quot;]&quot;</span><span class="s1">) + p.token)(</span><span class="s4">&quot;root&quot;</span><span class="s1">) + </span><span class="s4">&quot;]&quot;</span><span class="s1">)</span>
            <span class="s1">+ p.required_group(</span><span class="s4">&quot;value&quot;</span><span class="s1">))</span>

        <span class="s1">p.overline = cmd(</span><span class="s4">r&quot;\overline&quot;</span><span class="s2">, </span><span class="s1">p.required_group(</span><span class="s4">&quot;body&quot;</span><span class="s1">))</span>

        <span class="s1">p.overset  = cmd(</span>
            <span class="s4">r&quot;\overset&quot;</span><span class="s2">,</span>
            <span class="s1">p.optional_group(</span><span class="s4">&quot;annotation&quot;</span><span class="s1">) + p.optional_group(</span><span class="s4">&quot;body&quot;</span><span class="s1">))</span>
        <span class="s1">p.underset = cmd(</span>
            <span class="s4">r&quot;\underset&quot;</span><span class="s2">,</span>
            <span class="s1">p.optional_group(</span><span class="s4">&quot;annotation&quot;</span><span class="s1">) + p.optional_group(</span><span class="s4">&quot;body&quot;</span><span class="s1">))</span>

        <span class="s1">p.text = cmd(</span><span class="s4">r&quot;\text&quot;</span><span class="s2">, </span><span class="s1">QuotedString(</span><span class="s4">'{'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\\</span><span class="s4">'</span><span class="s2">, </span><span class="s1">endQuoteChar=</span><span class="s4">&quot;}&quot;</span><span class="s1">))</span>

        <span class="s1">p.substack = cmd(</span><span class="s4">r&quot;\substack&quot;</span><span class="s2">,</span>
                           <span class="s1">nested_expr(opener=</span><span class="s4">&quot;{&quot;</span><span class="s2">, </span><span class="s1">closer=</span><span class="s4">&quot;}&quot;</span><span class="s2">,</span>
                                       <span class="s1">content=Group(OneOrMore(p.token)) +</span>
                                       <span class="s1">ZeroOrMore(Literal(</span><span class="s4">&quot;</span><span class="s2">\\\\</span><span class="s4">&quot;</span><span class="s1">).suppress()))(</span><span class="s4">&quot;parts&quot;</span><span class="s1">))</span>

        <span class="s1">p.subsuper = (</span>
            <span class="s1">(Optional(p.placeable)(</span><span class="s4">&quot;nucleus&quot;</span><span class="s1">)</span>
             <span class="s1">+ OneOrMore(oneOf([</span><span class="s4">&quot;_&quot;</span><span class="s2">, </span><span class="s4">&quot;^&quot;</span><span class="s1">]) - p.placeable)(</span><span class="s4">&quot;subsuper&quot;</span><span class="s1">)</span>
             <span class="s1">+ Regex(</span><span class="s4">&quot;'*&quot;</span><span class="s1">)(</span><span class="s4">&quot;apostrophes&quot;</span><span class="s1">))</span>
            <span class="s1">| Regex(</span><span class="s4">&quot;'+&quot;</span><span class="s1">)(</span><span class="s4">&quot;apostrophes&quot;</span><span class="s1">)</span>
            <span class="s1">| (p.placeable(</span><span class="s4">&quot;nucleus&quot;</span><span class="s1">) + Regex(</span><span class="s4">&quot;'*&quot;</span><span class="s1">)(</span><span class="s4">&quot;apostrophes&quot;</span><span class="s1">))</span>
        <span class="s1">)</span>

        <span class="s1">p.simple = p.space | p.customspace | p.font | p.subsuper</span>

        <span class="s1">p.token &lt;&lt;= (</span>
            <span class="s1">p.simple</span>
            <span class="s1">| p.auto_delim</span>
            <span class="s1">| p.unclosed_group</span>
            <span class="s1">| p.unknown_symbol  </span><span class="s5"># Must be last</span>
        <span class="s1">)</span>

        <span class="s1">p.operatorname = cmd(</span><span class="s4">r&quot;\operatorname&quot;</span><span class="s2">, </span><span class="s4">&quot;{&quot; </span><span class="s1">+ ZeroOrMore(p.simple)(</span><span class="s4">&quot;name&quot;</span><span class="s1">) + </span><span class="s4">&quot;}&quot;</span><span class="s1">)</span>

        <span class="s1">p.boldsymbol = cmd(</span>
            <span class="s4">r&quot;\boldsymbol&quot;</span><span class="s2">, </span><span class="s4">&quot;{&quot; </span><span class="s1">+ ZeroOrMore(p.simple)(</span><span class="s4">&quot;value&quot;</span><span class="s1">) + </span><span class="s4">&quot;}&quot;</span><span class="s1">)</span>

        <span class="s1">p.placeable     &lt;&lt;= (</span>
            <span class="s1">p.accent     </span><span class="s5"># Must be before symbol as all accents are symbols</span>
            <span class="s1">| p.symbol   </span><span class="s5"># Must be second to catch all named symbols and single</span>
                         <span class="s5"># chars not in a group</span>
            <span class="s1">| p.function</span>
            <span class="s1">| p.operatorname</span>
            <span class="s1">| p.group</span>
            <span class="s1">| p.frac</span>
            <span class="s1">| p.dfrac</span>
            <span class="s1">| p.binom</span>
            <span class="s1">| p.genfrac</span>
            <span class="s1">| p.overset</span>
            <span class="s1">| p.underset</span>
            <span class="s1">| p.sqrt</span>
            <span class="s1">| p.overline</span>
            <span class="s1">| p.text</span>
            <span class="s1">| p.boldsymbol</span>
            <span class="s1">| p.substack</span>
        <span class="s1">)</span>

        <span class="s1">mdelim = </span><span class="s4">r&quot;\middle&quot; </span><span class="s1">- (p.delim(</span><span class="s4">&quot;mdelim&quot;</span><span class="s1">) | Error(</span><span class="s4">&quot;Expected a delimiter&quot;</span><span class="s1">))</span>
        <span class="s1">p.auto_delim    &lt;&lt;= (</span>
            <span class="s4">r&quot;\left&quot; </span><span class="s1">- (p.delim(</span><span class="s4">&quot;left&quot;</span><span class="s1">) | Error(</span><span class="s4">&quot;Expected a delimiter&quot;</span><span class="s1">))</span>
            <span class="s1">+ ZeroOrMore(p.simple | p.auto_delim | mdelim)(</span><span class="s4">&quot;mid&quot;</span><span class="s1">)</span>
            <span class="s1">+ </span><span class="s4">r&quot;\right&quot; </span><span class="s1">- (p.delim(</span><span class="s4">&quot;right&quot;</span><span class="s1">) | Error(</span><span class="s4">&quot;Expected a delimiter&quot;</span><span class="s1">))</span>
        <span class="s1">)</span>

        <span class="s5"># Leaf definitions.</span>
        <span class="s1">p.math          = OneOrMore(p.token)</span>
        <span class="s1">p.math_string   = QuotedString(</span><span class="s4">'$'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\\</span><span class="s4">'</span><span class="s2">, </span><span class="s1">unquoteResults=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">p.non_math      = Regex(</span><span class="s4">r&quot;(?:(?:\\[$])|[^$])*&quot;</span><span class="s1">).leaveWhitespace()</span>
        <span class="s1">p.main          = (</span>
            <span class="s1">p.non_math + ZeroOrMore(p.math_string + p.non_math) + StringEnd()</span>
        <span class="s1">)</span>
        <span class="s1">set_names_and_parse_actions()  </span><span class="s5"># for leaf definitions.</span>

        <span class="s1">self._expression = p.main</span>
        <span class="s1">self._math_expression = p.math</span>

        <span class="s5"># To add space to nucleus operators after sub/superscripts</span>
        <span class="s1">self._in_subscript_or_superscript = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">parse(self</span><span class="s2">, </span><span class="s1">s: str</span><span class="s2">, </span><span class="s1">fonts_object: Fonts</span><span class="s2">, </span><span class="s1">fontsize: float</span><span class="s2">, </span><span class="s1">dpi: float) -&gt; Hlist:</span>
        <span class="s0">&quot;&quot;&quot; 
        Parse expression *s* using the given *fonts_object* for 
        output, at the given *fontsize* and *dpi*. 
 
        Returns the parse tree of `Node` instances. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._state_stack = [</span>
            <span class="s1">ParserState(fonts_object</span><span class="s2">, </span><span class="s4">'default'</span><span class="s2">, </span><span class="s4">'rm'</span><span class="s2">, </span><span class="s1">fontsize</span><span class="s2">, </span><span class="s1">dpi)]</span>
        <span class="s1">self._em_width_cache: dict[tuple[str</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">float]</span><span class="s2">, </span><span class="s1">float] = {}</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">result = self._expression.parseString(s)</span>
        <span class="s2">except </span><span class="s1">ParseBaseException </span><span class="s2">as </span><span class="s1">err:</span>
            <span class="s5"># explain becomes a plain method on pyparsing 3 (err.explain(0)).</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot; </span><span class="s1">+ ParseException.explain(err</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)) </span><span class="s2">from None</span>
        <span class="s1">self._state_stack = []</span>
        <span class="s1">self._in_subscript_or_superscript = </span><span class="s2">False</span>
        <span class="s5"># prevent operator spacing from leaking into a new expression</span>
        <span class="s1">self._em_width_cache = {}</span>
        <span class="s1">ParserElement.resetCache()</span>
        <span class="s2">return </span><span class="s1">T.cast(Hlist</span><span class="s2">, </span><span class="s1">result[</span><span class="s3">0</span><span class="s1">])  </span><span class="s5"># Known return type from main.</span>

    <span class="s2">def </span><span class="s1">get_state(self) -&gt; ParserState:</span>
        <span class="s0">&quot;&quot;&quot;Get the current `State` of the parser.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._state_stack[-</span><span class="s3">1</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">pop_state(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Pop a `State` off of the stack.&quot;&quot;&quot;</span>
        <span class="s1">self._state_stack.pop()</span>

    <span class="s2">def </span><span class="s1">push_state(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Push a new `State` onto the stack, copying the current state.&quot;&quot;&quot;</span>
        <span class="s1">self._state_stack.append(self.get_state().copy())</span>

    <span class="s2">def </span><span class="s1">main(self</span><span class="s2">, </span><span class="s1">toks: ParseResults) -&gt; list[Hlist]:</span>
        <span class="s2">return </span><span class="s1">[Hlist(toks.asList())]</span>

    <span class="s2">def </span><span class="s1">math_string(self</span><span class="s2">, </span><span class="s1">toks: ParseResults) -&gt; ParseResults:</span>
        <span class="s2">return </span><span class="s1">self._math_expression.parseString(toks[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">1</span><span class="s1">:-</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">parseAll=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">math(self</span><span class="s2">, </span><span class="s1">toks: ParseResults) -&gt; T.Any:</span>
        <span class="s1">hlist = Hlist(toks.asList())</span>
        <span class="s1">self.pop_state()</span>
        <span class="s2">return </span><span class="s1">[hlist]</span>

    <span class="s2">def </span><span class="s1">non_math(self</span><span class="s2">, </span><span class="s1">toks: ParseResults) -&gt; T.Any:</span>
        <span class="s1">s = toks[</span><span class="s3">0</span><span class="s1">].replace(</span><span class="s4">r'\$'</span><span class="s2">, </span><span class="s4">'$'</span><span class="s1">)</span>
        <span class="s1">symbols = [Char(c</span><span class="s2">, </span><span class="s1">self.get_state()) </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">s]</span>
        <span class="s1">hlist = Hlist(symbols)</span>
        <span class="s5"># We're going into math now, so set font to 'it'</span>
        <span class="s1">self.push_state()</span>
        <span class="s1">self.get_state().font = mpl.rcParams[</span><span class="s4">'mathtext.default'</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">[hlist]</span>

    <span class="s1">float_literal = staticmethod(pyparsing_common.convertToFloat)</span>

    <span class="s2">def </span><span class="s1">text(self</span><span class="s2">, </span><span class="s1">toks: ParseResults) -&gt; T.Any:</span>
        <span class="s1">self.push_state()</span>
        <span class="s1">state = self.get_state()</span>
        <span class="s1">state.font = </span><span class="s4">'rm'</span>
        <span class="s1">hlist = Hlist([Char(c</span><span class="s2">, </span><span class="s1">state) </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">toks[</span><span class="s3">1</span><span class="s1">]])</span>
        <span class="s1">self.pop_state()</span>
        <span class="s2">return </span><span class="s1">[hlist]</span>

    <span class="s2">def </span><span class="s1">_make_space(self</span><span class="s2">, </span><span class="s1">percentage: float) -&gt; Kern:</span>
        <span class="s5"># In TeX, an em (the unit usually used to measure horizontal lengths)</span>
        <span class="s5"># is not the width of the character 'm'; it is the same in different</span>
        <span class="s5"># font styles (e.g. roman or italic). Mathtext, however, uses 'm' in</span>
        <span class="s5"># the italic style so that horizontal spaces don't depend on the</span>
        <span class="s5"># current font style.</span>
        <span class="s1">state = self.get_state()</span>
        <span class="s1">key = (state.font</span><span class="s2">, </span><span class="s1">state.fontsize</span><span class="s2">, </span><span class="s1">state.dpi)</span>
        <span class="s1">width = self._em_width_cache.get(key)</span>
        <span class="s2">if </span><span class="s1">width </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">metrics = state.fontset.get_metrics(</span>
                <span class="s4">'it'</span><span class="s2">, </span><span class="s1">mpl.rcParams[</span><span class="s4">'mathtext.default'</span><span class="s1">]</span><span class="s2">, </span><span class="s4">'m'</span><span class="s2">,</span>
                <span class="s1">state.fontsize</span><span class="s2">, </span><span class="s1">state.dpi)</span>
            <span class="s1">width = metrics.advance</span>
            <span class="s1">self._em_width_cache[key] = width</span>
        <span class="s2">return </span><span class="s1">Kern(width * percentage)</span>

    <span class="s1">_space_widths = {</span>
        <span class="s4">r'\,'</span><span class="s1">:         </span><span class="s3">0.16667</span><span class="s2">,   </span><span class="s5"># 3/18 em = 3 mu</span>
        <span class="s4">r'\thinspace'</span><span class="s1">: </span><span class="s3">0.16667</span><span class="s2">,   </span><span class="s5"># 3/18 em = 3 mu</span>
        <span class="s4">r'\/'</span><span class="s1">:         </span><span class="s3">0.16667</span><span class="s2">,   </span><span class="s5"># 3/18 em = 3 mu</span>
        <span class="s4">r'\&gt;'</span><span class="s1">:         </span><span class="s3">0.22222</span><span class="s2">,   </span><span class="s5"># 4/18 em = 4 mu</span>
        <span class="s4">r'\:'</span><span class="s1">:         </span><span class="s3">0.22222</span><span class="s2">,   </span><span class="s5"># 4/18 em = 4 mu</span>
        <span class="s4">r'\;'</span><span class="s1">:         </span><span class="s3">0.27778</span><span class="s2">,   </span><span class="s5"># 5/18 em = 5 mu</span>
        <span class="s4">r'\ '</span><span class="s1">:         </span><span class="s3">0.33333</span><span class="s2">,   </span><span class="s5"># 6/18 em = 6 mu</span>
        <span class="s4">r'~'</span><span class="s1">:          </span><span class="s3">0.33333</span><span class="s2">,   </span><span class="s5"># 6/18 em = 6 mu, nonbreakable</span>
        <span class="s4">r'\enspace'</span><span class="s1">:   </span><span class="s3">0.5</span><span class="s2">,       </span><span class="s5"># 9/18 em = 9 mu</span>
        <span class="s4">r'\quad'</span><span class="s1">:      </span><span class="s3">1</span><span class="s2">,         </span><span class="s5"># 1 em = 18 mu</span>
        <span class="s4">r'\qquad'</span><span class="s1">:     </span><span class="s3">2</span><span class="s2">,         </span><span class="s5"># 2 em = 36 mu</span>
        <span class="s4">r'\!'</span><span class="s1">:         -</span><span class="s3">0.16667</span><span class="s2">,  </span><span class="s5"># -3/18 em = -3 mu</span>
    <span class="s1">}</span>

    <span class="s2">def </span><span class="s1">space(self</span><span class="s2">, </span><span class="s1">toks: ParseResults) -&gt; T.Any:</span>
        <span class="s1">num = self._space_widths[toks[</span><span class="s4">&quot;space&quot;</span><span class="s1">]]</span>
        <span class="s1">box = self._make_space(num)</span>
        <span class="s2">return </span><span class="s1">[box]</span>

    <span class="s2">def </span><span class="s1">customspace(self</span><span class="s2">, </span><span class="s1">toks: ParseResults) -&gt; T.Any:</span>
        <span class="s2">return </span><span class="s1">[self._make_space(toks[</span><span class="s4">&quot;space&quot;</span><span class="s1">])]</span>

    <span class="s2">def </span><span class="s1">symbol(self</span><span class="s2">, </span><span class="s1">s: str</span><span class="s2">, </span><span class="s1">loc: int</span><span class="s2">,</span>
               <span class="s1">toks: ParseResults | dict[str</span><span class="s2">, </span><span class="s1">str]) -&gt; T.Any:</span>
        <span class="s1">c = toks[</span><span class="s4">&quot;sym&quot;</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">c == </span><span class="s4">&quot;-&quot;</span><span class="s1">:</span>
            <span class="s5"># &quot;U+2212 minus sign is the preferred representation of the unary</span>
            <span class="s5"># and binary minus sign rather than the ASCII-derived U+002D</span>
            <span class="s5"># hyphen-minus, because minus sign is unambiguous and because it</span>
            <span class="s5"># is rendered with a more desirable length, usually longer than a</span>
            <span class="s5"># hyphen.&quot; (https://www.unicode.org/reports/tr25/)</span>
            <span class="s1">c = </span><span class="s4">&quot;</span><span class="s2">\N{MINUS SIGN}</span><span class="s4">&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">char = Char(c</span><span class="s2">, </span><span class="s1">self.get_state())</span>
        <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">err:</span>
            <span class="s2">raise </span><span class="s1">ParseFatalException(s</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">,</span>
                                      <span class="s4">&quot;Unknown symbol: %s&quot; </span><span class="s1">% c) </span><span class="s2">from </span><span class="s1">err</span>

        <span class="s2">if </span><span class="s1">c </span><span class="s2">in </span><span class="s1">self._spaced_symbols:</span>
            <span class="s5"># iterate until we find previous character, needed for cases</span>
            <span class="s5"># such as ${ -2}$, $ -2$, or $   -2$.</span>
            <span class="s1">prev_char = next((c </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">s[:loc][::-</span><span class="s3">1</span><span class="s1">] </span><span class="s2">if </span><span class="s1">c != </span><span class="s4">' '</span><span class="s1">)</span><span class="s2">, </span><span class="s4">''</span><span class="s1">)</span>
            <span class="s5"># Binary operators at start of string should not be spaced</span>
            <span class="s5"># Also, operators in sub- or superscripts should not be spaced</span>
            <span class="s2">if </span><span class="s1">(self._in_subscript_or_superscript </span><span class="s2">or </span><span class="s1">(</span>
                    <span class="s1">c </span><span class="s2">in </span><span class="s1">self._binary_operators </span><span class="s2">and </span><span class="s1">(</span>
                    <span class="s1">len(s[:loc].split()) == </span><span class="s3">0 </span><span class="s2">or </span><span class="s1">prev_char == </span><span class="s4">'{' </span><span class="s2">or</span>
                    <span class="s1">prev_char </span><span class="s2">in </span><span class="s1">self._left_delims))):</span>
                <span class="s2">return </span><span class="s1">[char]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">[Hlist([self._make_space(</span><span class="s3">0.2</span><span class="s1">)</span><span class="s2">,</span>
                               <span class="s1">char</span><span class="s2">,</span>
                               <span class="s1">self._make_space(</span><span class="s3">0.2</span><span class="s1">)]</span><span class="s2">,</span>
                              <span class="s1">do_kern=</span><span class="s2">True</span><span class="s1">)]</span>
        <span class="s2">elif </span><span class="s1">c </span><span class="s2">in </span><span class="s1">self._punctuation_symbols:</span>
            <span class="s1">prev_char = next((c </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">s[:loc][::-</span><span class="s3">1</span><span class="s1">] </span><span class="s2">if </span><span class="s1">c != </span><span class="s4">' '</span><span class="s1">)</span><span class="s2">, </span><span class="s4">''</span><span class="s1">)</span>
            <span class="s1">next_char = next((c </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">s[loc + </span><span class="s3">1</span><span class="s1">:] </span><span class="s2">if </span><span class="s1">c != </span><span class="s4">' '</span><span class="s1">)</span><span class="s2">, </span><span class="s4">''</span><span class="s1">)</span>

            <span class="s5"># Do not space commas between brackets</span>
            <span class="s2">if </span><span class="s1">c == </span><span class="s4">','</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">prev_char == </span><span class="s4">'{' </span><span class="s2">and </span><span class="s1">next_char == </span><span class="s4">'}'</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">[char]</span>

            <span class="s5"># Do not space dots as decimal separators</span>
            <span class="s2">if </span><span class="s1">c == </span><span class="s4">'.' </span><span class="s2">and </span><span class="s1">prev_char.isdigit() </span><span class="s2">and </span><span class="s1">next_char.isdigit():</span>
                <span class="s2">return </span><span class="s1">[char]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">[Hlist([char</span><span class="s2">, </span><span class="s1">self._make_space(</span><span class="s3">0.2</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">do_kern=</span><span class="s2">True</span><span class="s1">)]</span>
        <span class="s2">return </span><span class="s1">[char]</span>

    <span class="s2">def </span><span class="s1">unknown_symbol(self</span><span class="s2">, </span><span class="s1">s: str</span><span class="s2">, </span><span class="s1">loc: int</span><span class="s2">, </span><span class="s1">toks: ParseResults) -&gt; T.Any:</span>
        <span class="s2">raise </span><span class="s1">ParseFatalException(s</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s4">f&quot;Unknown symbol: </span><span class="s2">{</span><span class="s1">toks[</span><span class="s4">'name'</span><span class="s1">]</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>

    <span class="s1">_accent_map = {</span>
        <span class="s4">r'hat'</span><span class="s1">:            </span><span class="s4">r'\circumflexaccent'</span><span class="s2">,</span>
        <span class="s4">r'breve'</span><span class="s1">:          </span><span class="s4">r'\combiningbreve'</span><span class="s2">,</span>
        <span class="s4">r'bar'</span><span class="s1">:            </span><span class="s4">r'\combiningoverline'</span><span class="s2">,</span>
        <span class="s4">r'grave'</span><span class="s1">:          </span><span class="s4">r'\combininggraveaccent'</span><span class="s2">,</span>
        <span class="s4">r'acute'</span><span class="s1">:          </span><span class="s4">r'\combiningacuteaccent'</span><span class="s2">,</span>
        <span class="s4">r'tilde'</span><span class="s1">:          </span><span class="s4">r'\combiningtilde'</span><span class="s2">,</span>
        <span class="s4">r'dot'</span><span class="s1">:            </span><span class="s4">r'\combiningdotabove'</span><span class="s2">,</span>
        <span class="s4">r'ddot'</span><span class="s1">:           </span><span class="s4">r'\combiningdiaeresis'</span><span class="s2">,</span>
        <span class="s4">r'dddot'</span><span class="s1">:          </span><span class="s4">r'\combiningthreedotsabove'</span><span class="s2">,</span>
        <span class="s4">r'ddddot'</span><span class="s1">:         </span><span class="s4">r'\combiningfourdotsabove'</span><span class="s2">,</span>
        <span class="s4">r'vec'</span><span class="s1">:            </span><span class="s4">r'\combiningrightarrowabove'</span><span class="s2">,</span>
        <span class="s4">r'&quot;'</span><span class="s1">:              </span><span class="s4">r'\combiningdiaeresis'</span><span class="s2">,</span>
        <span class="s4">r&quot;`&quot;</span><span class="s1">:              </span><span class="s4">r'\combininggraveaccent'</span><span class="s2">,</span>
        <span class="s4">r&quot;'&quot;</span><span class="s1">:              </span><span class="s4">r'\combiningacuteaccent'</span><span class="s2">,</span>
        <span class="s4">r'~'</span><span class="s1">:              </span><span class="s4">r'\combiningtilde'</span><span class="s2">,</span>
        <span class="s4">r'.'</span><span class="s1">:              </span><span class="s4">r'\combiningdotabove'</span><span class="s2">,</span>
        <span class="s4">r'^'</span><span class="s1">:              </span><span class="s4">r'\circumflexaccent'</span><span class="s2">,</span>
        <span class="s4">r'overrightarrow'</span><span class="s1">: </span><span class="s4">r'\rightarrow'</span><span class="s2">,</span>
        <span class="s4">r'overleftarrow'</span><span class="s1">:  </span><span class="s4">r'\leftarrow'</span><span class="s2">,</span>
        <span class="s4">r'mathring'</span><span class="s1">:       </span><span class="s4">r'\circ'</span><span class="s2">,</span>
    <span class="s1">}</span>

    <span class="s1">_wide_accents = set(</span><span class="s4">r&quot;widehat widetilde widebar&quot;</span><span class="s1">.split())</span>

    <span class="s2">def </span><span class="s1">accent(self</span><span class="s2">, </span><span class="s1">toks: ParseResults) -&gt; T.Any:</span>
        <span class="s1">state = self.get_state()</span>
        <span class="s1">thickness = state.get_current_underline_thickness()</span>
        <span class="s1">accent = toks[</span><span class="s4">&quot;accent&quot;</span><span class="s1">]</span>
        <span class="s1">sym = toks[</span><span class="s4">&quot;sym&quot;</span><span class="s1">]</span>
        <span class="s1">accent_box: Node</span>
        <span class="s2">if </span><span class="s1">accent </span><span class="s2">in </span><span class="s1">self._wide_accents:</span>
            <span class="s1">accent_box = AutoWidthChar(</span>
                <span class="s4">'</span><span class="s2">\\</span><span class="s4">' </span><span class="s1">+ accent</span><span class="s2">, </span><span class="s1">sym.width</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">char_class=Accent)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">accent_box = Accent(self._accent_map[accent]</span><span class="s2">, </span><span class="s1">state)</span>
        <span class="s2">if </span><span class="s1">accent == </span><span class="s4">'mathring'</span><span class="s1">:</span>
            <span class="s1">accent_box.shrink()</span>
            <span class="s1">accent_box.shrink()</span>
        <span class="s1">centered = HCentered([Hbox(sym.width / </span><span class="s3">4.0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">accent_box])</span>
        <span class="s1">centered.hpack(sym.width</span><span class="s2">, </span><span class="s4">'exactly'</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">Vlist([</span>
                <span class="s1">centered</span><span class="s2">,</span>
                <span class="s1">Vbox(</span><span class="s3">0.</span><span class="s2">, </span><span class="s1">thickness * </span><span class="s3">2.0</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Hlist([sym])</span>
                <span class="s1">])</span>

    <span class="s2">def </span><span class="s1">function(self</span><span class="s2">, </span><span class="s1">s: str</span><span class="s2">, </span><span class="s1">loc: int</span><span class="s2">, </span><span class="s1">toks: ParseResults) -&gt; T.Any:</span>
        <span class="s1">hlist = self.operatorname(s</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">toks)</span>
        <span class="s1">hlist.function_name = toks[</span><span class="s4">&quot;name&quot;</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">hlist</span>

    <span class="s2">def </span><span class="s1">operatorname(self</span><span class="s2">, </span><span class="s1">s: str</span><span class="s2">, </span><span class="s1">loc: int</span><span class="s2">, </span><span class="s1">toks: ParseResults) -&gt; T.Any:</span>
        <span class="s1">self.push_state()</span>
        <span class="s1">state = self.get_state()</span>
        <span class="s1">state.font = </span><span class="s4">'rm'</span>
        <span class="s1">hlist_list: list[Node] = []</span>
        <span class="s5"># Change the font of Chars, but leave Kerns alone</span>
        <span class="s1">name = toks[</span><span class="s4">&quot;name&quot;</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">name:</span>
            <span class="s2">if </span><span class="s1">isinstance(c</span><span class="s2">, </span><span class="s1">Char):</span>
                <span class="s1">c.font = </span><span class="s4">'rm'</span>
                <span class="s1">c._update_metrics()</span>
                <span class="s1">hlist_list.append(c)</span>
            <span class="s2">elif </span><span class="s1">isinstance(c</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s1">hlist_list.append(Char(c</span><span class="s2">, </span><span class="s1">state))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">hlist_list.append(c)</span>
        <span class="s1">next_char_loc = loc + len(name) + </span><span class="s3">1</span>
        <span class="s2">if </span><span class="s1">isinstance(name</span><span class="s2">, </span><span class="s1">ParseResults):</span>
            <span class="s1">next_char_loc += len(</span><span class="s4">'operatorname{}'</span><span class="s1">)</span>
        <span class="s1">next_char = next((c </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">s[next_char_loc:] </span><span class="s2">if </span><span class="s1">c != </span><span class="s4">' '</span><span class="s1">)</span><span class="s2">, </span><span class="s4">''</span><span class="s1">)</span>
        <span class="s1">delimiters = self._delims | {</span><span class="s4">'^'</span><span class="s2">, </span><span class="s4">'_'</span><span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(next_char </span><span class="s2">not in </span><span class="s1">delimiters </span><span class="s2">and</span>
                <span class="s1">name </span><span class="s2">not in </span><span class="s1">self._overunder_functions):</span>
            <span class="s5"># Add thin space except when followed by parenthesis, bracket, etc.</span>
            <span class="s1">hlist_list += [self._make_space(self._space_widths[</span><span class="s4">r'\,'</span><span class="s1">])]</span>
        <span class="s1">self.pop_state()</span>
        <span class="s5"># if followed by a super/subscript, set flag to true</span>
        <span class="s5"># This flag tells subsuper to add space after this operator</span>
        <span class="s2">if </span><span class="s1">next_char </span><span class="s2">in </span><span class="s1">{</span><span class="s4">'^'</span><span class="s2">, </span><span class="s4">'_'</span><span class="s1">}:</span>
            <span class="s1">self._in_subscript_or_superscript = </span><span class="s2">True</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._in_subscript_or_superscript = </span><span class="s2">False</span>

        <span class="s2">return </span><span class="s1">Hlist(hlist_list)</span>

    <span class="s2">def </span><span class="s1">start_group(self</span><span class="s2">, </span><span class="s1">toks: ParseResults) -&gt; T.Any:</span>
        <span class="s1">self.push_state()</span>
        <span class="s5"># Deal with LaTeX-style font tokens</span>
        <span class="s2">if </span><span class="s1">toks.get(</span><span class="s4">&quot;font&quot;</span><span class="s1">):</span>
            <span class="s1">self.get_state().font = toks.get(</span><span class="s4">&quot;font&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">group(self</span><span class="s2">, </span><span class="s1">toks: ParseResults) -&gt; T.Any:</span>
        <span class="s1">grp = Hlist(toks.get(</span><span class="s4">&quot;group&quot;</span><span class="s2">, </span><span class="s1">[]))</span>
        <span class="s2">return </span><span class="s1">[grp]</span>

    <span class="s2">def </span><span class="s1">required_group(self</span><span class="s2">, </span><span class="s1">toks: ParseResults) -&gt; T.Any:</span>
        <span class="s2">return </span><span class="s1">Hlist(toks.get(</span><span class="s4">&quot;group&quot;</span><span class="s2">, </span><span class="s1">[]))</span>

    <span class="s1">optional_group = required_group</span>

    <span class="s2">def </span><span class="s1">end_group(self) -&gt; T.Any:</span>
        <span class="s1">self.pop_state()</span>
        <span class="s2">return </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">unclosed_group(self</span><span class="s2">, </span><span class="s1">s: str</span><span class="s2">, </span><span class="s1">loc: int</span><span class="s2">, </span><span class="s1">toks: ParseResults) -&gt; T.Any:</span>
        <span class="s2">raise </span><span class="s1">ParseFatalException(s</span><span class="s2">, </span><span class="s1">len(s)</span><span class="s2">, </span><span class="s4">&quot;Expected '}'&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">font(self</span><span class="s2">, </span><span class="s1">toks: ParseResults) -&gt; T.Any:</span>
        <span class="s1">self.get_state().font = toks[</span><span class="s4">&quot;font&quot;</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">is_overunder(self</span><span class="s2">, </span><span class="s1">nucleus: Node) -&gt; bool:</span>
        <span class="s2">if </span><span class="s1">isinstance(nucleus</span><span class="s2">, </span><span class="s1">Char):</span>
            <span class="s2">return </span><span class="s1">nucleus.c </span><span class="s2">in </span><span class="s1">self._overunder_symbols</span>
        <span class="s2">elif </span><span class="s1">isinstance(nucleus</span><span class="s2">, </span><span class="s1">Hlist) </span><span class="s2">and </span><span class="s1">hasattr(nucleus</span><span class="s2">, </span><span class="s4">'function_name'</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">nucleus.function_name </span><span class="s2">in </span><span class="s1">self._overunder_functions</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">is_dropsub(self</span><span class="s2">, </span><span class="s1">nucleus: Node) -&gt; bool:</span>
        <span class="s2">if </span><span class="s1">isinstance(nucleus</span><span class="s2">, </span><span class="s1">Char):</span>
            <span class="s2">return </span><span class="s1">nucleus.c </span><span class="s2">in </span><span class="s1">self._dropsub_symbols</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">is_slanted(self</span><span class="s2">, </span><span class="s1">nucleus: Node) -&gt; bool:</span>
        <span class="s2">if </span><span class="s1">isinstance(nucleus</span><span class="s2">, </span><span class="s1">Char):</span>
            <span class="s2">return </span><span class="s1">nucleus.is_slanted()</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">subsuper(self</span><span class="s2">, </span><span class="s1">s: str</span><span class="s2">, </span><span class="s1">loc: int</span><span class="s2">, </span><span class="s1">toks: ParseResults) -&gt; T.Any:</span>
        <span class="s1">nucleus = toks.get(</span><span class="s4">&quot;nucleus&quot;</span><span class="s2">, </span><span class="s1">Hbox(</span><span class="s3">0</span><span class="s1">))</span>
        <span class="s1">subsuper = toks.get(</span><span class="s4">&quot;subsuper&quot;</span><span class="s2">, </span><span class="s1">[])</span>
        <span class="s1">napostrophes = len(toks.get(</span><span class="s4">&quot;apostrophes&quot;</span><span class="s2">, </span><span class="s1">[]))</span>

        <span class="s2">if not </span><span class="s1">subsuper </span><span class="s2">and not </span><span class="s1">napostrophes:</span>
            <span class="s2">return </span><span class="s1">nucleus</span>

        <span class="s1">sub = super = </span><span class="s2">None</span>
        <span class="s2">while </span><span class="s1">subsuper:</span>
            <span class="s1">op</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">*subsuper = subsuper</span>
            <span class="s2">if </span><span class="s1">op == </span><span class="s4">'_'</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">sub </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">ParseFatalException(</span><span class="s4">&quot;Double subscript&quot;</span><span class="s1">)</span>
                <span class="s1">sub = arg</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">super </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">ParseFatalException(</span><span class="s4">&quot;Double superscript&quot;</span><span class="s1">)</span>
                <span class="s1">super = arg</span>

        <span class="s1">state = self.get_state()</span>
        <span class="s1">rule_thickness = state.fontset.get_underline_thickness(</span>
            <span class="s1">state.font</span><span class="s2">, </span><span class="s1">state.fontsize</span><span class="s2">, </span><span class="s1">state.dpi)</span>
        <span class="s1">xHeight = state.fontset.get_xheight(</span>
            <span class="s1">state.font</span><span class="s2">, </span><span class="s1">state.fontsize</span><span class="s2">, </span><span class="s1">state.dpi)</span>

        <span class="s2">if </span><span class="s1">napostrophes:</span>
            <span class="s2">if </span><span class="s1">super </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">super = Hlist([])</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(napostrophes):</span>
                <span class="s1">super.children.extend(self.symbol(s</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">{</span><span class="s4">&quot;sym&quot;</span><span class="s1">: </span><span class="s4">&quot;</span><span class="s2">\\</span><span class="s4">prime&quot;</span><span class="s1">}))</span>
            <span class="s5"># kern() and hpack() needed to get the metrics right after</span>
            <span class="s5"># extending</span>
            <span class="s1">super.kern()</span>
            <span class="s1">super.hpack()</span>

        <span class="s5"># Handle over/under symbols, such as sum or prod</span>
        <span class="s2">if </span><span class="s1">self.is_overunder(nucleus):</span>
            <span class="s1">vlist = []</span>
            <span class="s1">shift = </span><span class="s3">0.</span>
            <span class="s1">width = nucleus.width</span>
            <span class="s2">if </span><span class="s1">super </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">super.shrink()</span>
                <span class="s1">width = max(width</span><span class="s2">, </span><span class="s1">super.width)</span>
            <span class="s2">if </span><span class="s1">sub </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">sub.shrink()</span>
                <span class="s1">width = max(width</span><span class="s2">, </span><span class="s1">sub.width)</span>

            <span class="s1">vgap = rule_thickness * </span><span class="s3">3.0</span>
            <span class="s2">if </span><span class="s1">super </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">hlist = HCentered([super])</span>
                <span class="s1">hlist.hpack(width</span><span class="s2">, </span><span class="s4">'exactly'</span><span class="s1">)</span>
                <span class="s1">vlist.extend([hlist</span><span class="s2">, </span><span class="s1">Vbox(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">vgap)])</span>
            <span class="s1">hlist = HCentered([nucleus])</span>
            <span class="s1">hlist.hpack(width</span><span class="s2">, </span><span class="s4">'exactly'</span><span class="s1">)</span>
            <span class="s1">vlist.append(hlist)</span>
            <span class="s2">if </span><span class="s1">sub </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">hlist = HCentered([sub])</span>
                <span class="s1">hlist.hpack(width</span><span class="s2">, </span><span class="s4">'exactly'</span><span class="s1">)</span>
                <span class="s1">vlist.extend([Vbox(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">vgap)</span><span class="s2">, </span><span class="s1">hlist])</span>
                <span class="s1">shift = hlist.height + vgap + nucleus.depth</span>
            <span class="s1">vlt = Vlist(vlist)</span>
            <span class="s1">vlt.shift_amount = shift</span>
            <span class="s1">result = Hlist([vlt])</span>
            <span class="s2">return </span><span class="s1">[result]</span>

        <span class="s5"># We remove kerning on the last character for consistency (otherwise</span>
        <span class="s5"># it will compute kerning based on non-shrunk characters and may put</span>
        <span class="s5"># them too close together when superscripted)</span>
        <span class="s5"># We change the width of the last character to match the advance to</span>
        <span class="s5"># consider some fonts with weird metrics: e.g. stix's f has a width of</span>
        <span class="s5"># 7.75 and a kerning of -4.0 for an advance of 3.72, and we want to put</span>
        <span class="s5"># the superscript at the advance</span>
        <span class="s1">last_char = nucleus</span>
        <span class="s2">if </span><span class="s1">isinstance(nucleus</span><span class="s2">, </span><span class="s1">Hlist):</span>
            <span class="s1">new_children = nucleus.children</span>
            <span class="s2">if </span><span class="s1">len(new_children):</span>
                <span class="s5"># remove last kern</span>
                <span class="s2">if </span><span class="s1">(isinstance(new_children[-</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">Kern) </span><span class="s2">and</span>
                        <span class="s1">hasattr(new_children[-</span><span class="s3">2</span><span class="s1">]</span><span class="s2">, </span><span class="s4">'_metrics'</span><span class="s1">)):</span>
                    <span class="s1">new_children = new_children[:-</span><span class="s3">1</span><span class="s1">]</span>
                <span class="s1">last_char = new_children[-</span><span class="s3">1</span><span class="s1">]</span>
                <span class="s2">if </span><span class="s1">hasattr(last_char</span><span class="s2">, </span><span class="s4">'_metrics'</span><span class="s1">):</span>
                    <span class="s1">last_char.width = last_char._metrics.advance</span>
            <span class="s5"># create new Hlist without kerning</span>
            <span class="s1">nucleus = Hlist(new_children</span><span class="s2">, </span><span class="s1">do_kern=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">isinstance(nucleus</span><span class="s2">, </span><span class="s1">Char):</span>
                <span class="s1">last_char.width = last_char._metrics.advance</span>
            <span class="s1">nucleus = Hlist([nucleus])</span>

        <span class="s5"># Handle regular sub/superscripts</span>
        <span class="s1">constants = _get_font_constant_set(state)</span>
        <span class="s1">lc_height   = last_char.height</span>
        <span class="s1">lc_baseline = </span><span class="s3">0</span>
        <span class="s2">if </span><span class="s1">self.is_dropsub(last_char):</span>
            <span class="s1">lc_baseline = last_char.depth</span>

        <span class="s5"># Compute kerning for sub and super</span>
        <span class="s1">superkern = constants.delta * xHeight</span>
        <span class="s1">subkern = constants.delta * xHeight</span>
        <span class="s2">if </span><span class="s1">self.is_slanted(last_char):</span>
            <span class="s1">superkern += constants.delta * xHeight</span>
            <span class="s1">superkern += (constants.delta_slanted *</span>
                          <span class="s1">(lc_height - xHeight * </span><span class="s3">2. </span><span class="s1">/ </span><span class="s3">3.</span><span class="s1">))</span>
            <span class="s2">if </span><span class="s1">self.is_dropsub(last_char):</span>
                <span class="s1">subkern = (</span><span class="s3">3 </span><span class="s1">* constants.delta -</span>
                           <span class="s1">constants.delta_integral) * lc_height</span>
                <span class="s1">superkern = (</span><span class="s3">3 </span><span class="s1">* constants.delta +</span>
                             <span class="s1">constants.delta_integral) * lc_height</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">subkern = </span><span class="s3">0</span>

        <span class="s1">x: List</span>
        <span class="s2">if </span><span class="s1">super </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s5"># node757</span>
            <span class="s5"># Note: One of super or sub must be a Node if we're in this function, but</span>
            <span class="s5"># mypy can't know this, since it can't interpret pyparsing expressions,</span>
            <span class="s5"># hence the cast.</span>
            <span class="s1">x = Hlist([Kern(subkern)</span><span class="s2">, </span><span class="s1">T.cast(Node</span><span class="s2">, </span><span class="s1">sub)])</span>
            <span class="s1">x.shrink()</span>
            <span class="s2">if </span><span class="s1">self.is_dropsub(last_char):</span>
                <span class="s1">shift_down = lc_baseline + constants.subdrop * xHeight</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">shift_down = constants.sub1 * xHeight</span>
            <span class="s1">x.shift_amount = shift_down</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">x = Hlist([Kern(superkern)</span><span class="s2">, </span><span class="s1">super])</span>
            <span class="s1">x.shrink()</span>
            <span class="s2">if </span><span class="s1">self.is_dropsub(last_char):</span>
                <span class="s1">shift_up = lc_height - constants.subdrop * xHeight</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">shift_up = constants.sup1 * xHeight</span>
            <span class="s2">if </span><span class="s1">sub </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">x.shift_amount = -shift_up</span>
            <span class="s2">else</span><span class="s1">:  </span><span class="s5"># Both sub and superscript</span>
                <span class="s1">y = Hlist([Kern(subkern)</span><span class="s2">, </span><span class="s1">sub])</span>
                <span class="s1">y.shrink()</span>
                <span class="s2">if </span><span class="s1">self.is_dropsub(last_char):</span>
                    <span class="s1">shift_down = lc_baseline + constants.subdrop * xHeight</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">shift_down = constants.sub2 * xHeight</span>
                <span class="s5"># If sub and superscript collide, move super up</span>
                <span class="s1">clr = (</span><span class="s3">2.0 </span><span class="s1">* rule_thickness -</span>
                       <span class="s1">((shift_up - x.depth) - (y.height - shift_down)))</span>
                <span class="s2">if </span><span class="s1">clr &gt; </span><span class="s3">0.</span><span class="s1">:</span>
                    <span class="s1">shift_up += clr</span>
                <span class="s1">x = Vlist([</span>
                    <span class="s1">x</span><span class="s2">,</span>
                    <span class="s1">Kern((shift_up - x.depth) - (y.height - shift_down))</span><span class="s2">,</span>
                    <span class="s1">y])</span>
                <span class="s1">x.shift_amount = shift_down</span>

        <span class="s2">if not </span><span class="s1">self.is_dropsub(last_char):</span>
            <span class="s1">x.width += constants.script_space * xHeight</span>

        <span class="s5"># Do we need to add a space after the nucleus?</span>
        <span class="s5"># To find out, check the flag set by operatorname</span>
        <span class="s1">spaced_nucleus = [nucleus</span><span class="s2">, </span><span class="s1">x]</span>
        <span class="s2">if </span><span class="s1">self._in_subscript_or_superscript:</span>
            <span class="s1">spaced_nucleus += [self._make_space(self._space_widths[</span><span class="s4">r'\,'</span><span class="s1">])]</span>
            <span class="s1">self._in_subscript_or_superscript = </span><span class="s2">False</span>

        <span class="s1">result = Hlist(spaced_nucleus)</span>
        <span class="s2">return </span><span class="s1">[result]</span>

    <span class="s2">def </span><span class="s1">_genfrac(self</span><span class="s2">, </span><span class="s1">ldelim: str</span><span class="s2">, </span><span class="s1">rdelim: str</span><span class="s2">, </span><span class="s1">rule: float | </span><span class="s2">None, </span><span class="s1">style: _MathStyle</span><span class="s2">,</span>
                 <span class="s1">num: Hlist</span><span class="s2">, </span><span class="s1">den: Hlist) -&gt; T.Any:</span>
        <span class="s1">state = self.get_state()</span>
        <span class="s1">thickness = state.get_current_underline_thickness()</span>

        <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(style.value):</span>
            <span class="s1">num.shrink()</span>
            <span class="s1">den.shrink()</span>
        <span class="s1">cnum = HCentered([num])</span>
        <span class="s1">cden = HCentered([den])</span>
        <span class="s1">width = max(num.width</span><span class="s2">, </span><span class="s1">den.width)</span>
        <span class="s1">cnum.hpack(width</span><span class="s2">, </span><span class="s4">'exactly'</span><span class="s1">)</span>
        <span class="s1">cden.hpack(width</span><span class="s2">, </span><span class="s4">'exactly'</span><span class="s1">)</span>
        <span class="s1">vlist = Vlist([cnum</span><span class="s2">,                      </span><span class="s5"># numerator</span>
                       <span class="s1">Vbox(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">thickness * </span><span class="s3">2.0</span><span class="s1">)</span><span class="s2">,  </span><span class="s5"># space</span>
                       <span class="s1">Hrule(state</span><span class="s2">, </span><span class="s1">rule)</span><span class="s2">,        </span><span class="s5"># rule</span>
                       <span class="s1">Vbox(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">thickness * </span><span class="s3">2.0</span><span class="s1">)</span><span class="s2">,  </span><span class="s5"># space</span>
                       <span class="s1">cden                       </span><span class="s5"># denominator</span>
                       <span class="s1">])</span>

        <span class="s5"># Shift so the fraction line sits in the middle of the</span>
        <span class="s5"># equals sign</span>
        <span class="s1">metrics = state.fontset.get_metrics(</span>
            <span class="s1">state.font</span><span class="s2">, </span><span class="s1">mpl.rcParams[</span><span class="s4">'mathtext.default'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s4">'='</span><span class="s2">, </span><span class="s1">state.fontsize</span><span class="s2">, </span><span class="s1">state.dpi)</span>
        <span class="s1">shift = (cden.height -</span>
                 <span class="s1">((metrics.ymax + metrics.ymin) / </span><span class="s3">2 </span><span class="s1">-</span>
                  <span class="s1">thickness * </span><span class="s3">3.0</span><span class="s1">))</span>
        <span class="s1">vlist.shift_amount = shift</span>

        <span class="s1">result = [Hlist([vlist</span><span class="s2">, </span><span class="s1">Hbox(thickness * </span><span class="s3">2.</span><span class="s1">)])]</span>
        <span class="s2">if </span><span class="s1">ldelim </span><span class="s2">or </span><span class="s1">rdelim:</span>
            <span class="s2">if </span><span class="s1">ldelim == </span><span class="s4">''</span><span class="s1">:</span>
                <span class="s1">ldelim = </span><span class="s4">'.'</span>
            <span class="s2">if </span><span class="s1">rdelim == </span><span class="s4">''</span><span class="s1">:</span>
                <span class="s1">rdelim = </span><span class="s4">'.'</span>
            <span class="s2">return </span><span class="s1">self._auto_sized_delimiter(ldelim</span><span class="s2">,</span>
                                              <span class="s1">T.cast(list[T.Union[Box</span><span class="s2">, </span><span class="s1">Char</span><span class="s2">, </span><span class="s1">str]]</span><span class="s2">,</span>
                                                     <span class="s1">result)</span><span class="s2">,</span>
                                              <span class="s1">rdelim)</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">style_literal(self</span><span class="s2">, </span><span class="s1">toks: ParseResults) -&gt; T.Any:</span>
        <span class="s2">return </span><span class="s1">self._MathStyle(int(toks[</span><span class="s4">&quot;style_literal&quot;</span><span class="s1">]))</span>

    <span class="s2">def </span><span class="s1">genfrac(self</span><span class="s2">, </span><span class="s1">toks: ParseResults) -&gt; T.Any:</span>
        <span class="s2">return </span><span class="s1">self._genfrac(</span>
            <span class="s1">toks.get(</span><span class="s4">&quot;ldelim&quot;</span><span class="s2">, </span><span class="s4">&quot;&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">toks.get(</span><span class="s4">&quot;rdelim&quot;</span><span class="s2">, </span><span class="s4">&quot;&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">toks[</span><span class="s4">&quot;rulesize&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">toks.get(</span><span class="s4">&quot;style&quot;</span><span class="s2">, </span><span class="s1">self._MathStyle.TEXTSTYLE)</span><span class="s2">,</span>
            <span class="s1">toks[</span><span class="s4">&quot;num&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">toks[</span><span class="s4">&quot;den&quot;</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">frac(self</span><span class="s2">, </span><span class="s1">toks: ParseResults) -&gt; T.Any:</span>
        <span class="s2">return </span><span class="s1">self._genfrac(</span>
            <span class="s4">&quot;&quot;</span><span class="s2">, </span><span class="s4">&quot;&quot;</span><span class="s2">, </span><span class="s1">self.get_state().get_current_underline_thickness()</span><span class="s2">,</span>
            <span class="s1">self._MathStyle.TEXTSTYLE</span><span class="s2">, </span><span class="s1">toks[</span><span class="s4">&quot;num&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">toks[</span><span class="s4">&quot;den&quot;</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">dfrac(self</span><span class="s2">, </span><span class="s1">toks: ParseResults) -&gt; T.Any:</span>
        <span class="s2">return </span><span class="s1">self._genfrac(</span>
            <span class="s4">&quot;&quot;</span><span class="s2">, </span><span class="s4">&quot;&quot;</span><span class="s2">, </span><span class="s1">self.get_state().get_current_underline_thickness()</span><span class="s2">,</span>
            <span class="s1">self._MathStyle.DISPLAYSTYLE</span><span class="s2">, </span><span class="s1">toks[</span><span class="s4">&quot;num&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">toks[</span><span class="s4">&quot;den&quot;</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">binom(self</span><span class="s2">, </span><span class="s1">toks: ParseResults) -&gt; T.Any:</span>
        <span class="s2">return </span><span class="s1">self._genfrac(</span>
            <span class="s4">&quot;(&quot;</span><span class="s2">, </span><span class="s4">&quot;)&quot;</span><span class="s2">, </span><span class="s3">0</span><span class="s2">,</span>
            <span class="s1">self._MathStyle.TEXTSTYLE</span><span class="s2">, </span><span class="s1">toks[</span><span class="s4">&quot;num&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">toks[</span><span class="s4">&quot;den&quot;</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">_genset(self</span><span class="s2">, </span><span class="s1">s: str</span><span class="s2">, </span><span class="s1">loc: int</span><span class="s2">, </span><span class="s1">toks: ParseResults) -&gt; T.Any:</span>
        <span class="s1">annotation = toks[</span><span class="s4">&quot;annotation&quot;</span><span class="s1">]</span>
        <span class="s1">body = toks[</span><span class="s4">&quot;body&quot;</span><span class="s1">]</span>
        <span class="s1">thickness = self.get_state().get_current_underline_thickness()</span>

        <span class="s1">annotation.shrink()</span>
        <span class="s1">cannotation = HCentered([annotation])</span>
        <span class="s1">cbody = HCentered([body])</span>
        <span class="s1">width = max(cannotation.width</span><span class="s2">, </span><span class="s1">cbody.width)</span>
        <span class="s1">cannotation.hpack(width</span><span class="s2">, </span><span class="s4">'exactly'</span><span class="s1">)</span>
        <span class="s1">cbody.hpack(width</span><span class="s2">, </span><span class="s4">'exactly'</span><span class="s1">)</span>

        <span class="s1">vgap = thickness * </span><span class="s3">3</span>
        <span class="s2">if </span><span class="s1">s[loc + </span><span class="s3">1</span><span class="s1">] == </span><span class="s4">&quot;u&quot;</span><span class="s1">:  </span><span class="s5"># \underset</span>
            <span class="s1">vlist = Vlist([cbody</span><span class="s2">,                       </span><span class="s5"># body</span>
                           <span class="s1">Vbox(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">vgap)</span><span class="s2">,               </span><span class="s5"># space</span>
                           <span class="s1">cannotation                  </span><span class="s5"># annotation</span>
                           <span class="s1">])</span>
            <span class="s5"># Shift so the body sits in the same vertical position</span>
            <span class="s1">vlist.shift_amount = cbody.depth + cannotation.height + vgap</span>
        <span class="s2">else</span><span class="s1">:  </span><span class="s5"># \overset</span>
            <span class="s1">vlist = Vlist([cannotation</span><span class="s2">,                 </span><span class="s5"># annotation</span>
                           <span class="s1">Vbox(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">vgap)</span><span class="s2">,               </span><span class="s5"># space</span>
                           <span class="s1">cbody                        </span><span class="s5"># body</span>
                           <span class="s1">])</span>

        <span class="s5"># To add horizontal gap between symbols: wrap the Vlist into</span>
        <span class="s5"># an Hlist and extend it with an Hbox(0, horizontal_gap)</span>
        <span class="s2">return </span><span class="s1">vlist</span>

    <span class="s1">overset = underset = _genset</span>

    <span class="s2">def </span><span class="s1">sqrt(self</span><span class="s2">, </span><span class="s1">toks: ParseResults) -&gt; T.Any:</span>
        <span class="s1">root = toks.get(</span><span class="s4">&quot;root&quot;</span><span class="s1">)</span>
        <span class="s1">body = toks[</span><span class="s4">&quot;value&quot;</span><span class="s1">]</span>
        <span class="s1">state = self.get_state()</span>
        <span class="s1">thickness = state.get_current_underline_thickness()</span>

        <span class="s5"># Determine the height of the body, and add a little extra to</span>
        <span class="s5"># the height so it doesn't seem cramped</span>
        <span class="s1">height = body.height - body.shift_amount + thickness * </span><span class="s3">5.0</span>
        <span class="s1">depth = body.depth + body.shift_amount</span>
        <span class="s1">check = AutoHeightChar(</span><span class="s4">r'\__sqrt__'</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">depth</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">always=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">height = check.height - check.shift_amount</span>
        <span class="s1">depth = check.depth + check.shift_amount</span>

        <span class="s5"># Put a little extra space to the left and right of the body</span>
        <span class="s1">padded_body = Hlist([Hbox(</span><span class="s3">2 </span><span class="s1">* thickness)</span><span class="s2">, </span><span class="s1">body</span><span class="s2">, </span><span class="s1">Hbox(</span><span class="s3">2 </span><span class="s1">* thickness)])</span>
        <span class="s1">rightside = Vlist([Hrule(state)</span><span class="s2">, </span><span class="s1">Glue(</span><span class="s4">'fill'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">padded_body])</span>
        <span class="s5"># Stretch the glue between the hrule and the body</span>
        <span class="s1">rightside.vpack(height + (state.fontsize * state.dpi) / (</span><span class="s3">100.0 </span><span class="s1">* </span><span class="s3">12.0</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s4">'exactly'</span><span class="s2">, </span><span class="s1">depth)</span>

        <span class="s5"># Add the root and shift it upward so it is above the tick.</span>
        <span class="s5"># The value of 0.6 is a hard-coded hack ;)</span>
        <span class="s2">if not </span><span class="s1">root:</span>
            <span class="s1">root = Box(check.width * </span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0.</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">root = Hlist(root)</span>
            <span class="s1">root.shrink()</span>
            <span class="s1">root.shrink()</span>

        <span class="s1">root_vlist = Vlist([Hlist([root])])</span>
        <span class="s1">root_vlist.shift_amount = -height * </span><span class="s3">0.6</span>

        <span class="s1">hlist = Hlist([root_vlist</span><span class="s2">,               </span><span class="s5"># Root</span>
                       <span class="s5"># Negative kerning to put root over tick</span>
                       <span class="s1">Kern(-check.width * </span><span class="s3">0.5</span><span class="s1">)</span><span class="s2">,</span>
                       <span class="s1">check</span><span class="s2">,                    </span><span class="s5"># Check</span>
                       <span class="s1">rightside])               </span><span class="s5"># Body</span>
        <span class="s2">return </span><span class="s1">[hlist]</span>

    <span class="s2">def </span><span class="s1">overline(self</span><span class="s2">, </span><span class="s1">toks: ParseResults) -&gt; T.Any:</span>
        <span class="s1">body = toks[</span><span class="s4">&quot;body&quot;</span><span class="s1">]</span>

        <span class="s1">state = self.get_state()</span>
        <span class="s1">thickness = state.get_current_underline_thickness()</span>

        <span class="s1">height = body.height - body.shift_amount + thickness * </span><span class="s3">3.0</span>
        <span class="s1">depth = body.depth + body.shift_amount</span>

        <span class="s5"># Place overline above body</span>
        <span class="s1">rightside = Vlist([Hrule(state)</span><span class="s2">, </span><span class="s1">Glue(</span><span class="s4">'fill'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Hlist([body])])</span>

        <span class="s5"># Stretch the glue between the hrule and the body</span>
        <span class="s1">rightside.vpack(height + (state.fontsize * state.dpi) / (</span><span class="s3">100.0 </span><span class="s1">* </span><span class="s3">12.0</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s4">'exactly'</span><span class="s2">, </span><span class="s1">depth)</span>

        <span class="s1">hlist = Hlist([rightside])</span>
        <span class="s2">return </span><span class="s1">[hlist]</span>

    <span class="s2">def </span><span class="s1">_auto_sized_delimiter(self</span><span class="s2">, </span><span class="s1">front: str</span><span class="s2">,</span>
                              <span class="s1">middle: list[Box | Char | str]</span><span class="s2">,</span>
                              <span class="s1">back: str) -&gt; T.Any:</span>
        <span class="s1">state = self.get_state()</span>
        <span class="s2">if </span><span class="s1">len(middle):</span>
            <span class="s1">height = max([x.height </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">middle </span><span class="s2">if not </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">str)])</span>
            <span class="s1">depth = max([x.depth </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">middle </span><span class="s2">if not </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">str)])</span>
            <span class="s1">factor = </span><span class="s2">None</span>
            <span class="s2">for </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">el </span><span class="s2">in </span><span class="s1">enumerate(middle):</span>
                <span class="s2">if </span><span class="s1">isinstance(el</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">el == </span><span class="s4">'</span><span class="s2">\\</span><span class="s4">middle'</span><span class="s1">:</span>
                    <span class="s1">c = T.cast(str</span><span class="s2">, </span><span class="s1">middle[idx + </span><span class="s3">1</span><span class="s1">])  </span><span class="s5"># Should be one of p.delims.</span>
                    <span class="s2">if </span><span class="s1">c != </span><span class="s4">'.'</span><span class="s1">:</span>
                        <span class="s1">middle[idx + </span><span class="s3">1</span><span class="s1">] = AutoHeightChar(</span>
                                <span class="s1">c</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">depth</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">factor=factor)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">middle.remove(c)</span>
                    <span class="s2">del </span><span class="s1">middle[idx]</span>
            <span class="s5"># There should only be \middle and its delimiter as str, which have</span>
            <span class="s5"># just been removed.</span>
            <span class="s1">middle_part = T.cast(list[T.Union[Box</span><span class="s2">, </span><span class="s1">Char]]</span><span class="s2">, </span><span class="s1">middle)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">height = </span><span class="s3">0</span>
            <span class="s1">depth = </span><span class="s3">0</span>
            <span class="s1">factor = </span><span class="s3">1.0</span>
            <span class="s1">middle_part = []</span>

        <span class="s1">parts: list[Node] = []</span>
        <span class="s5"># \left. and \right. aren't supposed to produce any symbols</span>
        <span class="s2">if </span><span class="s1">front != </span><span class="s4">'.'</span><span class="s1">:</span>
            <span class="s1">parts.append(</span>
                <span class="s1">AutoHeightChar(front</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">depth</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">factor=factor))</span>
        <span class="s1">parts.extend(middle_part)</span>
        <span class="s2">if </span><span class="s1">back != </span><span class="s4">'.'</span><span class="s1">:</span>
            <span class="s1">parts.append(</span>
                <span class="s1">AutoHeightChar(back</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">depth</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">factor=factor))</span>
        <span class="s1">hlist = Hlist(parts)</span>
        <span class="s2">return </span><span class="s1">hlist</span>

    <span class="s2">def </span><span class="s1">auto_delim(self</span><span class="s2">, </span><span class="s1">toks: ParseResults) -&gt; T.Any:</span>
        <span class="s2">return </span><span class="s1">self._auto_sized_delimiter(</span>
            <span class="s1">toks[</span><span class="s4">&quot;left&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s5"># if &quot;mid&quot; in toks ... can be removed when requiring pyparsing 3.</span>
            <span class="s1">toks[</span><span class="s4">&quot;mid&quot;</span><span class="s1">].asList() </span><span class="s2">if </span><span class="s4">&quot;mid&quot; </span><span class="s2">in </span><span class="s1">toks </span><span class="s2">else </span><span class="s1">[]</span><span class="s2">,</span>
            <span class="s1">toks[</span><span class="s4">&quot;right&quot;</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">boldsymbol(self</span><span class="s2">, </span><span class="s1">toks: ParseResults) -&gt; T.Any:</span>
        <span class="s1">self.push_state()</span>
        <span class="s1">state = self.get_state()</span>
        <span class="s1">hlist: list[Node] = []</span>
        <span class="s1">name = toks[</span><span class="s4">&quot;value&quot;</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">name:</span>
            <span class="s2">if </span><span class="s1">isinstance(c</span><span class="s2">, </span><span class="s1">Hlist):</span>
                <span class="s1">k = c.children[</span><span class="s3">1</span><span class="s1">]</span>
                <span class="s2">if </span><span class="s1">isinstance(k</span><span class="s2">, </span><span class="s1">Char):</span>
                    <span class="s1">k.font = </span><span class="s4">&quot;bf&quot;</span>
                    <span class="s1">k._update_metrics()</span>
                <span class="s1">hlist.append(c)</span>
            <span class="s2">elif </span><span class="s1">isinstance(c</span><span class="s2">, </span><span class="s1">Char):</span>
                <span class="s1">c.font = </span><span class="s4">&quot;bf&quot;</span>
                <span class="s2">if </span><span class="s1">(c.c </span><span class="s2">in </span><span class="s1">self._latin_alphabets </span><span class="s2">or</span>
                   <span class="s1">c.c[</span><span class="s3">1</span><span class="s1">:] </span><span class="s2">in </span><span class="s1">self._small_greek):</span>
                    <span class="s1">c.font = </span><span class="s4">&quot;bfit&quot;</span>
                    <span class="s1">c._update_metrics()</span>
                <span class="s1">c._update_metrics()</span>
                <span class="s1">hlist.append(c)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">hlist.append(c)</span>
        <span class="s1">self.pop_state()</span>

        <span class="s2">return </span><span class="s1">Hlist(hlist)</span>

    <span class="s2">def </span><span class="s1">substack(self</span><span class="s2">, </span><span class="s1">toks: ParseResults) -&gt; T.Any:</span>
        <span class="s1">parts = toks[</span><span class="s4">&quot;parts&quot;</span><span class="s1">]</span>
        <span class="s1">state = self.get_state()</span>
        <span class="s1">thickness = state.get_current_underline_thickness()</span>

        <span class="s1">hlist = [Hlist(k) </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">parts[</span><span class="s3">0</span><span class="s1">]]</span>
        <span class="s1">max_width = max(map(</span><span class="s2">lambda </span><span class="s1">c: c.width</span><span class="s2">, </span><span class="s1">hlist))</span>

        <span class="s1">vlist = []</span>
        <span class="s2">for </span><span class="s1">sub </span><span class="s2">in </span><span class="s1">hlist:</span>
            <span class="s1">cp = HCentered([sub])</span>
            <span class="s1">cp.hpack(max_width</span><span class="s2">, </span><span class="s4">'exactly'</span><span class="s1">)</span>
            <span class="s1">vlist.append(cp)</span>

        <span class="s1">stack = [val</span>
                 <span class="s2">for </span><span class="s1">pair </span><span class="s2">in </span><span class="s1">zip(vlist</span><span class="s2">, </span><span class="s1">[Vbox(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">thickness * </span><span class="s3">2</span><span class="s1">)] * len(vlist))</span>
                 <span class="s2">for </span><span class="s1">val </span><span class="s2">in </span><span class="s1">pair]</span>
        <span class="s2">del </span><span class="s1">stack[-</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">vlt = Vlist(stack)</span>
        <span class="s1">result = [Hlist([vlt])]</span>
        <span class="s2">return </span><span class="s1">result</span>
</pre>
</body>
</html>