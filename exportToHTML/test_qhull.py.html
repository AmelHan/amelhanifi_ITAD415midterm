<html>
<head>
<title>test_qhull.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #629755; font-style: italic;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_qhull.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">copy</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">(assert_equal</span><span class="s0">, </span><span class="s1">assert_almost_equal</span><span class="s0">,</span>
                           <span class="s1">assert_</span><span class="s0">, </span><span class="s1">assert_allclose</span><span class="s0">, </span><span class="s1">assert_array_equal)</span>
<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">from </span><span class="s1">pytest </span><span class="s0">import </span><span class="s1">raises </span><span class="s0">as </span><span class="s1">assert_raises</span>

<span class="s0">import </span><span class="s1">scipy.spatial._qhull </span><span class="s0">as </span><span class="s1">qhull</span>
<span class="s0">from </span><span class="s1">scipy.spatial </span><span class="s0">import </span><span class="s1">cKDTree </span><span class="s0">as </span><span class="s1">KDTree</span>
<span class="s0">from </span><span class="s1">scipy.spatial </span><span class="s0">import </span><span class="s1">Voronoi</span>

<span class="s0">import </span><span class="s1">itertools</span>

<span class="s0">def </span><span class="s1">sorted_tuple(x):</span>
    <span class="s0">return </span><span class="s1">tuple(sorted(x))</span>


<span class="s0">def </span><span class="s1">assert_unordered_tuple_list_equal(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">tpl=tuple):</span>
    <span class="s0">if </span><span class="s1">isinstance(a</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
        <span class="s1">a = a.tolist()</span>
    <span class="s0">if </span><span class="s1">isinstance(b</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
        <span class="s1">b = b.tolist()</span>
    <span class="s1">a = list(map(tpl</span><span class="s0">, </span><span class="s1">a))</span>
    <span class="s1">a.sort()</span>
    <span class="s1">b = list(map(tpl</span><span class="s0">, </span><span class="s1">b))</span>
    <span class="s1">b.sort()</span>
    <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s1">b)</span>


<span class="s1">np.random.seed(</span><span class="s2">1234</span><span class="s1">)</span>

<span class="s1">points = [(</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">,</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">,</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1.5</span><span class="s1">)]</span>

<span class="s1">pathological_data_1 = np.array([</span>
    <span class="s1">[-</span><span class="s2">3.14</span><span class="s0">,</span><span class="s1">-</span><span class="s2">3.14</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">3.14</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2.36</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">3.14</span><span class="s0">,</span><span class="s1">-</span><span class="s2">1.57</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">3.14</span><span class="s0">,</span><span class="s1">-</span><span class="s2">0.79</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">[-</span><span class="s2">3.14</span><span class="s0">,</span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">3.14</span><span class="s0">,</span><span class="s2">0.79</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">3.14</span><span class="s0">,</span><span class="s2">1.57</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">3.14</span><span class="s0">,</span><span class="s2">2.36</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">[-</span><span class="s2">3.14</span><span class="s0">,</span><span class="s2">3.14</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">2.36</span><span class="s0">,</span><span class="s1">-</span><span class="s2">3.14</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">2.36</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2.36</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">2.36</span><span class="s0">,</span><span class="s1">-</span><span class="s2">1.57</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">[-</span><span class="s2">2.36</span><span class="s0">,</span><span class="s1">-</span><span class="s2">0.79</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">2.36</span><span class="s0">,</span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">2.36</span><span class="s0">,</span><span class="s2">0.79</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">2.36</span><span class="s0">,</span><span class="s2">1.57</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">[-</span><span class="s2">2.36</span><span class="s0">,</span><span class="s2">2.36</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">2.36</span><span class="s0">,</span><span class="s2">3.14</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1.57</span><span class="s0">,</span><span class="s1">-</span><span class="s2">0.79</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1.57</span><span class="s0">,</span><span class="s2">0.79</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">[-</span><span class="s2">1.57</span><span class="s0">,</span><span class="s1">-</span><span class="s2">1.57</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1.57</span><span class="s0">,</span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1.57</span><span class="s0">,</span><span class="s2">1.57</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1.57</span><span class="s0">,</span><span class="s1">-</span><span class="s2">3.14</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">[-</span><span class="s2">1.57</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2.36</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1.57</span><span class="s0">,</span><span class="s2">2.36</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1.57</span><span class="s0">,</span><span class="s2">3.14</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">0.79</span><span class="s0">,</span><span class="s1">-</span><span class="s2">1.57</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">[-</span><span class="s2">0.79</span><span class="s0">,</span><span class="s2">1.57</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">0.79</span><span class="s0">,</span><span class="s1">-</span><span class="s2">3.14</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">0.79</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2.36</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">0.79</span><span class="s0">,</span><span class="s1">-</span><span class="s2">0.79</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">[-</span><span class="s2">0.79</span><span class="s0">,</span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">0.79</span><span class="s0">,</span><span class="s2">0.79</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">0.79</span><span class="s0">,</span><span class="s2">2.36</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">0.79</span><span class="s0">,</span><span class="s2">3.14</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s2">0.0</span><span class="s0">,</span><span class="s1">-</span><span class="s2">3.14</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2.36</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">,</span><span class="s1">-</span><span class="s2">1.57</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">,</span><span class="s1">-</span><span class="s2">0.79</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">,</span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s2">0.0</span><span class="s0">,</span><span class="s2">0.79</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">,</span><span class="s2">1.57</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">,</span><span class="s2">2.36</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">,</span><span class="s2">3.14</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.79</span><span class="s0">,</span><span class="s1">-</span><span class="s2">3.14</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s2">0.79</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2.36</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.79</span><span class="s0">,</span><span class="s1">-</span><span class="s2">0.79</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.79</span><span class="s0">,</span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.79</span><span class="s0">,</span><span class="s2">0.79</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s2">0.79</span><span class="s0">,</span><span class="s2">2.36</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.79</span><span class="s0">,</span><span class="s2">3.14</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.79</span><span class="s0">,</span><span class="s1">-</span><span class="s2">1.57</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.79</span><span class="s0">,</span><span class="s2">1.57</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s2">1.57</span><span class="s0">,</span><span class="s1">-</span><span class="s2">3.14</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.57</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2.36</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.57</span><span class="s0">,</span><span class="s2">2.36</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.57</span><span class="s0">,</span><span class="s2">3.14</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s2">1.57</span><span class="s0">,</span><span class="s1">-</span><span class="s2">1.57</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.57</span><span class="s0">,</span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.57</span><span class="s0">,</span><span class="s2">1.57</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.57</span><span class="s0">,</span><span class="s1">-</span><span class="s2">0.79</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s2">1.57</span><span class="s0">,</span><span class="s2">0.79</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2.36</span><span class="s0">,</span><span class="s1">-</span><span class="s2">3.14</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2.36</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2.36</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2.36</span><span class="s0">,</span><span class="s1">-</span><span class="s2">1.57</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s2">2.36</span><span class="s0">,</span><span class="s1">-</span><span class="s2">0.79</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2.36</span><span class="s0">,</span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2.36</span><span class="s0">,</span><span class="s2">0.79</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2.36</span><span class="s0">,</span><span class="s2">1.57</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s2">2.36</span><span class="s0">,</span><span class="s2">2.36</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2.36</span><span class="s0">,</span><span class="s2">3.14</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3.14</span><span class="s0">,</span><span class="s1">-</span><span class="s2">3.14</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3.14</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2.36</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s2">3.14</span><span class="s0">,</span><span class="s1">-</span><span class="s2">1.57</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3.14</span><span class="s0">,</span><span class="s1">-</span><span class="s2">0.79</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3.14</span><span class="s0">,</span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3.14</span><span class="s0">,</span><span class="s2">0.79</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s2">3.14</span><span class="s0">,</span><span class="s2">1.57</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3.14</span><span class="s0">,</span><span class="s2">2.36</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3.14</span><span class="s0">,</span><span class="s2">3.14</span><span class="s1">]</span><span class="s0">,</span>
<span class="s1">])</span>

<span class="s1">pathological_data_2 = np.array([</span>
    <span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1 </span><span class="s1">- np.finfo(np.float_).eps]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
<span class="s1">])</span>

<span class="s1">bug_2850_chunks = [np.random.rand(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">,</span>
                   <span class="s1">np.array([[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">,</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">,</span><span class="s2">1</span><span class="s1">]])  </span><span class="s3"># add corners</span>
                   <span class="s1">]</span>

<span class="s3"># same with some additional chunks</span>
<span class="s1">bug_2850_chunks_2 = (bug_2850_chunks +</span>
                     <span class="s1">[np.random.rand(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">,</span>
                      <span class="s2">0.25 </span><span class="s1">+ np.array([[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">,</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">,</span><span class="s2">1</span><span class="s1">]])])</span>

<span class="s1">DATASETS = {</span>
    <span class="s4">'some-points'</span><span class="s1">: np.asarray(points)</span><span class="s0">,</span>
    <span class="s4">'random-2d'</span><span class="s1">: np.random.rand(</span><span class="s2">30</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s4">'random-3d'</span><span class="s1">: np.random.rand(</span><span class="s2">30</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s4">'random-4d'</span><span class="s1">: np.random.rand(</span><span class="s2">30</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s4">'random-5d'</span><span class="s1">: np.random.rand(</span><span class="s2">30</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s4">'random-6d'</span><span class="s1">: np.random.rand(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">6</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s4">'random-7d'</span><span class="s1">: np.random.rand(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">7</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s4">'random-8d'</span><span class="s1">: np.random.rand(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">8</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s4">'pathological-1'</span><span class="s1">: pathological_data_1</span><span class="s0">,</span>
    <span class="s4">'pathological-2'</span><span class="s1">: pathological_data_2</span>
<span class="s1">}</span>

<span class="s1">INCREMENTAL_DATASETS = {</span>
    <span class="s4">'bug-2850'</span><span class="s1">: (bug_2850_chunks</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s4">'bug-2850-2'</span><span class="s1">: (bug_2850_chunks_2</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
<span class="s1">}</span>


<span class="s0">def </span><span class="s1">_add_inc_data(name</span><span class="s0">, </span><span class="s1">chunksize):</span>
    <span class="s5">&quot;&quot;&quot; 
    Generate incremental datasets from basic data sets 
    &quot;&quot;&quot;</span>
    <span class="s1">points = DATASETS[name]</span>
    <span class="s1">ndim = points.shape[</span><span class="s2">1</span><span class="s1">]</span>

    <span class="s1">opts = </span><span class="s0">None</span>
    <span class="s1">nmin = ndim + </span><span class="s2">2</span>

    <span class="s0">if </span><span class="s1">name == </span><span class="s4">'some-points'</span><span class="s1">:</span>
        <span class="s3"># since Qz is not allowed, use QJ</span>
        <span class="s1">opts = </span><span class="s4">'QJ Pp'</span>
    <span class="s0">elif </span><span class="s1">name == </span><span class="s4">'pathological-1'</span><span class="s1">:</span>
        <span class="s3"># include enough points so that we get different x-coordinates</span>
        <span class="s1">nmin = </span><span class="s2">12</span>

    <span class="s1">chunks = [points[:nmin]]</span>
    <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(nmin</span><span class="s0">, </span><span class="s1">len(points)</span><span class="s0">, </span><span class="s1">chunksize):</span>
        <span class="s1">chunks.append(points[j:j+chunksize])</span>

    <span class="s1">new_name = </span><span class="s4">&quot;%s-chunk-%d&quot; </span><span class="s1">% (name</span><span class="s0">, </span><span class="s1">chunksize)</span>
    <span class="s0">assert </span><span class="s1">new_name </span><span class="s0">not in </span><span class="s1">INCREMENTAL_DATASETS</span>
    <span class="s1">INCREMENTAL_DATASETS[new_name] = (chunks</span><span class="s0">, </span><span class="s1">opts)</span>


<span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">DATASETS:</span>
    <span class="s0">for </span><span class="s1">chunksize </span><span class="s0">in </span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">16</span><span class="s1">:</span>
        <span class="s1">_add_inc_data(name</span><span class="s0">, </span><span class="s1">chunksize)</span>


<span class="s0">class </span><span class="s1">Test_Qhull:</span>
    <span class="s0">def </span><span class="s1">test_swapping(self):</span>
        <span class="s3"># Check that Qhull state swapping works</span>

        <span class="s1">x = qhull._Qhull(</span><span class="s6">b'v'</span><span class="s0">,</span>
                         <span class="s1">np.array([[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">1</span><span class="s0">,</span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">1</span><span class="s0">,</span><span class="s2">1.</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">0.5</span><span class="s0">,</span><span class="s2">0.5</span><span class="s1">]])</span><span class="s0">,</span>
                         <span class="s6">b'Qz'</span><span class="s1">)</span>
        <span class="s1">xd = copy.deepcopy(x.get_voronoi_diagram())</span>

        <span class="s1">y = qhull._Qhull(</span><span class="s6">b'v'</span><span class="s0">,</span>
                         <span class="s1">np.array([[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">1</span><span class="s0">,</span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2.</span><span class="s1">]])</span><span class="s0">,</span>
                         <span class="s6">b'Qz'</span><span class="s1">)</span>
        <span class="s1">yd = copy.deepcopy(y.get_voronoi_diagram())</span>

        <span class="s1">xd2 = copy.deepcopy(x.get_voronoi_diagram())</span>
        <span class="s1">x.close()</span>
        <span class="s1">yd2 = copy.deepcopy(y.get_voronoi_diagram())</span>
        <span class="s1">y.close()</span>

        <span class="s1">assert_raises(RuntimeError</span><span class="s0">, </span><span class="s1">x.get_voronoi_diagram)</span>
        <span class="s1">assert_raises(RuntimeError</span><span class="s0">, </span><span class="s1">y.get_voronoi_diagram)</span>

        <span class="s1">assert_allclose(xd[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">xd2[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_unordered_tuple_list_equal(xd[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">xd2[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">tpl=sorted_tuple)</span>
        <span class="s1">assert_unordered_tuple_list_equal(xd[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">xd2[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">tpl=sorted_tuple)</span>
        <span class="s1">assert_unordered_tuple_list_equal(xd[</span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">xd2[</span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">tpl=sorted_tuple)</span>
        <span class="s1">assert_array_equal(xd[</span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">xd2[</span><span class="s2">4</span><span class="s1">])</span>

        <span class="s1">assert_allclose(yd[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">yd2[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_unordered_tuple_list_equal(yd[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">yd2[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">tpl=sorted_tuple)</span>
        <span class="s1">assert_unordered_tuple_list_equal(yd[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">yd2[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">tpl=sorted_tuple)</span>
        <span class="s1">assert_unordered_tuple_list_equal(yd[</span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">yd2[</span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">tpl=sorted_tuple)</span>
        <span class="s1">assert_array_equal(yd[</span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">yd2[</span><span class="s2">4</span><span class="s1">])</span>

        <span class="s1">x.close()</span>
        <span class="s1">assert_raises(RuntimeError</span><span class="s0">, </span><span class="s1">x.get_voronoi_diagram)</span>
        <span class="s1">y.close()</span>
        <span class="s1">assert_raises(RuntimeError</span><span class="s0">, </span><span class="s1">y.get_voronoi_diagram)</span>

    <span class="s0">def </span><span class="s1">test_issue_8051(self):</span>
        <span class="s1">points = np.array([[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]])</span>
        <span class="s1">Voronoi(points)</span>


<span class="s0">class </span><span class="s1">TestUtilities:</span>
    <span class="s5">&quot;&quot;&quot; 
    Check that utility functions work. 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">test_find_simplex(self):</span>
        <span class="s3"># Simple check that simplex finding works</span>
        <span class="s1">points = np.array([(</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">,</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">,</span><span class="s2">0</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">tri = qhull.Delaunay(points)</span>

        <span class="s3"># +---+</span>
        <span class="s3"># |\ 0|</span>
        <span class="s3"># | \ |</span>
        <span class="s3"># |1 \|</span>
        <span class="s3"># +---+</span>

        <span class="s1">assert_equal(tri.simplices</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]])</span>

        <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">[(</span><span class="s2">0.25</span><span class="s0">, </span><span class="s2">0.25</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">,</span>
                  <span class="s1">(</span><span class="s2">0.75</span><span class="s0">, </span><span class="s2">0.75</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">,</span>
                  <span class="s1">(</span><span class="s2">0.3</span><span class="s0">, </span><span class="s2">0.2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)]:</span>
            <span class="s1">i = tri.find_simplex(p[:</span><span class="s2">2</span><span class="s1">])</span>
            <span class="s1">assert_equal(i</span><span class="s0">, </span><span class="s1">p[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">err_msg=</span><span class="s4">f'</span><span class="s0">{</span><span class="s1">p</span><span class="s0">!r}</span><span class="s4">'</span><span class="s1">)</span>
            <span class="s1">j = qhull.tsearch(tri</span><span class="s0">, </span><span class="s1">p[:</span><span class="s2">2</span><span class="s1">])</span>
            <span class="s1">assert_equal(i</span><span class="s0">, </span><span class="s1">j)</span>

    <span class="s0">def </span><span class="s1">test_plane_distance(self):</span>
        <span class="s3"># Compare plane distance from hyperplane equations obtained from Qhull</span>
        <span class="s3"># to manually computed plane equations</span>
        <span class="s1">x = np.array([(</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0.99189033</span><span class="s0">, </span><span class="s2">0.37674127</span><span class="s1">)</span><span class="s0">,</span>
                      <span class="s1">(</span><span class="s2">0.99440079</span><span class="s0">, </span><span class="s2">0.45182168</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">p = np.array([</span><span class="s2">0.99966555</span><span class="s0">, </span><span class="s2">0.15685619</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.double)</span>

        <span class="s1">tri = qhull.Delaunay(x)</span>

        <span class="s1">z = tri.lift_points(x)</span>
        <span class="s1">pz = tri.lift_points(p)</span>

        <span class="s1">dist = tri.plane_distance(p)</span>

        <span class="s0">for </span><span class="s1">j</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">enumerate(tri.simplices):</span>
            <span class="s1">x1 = z[v[</span><span class="s2">0</span><span class="s1">]]</span>
            <span class="s1">x2 = z[v[</span><span class="s2">1</span><span class="s1">]]</span>
            <span class="s1">x3 = z[v[</span><span class="s2">2</span><span class="s1">]]</span>

            <span class="s1">n = np.cross(x1 - x3</span><span class="s0">, </span><span class="s1">x2 - x3)</span>
            <span class="s1">n /= np.sqrt(np.dot(n</span><span class="s0">, </span><span class="s1">n))</span>
            <span class="s1">n *= -np.sign(n[</span><span class="s2">2</span><span class="s1">])</span>

            <span class="s1">d = np.dot(n</span><span class="s0">, </span><span class="s1">pz - x3)</span>

            <span class="s1">assert_almost_equal(dist[j]</span><span class="s0">, </span><span class="s1">d)</span>

    <span class="s0">def </span><span class="s1">test_convex_hull(self):</span>
        <span class="s3"># Simple check that the convex hull seems to works</span>
        <span class="s1">points = np.array([(</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">,</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">,</span><span class="s2">0</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">tri = qhull.Delaunay(points)</span>

        <span class="s3"># +---+</span>
        <span class="s3"># |\ 0|</span>
        <span class="s3"># | \ |</span>
        <span class="s3"># |1 \|</span>
        <span class="s3"># +---+</span>

        <span class="s1">assert_equal(tri.convex_hull</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]])</span>

    <span class="s0">def </span><span class="s1">test_volume_area(self):</span>
        <span class="s3">#Basic check that we get back the correct volume and area for a cube</span>
        <span class="s1">points = np.array([(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">,</span>
                           <span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)])</span>
        <span class="s1">hull = qhull.ConvexHull(points)</span>

        <span class="s1">assert_allclose(hull.volume</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-14</span><span class="s0">,</span>
                        <span class="s1">err_msg=</span><span class="s4">&quot;Volume of cube is incorrect&quot;</span><span class="s1">)</span>
        <span class="s1">assert_allclose(hull.area</span><span class="s0">, </span><span class="s2">6.</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-14</span><span class="s0">,</span>
                        <span class="s1">err_msg=</span><span class="s4">&quot;Area of cube is incorrect&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_random_volume_area(self):</span>
        <span class="s3">#Test that the results for a random 10-point convex are</span>
        <span class="s3">#coherent with the output of qconvex Qt s FA</span>
        <span class="s1">points = np.array([(</span><span class="s2">0.362568364506</span><span class="s0">, </span><span class="s2">0.472712355305</span><span class="s0">, </span><span class="s2">0.347003084477</span><span class="s1">)</span><span class="s0">,</span>
                           <span class="s1">(</span><span class="s2">0.733731893414</span><span class="s0">, </span><span class="s2">0.634480295684</span><span class="s0">, </span><span class="s2">0.950513180209</span><span class="s1">)</span><span class="s0">,</span>
                           <span class="s1">(</span><span class="s2">0.511239955611</span><span class="s0">, </span><span class="s2">0.876839441267</span><span class="s0">, </span><span class="s2">0.418047827863</span><span class="s1">)</span><span class="s0">,</span>
                           <span class="s1">(</span><span class="s2">0.0765906233393</span><span class="s0">, </span><span class="s2">0.527373281342</span><span class="s0">, </span><span class="s2">0.6509863541</span><span class="s1">)</span><span class="s0">,</span>
                           <span class="s1">(</span><span class="s2">0.146694972056</span><span class="s0">, </span><span class="s2">0.596725793348</span><span class="s0">, </span><span class="s2">0.894860986685</span><span class="s1">)</span><span class="s0">,</span>
                           <span class="s1">(</span><span class="s2">0.513808585741</span><span class="s0">, </span><span class="s2">0.069576205858</span><span class="s0">, </span><span class="s2">0.530890338876</span><span class="s1">)</span><span class="s0">,</span>
                           <span class="s1">(</span><span class="s2">0.512343805118</span><span class="s0">, </span><span class="s2">0.663537132612</span><span class="s0">, </span><span class="s2">0.037689295973</span><span class="s1">)</span><span class="s0">,</span>
                           <span class="s1">(</span><span class="s2">0.47282965018</span><span class="s0">, </span><span class="s2">0.462176697655</span><span class="s0">, </span><span class="s2">0.14061843691</span><span class="s1">)</span><span class="s0">,</span>
                           <span class="s1">(</span><span class="s2">0.240584597123</span><span class="s0">, </span><span class="s2">0.778660020591</span><span class="s0">, </span><span class="s2">0.722913476339</span><span class="s1">)</span><span class="s0">,</span>
                           <span class="s1">(</span><span class="s2">0.951271745935</span><span class="s0">, </span><span class="s2">0.967000673944</span><span class="s0">, </span><span class="s2">0.890661319684</span><span class="s1">)])</span>

        <span class="s1">hull = qhull.ConvexHull(points)</span>
        <span class="s1">assert_allclose(hull.volume</span><span class="s0">, </span><span class="s2">0.14562013</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-07</span><span class="s0">,</span>
                        <span class="s1">err_msg=</span><span class="s4">&quot;Volume of random polyhedron is incorrect&quot;</span><span class="s1">)</span>
        <span class="s1">assert_allclose(hull.area</span><span class="s0">, </span><span class="s2">1.6670425</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-07</span><span class="s0">,</span>
                        <span class="s1">err_msg=</span><span class="s4">&quot;Area of random polyhedron is incorrect&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_incremental_volume_area_random_input(self):</span>
        <span class="s5">&quot;&quot;&quot;Test that incremental mode gives the same volume/area as 
        non-incremental mode and incremental mode with restart&quot;&quot;&quot;</span>
        <span class="s1">nr_points = </span><span class="s2">20</span>
        <span class="s1">dim = </span><span class="s2">3</span>
        <span class="s1">points = np.random.random((nr_points</span><span class="s0">, </span><span class="s1">dim))</span>
        <span class="s1">inc_hull = qhull.ConvexHull(points[:dim+</span><span class="s2">1</span><span class="s0">, </span><span class="s1">:]</span><span class="s0">, </span><span class="s1">incremental=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">inc_restart_hull = qhull.ConvexHull(points[:dim+</span><span class="s2">1</span><span class="s0">, </span><span class="s1">:]</span><span class="s0">, </span><span class="s1">incremental=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(dim+</span><span class="s2">1</span><span class="s0">, </span><span class="s1">nr_points):</span>
            <span class="s1">hull = qhull.ConvexHull(points[:i+</span><span class="s2">1</span><span class="s0">, </span><span class="s1">:])</span>
            <span class="s1">inc_hull.add_points(points[i:i+</span><span class="s2">1</span><span class="s0">, </span><span class="s1">:])</span>
            <span class="s1">inc_restart_hull.add_points(points[i:i+</span><span class="s2">1</span><span class="s0">, </span><span class="s1">:]</span><span class="s0">, </span><span class="s1">restart=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">assert_allclose(hull.volume</span><span class="s0">, </span><span class="s1">inc_hull.volume</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-7</span><span class="s1">)</span>
            <span class="s1">assert_allclose(hull.volume</span><span class="s0">, </span><span class="s1">inc_restart_hull.volume</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-7</span><span class="s1">)</span>
            <span class="s1">assert_allclose(hull.area</span><span class="s0">, </span><span class="s1">inc_hull.area</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-7</span><span class="s1">)</span>
            <span class="s1">assert_allclose(hull.area</span><span class="s0">, </span><span class="s1">inc_restart_hull.area</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-7</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_check_barycentric_transforms(self</span><span class="s0">, </span><span class="s1">tri</span><span class="s0">, </span><span class="s1">err_msg=</span><span class="s4">&quot;&quot;</span><span class="s0">,</span>
                                      <span class="s1">unit_cube=</span><span class="s0">False,</span>
                                      <span class="s1">unit_cube_tol=</span><span class="s2">0</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Check that a triangulation has reasonable barycentric transforms&quot;&quot;&quot;</span>
        <span class="s1">vertices = tri.points[tri.simplices]</span>
        <span class="s1">sc = </span><span class="s2">1</span><span class="s1">/(tri.ndim + </span><span class="s2">1.0</span><span class="s1">)</span>
        <span class="s1">centroids = vertices.sum(axis=</span><span class="s2">1</span><span class="s1">) * sc</span>

        <span class="s3"># Either: (i) the simplex has a `nan` barycentric transform,</span>
        <span class="s3"># or, (ii) the centroid is in the simplex</span>

        <span class="s0">def </span><span class="s1">barycentric_transform(tr</span><span class="s0">, </span><span class="s1">x):</span>
            <span class="s1">r = tr[:</span><span class="s0">,</span><span class="s1">-</span><span class="s2">1</span><span class="s0">,</span><span class="s1">:]</span>
            <span class="s1">Tinv = tr[:</span><span class="s0">,</span><span class="s1">:-</span><span class="s2">1</span><span class="s0">,</span><span class="s1">:]</span>
            <span class="s0">return </span><span class="s1">np.einsum(</span><span class="s4">'ijk,ik-&gt;ij'</span><span class="s0">, </span><span class="s1">Tinv</span><span class="s0">, </span><span class="s1">x - r)</span>

        <span class="s1">eps = np.finfo(float).eps</span>

        <span class="s1">c = barycentric_transform(tri.transform</span><span class="s0">, </span><span class="s1">centroids)</span>
        <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s4">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s1">ok = np.isnan(c).all(axis=</span><span class="s2">1</span><span class="s1">) | (abs(c - sc)/sc &lt; </span><span class="s2">0.1</span><span class="s1">).all(axis=</span><span class="s2">1</span><span class="s1">)</span>

        <span class="s1">assert_(ok.all()</span><span class="s0">, </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">err_msg</span><span class="s0">} {</span><span class="s1">np.nonzero(~ok)</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">)</span>

        <span class="s3"># Invalid simplices must be (nearly) zero volume</span>
        <span class="s1">q = vertices[:</span><span class="s0">,</span><span class="s1">:-</span><span class="s2">1</span><span class="s0">,</span><span class="s1">:] - vertices[:</span><span class="s0">,</span><span class="s1">-</span><span class="s2">1</span><span class="s0">,None,</span><span class="s1">:]</span>
        <span class="s1">volume = np.array([np.linalg.det(q[k</span><span class="s0">,</span><span class="s1">:</span><span class="s0">,</span><span class="s1">:])</span>
                           <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(tri.nsimplex)])</span>
        <span class="s1">ok = np.isfinite(tri.transform[:</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s1">]) | (volume &lt; np.sqrt(eps))</span>
        <span class="s1">assert_(ok.all()</span><span class="s0">, </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">err_msg</span><span class="s0">} {</span><span class="s1">np.nonzero(~ok)</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">)</span>

        <span class="s3"># Also, find_simplex for the centroid should end up in some</span>
        <span class="s3"># simplex for the non-degenerate cases</span>
        <span class="s1">j = tri.find_simplex(centroids)</span>
        <span class="s1">ok = (j != -</span><span class="s2">1</span><span class="s1">) | np.isnan(tri.transform[:</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_(ok.all()</span><span class="s0">, </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">err_msg</span><span class="s0">} {</span><span class="s1">np.nonzero(~ok)</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">unit_cube:</span>
            <span class="s3"># If in unit cube, no interior point should be marked out of hull</span>
            <span class="s1">at_boundary = (centroids &lt;= unit_cube_tol).any(axis=</span><span class="s2">1</span><span class="s1">)</span>
            <span class="s1">at_boundary |= (centroids &gt;= </span><span class="s2">1 </span><span class="s1">- unit_cube_tol).any(axis=</span><span class="s2">1</span><span class="s1">)</span>

            <span class="s1">ok = (j != -</span><span class="s2">1</span><span class="s1">) | at_boundary</span>
            <span class="s1">assert_(ok.all()</span><span class="s0">, </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">err_msg</span><span class="s0">} {</span><span class="s1">np.nonzero(~ok)</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_degenerate_barycentric_transforms(self):</span>
        <span class="s3"># The triangulation should not produce invalid barycentric</span>
        <span class="s3"># transforms that stump the simplex finding</span>
        <span class="s1">data = np.load(os.path.join(os.path.dirname(__file__)</span><span class="s0">, </span><span class="s4">'data'</span><span class="s0">,</span>
                                    <span class="s4">'degenerate_pointset.npz'</span><span class="s1">))</span>
        <span class="s1">points = data[</span><span class="s4">'c'</span><span class="s1">]</span>
        <span class="s1">data.close()</span>

        <span class="s1">tri = qhull.Delaunay(points)</span>

        <span class="s3"># Check that there are not too many invalid simplices</span>
        <span class="s1">bad_count = np.isnan(tri.transform[:</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s1">]).sum()</span>
        <span class="s1">assert_(bad_count &lt; </span><span class="s2">23</span><span class="s0">, </span><span class="s1">bad_count)</span>

        <span class="s3"># Check the transforms</span>
        <span class="s1">self._check_barycentric_transforms(tri)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s0">def </span><span class="s1">test_more_barycentric_transforms(self):</span>
        <span class="s3"># Triangulate some &quot;nasty&quot; grids</span>

        <span class="s1">eps = np.finfo(float).eps</span>

        <span class="s1">npoints = {</span><span class="s2">2</span><span class="s1">: </span><span class="s2">70</span><span class="s0">, </span><span class="s2">3</span><span class="s1">: </span><span class="s2">11</span><span class="s0">, </span><span class="s2">4</span><span class="s1">: </span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s1">: </span><span class="s2">3</span><span class="s1">}</span>

        <span class="s0">for </span><span class="s1">ndim </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">6</span><span class="s1">):</span>
            <span class="s3"># Generate an uniform grid in n-d unit cube</span>
            <span class="s1">x = np.linspace(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">npoints[ndim])</span>
            <span class="s1">grid = np.c_[list(map(np.ravel</span><span class="s0">, </span><span class="s1">np.broadcast_arrays(*np.ix_(*([x]*ndim)))))].T</span>

            <span class="s1">err_msg = </span><span class="s4">&quot;ndim=%d&quot; </span><span class="s1">% ndim</span>

            <span class="s3"># Check using regular grid</span>
            <span class="s1">tri = qhull.Delaunay(grid)</span>
            <span class="s1">self._check_barycentric_transforms(tri</span><span class="s0">, </span><span class="s1">err_msg=err_msg</span><span class="s0">,</span>
                                               <span class="s1">unit_cube=</span><span class="s0">True</span><span class="s1">)</span>

            <span class="s3"># Check with eps-perturbations</span>
            <span class="s1">np.random.seed(</span><span class="s2">1234</span><span class="s1">)</span>
            <span class="s1">m = (np.random.rand(grid.shape[</span><span class="s2">0</span><span class="s1">]) &lt; </span><span class="s2">0.2</span><span class="s1">)</span>
            <span class="s1">grid[m</span><span class="s0">,</span><span class="s1">:] += </span><span class="s2">2</span><span class="s1">*eps*(np.random.rand(*grid[m</span><span class="s0">,</span><span class="s1">:].shape) - </span><span class="s2">0.5</span><span class="s1">)</span>

            <span class="s1">tri = qhull.Delaunay(grid)</span>
            <span class="s1">self._check_barycentric_transforms(tri</span><span class="s0">, </span><span class="s1">err_msg=err_msg</span><span class="s0">,</span>
                                               <span class="s1">unit_cube=</span><span class="s0">True,</span>
                                               <span class="s1">unit_cube_tol=</span><span class="s2">2</span><span class="s1">*eps)</span>

            <span class="s3"># Check with duplicated data</span>
            <span class="s1">tri = qhull.Delaunay(np.r_[grid</span><span class="s0">, </span><span class="s1">grid])</span>
            <span class="s1">self._check_barycentric_transforms(tri</span><span class="s0">, </span><span class="s1">err_msg=err_msg</span><span class="s0">,</span>
                                               <span class="s1">unit_cube=</span><span class="s0">True,</span>
                                               <span class="s1">unit_cube_tol=</span><span class="s2">2</span><span class="s1">*eps)</span>


<span class="s0">class </span><span class="s1">TestVertexNeighborVertices:</span>
    <span class="s0">def </span><span class="s1">_check(self</span><span class="s0">, </span><span class="s1">tri):</span>
        <span class="s1">expected = [set() </span><span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(tri.points.shape[</span><span class="s2">0</span><span class="s1">])]</span>
        <span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">tri.simplices:</span>
            <span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">s:</span>
                <span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">s:</span>
                    <span class="s0">if </span><span class="s1">a != b:</span>
                        <span class="s1">expected[a].add(b)</span>

        <span class="s1">indptr</span><span class="s0">, </span><span class="s1">indices = tri.vertex_neighbor_vertices</span>

        <span class="s1">got = [set(map(int</span><span class="s0">, </span><span class="s1">indices[indptr[j]:indptr[j+</span><span class="s2">1</span><span class="s1">]]))</span>
               <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(tri.points.shape[</span><span class="s2">0</span><span class="s1">])]</span>

        <span class="s1">assert_equal(got</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">err_msg=</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">got</span><span class="s0">!r} </span><span class="s4">!= </span><span class="s0">{</span><span class="s1">expected</span><span class="s0">!r}</span><span class="s4">&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_triangle(self):</span>
        <span class="s1">points = np.array([(</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">,</span><span class="s2">0</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">tri = qhull.Delaunay(points)</span>
        <span class="s1">self._check(tri)</span>

    <span class="s0">def </span><span class="s1">test_rectangle(self):</span>
        <span class="s1">points = np.array([(</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">,</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">,</span><span class="s2">0</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">tri = qhull.Delaunay(points)</span>
        <span class="s1">self._check(tri)</span>

    <span class="s0">def </span><span class="s1">test_complicated(self):</span>
        <span class="s1">points = np.array([(</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">,</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">,</span><span class="s2">0</span><span class="s1">)</span><span class="s0">,</span>
                           <span class="s1">(</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0.9</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">tri = qhull.Delaunay(points)</span>
        <span class="s1">self._check(tri)</span>


<span class="s0">class </span><span class="s1">TestDelaunay:</span>
    <span class="s5">&quot;&quot;&quot; 
    Check that triangulation works. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">test_masked_array_fails(self):</span>
        <span class="s1">masked_array = np.ma.masked_all(</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">qhull.Delaunay</span><span class="s0">, </span><span class="s1">masked_array)</span>

    <span class="s0">def </span><span class="s1">test_array_with_nans_fails(self):</span>
        <span class="s1">points_with_nan = np.array([(</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">,</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">,</span><span class="s1">np.nan)]</span><span class="s0">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">qhull.Delaunay</span><span class="s0">, </span><span class="s1">points_with_nan)</span>

    <span class="s0">def </span><span class="s1">test_nd_simplex(self):</span>
        <span class="s3"># simple smoke test: triangulate a n-dimensional simplex</span>
        <span class="s0">for </span><span class="s1">nd </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">8</span><span class="s1">):</span>
            <span class="s1">points = np.zeros((nd+</span><span class="s2">1</span><span class="s0">, </span><span class="s1">nd))</span>
            <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(nd):</span>
                <span class="s1">points[j</span><span class="s0">,</span><span class="s1">j] = </span><span class="s2">1.0</span>
            <span class="s1">points[-</span><span class="s2">1</span><span class="s0">,</span><span class="s1">:] = </span><span class="s2">1.0</span>

            <span class="s1">tri = qhull.Delaunay(points)</span>

            <span class="s1">tri.simplices.sort()</span>

            <span class="s1">assert_equal(tri.simplices</span><span class="s0">, </span><span class="s1">np.arange(nd+</span><span class="s2">1</span><span class="s0">, </span><span class="s1">dtype=int)[</span><span class="s0">None, </span><span class="s1">:])</span>
            <span class="s1">assert_equal(tri.neighbors</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1 </span><span class="s1">+ np.zeros((nd+</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=int)[</span><span class="s0">None,</span><span class="s1">:])</span>

    <span class="s0">def </span><span class="s1">test_2d_square(self):</span>
        <span class="s3"># simple smoke test: 2d square</span>
        <span class="s1">points = np.array([(</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">,</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">,</span><span class="s2">0</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">tri = qhull.Delaunay(points)</span>

        <span class="s1">assert_equal(tri.simplices</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]])</span>
        <span class="s1">assert_equal(tri.neighbors</span><span class="s0">, </span><span class="s1">[[-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]])</span>

    <span class="s0">def </span><span class="s1">test_duplicate_points(self):</span>
        <span class="s1">x = np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">y = np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>

        <span class="s1">xp = np.r_[x</span><span class="s0">, </span><span class="s1">x]</span>
        <span class="s1">yp = np.r_[y</span><span class="s0">, </span><span class="s1">y]</span>

        <span class="s3"># shouldn't fail on duplicate points</span>
        <span class="s1">qhull.Delaunay(np.c_[x</span><span class="s0">, </span><span class="s1">y])</span>
        <span class="s1">qhull.Delaunay(np.c_[xp</span><span class="s0">, </span><span class="s1">yp])</span>

    <span class="s0">def </span><span class="s1">test_pathological(self):</span>
        <span class="s3"># both should succeed</span>
        <span class="s1">points = DATASETS[</span><span class="s4">'pathological-1'</span><span class="s1">]</span>
        <span class="s1">tri = qhull.Delaunay(points)</span>
        <span class="s1">assert_equal(tri.points[tri.simplices].max()</span><span class="s0">, </span><span class="s1">points.max())</span>
        <span class="s1">assert_equal(tri.points[tri.simplices].min()</span><span class="s0">, </span><span class="s1">points.min())</span>

        <span class="s1">points = DATASETS[</span><span class="s4">'pathological-2'</span><span class="s1">]</span>
        <span class="s1">tri = qhull.Delaunay(points)</span>
        <span class="s1">assert_equal(tri.points[tri.simplices].max()</span><span class="s0">, </span><span class="s1">points.max())</span>
        <span class="s1">assert_equal(tri.points[tri.simplices].min()</span><span class="s0">, </span><span class="s1">points.min())</span>

    <span class="s0">def </span><span class="s1">test_joggle(self):</span>
        <span class="s3"># Check that the option QJ indeed guarantees that all input points</span>
        <span class="s3"># occur as vertices of the triangulation</span>

        <span class="s1">points = np.random.rand(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">points = np.r_[points</span><span class="s0">, </span><span class="s1">points]  </span><span class="s3"># duplicate input data</span>

        <span class="s1">tri = qhull.Delaunay(points</span><span class="s0">, </span><span class="s1">qhull_options=</span><span class="s4">&quot;QJ Qbb Pp&quot;</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(np.unique(tri.simplices.ravel())</span><span class="s0">,</span>
                           <span class="s1">np.arange(len(points)))</span>

    <span class="s0">def </span><span class="s1">test_coplanar(self):</span>
        <span class="s3"># Check that the coplanar point output option indeed works</span>
        <span class="s1">points = np.random.rand(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">points = np.r_[points</span><span class="s0">, </span><span class="s1">points]  </span><span class="s3"># duplicate input data</span>

        <span class="s1">tri = qhull.Delaunay(points)</span>

        <span class="s1">assert_(len(np.unique(tri.simplices.ravel())) == len(points)//</span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">assert_(len(tri.coplanar) == len(points)//</span><span class="s2">2</span><span class="s1">)</span>

        <span class="s1">assert_(len(np.unique(tri.coplanar[:</span><span class="s0">,</span><span class="s2">2</span><span class="s1">])) == len(points)//</span><span class="s2">2</span><span class="s1">)</span>

        <span class="s1">assert_(np.all(tri.vertex_to_simplex &gt;= </span><span class="s2">0</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_furthest_site(self):</span>
        <span class="s1">points = [(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1.1</span><span class="s0">, </span><span class="s2">1.1</span><span class="s1">)]</span>
        <span class="s1">tri = qhull.Delaunay(points</span><span class="s0">, </span><span class="s1">furthest_site=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s1">expected = np.array([(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)])  </span><span class="s3"># from Qhull</span>
        <span class="s1">assert_array_equal(tri.simplices</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;name&quot;</span><span class="s0">, </span><span class="s1">sorted(INCREMENTAL_DATASETS))</span>
    <span class="s0">def </span><span class="s1">test_incremental(self</span><span class="s0">, </span><span class="s1">name):</span>
        <span class="s3"># Test incremental construction of the triangulation</span>

        <span class="s1">chunks</span><span class="s0">, </span><span class="s1">opts = INCREMENTAL_DATASETS[name]</span>
        <span class="s1">points = np.concatenate(chunks</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">)</span>

        <span class="s1">obj = qhull.Delaunay(chunks[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">incremental=</span><span class="s0">True,</span>
                             <span class="s1">qhull_options=opts)</span>
        <span class="s0">for </span><span class="s1">chunk </span><span class="s0">in </span><span class="s1">chunks[</span><span class="s2">1</span><span class="s1">:]:</span>
            <span class="s1">obj.add_points(chunk)</span>

        <span class="s1">obj2 = qhull.Delaunay(points)</span>

        <span class="s1">obj3 = qhull.Delaunay(chunks[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">incremental=</span><span class="s0">True,</span>
                              <span class="s1">qhull_options=opts)</span>
        <span class="s0">if </span><span class="s1">len(chunks) &gt; </span><span class="s2">1</span><span class="s1">:</span>
            <span class="s1">obj3.add_points(np.concatenate(chunks[</span><span class="s2">1</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">)</span><span class="s0">,</span>
                            <span class="s1">restart=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s3"># Check that the incremental mode agrees with upfront mode</span>
        <span class="s0">if </span><span class="s1">name.startswith(</span><span class="s4">'pathological'</span><span class="s1">):</span>
            <span class="s3"># XXX: These produce valid but different triangulations.</span>
            <span class="s3">#      They look OK when plotted, but how to check them?</span>

            <span class="s1">assert_array_equal(np.unique(obj.simplices.ravel())</span><span class="s0">,</span>
                               <span class="s1">np.arange(points.shape[</span><span class="s2">0</span><span class="s1">]))</span>
            <span class="s1">assert_array_equal(np.unique(obj2.simplices.ravel())</span><span class="s0">,</span>
                               <span class="s1">np.arange(points.shape[</span><span class="s2">0</span><span class="s1">]))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">assert_unordered_tuple_list_equal(obj.simplices</span><span class="s0">, </span><span class="s1">obj2.simplices</span><span class="s0">,</span>
                                              <span class="s1">tpl=sorted_tuple)</span>

        <span class="s1">assert_unordered_tuple_list_equal(obj2.simplices</span><span class="s0">, </span><span class="s1">obj3.simplices</span><span class="s0">,</span>
                                          <span class="s1">tpl=sorted_tuple)</span>


<span class="s0">def </span><span class="s1">assert_hulls_equal(points</span><span class="s0">, </span><span class="s1">facets_1</span><span class="s0">, </span><span class="s1">facets_2):</span>
    <span class="s3"># Check that two convex hulls constructed from the same point set</span>
    <span class="s3"># are equal</span>

    <span class="s1">facets_1 = set(map(sorted_tuple</span><span class="s0">, </span><span class="s1">facets_1))</span>
    <span class="s1">facets_2 = set(map(sorted_tuple</span><span class="s0">, </span><span class="s1">facets_2))</span>

    <span class="s0">if </span><span class="s1">facets_1 != facets_2 </span><span class="s0">and </span><span class="s1">points.shape[</span><span class="s2">1</span><span class="s1">] == </span><span class="s2">2</span><span class="s1">:</span>
        <span class="s3"># The direct check fails for the pathological cases</span>
        <span class="s3"># --- then the convex hull from Delaunay differs (due</span>
        <span class="s3"># to rounding error etc.) from the hull computed</span>
        <span class="s3"># otherwise, by the question whether (tricoplanar)</span>
        <span class="s3"># points that lie almost exactly on the hull are</span>
        <span class="s3"># included as vertices of the hull or not.</span>
        <span class="s3">#</span>
        <span class="s3"># So we check the result, and accept it if the Delaunay</span>
        <span class="s3"># hull line segments are a subset of the usual hull.</span>

        <span class="s1">eps = </span><span class="s2">1000 </span><span class="s1">* np.finfo(float).eps</span>

        <span class="s0">for </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b </span><span class="s0">in </span><span class="s1">facets_1:</span>
            <span class="s0">for </span><span class="s1">ap</span><span class="s0">, </span><span class="s1">bp </span><span class="s0">in </span><span class="s1">facets_2:</span>
                <span class="s1">t = points[bp] - points[ap]</span>
                <span class="s1">t /= np.linalg.norm(t)       </span><span class="s3"># tangent</span>
                <span class="s1">n = np.array([-t[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">t[</span><span class="s2">0</span><span class="s1">]])  </span><span class="s3"># normal</span>

                <span class="s3"># check that the two line segments are parallel</span>
                <span class="s3"># to the same line</span>
                <span class="s1">c1 = np.dot(n</span><span class="s0">, </span><span class="s1">points[b] - points[ap])</span>
                <span class="s1">c2 = np.dot(n</span><span class="s0">, </span><span class="s1">points[a] - points[ap])</span>
                <span class="s0">if not </span><span class="s1">np.allclose(np.dot(c1</span><span class="s0">, </span><span class="s1">n)</span><span class="s0">, </span><span class="s2">0</span><span class="s1">):</span>
                    <span class="s0">continue</span>
                <span class="s0">if not </span><span class="s1">np.allclose(np.dot(c2</span><span class="s0">, </span><span class="s1">n)</span><span class="s0">, </span><span class="s2">0</span><span class="s1">):</span>
                    <span class="s0">continue</span>

                <span class="s3"># Check that the segment (a, b) is contained in (ap, bp)</span>
                <span class="s1">c1 = np.dot(t</span><span class="s0">, </span><span class="s1">points[a] - points[ap])</span>
                <span class="s1">c2 = np.dot(t</span><span class="s0">, </span><span class="s1">points[b] - points[ap])</span>
                <span class="s1">c3 = np.dot(t</span><span class="s0">, </span><span class="s1">points[bp] - points[ap])</span>
                <span class="s0">if </span><span class="s1">c1 &lt; -eps </span><span class="s0">or </span><span class="s1">c1 &gt; c3 + eps:</span>
                    <span class="s0">continue</span>
                <span class="s0">if </span><span class="s1">c2 &lt; -eps </span><span class="s0">or </span><span class="s1">c2 &gt; c3 + eps:</span>
                    <span class="s0">continue</span>

                <span class="s3"># OK:</span>
                <span class="s0">break</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">AssertionError(</span><span class="s4">&quot;comparison fails&quot;</span><span class="s1">)</span>

        <span class="s3"># it was OK</span>
        <span class="s0">return</span>

    <span class="s1">assert_equal(facets_1</span><span class="s0">, </span><span class="s1">facets_2)</span>


<span class="s0">class </span><span class="s1">TestConvexHull:</span>
    <span class="s0">def </span><span class="s1">test_masked_array_fails(self):</span>
        <span class="s1">masked_array = np.ma.masked_all(</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">qhull.ConvexHull</span><span class="s0">, </span><span class="s1">masked_array)</span>

    <span class="s0">def </span><span class="s1">test_array_with_nans_fails(self):</span>
        <span class="s1">points_with_nan = np.array([(</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">,</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">,</span><span class="s1">np.nan)]</span><span class="s0">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">qhull.ConvexHull</span><span class="s0">, </span><span class="s1">points_with_nan)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;name&quot;</span><span class="s0">, </span><span class="s1">sorted(DATASETS))</span>
    <span class="s0">def </span><span class="s1">test_hull_consistency_tri(self</span><span class="s0">, </span><span class="s1">name):</span>
        <span class="s3"># Check that a convex hull returned by qhull in ndim</span>
        <span class="s3"># and the hull constructed from ndim delaunay agree</span>
        <span class="s1">points = DATASETS[name]</span>

        <span class="s1">tri = qhull.Delaunay(points)</span>
        <span class="s1">hull = qhull.ConvexHull(points)</span>

        <span class="s1">assert_hulls_equal(points</span><span class="s0">, </span><span class="s1">tri.convex_hull</span><span class="s0">, </span><span class="s1">hull.simplices)</span>

        <span class="s3"># Check that the hull extremes are as expected</span>
        <span class="s0">if </span><span class="s1">points.shape[</span><span class="s2">1</span><span class="s1">] == </span><span class="s2">2</span><span class="s1">:</span>
            <span class="s1">assert_equal(np.unique(hull.simplices)</span><span class="s0">, </span><span class="s1">np.sort(hull.vertices))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">assert_equal(np.unique(hull.simplices)</span><span class="s0">, </span><span class="s1">hull.vertices)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;name&quot;</span><span class="s0">, </span><span class="s1">sorted(INCREMENTAL_DATASETS))</span>
    <span class="s0">def </span><span class="s1">test_incremental(self</span><span class="s0">, </span><span class="s1">name):</span>
        <span class="s3"># Test incremental construction of the convex hull</span>
        <span class="s1">chunks</span><span class="s0">, </span><span class="s1">_ = INCREMENTAL_DATASETS[name]</span>
        <span class="s1">points = np.concatenate(chunks</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">)</span>

        <span class="s1">obj = qhull.ConvexHull(chunks[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">incremental=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">chunk </span><span class="s0">in </span><span class="s1">chunks[</span><span class="s2">1</span><span class="s1">:]:</span>
            <span class="s1">obj.add_points(chunk)</span>

        <span class="s1">obj2 = qhull.ConvexHull(points)</span>

        <span class="s1">obj3 = qhull.ConvexHull(chunks[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">incremental=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">len(chunks) &gt; </span><span class="s2">1</span><span class="s1">:</span>
            <span class="s1">obj3.add_points(np.concatenate(chunks[</span><span class="s2">1</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">)</span><span class="s0">,</span>
                            <span class="s1">restart=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s3"># Check that the incremental mode agrees with upfront mode</span>
        <span class="s1">assert_hulls_equal(points</span><span class="s0">, </span><span class="s1">obj.simplices</span><span class="s0">, </span><span class="s1">obj2.simplices)</span>
        <span class="s1">assert_hulls_equal(points</span><span class="s0">, </span><span class="s1">obj.simplices</span><span class="s0">, </span><span class="s1">obj3.simplices)</span>

    <span class="s0">def </span><span class="s1">test_vertices_2d(self):</span>
        <span class="s3"># The vertices should be in counterclockwise order in 2-D</span>
        <span class="s1">np.random.seed(</span><span class="s2">1234</span><span class="s1">)</span>
        <span class="s1">points = np.random.rand(</span><span class="s2">30</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>

        <span class="s1">hull = qhull.ConvexHull(points)</span>
        <span class="s1">assert_equal(np.unique(hull.simplices)</span><span class="s0">, </span><span class="s1">np.sort(hull.vertices))</span>

        <span class="s3"># Check counterclockwiseness</span>
        <span class="s1">x</span><span class="s0">, </span><span class="s1">y = hull.points[hull.vertices].T</span>
        <span class="s1">angle = np.arctan2(y - y.mean()</span><span class="s0">, </span><span class="s1">x - x.mean())</span>
        <span class="s1">assert_(np.all(np.diff(np.unwrap(angle)) &gt; </span><span class="s2">0</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_volume_area(self):</span>
        <span class="s3"># Basic check that we get back the correct volume and area for a cube</span>
        <span class="s1">points = np.array([(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">,</span>
                           <span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)])</span>
        <span class="s1">tri = qhull.ConvexHull(points)</span>

        <span class="s1">assert_allclose(tri.volume</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-14</span><span class="s1">)</span>
        <span class="s1">assert_allclose(tri.area</span><span class="s0">, </span><span class="s2">6.</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-14</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;incremental&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, True</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_good2d(self</span><span class="s0">, </span><span class="s1">incremental):</span>
        <span class="s3"># Make sure the QGn option gives the correct value of &quot;good&quot;.</span>
        <span class="s1">points = np.array([[</span><span class="s2">0.2</span><span class="s0">, </span><span class="s2">0.2</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s2">0.2</span><span class="s0">, </span><span class="s2">0.4</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s2">0.4</span><span class="s0">, </span><span class="s2">0.4</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s2">0.4</span><span class="s0">, </span><span class="s2">0.2</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s2">0.3</span><span class="s0">, </span><span class="s2">0.6</span><span class="s1">]])</span>
        <span class="s1">hull = qhull.ConvexHull(points=points</span><span class="s0">,</span>
                                <span class="s1">incremental=incremental</span><span class="s0">,</span>
                                <span class="s1">qhull_options=</span><span class="s4">'QG4'</span><span class="s1">)</span>
        <span class="s1">expected = np.array([</span><span class="s0">False, True, False, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
        <span class="s1">actual = hull.good</span>
        <span class="s1">assert_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;visibility&quot;</span><span class="s0">, </span><span class="s1">[</span>
                              <span class="s4">&quot;QG4&quot;</span><span class="s0">,  </span><span class="s3"># visible=True</span>
                              <span class="s4">&quot;QG-4&quot;</span><span class="s0">,  </span><span class="s3"># visible=False</span>
                              <span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;new_gen, expected&quot;</span><span class="s0">, </span><span class="s1">[</span>
        <span class="s3"># add generator that places QG4 inside hull</span>
        <span class="s3"># so all facets are invisible</span>
        <span class="s1">(np.array([[</span><span class="s2">0.3</span><span class="s0">, </span><span class="s2">0.7</span><span class="s1">]])</span><span class="s0">,</span>
         <span class="s1">np.array([</span><span class="s0">False, False, False, False, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=bool))</span><span class="s0">,</span>
        <span class="s3"># adding a generator on the opposite side of the square</span>
        <span class="s3"># should preserve the single visible facet &amp; add one invisible</span>
        <span class="s3"># facet</span>
        <span class="s1">(np.array([[</span><span class="s2">0.3</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.7</span><span class="s1">]])</span><span class="s0">,</span>
         <span class="s1">np.array([</span><span class="s0">False, True, False, False, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=bool))</span><span class="s0">,</span>
        <span class="s3"># split the visible facet on top of the square into two</span>
        <span class="s3"># visible facets, with visibility at the end of the array</span>
        <span class="s3"># because add_points concatenates</span>
        <span class="s1">(np.array([[</span><span class="s2">0.3</span><span class="s0">, </span><span class="s2">0.41</span><span class="s1">]])</span><span class="s0">,</span>
         <span class="s1">np.array([</span><span class="s0">False, False, False, True, True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=bool))</span><span class="s0">,</span>
        <span class="s3"># with our current Qhull options, coplanarity will not count</span>
        <span class="s3"># for visibility; this case shifts one visible &amp; one invisible</span>
        <span class="s3"># facet &amp; adds a coplanar facet</span>
        <span class="s3"># simplex at index position 2 is the shifted visible facet</span>
        <span class="s3"># the final simplex is the coplanar facet</span>
        <span class="s1">(np.array([[</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.6</span><span class="s0">, </span><span class="s2">0.6</span><span class="s1">]])</span><span class="s0">,</span>
         <span class="s1">np.array([</span><span class="s0">False, False, True, False, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=bool))</span><span class="s0">,</span>
        <span class="s3"># place the new generator such that it envelops the query</span>
        <span class="s3"># point within the convex hull, but only just barely within</span>
        <span class="s3"># the double precision limit</span>
        <span class="s3"># NOTE: testing exact degeneracy is less predictable than this</span>
        <span class="s3"># scenario, perhaps because of the default Qt option we have</span>
        <span class="s3"># enabled for Qhull to handle precision matters</span>
        <span class="s1">(np.array([[</span><span class="s2">0.3</span><span class="s0">, </span><span class="s2">0.6 </span><span class="s1">+ </span><span class="s2">1e-16</span><span class="s1">]])</span><span class="s0">,</span>
         <span class="s1">np.array([</span><span class="s0">False, False, False, False, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=bool))</span><span class="s0">,</span>
        <span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_good2d_incremental_changes(self</span><span class="s0">, </span><span class="s1">new_gen</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">,</span>
                                        <span class="s1">visibility):</span>
        <span class="s3"># use the usual square convex hull</span>
        <span class="s3"># generators from test_good2d</span>
        <span class="s1">points = np.array([[</span><span class="s2">0.2</span><span class="s0">, </span><span class="s2">0.2</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s2">0.2</span><span class="s0">, </span><span class="s2">0.4</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s2">0.4</span><span class="s0">, </span><span class="s2">0.4</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s2">0.4</span><span class="s0">, </span><span class="s2">0.2</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s2">0.3</span><span class="s0">, </span><span class="s2">0.6</span><span class="s1">]])</span>
        <span class="s1">hull = qhull.ConvexHull(points=points</span><span class="s0">,</span>
                                <span class="s1">incremental=</span><span class="s0">True,</span>
                                <span class="s1">qhull_options=visibility)</span>
        <span class="s1">hull.add_points(new_gen)</span>
        <span class="s1">actual = hull.good</span>
        <span class="s0">if </span><span class="s4">'-' </span><span class="s0">in </span><span class="s1">visibility:</span>
            <span class="s1">expected = np.invert(expected)</span>
        <span class="s1">assert_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;incremental&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, True</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_good2d_no_option(self</span><span class="s0">, </span><span class="s1">incremental):</span>
        <span class="s3"># handle case where good attribue doesn't exist</span>
        <span class="s3"># because Qgn or Qg-n wasn't specified</span>
        <span class="s1">points = np.array([[</span><span class="s2">0.2</span><span class="s0">, </span><span class="s2">0.2</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s2">0.2</span><span class="s0">, </span><span class="s2">0.4</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s2">0.4</span><span class="s0">, </span><span class="s2">0.4</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s2">0.4</span><span class="s0">, </span><span class="s2">0.2</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s2">0.3</span><span class="s0">, </span><span class="s2">0.6</span><span class="s1">]])</span>
        <span class="s1">hull = qhull.ConvexHull(points=points</span><span class="s0">,</span>
                                <span class="s1">incremental=incremental)</span>
        <span class="s1">actual = hull.good</span>
        <span class="s0">assert </span><span class="s1">actual </span><span class="s0">is None</span>
        <span class="s3"># preserve None after incremental addition</span>
        <span class="s0">if </span><span class="s1">incremental:</span>
            <span class="s1">hull.add_points(np.zeros((</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)))</span>
            <span class="s1">actual = hull.good</span>
            <span class="s0">assert </span><span class="s1">actual </span><span class="s0">is None</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;incremental&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, True</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_good2d_inside(self</span><span class="s0">, </span><span class="s1">incremental):</span>
        <span class="s3"># Make sure the QGn option gives the correct value of &quot;good&quot;.</span>
        <span class="s3"># When point n is inside the convex hull of the rest, good is</span>
        <span class="s3"># all False.</span>
        <span class="s1">points = np.array([[</span><span class="s2">0.2</span><span class="s0">, </span><span class="s2">0.2</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s2">0.2</span><span class="s0">, </span><span class="s2">0.4</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s2">0.4</span><span class="s0">, </span><span class="s2">0.4</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s2">0.4</span><span class="s0">, </span><span class="s2">0.2</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s2">0.3</span><span class="s0">, </span><span class="s2">0.3</span><span class="s1">]])</span>
        <span class="s1">hull = qhull.ConvexHull(points=points</span><span class="s0">,</span>
                                <span class="s1">incremental=incremental</span><span class="s0">,</span>
                                <span class="s1">qhull_options=</span><span class="s4">'QG4'</span><span class="s1">)</span>
        <span class="s1">expected = np.array([</span><span class="s0">False, False, False, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
        <span class="s1">actual = hull.good</span>
        <span class="s1">assert_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;incremental&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, True</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_good3d(self</span><span class="s0">, </span><span class="s1">incremental):</span>
        <span class="s3"># Make sure the QGn option gives the correct value of &quot;good&quot;</span>
        <span class="s3"># for a 3d figure</span>
        <span class="s1">points = np.array([[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s2">0.90029516</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.39187448</span><span class="s0">, </span><span class="s2">0.18948093</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s2">0.48676420</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.72627633</span><span class="s0">, </span><span class="s2">0.48536925</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s2">0.57651530</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.81179274</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.09285832</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s2">0.67846893</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.71119562</span><span class="s0">, </span><span class="s2">0.18406710</span><span class="s1">]])</span>
        <span class="s1">hull = qhull.ConvexHull(points=points</span><span class="s0">,</span>
                                <span class="s1">incremental=incremental</span><span class="s0">,</span>
                                <span class="s1">qhull_options=</span><span class="s4">'QG0'</span><span class="s1">)</span>
        <span class="s1">expected = np.array([</span><span class="s0">True, False, False, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
        <span class="s1">assert_equal(hull.good</span><span class="s0">, </span><span class="s1">expected)</span>

<span class="s0">class </span><span class="s1">TestVoronoi:</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;qhull_opts, extra_pts&quot;</span><span class="s0">, </span><span class="s1">[</span>
        <span class="s3"># option Qz (default for SciPy) will add</span>
        <span class="s3"># an extra point at infinity</span>
        <span class="s1">(</span><span class="s4">&quot;Qbb Qc Qz&quot;</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s4">&quot;Qbb Qc&quot;</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;n_pts&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">50</span><span class="s0">, </span><span class="s2">100</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;ndim&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_point_region_structure(self</span><span class="s0">,</span>
                                    <span class="s1">qhull_opts</span><span class="s0">,</span>
                                    <span class="s1">n_pts</span><span class="s0">,</span>
                                    <span class="s1">extra_pts</span><span class="s0">,</span>
                                    <span class="s1">ndim):</span>
        <span class="s3"># see gh-16773</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s2">7790</span><span class="s1">)</span>
        <span class="s1">points = rng.random((n_pts</span><span class="s0">, </span><span class="s1">ndim))</span>
        <span class="s1">vor = Voronoi(points</span><span class="s0">, </span><span class="s1">qhull_options=qhull_opts)</span>
        <span class="s1">pt_region = vor.point_region</span>
        <span class="s0">assert </span><span class="s1">pt_region.max() == n_pts - </span><span class="s2">1 </span><span class="s1">+ extra_pts</span>
        <span class="s0">assert </span><span class="s1">pt_region.size == len(vor.regions) - extra_pts</span>
        <span class="s0">assert </span><span class="s1">len(vor.regions) == n_pts + extra_pts</span>
        <span class="s0">assert </span><span class="s1">vor.points.shape[</span><span class="s2">0</span><span class="s1">] == n_pts</span>
        <span class="s3"># if there is an empty sublist in the Voronoi</span>
        <span class="s3"># regions data structure, it should never be</span>
        <span class="s3"># indexed because it corresponds to an internally</span>
        <span class="s3"># added point at infinity and is not a member of the</span>
        <span class="s3"># generators (input points)</span>
        <span class="s0">if </span><span class="s1">extra_pts:</span>
            <span class="s1">sublens = [len(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">vor.regions]</span>
            <span class="s3"># only one point at infinity (empty region)</span>
            <span class="s3"># is allowed</span>
            <span class="s0">assert </span><span class="s1">sublens.count(</span><span class="s2">0</span><span class="s1">) == </span><span class="s2">1</span>
            <span class="s0">assert </span><span class="s1">sublens.index(</span><span class="s2">0</span><span class="s1">) </span><span class="s0">not in </span><span class="s1">pt_region</span>

    <span class="s0">def </span><span class="s1">test_masked_array_fails(self):</span>
        <span class="s1">masked_array = np.ma.masked_all(</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">qhull.Voronoi</span><span class="s0">, </span><span class="s1">masked_array)</span>

    <span class="s0">def </span><span class="s1">test_simple(self):</span>
        <span class="s3"># Simple case with known Voronoi diagram</span>
        <span class="s1">points = [(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">,</span>
                  <span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">,</span>
                  <span class="s1">(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)]</span>

        <span class="s3"># qhull v o Fv Qbb Qc Qz &lt; dat</span>
        <span class="s1">output = </span><span class="s4">&quot;&quot;&quot; 
        2 
        5 10 1 
        -10.101 -10.101 
           0.5    0.5 
           0.5    1.5 
           1.5    0.5 
           1.5    1.5 
        2 0 1 
        3 2 0 1 
        2 0 2 
        3 3 0 1 
        4 1 2 4 3 
        3 4 0 2 
        2 0 3 
        3 4 0 3 
        2 0 4 
        0 
        12 
        4 0 3 0 1 
        4 0 1 0 1 
        4 1 4 1 2 
        4 1 2 0 2 
        4 2 5 0 2 
        4 3 4 1 3 
        4 3 6 0 3 
        4 4 5 2 4 
        4 4 7 3 4 
        4 5 8 0 4 
        4 6 7 0 3 
        4 7 8 0 4 
        &quot;&quot;&quot;</span>
        <span class="s1">self._compare_qvoronoi(points</span><span class="s0">, </span><span class="s1">output)</span>

    <span class="s0">def </span><span class="s1">_compare_qvoronoi(self</span><span class="s0">, </span><span class="s1">points</span><span class="s0">, </span><span class="s1">output</span><span class="s0">, </span><span class="s1">**kw):</span>
        <span class="s5">&quot;&quot;&quot;Compare to output from 'qvoronoi o Fv &lt; data' to Voronoi()&quot;&quot;&quot;</span>

        <span class="s3"># Parse output</span>
        <span class="s1">output = [list(map(float</span><span class="s0">, </span><span class="s1">x.split())) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">output.strip().splitlines()]</span>
        <span class="s1">nvertex = int(output[</span><span class="s2">1</span><span class="s1">][</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">vertices = list(map(tuple</span><span class="s0">, </span><span class="s1">output[</span><span class="s2">3</span><span class="s1">:</span><span class="s2">2</span><span class="s1">+nvertex]))  </span><span class="s3"># exclude inf</span>
        <span class="s1">nregion = int(output[</span><span class="s2">1</span><span class="s1">][</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">regions = [[int(y)-</span><span class="s2">1 </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">x[</span><span class="s2">1</span><span class="s1">:]]</span>
                   <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">output[</span><span class="s2">2</span><span class="s1">+nvertex:</span><span class="s2">2</span><span class="s1">+nvertex+nregion]]</span>
        <span class="s1">ridge_points = [[int(y) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">x[</span><span class="s2">1</span><span class="s1">:</span><span class="s2">3</span><span class="s1">]]</span>
                        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">output[</span><span class="s2">3</span><span class="s1">+nvertex+nregion:]]</span>
        <span class="s1">ridge_vertices = [[int(y)-</span><span class="s2">1 </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">x[</span><span class="s2">3</span><span class="s1">:]]</span>
                          <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">output[</span><span class="s2">3</span><span class="s1">+nvertex+nregion:]]</span>

        <span class="s3"># Compare results</span>
        <span class="s1">vor = qhull.Voronoi(points</span><span class="s0">, </span><span class="s1">**kw)</span>

        <span class="s0">def </span><span class="s1">sorttuple(x):</span>
            <span class="s0">return </span><span class="s1">tuple(sorted(x))</span>

        <span class="s1">assert_allclose(vor.vertices</span><span class="s0">, </span><span class="s1">vertices)</span>
        <span class="s1">assert_equal(set(map(tuple</span><span class="s0">, </span><span class="s1">vor.regions))</span><span class="s0">,</span>
                     <span class="s1">set(map(tuple</span><span class="s0">, </span><span class="s1">regions)))</span>

        <span class="s1">p1 = list(zip(list(map(sorttuple</span><span class="s0">, </span><span class="s1">ridge_points))</span><span class="s0">, </span><span class="s1">list(map(sorttuple</span><span class="s0">, </span><span class="s1">ridge_vertices))))</span>
        <span class="s1">p2 = list(zip(list(map(sorttuple</span><span class="s0">, </span><span class="s1">vor.ridge_points.tolist()))</span><span class="s0">,</span>
                 <span class="s1">list(map(sorttuple</span><span class="s0">, </span><span class="s1">vor.ridge_vertices))))</span>
        <span class="s1">p1.sort()</span>
        <span class="s1">p2.sort()</span>

        <span class="s1">assert_equal(p1</span><span class="s0">, </span><span class="s1">p2)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;name&quot;</span><span class="s0">, </span><span class="s1">sorted(DATASETS))</span>
    <span class="s0">def </span><span class="s1">test_ridges(self</span><span class="s0">, </span><span class="s1">name):</span>
        <span class="s3"># Check that the ridges computed by Voronoi indeed separate</span>
        <span class="s3"># the regions of nearest neighborhood, by comparing the result</span>
        <span class="s3"># to KDTree.</span>

        <span class="s1">points = DATASETS[name]</span>

        <span class="s1">tree = KDTree(points)</span>
        <span class="s1">vor = qhull.Voronoi(points)</span>

        <span class="s0">for </span><span class="s1">p</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">vor.ridge_dict.items():</span>
            <span class="s3"># consider only finite ridges</span>
            <span class="s0">if not </span><span class="s1">np.all(np.asarray(v) &gt;= </span><span class="s2">0</span><span class="s1">):</span>
                <span class="s0">continue</span>

            <span class="s1">ridge_midpoint = vor.vertices[v].mean(axis=</span><span class="s2">0</span><span class="s1">)</span>
            <span class="s1">d = </span><span class="s2">1e-6 </span><span class="s1">* (points[p[</span><span class="s2">0</span><span class="s1">]] - ridge_midpoint)</span>

            <span class="s1">dist</span><span class="s0">, </span><span class="s1">k = tree.query(ridge_midpoint + d</span><span class="s0">, </span><span class="s1">k=</span><span class="s2">1</span><span class="s1">)</span>
            <span class="s1">assert_equal(k</span><span class="s0">, </span><span class="s1">p[</span><span class="s2">0</span><span class="s1">])</span>

            <span class="s1">dist</span><span class="s0">, </span><span class="s1">k = tree.query(ridge_midpoint - d</span><span class="s0">, </span><span class="s1">k=</span><span class="s2">1</span><span class="s1">)</span>
            <span class="s1">assert_equal(k</span><span class="s0">, </span><span class="s1">p[</span><span class="s2">1</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_furthest_site(self):</span>
        <span class="s1">points = [(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1.1</span><span class="s0">, </span><span class="s2">1.1</span><span class="s1">)]</span>

        <span class="s3"># qhull v o Fv Qbb Qc Qu &lt; dat</span>
        <span class="s1">output = </span><span class="s4">&quot;&quot;&quot; 
        2 
        3 5 1 
        -10.101 -10.101 
        0.6000000000000001    0.5 
           0.5 0.6000000000000001 
        3 0 2 1 
        2 0 1 
        2 0 2 
        0 
        3 0 2 1 
        5 
        4 0 2 0 2 
        4 0 4 1 2 
        4 0 1 0 1 
        4 1 4 0 1 
        4 2 4 0 2 
        &quot;&quot;&quot;</span>
        <span class="s1">self._compare_qvoronoi(points</span><span class="s0">, </span><span class="s1">output</span><span class="s0">, </span><span class="s1">furthest_site=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_furthest_site_flag(self):</span>
        <span class="s1">points = [(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1.1</span><span class="s0">, </span><span class="s2">1.1</span><span class="s1">)]</span>

        <span class="s1">vor = Voronoi(points)</span>
        <span class="s1">assert_equal(vor.furthest_site</span><span class="s0">,False</span><span class="s1">)</span>
        <span class="s1">vor = Voronoi(points</span><span class="s0">,</span><span class="s1">furthest_site=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">assert_equal(vor.furthest_site</span><span class="s0">,True</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;name&quot;</span><span class="s0">, </span><span class="s1">sorted(INCREMENTAL_DATASETS))</span>
    <span class="s0">def </span><span class="s1">test_incremental(self</span><span class="s0">, </span><span class="s1">name):</span>
        <span class="s3"># Test incremental construction of the triangulation</span>

        <span class="s0">if </span><span class="s1">INCREMENTAL_DATASETS[name][</span><span class="s2">0</span><span class="s1">][</span><span class="s2">0</span><span class="s1">].shape[</span><span class="s2">1</span><span class="s1">] &gt; </span><span class="s2">3</span><span class="s1">:</span>
            <span class="s3"># too slow (testing of the result --- qhull is still fast)</span>
            <span class="s0">return</span>

        <span class="s1">chunks</span><span class="s0">, </span><span class="s1">opts = INCREMENTAL_DATASETS[name]</span>
        <span class="s1">points = np.concatenate(chunks</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">)</span>

        <span class="s1">obj = qhull.Voronoi(chunks[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">incremental=</span><span class="s0">True,</span>
                             <span class="s1">qhull_options=opts)</span>
        <span class="s0">for </span><span class="s1">chunk </span><span class="s0">in </span><span class="s1">chunks[</span><span class="s2">1</span><span class="s1">:]:</span>
            <span class="s1">obj.add_points(chunk)</span>

        <span class="s1">obj2 = qhull.Voronoi(points)</span>

        <span class="s1">obj3 = qhull.Voronoi(chunks[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">incremental=</span><span class="s0">True,</span>
                             <span class="s1">qhull_options=opts)</span>
        <span class="s0">if </span><span class="s1">len(chunks) &gt; </span><span class="s2">1</span><span class="s1">:</span>
            <span class="s1">obj3.add_points(np.concatenate(chunks[</span><span class="s2">1</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">)</span><span class="s0">,</span>
                            <span class="s1">restart=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s3"># -- Check that the incremental mode agrees with upfront mode</span>
        <span class="s1">assert_equal(len(obj.point_region)</span><span class="s0">, </span><span class="s1">len(obj2.point_region))</span>
        <span class="s1">assert_equal(len(obj.point_region)</span><span class="s0">, </span><span class="s1">len(obj3.point_region))</span>

        <span class="s3"># The vertices may be in different order or duplicated in</span>
        <span class="s3"># the incremental map</span>
        <span class="s0">for </span><span class="s1">objx </span><span class="s0">in </span><span class="s1">obj</span><span class="s0">, </span><span class="s1">obj3:</span>
            <span class="s1">vertex_map = {-</span><span class="s2">1</span><span class="s1">: -</span><span class="s2">1</span><span class="s1">}</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">enumerate(objx.vertices):</span>
                <span class="s0">for </span><span class="s1">j</span><span class="s0">, </span><span class="s1">v2 </span><span class="s0">in </span><span class="s1">enumerate(obj2.vertices):</span>
                    <span class="s0">if </span><span class="s1">np.allclose(v</span><span class="s0">, </span><span class="s1">v2):</span>
                        <span class="s1">vertex_map[i] = j</span>

            <span class="s0">def </span><span class="s1">remap(x):</span>
                <span class="s0">if </span><span class="s1">hasattr(x</span><span class="s0">, </span><span class="s4">'__len__'</span><span class="s1">):</span>
                    <span class="s0">return </span><span class="s1">tuple({remap(y) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">x})</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s1">vertex_map[x]</span>
                <span class="s0">except </span><span class="s1">KeyError </span><span class="s0">as </span><span class="s1">e:</span>
                    <span class="s0">raise </span><span class="s1">AssertionError(</span><span class="s4">&quot;incremental result has spurious vertex at %r&quot;</span>
                                         <span class="s1">% (objx.vertices[x]</span><span class="s0">,</span><span class="s1">)) </span><span class="s0">from </span><span class="s1">e</span>

            <span class="s0">def </span><span class="s1">simplified(x):</span>
                <span class="s1">items = set(map(sorted_tuple</span><span class="s0">, </span><span class="s1">x))</span>
                <span class="s0">if </span><span class="s1">() </span><span class="s0">in </span><span class="s1">items:</span>
                    <span class="s1">items.remove(())</span>
                <span class="s1">items = [x </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">items </span><span class="s0">if </span><span class="s1">len(x) &gt; </span><span class="s2">1</span><span class="s1">]</span>
                <span class="s1">items.sort()</span>
                <span class="s0">return </span><span class="s1">items</span>

            <span class="s1">assert_equal(</span>
                <span class="s1">simplified(remap(objx.regions))</span><span class="s0">,</span>
                <span class="s1">simplified(obj2.regions)</span>
                <span class="s1">)</span>
            <span class="s1">assert_equal(</span>
                <span class="s1">simplified(remap(objx.ridge_vertices))</span><span class="s0">,</span>
                <span class="s1">simplified(obj2.ridge_vertices)</span>
                <span class="s1">)</span>

            <span class="s3"># XXX: compare ridge_points --- not clear exactly how to do this</span>


<span class="s0">class </span><span class="s1">Test_HalfspaceIntersection:</span>
    <span class="s0">def </span><span class="s1">assert_unordered_allclose(self</span><span class="s0">, </span><span class="s1">arr1</span><span class="s0">, </span><span class="s1">arr2</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-7</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Check that every line in arr1 is only once in arr2&quot;&quot;&quot;</span>
        <span class="s1">assert_equal(arr1.shape</span><span class="s0">, </span><span class="s1">arr2.shape)</span>

        <span class="s1">truths = np.zeros((arr1.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
        <span class="s0">for </span><span class="s1">l1 </span><span class="s0">in </span><span class="s1">arr1:</span>
            <span class="s1">indexes = np.nonzero((abs(arr2 - l1) &lt; rtol).all(axis=</span><span class="s2">1</span><span class="s1">))[</span><span class="s2">0</span><span class="s1">]</span>
            <span class="s1">assert_equal(indexes.shape</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">,</span><span class="s1">))</span>
            <span class="s1">truths[indexes[</span><span class="s2">0</span><span class="s1">]] = </span><span class="s0">True</span>
        <span class="s1">assert_(truths.all())</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;dt&quot;</span><span class="s0">, </span><span class="s1">[np.float64</span><span class="s0">, </span><span class="s1">int])</span>
    <span class="s0">def </span><span class="s1">test_cube_halfspace_intersection(self</span><span class="s0">, </span><span class="s1">dt):</span>
        <span class="s1">halfspaces = np.array([[-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
                               <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
                               <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
                               <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
        <span class="s1">feasible_point = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dt)</span>

        <span class="s1">points = np.array([[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s1">]])</span>

        <span class="s1">hull = qhull.HalfspaceIntersection(halfspaces</span><span class="s0">, </span><span class="s1">feasible_point)</span>

        <span class="s1">assert_allclose(hull.intersections</span><span class="s0">, </span><span class="s1">points)</span>

    <span class="s0">def </span><span class="s1">test_self_dual_polytope_intersection(self):</span>
        <span class="s1">fname = os.path.join(os.path.dirname(__file__)</span><span class="s0">, </span><span class="s4">'data'</span><span class="s0">,</span>
                             <span class="s4">'selfdual-4d-polytope.txt'</span><span class="s1">)</span>
        <span class="s1">ineqs = np.genfromtxt(fname)</span>
        <span class="s1">halfspaces = -np.hstack((ineqs[:</span><span class="s0">, </span><span class="s2">1</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">ineqs[:</span><span class="s0">, </span><span class="s1">:</span><span class="s2">1</span><span class="s1">]))</span>

        <span class="s1">feas_point = np.array([</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s2">0.</span><span class="s1">])</span>
        <span class="s1">hs = qhull.HalfspaceIntersection(halfspaces</span><span class="s0">, </span><span class="s1">feas_point)</span>

        <span class="s1">assert_equal(hs.intersections.shape</span><span class="s0">, </span><span class="s1">(</span><span class="s2">24</span><span class="s0">, </span><span class="s2">4</span><span class="s1">))</span>

        <span class="s1">assert_almost_equal(hs.dual_volume</span><span class="s0">, </span><span class="s2">32.0</span><span class="s1">)</span>
        <span class="s1">assert_equal(len(hs.dual_facets)</span><span class="s0">, </span><span class="s2">24</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">facet </span><span class="s0">in </span><span class="s1">hs.dual_facets:</span>
            <span class="s1">assert_equal(len(facet)</span><span class="s0">, </span><span class="s2">6</span><span class="s1">)</span>

        <span class="s1">dists = halfspaces[:</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">] + halfspaces[:</span><span class="s0">, </span><span class="s1">:-</span><span class="s2">1</span><span class="s1">].dot(feas_point)</span>
        <span class="s1">self.assert_unordered_allclose((halfspaces[:</span><span class="s0">, </span><span class="s1">:-</span><span class="s2">1</span><span class="s1">].T/dists).T</span><span class="s0">, </span><span class="s1">hs.dual_points)</span>

        <span class="s1">points = itertools.permutations([</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.5</span><span class="s1">])</span>
        <span class="s0">for </span><span class="s1">point </span><span class="s0">in </span><span class="s1">points:</span>
            <span class="s1">assert_equal(np.sum((hs.intersections == point).all(axis=</span><span class="s2">1</span><span class="s1">))</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_wrong_feasible_point(self):</span>
        <span class="s1">halfspaces = np.array([[-</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">,</span>
                               <span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">,</span>
                               <span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">,</span>
                               <span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.0</span><span class="s1">]])</span>
        <span class="s1">feasible_point = np.array([</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">])</span>
        <span class="s3">#Feasible point is (ndim,) instead of (ndim-1,)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">qhull.HalfspaceIntersection</span><span class="s0">, </span><span class="s1">halfspaces</span><span class="s0">, </span><span class="s1">feasible_point)</span>
        <span class="s1">feasible_point = np.array([[</span><span class="s2">0.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.5</span><span class="s1">]])</span>
        <span class="s3">#Feasible point is (ndim-1, 1) instead of (ndim-1,)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">qhull.HalfspaceIntersection</span><span class="s0">, </span><span class="s1">halfspaces</span><span class="s0">, </span><span class="s1">feasible_point)</span>
        <span class="s1">feasible_point = np.array([[</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">]])</span>
        <span class="s3">#Feasible point is (1, ndim-1) instead of (ndim-1,)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">qhull.HalfspaceIntersection</span><span class="s0">, </span><span class="s1">halfspaces</span><span class="s0">, </span><span class="s1">feasible_point)</span>

        <span class="s1">feasible_point = np.array([-</span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.5</span><span class="s1">])</span>
        <span class="s3">#Feasible point is outside feasible region</span>
        <span class="s1">assert_raises(qhull.QhullError</span><span class="s0">, </span><span class="s1">qhull.HalfspaceIntersection</span><span class="s0">, </span><span class="s1">halfspaces</span><span class="s0">, </span><span class="s1">feasible_point)</span>

    <span class="s0">def </span><span class="s1">test_incremental(self):</span>
        <span class="s3">#Cube</span>
        <span class="s1">halfspaces = np.array([[</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.5</span><span class="s1">]</span><span class="s0">,</span>
                               <span class="s1">[</span><span class="s2">0.</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.5</span><span class="s1">]</span><span class="s0">,</span>
                               <span class="s1">[-</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.5</span><span class="s1">]</span><span class="s0">,</span>
                               <span class="s1">[</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.5</span><span class="s1">]</span><span class="s0">,</span>
                               <span class="s1">[</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.5</span><span class="s1">]</span><span class="s0">,</span>
                               <span class="s1">[</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.5</span><span class="s1">]])</span>
        <span class="s3">#Cut each summit</span>
        <span class="s1">extra_normals = np.array([[</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s2">1.</span><span class="s1">]</span><span class="s0">,</span>
                                  <span class="s1">[</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.</span><span class="s1">]</span><span class="s0">,</span>
                                  <span class="s1">[</span><span class="s2">1.</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">1.</span><span class="s1">]</span><span class="s0">,</span>
                                  <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.</span><span class="s1">]])</span>
        <span class="s1">offsets = np.array([[-</span><span class="s2">1.</span><span class="s1">]]*</span><span class="s2">8</span><span class="s1">)</span>
        <span class="s1">extra_halfspaces = np.hstack((np.vstack((extra_normals</span><span class="s0">, </span><span class="s1">-extra_normals))</span><span class="s0">,</span>
                                      <span class="s1">offsets))</span>

        <span class="s1">feas_point = np.array([</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s2">0.</span><span class="s1">])</span>

        <span class="s1">inc_hs = qhull.HalfspaceIntersection(halfspaces</span><span class="s0">, </span><span class="s1">feas_point</span><span class="s0">, </span><span class="s1">incremental=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s1">inc_res_hs = qhull.HalfspaceIntersection(halfspaces</span><span class="s0">, </span><span class="s1">feas_point</span><span class="s0">, </span><span class="s1">incremental=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">ehs </span><span class="s0">in </span><span class="s1">enumerate(extra_halfspaces):</span>
            <span class="s1">inc_hs.add_halfspaces(ehs[np.newaxis</span><span class="s0">, </span><span class="s1">:])</span>

            <span class="s1">inc_res_hs.add_halfspaces(ehs[np.newaxis</span><span class="s0">, </span><span class="s1">:]</span><span class="s0">, </span><span class="s1">restart=</span><span class="s0">True</span><span class="s1">)</span>

            <span class="s1">total = np.vstack((halfspaces</span><span class="s0">, </span><span class="s1">extra_halfspaces[:i+</span><span class="s2">1</span><span class="s0">, </span><span class="s1">:]))</span>

            <span class="s1">hs = qhull.HalfspaceIntersection(total</span><span class="s0">, </span><span class="s1">feas_point)</span>

            <span class="s1">assert_allclose(inc_hs.halfspaces</span><span class="s0">, </span><span class="s1">inc_res_hs.halfspaces)</span>
            <span class="s1">assert_allclose(inc_hs.halfspaces</span><span class="s0">, </span><span class="s1">hs.halfspaces)</span>

            <span class="s3">#Direct computation and restart should have points in same order</span>
            <span class="s1">assert_allclose(hs.intersections</span><span class="s0">, </span><span class="s1">inc_res_hs.intersections)</span>
            <span class="s3">#Incremental will have points in different order than direct computation</span>
            <span class="s1">self.assert_unordered_allclose(inc_hs.intersections</span><span class="s0">, </span><span class="s1">hs.intersections)</span>

        <span class="s1">inc_hs.close()</span>

    <span class="s0">def </span><span class="s1">test_cube(self):</span>
        <span class="s3"># Halfspaces of the cube:</span>
        <span class="s1">halfspaces = np.array([[-</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s2">0.</span><span class="s1">]</span><span class="s0">,  </span><span class="s3"># x &gt;= 0</span>
                               <span class="s1">[</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.</span><span class="s1">]</span><span class="s0">,  </span><span class="s3"># x &lt;= 1</span>
                               <span class="s1">[</span><span class="s2">0.</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s2">0.</span><span class="s1">]</span><span class="s0">,  </span><span class="s3"># y &gt;= 0</span>
                               <span class="s1">[</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.</span><span class="s1">]</span><span class="s0">,  </span><span class="s3"># y &lt;= 1</span>
                               <span class="s1">[</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">0.</span><span class="s1">]</span><span class="s0">,  </span><span class="s3"># z &gt;= 0</span>
                               <span class="s1">[</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.</span><span class="s1">]])  </span><span class="s3"># z &lt;= 1</span>
        <span class="s1">point = np.array([</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">])</span>

        <span class="s1">hs = qhull.HalfspaceIntersection(halfspaces</span><span class="s0">, </span><span class="s1">point)</span>

        <span class="s3"># qhalf H0.5,0.5,0.5 o &lt; input.txt</span>
        <span class="s1">qhalf_points = np.array([</span>
            <span class="s1">[-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]])</span>
        <span class="s1">qhalf_facets = [</span>
            <span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">5</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">5</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]]</span>

        <span class="s0">assert </span><span class="s1">len(qhalf_facets) == len(hs.dual_facets)</span>
        <span class="s0">for </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b </span><span class="s0">in </span><span class="s1">zip(qhalf_facets</span><span class="s0">, </span><span class="s1">hs.dual_facets):</span>
            <span class="s0">assert </span><span class="s1">set(a) == set(b)  </span><span class="s3"># facet orientation can differ</span>

        <span class="s1">assert_allclose(hs.dual_points</span><span class="s0">, </span><span class="s1">qhalf_points)</span>
</pre>
</body>
</html>