<html>
<head>
<title>_ode.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6a8759;}
.s4 { color: #cc7832;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_ode.py</font>
</center></td></tr></table>
<pre><span class="s0"># Authors: Pearu Peterson, Pauli Virtanen, John Travers</span>
<span class="s2">&quot;&quot;&quot; 
First-order ODE integrators. 
 
User-friendly interface to various numerical integrators for solving a 
system of first order ODEs with prescribed initial conditions:: 
 
    d y(t)[i] 
    ---------  = f(t,y(t))[i], 
       d t 
 
    y(t=0)[i] = y0[i], 
 
where:: 
 
    i = 0, ..., len(y0) - 1 
 
class ode 
--------- 
 
A generic interface class to numeric integrators. It has the following 
methods:: 
 
    integrator = ode(f, jac=None) 
    integrator = integrator.set_integrator(name, **params) 
    integrator = integrator.set_initial_value(y0, t0=0.0) 
    integrator = integrator.set_f_params(*args) 
    integrator = integrator.set_jac_params(*args) 
    y1 = integrator.integrate(t1, step=False, relax=False) 
    flag = integrator.successful() 
 
class complex_ode 
----------------- 
 
This class has the same generic interface as ode, except it can handle complex 
f, y and Jacobians by transparently translating them into the equivalent 
real-valued system. It supports the real-valued solvers (i.e., not zvode) and is 
an alternative to ode with the zvode solver, sometimes performing better. 
&quot;&quot;&quot;</span>
<span class="s0"># XXX: Integrators must have:</span>
<span class="s0"># ===========================</span>
<span class="s0"># cvode - C version of vode and vodpk with many improvements.</span>
<span class="s0">#   Get it from http://www.netlib.org/ode/cvode.tar.gz.</span>
<span class="s0">#   To wrap cvode to Python, one must write the extension module by</span>
<span class="s0">#   hand. Its interface is too much 'advanced C' that using f2py</span>
<span class="s0">#   would be too complicated (or impossible).</span>
<span class="s0">#</span>
<span class="s0"># How to define a new integrator:</span>
<span class="s0"># ===============================</span>
<span class="s0">#</span>
<span class="s0"># class myodeint(IntegratorBase):</span>
<span class="s0">#</span>
<span class="s0">#     runner = &lt;odeint function&gt; or None</span>
<span class="s0">#</span>
<span class="s0">#     def __init__(self,...):                           # required</span>
<span class="s0">#         &lt;initialize&gt;</span>
<span class="s0">#</span>
<span class="s0">#     def reset(self,n,has_jac):                        # optional</span>
<span class="s0">#         # n - the size of the problem (number of equations)</span>
<span class="s0">#         # has_jac - whether user has supplied its own routine for Jacobian</span>
<span class="s0">#         &lt;allocate memory,initialize further&gt;</span>
<span class="s0">#</span>
<span class="s0">#     def run(self,f,jac,y0,t0,t1,f_params,jac_params): # required</span>
<span class="s0">#         # this method is called to integrate from t=t0 to t=t1</span>
<span class="s0">#         # with initial condition y0. f and jac are user-supplied functions</span>
<span class="s0">#         # that define the problem. f_params,jac_params are additional</span>
<span class="s0">#         # arguments</span>
<span class="s0">#         # to these functions.</span>
<span class="s0">#         &lt;calculate y1&gt;</span>
<span class="s0">#         if &lt;calculation was unsuccessful&gt;:</span>
<span class="s0">#             self.success = 0</span>
<span class="s0">#         return t1,y1</span>
<span class="s0">#</span>
<span class="s0">#     # In addition, one can define step() and run_relax() methods (they</span>
<span class="s0">#     # take the same arguments as run()) if the integrator can support</span>
<span class="s0">#     # these features (see IntegratorBase doc strings).</span>
<span class="s0">#</span>
<span class="s0"># if myodeint.runner:</span>
<span class="s0">#     IntegratorBase.integrator_classes.append(myodeint)</span>

<span class="s1">__all__ = [</span><span class="s3">'ode'</span><span class="s4">, </span><span class="s3">'complex_ode'</span><span class="s1">]</span>

<span class="s4">import </span><span class="s1">re</span>
<span class="s4">import </span><span class="s1">warnings</span>

<span class="s4">from </span><span class="s1">numpy </span><span class="s4">import </span><span class="s1">asarray</span><span class="s4">, </span><span class="s1">array</span><span class="s4">, </span><span class="s1">zeros</span><span class="s4">, </span><span class="s1">isscalar</span><span class="s4">, </span><span class="s1">real</span><span class="s4">, </span><span class="s1">imag</span><span class="s4">, </span><span class="s1">vstack</span>

<span class="s4">from </span><span class="s1">. </span><span class="s4">import </span><span class="s1">_vode</span>
<span class="s4">from </span><span class="s1">. </span><span class="s4">import </span><span class="s1">_dop</span>
<span class="s4">from </span><span class="s1">. </span><span class="s4">import </span><span class="s1">_lsoda</span>


<span class="s1">_dop_int_dtype = _dop.types.intvar.dtype</span>
<span class="s1">_vode_int_dtype = _vode.types.intvar.dtype</span>
<span class="s1">_lsoda_int_dtype = _lsoda.types.intvar.dtype</span>


<span class="s0"># ------------------------------------------------------------------------------</span>
<span class="s0"># User interface</span>
<span class="s0"># ------------------------------------------------------------------------------</span>


<span class="s4">class </span><span class="s1">ode:</span>
    <span class="s2">&quot;&quot;&quot; 
    A generic interface class to numeric integrators. 
 
    Solve an equation system :math:`y'(t) = f(t,y)` with (optional) ``jac = df/dy``. 
 
    *Note*: The first two arguments of ``f(t, y, ...)`` are in the 
    opposite order of the arguments in the system definition function used 
    by `scipy.integrate.odeint`. 
 
    Parameters 
    ---------- 
    f : callable ``f(t, y, *f_args)`` 
        Right-hand side of the differential equation. t is a scalar, 
        ``y.shape == (n,)``. 
        ``f_args`` is set by calling ``set_f_params(*args)``. 
        `f` should return a scalar, array or list (not a tuple). 
    jac : callable ``jac(t, y, *jac_args)``, optional 
        Jacobian of the right-hand side, ``jac[i,j] = d f[i] / d y[j]``. 
        ``jac_args`` is set by calling ``set_jac_params(*args)``. 
 
    Attributes 
    ---------- 
    t : float 
        Current time. 
    y : ndarray 
        Current variable values. 
 
    See also 
    -------- 
    odeint : an integrator with a simpler interface based on lsoda from ODEPACK 
    quad : for finding the area under a curve 
 
    Notes 
    ----- 
    Available integrators are listed below. They can be selected using 
    the `set_integrator` method. 
 
    &quot;vode&quot; 
 
        Real-valued Variable-coefficient Ordinary Differential Equation 
        solver, with fixed-leading-coefficient implementation. It provides 
        implicit Adams method (for non-stiff problems) and a method based on 
        backward differentiation formulas (BDF) (for stiff problems). 
 
        Source: http://www.netlib.org/ode/vode.f 
 
        .. warning:: 
 
           This integrator is not re-entrant. You cannot have two `ode` 
           instances using the &quot;vode&quot; integrator at the same time. 
 
        This integrator accepts the following parameters in `set_integrator` 
        method of the `ode` class: 
 
        - atol : float or sequence 
          absolute tolerance for solution 
        - rtol : float or sequence 
          relative tolerance for solution 
        - lband : None or int 
        - uband : None or int 
          Jacobian band width, jac[i,j] != 0 for i-lband &lt;= j &lt;= i+uband. 
          Setting these requires your jac routine to return the jacobian 
          in packed format, jac_packed[i-j+uband, j] = jac[i,j]. The 
          dimension of the matrix must be (lband+uband+1, len(y)). 
        - method: 'adams' or 'bdf' 
          Which solver to use, Adams (non-stiff) or BDF (stiff) 
        - with_jacobian : bool 
          This option is only considered when the user has not supplied a 
          Jacobian function and has not indicated (by setting either band) 
          that the Jacobian is banded. In this case, `with_jacobian` specifies 
          whether the iteration method of the ODE solver's correction step is 
          chord iteration with an internally generated full Jacobian or 
          functional iteration with no Jacobian. 
        - nsteps : int 
          Maximum number of (internally defined) steps allowed during one 
          call to the solver. 
        - first_step : float 
        - min_step : float 
        - max_step : float 
          Limits for the step sizes used by the integrator. 
        - order : int 
          Maximum order used by the integrator, 
          order &lt;= 12 for Adams, &lt;= 5 for BDF. 
 
    &quot;zvode&quot; 
 
        Complex-valued Variable-coefficient Ordinary Differential Equation 
        solver, with fixed-leading-coefficient implementation. It provides 
        implicit Adams method (for non-stiff problems) and a method based on 
        backward differentiation formulas (BDF) (for stiff problems). 
 
        Source: http://www.netlib.org/ode/zvode.f 
 
        .. warning:: 
 
           This integrator is not re-entrant. You cannot have two `ode` 
           instances using the &quot;zvode&quot; integrator at the same time. 
 
        This integrator accepts the same parameters in `set_integrator` 
        as the &quot;vode&quot; solver. 
 
        .. note:: 
 
            When using ZVODE for a stiff system, it should only be used for 
            the case in which the function f is analytic, that is, when each f(i) 
            is an analytic function of each y(j). Analyticity means that the 
            partial derivative df(i)/dy(j) is a unique complex number, and this 
            fact is critical in the way ZVODE solves the dense or banded linear 
            systems that arise in the stiff case. For a complex stiff ODE system 
            in which f is not analytic, ZVODE is likely to have convergence 
            failures, and for this problem one should instead use DVODE on the 
            equivalent real system (in the real and imaginary parts of y). 
 
    &quot;lsoda&quot; 
 
        Real-valued Variable-coefficient Ordinary Differential Equation 
        solver, with fixed-leading-coefficient implementation. It provides 
        automatic method switching between implicit Adams method (for non-stiff 
        problems) and a method based on backward differentiation formulas (BDF) 
        (for stiff problems). 
 
        Source: http://www.netlib.org/odepack 
 
        .. warning:: 
 
           This integrator is not re-entrant. You cannot have two `ode` 
           instances using the &quot;lsoda&quot; integrator at the same time. 
 
        This integrator accepts the following parameters in `set_integrator` 
        method of the `ode` class: 
 
        - atol : float or sequence 
          absolute tolerance for solution 
        - rtol : float or sequence 
          relative tolerance for solution 
        - lband : None or int 
        - uband : None or int 
          Jacobian band width, jac[i,j] != 0 for i-lband &lt;= j &lt;= i+uband. 
          Setting these requires your jac routine to return the jacobian 
          in packed format, jac_packed[i-j+uband, j] = jac[i,j]. 
        - with_jacobian : bool 
          *Not used.* 
        - nsteps : int 
          Maximum number of (internally defined) steps allowed during one 
          call to the solver. 
        - first_step : float 
        - min_step : float 
        - max_step : float 
          Limits for the step sizes used by the integrator. 
        - max_order_ns : int 
          Maximum order used in the nonstiff case (default 12). 
        - max_order_s : int 
          Maximum order used in the stiff case (default 5). 
        - max_hnil : int 
          Maximum number of messages reporting too small step size (t + h = t) 
          (default 0) 
        - ixpr : int 
          Whether to generate extra printing at method switches (default False). 
 
    &quot;dopri5&quot; 
 
        This is an explicit runge-kutta method of order (4)5 due to Dormand &amp; 
        Prince (with stepsize control and dense output). 
 
        Authors: 
 
            E. Hairer and G. Wanner 
            Universite de Geneve, Dept. de Mathematiques 
            CH-1211 Geneve 24, Switzerland 
            e-mail:  ernst.hairer@math.unige.ch, gerhard.wanner@math.unige.ch 
 
        This code is described in [HNW93]_. 
 
        This integrator accepts the following parameters in set_integrator() 
        method of the ode class: 
 
        - atol : float or sequence 
          absolute tolerance for solution 
        - rtol : float or sequence 
          relative tolerance for solution 
        - nsteps : int 
          Maximum number of (internally defined) steps allowed during one 
          call to the solver. 
        - first_step : float 
        - max_step : float 
        - safety : float 
          Safety factor on new step selection (default 0.9) 
        - ifactor : float 
        - dfactor : float 
          Maximum factor to increase/decrease step size by in one step 
        - beta : float 
          Beta parameter for stabilised step size control. 
        - verbosity : int 
          Switch for printing messages (&lt; 0 for no messages). 
 
    &quot;dop853&quot; 
 
        This is an explicit runge-kutta method of order 8(5,3) due to Dormand 
        &amp; Prince (with stepsize control and dense output). 
 
        Options and references the same as &quot;dopri5&quot;. 
 
    Examples 
    -------- 
 
    A problem to integrate and the corresponding jacobian: 
 
    &gt;&gt;&gt; from scipy.integrate import ode 
    &gt;&gt;&gt; 
    &gt;&gt;&gt; y0, t0 = [1.0j, 2.0], 0 
    &gt;&gt;&gt; 
    &gt;&gt;&gt; def f(t, y, arg1): 
    ...     return [1j*arg1*y[0] + y[1], -arg1*y[1]**2] 
    &gt;&gt;&gt; def jac(t, y, arg1): 
    ...     return [[1j*arg1, 1], [0, -arg1*2*y[1]]] 
 
    The integration: 
 
    &gt;&gt;&gt; r = ode(f, jac).set_integrator('zvode', method='bdf') 
    &gt;&gt;&gt; r.set_initial_value(y0, t0).set_f_params(2.0).set_jac_params(2.0) 
    &gt;&gt;&gt; t1 = 10 
    &gt;&gt;&gt; dt = 1 
    &gt;&gt;&gt; while r.successful() and r.t &lt; t1: 
    ...     print(r.t+dt, r.integrate(r.t+dt)) 
    1 [-0.71038232+0.23749653j  0.40000271+0.j        ] 
    2.0 [0.19098503-0.52359246j 0.22222356+0.j        ] 
    3.0 [0.47153208+0.52701229j 0.15384681+0.j        ] 
    4.0 [-0.61905937+0.30726255j  0.11764744+0.j        ] 
    5.0 [0.02340997-0.61418799j 0.09523835+0.j        ] 
    6.0 [0.58643071+0.339819j 0.08000018+0.j      ] 
    7.0 [-0.52070105+0.44525141j  0.06896565+0.j        ] 
    8.0 [-0.15986733-0.61234476j  0.06060616+0.j        ] 
    9.0 [0.64850462+0.15048982j 0.05405414+0.j        ] 
    10.0 [-0.38404699+0.56382299j  0.04878055+0.j        ] 
 
    References 
    ---------- 
    .. [HNW93] E. Hairer, S.P. Norsett and G. Wanner, Solving Ordinary 
        Differential Equations i. Nonstiff Problems. 2nd edition. 
        Springer Series in Computational Mathematics, 
        Springer-Verlag (1993) 
 
    &quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">f</span><span class="s4">, </span><span class="s1">jac=</span><span class="s4">None</span><span class="s1">):</span>
        <span class="s1">self.stiff = </span><span class="s5">0</span>
        <span class="s1">self.f = f</span>
        <span class="s1">self.jac = jac</span>
        <span class="s1">self.f_params = ()</span>
        <span class="s1">self.jac_params = ()</span>
        <span class="s1">self._y = []</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">y(self):</span>
        <span class="s4">return </span><span class="s1">self._y</span>

    <span class="s4">def </span><span class="s1">set_initial_value(self</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">t=</span><span class="s5">0.0</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Set initial conditions y(t) = y.&quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">isscalar(y):</span>
            <span class="s1">y = [y]</span>
        <span class="s1">n_prev = len(self._y)</span>
        <span class="s4">if not </span><span class="s1">n_prev:</span>
            <span class="s1">self.set_integrator(</span><span class="s3">''</span><span class="s1">)  </span><span class="s0"># find first available integrator</span>
        <span class="s1">self._y = asarray(y</span><span class="s4">, </span><span class="s1">self._integrator.scalar)</span>
        <span class="s1">self.t = t</span>
        <span class="s1">self._integrator.reset(len(self._y)</span><span class="s4">, </span><span class="s1">self.jac </span><span class="s4">is not None</span><span class="s1">)</span>
        <span class="s4">return </span><span class="s1">self</span>

    <span class="s4">def </span><span class="s1">set_integrator(self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">**integrator_params):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set integrator by name. 
 
        Parameters 
        ---------- 
        name : str 
            Name of the integrator. 
        **integrator_params 
            Additional parameters for the integrator. 
        &quot;&quot;&quot;</span>
        <span class="s1">integrator = find_integrator(name)</span>
        <span class="s4">if </span><span class="s1">integrator </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s0"># FIXME: this really should be raise an exception. Will that break</span>
            <span class="s0"># any code?</span>
            <span class="s1">warnings.warn(</span><span class="s3">'No integrator name match with %r or is not '</span>
                          <span class="s3">'available.' </span><span class="s1">% name)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">self._integrator = integrator(**integrator_params)</span>
            <span class="s4">if not </span><span class="s1">len(self._y):</span>
                <span class="s1">self.t = </span><span class="s5">0.0</span>
                <span class="s1">self._y = array([</span><span class="s5">0.0</span><span class="s1">]</span><span class="s4">, </span><span class="s1">self._integrator.scalar)</span>
            <span class="s1">self._integrator.reset(len(self._y)</span><span class="s4">, </span><span class="s1">self.jac </span><span class="s4">is not None</span><span class="s1">)</span>
        <span class="s4">return </span><span class="s1">self</span>

    <span class="s4">def </span><span class="s1">integrate(self</span><span class="s4">, </span><span class="s1">t</span><span class="s4">, </span><span class="s1">step=</span><span class="s4">False, </span><span class="s1">relax=</span><span class="s4">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Find y=y(t), set y as an initial condition, and return y. 
 
        Parameters 
        ---------- 
        t : float 
            The endpoint of the integration step. 
        step : bool 
            If True, and if the integrator supports the step method, 
            then perform a single integration step and return. 
            This parameter is provided in order to expose internals of 
            the implementation, and should not be changed from its default 
            value in most cases. 
        relax : bool 
            If True and if the integrator supports the run_relax method, 
            then integrate until t_1 &gt;= t and return. ``relax`` is not 
            referenced if ``step=True``. 
            This parameter is provided in order to expose internals of 
            the implementation, and should not be changed from its default 
            value in most cases. 
 
        Returns 
        ------- 
        y : float 
            The integrated value at t 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">step </span><span class="s4">and </span><span class="s1">self._integrator.supports_step:</span>
            <span class="s1">mth = self._integrator.step</span>
        <span class="s4">elif </span><span class="s1">relax </span><span class="s4">and </span><span class="s1">self._integrator.supports_run_relax:</span>
            <span class="s1">mth = self._integrator.run_relax</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">mth = self._integrator.run</span>

        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">self._y</span><span class="s4">, </span><span class="s1">self.t = mth(self.f</span><span class="s4">, </span><span class="s1">self.jac </span><span class="s4">or </span><span class="s1">(</span><span class="s4">lambda</span><span class="s1">: </span><span class="s4">None</span><span class="s1">)</span><span class="s4">,</span>
                                  <span class="s1">self._y</span><span class="s4">, </span><span class="s1">self.t</span><span class="s4">, </span><span class="s1">t</span><span class="s4">,</span>
                                  <span class="s1">self.f_params</span><span class="s4">, </span><span class="s1">self.jac_params)</span>
        <span class="s4">except </span><span class="s1">SystemError </span><span class="s4">as </span><span class="s1">e:</span>
            <span class="s0"># f2py issue with tuple returns, see ticket 1187.</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span>
                <span class="s3">'Function to integrate must not return a tuple.'</span>
            <span class="s1">) </span><span class="s4">from </span><span class="s1">e</span>

        <span class="s4">return </span><span class="s1">self._y</span>

    <span class="s4">def </span><span class="s1">successful(self):</span>
        <span class="s2">&quot;&quot;&quot;Check if integration was successful.&quot;&quot;&quot;</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">self._integrator</span>
        <span class="s4">except </span><span class="s1">AttributeError:</span>
            <span class="s1">self.set_integrator(</span><span class="s3">''</span><span class="s1">)</span>
        <span class="s4">return </span><span class="s1">self._integrator.success == </span><span class="s5">1</span>

    <span class="s4">def </span><span class="s1">get_return_code(self):</span>
        <span class="s2">&quot;&quot;&quot;Extracts the return code for the integration to enable better control 
        if the integration fails. 
 
        In general, a return code &gt; 0 implies success, while a return code &lt; 0 
        implies failure. 
 
        Notes 
        ----- 
        This section describes possible return codes and their meaning, for available 
        integrators that can be selected by `set_integrator` method. 
 
        &quot;vode&quot; 
 
        ===========  ======= 
        Return Code  Message 
        ===========  ======= 
        2            Integration successful. 
        -1           Excess work done on this call. (Perhaps wrong MF.) 
        -2           Excess accuracy requested. (Tolerances too small.) 
        -3           Illegal input detected. (See printed message.) 
        -4           Repeated error test failures. (Check all input.) 
        -5           Repeated convergence failures. (Perhaps bad Jacobian 
                     supplied or wrong choice of MF or tolerances.) 
        -6           Error weight became zero during problem. (Solution 
                     component i vanished, and ATOL or ATOL(i) = 0.) 
        ===========  ======= 
 
        &quot;zvode&quot; 
 
        ===========  ======= 
        Return Code  Message 
        ===========  ======= 
        2            Integration successful. 
        -1           Excess work done on this call. (Perhaps wrong MF.) 
        -2           Excess accuracy requested. (Tolerances too small.) 
        -3           Illegal input detected. (See printed message.) 
        -4           Repeated error test failures. (Check all input.) 
        -5           Repeated convergence failures. (Perhaps bad Jacobian 
                     supplied or wrong choice of MF or tolerances.) 
        -6           Error weight became zero during problem. (Solution 
                     component i vanished, and ATOL or ATOL(i) = 0.) 
        ===========  ======= 
 
        &quot;dopri5&quot; 
 
        ===========  ======= 
        Return Code  Message 
        ===========  ======= 
        1            Integration successful. 
        2            Integration successful (interrupted by solout). 
        -1           Input is not consistent. 
        -2           Larger nsteps is needed. 
        -3           Step size becomes too small. 
        -4           Problem is probably stiff (interrupted). 
        ===========  ======= 
 
        &quot;dop853&quot; 
 
        ===========  ======= 
        Return Code  Message 
        ===========  ======= 
        1            Integration successful. 
        2            Integration successful (interrupted by solout). 
        -1           Input is not consistent. 
        -2           Larger nsteps is needed. 
        -3           Step size becomes too small. 
        -4           Problem is probably stiff (interrupted). 
        ===========  ======= 
 
        &quot;lsoda&quot; 
 
        ===========  ======= 
        Return Code  Message 
        ===========  ======= 
        2            Integration successful. 
        -1           Excess work done on this call (perhaps wrong Dfun type). 
        -2           Excess accuracy requested (tolerances too small). 
        -3           Illegal input detected (internal error). 
        -4           Repeated error test failures (internal error). 
        -5           Repeated convergence failures (perhaps bad Jacobian or tolerances). 
        -6           Error weight became zero during problem. 
        -7           Internal workspace insufficient to finish (internal error). 
        ===========  ======= 
        &quot;&quot;&quot;</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">self._integrator</span>
        <span class="s4">except </span><span class="s1">AttributeError:</span>
            <span class="s1">self.set_integrator(</span><span class="s3">''</span><span class="s1">)</span>
        <span class="s4">return </span><span class="s1">self._integrator.istate</span>

    <span class="s4">def </span><span class="s1">set_f_params(self</span><span class="s4">, </span><span class="s1">*args):</span>
        <span class="s2">&quot;&quot;&quot;Set extra parameters for user-supplied function f.&quot;&quot;&quot;</span>
        <span class="s1">self.f_params = args</span>
        <span class="s4">return </span><span class="s1">self</span>

    <span class="s4">def </span><span class="s1">set_jac_params(self</span><span class="s4">, </span><span class="s1">*args):</span>
        <span class="s2">&quot;&quot;&quot;Set extra parameters for user-supplied function jac.&quot;&quot;&quot;</span>
        <span class="s1">self.jac_params = args</span>
        <span class="s4">return </span><span class="s1">self</span>

    <span class="s4">def </span><span class="s1">set_solout(self</span><span class="s4">, </span><span class="s1">solout):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set callable to be called at every successful integration step. 
 
        Parameters 
        ---------- 
        solout : callable 
            ``solout(t, y)`` is called at each internal integrator step, 
            t is a scalar providing the current independent position 
            y is the current soloution ``y.shape == (n,)`` 
            solout should return -1 to stop integration 
            otherwise it should return None or 0 
 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">self._integrator.supports_solout:</span>
            <span class="s1">self._integrator.set_solout(solout)</span>
            <span class="s4">if </span><span class="s1">self._y </span><span class="s4">is not None</span><span class="s1">:</span>
                <span class="s1">self._integrator.reset(len(self._y)</span><span class="s4">, </span><span class="s1">self.jac </span><span class="s4">is not None</span><span class="s1">)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;selected integrator does not support solout,&quot;</span>
                             <span class="s3">&quot; choose another one&quot;</span><span class="s1">)</span>


<span class="s4">def </span><span class="s1">_transform_banded_jac(bjac):</span>
    <span class="s2">&quot;&quot;&quot; 
    Convert a real matrix of the form (for example) 
 
        [0 0 A B]        [0 0 0 B] 
        [0 0 C D]        [0 0 A D] 
        [E F G H]   to   [0 F C H] 
        [I J K L]        [E J G L] 
                         [I 0 K 0] 
 
    That is, every other column is shifted up one. 
    &quot;&quot;&quot;</span>
    <span class="s0"># Shift every other column.</span>
    <span class="s1">newjac = zeros((bjac.shape[</span><span class="s5">0</span><span class="s1">] + </span><span class="s5">1</span><span class="s4">, </span><span class="s1">bjac.shape[</span><span class="s5">1</span><span class="s1">]))</span>
    <span class="s1">newjac[</span><span class="s5">1</span><span class="s1">:</span><span class="s4">, </span><span class="s1">::</span><span class="s5">2</span><span class="s1">] = bjac[:</span><span class="s4">, </span><span class="s1">::</span><span class="s5">2</span><span class="s1">]</span>
    <span class="s1">newjac[:-</span><span class="s5">1</span><span class="s4">, </span><span class="s5">1</span><span class="s1">::</span><span class="s5">2</span><span class="s1">] = bjac[:</span><span class="s4">, </span><span class="s5">1</span><span class="s1">::</span><span class="s5">2</span><span class="s1">]</span>
    <span class="s4">return </span><span class="s1">newjac</span>


<span class="s4">class </span><span class="s1">complex_ode(ode):</span>
    <span class="s2">&quot;&quot;&quot; 
    A wrapper of ode for complex systems. 
 
    This functions similarly as `ode`, but re-maps a complex-valued 
    equation system to a real-valued one before using the integrators. 
 
    Parameters 
    ---------- 
    f : callable ``f(t, y, *f_args)`` 
        Rhs of the equation. t is a scalar, ``y.shape == (n,)``. 
        ``f_args`` is set by calling ``set_f_params(*args)``. 
    jac : callable ``jac(t, y, *jac_args)`` 
        Jacobian of the rhs, ``jac[i,j] = d f[i] / d y[j]``. 
        ``jac_args`` is set by calling ``set_f_params(*args)``. 
 
    Attributes 
    ---------- 
    t : float 
        Current time. 
    y : ndarray 
        Current variable values. 
 
    Examples 
    -------- 
    For usage examples, see `ode`. 
 
    &quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">f</span><span class="s4">, </span><span class="s1">jac=</span><span class="s4">None</span><span class="s1">):</span>
        <span class="s1">self.cf = f</span>
        <span class="s1">self.cjac = jac</span>
        <span class="s4">if </span><span class="s1">jac </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">ode.__init__(self</span><span class="s4">, </span><span class="s1">self._wrap</span><span class="s4">, None</span><span class="s1">)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">ode.__init__(self</span><span class="s4">, </span><span class="s1">self._wrap</span><span class="s4">, </span><span class="s1">self._wrap_jac)</span>

    <span class="s4">def </span><span class="s1">_wrap(self</span><span class="s4">, </span><span class="s1">t</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">*f_args):</span>
        <span class="s1">f = self.cf(*((t</span><span class="s4">, </span><span class="s1">y[::</span><span class="s5">2</span><span class="s1">] + </span><span class="s5">1j </span><span class="s1">* y[</span><span class="s5">1</span><span class="s1">::</span><span class="s5">2</span><span class="s1">]) + f_args))</span>
        <span class="s0"># self.tmp is a real-valued array containing the interleaved</span>
        <span class="s0"># real and imaginary parts of f.</span>
        <span class="s1">self.tmp[::</span><span class="s5">2</span><span class="s1">] = real(f)</span>
        <span class="s1">self.tmp[</span><span class="s5">1</span><span class="s1">::</span><span class="s5">2</span><span class="s1">] = imag(f)</span>
        <span class="s4">return </span><span class="s1">self.tmp</span>

    <span class="s4">def </span><span class="s1">_wrap_jac(self</span><span class="s4">, </span><span class="s1">t</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">*jac_args):</span>
        <span class="s0"># jac is the complex Jacobian computed by the user-defined function.</span>
        <span class="s1">jac = self.cjac(*((t</span><span class="s4">, </span><span class="s1">y[::</span><span class="s5">2</span><span class="s1">] + </span><span class="s5">1j </span><span class="s1">* y[</span><span class="s5">1</span><span class="s1">::</span><span class="s5">2</span><span class="s1">]) + jac_args))</span>

        <span class="s0"># jac_tmp is the real version of the complex Jacobian.  Each complex</span>
        <span class="s0"># entry in jac, say 2+3j, becomes a 2x2 block of the form</span>
        <span class="s0">#     [2 -3]</span>
        <span class="s0">#     [3  2]</span>
        <span class="s1">jac_tmp = zeros((</span><span class="s5">2 </span><span class="s1">* jac.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">, </span><span class="s5">2 </span><span class="s1">* jac.shape[</span><span class="s5">1</span><span class="s1">]))</span>
        <span class="s1">jac_tmp[</span><span class="s5">1</span><span class="s1">::</span><span class="s5">2</span><span class="s4">, </span><span class="s5">1</span><span class="s1">::</span><span class="s5">2</span><span class="s1">] = jac_tmp[::</span><span class="s5">2</span><span class="s4">, </span><span class="s1">::</span><span class="s5">2</span><span class="s1">] = real(jac)</span>
        <span class="s1">jac_tmp[</span><span class="s5">1</span><span class="s1">::</span><span class="s5">2</span><span class="s4">, </span><span class="s1">::</span><span class="s5">2</span><span class="s1">] = imag(jac)</span>
        <span class="s1">jac_tmp[::</span><span class="s5">2</span><span class="s4">, </span><span class="s5">1</span><span class="s1">::</span><span class="s5">2</span><span class="s1">] = -jac_tmp[</span><span class="s5">1</span><span class="s1">::</span><span class="s5">2</span><span class="s4">, </span><span class="s1">::</span><span class="s5">2</span><span class="s1">]</span>

        <span class="s1">ml = getattr(self._integrator</span><span class="s4">, </span><span class="s3">'ml'</span><span class="s4">, None</span><span class="s1">)</span>
        <span class="s1">mu = getattr(self._integrator</span><span class="s4">, </span><span class="s3">'mu'</span><span class="s4">, None</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">ml </span><span class="s4">is not None or </span><span class="s1">mu </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s0"># Jacobian is banded.  The user's Jacobian function has computed</span>
            <span class="s0"># the complex Jacobian in packed format.  The corresponding</span>
            <span class="s0"># real-valued version has every other column shifted up.</span>
            <span class="s1">jac_tmp = _transform_banded_jac(jac_tmp)</span>

        <span class="s4">return </span><span class="s1">jac_tmp</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">y(self):</span>
        <span class="s4">return </span><span class="s1">self._y[::</span><span class="s5">2</span><span class="s1">] + </span><span class="s5">1j </span><span class="s1">* self._y[</span><span class="s5">1</span><span class="s1">::</span><span class="s5">2</span><span class="s1">]</span>

    <span class="s4">def </span><span class="s1">set_integrator(self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">**integrator_params):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set integrator by name. 
 
        Parameters 
        ---------- 
        name : str 
            Name of the integrator 
        **integrator_params 
            Additional parameters for the integrator. 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">name == </span><span class="s3">'zvode'</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;zvode must be used with ode, not complex_ode&quot;</span><span class="s1">)</span>

        <span class="s1">lband = integrator_params.get(</span><span class="s3">'lband'</span><span class="s1">)</span>
        <span class="s1">uband = integrator_params.get(</span><span class="s3">'uband'</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">lband </span><span class="s4">is not None or </span><span class="s1">uband </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s0"># The Jacobian is banded.  Override the user-supplied bandwidths</span>
            <span class="s0"># (which are for the complex Jacobian) with the bandwidths of</span>
            <span class="s0"># the corresponding real-valued Jacobian wrapper of the complex</span>
            <span class="s0"># Jacobian.</span>
            <span class="s1">integrator_params[</span><span class="s3">'lband'</span><span class="s1">] = </span><span class="s5">2 </span><span class="s1">* (lband </span><span class="s4">or </span><span class="s5">0</span><span class="s1">) + </span><span class="s5">1</span>
            <span class="s1">integrator_params[</span><span class="s3">'uband'</span><span class="s1">] = </span><span class="s5">2 </span><span class="s1">* (uband </span><span class="s4">or </span><span class="s5">0</span><span class="s1">) + </span><span class="s5">1</span>

        <span class="s4">return </span><span class="s1">ode.set_integrator(self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">**integrator_params)</span>

    <span class="s4">def </span><span class="s1">set_initial_value(self</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">t=</span><span class="s5">0.0</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Set initial conditions y(t) = y.&quot;&quot;&quot;</span>
        <span class="s1">y = asarray(y)</span>
        <span class="s1">self.tmp = zeros(y.size * </span><span class="s5">2</span><span class="s4">, </span><span class="s3">'float'</span><span class="s1">)</span>
        <span class="s1">self.tmp[::</span><span class="s5">2</span><span class="s1">] = real(y)</span>
        <span class="s1">self.tmp[</span><span class="s5">1</span><span class="s1">::</span><span class="s5">2</span><span class="s1">] = imag(y)</span>
        <span class="s4">return </span><span class="s1">ode.set_initial_value(self</span><span class="s4">, </span><span class="s1">self.tmp</span><span class="s4">, </span><span class="s1">t)</span>

    <span class="s4">def </span><span class="s1">integrate(self</span><span class="s4">, </span><span class="s1">t</span><span class="s4">, </span><span class="s1">step=</span><span class="s4">False, </span><span class="s1">relax=</span><span class="s4">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Find y=y(t), set y as an initial condition, and return y. 
 
        Parameters 
        ---------- 
        t : float 
            The endpoint of the integration step. 
        step : bool 
            If True, and if the integrator supports the step method, 
            then perform a single integration step and return. 
            This parameter is provided in order to expose internals of 
            the implementation, and should not be changed from its default 
            value in most cases. 
        relax : bool 
            If True and if the integrator supports the run_relax method, 
            then integrate until t_1 &gt;= t and return. ``relax`` is not 
            referenced if ``step=True``. 
            This parameter is provided in order to expose internals of 
            the implementation, and should not be changed from its default 
            value in most cases. 
 
        Returns 
        ------- 
        y : float 
            The integrated value at t 
        &quot;&quot;&quot;</span>
        <span class="s1">y = ode.integrate(self</span><span class="s4">, </span><span class="s1">t</span><span class="s4">, </span><span class="s1">step</span><span class="s4">, </span><span class="s1">relax)</span>
        <span class="s4">return </span><span class="s1">y[::</span><span class="s5">2</span><span class="s1">] + </span><span class="s5">1j </span><span class="s1">* y[</span><span class="s5">1</span><span class="s1">::</span><span class="s5">2</span><span class="s1">]</span>

    <span class="s4">def </span><span class="s1">set_solout(self</span><span class="s4">, </span><span class="s1">solout):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set callable to be called at every successful integration step. 
 
        Parameters 
        ---------- 
        solout : callable 
            ``solout(t, y)`` is called at each internal integrator step, 
            t is a scalar providing the current independent position 
            y is the current soloution ``y.shape == (n,)`` 
            solout should return -1 to stop integration 
            otherwise it should return None or 0 
 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">self._integrator.supports_solout:</span>
            <span class="s1">self._integrator.set_solout(solout</span><span class="s4">, </span><span class="s1">complex=</span><span class="s4">True</span><span class="s1">)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;selected integrator does not support solouta,&quot;</span>
                            <span class="s1">+ </span><span class="s3">&quot;choose another one&quot;</span><span class="s1">)</span>


<span class="s0"># ------------------------------------------------------------------------------</span>
<span class="s0"># ODE integrators</span>
<span class="s0"># ------------------------------------------------------------------------------</span>

<span class="s4">def </span><span class="s1">find_integrator(name):</span>
    <span class="s4">for </span><span class="s1">cl </span><span class="s4">in </span><span class="s1">IntegratorBase.integrator_classes:</span>
        <span class="s4">if </span><span class="s1">re.match(name</span><span class="s4">, </span><span class="s1">cl.__name__</span><span class="s4">, </span><span class="s1">re.I):</span>
            <span class="s4">return </span><span class="s1">cl</span>
    <span class="s4">return None</span>


<span class="s4">class </span><span class="s1">IntegratorConcurrencyError(RuntimeError):</span>
    <span class="s2">&quot;&quot;&quot; 
    Failure due to concurrent usage of an integrator that can be used 
    only for a single problem at a time. 
 
    &quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">name):</span>
        <span class="s1">msg = (</span><span class="s3">&quot;Integrator `%s` can be used to solve only a single problem &quot;</span>
               <span class="s3">&quot;at a time. If you want to integrate multiple problems, &quot;</span>
               <span class="s3">&quot;consider using a different integrator &quot;</span>
               <span class="s3">&quot;(see `ode.set_integrator`)&quot;</span><span class="s1">) % name</span>
        <span class="s1">RuntimeError.__init__(self</span><span class="s4">, </span><span class="s1">msg)</span>


<span class="s4">class </span><span class="s1">IntegratorBase:</span>
    <span class="s1">runner = </span><span class="s4">None  </span><span class="s0"># runner is None =&gt; integrator is not available</span>
    <span class="s1">success = </span><span class="s4">None  </span><span class="s0"># success==1 if integrator was called successfully</span>
    <span class="s1">istate = </span><span class="s4">None  </span><span class="s0"># istate &gt; 0 means success, istate &lt; 0 means failure</span>
    <span class="s1">supports_run_relax = </span><span class="s4">None</span>
    <span class="s1">supports_step = </span><span class="s4">None</span>
    <span class="s1">supports_solout = </span><span class="s4">False</span>
    <span class="s1">integrator_classes = []</span>
    <span class="s1">scalar = float</span>

    <span class="s4">def </span><span class="s1">acquire_new_handle(self):</span>
        <span class="s0"># Some of the integrators have internal state (ancient</span>
        <span class="s0"># Fortran...), and so only one instance can use them at a time.</span>
        <span class="s0"># We keep track of this, and fail when concurrent usage is tried.</span>
        <span class="s1">self.__class__.active_global_handle += </span><span class="s5">1</span>
        <span class="s1">self.handle = self.__class__.active_global_handle</span>

    <span class="s4">def </span><span class="s1">check_handle(self):</span>
        <span class="s4">if </span><span class="s1">self.handle </span><span class="s4">is not </span><span class="s1">self.__class__.active_global_handle:</span>
            <span class="s4">raise </span><span class="s1">IntegratorConcurrencyError(self.__class__.__name__)</span>

    <span class="s4">def </span><span class="s1">reset(self</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">has_jac):</span>
        <span class="s2">&quot;&quot;&quot;Prepare integrator for call: allocate memory, set flags, etc. 
        n - number of equations. 
        has_jac - if user has supplied function for evaluating Jacobian. 
        &quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">run(self</span><span class="s4">, </span><span class="s1">f</span><span class="s4">, </span><span class="s1">jac</span><span class="s4">, </span><span class="s1">y0</span><span class="s4">, </span><span class="s1">t0</span><span class="s4">, </span><span class="s1">t1</span><span class="s4">, </span><span class="s1">f_params</span><span class="s4">, </span><span class="s1">jac_params):</span>
        <span class="s2">&quot;&quot;&quot;Integrate from t=t0 to t=t1 using y0 as an initial condition. 
        Return 2-tuple (y1,t1) where y1 is the result and t=t1 
        defines the stoppage coordinate of the result. 
        &quot;&quot;&quot;</span>
        <span class="s4">raise </span><span class="s1">NotImplementedError(</span><span class="s3">'all integrators must define '</span>
                                  <span class="s3">'run(f, jac, t0, t1, y0, f_params, jac_params)'</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">step(self</span><span class="s4">, </span><span class="s1">f</span><span class="s4">, </span><span class="s1">jac</span><span class="s4">, </span><span class="s1">y0</span><span class="s4">, </span><span class="s1">t0</span><span class="s4">, </span><span class="s1">t1</span><span class="s4">, </span><span class="s1">f_params</span><span class="s4">, </span><span class="s1">jac_params):</span>
        <span class="s2">&quot;&quot;&quot;Make one integration step and return (y1,t1).&quot;&quot;&quot;</span>
        <span class="s4">raise </span><span class="s1">NotImplementedError(</span><span class="s3">'%s does not support step() method' </span><span class="s1">%</span>
                                  <span class="s1">self.__class__.__name__)</span>

    <span class="s4">def </span><span class="s1">run_relax(self</span><span class="s4">, </span><span class="s1">f</span><span class="s4">, </span><span class="s1">jac</span><span class="s4">, </span><span class="s1">y0</span><span class="s4">, </span><span class="s1">t0</span><span class="s4">, </span><span class="s1">t1</span><span class="s4">, </span><span class="s1">f_params</span><span class="s4">, </span><span class="s1">jac_params):</span>
        <span class="s2">&quot;&quot;&quot;Integrate from t=t0 to t&gt;=t1 and return (y1,t).&quot;&quot;&quot;</span>
        <span class="s4">raise </span><span class="s1">NotImplementedError(</span><span class="s3">'%s does not support run_relax() method' </span><span class="s1">%</span>
                                  <span class="s1">self.__class__.__name__)</span>

    <span class="s0"># XXX: __str__ method for getting visual state of the integrator</span>


<span class="s4">def </span><span class="s1">_vode_banded_jac_wrapper(jacfunc</span><span class="s4">, </span><span class="s1">ml</span><span class="s4">, </span><span class="s1">jac_params):</span>
    <span class="s2">&quot;&quot;&quot; 
    Wrap a banded Jacobian function with a function that pads 
    the Jacobian with `ml` rows of zeros. 
    &quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">jac_wrapper(t</span><span class="s4">, </span><span class="s1">y):</span>
        <span class="s1">jac = asarray(jacfunc(t</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">*jac_params))</span>
        <span class="s1">padded_jac = vstack((jac</span><span class="s4">, </span><span class="s1">zeros((ml</span><span class="s4">, </span><span class="s1">jac.shape[</span><span class="s5">1</span><span class="s1">]))))</span>
        <span class="s4">return </span><span class="s1">padded_jac</span>

    <span class="s4">return </span><span class="s1">jac_wrapper</span>


<span class="s4">class </span><span class="s1">vode(IntegratorBase):</span>
    <span class="s1">runner = getattr(_vode</span><span class="s4">, </span><span class="s3">'dvode'</span><span class="s4">, None</span><span class="s1">)</span>

    <span class="s1">messages = {-</span><span class="s5">1</span><span class="s1">: </span><span class="s3">'Excess work done on this call. (Perhaps wrong MF.)'</span><span class="s4">,</span>
                <span class="s1">-</span><span class="s5">2</span><span class="s1">: </span><span class="s3">'Excess accuracy requested. (Tolerances too small.)'</span><span class="s4">,</span>
                <span class="s1">-</span><span class="s5">3</span><span class="s1">: </span><span class="s3">'Illegal input detected. (See printed message.)'</span><span class="s4">,</span>
                <span class="s1">-</span><span class="s5">4</span><span class="s1">: </span><span class="s3">'Repeated error test failures. (Check all input.)'</span><span class="s4">,</span>
                <span class="s1">-</span><span class="s5">5</span><span class="s1">: </span><span class="s3">'Repeated convergence failures. (Perhaps bad'</span>
                    <span class="s3">' Jacobian supplied or wrong choice of MF or tolerances.)'</span><span class="s4">,</span>
                <span class="s1">-</span><span class="s5">6</span><span class="s1">: </span><span class="s3">'Error weight became zero during problem. (Solution'</span>
                    <span class="s3">' component i vanished, and ATOL or ATOL(i) = 0.)'</span>
                <span class="s1">}</span>
    <span class="s1">supports_run_relax = </span><span class="s5">1</span>
    <span class="s1">supports_step = </span><span class="s5">1</span>
    <span class="s1">active_global_handle = </span><span class="s5">0</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">,</span>
                 <span class="s1">method=</span><span class="s3">'adams'</span><span class="s4">,</span>
                 <span class="s1">with_jacobian=</span><span class="s4">False,</span>
                 <span class="s1">rtol=</span><span class="s5">1e-6</span><span class="s4">, </span><span class="s1">atol=</span><span class="s5">1e-12</span><span class="s4">,</span>
                 <span class="s1">lband=</span><span class="s4">None, </span><span class="s1">uband=</span><span class="s4">None,</span>
                 <span class="s1">order=</span><span class="s5">12</span><span class="s4">,</span>
                 <span class="s1">nsteps=</span><span class="s5">500</span><span class="s4">,</span>
                 <span class="s1">max_step=</span><span class="s5">0.0</span><span class="s4">,  </span><span class="s0"># corresponds to infinite</span>
                 <span class="s1">min_step=</span><span class="s5">0.0</span><span class="s4">,</span>
                 <span class="s1">first_step=</span><span class="s5">0.0</span><span class="s4">,  </span><span class="s0"># determined by solver</span>
                 <span class="s1">):</span>

        <span class="s4">if </span><span class="s1">re.match(method</span><span class="s4">, </span><span class="s3">r'adams'</span><span class="s4">, </span><span class="s1">re.I):</span>
            <span class="s1">self.meth = </span><span class="s5">1</span>
        <span class="s4">elif </span><span class="s1">re.match(method</span><span class="s4">, </span><span class="s3">r'bdf'</span><span class="s4">, </span><span class="s1">re.I):</span>
            <span class="s1">self.meth = </span><span class="s5">2</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Unknown integration method %s' </span><span class="s1">% method)</span>
        <span class="s1">self.with_jacobian = with_jacobian</span>
        <span class="s1">self.rtol = rtol</span>
        <span class="s1">self.atol = atol</span>
        <span class="s1">self.mu = uband</span>
        <span class="s1">self.ml = lband</span>

        <span class="s1">self.order = order</span>
        <span class="s1">self.nsteps = nsteps</span>
        <span class="s1">self.max_step = max_step</span>
        <span class="s1">self.min_step = min_step</span>
        <span class="s1">self.first_step = first_step</span>
        <span class="s1">self.success = </span><span class="s5">1</span>

        <span class="s1">self.initialized = </span><span class="s4">False</span>

    <span class="s4">def </span><span class="s1">_determine_mf_and_set_bands(self</span><span class="s4">, </span><span class="s1">has_jac):</span>
        <span class="s2">&quot;&quot;&quot; 
        Determine the `MF` parameter (Method Flag) for the Fortran subroutine `dvode`. 
 
        In the Fortran code, the legal values of `MF` are: 
            10, 11, 12, 13, 14, 15, 20, 21, 22, 23, 24, 25, 
            -11, -12, -14, -15, -21, -22, -24, -25 
        but this Python wrapper does not use negative values. 
 
        Returns 
 
            mf  = 10*self.meth + miter 
 
        self.meth is the linear multistep method: 
            self.meth == 1:  method=&quot;adams&quot; 
            self.meth == 2:  method=&quot;bdf&quot; 
 
        miter is the correction iteration method: 
            miter == 0:  Functional iteraton; no Jacobian involved. 
            miter == 1:  Chord iteration with user-supplied full Jacobian. 
            miter == 2:  Chord iteration with internally computed full Jacobian. 
            miter == 3:  Chord iteration with internally computed diagonal Jacobian. 
            miter == 4:  Chord iteration with user-supplied banded Jacobian. 
            miter == 5:  Chord iteration with internally computed banded Jacobian. 
 
        Side effects: If either self.mu or self.ml is not None and the other is None, 
        then the one that is None is set to 0. 
        &quot;&quot;&quot;</span>

        <span class="s1">jac_is_banded = self.mu </span><span class="s4">is not None or </span><span class="s1">self.ml </span><span class="s4">is not None</span>
        <span class="s4">if </span><span class="s1">jac_is_banded:</span>
            <span class="s4">if </span><span class="s1">self.mu </span><span class="s4">is None</span><span class="s1">:</span>
                <span class="s1">self.mu = </span><span class="s5">0</span>
            <span class="s4">if </span><span class="s1">self.ml </span><span class="s4">is None</span><span class="s1">:</span>
                <span class="s1">self.ml = </span><span class="s5">0</span>

        <span class="s0"># has_jac is True if the user provided a Jacobian function.</span>
        <span class="s4">if </span><span class="s1">has_jac:</span>
            <span class="s4">if </span><span class="s1">jac_is_banded:</span>
                <span class="s1">miter = </span><span class="s5">4</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">miter = </span><span class="s5">1</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">if </span><span class="s1">jac_is_banded:</span>
                <span class="s4">if </span><span class="s1">self.ml == self.mu == </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s1">miter = </span><span class="s5">3  </span><span class="s0"># Chord iteration with internal diagonal Jacobian.</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s1">miter = </span><span class="s5">5  </span><span class="s0"># Chord iteration with internal banded Jacobian.</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s0"># self.with_jacobian is set by the user in the call to ode.set_integrator.</span>
                <span class="s4">if </span><span class="s1">self.with_jacobian:</span>
                    <span class="s1">miter = </span><span class="s5">2  </span><span class="s0"># Chord iteration with internal full Jacobian.</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s1">miter = </span><span class="s5">0  </span><span class="s0"># Functional iteraton; no Jacobian involved.</span>

        <span class="s1">mf = </span><span class="s5">10 </span><span class="s1">* self.meth + miter</span>
        <span class="s4">return </span><span class="s1">mf</span>

    <span class="s4">def </span><span class="s1">reset(self</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">has_jac):</span>
        <span class="s1">mf = self._determine_mf_and_set_bands(has_jac)</span>

        <span class="s4">if </span><span class="s1">mf == </span><span class="s5">10</span><span class="s1">:</span>
            <span class="s1">lrw = </span><span class="s5">20 </span><span class="s1">+ </span><span class="s5">16 </span><span class="s1">* n</span>
        <span class="s4">elif </span><span class="s1">mf </span><span class="s4">in </span><span class="s1">[</span><span class="s5">11</span><span class="s4">, </span><span class="s5">12</span><span class="s1">]:</span>
            <span class="s1">lrw = </span><span class="s5">22 </span><span class="s1">+ </span><span class="s5">16 </span><span class="s1">* n + </span><span class="s5">2 </span><span class="s1">* n * n</span>
        <span class="s4">elif </span><span class="s1">mf == </span><span class="s5">13</span><span class="s1">:</span>
            <span class="s1">lrw = </span><span class="s5">22 </span><span class="s1">+ </span><span class="s5">17 </span><span class="s1">* n</span>
        <span class="s4">elif </span><span class="s1">mf </span><span class="s4">in </span><span class="s1">[</span><span class="s5">14</span><span class="s4">, </span><span class="s5">15</span><span class="s1">]:</span>
            <span class="s1">lrw = </span><span class="s5">22 </span><span class="s1">+ </span><span class="s5">18 </span><span class="s1">* n + (</span><span class="s5">3 </span><span class="s1">* self.ml + </span><span class="s5">2 </span><span class="s1">* self.mu) * n</span>
        <span class="s4">elif </span><span class="s1">mf == </span><span class="s5">20</span><span class="s1">:</span>
            <span class="s1">lrw = </span><span class="s5">20 </span><span class="s1">+ </span><span class="s5">9 </span><span class="s1">* n</span>
        <span class="s4">elif </span><span class="s1">mf </span><span class="s4">in </span><span class="s1">[</span><span class="s5">21</span><span class="s4">, </span><span class="s5">22</span><span class="s1">]:</span>
            <span class="s1">lrw = </span><span class="s5">22 </span><span class="s1">+ </span><span class="s5">9 </span><span class="s1">* n + </span><span class="s5">2 </span><span class="s1">* n * n</span>
        <span class="s4">elif </span><span class="s1">mf == </span><span class="s5">23</span><span class="s1">:</span>
            <span class="s1">lrw = </span><span class="s5">22 </span><span class="s1">+ </span><span class="s5">10 </span><span class="s1">* n</span>
        <span class="s4">elif </span><span class="s1">mf </span><span class="s4">in </span><span class="s1">[</span><span class="s5">24</span><span class="s4">, </span><span class="s5">25</span><span class="s1">]:</span>
            <span class="s1">lrw = </span><span class="s5">22 </span><span class="s1">+ </span><span class="s5">11 </span><span class="s1">* n + (</span><span class="s5">3 </span><span class="s1">* self.ml + </span><span class="s5">2 </span><span class="s1">* self.mu) * n</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Unexpected mf=%s' </span><span class="s1">% mf)</span>

        <span class="s4">if </span><span class="s1">mf % </span><span class="s5">10 </span><span class="s4">in </span><span class="s1">[</span><span class="s5">0</span><span class="s4">, </span><span class="s5">3</span><span class="s1">]:</span>
            <span class="s1">liw = </span><span class="s5">30</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">liw = </span><span class="s5">30 </span><span class="s1">+ n</span>

        <span class="s1">rwork = zeros((lrw</span><span class="s4">,</span><span class="s1">)</span><span class="s4">, </span><span class="s1">float)</span>
        <span class="s1">rwork[</span><span class="s5">4</span><span class="s1">] = self.first_step</span>
        <span class="s1">rwork[</span><span class="s5">5</span><span class="s1">] = self.max_step</span>
        <span class="s1">rwork[</span><span class="s5">6</span><span class="s1">] = self.min_step</span>
        <span class="s1">self.rwork = rwork</span>

        <span class="s1">iwork = zeros((liw</span><span class="s4">,</span><span class="s1">)</span><span class="s4">, </span><span class="s1">_vode_int_dtype)</span>
        <span class="s4">if </span><span class="s1">self.ml </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">iwork[</span><span class="s5">0</span><span class="s1">] = self.ml</span>
        <span class="s4">if </span><span class="s1">self.mu </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">iwork[</span><span class="s5">1</span><span class="s1">] = self.mu</span>
        <span class="s1">iwork[</span><span class="s5">4</span><span class="s1">] = self.order</span>
        <span class="s1">iwork[</span><span class="s5">5</span><span class="s1">] = self.nsteps</span>
        <span class="s1">iwork[</span><span class="s5">6</span><span class="s1">] = </span><span class="s5">2  </span><span class="s0"># mxhnil</span>
        <span class="s1">self.iwork = iwork</span>

        <span class="s1">self.call_args = [self.rtol</span><span class="s4">, </span><span class="s1">self.atol</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s5">1</span><span class="s4">,</span>
                          <span class="s1">self.rwork</span><span class="s4">, </span><span class="s1">self.iwork</span><span class="s4">, </span><span class="s1">mf]</span>
        <span class="s1">self.success = </span><span class="s5">1</span>
        <span class="s1">self.initialized = </span><span class="s4">False</span>

    <span class="s4">def </span><span class="s1">run(self</span><span class="s4">, </span><span class="s1">f</span><span class="s4">, </span><span class="s1">jac</span><span class="s4">, </span><span class="s1">y0</span><span class="s4">, </span><span class="s1">t0</span><span class="s4">, </span><span class="s1">t1</span><span class="s4">, </span><span class="s1">f_params</span><span class="s4">, </span><span class="s1">jac_params):</span>
        <span class="s4">if </span><span class="s1">self.initialized:</span>
            <span class="s1">self.check_handle()</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">self.initialized = </span><span class="s4">True</span>
            <span class="s1">self.acquire_new_handle()</span>

        <span class="s4">if </span><span class="s1">self.ml </span><span class="s4">is not None and </span><span class="s1">self.ml &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0"># Banded Jacobian. Wrap the user-provided function with one</span>
            <span class="s0"># that pads the Jacobian array with the extra `self.ml` rows</span>
            <span class="s0"># required by the f2py-generated wrapper.</span>
            <span class="s1">jac = _vode_banded_jac_wrapper(jac</span><span class="s4">, </span><span class="s1">self.ml</span><span class="s4">, </span><span class="s1">jac_params)</span>

        <span class="s1">args = ((f</span><span class="s4">, </span><span class="s1">jac</span><span class="s4">, </span><span class="s1">y0</span><span class="s4">, </span><span class="s1">t0</span><span class="s4">, </span><span class="s1">t1) + tuple(self.call_args) +</span>
                <span class="s1">(f_params</span><span class="s4">, </span><span class="s1">jac_params))</span>
        <span class="s1">y1</span><span class="s4">, </span><span class="s1">t</span><span class="s4">, </span><span class="s1">istate = self.runner(*args)</span>
        <span class="s1">self.istate = istate</span>
        <span class="s4">if </span><span class="s1">istate &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">unexpected_istate_msg = </span><span class="s3">f'Unexpected istate=</span><span class="s4">{</span><span class="s1">istate</span><span class="s4">:</span><span class="s3">d</span><span class="s4">}</span><span class="s3">'</span>
            <span class="s1">warnings.warn(</span><span class="s3">'{:s}: {:s}'</span><span class="s1">.format(self.__class__.__name__</span><span class="s4">,</span>
                          <span class="s1">self.messages.get(istate</span><span class="s4">, </span><span class="s1">unexpected_istate_msg)))</span>
            <span class="s1">self.success = </span><span class="s5">0</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">self.call_args[</span><span class="s5">3</span><span class="s1">] = </span><span class="s5">2  </span><span class="s0"># upgrade istate from 1 to 2</span>
            <span class="s1">self.istate = </span><span class="s5">2</span>
        <span class="s4">return </span><span class="s1">y1</span><span class="s4">, </span><span class="s1">t</span>

    <span class="s4">def </span><span class="s1">step(self</span><span class="s4">, </span><span class="s1">*args):</span>
        <span class="s1">itask = self.call_args[</span><span class="s5">2</span><span class="s1">]</span>
        <span class="s1">self.call_args[</span><span class="s5">2</span><span class="s1">] = </span><span class="s5">2</span>
        <span class="s1">r = self.run(*args)</span>
        <span class="s1">self.call_args[</span><span class="s5">2</span><span class="s1">] = itask</span>
        <span class="s4">return </span><span class="s1">r</span>

    <span class="s4">def </span><span class="s1">run_relax(self</span><span class="s4">, </span><span class="s1">*args):</span>
        <span class="s1">itask = self.call_args[</span><span class="s5">2</span><span class="s1">]</span>
        <span class="s1">self.call_args[</span><span class="s5">2</span><span class="s1">] = </span><span class="s5">3</span>
        <span class="s1">r = self.run(*args)</span>
        <span class="s1">self.call_args[</span><span class="s5">2</span><span class="s1">] = itask</span>
        <span class="s4">return </span><span class="s1">r</span>


<span class="s4">if </span><span class="s1">vode.runner </span><span class="s4">is not None</span><span class="s1">:</span>
    <span class="s1">IntegratorBase.integrator_classes.append(vode)</span>


<span class="s4">class </span><span class="s1">zvode(vode):</span>
    <span class="s1">runner = getattr(_vode</span><span class="s4">, </span><span class="s3">'zvode'</span><span class="s4">, None</span><span class="s1">)</span>

    <span class="s1">supports_run_relax = </span><span class="s5">1</span>
    <span class="s1">supports_step = </span><span class="s5">1</span>
    <span class="s1">scalar = complex</span>
    <span class="s1">active_global_handle = </span><span class="s5">0</span>

    <span class="s4">def </span><span class="s1">reset(self</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">has_jac):</span>
        <span class="s1">mf = self._determine_mf_and_set_bands(has_jac)</span>

        <span class="s4">if </span><span class="s1">mf </span><span class="s4">in </span><span class="s1">(</span><span class="s5">10</span><span class="s4">,</span><span class="s1">):</span>
            <span class="s1">lzw = </span><span class="s5">15 </span><span class="s1">* n</span>
        <span class="s4">elif </span><span class="s1">mf </span><span class="s4">in </span><span class="s1">(</span><span class="s5">11</span><span class="s4">, </span><span class="s5">12</span><span class="s1">):</span>
            <span class="s1">lzw = </span><span class="s5">15 </span><span class="s1">* n + </span><span class="s5">2 </span><span class="s1">* n ** </span><span class="s5">2</span>
        <span class="s4">elif </span><span class="s1">mf </span><span class="s4">in </span><span class="s1">(-</span><span class="s5">11</span><span class="s4">, </span><span class="s1">-</span><span class="s5">12</span><span class="s1">):</span>
            <span class="s1">lzw = </span><span class="s5">15 </span><span class="s1">* n + n ** </span><span class="s5">2</span>
        <span class="s4">elif </span><span class="s1">mf </span><span class="s4">in </span><span class="s1">(</span><span class="s5">13</span><span class="s4">,</span><span class="s1">):</span>
            <span class="s1">lzw = </span><span class="s5">16 </span><span class="s1">* n</span>
        <span class="s4">elif </span><span class="s1">mf </span><span class="s4">in </span><span class="s1">(</span><span class="s5">14</span><span class="s4">, </span><span class="s5">15</span><span class="s1">):</span>
            <span class="s1">lzw = </span><span class="s5">17 </span><span class="s1">* n + (</span><span class="s5">3 </span><span class="s1">* self.ml + </span><span class="s5">2 </span><span class="s1">* self.mu) * n</span>
        <span class="s4">elif </span><span class="s1">mf </span><span class="s4">in </span><span class="s1">(-</span><span class="s5">14</span><span class="s4">, </span><span class="s1">-</span><span class="s5">15</span><span class="s1">):</span>
            <span class="s1">lzw = </span><span class="s5">16 </span><span class="s1">* n + (</span><span class="s5">2 </span><span class="s1">* self.ml + self.mu) * n</span>
        <span class="s4">elif </span><span class="s1">mf </span><span class="s4">in </span><span class="s1">(</span><span class="s5">20</span><span class="s4">,</span><span class="s1">):</span>
            <span class="s1">lzw = </span><span class="s5">8 </span><span class="s1">* n</span>
        <span class="s4">elif </span><span class="s1">mf </span><span class="s4">in </span><span class="s1">(</span><span class="s5">21</span><span class="s4">, </span><span class="s5">22</span><span class="s1">):</span>
            <span class="s1">lzw = </span><span class="s5">8 </span><span class="s1">* n + </span><span class="s5">2 </span><span class="s1">* n ** </span><span class="s5">2</span>
        <span class="s4">elif </span><span class="s1">mf </span><span class="s4">in </span><span class="s1">(-</span><span class="s5">21</span><span class="s4">, </span><span class="s1">-</span><span class="s5">22</span><span class="s1">):</span>
            <span class="s1">lzw = </span><span class="s5">8 </span><span class="s1">* n + n ** </span><span class="s5">2</span>
        <span class="s4">elif </span><span class="s1">mf </span><span class="s4">in </span><span class="s1">(</span><span class="s5">23</span><span class="s4">,</span><span class="s1">):</span>
            <span class="s1">lzw = </span><span class="s5">9 </span><span class="s1">* n</span>
        <span class="s4">elif </span><span class="s1">mf </span><span class="s4">in </span><span class="s1">(</span><span class="s5">24</span><span class="s4">, </span><span class="s5">25</span><span class="s1">):</span>
            <span class="s1">lzw = </span><span class="s5">10 </span><span class="s1">* n + (</span><span class="s5">3 </span><span class="s1">* self.ml + </span><span class="s5">2 </span><span class="s1">* self.mu) * n</span>
        <span class="s4">elif </span><span class="s1">mf </span><span class="s4">in </span><span class="s1">(-</span><span class="s5">24</span><span class="s4">, </span><span class="s1">-</span><span class="s5">25</span><span class="s1">):</span>
            <span class="s1">lzw = </span><span class="s5">9 </span><span class="s1">* n + (</span><span class="s5">2 </span><span class="s1">* self.ml + self.mu) * n</span>

        <span class="s1">lrw = </span><span class="s5">20 </span><span class="s1">+ n</span>

        <span class="s4">if </span><span class="s1">mf % </span><span class="s5">10 </span><span class="s4">in </span><span class="s1">(</span><span class="s5">0</span><span class="s4">, </span><span class="s5">3</span><span class="s1">):</span>
            <span class="s1">liw = </span><span class="s5">30</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">liw = </span><span class="s5">30 </span><span class="s1">+ n</span>

        <span class="s1">zwork = zeros((lzw</span><span class="s4">,</span><span class="s1">)</span><span class="s4">, </span><span class="s1">complex)</span>
        <span class="s1">self.zwork = zwork</span>

        <span class="s1">rwork = zeros((lrw</span><span class="s4">,</span><span class="s1">)</span><span class="s4">, </span><span class="s1">float)</span>
        <span class="s1">rwork[</span><span class="s5">4</span><span class="s1">] = self.first_step</span>
        <span class="s1">rwork[</span><span class="s5">5</span><span class="s1">] = self.max_step</span>
        <span class="s1">rwork[</span><span class="s5">6</span><span class="s1">] = self.min_step</span>
        <span class="s1">self.rwork = rwork</span>

        <span class="s1">iwork = zeros((liw</span><span class="s4">,</span><span class="s1">)</span><span class="s4">, </span><span class="s1">_vode_int_dtype)</span>
        <span class="s4">if </span><span class="s1">self.ml </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">iwork[</span><span class="s5">0</span><span class="s1">] = self.ml</span>
        <span class="s4">if </span><span class="s1">self.mu </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">iwork[</span><span class="s5">1</span><span class="s1">] = self.mu</span>
        <span class="s1">iwork[</span><span class="s5">4</span><span class="s1">] = self.order</span>
        <span class="s1">iwork[</span><span class="s5">5</span><span class="s1">] = self.nsteps</span>
        <span class="s1">iwork[</span><span class="s5">6</span><span class="s1">] = </span><span class="s5">2  </span><span class="s0"># mxhnil</span>
        <span class="s1">self.iwork = iwork</span>

        <span class="s1">self.call_args = [self.rtol</span><span class="s4">, </span><span class="s1">self.atol</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s5">1</span><span class="s4">,</span>
                          <span class="s1">self.zwork</span><span class="s4">, </span><span class="s1">self.rwork</span><span class="s4">, </span><span class="s1">self.iwork</span><span class="s4">, </span><span class="s1">mf]</span>
        <span class="s1">self.success = </span><span class="s5">1</span>
        <span class="s1">self.initialized = </span><span class="s4">False</span>


<span class="s4">if </span><span class="s1">zvode.runner </span><span class="s4">is not None</span><span class="s1">:</span>
    <span class="s1">IntegratorBase.integrator_classes.append(zvode)</span>


<span class="s4">class </span><span class="s1">dopri5(IntegratorBase):</span>
    <span class="s1">runner = getattr(_dop</span><span class="s4">, </span><span class="s3">'dopri5'</span><span class="s4">, None</span><span class="s1">)</span>
    <span class="s1">name = </span><span class="s3">'dopri5'</span>
    <span class="s1">supports_solout = </span><span class="s4">True</span>

    <span class="s1">messages = {</span><span class="s5">1</span><span class="s1">: </span><span class="s3">'computation successful'</span><span class="s4">,</span>
                <span class="s5">2</span><span class="s1">: </span><span class="s3">'computation successful (interrupted by solout)'</span><span class="s4">,</span>
                <span class="s1">-</span><span class="s5">1</span><span class="s1">: </span><span class="s3">'input is not consistent'</span><span class="s4">,</span>
                <span class="s1">-</span><span class="s5">2</span><span class="s1">: </span><span class="s3">'larger nsteps is needed'</span><span class="s4">,</span>
                <span class="s1">-</span><span class="s5">3</span><span class="s1">: </span><span class="s3">'step size becomes too small'</span><span class="s4">,</span>
                <span class="s1">-</span><span class="s5">4</span><span class="s1">: </span><span class="s3">'problem is probably stiff (interrupted)'</span><span class="s4">,</span>
                <span class="s1">}</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">,</span>
                 <span class="s1">rtol=</span><span class="s5">1e-6</span><span class="s4">, </span><span class="s1">atol=</span><span class="s5">1e-12</span><span class="s4">,</span>
                 <span class="s1">nsteps=</span><span class="s5">500</span><span class="s4">,</span>
                 <span class="s1">max_step=</span><span class="s5">0.0</span><span class="s4">,</span>
                 <span class="s1">first_step=</span><span class="s5">0.0</span><span class="s4">,  </span><span class="s0"># determined by solver</span>
                 <span class="s1">safety=</span><span class="s5">0.9</span><span class="s4">,</span>
                 <span class="s1">ifactor=</span><span class="s5">10.0</span><span class="s4">,</span>
                 <span class="s1">dfactor=</span><span class="s5">0.2</span><span class="s4">,</span>
                 <span class="s1">beta=</span><span class="s5">0.0</span><span class="s4">,</span>
                 <span class="s1">method=</span><span class="s4">None,</span>
                 <span class="s1">verbosity=-</span><span class="s5">1</span><span class="s4">,  </span><span class="s0"># no messages if negative</span>
                 <span class="s1">):</span>
        <span class="s1">self.rtol = rtol</span>
        <span class="s1">self.atol = atol</span>
        <span class="s1">self.nsteps = nsteps</span>
        <span class="s1">self.max_step = max_step</span>
        <span class="s1">self.first_step = first_step</span>
        <span class="s1">self.safety = safety</span>
        <span class="s1">self.ifactor = ifactor</span>
        <span class="s1">self.dfactor = dfactor</span>
        <span class="s1">self.beta = beta</span>
        <span class="s1">self.verbosity = verbosity</span>
        <span class="s1">self.success = </span><span class="s5">1</span>
        <span class="s1">self.set_solout(</span><span class="s4">None</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">set_solout(self</span><span class="s4">, </span><span class="s1">solout</span><span class="s4">, </span><span class="s1">complex=</span><span class="s4">False</span><span class="s1">):</span>
        <span class="s1">self.solout = solout</span>
        <span class="s1">self.solout_cmplx = complex</span>
        <span class="s4">if </span><span class="s1">solout </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">self.iout = </span><span class="s5">0</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">self.iout = </span><span class="s5">1</span>

    <span class="s4">def </span><span class="s1">reset(self</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">has_jac):</span>
        <span class="s1">work = zeros((</span><span class="s5">8 </span><span class="s1">* n + </span><span class="s5">21</span><span class="s4">,</span><span class="s1">)</span><span class="s4">, </span><span class="s1">float)</span>
        <span class="s1">work[</span><span class="s5">1</span><span class="s1">] = self.safety</span>
        <span class="s1">work[</span><span class="s5">2</span><span class="s1">] = self.dfactor</span>
        <span class="s1">work[</span><span class="s5">3</span><span class="s1">] = self.ifactor</span>
        <span class="s1">work[</span><span class="s5">4</span><span class="s1">] = self.beta</span>
        <span class="s1">work[</span><span class="s5">5</span><span class="s1">] = self.max_step</span>
        <span class="s1">work[</span><span class="s5">6</span><span class="s1">] = self.first_step</span>
        <span class="s1">self.work = work</span>
        <span class="s1">iwork = zeros((</span><span class="s5">21</span><span class="s4">,</span><span class="s1">)</span><span class="s4">, </span><span class="s1">_dop_int_dtype)</span>
        <span class="s1">iwork[</span><span class="s5">0</span><span class="s1">] = self.nsteps</span>
        <span class="s1">iwork[</span><span class="s5">2</span><span class="s1">] = self.verbosity</span>
        <span class="s1">self.iwork = iwork</span>
        <span class="s1">self.call_args = [self.rtol</span><span class="s4">, </span><span class="s1">self.atol</span><span class="s4">, </span><span class="s1">self._solout</span><span class="s4">,</span>
                          <span class="s1">self.iout</span><span class="s4">, </span><span class="s1">self.work</span><span class="s4">, </span><span class="s1">self.iwork]</span>
        <span class="s1">self.success = </span><span class="s5">1</span>

    <span class="s4">def </span><span class="s1">run(self</span><span class="s4">, </span><span class="s1">f</span><span class="s4">, </span><span class="s1">jac</span><span class="s4">, </span><span class="s1">y0</span><span class="s4">, </span><span class="s1">t0</span><span class="s4">, </span><span class="s1">t1</span><span class="s4">, </span><span class="s1">f_params</span><span class="s4">, </span><span class="s1">jac_params):</span>
        <span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">iwork</span><span class="s4">, </span><span class="s1">istate = self.runner(*((f</span><span class="s4">, </span><span class="s1">t0</span><span class="s4">, </span><span class="s1">y0</span><span class="s4">, </span><span class="s1">t1) +</span>
                                          <span class="s1">tuple(self.call_args) + (f_params</span><span class="s4">,</span><span class="s1">)))</span>
        <span class="s1">self.istate = istate</span>
        <span class="s4">if </span><span class="s1">istate &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">unexpected_istate_msg = </span><span class="s3">f'Unexpected istate=</span><span class="s4">{</span><span class="s1">istate</span><span class="s4">:</span><span class="s3">d</span><span class="s4">}</span><span class="s3">'</span>
            <span class="s1">warnings.warn(</span><span class="s3">'{:s}: {:s}'</span><span class="s1">.format(self.__class__.__name__</span><span class="s4">,</span>
                          <span class="s1">self.messages.get(istate</span><span class="s4">, </span><span class="s1">unexpected_istate_msg)))</span>
            <span class="s1">self.success = </span><span class="s5">0</span>
        <span class="s4">return </span><span class="s1">y</span><span class="s4">, </span><span class="s1">x</span>

    <span class="s4">def </span><span class="s1">_solout(self</span><span class="s4">, </span><span class="s1">nr</span><span class="s4">, </span><span class="s1">xold</span><span class="s4">, </span><span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">nd</span><span class="s4">, </span><span class="s1">icomp</span><span class="s4">, </span><span class="s1">con):</span>
        <span class="s4">if </span><span class="s1">self.solout </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s4">if </span><span class="s1">self.solout_cmplx:</span>
                <span class="s1">y = y[::</span><span class="s5">2</span><span class="s1">] + </span><span class="s5">1j </span><span class="s1">* y[</span><span class="s5">1</span><span class="s1">::</span><span class="s5">2</span><span class="s1">]</span>
            <span class="s4">return </span><span class="s1">self.solout(x</span><span class="s4">, </span><span class="s1">y)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s5">1</span>


<span class="s4">if </span><span class="s1">dopri5.runner </span><span class="s4">is not None</span><span class="s1">:</span>
    <span class="s1">IntegratorBase.integrator_classes.append(dopri5)</span>


<span class="s4">class </span><span class="s1">dop853(dopri5):</span>
    <span class="s1">runner = getattr(_dop</span><span class="s4">, </span><span class="s3">'dop853'</span><span class="s4">, None</span><span class="s1">)</span>
    <span class="s1">name = </span><span class="s3">'dop853'</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">,</span>
                 <span class="s1">rtol=</span><span class="s5">1e-6</span><span class="s4">, </span><span class="s1">atol=</span><span class="s5">1e-12</span><span class="s4">,</span>
                 <span class="s1">nsteps=</span><span class="s5">500</span><span class="s4">,</span>
                 <span class="s1">max_step=</span><span class="s5">0.0</span><span class="s4">,</span>
                 <span class="s1">first_step=</span><span class="s5">0.0</span><span class="s4">,  </span><span class="s0"># determined by solver</span>
                 <span class="s1">safety=</span><span class="s5">0.9</span><span class="s4">,</span>
                 <span class="s1">ifactor=</span><span class="s5">6.0</span><span class="s4">,</span>
                 <span class="s1">dfactor=</span><span class="s5">0.3</span><span class="s4">,</span>
                 <span class="s1">beta=</span><span class="s5">0.0</span><span class="s4">,</span>
                 <span class="s1">method=</span><span class="s4">None,</span>
                 <span class="s1">verbosity=-</span><span class="s5">1</span><span class="s4">,  </span><span class="s0"># no messages if negative</span>
                 <span class="s1">):</span>
        <span class="s1">super().__init__(rtol</span><span class="s4">, </span><span class="s1">atol</span><span class="s4">, </span><span class="s1">nsteps</span><span class="s4">, </span><span class="s1">max_step</span><span class="s4">, </span><span class="s1">first_step</span><span class="s4">, </span><span class="s1">safety</span><span class="s4">,</span>
                         <span class="s1">ifactor</span><span class="s4">, </span><span class="s1">dfactor</span><span class="s4">, </span><span class="s1">beta</span><span class="s4">, </span><span class="s1">method</span><span class="s4">, </span><span class="s1">verbosity)</span>

    <span class="s4">def </span><span class="s1">reset(self</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">has_jac):</span>
        <span class="s1">work = zeros((</span><span class="s5">11 </span><span class="s1">* n + </span><span class="s5">21</span><span class="s4">,</span><span class="s1">)</span><span class="s4">, </span><span class="s1">float)</span>
        <span class="s1">work[</span><span class="s5">1</span><span class="s1">] = self.safety</span>
        <span class="s1">work[</span><span class="s5">2</span><span class="s1">] = self.dfactor</span>
        <span class="s1">work[</span><span class="s5">3</span><span class="s1">] = self.ifactor</span>
        <span class="s1">work[</span><span class="s5">4</span><span class="s1">] = self.beta</span>
        <span class="s1">work[</span><span class="s5">5</span><span class="s1">] = self.max_step</span>
        <span class="s1">work[</span><span class="s5">6</span><span class="s1">] = self.first_step</span>
        <span class="s1">self.work = work</span>
        <span class="s1">iwork = zeros((</span><span class="s5">21</span><span class="s4">,</span><span class="s1">)</span><span class="s4">, </span><span class="s1">_dop_int_dtype)</span>
        <span class="s1">iwork[</span><span class="s5">0</span><span class="s1">] = self.nsteps</span>
        <span class="s1">iwork[</span><span class="s5">2</span><span class="s1">] = self.verbosity</span>
        <span class="s1">self.iwork = iwork</span>
        <span class="s1">self.call_args = [self.rtol</span><span class="s4">, </span><span class="s1">self.atol</span><span class="s4">, </span><span class="s1">self._solout</span><span class="s4">,</span>
                          <span class="s1">self.iout</span><span class="s4">, </span><span class="s1">self.work</span><span class="s4">, </span><span class="s1">self.iwork]</span>
        <span class="s1">self.success = </span><span class="s5">1</span>


<span class="s4">if </span><span class="s1">dop853.runner </span><span class="s4">is not None</span><span class="s1">:</span>
    <span class="s1">IntegratorBase.integrator_classes.append(dop853)</span>


<span class="s4">class </span><span class="s1">lsoda(IntegratorBase):</span>
    <span class="s1">runner = getattr(_lsoda</span><span class="s4">, </span><span class="s3">'lsoda'</span><span class="s4">, None</span><span class="s1">)</span>
    <span class="s1">active_global_handle = </span><span class="s5">0</span>

    <span class="s1">messages = {</span>
        <span class="s5">2</span><span class="s1">: </span><span class="s3">&quot;Integration successful.&quot;</span><span class="s4">,</span>
        <span class="s1">-</span><span class="s5">1</span><span class="s1">: </span><span class="s3">&quot;Excess work done on this call (perhaps wrong Dfun type).&quot;</span><span class="s4">,</span>
        <span class="s1">-</span><span class="s5">2</span><span class="s1">: </span><span class="s3">&quot;Excess accuracy requested (tolerances too small).&quot;</span><span class="s4">,</span>
        <span class="s1">-</span><span class="s5">3</span><span class="s1">: </span><span class="s3">&quot;Illegal input detected (internal error).&quot;</span><span class="s4">,</span>
        <span class="s1">-</span><span class="s5">4</span><span class="s1">: </span><span class="s3">&quot;Repeated error test failures (internal error).&quot;</span><span class="s4">,</span>
        <span class="s1">-</span><span class="s5">5</span><span class="s1">: </span><span class="s3">&quot;Repeated convergence failures (perhaps bad Jacobian or tolerances).&quot;</span><span class="s4">,</span>
        <span class="s1">-</span><span class="s5">6</span><span class="s1">: </span><span class="s3">&quot;Error weight became zero during problem.&quot;</span><span class="s4">,</span>
        <span class="s1">-</span><span class="s5">7</span><span class="s1">: </span><span class="s3">&quot;Internal workspace insufficient to finish (internal error).&quot;</span>
    <span class="s1">}</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">,</span>
                 <span class="s1">with_jacobian=</span><span class="s4">False,</span>
                 <span class="s1">rtol=</span><span class="s5">1e-6</span><span class="s4">, </span><span class="s1">atol=</span><span class="s5">1e-12</span><span class="s4">,</span>
                 <span class="s1">lband=</span><span class="s4">None, </span><span class="s1">uband=</span><span class="s4">None,</span>
                 <span class="s1">nsteps=</span><span class="s5">500</span><span class="s4">,</span>
                 <span class="s1">max_step=</span><span class="s5">0.0</span><span class="s4">,  </span><span class="s0"># corresponds to infinite</span>
                 <span class="s1">min_step=</span><span class="s5">0.0</span><span class="s4">,</span>
                 <span class="s1">first_step=</span><span class="s5">0.0</span><span class="s4">,  </span><span class="s0"># determined by solver</span>
                 <span class="s1">ixpr=</span><span class="s5">0</span><span class="s4">,</span>
                 <span class="s1">max_hnil=</span><span class="s5">0</span><span class="s4">,</span>
                 <span class="s1">max_order_ns=</span><span class="s5">12</span><span class="s4">,</span>
                 <span class="s1">max_order_s=</span><span class="s5">5</span><span class="s4">,</span>
                 <span class="s1">method=</span><span class="s4">None</span>
                 <span class="s1">):</span>

        <span class="s1">self.with_jacobian = with_jacobian</span>
        <span class="s1">self.rtol = rtol</span>
        <span class="s1">self.atol = atol</span>
        <span class="s1">self.mu = uband</span>
        <span class="s1">self.ml = lband</span>

        <span class="s1">self.max_order_ns = max_order_ns</span>
        <span class="s1">self.max_order_s = max_order_s</span>
        <span class="s1">self.nsteps = nsteps</span>
        <span class="s1">self.max_step = max_step</span>
        <span class="s1">self.min_step = min_step</span>
        <span class="s1">self.first_step = first_step</span>
        <span class="s1">self.ixpr = ixpr</span>
        <span class="s1">self.max_hnil = max_hnil</span>
        <span class="s1">self.success = </span><span class="s5">1</span>

        <span class="s1">self.initialized = </span><span class="s4">False</span>

    <span class="s4">def </span><span class="s1">reset(self</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">has_jac):</span>
        <span class="s0"># Calculate parameters for Fortran subroutine dvode.</span>
        <span class="s4">if </span><span class="s1">has_jac:</span>
            <span class="s4">if </span><span class="s1">self.mu </span><span class="s4">is None and </span><span class="s1">self.ml </span><span class="s4">is None</span><span class="s1">:</span>
                <span class="s1">jt = </span><span class="s5">1</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s4">if </span><span class="s1">self.mu </span><span class="s4">is None</span><span class="s1">:</span>
                    <span class="s1">self.mu = </span><span class="s5">0</span>
                <span class="s4">if </span><span class="s1">self.ml </span><span class="s4">is None</span><span class="s1">:</span>
                    <span class="s1">self.ml = </span><span class="s5">0</span>
                <span class="s1">jt = </span><span class="s5">4</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">if </span><span class="s1">self.mu </span><span class="s4">is None and </span><span class="s1">self.ml </span><span class="s4">is None</span><span class="s1">:</span>
                <span class="s1">jt = </span><span class="s5">2</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s4">if </span><span class="s1">self.mu </span><span class="s4">is None</span><span class="s1">:</span>
                    <span class="s1">self.mu = </span><span class="s5">0</span>
                <span class="s4">if </span><span class="s1">self.ml </span><span class="s4">is None</span><span class="s1">:</span>
                    <span class="s1">self.ml = </span><span class="s5">0</span>
                <span class="s1">jt = </span><span class="s5">5</span>
        <span class="s1">lrn = </span><span class="s5">20 </span><span class="s1">+ (self.max_order_ns + </span><span class="s5">4</span><span class="s1">) * n</span>
        <span class="s4">if </span><span class="s1">jt </span><span class="s4">in </span><span class="s1">[</span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s1">]:</span>
            <span class="s1">lrs = </span><span class="s5">22 </span><span class="s1">+ (self.max_order_s + </span><span class="s5">4</span><span class="s1">) * n + n * n</span>
        <span class="s4">elif </span><span class="s1">jt </span><span class="s4">in </span><span class="s1">[</span><span class="s5">4</span><span class="s4">, </span><span class="s5">5</span><span class="s1">]:</span>
            <span class="s1">lrs = </span><span class="s5">22 </span><span class="s1">+ (self.max_order_s + </span><span class="s5">5 </span><span class="s1">+ </span><span class="s5">2 </span><span class="s1">* self.ml + self.mu) * n</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Unexpected jt=%s' </span><span class="s1">% jt)</span>
        <span class="s1">lrw = max(lrn</span><span class="s4">, </span><span class="s1">lrs)</span>
        <span class="s1">liw = </span><span class="s5">20 </span><span class="s1">+ n</span>
        <span class="s1">rwork = zeros((lrw</span><span class="s4">,</span><span class="s1">)</span><span class="s4">, </span><span class="s1">float)</span>
        <span class="s1">rwork[</span><span class="s5">4</span><span class="s1">] = self.first_step</span>
        <span class="s1">rwork[</span><span class="s5">5</span><span class="s1">] = self.max_step</span>
        <span class="s1">rwork[</span><span class="s5">6</span><span class="s1">] = self.min_step</span>
        <span class="s1">self.rwork = rwork</span>
        <span class="s1">iwork = zeros((liw</span><span class="s4">,</span><span class="s1">)</span><span class="s4">, </span><span class="s1">_lsoda_int_dtype)</span>
        <span class="s4">if </span><span class="s1">self.ml </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">iwork[</span><span class="s5">0</span><span class="s1">] = self.ml</span>
        <span class="s4">if </span><span class="s1">self.mu </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">iwork[</span><span class="s5">1</span><span class="s1">] = self.mu</span>
        <span class="s1">iwork[</span><span class="s5">4</span><span class="s1">] = self.ixpr</span>
        <span class="s1">iwork[</span><span class="s5">5</span><span class="s1">] = self.nsteps</span>
        <span class="s1">iwork[</span><span class="s5">6</span><span class="s1">] = self.max_hnil</span>
        <span class="s1">iwork[</span><span class="s5">7</span><span class="s1">] = self.max_order_ns</span>
        <span class="s1">iwork[</span><span class="s5">8</span><span class="s1">] = self.max_order_s</span>
        <span class="s1">self.iwork = iwork</span>
        <span class="s1">self.call_args = [self.rtol</span><span class="s4">, </span><span class="s1">self.atol</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s5">1</span><span class="s4">,</span>
                          <span class="s1">self.rwork</span><span class="s4">, </span><span class="s1">self.iwork</span><span class="s4">, </span><span class="s1">jt]</span>
        <span class="s1">self.success = </span><span class="s5">1</span>
        <span class="s1">self.initialized = </span><span class="s4">False</span>

    <span class="s4">def </span><span class="s1">run(self</span><span class="s4">, </span><span class="s1">f</span><span class="s4">, </span><span class="s1">jac</span><span class="s4">, </span><span class="s1">y0</span><span class="s4">, </span><span class="s1">t0</span><span class="s4">, </span><span class="s1">t1</span><span class="s4">, </span><span class="s1">f_params</span><span class="s4">, </span><span class="s1">jac_params):</span>
        <span class="s4">if </span><span class="s1">self.initialized:</span>
            <span class="s1">self.check_handle()</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">self.initialized = </span><span class="s4">True</span>
            <span class="s1">self.acquire_new_handle()</span>
        <span class="s1">args = [f</span><span class="s4">, </span><span class="s1">y0</span><span class="s4">, </span><span class="s1">t0</span><span class="s4">, </span><span class="s1">t1] + self.call_args[:-</span><span class="s5">1</span><span class="s1">] + \</span>
               <span class="s1">[jac</span><span class="s4">, </span><span class="s1">self.call_args[-</span><span class="s5">1</span><span class="s1">]</span><span class="s4">, </span><span class="s1">f_params</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s1">jac_params]</span>
        <span class="s1">y1</span><span class="s4">, </span><span class="s1">t</span><span class="s4">, </span><span class="s1">istate = self.runner(*args)</span>
        <span class="s1">self.istate = istate</span>
        <span class="s4">if </span><span class="s1">istate &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">unexpected_istate_msg = </span><span class="s3">f'Unexpected istate=</span><span class="s4">{</span><span class="s1">istate</span><span class="s4">:</span><span class="s3">d</span><span class="s4">}</span><span class="s3">'</span>
            <span class="s1">warnings.warn(</span><span class="s3">'{:s}: {:s}'</span><span class="s1">.format(self.__class__.__name__</span><span class="s4">,</span>
                          <span class="s1">self.messages.get(istate</span><span class="s4">, </span><span class="s1">unexpected_istate_msg)))</span>
            <span class="s1">self.success = </span><span class="s5">0</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">self.call_args[</span><span class="s5">3</span><span class="s1">] = </span><span class="s5">2  </span><span class="s0"># upgrade istate from 1 to 2</span>
            <span class="s1">self.istate = </span><span class="s5">2</span>
        <span class="s4">return </span><span class="s1">y1</span><span class="s4">, </span><span class="s1">t</span>

    <span class="s4">def </span><span class="s1">step(self</span><span class="s4">, </span><span class="s1">*args):</span>
        <span class="s1">itask = self.call_args[</span><span class="s5">2</span><span class="s1">]</span>
        <span class="s1">self.call_args[</span><span class="s5">2</span><span class="s1">] = </span><span class="s5">2</span>
        <span class="s1">r = self.run(*args)</span>
        <span class="s1">self.call_args[</span><span class="s5">2</span><span class="s1">] = itask</span>
        <span class="s4">return </span><span class="s1">r</span>

    <span class="s4">def </span><span class="s1">run_relax(self</span><span class="s4">, </span><span class="s1">*args):</span>
        <span class="s1">itask = self.call_args[</span><span class="s5">2</span><span class="s1">]</span>
        <span class="s1">self.call_args[</span><span class="s5">2</span><span class="s1">] = </span><span class="s5">3</span>
        <span class="s1">r = self.run(*args)</span>
        <span class="s1">self.call_args[</span><span class="s5">2</span><span class="s1">] = itask</span>
        <span class="s4">return </span><span class="s1">r</span>


<span class="s4">if </span><span class="s1">lsoda.runner:</span>
    <span class="s1">IntegratorBase.integrator_classes.append(lsoda)</span>
</pre>
</body>
</html>