<html>
<head>
<title>test_collapsed.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_collapsed.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Tests for collapsed observation vector 
 
These tests cannot be run for the Clark 1989 model since the dimension of 
observations (2) is smaller than the number of states (6). 
 
Author: Chad Fulton 
License: Simplified-BSD 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">import </span><span class="s1">pytest</span>
<span class="s2">import </span><span class="s1">os</span>

<span class="s2">from </span><span class="s1">statsmodels </span><span class="s2">import </span><span class="s1">datasets</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace </span><span class="s2">import </span><span class="s1">dynamic_factor</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace.mlemodel </span><span class="s2">import </span><span class="s1">MLEModel</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace.kalman_filter </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">FILTER_UNIVARIATE)</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace.kalman_smoother </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">SMOOTH_CLASSICAL</span><span class="s2">, </span><span class="s1">SMOOTH_ALTERNATIVE</span><span class="s2">,</span>
    <span class="s1">SMOOTH_UNIVARIATE)</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace.tests.results </span><span class="s2">import </span><span class="s1">results_kalman_filter</span>
<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">assert_equal</span><span class="s2">, </span><span class="s1">assert_allclose</span>

<span class="s1">current_path = os.path.dirname(os.path.abspath(__file__))</span>


<span class="s2">class </span><span class="s1">Trivariate:</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests collapsing three-dimensional observation data to two-dimensional 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">dtype=float</span><span class="s2">, </span><span class="s1">alternate_timing=</span><span class="s2">False, </span><span class="s1">**kwargs):</span>
        <span class="s1">cls.results = results_kalman_filter.uc_bi</span>

        <span class="s3"># GDP and Unemployment, Quarterly, 1948.1 - 1995.3</span>
        <span class="s1">data = pd.DataFrame(</span>
            <span class="s1">cls.results[</span><span class="s4">'data'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">index=pd.date_range(</span><span class="s4">'1947-01-01'</span><span class="s2">, </span><span class="s4">'1995-07-01'</span><span class="s2">, </span><span class="s1">freq=</span><span class="s4">'QS'</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">columns=[</span><span class="s4">'GDP'</span><span class="s2">, </span><span class="s4">'UNEMP'</span><span class="s1">]</span>
        <span class="s1">)[</span><span class="s5">4</span><span class="s1">:]</span>
        <span class="s1">data[</span><span class="s4">'GDP'</span><span class="s1">] = np.log(data[</span><span class="s4">'GDP'</span><span class="s1">])</span>
        <span class="s1">data[</span><span class="s4">'UNEMP'</span><span class="s1">] = (data[</span><span class="s4">'UNEMP'</span><span class="s1">]/</span><span class="s5">100</span><span class="s1">)</span>
        <span class="s1">data[</span><span class="s4">'X'</span><span class="s1">] = np.exp(data[</span><span class="s4">'GDP'</span><span class="s1">]) * data[</span><span class="s4">'UNEMP'</span><span class="s1">]</span>

        <span class="s1">k_states = </span><span class="s5">2</span>
        <span class="s1">cls.mlemodel = MLEModel(data</span><span class="s2">, </span><span class="s1">k_states=k_states</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">cls.model = cls.mlemodel.ssm</span>
        <span class="s2">if </span><span class="s1">alternate_timing:</span>
            <span class="s1">cls.model.timing_init_filtered = </span><span class="s2">True</span>

        <span class="s3"># Statespace representation</span>
        <span class="s1">cls.model[</span><span class="s4">'selection'</span><span class="s1">] = np.eye(cls.model.k_states)</span>

        <span class="s3"># Update matrices with test parameters</span>
        <span class="s1">cls.model[</span><span class="s4">'design'</span><span class="s1">] = np.array([[</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.2</span><span class="s1">]</span><span class="s2">,</span>
                                        <span class="s1">[</span><span class="s5">0</span><span class="s2">,   </span><span class="s5">0.8</span><span class="s1">]</span><span class="s2">,</span>
                                        <span class="s1">[</span><span class="s5">1</span><span class="s2">,  </span><span class="s1">-</span><span class="s5">0.5</span><span class="s1">]])</span>
        <span class="s1">cls.model[</span><span class="s4">'transition'</span><span class="s1">] = np.array([[</span><span class="s5">0.4</span><span class="s2">, </span><span class="s5">0.5</span><span class="s1">]</span><span class="s2">,</span>
                                            <span class="s1">[</span><span class="s5">1</span><span class="s2">,   </span><span class="s5">0</span><span class="s1">]])</span>
        <span class="s1">cls.model[</span><span class="s4">'obs_cov'</span><span class="s1">] = np.diag([</span><span class="s5">0.2</span><span class="s2">, </span><span class="s5">1.1</span><span class="s2">, </span><span class="s5">0.5</span><span class="s1">])</span>
        <span class="s1">cls.model[</span><span class="s4">'state_cov'</span><span class="s1">] = np.diag([</span><span class="s5">2.</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span>

        <span class="s3"># Initialization</span>
        <span class="s1">cls.model.initialize_approximate_diffuse()</span>

    <span class="s2">def </span><span class="s1">test_using_collapsed(self):</span>
        <span class="s3"># Test to make sure the results_b actually used a collapsed Kalman</span>
        <span class="s3"># filtering approach (i.e. that the flag being set actually caused the</span>
        <span class="s3"># filter to not use the conventional filter)</span>

        <span class="s2">assert not </span><span class="s1">self.results_a.filter_collapsed</span>
        <span class="s2">assert </span><span class="s1">self.results_b.filter_collapsed</span>

        <span class="s2">assert </span><span class="s1">self.results_a.collapsed_forecasts </span><span class="s2">is None</span>
        <span class="s2">assert </span><span class="s1">self.results_b.collapsed_forecasts </span><span class="s2">is not None</span>

        <span class="s1">assert_equal(self.results_a.forecasts.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">assert_equal(self.results_b.collapsed_forecasts.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_forecasts(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results_a.forecasts[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">,</span>
            <span class="s1">self.results_b.forecasts[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_forecasts_error(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results_a.forecasts_error[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">,</span>
            <span class="s1">self.results_b.forecasts_error[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_forecasts_error_cov(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results_a.forecasts_error_cov[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">,</span>
            <span class="s1">self.results_b.forecasts_error_cov[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_filtered_state(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results_a.filtered_state</span><span class="s2">,</span>
            <span class="s1">self.results_b.filtered_state</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_filtered_state_cov(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results_a.filtered_state_cov</span><span class="s2">,</span>
            <span class="s1">self.results_b.filtered_state_cov</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_predicted_state(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results_a.predicted_state</span><span class="s2">,</span>
            <span class="s1">self.results_b.predicted_state</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_predicted_state_cov(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results_a.predicted_state_cov</span><span class="s2">,</span>
            <span class="s1">self.results_b.predicted_state_cov</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_loglike(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results_a.llf_obs</span><span class="s2">,</span>
            <span class="s1">self.results_b.llf_obs</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_smoothed_states(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results_a.smoothed_state</span><span class="s2">,</span>
            <span class="s1">self.results_b.smoothed_state</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_smoothed_states_cov(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results_a.smoothed_state_cov</span><span class="s2">,</span>
            <span class="s1">self.results_b.smoothed_state_cov</span><span class="s2">,</span>
            <span class="s1">atol=</span><span class="s5">1e-4</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_smoothed_states_autocov(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results_a.smoothed_state_autocov</span><span class="s2">,</span>
            <span class="s1">self.results_b.smoothed_state_autocov</span>
        <span class="s1">)</span>

    <span class="s3"># Skipped because &quot;measurement&quot; refers to different things; even different</span>
    <span class="s3"># dimensions</span>
    <span class="s1">@pytest.mark.skip</span>
    <span class="s2">def </span><span class="s1">test_smoothed_measurement_disturbance(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results_a.smoothed_measurement_disturbance</span><span class="s2">,</span>
            <span class="s1">self.results_b.smoothed_measurement_disturbance</span>
        <span class="s1">)</span>

    <span class="s3"># Skipped because &quot;measurement&quot; refers to different things; even different</span>
    <span class="s3"># dimensions</span>
    <span class="s1">@pytest.mark.skip</span>
    <span class="s2">def </span><span class="s1">test_smoothed_measurement_disturbance_cov(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results_a.smoothed_measurement_disturbance_cov</span><span class="s2">,</span>
            <span class="s1">self.results_b.smoothed_measurement_disturbance_cov</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_smoothed_state_disturbance(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results_a.smoothed_state_disturbance</span><span class="s2">,</span>
            <span class="s1">self.results_b.smoothed_state_disturbance</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_smoothed_state_disturbance_cov(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results_a.smoothed_state_disturbance_cov</span><span class="s2">,</span>
            <span class="s1">self.results_b.smoothed_state_disturbance_cov</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_simulation_smoothed_state(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.sim_a.simulated_state</span><span class="s2">,</span>
            <span class="s1">self.sim_a.simulated_state</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_simulation_smoothed_measurement_disturbance(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.sim_a.simulated_measurement_disturbance</span><span class="s2">,</span>
            <span class="s1">self.sim_a.simulated_measurement_disturbance</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_simulation_smoothed_state_disturbance(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.sim_a.simulated_state_disturbance</span><span class="s2">,</span>
            <span class="s1">self.sim_a.simulated_state_disturbance</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestTrivariateConventional(Trivariate):</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">dtype=float</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(TestTrivariateConventional</span><span class="s2">, </span><span class="s1">cls).setup_class(dtype</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s1">nobs = cls.model.nobs</span>
        <span class="s1">k_endog = cls.model.k_endog</span>
        <span class="s1">k_posdef = cls.model.k_posdef</span>

        <span class="s3"># Collapsed filtering, smoothing, and simulation smoothing</span>
        <span class="s1">cls.model.filter_conventional = </span><span class="s2">True</span>
        <span class="s1">cls.model.filter_collapsed = </span><span class="s2">True</span>
        <span class="s1">cls.results_b = cls.model.smooth()</span>
        <span class="s1">cls.sim_b = cls.model.simulation_smoother(</span>
            <span class="s1">measurement_disturbance_variates=np.zeros(nobs * k_endog)</span><span class="s2">,</span>
            <span class="s1">state_disturbance_variates=np.zeros(nobs * k_posdef)</span><span class="s2">,</span>
            <span class="s1">initial_state_variates=np.zeros(cls.model.k_states)</span>
        <span class="s1">)</span>

        <span class="s3"># Conventional filtering, smoothing, and simulation smoothing</span>
        <span class="s1">cls.model.filter_collapsed = </span><span class="s2">False</span>
        <span class="s1">cls.results_a = cls.model.smooth()</span>
        <span class="s1">cls.sim_a = cls.model.simulation_smoother(</span>
            <span class="s1">measurement_disturbance_variates=np.zeros(nobs * k_endog)</span><span class="s2">,</span>
            <span class="s1">state_disturbance_variates=np.zeros(nobs * k_posdef)</span><span class="s2">,</span>
            <span class="s1">initial_state_variates=np.zeros(cls.model.k_states)</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestTrivariateConventionalAlternate(TestTrivariateConventional):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(TestTrivariateConventionalAlternate</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">alternate_timing=</span><span class="s2">True, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">test_using_alterate(self):</span>
        <span class="s2">assert </span><span class="s1">self.model._kalman_filter.filter_timing == </span><span class="s5">1</span>


<span class="s2">class </span><span class="s1">TestTrivariateConventionalPartialMissing(Trivariate):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">dtype=float</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(TestTrivariateConventionalPartialMissing</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">dtype</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">nobs = cls.model.nobs</span>
        <span class="s1">k_endog = cls.model.k_endog</span>
        <span class="s1">k_posdef = cls.model.k_posdef</span>

        <span class="s3"># Set partially missing data</span>
        <span class="s1">cls.model.endog[:</span><span class="s5">2</span><span class="s2">, </span><span class="s5">10</span><span class="s1">:</span><span class="s5">180</span><span class="s1">] = np.nan</span>

        <span class="s3"># Collapsed filtering, smoothing, and simulation smoothing</span>
        <span class="s1">cls.model.filter_conventional = </span><span class="s2">True</span>
        <span class="s1">cls.model.filter_collapsed = </span><span class="s2">True</span>
        <span class="s1">cls.results_b = cls.model.smooth()</span>
        <span class="s1">cls.sim_b = cls.model.simulation_smoother(</span>
            <span class="s1">measurement_disturbance_variates=np.zeros(nobs * k_endog)</span><span class="s2">,</span>
            <span class="s1">state_disturbance_variates=np.zeros(nobs * k_posdef)</span><span class="s2">,</span>
            <span class="s1">initial_state_variates=np.zeros(cls.model.k_states)</span>
        <span class="s1">)</span>

        <span class="s3"># Conventional filtering, smoothing, and simulation smoothing</span>
        <span class="s1">cls.model.filter_collapsed = </span><span class="s2">False</span>
        <span class="s1">cls.results_a = cls.model.smooth()</span>
        <span class="s1">cls.sim_a = cls.model.simulation_smoother(</span>
            <span class="s1">measurement_disturbance_variates=np.zeros(nobs * k_endog)</span><span class="s2">,</span>
            <span class="s1">state_disturbance_variates=np.zeros(nobs * k_posdef)</span><span class="s2">,</span>
            <span class="s1">initial_state_variates=np.zeros(cls.model.k_states)</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestTrivariateConventionalPartialMissingAlternate(</span>
        <span class="s1">TestTrivariateConventionalPartialMissing):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(TestTrivariateConventionalPartialMissingAlternate</span><span class="s2">,</span>
              <span class="s1">cls).setup_class(alternate_timing=</span><span class="s2">True, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">test_using_alterate(self):</span>
        <span class="s2">assert </span><span class="s1">self.model._kalman_filter.filter_timing == </span><span class="s5">1</span>


<span class="s2">class </span><span class="s1">TestTrivariateConventionalAllMissing(Trivariate):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">dtype=float</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(TestTrivariateConventionalAllMissing</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">dtype</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">nobs = cls.model.nobs</span>
        <span class="s1">k_endog = cls.model.k_endog</span>
        <span class="s1">k_posdef = cls.model.k_posdef</span>

        <span class="s3"># Set partially missing data</span>
        <span class="s1">cls.model.endog[:</span><span class="s2">, </span><span class="s5">10</span><span class="s1">:</span><span class="s5">180</span><span class="s1">] = np.nan</span>

        <span class="s3"># Collapsed filtering, smoothing, and simulation smoothing</span>
        <span class="s1">cls.model.filter_conventional = </span><span class="s2">True</span>
        <span class="s1">cls.model.filter_collapsed = </span><span class="s2">True</span>
        <span class="s1">cls.results_b = cls.model.smooth()</span>
        <span class="s1">cls.sim_b = cls.model.simulation_smoother(</span>
            <span class="s1">measurement_disturbance_variates=np.zeros(nobs * k_endog)</span><span class="s2">,</span>
            <span class="s1">state_disturbance_variates=np.zeros(nobs * k_posdef)</span><span class="s2">,</span>
            <span class="s1">initial_state_variates=np.zeros(cls.model.k_states)</span>
        <span class="s1">)</span>

        <span class="s3"># Conventional filtering, smoothing, and simulation smoothing</span>
        <span class="s1">cls.model.filter_collapsed = </span><span class="s2">False</span>
        <span class="s1">cls.results_a = cls.model.smooth()</span>
        <span class="s1">cls.sim_a = cls.model.simulation_smoother(</span>
            <span class="s1">measurement_disturbance_variates=np.zeros(nobs * k_endog)</span><span class="s2">,</span>
            <span class="s1">state_disturbance_variates=np.zeros(nobs * k_posdef)</span><span class="s2">,</span>
            <span class="s1">initial_state_variates=np.zeros(cls.model.k_states)</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestTrivariateConventionalAllMissingAlternate(</span>
        <span class="s1">TestTrivariateConventionalAllMissing):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(TestTrivariateConventionalAllMissingAlternate</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">alternate_timing=</span><span class="s2">True, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">test_using_alterate(self):</span>
        <span class="s2">assert </span><span class="s1">self.model._kalman_filter.filter_timing == </span><span class="s5">1</span>


<span class="s2">class </span><span class="s1">TestTrivariateUnivariate(Trivariate):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">dtype=float</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(TestTrivariateUnivariate</span><span class="s2">, </span><span class="s1">cls).setup_class(dtype</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">nobs = cls.model.nobs</span>
        <span class="s1">k_endog = cls.model.k_endog</span>
        <span class="s1">k_posdef = cls.model.k_posdef</span>

        <span class="s3"># Collapsed filtering, smoothing, and simulation smoothing</span>
        <span class="s1">cls.model.filter_univariate = </span><span class="s2">True</span>
        <span class="s1">cls.model.filter_collapsed = </span><span class="s2">True</span>
        <span class="s1">cls.results_b = cls.model.smooth()</span>
        <span class="s1">cls.sim_b = cls.model.simulation_smoother(</span>
            <span class="s1">measurement_disturbance_variates=np.zeros(nobs * k_endog)</span><span class="s2">,</span>
            <span class="s1">state_disturbance_variates=np.zeros(nobs * k_posdef)</span><span class="s2">,</span>
            <span class="s1">initial_state_variates=np.zeros(cls.model.k_states)</span>
        <span class="s1">)</span>

        <span class="s3"># Univariate filtering, smoothing, and simulation smoothing</span>
        <span class="s1">cls.model.filter_collapsed = </span><span class="s2">False</span>
        <span class="s1">cls.results_a = cls.model.smooth()</span>
        <span class="s1">cls.sim_a = cls.model.simulation_smoother(</span>
            <span class="s1">measurement_disturbance_variates=np.zeros(nobs * k_endog)</span><span class="s2">,</span>
            <span class="s1">state_disturbance_variates=np.zeros(nobs * k_posdef)</span><span class="s2">,</span>
            <span class="s1">initial_state_variates=np.zeros(cls.model.k_states)</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestTrivariateUnivariateAlternate(TestTrivariateUnivariate):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(TestTrivariateUnivariateAlternate</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">alternate_timing=</span><span class="s2">True, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">test_using_alterate(self):</span>
        <span class="s2">assert </span><span class="s1">self.model._kalman_filter.filter_timing == </span><span class="s5">1</span>


<span class="s2">class </span><span class="s1">TestTrivariateUnivariatePartialMissing(Trivariate):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">dtype=float</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(TestTrivariateUnivariatePartialMissing</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">dtype</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">nobs = cls.model.nobs</span>
        <span class="s1">k_endog = cls.model.k_endog</span>
        <span class="s1">k_posdef = cls.model.k_posdef</span>

        <span class="s3"># Set partially missing data</span>
        <span class="s1">cls.model.endog[:</span><span class="s5">2</span><span class="s2">, </span><span class="s5">10</span><span class="s1">:</span><span class="s5">180</span><span class="s1">] = np.nan</span>

        <span class="s3"># Collapsed filtering, smoothing, and simulation smoothing</span>
        <span class="s1">cls.model.filter_univariate = </span><span class="s2">True</span>
        <span class="s1">cls.model.filter_collapsed = </span><span class="s2">True</span>
        <span class="s1">cls.results_b = cls.model.smooth()</span>
        <span class="s1">cls.sim_b = cls.model.simulation_smoother(</span>
            <span class="s1">measurement_disturbance_variates=np.zeros(nobs * k_endog)</span><span class="s2">,</span>
            <span class="s1">state_disturbance_variates=np.zeros(nobs * k_posdef)</span><span class="s2">,</span>
            <span class="s1">initial_state_variates=np.zeros(cls.model.k_states)</span>
        <span class="s1">)</span>

        <span class="s3"># Univariate filtering, smoothing, and simulation smoothing</span>
        <span class="s1">cls.model.filter_collapsed = </span><span class="s2">False</span>
        <span class="s1">cls.results_a = cls.model.smooth()</span>
        <span class="s1">cls.sim_a = cls.model.simulation_smoother(</span>
            <span class="s1">measurement_disturbance_variates=np.zeros(nobs * k_endog)</span><span class="s2">,</span>
            <span class="s1">state_disturbance_variates=np.zeros(nobs * k_posdef)</span><span class="s2">,</span>
            <span class="s1">initial_state_variates=np.zeros(cls.model.k_states)</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestTrivariateUnivariatePartialMissingAlternate(</span>
        <span class="s1">TestTrivariateUnivariatePartialMissing):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(TestTrivariateUnivariatePartialMissingAlternate</span><span class="s2">,</span>
              <span class="s1">cls).setup_class(alternate_timing=</span><span class="s2">True, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">test_using_alterate(self):</span>
        <span class="s2">assert </span><span class="s1">self.model._kalman_filter.filter_timing == </span><span class="s5">1</span>


<span class="s2">class </span><span class="s1">TestTrivariateUnivariateAllMissing(Trivariate):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">dtype=float</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(TestTrivariateUnivariateAllMissing</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">dtype</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">nobs = cls.model.nobs</span>
        <span class="s1">k_endog = cls.model.k_endog</span>
        <span class="s1">k_posdef = cls.model.k_posdef</span>

        <span class="s3"># Set partially missing data</span>
        <span class="s1">cls.model.endog[:</span><span class="s2">, </span><span class="s5">10</span><span class="s1">:</span><span class="s5">180</span><span class="s1">] = np.nan</span>

        <span class="s3"># Univariate filtering, smoothing, and simulation smoothing</span>
        <span class="s1">cls.model.filter_univariate = </span><span class="s2">True</span>
        <span class="s1">cls.model.filter_collapsed = </span><span class="s2">True</span>
        <span class="s1">cls.results_b = cls.model.smooth()</span>
        <span class="s1">cls.sim_b = cls.model.simulation_smoother(</span>
            <span class="s1">measurement_disturbance_variates=np.zeros(nobs * k_endog)</span><span class="s2">,</span>
            <span class="s1">state_disturbance_variates=np.zeros(nobs * k_posdef)</span><span class="s2">,</span>
            <span class="s1">initial_state_variates=np.zeros(cls.model.k_states)</span>
        <span class="s1">)</span>

        <span class="s3"># Conventional filtering, smoothing, and simulation smoothing</span>
        <span class="s1">cls.model.filter_collapsed = </span><span class="s2">False</span>
        <span class="s1">cls.results_a = cls.model.smooth()</span>
        <span class="s1">cls.sim_a = cls.model.simulation_smoother(</span>
            <span class="s1">measurement_disturbance_variates=np.zeros(nobs * k_endog)</span><span class="s2">,</span>
            <span class="s1">state_disturbance_variates=np.zeros(nobs * k_posdef)</span><span class="s2">,</span>
            <span class="s1">initial_state_variates=np.zeros(cls.model.k_states)</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestTrivariateUnivariateAllMissingAlternate(</span>
        <span class="s1">TestTrivariateUnivariateAllMissing):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(TestTrivariateUnivariateAllMissingAlternate</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">alternate_timing=</span><span class="s2">True, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">test_using_alterate(self):</span>
        <span class="s2">assert </span><span class="s1">self.model._kalman_filter.filter_timing == </span><span class="s5">1</span>


<span class="s2">class </span><span class="s1">TestDFM:</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">create_model(cls</span><span class="s2">, </span><span class="s1">obs</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s3"># Create the model with typical state space</span>
        <span class="s1">mod = MLEModel(obs</span><span class="s2">, </span><span class="s1">k_states=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">k_posdef=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">mod[</span><span class="s4">'design'</span><span class="s1">] = np.array([[-</span><span class="s5">32.47143586</span><span class="s2">, </span><span class="s5">17.33779024</span><span class="s1">]</span><span class="s2">,</span>
                                  <span class="s1">[-</span><span class="s5">7.40264169</span><span class="s2">, </span><span class="s5">1.69279859</span><span class="s1">]</span><span class="s2">,</span>
                                  <span class="s1">[-</span><span class="s5">209.04702853</span><span class="s2">, </span><span class="s5">125.2879374</span><span class="s1">]])</span>
        <span class="s1">mod[</span><span class="s4">'obs_cov'</span><span class="s1">] = np.diag(</span>
            <span class="s1">np.array([</span><span class="s5">0.0622668</span><span class="s2">, </span><span class="s5">1.95666886</span><span class="s2">, </span><span class="s5">58.37473642</span><span class="s1">]))</span>
        <span class="s1">mod[</span><span class="s4">'transition'</span><span class="s1">] = np.array([[</span><span class="s5">0.29935707</span><span class="s2">, </span><span class="s5">0.33289005</span><span class="s1">]</span><span class="s2">,</span>
                                      <span class="s1">[-</span><span class="s5">0.7639868</span><span class="s2">, </span><span class="s5">1.2844237</span><span class="s1">]])</span>
        <span class="s1">mod[</span><span class="s4">'selection'</span><span class="s1">] = np.eye(</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">mod[</span><span class="s4">'state_cov'</span><span class="s1">] = np.array([[</span><span class="s5">1.2</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.25</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[-</span><span class="s5">0.25</span><span class="s2">, </span><span class="s5">1.1</span><span class="s1">]])</span>
        <span class="s1">mod.initialize_approximate_diffuse(</span><span class="s5">1e6</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">mod</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">collapse(cls</span><span class="s2">, </span><span class="s1">obs</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">mod = cls.create_model(obs</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">mod.smooth([]</span><span class="s2">, </span><span class="s1">return_ssm=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s1">_ss = mod.ssm._statespace</span>
        <span class="s1">out = np.zeros((mod.nobs</span><span class="s2">, </span><span class="s1">mod.k_states))</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">range(mod.nobs):</span>
            <span class="s1">_ss.seek(t</span><span class="s2">, </span><span class="s1">mod.ssm.filter_univariate</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">out[t] = np.array(_ss.collapse_obs)</span>
        <span class="s2">return </span><span class="s1">out</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">which=</span><span class="s4">'mixed'</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s3"># Data</span>
        <span class="s1">dta = datasets.macrodata.load_pandas().data</span>
        <span class="s1">dta.index = pd.date_range(start=</span><span class="s4">'1959-01-01'</span><span class="s2">,</span>
                                  <span class="s1">end=</span><span class="s4">'2009-7-01'</span><span class="s2">, </span><span class="s1">freq=</span><span class="s4">'QS'</span><span class="s1">)</span>
        <span class="s1">levels = dta[[</span><span class="s4">'realgdp'</span><span class="s2">, </span><span class="s4">'realcons'</span><span class="s2">, </span><span class="s4">'realinv'</span><span class="s1">]]</span>
        <span class="s1">obs = np.log(levels).diff().iloc[</span><span class="s5">1</span><span class="s1">:] * </span><span class="s5">400</span>

        <span class="s2">if </span><span class="s1">which == </span><span class="s4">'all'</span><span class="s1">:</span>
            <span class="s1">obs.iloc[:</span><span class="s5">50</span><span class="s2">, </span><span class="s1">:] = np.nan</span>
            <span class="s1">obs.iloc[</span><span class="s5">119</span><span class="s1">:</span><span class="s5">130</span><span class="s2">, </span><span class="s1">:] = np.nan</span>
        <span class="s2">elif </span><span class="s1">which == </span><span class="s4">'partial'</span><span class="s1">:</span>
            <span class="s1">obs.iloc[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">50</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = np.nan</span>
            <span class="s1">obs.iloc[</span><span class="s5">119</span><span class="s1">:</span><span class="s5">130</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = np.nan</span>
        <span class="s2">elif </span><span class="s1">which == </span><span class="s4">'mixed'</span><span class="s1">:</span>
            <span class="s1">obs.iloc[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">50</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = np.nan</span>
            <span class="s1">obs.iloc[</span><span class="s5">19</span><span class="s1">:</span><span class="s5">70</span><span class="s2">, </span><span class="s5">1</span><span class="s1">] = np.nan</span>
            <span class="s1">obs.iloc[</span><span class="s5">39</span><span class="s1">:</span><span class="s5">90</span><span class="s2">, </span><span class="s5">2</span><span class="s1">] = np.nan</span>
            <span class="s1">obs.iloc[</span><span class="s5">119</span><span class="s1">:</span><span class="s5">130</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = np.nan</span>
            <span class="s1">obs.iloc[</span><span class="s5">119</span><span class="s1">:</span><span class="s5">130</span><span class="s2">, </span><span class="s5">2</span><span class="s1">] = np.nan</span>

        <span class="s1">mod = cls.create_model(obs</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">cls.model = mod.ssm</span>

        <span class="s1">nobs = cls.model.nobs</span>
        <span class="s1">k_endog = cls.model.k_endog</span>
        <span class="s1">k_posdef = cls.model.k_posdef</span>

        <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
        <span class="s1">mdv = np.random.normal(size=nobs * k_endog)</span>
        <span class="s1">sdv = np.random.normal(size=nobs * k_posdef)</span>
        <span class="s1">isv = np.random.normal(size=cls.model.k_states)</span>

        <span class="s3"># Collapsed filtering, smoothing, and simulation smoothing</span>
        <span class="s1">cls.model.filter_collapsed = </span><span class="s2">True</span>
        <span class="s1">cls.results_b = cls.model.smooth()</span>
        <span class="s1">cls.sim_b = cls.model.simulation_smoother()</span>
        <span class="s1">cls.sim_b.simulate(measurement_disturbance_variates=mdv</span><span class="s2">,</span>
                           <span class="s1">state_disturbance_variates=sdv</span><span class="s2">,</span>
                           <span class="s1">initial_state_variates=isv)</span>

        <span class="s3"># Conventional filtering, smoothing, and simulation smoothing</span>
        <span class="s1">cls.model.filter_collapsed = </span><span class="s2">False</span>
        <span class="s1">cls.results_a = cls.model.smooth()</span>
        <span class="s1">cls.sim_a = cls.model.simulation_smoother()</span>
        <span class="s1">cls.sim_a.simulate(measurement_disturbance_variates=mdv</span><span class="s2">,</span>
                           <span class="s1">state_disturbance_variates=sdv</span><span class="s2">,</span>
                           <span class="s1">initial_state_variates=isv)</span>

        <span class="s3"># Create the model with augmented state space</span>
        <span class="s1">kwargs.pop(</span><span class="s4">'filter_collapsed'</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">mod = MLEModel(obs</span><span class="s2">, </span><span class="s1">k_states=</span><span class="s5">4</span><span class="s2">, </span><span class="s1">k_posdef=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">mod[</span><span class="s4">'design'</span><span class="s2">, </span><span class="s1">:</span><span class="s5">3</span><span class="s2">, </span><span class="s1">:</span><span class="s5">2</span><span class="s1">] = np.array([[-</span><span class="s5">32.47143586</span><span class="s2">, </span><span class="s5">17.33779024</span><span class="s1">]</span><span class="s2">,</span>
                                          <span class="s1">[-</span><span class="s5">7.40264169</span><span class="s2">, </span><span class="s5">1.69279859</span><span class="s1">]</span><span class="s2">,</span>
                                          <span class="s1">[-</span><span class="s5">209.04702853</span><span class="s2">, </span><span class="s5">125.2879374</span><span class="s1">]])</span>
        <span class="s1">mod[</span><span class="s4">'obs_cov'</span><span class="s1">] = np.diag(</span>
            <span class="s1">np.array([</span><span class="s5">0.0622668</span><span class="s2">, </span><span class="s5">1.95666886</span><span class="s2">, </span><span class="s5">58.37473642</span><span class="s1">]))</span>
        <span class="s1">mod[</span><span class="s4">'transition'</span><span class="s2">, </span><span class="s1">:</span><span class="s5">2</span><span class="s2">, </span><span class="s1">:</span><span class="s5">2</span><span class="s1">] = np.array([[</span><span class="s5">0.29935707</span><span class="s2">, </span><span class="s5">0.33289005</span><span class="s1">]</span><span class="s2">,</span>
                                              <span class="s1">[-</span><span class="s5">0.7639868</span><span class="s2">, </span><span class="s5">1.2844237</span><span class="s1">]])</span>
        <span class="s1">mod[</span><span class="s4">'transition'</span><span class="s2">, </span><span class="s5">2</span><span class="s1">:</span><span class="s2">, </span><span class="s1">:</span><span class="s5">2</span><span class="s1">] = np.eye(</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">mod[</span><span class="s4">'selection'</span><span class="s2">, </span><span class="s1">:</span><span class="s5">2</span><span class="s2">, </span><span class="s1">:</span><span class="s5">2</span><span class="s1">] = np.eye(</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">mod[</span><span class="s4">'state_cov'</span><span class="s1">] = np.array([[</span><span class="s5">1.2</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.25</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[-</span><span class="s5">0.25</span><span class="s2">, </span><span class="s5">1.1</span><span class="s1">]])</span>

        <span class="s1">mod.initialize_approximate_diffuse(</span><span class="s5">1e6</span><span class="s1">)</span>
        <span class="s1">cls.augmented_model = mod.ssm</span>
        <span class="s1">cls.augmented_results = mod.ssm.smooth()</span>

    <span class="s2">def </span><span class="s1">test_using_collapsed(self):</span>
        <span class="s3"># Test to make sure the results_b actually used a collapsed Kalman</span>
        <span class="s3"># filtering approach (i.e. that the flag being set actually caused the</span>
        <span class="s3"># filter to not use the conventional filter)</span>

        <span class="s2">assert not </span><span class="s1">self.results_a.filter_collapsed</span>
        <span class="s2">assert </span><span class="s1">self.results_b.filter_collapsed</span>

        <span class="s2">assert </span><span class="s1">self.results_a.collapsed_forecasts </span><span class="s2">is None</span>
        <span class="s2">assert </span><span class="s1">self.results_b.collapsed_forecasts </span><span class="s2">is not None</span>

        <span class="s1">assert_equal(self.results_a.forecasts.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">assert_equal(self.results_b.collapsed_forecasts.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_forecasts(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results_a.forecasts[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">,</span>
            <span class="s1">self.results_b.forecasts[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_forecasts_error(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results_a.forecasts_error[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">,</span>
            <span class="s1">self.results_b.forecasts_error[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_forecasts_error_cov(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results_a.forecasts_error_cov[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">,</span>
            <span class="s1">self.results_b.forecasts_error_cov[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_filtered_state(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results_a.filtered_state</span><span class="s2">,</span>
            <span class="s1">self.results_b.filtered_state</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_filtered_state_cov(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results_a.filtered_state_cov</span><span class="s2">,</span>
            <span class="s1">self.results_b.filtered_state_cov</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_predicted_state(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results_a.predicted_state</span><span class="s2">,</span>
            <span class="s1">self.results_b.predicted_state</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_predicted_state_cov(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results_a.predicted_state_cov</span><span class="s2">,</span>
            <span class="s1">self.results_b.predicted_state_cov</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_loglike(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results_a.llf_obs</span><span class="s2">,</span>
            <span class="s1">self.results_b.llf_obs</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_smoothed_states(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results_a.smoothed_state</span><span class="s2">,</span>
            <span class="s1">self.results_b.smoothed_state</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_smoothed_states_cov(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results_a.smoothed_state_cov</span><span class="s2">,</span>
            <span class="s1">self.results_b.smoothed_state_cov</span><span class="s2">,</span>
            <span class="s1">atol=</span><span class="s5">1e-4</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_smoothed_states_autocov(self):</span>
        <span class="s3"># Cov(\alpha_{t+1}, \alpha_t)</span>
        <span class="s3"># Test collapsed against non-collapsed</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results_a.smoothed_state_autocov</span><span class="s2">,</span>
            <span class="s1">self.results_b.smoothed_state_autocov</span>
        <span class="s1">)</span>

        <span class="s3"># Directly test using the augmented model</span>
        <span class="s3"># Initialization makes these two methods slightly different for the</span>
        <span class="s3"># first few observations</span>
        <span class="s1">assert_allclose(self.results_a.smoothed_state_autocov[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">:</span><span class="s5">5</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">self.augmented_results.smoothed_state_cov[:</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s1">:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">:</span><span class="s5">6</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">atol=</span><span class="s5">1e-4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(self.results_a.smoothed_state_autocov[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s5">5</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">self.augmented_results.smoothed_state_cov[:</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s1">:</span><span class="s2">, </span><span class="s5">6</span><span class="s1">:]</span><span class="s2">,</span>
                        <span class="s1">atol=</span><span class="s5">1e-7</span><span class="s1">)</span>

    <span class="s3"># Skipped because &quot;measurement&quot; refers to different things; even different</span>
    <span class="s3"># dimensions</span>
    <span class="s1">@pytest.mark.skip</span>
    <span class="s2">def </span><span class="s1">test_smoothed_measurement_disturbance(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results_a.smoothed_measurement_disturbance</span><span class="s2">,</span>
            <span class="s1">self.results_b.smoothed_measurement_disturbance</span>
        <span class="s1">)</span>

    <span class="s3"># Skipped because &quot;measurement&quot; refers to different things; even different</span>
    <span class="s3"># dimensions</span>
    <span class="s1">@pytest.mark.skip</span>
    <span class="s2">def </span><span class="s1">test_smoothed_measurement_disturbance_cov(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results_a.smoothed_measurement_disturbance_cov</span><span class="s2">,</span>
            <span class="s1">self.results_b.smoothed_measurement_disturbance_cov</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_smoothed_state_disturbance(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results_a.smoothed_state_disturbance</span><span class="s2">,</span>
            <span class="s1">self.results_b.smoothed_state_disturbance</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_smoothed_state_disturbance_cov(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results_a.smoothed_state_disturbance_cov</span><span class="s2">,</span>
            <span class="s1">self.results_b.smoothed_state_disturbance_cov</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_simulation_smoothed_state(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.sim_a.simulated_state</span><span class="s2">,</span>
            <span class="s1">self.sim_b.simulated_state</span>
        <span class="s1">)</span>

    <span class="s3"># Skipped because &quot;measurement&quot; refers to different things; even different</span>
    <span class="s3"># dimensions</span>
    <span class="s1">@pytest.mark.skip</span>
    <span class="s2">def </span><span class="s1">test_simulation_smoothed_measurement_disturbance(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.sim_a.simulated_measurement_disturbance</span><span class="s2">,</span>
            <span class="s1">self.sim_b.simulated_measurement_disturbance</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_simulation_smoothed_state_disturbance(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.sim_a.simulated_state_disturbance</span><span class="s2">,</span>
            <span class="s1">self.sim_b.simulated_state_disturbance</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestDFMClassicalSmoothing(TestDFM):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(TestDFMClassicalSmoothing</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">smooth_method=SMOOTH_CLASSICAL</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">test_smooth_method(self):</span>
        <span class="s1">assert_equal(self.model.smooth_method</span><span class="s2">, </span><span class="s1">SMOOTH_CLASSICAL)</span>
        <span class="s1">assert_equal(self.model._kalman_smoother.smooth_method</span><span class="s2">,</span>
                     <span class="s1">SMOOTH_CLASSICAL)</span>
        <span class="s1">assert_equal(self.model._kalman_smoother._smooth_method</span><span class="s2">,</span>
                     <span class="s1">SMOOTH_CLASSICAL)</span>


<span class="s2">class </span><span class="s1">TestDFMUnivariateSmoothing(TestDFM):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(TestDFMUnivariateSmoothing</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">filter_method=FILTER_UNIVARIATE</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">test_smooth_method(self):</span>
        <span class="s1">assert_equal(self.model.smooth_method</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(self.model._kalman_smoother.smooth_method</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(self.model._kalman_smoother._smooth_method</span><span class="s2">,</span>
                     <span class="s1">SMOOTH_UNIVARIATE)</span>


<span class="s2">class </span><span class="s1">TestDFMAlternativeSmoothing(TestDFM):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(TestDFMAlternativeSmoothing</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">smooth_method=SMOOTH_ALTERNATIVE</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">test_smooth_method(self):</span>
        <span class="s1">assert_equal(self.model.smooth_method</span><span class="s2">, </span><span class="s1">SMOOTH_ALTERNATIVE)</span>
        <span class="s1">assert_equal(self.model._kalman_smoother.smooth_method</span><span class="s2">,</span>
                     <span class="s1">SMOOTH_ALTERNATIVE)</span>
        <span class="s1">assert_equal(self.model._kalman_smoother._smooth_method</span><span class="s2">,</span>
                     <span class="s1">SMOOTH_ALTERNATIVE)</span>


<span class="s2">class </span><span class="s1">TestDFMMeasurementDisturbance(TestDFM):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(TestDFMMeasurementDisturbance</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">smooth_method=SMOOTH_CLASSICAL</span><span class="s2">, </span><span class="s1">which=</span><span class="s4">'none'</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">test_smoothed_state_disturbance(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results_a.smoothed_state_disturbance</span><span class="s2">,</span>
            <span class="s1">self.results_b.smoothed_state_disturbance</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-7</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_smoothed_measurement_disturbance(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.collapse(self.results_a.smoothed_measurement_disturbance.T).T</span><span class="s2">,</span>
            <span class="s1">self.results_b.smoothed_measurement_disturbance</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-7</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_simulation_smoothed_measurement_disturbance(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.collapse(self.sim_a.simulated_measurement_disturbance.T)</span><span class="s2">,</span>
            <span class="s1">self.sim_b.simulated_measurement_disturbance.T</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-7</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_simulation_smoothed_state_disturbance(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.sim_a.simulated_state_disturbance</span><span class="s2">,</span>
            <span class="s1">self.sim_b.simulated_state_disturbance</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-7</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_dfm_missing(reset_randomstate):</span>
    <span class="s3"># This test is not captured by the TestTrivariate and TestDFM tests above</span>
    <span class="s3"># because it has k_states = 1</span>
    <span class="s1">endog = np.random.normal(size=(</span><span class="s5">100</span><span class="s2">, </span><span class="s5">3</span><span class="s1">))</span>
    <span class="s1">endog[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:</span><span class="s5">1</span><span class="s1">] = np.nan</span>

    <span class="s1">mod = dynamic_factor.DynamicFactor(endog</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">mod.ssm.filter_collapsed = </span><span class="s2">True</span>
    <span class="s1">res = mod.smooth(mod.start_params)</span>
    <span class="s1">mod.ssm.filter_collapsed = </span><span class="s2">False</span>
    <span class="s1">res2 = mod.smooth(mod.start_params)</span>

    <span class="s1">assert_allclose(res.llf</span><span class="s2">, </span><span class="s1">res2.llf)</span>
</pre>
</body>
</html>