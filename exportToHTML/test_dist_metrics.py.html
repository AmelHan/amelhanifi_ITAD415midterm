<html>
<head>
<title>test_dist_metrics.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_dist_metrics.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">copy</span>
<span class="s0">import </span><span class="s1">itertools</span>
<span class="s0">import </span><span class="s1">pickle</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">import </span><span class="s1">scipy.sparse </span><span class="s0">as </span><span class="s1">sp</span>
<span class="s0">from </span><span class="s1">scipy.spatial.distance </span><span class="s0">import </span><span class="s1">cdist</span>

<span class="s0">from </span><span class="s1">sklearn.metrics </span><span class="s0">import </span><span class="s1">DistanceMetric</span>
<span class="s0">from </span><span class="s1">sklearn.metrics._dist_metrics </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">BOOL_METRICS</span><span class="s0">,</span>
    <span class="s1">DistanceMetric32</span><span class="s0">,</span>
    <span class="s1">DistanceMetric64</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">sklearn.utils </span><span class="s0">import </span><span class="s1">check_random_state</span>
<span class="s0">from </span><span class="s1">sklearn.utils._testing </span><span class="s0">import </span><span class="s1">assert_allclose</span><span class="s0">, </span><span class="s1">create_memmap_backed_data</span>
<span class="s0">from </span><span class="s1">sklearn.utils.fixes </span><span class="s0">import </span><span class="s1">parse_version</span><span class="s0">, </span><span class="s1">sp_version</span>


<span class="s0">def </span><span class="s1">dist_func(x1</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s1">p):</span>
    <span class="s0">return </span><span class="s1">np.sum((x1 - x2) ** p) ** (</span><span class="s2">1.0 </span><span class="s1">/ p)</span>


<span class="s1">rng = check_random_state(</span><span class="s2">0</span><span class="s1">)</span>
<span class="s1">d = </span><span class="s2">4</span>
<span class="s1">n1 = </span><span class="s2">20</span>
<span class="s1">n2 = </span><span class="s2">25</span>
<span class="s1">X64 = rng.random_sample((n1</span><span class="s0">, </span><span class="s1">d))</span>
<span class="s1">Y64 = rng.random_sample((n2</span><span class="s0">, </span><span class="s1">d))</span>
<span class="s1">X32 = X64.astype(</span><span class="s3">&quot;float32&quot;</span><span class="s1">)</span>
<span class="s1">Y32 = Y64.astype(</span><span class="s3">&quot;float32&quot;</span><span class="s1">)</span>

<span class="s1">[X_mmap</span><span class="s0">, </span><span class="s1">Y_mmap] = create_memmap_backed_data([X64</span><span class="s0">, </span><span class="s1">Y64])</span>

<span class="s4"># make boolean arrays: ones and zeros</span>
<span class="s1">X_bool = (X64 &lt; </span><span class="s2">0.3</span><span class="s1">).astype(np.float64)  </span><span class="s4"># quite sparse</span>
<span class="s1">Y_bool = (Y64 &lt; </span><span class="s2">0.7</span><span class="s1">).astype(np.float64)  </span><span class="s4"># not too sparse</span>

<span class="s1">[X_bool_mmap</span><span class="s0">, </span><span class="s1">Y_bool_mmap] = create_memmap_backed_data([X_bool</span><span class="s0">, </span><span class="s1">Y_bool])</span>


<span class="s1">V = rng.random_sample((d</span><span class="s0">, </span><span class="s1">d))</span>
<span class="s1">VI = np.dot(V</span><span class="s0">, </span><span class="s1">V.T)</span>

<span class="s1">METRICS_DEFAULT_PARAMS = [</span>
    <span class="s1">(</span><span class="s3">&quot;euclidean&quot;</span><span class="s0">, </span><span class="s1">{})</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;cityblock&quot;</span><span class="s0">, </span><span class="s1">{})</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;minkowski&quot;</span><span class="s0">, </span><span class="s1">dict(p=(</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)))</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;chebyshev&quot;</span><span class="s0">, </span><span class="s1">{})</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;seuclidean&quot;</span><span class="s0">, </span><span class="s1">dict(V=(rng.random_sample(d)</span><span class="s0">,</span><span class="s1">)))</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;mahalanobis&quot;</span><span class="s0">, </span><span class="s1">dict(VI=(VI</span><span class="s0">,</span><span class="s1">)))</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;hamming&quot;</span><span class="s0">, </span><span class="s1">{})</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;canberra&quot;</span><span class="s0">, </span><span class="s1">{})</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;braycurtis&quot;</span><span class="s0">, </span><span class="s1">{})</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;minkowski&quot;</span><span class="s0">, </span><span class="s1">dict(p=(</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">w=(rng.random_sample(d)</span><span class="s0">,</span><span class="s1">)))</span><span class="s0">,</span>
<span class="s1">]</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;metric_param_grid&quot;</span><span class="s0">, </span><span class="s1">METRICS_DEFAULT_PARAMS</span><span class="s0">, </span><span class="s1">ids=</span><span class="s0">lambda </span><span class="s1">params: params[</span><span class="s2">0</span><span class="s1">]</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;X, Y&quot;</span><span class="s0">, </span><span class="s1">[(X64</span><span class="s0">, </span><span class="s1">Y64)</span><span class="s0">, </span><span class="s1">(X32</span><span class="s0">, </span><span class="s1">Y32)</span><span class="s0">, </span><span class="s1">(X_mmap</span><span class="s0">, </span><span class="s1">Y_mmap)])</span>
<span class="s0">def </span><span class="s1">test_cdist(metric_param_grid</span><span class="s0">, </span><span class="s1">X</span><span class="s0">, </span><span class="s1">Y):</span>
    <span class="s1">metric</span><span class="s0">, </span><span class="s1">param_grid = metric_param_grid</span>
    <span class="s1">keys = param_grid.keys()</span>
    <span class="s1">X_csr</span><span class="s0">, </span><span class="s1">Y_csr = sp.csr_matrix(X)</span><span class="s0">, </span><span class="s1">sp.csr_matrix(Y)</span>
    <span class="s0">for </span><span class="s1">vals </span><span class="s0">in </span><span class="s1">itertools.product(*param_grid.values()):</span>
        <span class="s1">kwargs = dict(zip(keys</span><span class="s0">, </span><span class="s1">vals))</span>
        <span class="s1">rtol_dict = {}</span>
        <span class="s0">if </span><span class="s1">metric == </span><span class="s3">&quot;mahalanobis&quot; </span><span class="s0">and </span><span class="s1">X.dtype == np.float32:</span>
            <span class="s4"># Computation of mahalanobis differs between</span>
            <span class="s4"># the scipy and scikit-learn implementation.</span>
            <span class="s4"># Hence, we increase the relative tolerance.</span>
            <span class="s4"># TODO: Inspect slight numerical discrepancy</span>
            <span class="s4"># with scipy</span>
            <span class="s1">rtol_dict = {</span><span class="s3">&quot;rtol&quot;</span><span class="s1">: </span><span class="s2">1e-6</span><span class="s1">}</span>

        <span class="s4"># TODO: Remove when scipy minimum version &gt;= 1.7.0</span>
        <span class="s4"># scipy supports 0&lt;p&lt;1 for minkowski metric &gt;= 1.7.0</span>
        <span class="s0">if </span><span class="s1">metric == </span><span class="s3">&quot;minkowski&quot;</span><span class="s1">:</span>
            <span class="s1">p = kwargs[</span><span class="s3">&quot;p&quot;</span><span class="s1">]</span>
            <span class="s0">if </span><span class="s1">sp_version &lt; parse_version(</span><span class="s3">&quot;1.7.0&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">p &lt; </span><span class="s2">1</span><span class="s1">:</span>
                <span class="s1">pytest.skip(</span><span class="s3">&quot;scipy does not support 0&lt;p&lt;1 for minkowski metric &lt; 1.7.0&quot;</span><span class="s1">)</span>

        <span class="s1">D_scipy_cdist = cdist(X</span><span class="s0">, </span><span class="s1">Y</span><span class="s0">, </span><span class="s1">metric</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s1">dm = DistanceMetric.get_metric(metric</span><span class="s0">, </span><span class="s1">X.dtype</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s4"># DistanceMetric.pairwise must be consistent for all</span>
        <span class="s4"># combinations of formats in {sparse, dense}.</span>
        <span class="s1">D_sklearn = dm.pairwise(X</span><span class="s0">, </span><span class="s1">Y)</span>
        <span class="s0">assert </span><span class="s1">D_sklearn.flags.c_contiguous</span>
        <span class="s1">assert_allclose(D_sklearn</span><span class="s0">, </span><span class="s1">D_scipy_cdist</span><span class="s0">, </span><span class="s1">**rtol_dict)</span>

        <span class="s1">D_sklearn = dm.pairwise(X_csr</span><span class="s0">, </span><span class="s1">Y_csr)</span>
        <span class="s0">assert </span><span class="s1">D_sklearn.flags.c_contiguous</span>
        <span class="s1">assert_allclose(D_sklearn</span><span class="s0">, </span><span class="s1">D_scipy_cdist</span><span class="s0">, </span><span class="s1">**rtol_dict)</span>

        <span class="s1">D_sklearn = dm.pairwise(X_csr</span><span class="s0">, </span><span class="s1">Y)</span>
        <span class="s0">assert </span><span class="s1">D_sklearn.flags.c_contiguous</span>
        <span class="s1">assert_allclose(D_sklearn</span><span class="s0">, </span><span class="s1">D_scipy_cdist</span><span class="s0">, </span><span class="s1">**rtol_dict)</span>

        <span class="s1">D_sklearn = dm.pairwise(X</span><span class="s0">, </span><span class="s1">Y_csr)</span>
        <span class="s0">assert </span><span class="s1">D_sklearn.flags.c_contiguous</span>
        <span class="s1">assert_allclose(D_sklearn</span><span class="s0">, </span><span class="s1">D_scipy_cdist</span><span class="s0">, </span><span class="s1">**rtol_dict)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;metric&quot;</span><span class="s0">, </span><span class="s1">BOOL_METRICS)</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;X_bool, Y_bool&quot;</span><span class="s0">, </span><span class="s1">[(X_bool</span><span class="s0">, </span><span class="s1">Y_bool)</span><span class="s0">, </span><span class="s1">(X_bool_mmap</span><span class="s0">, </span><span class="s1">Y_bool_mmap)]</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_cdist_bool_metric(metric</span><span class="s0">, </span><span class="s1">X_bool</span><span class="s0">, </span><span class="s1">Y_bool):</span>
    <span class="s1">D_scipy_cdist = cdist(X_bool</span><span class="s0">, </span><span class="s1">Y_bool</span><span class="s0">, </span><span class="s1">metric)</span>

    <span class="s1">dm = DistanceMetric.get_metric(metric)</span>
    <span class="s1">D_sklearn = dm.pairwise(X_bool</span><span class="s0">, </span><span class="s1">Y_bool)</span>
    <span class="s1">assert_allclose(D_sklearn</span><span class="s0">, </span><span class="s1">D_scipy_cdist)</span>

    <span class="s4"># DistanceMetric.pairwise must be consistent</span>
    <span class="s4"># on all combinations of format in {sparse, dense}Â².</span>
    <span class="s1">X_bool_csr</span><span class="s0">, </span><span class="s1">Y_bool_csr = sp.csr_matrix(X_bool)</span><span class="s0">, </span><span class="s1">sp.csr_matrix(Y_bool)</span>

    <span class="s1">D_sklearn = dm.pairwise(X_bool</span><span class="s0">, </span><span class="s1">Y_bool)</span>
    <span class="s0">assert </span><span class="s1">D_sklearn.flags.c_contiguous</span>
    <span class="s1">assert_allclose(D_sklearn</span><span class="s0">, </span><span class="s1">D_scipy_cdist)</span>

    <span class="s1">D_sklearn = dm.pairwise(X_bool_csr</span><span class="s0">, </span><span class="s1">Y_bool_csr)</span>
    <span class="s0">assert </span><span class="s1">D_sklearn.flags.c_contiguous</span>
    <span class="s1">assert_allclose(D_sklearn</span><span class="s0">, </span><span class="s1">D_scipy_cdist)</span>

    <span class="s1">D_sklearn = dm.pairwise(X_bool</span><span class="s0">, </span><span class="s1">Y_bool_csr)</span>
    <span class="s0">assert </span><span class="s1">D_sklearn.flags.c_contiguous</span>
    <span class="s1">assert_allclose(D_sklearn</span><span class="s0">, </span><span class="s1">D_scipy_cdist)</span>

    <span class="s1">D_sklearn = dm.pairwise(X_bool_csr</span><span class="s0">, </span><span class="s1">Y_bool)</span>
    <span class="s0">assert </span><span class="s1">D_sklearn.flags.c_contiguous</span>
    <span class="s1">assert_allclose(D_sklearn</span><span class="s0">, </span><span class="s1">D_scipy_cdist)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;metric_param_grid&quot;</span><span class="s0">, </span><span class="s1">METRICS_DEFAULT_PARAMS</span><span class="s0">, </span><span class="s1">ids=</span><span class="s0">lambda </span><span class="s1">params: params[</span><span class="s2">0</span><span class="s1">]</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;X&quot;</span><span class="s0">, </span><span class="s1">[X64</span><span class="s0">, </span><span class="s1">X32</span><span class="s0">, </span><span class="s1">X_mmap])</span>
<span class="s0">def </span><span class="s1">test_pdist(metric_param_grid</span><span class="s0">, </span><span class="s1">X):</span>
    <span class="s1">metric</span><span class="s0">, </span><span class="s1">param_grid = metric_param_grid</span>
    <span class="s1">keys = param_grid.keys()</span>
    <span class="s1">X_csr = sp.csr_matrix(X)</span>
    <span class="s0">for </span><span class="s1">vals </span><span class="s0">in </span><span class="s1">itertools.product(*param_grid.values()):</span>
        <span class="s1">kwargs = dict(zip(keys</span><span class="s0">, </span><span class="s1">vals))</span>
        <span class="s1">rtol_dict = {}</span>
        <span class="s0">if </span><span class="s1">metric == </span><span class="s3">&quot;mahalanobis&quot; </span><span class="s0">and </span><span class="s1">X.dtype == np.float32:</span>
            <span class="s4"># Computation of mahalanobis differs between</span>
            <span class="s4"># the scipy and scikit-learn implementation.</span>
            <span class="s4"># Hence, we increase the relative tolerance.</span>
            <span class="s4"># TODO: Inspect slight numerical discrepancy</span>
            <span class="s4"># with scipy</span>
            <span class="s1">rtol_dict = {</span><span class="s3">&quot;rtol&quot;</span><span class="s1">: </span><span class="s2">1e-6</span><span class="s1">}</span>

        <span class="s4"># TODO: Remove when scipy minimum version &gt;= 1.7.0</span>
        <span class="s4"># scipy supports 0&lt;p&lt;1 for minkowski metric &gt;= 1.7.0</span>
        <span class="s0">if </span><span class="s1">metric == </span><span class="s3">&quot;minkowski&quot;</span><span class="s1">:</span>
            <span class="s1">p = kwargs[</span><span class="s3">&quot;p&quot;</span><span class="s1">]</span>
            <span class="s0">if </span><span class="s1">sp_version &lt; parse_version(</span><span class="s3">&quot;1.7.0&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">p &lt; </span><span class="s2">1</span><span class="s1">:</span>
                <span class="s1">pytest.skip(</span><span class="s3">&quot;scipy does not support 0&lt;p&lt;1 for minkowski metric &lt; 1.7.0&quot;</span><span class="s1">)</span>
        <span class="s1">D_scipy_pdist = cdist(X</span><span class="s0">, </span><span class="s1">X</span><span class="s0">, </span><span class="s1">metric</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s1">dm = DistanceMetric.get_metric(metric</span><span class="s0">, </span><span class="s1">X.dtype</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">D_sklearn = dm.pairwise(X)</span>
        <span class="s0">assert </span><span class="s1">D_sklearn.flags.c_contiguous</span>
        <span class="s1">assert_allclose(D_sklearn</span><span class="s0">, </span><span class="s1">D_scipy_pdist</span><span class="s0">, </span><span class="s1">**rtol_dict)</span>

        <span class="s1">D_sklearn_csr = dm.pairwise(X_csr)</span>
        <span class="s0">assert </span><span class="s1">D_sklearn.flags.c_contiguous</span>
        <span class="s1">assert_allclose(D_sklearn_csr</span><span class="s0">, </span><span class="s1">D_scipy_pdist</span><span class="s0">, </span><span class="s1">**rtol_dict)</span>

        <span class="s1">D_sklearn_csr = dm.pairwise(X_csr</span><span class="s0">, </span><span class="s1">X_csr)</span>
        <span class="s0">assert </span><span class="s1">D_sklearn.flags.c_contiguous</span>
        <span class="s1">assert_allclose(D_sklearn_csr</span><span class="s0">, </span><span class="s1">D_scipy_pdist</span><span class="s0">, </span><span class="s1">**rtol_dict)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;metric_param_grid&quot;</span><span class="s0">, </span><span class="s1">METRICS_DEFAULT_PARAMS</span><span class="s0">, </span><span class="s1">ids=</span><span class="s0">lambda </span><span class="s1">params: params[</span><span class="s2">0</span><span class="s1">]</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_distance_metrics_dtype_consistency(metric_param_grid):</span>
    <span class="s4"># DistanceMetric must return similar distances for both float32 and float64</span>
    <span class="s4"># input data.</span>
    <span class="s1">metric</span><span class="s0">, </span><span class="s1">param_grid = metric_param_grid</span>
    <span class="s1">keys = param_grid.keys()</span>

    <span class="s4"># Choose rtol to make sure that this test is robust to changes in the random</span>
    <span class="s4"># seed in the module-level test data generation code.</span>
    <span class="s1">rtol = </span><span class="s2">1e-5</span>

    <span class="s0">for </span><span class="s1">vals </span><span class="s0">in </span><span class="s1">itertools.product(*param_grid.values()):</span>
        <span class="s1">kwargs = dict(zip(keys</span><span class="s0">, </span><span class="s1">vals))</span>
        <span class="s1">dm64 = DistanceMetric.get_metric(metric</span><span class="s0">, </span><span class="s1">np.float64</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">dm32 = DistanceMetric.get_metric(metric</span><span class="s0">, </span><span class="s1">np.float32</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s1">D64 = dm64.pairwise(X64)</span>
        <span class="s1">D32 = dm32.pairwise(X32)</span>

        <span class="s4"># Both results are np.float64 dtype because the accumulation across</span>
        <span class="s4"># features is done in float64. However the input data and the element</span>
        <span class="s4"># wise arithmetic operations are done in float32 so we can expect a</span>
        <span class="s4"># small discrepancy.</span>
        <span class="s0">assert </span><span class="s1">D64.dtype == D32.dtype == np.float64</span>

        <span class="s4"># assert_allclose introspects the dtype of the input arrays to decide</span>
        <span class="s4"># which rtol value to use by default but in this case we know that D32</span>
        <span class="s4"># is not computed with the same precision so we set rtol manually.</span>
        <span class="s1">assert_allclose(D64</span><span class="s0">, </span><span class="s1">D32</span><span class="s0">, </span><span class="s1">rtol=rtol)</span>

        <span class="s1">D64 = dm64.pairwise(X64</span><span class="s0">, </span><span class="s1">Y64)</span>
        <span class="s1">D32 = dm32.pairwise(X32</span><span class="s0">, </span><span class="s1">Y32)</span>
        <span class="s1">assert_allclose(D64</span><span class="s0">, </span><span class="s1">D32</span><span class="s0">, </span><span class="s1">rtol=rtol)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;metric&quot;</span><span class="s0">, </span><span class="s1">BOOL_METRICS)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;X_bool&quot;</span><span class="s0">, </span><span class="s1">[X_bool</span><span class="s0">, </span><span class="s1">X_bool_mmap])</span>
<span class="s0">def </span><span class="s1">test_pdist_bool_metrics(metric</span><span class="s0">, </span><span class="s1">X_bool):</span>
    <span class="s1">D_scipy_pdist = cdist(X_bool</span><span class="s0">, </span><span class="s1">X_bool</span><span class="s0">, </span><span class="s1">metric)</span>
    <span class="s1">dm = DistanceMetric.get_metric(metric)</span>
    <span class="s1">D_sklearn = dm.pairwise(X_bool)</span>
    <span class="s1">assert_allclose(D_sklearn</span><span class="s0">, </span><span class="s1">D_scipy_pdist)</span>

    <span class="s1">X_bool_csr = sp.csr_matrix(X_bool)</span>
    <span class="s1">D_sklearn = dm.pairwise(X_bool_csr)</span>
    <span class="s1">assert_allclose(D_sklearn</span><span class="s0">, </span><span class="s1">D_scipy_pdist)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;writable_kwargs&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;metric_param_grid&quot;</span><span class="s0">, </span><span class="s1">METRICS_DEFAULT_PARAMS</span><span class="s0">, </span><span class="s1">ids=</span><span class="s0">lambda </span><span class="s1">params: params[</span><span class="s2">0</span><span class="s1">]</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;X&quot;</span><span class="s0">, </span><span class="s1">[X64</span><span class="s0">, </span><span class="s1">X32])</span>
<span class="s0">def </span><span class="s1">test_pickle(writable_kwargs</span><span class="s0">, </span><span class="s1">metric_param_grid</span><span class="s0">, </span><span class="s1">X):</span>
    <span class="s1">metric</span><span class="s0">, </span><span class="s1">param_grid = metric_param_grid</span>
    <span class="s1">keys = param_grid.keys()</span>
    <span class="s0">for </span><span class="s1">vals </span><span class="s0">in </span><span class="s1">itertools.product(*param_grid.values()):</span>
        <span class="s0">if </span><span class="s1">any(isinstance(val</span><span class="s0">, </span><span class="s1">np.ndarray) </span><span class="s0">for </span><span class="s1">val </span><span class="s0">in </span><span class="s1">vals):</span>
            <span class="s1">vals = copy.deepcopy(vals)</span>
            <span class="s0">for </span><span class="s1">val </span><span class="s0">in </span><span class="s1">vals:</span>
                <span class="s0">if </span><span class="s1">isinstance(val</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
                    <span class="s1">val.setflags(write=writable_kwargs)</span>
        <span class="s1">kwargs = dict(zip(keys</span><span class="s0">, </span><span class="s1">vals))</span>
        <span class="s1">dm = DistanceMetric.get_metric(metric</span><span class="s0">, </span><span class="s1">X.dtype</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">D1 = dm.pairwise(X)</span>
        <span class="s1">dm2 = pickle.loads(pickle.dumps(dm))</span>
        <span class="s1">D2 = dm2.pairwise(X)</span>
        <span class="s1">assert_allclose(D1</span><span class="s0">, </span><span class="s1">D2)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;metric&quot;</span><span class="s0">, </span><span class="s1">BOOL_METRICS)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;X_bool&quot;</span><span class="s0">, </span><span class="s1">[X_bool</span><span class="s0">, </span><span class="s1">X_bool_mmap])</span>
<span class="s0">def </span><span class="s1">test_pickle_bool_metrics(metric</span><span class="s0">, </span><span class="s1">X_bool):</span>
    <span class="s1">dm = DistanceMetric.get_metric(metric)</span>
    <span class="s1">D1 = dm.pairwise(X_bool)</span>
    <span class="s1">dm2 = pickle.loads(pickle.dumps(dm))</span>
    <span class="s1">D2 = dm2.pairwise(X_bool)</span>
    <span class="s1">assert_allclose(D1</span><span class="s0">, </span><span class="s1">D2)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;X, Y&quot;</span><span class="s0">, </span><span class="s1">[(X64</span><span class="s0">, </span><span class="s1">Y64)</span><span class="s0">, </span><span class="s1">(X32</span><span class="s0">, </span><span class="s1">Y32)</span><span class="s0">, </span><span class="s1">(X_mmap</span><span class="s0">, </span><span class="s1">Y_mmap)])</span>
<span class="s0">def </span><span class="s1">test_haversine_metric(X</span><span class="s0">, </span><span class="s1">Y):</span>
    <span class="s4"># The Haversine DistanceMetric only works on 2 features.</span>
    <span class="s1">X = np.asarray(X[:</span><span class="s0">, </span><span class="s1">:</span><span class="s2">2</span><span class="s1">])</span>
    <span class="s1">Y = np.asarray(Y[:</span><span class="s0">, </span><span class="s1">:</span><span class="s2">2</span><span class="s1">])</span>

    <span class="s1">X_csr</span><span class="s0">, </span><span class="s1">Y_csr = sp.csr_matrix(X)</span><span class="s0">, </span><span class="s1">sp.csr_matrix(Y)</span>

    <span class="s4"># Haversine is not supported by scipy.special.distance.{cdist,pdist}</span>
    <span class="s4"># So we reimplement it to have a reference.</span>
    <span class="s0">def </span><span class="s1">haversine_slow(x1</span><span class="s0">, </span><span class="s1">x2):</span>
        <span class="s0">return </span><span class="s2">2 </span><span class="s1">* np.arcsin(</span>
            <span class="s1">np.sqrt(</span>
                <span class="s1">np.sin(</span><span class="s2">0.5 </span><span class="s1">* (x1[</span><span class="s2">0</span><span class="s1">] - x2[</span><span class="s2">0</span><span class="s1">])) ** </span><span class="s2">2</span>
                <span class="s1">+ np.cos(x1[</span><span class="s2">0</span><span class="s1">]) * np.cos(x2[</span><span class="s2">0</span><span class="s1">]) * np.sin(</span><span class="s2">0.5 </span><span class="s1">* (x1[</span><span class="s2">1</span><span class="s1">] - x2[</span><span class="s2">1</span><span class="s1">])) ** </span><span class="s2">2</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s1">D_reference = np.zeros((X_csr.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">Y_csr.shape[</span><span class="s2">0</span><span class="s1">]))</span>
    <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">xi </span><span class="s0">in </span><span class="s1">enumerate(X):</span>
        <span class="s0">for </span><span class="s1">j</span><span class="s0">, </span><span class="s1">yj </span><span class="s0">in </span><span class="s1">enumerate(Y):</span>
            <span class="s1">D_reference[i</span><span class="s0">, </span><span class="s1">j] = haversine_slow(xi</span><span class="s0">, </span><span class="s1">yj)</span>

    <span class="s1">haversine = DistanceMetric.get_metric(</span><span class="s3">&quot;haversine&quot;</span><span class="s0">, </span><span class="s1">X.dtype)</span>

    <span class="s1">D_sklearn = haversine.pairwise(X</span><span class="s0">, </span><span class="s1">Y)</span>
    <span class="s1">assert_allclose(</span>
        <span class="s1">haversine.dist_to_rdist(D_sklearn)</span><span class="s0">, </span><span class="s1">np.sin(</span><span class="s2">0.5 </span><span class="s1">* D_reference) ** </span><span class="s2">2</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-6</span>
    <span class="s1">)</span>

    <span class="s1">assert_allclose(D_sklearn</span><span class="s0">, </span><span class="s1">D_reference)</span>

    <span class="s1">D_sklearn = haversine.pairwise(X_csr</span><span class="s0">, </span><span class="s1">Y_csr)</span>
    <span class="s0">assert </span><span class="s1">D_sklearn.flags.c_contiguous</span>
    <span class="s1">assert_allclose(D_sklearn</span><span class="s0">, </span><span class="s1">D_reference)</span>

    <span class="s1">D_sklearn = haversine.pairwise(X_csr</span><span class="s0">, </span><span class="s1">Y)</span>
    <span class="s0">assert </span><span class="s1">D_sklearn.flags.c_contiguous</span>
    <span class="s1">assert_allclose(D_sklearn</span><span class="s0">, </span><span class="s1">D_reference)</span>

    <span class="s1">D_sklearn = haversine.pairwise(X</span><span class="s0">, </span><span class="s1">Y_csr)</span>
    <span class="s0">assert </span><span class="s1">D_sklearn.flags.c_contiguous</span>
    <span class="s1">assert_allclose(D_sklearn</span><span class="s0">, </span><span class="s1">D_reference)</span>


<span class="s0">def </span><span class="s1">test_pyfunc_metric():</span>
    <span class="s1">X = np.random.random((</span><span class="s2">10</span><span class="s0">, </span><span class="s2">3</span><span class="s1">))</span>

    <span class="s1">euclidean = DistanceMetric.get_metric(</span><span class="s3">&quot;euclidean&quot;</span><span class="s1">)</span>
    <span class="s1">pyfunc = DistanceMetric.get_metric(</span><span class="s3">&quot;pyfunc&quot;</span><span class="s0">, </span><span class="s1">func=dist_func</span><span class="s0">, </span><span class="s1">p=</span><span class="s2">2</span><span class="s1">)</span>

    <span class="s4"># Check if both callable metric and predefined metric initialized</span>
    <span class="s4"># DistanceMetric object is picklable</span>
    <span class="s1">euclidean_pkl = pickle.loads(pickle.dumps(euclidean))</span>
    <span class="s1">pyfunc_pkl = pickle.loads(pickle.dumps(pyfunc))</span>

    <span class="s1">D1 = euclidean.pairwise(X)</span>
    <span class="s1">D2 = pyfunc.pairwise(X)</span>

    <span class="s1">D1_pkl = euclidean_pkl.pairwise(X)</span>
    <span class="s1">D2_pkl = pyfunc_pkl.pairwise(X)</span>

    <span class="s1">assert_allclose(D1</span><span class="s0">, </span><span class="s1">D2)</span>
    <span class="s1">assert_allclose(D1_pkl</span><span class="s0">, </span><span class="s1">D2_pkl)</span>


<span class="s0">def </span><span class="s1">test_input_data_size():</span>
    <span class="s4"># Regression test for #6288</span>
    <span class="s4"># Previously, a metric requiring a particular input dimension would fail</span>
    <span class="s0">def </span><span class="s1">custom_metric(x</span><span class="s0">, </span><span class="s1">y):</span>
        <span class="s0">assert </span><span class="s1">x.shape[</span><span class="s2">0</span><span class="s1">] == </span><span class="s2">3</span>
        <span class="s0">return </span><span class="s1">np.sum((x - y) ** </span><span class="s2">2</span><span class="s1">)</span>

    <span class="s1">rng = check_random_state(</span><span class="s2">0</span><span class="s1">)</span>
    <span class="s1">X = rng.rand(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span>

    <span class="s1">pyfunc = DistanceMetric.get_metric(</span><span class="s3">&quot;pyfunc&quot;</span><span class="s0">, </span><span class="s1">func=custom_metric)</span>
    <span class="s1">eucl = DistanceMetric.get_metric(</span><span class="s3">&quot;euclidean&quot;</span><span class="s1">)</span>
    <span class="s1">assert_allclose(pyfunc.pairwise(X)</span><span class="s0">, </span><span class="s1">eucl.pairwise(X) ** </span><span class="s2">2</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_readonly_kwargs():</span>
    <span class="s4"># Non-regression test for:</span>
    <span class="s4"># https://github.com/scikit-learn/scikit-learn/issues/21685</span>

    <span class="s1">rng = check_random_state(</span><span class="s2">0</span><span class="s1">)</span>

    <span class="s1">weights = rng.rand(</span><span class="s2">100</span><span class="s1">)</span>
    <span class="s1">VI = rng.rand(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)</span>
    <span class="s1">weights.setflags(write=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">VI.setflags(write=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s4"># Those distances metrics have to support readonly buffers.</span>
    <span class="s1">DistanceMetric.get_metric(</span><span class="s3">&quot;seuclidean&quot;</span><span class="s0">, </span><span class="s1">V=weights)</span>
    <span class="s1">DistanceMetric.get_metric(</span><span class="s3">&quot;mahalanobis&quot;</span><span class="s0">, </span><span class="s1">VI=VI)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;w, err_type, err_msg&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1.5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">13</span><span class="s1">])</span><span class="s0">, </span><span class="s1">ValueError</span><span class="s0">, </span><span class="s3">&quot;w cannot contain negative weights&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1.5</span><span class="s0">, </span><span class="s1">np.nan])</span><span class="s0">, </span><span class="s1">ValueError</span><span class="s0">, </span><span class="s3">&quot;w contains NaN&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s1">sp.csr_matrix([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">TypeError</span><span class="s0">,</span>
            <span class="s3">&quot;A sparse matrix was passed, but dense data is required&quot;</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(np.array([</span><span class="s3">&quot;a&quot;</span><span class="s0">, </span><span class="s3">&quot;b&quot;</span><span class="s0">, </span><span class="s3">&quot;c&quot;</span><span class="s1">])</span><span class="s0">, </span><span class="s1">ValueError</span><span class="s0">, </span><span class="s3">&quot;could not convert string to float&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(np.array([])</span><span class="s0">, </span><span class="s1">ValueError</span><span class="s0">, </span><span class="s3">&quot;a minimum of 1 is required&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_minkowski_metric_validate_weights_values(w</span><span class="s0">, </span><span class="s1">err_type</span><span class="s0">, </span><span class="s1">err_msg):</span>
    <span class="s0">with </span><span class="s1">pytest.raises(err_type</span><span class="s0">, </span><span class="s1">match=err_msg):</span>
        <span class="s1">DistanceMetric.get_metric(</span><span class="s3">&quot;minkowski&quot;</span><span class="s0">, </span><span class="s1">p=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">w=w)</span>


<span class="s0">def </span><span class="s1">test_minkowski_metric_validate_weights_size():</span>
    <span class="s1">w2 = rng.random_sample(d + </span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">dm = DistanceMetric.get_metric(</span><span class="s3">&quot;minkowski&quot;</span><span class="s0">, </span><span class="s1">p=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">w=w2)</span>
    <span class="s1">msg = (</span>
        <span class="s3">&quot;MinkowskiDistance: the size of w must match &quot;</span>
        <span class="s3">f&quot;the number of features </span><span class="s0">\\</span><span class="s3">(</span><span class="s0">{</span><span class="s1">X64.shape[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">}\\</span><span class="s3">). &quot;</span>
        <span class="s3">f&quot;Currently len</span><span class="s0">\\</span><span class="s3">(w</span><span class="s0">\\</span><span class="s3">)=</span><span class="s0">{</span><span class="s1">w2.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">}</span><span class="s3">.&quot;</span>
    <span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">dm.pairwise(X64</span><span class="s0">, </span><span class="s1">Y64)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;metric, metric_kwargs&quot;</span><span class="s0">, </span><span class="s1">METRICS_DEFAULT_PARAMS)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">(np.float32</span><span class="s0">, </span><span class="s1">np.float64))</span>
<span class="s0">def </span><span class="s1">test_get_metric_dtype(metric</span><span class="s0">, </span><span class="s1">metric_kwargs</span><span class="s0">, </span><span class="s1">dtype):</span>
    <span class="s1">specialized_cls = {</span>
        <span class="s1">np.float32: DistanceMetric32</span><span class="s0">,</span>
        <span class="s1">np.float64: DistanceMetric64</span><span class="s0">,</span>
    <span class="s1">}[dtype]</span>

    <span class="s4"># We don't need the entire grid, just one for a sanity check</span>
    <span class="s1">metric_kwargs = {k: v[</span><span class="s2">0</span><span class="s1">] </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">metric_kwargs.items()}</span>
    <span class="s1">generic_type = type(DistanceMetric.get_metric(metric</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">**metric_kwargs))</span>
    <span class="s1">specialized_type = type(specialized_cls.get_metric(metric</span><span class="s0">, </span><span class="s1">**metric_kwargs))</span>

    <span class="s0">assert </span><span class="s1">generic_type </span><span class="s0">is </span><span class="s1">specialized_type</span>


<span class="s0">def </span><span class="s1">test_get_metric_bad_dtype():</span>
    <span class="s1">dtype = np.int32</span>
    <span class="s1">msg = </span><span class="s3">r&quot;Unexpected dtype .* provided. Please select a dtype from&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">DistanceMetric.get_metric(</span><span class="s3">&quot;manhattan&quot;</span><span class="s0">, </span><span class="s1">dtype)</span>


<span class="s0">def </span><span class="s1">test_minkowski_metric_validate_bad_p_parameter():</span>
    <span class="s1">msg = </span><span class="s3">&quot;p must be greater than 0&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">DistanceMetric.get_metric(</span><span class="s3">&quot;minkowski&quot;</span><span class="s0">, </span><span class="s1">p=</span><span class="s2">0</span><span class="s1">)</span>
</pre>
</body>
</html>