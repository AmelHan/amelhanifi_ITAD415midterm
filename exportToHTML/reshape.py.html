<html>
<head>
<title>reshape.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
reshape.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">itertools</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s0">,</span>
    <span class="s1">cast</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">import </span><span class="s1">pandas._libs.reshape </span><span class="s0">as </span><span class="s1">libreshape</span>
<span class="s0">from </span><span class="s1">pandas.errors </span><span class="s0">import </span><span class="s1">PerformanceWarning</span>
<span class="s0">from </span><span class="s1">pandas.util._decorators </span><span class="s0">import </span><span class="s1">cache_readonly</span>
<span class="s0">from </span><span class="s1">pandas.util._exceptions </span><span class="s0">import </span><span class="s1">find_stack_level</span>

<span class="s0">from </span><span class="s1">pandas.core.dtypes.cast </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">find_common_type</span><span class="s0">,</span>
    <span class="s1">maybe_promote</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">ensure_platform_int</span><span class="s0">,</span>
    <span class="s1">is_1d_only_ea_dtype</span><span class="s0">,</span>
    <span class="s1">is_integer</span><span class="s0">,</span>
    <span class="s1">needs_i8_conversion</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.dtypes </span><span class="s0">import </span><span class="s1">ExtensionDtype</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.missing </span><span class="s0">import </span><span class="s1">notna</span>

<span class="s0">import </span><span class="s1">pandas.core.algorithms </span><span class="s0">as </span><span class="s1">algos</span>
<span class="s0">from </span><span class="s1">pandas.core.algorithms </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">factorize</span><span class="s0">,</span>
    <span class="s1">unique</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.arrays.categorical </span><span class="s0">import </span><span class="s1">factorize_from_iterable</span>
<span class="s0">from </span><span class="s1">pandas.core.construction </span><span class="s0">import </span><span class="s1">ensure_wrapped_if_datetimelike</span>
<span class="s0">from </span><span class="s1">pandas.core.frame </span><span class="s0">import </span><span class="s1">DataFrame</span>
<span class="s0">from </span><span class="s1">pandas.core.indexes.api </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Index</span><span class="s0">,</span>
    <span class="s1">MultiIndex</span><span class="s0">,</span>
    <span class="s1">RangeIndex</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.reshape.concat </span><span class="s0">import </span><span class="s1">concat</span>
<span class="s0">from </span><span class="s1">pandas.core.series </span><span class="s0">import </span><span class="s1">Series</span>
<span class="s0">from </span><span class="s1">pandas.core.sorting </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">compress_group_index</span><span class="s0">,</span>
    <span class="s1">decons_obs_group_ids</span><span class="s0">,</span>
    <span class="s1">get_compressed_ids</span><span class="s0">,</span>
    <span class="s1">get_group_index</span><span class="s0">,</span>
    <span class="s1">get_group_index_sorter</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s0">from </span><span class="s1">pandas._typing </span><span class="s0">import </span><span class="s1">(</span>
        <span class="s1">ArrayLike</span><span class="s0">,</span>
        <span class="s1">Level</span><span class="s0">,</span>
        <span class="s1">npt</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s0">from </span><span class="s1">pandas.core.arrays </span><span class="s0">import </span><span class="s1">ExtensionArray</span>
    <span class="s0">from </span><span class="s1">pandas.core.indexes.frozen </span><span class="s0">import </span><span class="s1">FrozenList</span>


<span class="s0">class </span><span class="s1">_Unstacker:</span>
    <span class="s2">&quot;&quot;&quot; 
    Helper class to unstack data / pivot with multi-level index 
 
    Parameters 
    ---------- 
    index : MultiIndex 
    level : int or str, default last level 
        Level to &quot;unstack&quot;. Accepts a name for the level. 
    fill_value : scalar, optional 
        Default value to fill in missing values if subgroups do not have the 
        same set of labels. By default, missing values will be replaced with 
        the default fill value for that data type, NaN for float, NaT for 
        datetimelike, etc. For integer types, by default data will converted to 
        float and missing values will be set to NaN. 
    constructor : object 
        Pandas ``DataFrame`` or subclass used to create unstacked 
        response.  If None, DataFrame will be used. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; index = pd.MultiIndex.from_tuples([('one', 'a'), ('one', 'b'), 
    ...                                    ('two', 'a'), ('two', 'b')]) 
    &gt;&gt;&gt; s = pd.Series(np.arange(1, 5, dtype=np.int64), index=index) 
    &gt;&gt;&gt; s 
    one  a    1 
         b    2 
    two  a    3 
         b    4 
    dtype: int64 
 
    &gt;&gt;&gt; s.unstack(level=-1) 
         a  b 
    one  1  2 
    two  3  4 
 
    &gt;&gt;&gt; s.unstack(level=0) 
       one  two 
    a    1    3 
    b    2    4 
 
    Returns 
    ------- 
    unstacked : DataFrame 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">index: MultiIndex</span><span class="s0">, </span><span class="s1">level: Level</span><span class="s0">, </span><span class="s1">constructor</span><span class="s0">, </span><span class="s1">sort: bool = </span><span class="s0">True</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self.constructor = constructor</span>
        <span class="s1">self.sort = sort</span>

        <span class="s1">self.index = index.remove_unused_levels()</span>

        <span class="s1">self.level = self.index._get_level_number(level)</span>

        <span class="s3"># when index includes `nan`, need to lift levels/strides by 1</span>
        <span class="s1">self.lift = </span><span class="s4">1 </span><span class="s0">if </span><span class="s1">-</span><span class="s4">1 </span><span class="s0">in </span><span class="s1">self.index.codes[self.level] </span><span class="s0">else </span><span class="s4">0</span>

        <span class="s3"># Note: the &quot;pop&quot; below alters these in-place.</span>
        <span class="s1">self.new_index_levels = list(self.index.levels)</span>
        <span class="s1">self.new_index_names = list(self.index.names)</span>

        <span class="s1">self.removed_name = self.new_index_names.pop(self.level)</span>
        <span class="s1">self.removed_level = self.new_index_levels.pop(self.level)</span>
        <span class="s1">self.removed_level_full = index.levels[self.level]</span>
        <span class="s0">if not </span><span class="s1">self.sort:</span>
            <span class="s1">unique_codes = unique(self.index.codes[self.level])</span>
            <span class="s1">self.removed_level = self.removed_level.take(unique_codes)</span>
            <span class="s1">self.removed_level_full = self.removed_level_full.take(unique_codes)</span>

        <span class="s3"># Bug fix GH 20601</span>
        <span class="s3"># If the data frame is too big, the number of unique index combination</span>
        <span class="s3"># will cause int32 overflow on windows environments.</span>
        <span class="s3"># We want to check and raise an warning before this happens</span>
        <span class="s1">num_rows = np.max([index_level.size </span><span class="s0">for </span><span class="s1">index_level </span><span class="s0">in </span><span class="s1">self.new_index_levels])</span>
        <span class="s1">num_columns = self.removed_level.size</span>

        <span class="s3"># GH20601: This forces an overflow if the number of cells is too high.</span>
        <span class="s1">num_cells = num_rows * num_columns</span>

        <span class="s3"># GH 26314: Previous ValueError raised was too restrictive for many users.</span>
        <span class="s0">if </span><span class="s1">num_cells &gt; np.iinfo(np.int32).max:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s5">f&quot;The following operation may generate </span><span class="s0">{</span><span class="s1">num_cells</span><span class="s0">} </span><span class="s5">cells &quot;</span>
                <span class="s5">f&quot;in the resulting pandas object.&quot;</span><span class="s0">,</span>
                <span class="s1">PerformanceWarning</span><span class="s0">,</span>
                <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s1">self._make_selectors()</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">_indexer_and_to_sort(</span>
        <span class="s1">self</span><span class="s0">,</span>
    <span class="s1">) -&gt; tuple[</span>
        <span class="s1">npt.NDArray[np.intp]</span><span class="s0">,</span>
        <span class="s1">list[np.ndarray]</span><span class="s0">,  </span><span class="s3"># each has _some_ signed integer dtype</span>
    <span class="s1">]:</span>
        <span class="s1">v = self.level</span>

        <span class="s1">codes = list(self.index.codes)</span>
        <span class="s1">levs = list(self.index.levels)</span>
        <span class="s1">to_sort = codes[:v] + codes[v + </span><span class="s4">1 </span><span class="s1">:] + [codes[v]]</span>
        <span class="s1">sizes = tuple(len(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">levs[:v] + levs[v + </span><span class="s4">1 </span><span class="s1">:] + [levs[v]])</span>

        <span class="s1">comp_index</span><span class="s0">, </span><span class="s1">obs_ids = get_compressed_ids(to_sort</span><span class="s0">, </span><span class="s1">sizes)</span>
        <span class="s1">ngroups = len(obs_ids)</span>

        <span class="s1">indexer = get_group_index_sorter(comp_index</span><span class="s0">, </span><span class="s1">ngroups)</span>
        <span class="s0">return </span><span class="s1">indexer</span><span class="s0">, </span><span class="s1">to_sort</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">sorted_labels(self) -&gt; list[np.ndarray]:</span>
        <span class="s1">indexer</span><span class="s0">, </span><span class="s1">to_sort = self._indexer_and_to_sort</span>
        <span class="s0">if </span><span class="s1">self.sort:</span>
            <span class="s0">return </span><span class="s1">[line.take(indexer) </span><span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">to_sort]</span>
        <span class="s0">return </span><span class="s1">to_sort</span>

    <span class="s0">def </span><span class="s1">_make_sorted_values(self</span><span class="s0">, </span><span class="s1">values: np.ndarray) -&gt; np.ndarray:</span>
        <span class="s0">if </span><span class="s1">self.sort:</span>
            <span class="s1">indexer</span><span class="s0">, </span><span class="s1">_ = self._indexer_and_to_sort</span>

            <span class="s1">sorted_values = algos.take_nd(values</span><span class="s0">, </span><span class="s1">indexer</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">sorted_values</span>
        <span class="s0">return </span><span class="s1">values</span>

    <span class="s0">def </span><span class="s1">_make_selectors(self):</span>
        <span class="s1">new_levels = self.new_index_levels</span>

        <span class="s3"># make the mask</span>
        <span class="s1">remaining_labels = self.sorted_labels[:-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">level_sizes = tuple(len(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">new_levels)</span>

        <span class="s1">comp_index</span><span class="s0">, </span><span class="s1">obs_ids = get_compressed_ids(remaining_labels</span><span class="s0">, </span><span class="s1">level_sizes)</span>
        <span class="s1">ngroups = len(obs_ids)</span>

        <span class="s1">comp_index = ensure_platform_int(comp_index)</span>
        <span class="s1">stride = self.index.levshape[self.level] + self.lift</span>
        <span class="s1">self.full_shape = ngroups</span><span class="s0">, </span><span class="s1">stride</span>

        <span class="s1">selector = self.sorted_labels[-</span><span class="s4">1</span><span class="s1">] + stride * comp_index + self.lift</span>
        <span class="s1">mask = np.zeros(np.prod(self.full_shape)</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
        <span class="s1">mask.put(selector</span><span class="s0">, True</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">mask.sum() &lt; len(self.index):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Index contains duplicate entries, cannot reshape&quot;</span><span class="s1">)</span>

        <span class="s1">self.group_index = comp_index</span>
        <span class="s1">self.mask = mask</span>
        <span class="s0">if </span><span class="s1">self.sort:</span>
            <span class="s1">self.compressor = comp_index.searchsorted(np.arange(ngroups))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.compressor = np.sort(np.unique(comp_index</span><span class="s0">, </span><span class="s1">return_index=</span><span class="s0">True</span><span class="s1">)[</span><span class="s4">1</span><span class="s1">])</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">mask_all(self) -&gt; bool:</span>
        <span class="s0">return </span><span class="s1">bool(self.mask.all())</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">arange_result(self) -&gt; tuple[npt.NDArray[np.intp]</span><span class="s0">, </span><span class="s1">npt.NDArray[np.bool_]]:</span>
        <span class="s3"># We cache this for re-use in ExtensionBlock._unstack</span>
        <span class="s1">dummy_arr = np.arange(len(self.index)</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>
        <span class="s1">new_values</span><span class="s0">, </span><span class="s1">mask = self.get_new_values(dummy_arr</span><span class="s0">, </span><span class="s1">fill_value=-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">new_values</span><span class="s0">, </span><span class="s1">mask.any(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s3"># TODO: in all tests we have mask.any(0).all(); can we rely on that?</span>

    <span class="s0">def </span><span class="s1">get_result(self</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">value_columns</span><span class="s0">, </span><span class="s1">fill_value) -&gt; DataFrame:</span>
        <span class="s0">if </span><span class="s1">values.ndim == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">values = values[:</span><span class="s0">, </span><span class="s1">np.newaxis]</span>

        <span class="s0">if </span><span class="s1">value_columns </span><span class="s0">is None and </span><span class="s1">values.shape[</span><span class="s4">1</span><span class="s1">] != </span><span class="s4">1</span><span class="s1">:  </span><span class="s3"># pragma: no cover</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;must pass column labels for multi-column data&quot;</span><span class="s1">)</span>

        <span class="s1">values</span><span class="s0">, </span><span class="s1">_ = self.get_new_values(values</span><span class="s0">, </span><span class="s1">fill_value)</span>
        <span class="s1">columns = self.get_new_columns(value_columns)</span>
        <span class="s1">index = self.new_index</span>

        <span class="s0">return </span><span class="s1">self.constructor(</span>
            <span class="s1">values</span><span class="s0">, </span><span class="s1">index=index</span><span class="s0">, </span><span class="s1">columns=columns</span><span class="s0">, </span><span class="s1">dtype=values.dtype</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_new_values(self</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">fill_value=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">values.ndim == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">values = values[:</span><span class="s0">, </span><span class="s1">np.newaxis]</span>

        <span class="s1">sorted_values = self._make_sorted_values(values)</span>

        <span class="s3"># place the values</span>
        <span class="s1">length</span><span class="s0">, </span><span class="s1">width = self.full_shape</span>
        <span class="s1">stride = values.shape[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">result_width = width * stride</span>
        <span class="s1">result_shape = (length</span><span class="s0">, </span><span class="s1">result_width)</span>
        <span class="s1">mask = self.mask</span>
        <span class="s1">mask_all = self.mask_all</span>

        <span class="s3"># we can simply reshape if we don't have a mask</span>
        <span class="s0">if </span><span class="s1">mask_all </span><span class="s0">and </span><span class="s1">len(values):</span>
            <span class="s3"># TODO: Under what circumstances can we rely on sorted_values</span>
            <span class="s3">#  matching values?  When that holds, we can slice instead</span>
            <span class="s3">#  of take (in particular for EAs)</span>
            <span class="s1">new_values = (</span>
                <span class="s1">sorted_values.reshape(length</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">stride)</span>
                <span class="s1">.swapaxes(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
                <span class="s1">.reshape(result_shape)</span>
            <span class="s1">)</span>
            <span class="s1">new_mask = np.ones(result_shape</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
            <span class="s0">return </span><span class="s1">new_values</span><span class="s0">, </span><span class="s1">new_mask</span>

        <span class="s1">dtype = values.dtype</span>

        <span class="s3"># if our mask is all True, then we can use our existing dtype</span>
        <span class="s0">if </span><span class="s1">mask_all:</span>
            <span class="s1">dtype = values.dtype</span>
            <span class="s1">new_values = np.empty(result_shape</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">isinstance(dtype</span><span class="s0">, </span><span class="s1">ExtensionDtype):</span>
                <span class="s3"># GH#41875</span>
                <span class="s3"># We are assuming that fill_value can be held by this dtype,</span>
                <span class="s3">#  unlike the non-EA case that promotes.</span>
                <span class="s1">cls = dtype.construct_array_type()</span>
                <span class="s1">new_values = cls._empty(result_shape</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
                <span class="s1">new_values[:] = fill_value</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">dtype</span><span class="s0">, </span><span class="s1">fill_value = maybe_promote(dtype</span><span class="s0">, </span><span class="s1">fill_value)</span>
                <span class="s1">new_values = np.empty(result_shape</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
                <span class="s1">new_values.fill(fill_value)</span>

        <span class="s1">name = dtype.name</span>
        <span class="s1">new_mask = np.zeros(result_shape</span><span class="s0">, </span><span class="s1">dtype=bool)</span>

        <span class="s3"># we need to convert to a basic dtype</span>
        <span class="s3"># and possibly coerce an input to our output dtype</span>
        <span class="s3"># e.g. ints -&gt; floats</span>
        <span class="s0">if </span><span class="s1">needs_i8_conversion(values.dtype):</span>
            <span class="s1">sorted_values = sorted_values.view(</span><span class="s5">&quot;i8&quot;</span><span class="s1">)</span>
            <span class="s1">new_values = new_values.view(</span><span class="s5">&quot;i8&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">sorted_values = sorted_values.astype(name</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s3"># fill in our values &amp; mask</span>
        <span class="s1">libreshape.unstack(</span>
            <span class="s1">sorted_values</span><span class="s0">,</span>
            <span class="s1">mask.view(</span><span class="s5">&quot;u1&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">stride</span><span class="s0">,</span>
            <span class="s1">length</span><span class="s0">,</span>
            <span class="s1">width</span><span class="s0">,</span>
            <span class="s1">new_values</span><span class="s0">,</span>
            <span class="s1">new_mask.view(</span><span class="s5">&quot;u1&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s3"># reconstruct dtype if needed</span>
        <span class="s0">if </span><span class="s1">needs_i8_conversion(values.dtype):</span>
            <span class="s3"># view as datetime64 so we can wrap in DatetimeArray and use</span>
            <span class="s3">#  DTA's view method</span>
            <span class="s1">new_values = new_values.view(</span><span class="s5">&quot;M8[ns]&quot;</span><span class="s1">)</span>
            <span class="s1">new_values = ensure_wrapped_if_datetimelike(new_values)</span>
            <span class="s1">new_values = new_values.view(values.dtype)</span>

        <span class="s0">return </span><span class="s1">new_values</span><span class="s0">, </span><span class="s1">new_mask</span>

    <span class="s0">def </span><span class="s1">get_new_columns(self</span><span class="s0">, </span><span class="s1">value_columns: Index | </span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">value_columns </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.lift == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">self.removed_level._rename(name=self.removed_name)</span>

            <span class="s1">lev = self.removed_level.insert(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">item=self.removed_level._na_value)</span>
            <span class="s0">return </span><span class="s1">lev.rename(self.removed_name)</span>

        <span class="s1">stride = len(self.removed_level) + self.lift</span>
        <span class="s1">width = len(value_columns)</span>
        <span class="s1">propagator = np.repeat(np.arange(width)</span><span class="s0">, </span><span class="s1">stride)</span>

        <span class="s1">new_levels: FrozenList | list[Index]</span>

        <span class="s0">if </span><span class="s1">isinstance(value_columns</span><span class="s0">, </span><span class="s1">MultiIndex):</span>
            <span class="s3"># error: Cannot determine type of &quot;__add__&quot;  [has-type]</span>
            <span class="s1">new_levels = value_columns.levels + (  </span><span class="s3"># type: ignore[has-type]</span>
                <span class="s1">self.removed_level_full</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s1">new_names = value_columns.names + (self.removed_name</span><span class="s0">,</span><span class="s1">)</span>

            <span class="s1">new_codes = [lab.take(propagator) </span><span class="s0">for </span><span class="s1">lab </span><span class="s0">in </span><span class="s1">value_columns.codes]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">new_levels = [</span>
                <span class="s1">value_columns</span><span class="s0">,</span>
                <span class="s1">self.removed_level_full</span><span class="s0">,</span>
            <span class="s1">]</span>
            <span class="s1">new_names = [value_columns.name</span><span class="s0">, </span><span class="s1">self.removed_name]</span>
            <span class="s1">new_codes = [propagator]</span>

        <span class="s1">repeater = self._repeater</span>

        <span class="s3"># The entire level is then just a repetition of the single chunk:</span>
        <span class="s1">new_codes.append(np.tile(repeater</span><span class="s0">, </span><span class="s1">width))</span>
        <span class="s0">return </span><span class="s1">MultiIndex(</span>
            <span class="s1">levels=new_levels</span><span class="s0">, </span><span class="s1">codes=new_codes</span><span class="s0">, </span><span class="s1">names=new_names</span><span class="s0">, </span><span class="s1">verify_integrity=</span><span class="s0">False</span>
        <span class="s1">)</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">_repeater(self) -&gt; np.ndarray:</span>
        <span class="s3"># The two indices differ only if the unstacked level had unused items:</span>
        <span class="s0">if </span><span class="s1">len(self.removed_level_full) != len(self.removed_level):</span>
            <span class="s3"># In this case, we remap the new codes to the original level:</span>
            <span class="s1">repeater = self.removed_level_full.get_indexer(self.removed_level)</span>
            <span class="s0">if </span><span class="s1">self.lift:</span>
                <span class="s1">repeater = np.insert(repeater</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s3"># Otherwise, we just use each level item exactly once:</span>
            <span class="s1">stride = len(self.removed_level) + self.lift</span>
            <span class="s1">repeater = np.arange(stride) - self.lift</span>

        <span class="s0">return </span><span class="s1">repeater</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">new_index(self) -&gt; MultiIndex:</span>
        <span class="s3"># Does not depend on values or value_columns</span>
        <span class="s1">result_codes = [lab.take(self.compressor) </span><span class="s0">for </span><span class="s1">lab </span><span class="s0">in </span><span class="s1">self.sorted_labels[:-</span><span class="s4">1</span><span class="s1">]]</span>

        <span class="s3"># construct the new index</span>
        <span class="s0">if </span><span class="s1">len(self.new_index_levels) == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">level</span><span class="s0">, </span><span class="s1">level_codes = self.new_index_levels[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">result_codes[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s0">if </span><span class="s1">(level_codes == -</span><span class="s4">1</span><span class="s1">).any():</span>
                <span class="s1">level = level.insert(len(level)</span><span class="s0">, </span><span class="s1">level._na_value)</span>
            <span class="s0">return </span><span class="s1">level.take(level_codes).rename(self.new_index_names[</span><span class="s4">0</span><span class="s1">])</span>

        <span class="s0">return </span><span class="s1">MultiIndex(</span>
            <span class="s1">levels=self.new_index_levels</span><span class="s0">,</span>
            <span class="s1">codes=result_codes</span><span class="s0">,</span>
            <span class="s1">names=self.new_index_names</span><span class="s0">,</span>
            <span class="s1">verify_integrity=</span><span class="s0">False,</span>
        <span class="s1">)</span>


<span class="s0">def </span><span class="s1">_unstack_multiple(</span>
    <span class="s1">data: Series | DataFrame</span><span class="s0">, </span><span class="s1">clocs</span><span class="s0">, </span><span class="s1">fill_value=</span><span class="s0">None, </span><span class="s1">sort: bool = </span><span class="s0">True</span>
<span class="s1">):</span>
    <span class="s0">if </span><span class="s1">len(clocs) == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">data</span>

    <span class="s3"># NOTE: This doesn't deal with hierarchical columns yet</span>

    <span class="s1">index = data.index</span>
    <span class="s1">index = cast(MultiIndex</span><span class="s0">, </span><span class="s1">index)  </span><span class="s3"># caller is responsible for checking</span>

    <span class="s3"># GH 19966 Make sure if MultiIndexed index has tuple name, they will be</span>
    <span class="s3"># recognised as a whole</span>
    <span class="s0">if </span><span class="s1">clocs </span><span class="s0">in </span><span class="s1">index.names:</span>
        <span class="s1">clocs = [clocs]</span>
    <span class="s1">clocs = [index._get_level_number(i) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">clocs]</span>

    <span class="s1">rlocs = [i </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(index.nlevels) </span><span class="s0">if </span><span class="s1">i </span><span class="s0">not in </span><span class="s1">clocs]</span>

    <span class="s1">clevels = [index.levels[i] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">clocs]</span>
    <span class="s1">ccodes = [index.codes[i] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">clocs]</span>
    <span class="s1">cnames = [index.names[i] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">clocs]</span>
    <span class="s1">rlevels = [index.levels[i] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">rlocs]</span>
    <span class="s1">rcodes = [index.codes[i] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">rlocs]</span>
    <span class="s1">rnames = [index.names[i] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">rlocs]</span>

    <span class="s1">shape = tuple(len(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">clevels)</span>
    <span class="s1">group_index = get_group_index(ccodes</span><span class="s0">, </span><span class="s1">shape</span><span class="s0">, </span><span class="s1">sort=</span><span class="s0">False, </span><span class="s1">xnull=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">comp_ids</span><span class="s0">, </span><span class="s1">obs_ids = compress_group_index(group_index</span><span class="s0">, </span><span class="s1">sort=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">recons_codes = decons_obs_group_ids(comp_ids</span><span class="s0">, </span><span class="s1">obs_ids</span><span class="s0">, </span><span class="s1">shape</span><span class="s0">, </span><span class="s1">ccodes</span><span class="s0">, </span><span class="s1">xnull=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">if not </span><span class="s1">rlocs:</span>
        <span class="s3"># Everything is in clocs, so the dummy df has a regular index</span>
        <span class="s1">dummy_index = Index(obs_ids</span><span class="s0">, </span><span class="s1">name=</span><span class="s5">&quot;__placeholder__&quot;</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">dummy_index = MultiIndex(</span>
            <span class="s1">levels=rlevels + [obs_ids]</span><span class="s0">,</span>
            <span class="s1">codes=rcodes + [comp_ids]</span><span class="s0">,</span>
            <span class="s1">names=rnames + [</span><span class="s5">&quot;__placeholder__&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">verify_integrity=</span><span class="s0">False,</span>
        <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">isinstance(data</span><span class="s0">, </span><span class="s1">Series):</span>
        <span class="s1">dummy = data.copy()</span>
        <span class="s1">dummy.index = dummy_index</span>

        <span class="s1">unstacked = dummy.unstack(</span><span class="s5">&quot;__placeholder__&quot;</span><span class="s0">, </span><span class="s1">fill_value=fill_value</span><span class="s0">, </span><span class="s1">sort=sort)</span>
        <span class="s1">new_levels = clevels</span>
        <span class="s1">new_names = cnames</span>
        <span class="s1">new_codes = recons_codes</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">isinstance(data.columns</span><span class="s0">, </span><span class="s1">MultiIndex):</span>
            <span class="s1">result = data</span>
            <span class="s0">while </span><span class="s1">clocs:</span>
                <span class="s1">val = clocs.pop(</span><span class="s4">0</span><span class="s1">)</span>
                <span class="s1">result = result.unstack(val</span><span class="s0">, </span><span class="s1">fill_value=fill_value</span><span class="s0">, </span><span class="s1">sort=sort)</span>
                <span class="s1">clocs = [v </span><span class="s0">if </span><span class="s1">v &lt; val </span><span class="s0">else </span><span class="s1">v - </span><span class="s4">1 </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">clocs]</span>

            <span class="s0">return </span><span class="s1">result</span>

        <span class="s3"># GH#42579 deep=False to avoid consolidating</span>
        <span class="s1">dummy_df = data.copy(deep=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">dummy_df.index = dummy_index</span>

        <span class="s1">unstacked = dummy_df.unstack(</span>
            <span class="s5">&quot;__placeholder__&quot;</span><span class="s0">, </span><span class="s1">fill_value=fill_value</span><span class="s0">, </span><span class="s1">sort=sort</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">isinstance(unstacked</span><span class="s0">, </span><span class="s1">Series):</span>
            <span class="s1">unstcols = unstacked.index</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">unstcols = unstacked.columns</span>
        <span class="s0">assert </span><span class="s1">isinstance(unstcols</span><span class="s0">, </span><span class="s1">MultiIndex)  </span><span class="s3"># for mypy</span>
        <span class="s1">new_levels = [unstcols.levels[</span><span class="s4">0</span><span class="s1">]] + clevels</span>
        <span class="s1">new_names = [data.columns.name] + cnames</span>

        <span class="s1">new_codes = [unstcols.codes[</span><span class="s4">0</span><span class="s1">]]</span>
        <span class="s1">new_codes.extend(rec.take(unstcols.codes[-</span><span class="s4">1</span><span class="s1">]) </span><span class="s0">for </span><span class="s1">rec </span><span class="s0">in </span><span class="s1">recons_codes)</span>

    <span class="s1">new_columns = MultiIndex(</span>
        <span class="s1">levels=new_levels</span><span class="s0">, </span><span class="s1">codes=new_codes</span><span class="s0">, </span><span class="s1">names=new_names</span><span class="s0">, </span><span class="s1">verify_integrity=</span><span class="s0">False</span>
    <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">isinstance(unstacked</span><span class="s0">, </span><span class="s1">Series):</span>
        <span class="s1">unstacked.index = new_columns</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">unstacked.columns = new_columns</span>

    <span class="s0">return </span><span class="s1">unstacked</span>


<span class="s0">def </span><span class="s1">unstack(obj: Series | DataFrame</span><span class="s0">, </span><span class="s1">level</span><span class="s0">, </span><span class="s1">fill_value=</span><span class="s0">None, </span><span class="s1">sort: bool = </span><span class="s0">True</span><span class="s1">):</span>
    <span class="s0">if </span><span class="s1">isinstance(level</span><span class="s0">, </span><span class="s1">(tuple</span><span class="s0">, </span><span class="s1">list)):</span>
        <span class="s0">if </span><span class="s1">len(level) != </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s3"># _unstack_multiple only handles MultiIndexes,</span>
            <span class="s3"># and isn't needed for a single level</span>
            <span class="s0">return </span><span class="s1">_unstack_multiple(obj</span><span class="s0">, </span><span class="s1">level</span><span class="s0">, </span><span class="s1">fill_value=fill_value</span><span class="s0">, </span><span class="s1">sort=sort)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">level = level[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s0">if not </span><span class="s1">is_integer(level) </span><span class="s0">and not </span><span class="s1">level == </span><span class="s5">&quot;__placeholder__&quot;</span><span class="s1">:</span>
        <span class="s3"># check if level is valid in case of regular index</span>
        <span class="s1">obj.index._get_level_number(level)</span>

    <span class="s0">if </span><span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">DataFrame):</span>
        <span class="s0">if </span><span class="s1">isinstance(obj.index</span><span class="s0">, </span><span class="s1">MultiIndex):</span>
            <span class="s0">return </span><span class="s1">_unstack_frame(obj</span><span class="s0">, </span><span class="s1">level</span><span class="s0">, </span><span class="s1">fill_value=fill_value</span><span class="s0">, </span><span class="s1">sort=sort)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">obj.T.stack(future_stack=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">elif not </span><span class="s1">isinstance(obj.index</span><span class="s0">, </span><span class="s1">MultiIndex):</span>
        <span class="s3"># GH 36113</span>
        <span class="s3"># Give nicer error messages when unstack a Series whose</span>
        <span class="s3"># Index is not a MultiIndex.</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span>
            <span class="s5">f&quot;index must be a MultiIndex to unstack, </span><span class="s0">{</span><span class="s1">type(obj.index)</span><span class="s0">} </span><span class="s5">was passed&quot;</span>
        <span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">is_1d_only_ea_dtype(obj.dtype):</span>
            <span class="s0">return </span><span class="s1">_unstack_extension_series(obj</span><span class="s0">, </span><span class="s1">level</span><span class="s0">, </span><span class="s1">fill_value</span><span class="s0">, </span><span class="s1">sort=sort)</span>
        <span class="s1">unstacker = _Unstacker(</span>
            <span class="s1">obj.index</span><span class="s0">, </span><span class="s1">level=level</span><span class="s0">, </span><span class="s1">constructor=obj._constructor_expanddim</span><span class="s0">, </span><span class="s1">sort=sort</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">unstacker.get_result(</span>
            <span class="s1">obj._values</span><span class="s0">, </span><span class="s1">value_columns=</span><span class="s0">None, </span><span class="s1">fill_value=fill_value</span>
        <span class="s1">)</span>


<span class="s0">def </span><span class="s1">_unstack_frame(</span>
    <span class="s1">obj: DataFrame</span><span class="s0">, </span><span class="s1">level</span><span class="s0">, </span><span class="s1">fill_value=</span><span class="s0">None, </span><span class="s1">sort: bool = </span><span class="s0">True</span>
<span class="s1">) -&gt; DataFrame:</span>
    <span class="s0">assert </span><span class="s1">isinstance(obj.index</span><span class="s0">, </span><span class="s1">MultiIndex)  </span><span class="s3"># checked by caller</span>
    <span class="s1">unstacker = _Unstacker(</span>
        <span class="s1">obj.index</span><span class="s0">, </span><span class="s1">level=level</span><span class="s0">, </span><span class="s1">constructor=obj._constructor</span><span class="s0">, </span><span class="s1">sort=sort</span>
    <span class="s1">)</span>

    <span class="s0">if not </span><span class="s1">obj._can_fast_transpose:</span>
        <span class="s1">mgr = obj._mgr.unstack(unstacker</span><span class="s0">, </span><span class="s1">fill_value=fill_value)</span>
        <span class="s0">return </span><span class="s1">obj._constructor_from_mgr(mgr</span><span class="s0">, </span><span class="s1">axes=mgr.axes)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">unstacker.get_result(</span>
            <span class="s1">obj._values</span><span class="s0">, </span><span class="s1">value_columns=obj.columns</span><span class="s0">, </span><span class="s1">fill_value=fill_value</span>
        <span class="s1">)</span>


<span class="s0">def </span><span class="s1">_unstack_extension_series(</span>
    <span class="s1">series: Series</span><span class="s0">, </span><span class="s1">level</span><span class="s0">, </span><span class="s1">fill_value</span><span class="s0">, </span><span class="s1">sort: bool</span>
<span class="s1">) -&gt; DataFrame:</span>
    <span class="s2">&quot;&quot;&quot; 
    Unstack an ExtensionArray-backed Series. 
 
    The ExtensionDtype is preserved. 
 
    Parameters 
    ---------- 
    series : Series 
        A Series with an ExtensionArray for values 
    level : Any 
        The level name or number. 
    fill_value : Any 
        The user-level (not physical storage) fill value to use for 
        missing values introduced by the reshape. Passed to 
        ``series.values.take``. 
    sort : bool 
        Whether to sort the resulting MuliIndex levels 
 
    Returns 
    ------- 
    DataFrame 
        Each column of the DataFrame will have the same dtype as 
        the input Series. 
    &quot;&quot;&quot;</span>
    <span class="s3"># Defer to the logic in ExtensionBlock._unstack</span>
    <span class="s1">df = series.to_frame()</span>
    <span class="s1">result = df.unstack(level=level</span><span class="s0">, </span><span class="s1">fill_value=fill_value</span><span class="s0">, </span><span class="s1">sort=sort)</span>

    <span class="s3"># equiv: result.droplevel(level=0, axis=1)</span>
    <span class="s3">#  but this avoids an extra copy</span>
    <span class="s1">result.columns = result.columns.droplevel(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">result</span>


<span class="s0">def </span><span class="s1">stack(frame: DataFrame</span><span class="s0">, </span><span class="s1">level=-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">dropna: bool = </span><span class="s0">True, </span><span class="s1">sort: bool = </span><span class="s0">True</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Convert DataFrame to Series with multi-level Index. Columns become the 
    second level of the resulting hierarchical index 
 
    Returns 
    ------- 
    stacked : Series or DataFrame 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">stack_factorize(index):</span>
        <span class="s0">if </span><span class="s1">index.is_unique:</span>
            <span class="s0">return </span><span class="s1">index</span><span class="s0">, </span><span class="s1">np.arange(len(index))</span>
        <span class="s1">codes</span><span class="s0">, </span><span class="s1">categories = factorize_from_iterable(index)</span>
        <span class="s0">return </span><span class="s1">categories</span><span class="s0">, </span><span class="s1">codes</span>

    <span class="s1">N</span><span class="s0">, </span><span class="s1">K = frame.shape</span>

    <span class="s3"># Will also convert negative level numbers and check if out of bounds.</span>
    <span class="s1">level_num = frame.columns._get_level_number(level)</span>

    <span class="s0">if </span><span class="s1">isinstance(frame.columns</span><span class="s0">, </span><span class="s1">MultiIndex):</span>
        <span class="s0">return </span><span class="s1">_stack_multi_columns(</span>
            <span class="s1">frame</span><span class="s0">, </span><span class="s1">level_num=level_num</span><span class="s0">, </span><span class="s1">dropna=dropna</span><span class="s0">, </span><span class="s1">sort=sort</span>
        <span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">isinstance(frame.index</span><span class="s0">, </span><span class="s1">MultiIndex):</span>
        <span class="s1">new_levels = list(frame.index.levels)</span>
        <span class="s1">new_codes = [lab.repeat(K) </span><span class="s0">for </span><span class="s1">lab </span><span class="s0">in </span><span class="s1">frame.index.codes]</span>

        <span class="s1">clev</span><span class="s0">, </span><span class="s1">clab = stack_factorize(frame.columns)</span>
        <span class="s1">new_levels.append(clev)</span>
        <span class="s1">new_codes.append(np.tile(clab</span><span class="s0">, </span><span class="s1">N).ravel())</span>

        <span class="s1">new_names = list(frame.index.names)</span>
        <span class="s1">new_names.append(frame.columns.name)</span>
        <span class="s1">new_index = MultiIndex(</span>
            <span class="s1">levels=new_levels</span><span class="s0">, </span><span class="s1">codes=new_codes</span><span class="s0">, </span><span class="s1">names=new_names</span><span class="s0">, </span><span class="s1">verify_integrity=</span><span class="s0">False</span>
        <span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">levels</span><span class="s0">, </span><span class="s1">(ilab</span><span class="s0">, </span><span class="s1">clab) = zip(*map(stack_factorize</span><span class="s0">, </span><span class="s1">(frame.index</span><span class="s0">, </span><span class="s1">frame.columns)))</span>
        <span class="s1">codes = ilab.repeat(K)</span><span class="s0">, </span><span class="s1">np.tile(clab</span><span class="s0">, </span><span class="s1">N).ravel()</span>
        <span class="s1">new_index = MultiIndex(</span>
            <span class="s1">levels=levels</span><span class="s0">,</span>
            <span class="s1">codes=codes</span><span class="s0">,</span>
            <span class="s1">names=[frame.index.name</span><span class="s0">, </span><span class="s1">frame.columns.name]</span><span class="s0">,</span>
            <span class="s1">verify_integrity=</span><span class="s0">False,</span>
        <span class="s1">)</span>

    <span class="s1">new_values: ArrayLike</span>
    <span class="s0">if not </span><span class="s1">frame.empty </span><span class="s0">and </span><span class="s1">frame._is_homogeneous_type:</span>
        <span class="s3"># For homogeneous EAs, frame._values will coerce to object. So</span>
        <span class="s3"># we concatenate instead.</span>
        <span class="s1">dtypes = list(frame.dtypes._values)</span>
        <span class="s1">dtype = dtypes[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s0">if </span><span class="s1">isinstance(dtype</span><span class="s0">, </span><span class="s1">ExtensionDtype):</span>
            <span class="s1">arr = dtype.construct_array_type()</span>
            <span class="s1">new_values = arr._concat_same_type(</span>
                <span class="s1">[col._values </span><span class="s0">for </span><span class="s1">_</span><span class="s0">, </span><span class="s1">col </span><span class="s0">in </span><span class="s1">frame.items()]</span>
            <span class="s1">)</span>
            <span class="s1">new_values = _reorder_for_extension_array_stack(new_values</span><span class="s0">, </span><span class="s1">N</span><span class="s0">, </span><span class="s1">K)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s3"># homogeneous, non-EA</span>
            <span class="s1">new_values = frame._values.ravel()</span>

    <span class="s0">else</span><span class="s1">:</span>
        <span class="s3"># non-homogeneous</span>
        <span class="s1">new_values = frame._values.ravel()</span>

    <span class="s0">if </span><span class="s1">dropna:</span>
        <span class="s1">mask = notna(new_values)</span>
        <span class="s1">new_values = new_values[mask]</span>
        <span class="s1">new_index = new_index[mask]</span>

    <span class="s0">return </span><span class="s1">frame._constructor_sliced(new_values</span><span class="s0">, </span><span class="s1">index=new_index)</span>


<span class="s0">def </span><span class="s1">stack_multiple(frame: DataFrame</span><span class="s0">, </span><span class="s1">level</span><span class="s0">, </span><span class="s1">dropna: bool = </span><span class="s0">True, </span><span class="s1">sort: bool = </span><span class="s0">True</span><span class="s1">):</span>
    <span class="s3"># If all passed levels match up to column names, no</span>
    <span class="s3"># ambiguity about what to do</span>
    <span class="s0">if </span><span class="s1">all(lev </span><span class="s0">in </span><span class="s1">frame.columns.names </span><span class="s0">for </span><span class="s1">lev </span><span class="s0">in </span><span class="s1">level):</span>
        <span class="s1">result = frame</span>
        <span class="s0">for </span><span class="s1">lev </span><span class="s0">in </span><span class="s1">level:</span>
            <span class="s1">result = stack(result</span><span class="s0">, </span><span class="s1">lev</span><span class="s0">, </span><span class="s1">dropna=dropna</span><span class="s0">, </span><span class="s1">sort=sort)</span>

    <span class="s3"># Otherwise, level numbers may change as each successive level is stacked</span>
    <span class="s0">elif </span><span class="s1">all(isinstance(lev</span><span class="s0">, </span><span class="s1">int) </span><span class="s0">for </span><span class="s1">lev </span><span class="s0">in </span><span class="s1">level):</span>
        <span class="s3"># As each stack is done, the level numbers decrease, so we need</span>
        <span class="s3">#  to account for that when level is a sequence of ints</span>
        <span class="s1">result = frame</span>
        <span class="s3"># _get_level_number() checks level numbers are in range and converts</span>
        <span class="s3"># negative numbers to positive</span>
        <span class="s1">level = [frame.columns._get_level_number(lev) </span><span class="s0">for </span><span class="s1">lev </span><span class="s0">in </span><span class="s1">level]</span>

        <span class="s0">while </span><span class="s1">level:</span>
            <span class="s1">lev = level.pop(</span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">result = stack(result</span><span class="s0">, </span><span class="s1">lev</span><span class="s0">, </span><span class="s1">dropna=dropna</span><span class="s0">, </span><span class="s1">sort=sort)</span>
            <span class="s3"># Decrement all level numbers greater than current, as these</span>
            <span class="s3"># have now shifted down by one</span>
            <span class="s1">level = [v </span><span class="s0">if </span><span class="s1">v &lt;= lev </span><span class="s0">else </span><span class="s1">v - </span><span class="s4">1 </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">level]</span>

    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span>
            <span class="s5">&quot;level should contain all level names or all level &quot;</span>
            <span class="s5">&quot;numbers, not a mixture of the two.&quot;</span>
        <span class="s1">)</span>

    <span class="s0">return </span><span class="s1">result</span>


<span class="s0">def </span><span class="s1">_stack_multi_column_index(columns: MultiIndex) -&gt; MultiIndex:</span>
    <span class="s2">&quot;&quot;&quot;Creates a MultiIndex from the first N-1 levels of this MultiIndex.&quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">len(columns.levels) &lt;= </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">columns.levels[</span><span class="s4">0</span><span class="s1">]._rename(name=columns.names[</span><span class="s4">0</span><span class="s1">])</span>

    <span class="s1">levs = [</span>
        <span class="s1">[lev[c] </span><span class="s0">if </span><span class="s1">c &gt;= </span><span class="s4">0 </span><span class="s0">else None for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">codes]</span>
        <span class="s0">for </span><span class="s1">lev</span><span class="s0">, </span><span class="s1">codes </span><span class="s0">in </span><span class="s1">zip(columns.levels[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">columns.codes[:-</span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">]</span>

    <span class="s3"># Remove duplicate tuples in the MultiIndex.</span>
    <span class="s1">tuples = zip(*levs)</span>
    <span class="s1">unique_tuples = (key </span><span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">itertools.groupby(tuples))</span>
    <span class="s1">new_levs = zip(*unique_tuples)</span>

    <span class="s3"># The dtype of each level must be explicitly set to avoid inferring the wrong type.</span>
    <span class="s3"># See GH-36991.</span>
    <span class="s0">return </span><span class="s1">MultiIndex.from_arrays(</span>
        <span class="s1">[</span>
            <span class="s3"># Not all indices can accept None values.</span>
            <span class="s1">Index(new_lev</span><span class="s0">, </span><span class="s1">dtype=lev.dtype) </span><span class="s0">if None not in </span><span class="s1">new_lev </span><span class="s0">else </span><span class="s1">new_lev</span>
            <span class="s0">for </span><span class="s1">new_lev</span><span class="s0">, </span><span class="s1">lev </span><span class="s0">in </span><span class="s1">zip(new_levs</span><span class="s0">, </span><span class="s1">columns.levels)</span>
        <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">names=columns.names[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">_stack_multi_columns(</span>
    <span class="s1">frame: DataFrame</span><span class="s0">, </span><span class="s1">level_num: int = -</span><span class="s4">1</span><span class="s0">, </span><span class="s1">dropna: bool = </span><span class="s0">True, </span><span class="s1">sort: bool = </span><span class="s0">True</span>
<span class="s1">) -&gt; DataFrame:</span>
    <span class="s0">def </span><span class="s1">_convert_level_number(level_num: int</span><span class="s0">, </span><span class="s1">columns: Index):</span>
        <span class="s2">&quot;&quot;&quot; 
        Logic for converting the level number to something we can safely pass 
        to swaplevel. 
 
        If `level_num` matches a column name return the name from 
        position `level_num`, otherwise return `level_num`. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">level_num </span><span class="s0">in </span><span class="s1">columns.names:</span>
            <span class="s0">return </span><span class="s1">columns.names[level_num]</span>

        <span class="s0">return </span><span class="s1">level_num</span>

    <span class="s1">this = frame.copy(deep=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">mi_cols = this.columns  </span><span class="s3"># cast(MultiIndex, this.columns)</span>
    <span class="s0">assert </span><span class="s1">isinstance(mi_cols</span><span class="s0">, </span><span class="s1">MultiIndex)  </span><span class="s3"># caller is responsible</span>

    <span class="s3"># this makes life much simpler</span>
    <span class="s0">if </span><span class="s1">level_num != mi_cols.nlevels - </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s3"># roll levels to put selected level at end</span>
        <span class="s1">roll_columns = mi_cols</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(level_num</span><span class="s0">, </span><span class="s1">mi_cols.nlevels - </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s3"># Need to check if the ints conflict with level names</span>
            <span class="s1">lev1 = _convert_level_number(i</span><span class="s0">, </span><span class="s1">roll_columns)</span>
            <span class="s1">lev2 = _convert_level_number(i + </span><span class="s4">1</span><span class="s0">, </span><span class="s1">roll_columns)</span>
            <span class="s1">roll_columns = roll_columns.swaplevel(lev1</span><span class="s0">, </span><span class="s1">lev2)</span>
        <span class="s1">this.columns = mi_cols = roll_columns</span>

    <span class="s0">if not </span><span class="s1">mi_cols._is_lexsorted() </span><span class="s0">and </span><span class="s1">sort:</span>
        <span class="s3"># Workaround the edge case where 0 is one of the column names,</span>
        <span class="s3"># which interferes with trying to sort based on the first</span>
        <span class="s3"># level</span>
        <span class="s1">level_to_sort = _convert_level_number(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">mi_cols)</span>
        <span class="s1">this = this.sort_index(level=level_to_sort</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">mi_cols = this.columns</span>

    <span class="s1">mi_cols = cast(MultiIndex</span><span class="s0">, </span><span class="s1">mi_cols)</span>
    <span class="s1">new_columns = _stack_multi_column_index(mi_cols)</span>

    <span class="s3"># time to ravel the values</span>
    <span class="s1">new_data = {}</span>
    <span class="s1">level_vals = mi_cols.levels[-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">level_codes = unique(mi_cols.codes[-</span><span class="s4">1</span><span class="s1">])</span>
    <span class="s0">if </span><span class="s1">sort:</span>
        <span class="s1">level_codes = np.sort(level_codes)</span>
    <span class="s1">level_vals_nan = level_vals.insert(len(level_vals)</span><span class="s0">, None</span><span class="s1">)</span>

    <span class="s1">level_vals_used = np.take(level_vals_nan</span><span class="s0">, </span><span class="s1">level_codes)</span>
    <span class="s1">levsize = len(level_codes)</span>
    <span class="s1">drop_cols = []</span>
    <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">new_columns:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">loc = this.columns.get_loc(key)</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s1">drop_cols.append(key)</span>
            <span class="s0">continue</span>

        <span class="s3"># can make more efficient?</span>
        <span class="s3"># we almost always return a slice</span>
        <span class="s3"># but if unsorted can get a boolean</span>
        <span class="s3"># indexer</span>
        <span class="s0">if not </span><span class="s1">isinstance(loc</span><span class="s0">, </span><span class="s1">slice):</span>
            <span class="s1">slice_len = len(loc)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">slice_len = loc.stop - loc.start</span>

        <span class="s0">if </span><span class="s1">slice_len != levsize:</span>
            <span class="s1">chunk = this.loc[:</span><span class="s0">, </span><span class="s1">this.columns[loc]]</span>
            <span class="s1">chunk.columns = level_vals_nan.take(chunk.columns.codes[-</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s1">value_slice = chunk.reindex(columns=level_vals_used).values</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">subset = this.iloc[:</span><span class="s0">, </span><span class="s1">loc]</span>
            <span class="s1">dtype = find_common_type(subset.dtypes.tolist())</span>
            <span class="s0">if </span><span class="s1">isinstance(dtype</span><span class="s0">, </span><span class="s1">ExtensionDtype):</span>
                <span class="s3"># TODO(EA2D): won't need special case, can go through .values</span>
                <span class="s3">#  paths below (might change to ._values)</span>
                <span class="s1">value_slice = dtype.construct_array_type()._concat_same_type(</span>
                    <span class="s1">[x._values.astype(dtype</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">) </span><span class="s0">for </span><span class="s1">_</span><span class="s0">, </span><span class="s1">x </span><span class="s0">in </span><span class="s1">subset.items()]</span>
                <span class="s1">)</span>
                <span class="s1">N</span><span class="s0">, </span><span class="s1">K = subset.shape</span>
                <span class="s1">idx = np.arange(N * K).reshape(K</span><span class="s0">, </span><span class="s1">N).T.ravel()</span>
                <span class="s1">value_slice = value_slice.take(idx)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">value_slice = subset.values</span>

        <span class="s0">if </span><span class="s1">value_slice.ndim &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s3"># i.e. not extension</span>
            <span class="s1">value_slice = value_slice.ravel()</span>

        <span class="s1">new_data[key] = value_slice</span>

    <span class="s0">if </span><span class="s1">len(drop_cols) &gt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">new_columns = new_columns.difference(drop_cols)</span>

    <span class="s1">N = len(this)</span>

    <span class="s0">if </span><span class="s1">isinstance(this.index</span><span class="s0">, </span><span class="s1">MultiIndex):</span>
        <span class="s1">new_levels = list(this.index.levels)</span>
        <span class="s1">new_names = list(this.index.names)</span>
        <span class="s1">new_codes = [lab.repeat(levsize) </span><span class="s0">for </span><span class="s1">lab </span><span class="s0">in </span><span class="s1">this.index.codes]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">old_codes</span><span class="s0">, </span><span class="s1">old_levels = factorize_from_iterable(this.index)</span>
        <span class="s1">new_levels = [old_levels]</span>
        <span class="s1">new_codes = [old_codes.repeat(levsize)]</span>
        <span class="s1">new_names = [this.index.name]  </span><span class="s3"># something better?</span>

    <span class="s1">new_levels.append(level_vals)</span>
    <span class="s1">new_codes.append(np.tile(level_codes</span><span class="s0">, </span><span class="s1">N))</span>
    <span class="s1">new_names.append(frame.columns.names[level_num])</span>

    <span class="s1">new_index = MultiIndex(</span>
        <span class="s1">levels=new_levels</span><span class="s0">, </span><span class="s1">codes=new_codes</span><span class="s0">, </span><span class="s1">names=new_names</span><span class="s0">, </span><span class="s1">verify_integrity=</span><span class="s0">False</span>
    <span class="s1">)</span>

    <span class="s1">result = frame._constructor(new_data</span><span class="s0">, </span><span class="s1">index=new_index</span><span class="s0">, </span><span class="s1">columns=new_columns)</span>

    <span class="s0">if </span><span class="s1">frame.columns.nlevels &gt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">desired_columns = frame.columns._drop_level_numbers([level_num]).unique()</span>
        <span class="s0">if not </span><span class="s1">result.columns.equals(desired_columns):</span>
            <span class="s1">result = result[desired_columns]</span>

    <span class="s3"># more efficient way to go about this? can do the whole masking biz but</span>
    <span class="s3"># will only save a small amount of time...</span>
    <span class="s0">if </span><span class="s1">dropna:</span>
        <span class="s1">result = result.dropna(axis=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">how=</span><span class="s5">&quot;all&quot;</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">result</span>


<span class="s0">def </span><span class="s1">_reorder_for_extension_array_stack(</span>
    <span class="s1">arr: ExtensionArray</span><span class="s0">, </span><span class="s1">n_rows: int</span><span class="s0">, </span><span class="s1">n_columns: int</span>
<span class="s1">) -&gt; ExtensionArray:</span>
    <span class="s2">&quot;&quot;&quot; 
    Re-orders the values when stacking multiple extension-arrays. 
 
    The indirect stacking method used for EAs requires a followup 
    take to get the order correct. 
 
    Parameters 
    ---------- 
    arr : ExtensionArray 
    n_rows, n_columns : int 
        The number of rows and columns in the original DataFrame. 
 
    Returns 
    ------- 
    taken : ExtensionArray 
        The original `arr` with elements re-ordered appropriately 
 
    Examples 
    -------- 
    &gt;&gt;&gt; arr = np.array(['a', 'b', 'c', 'd', 'e', 'f']) 
    &gt;&gt;&gt; _reorder_for_extension_array_stack(arr, 2, 3) 
    array(['a', 'c', 'e', 'b', 'd', 'f'], dtype='&lt;U1') 
 
    &gt;&gt;&gt; _reorder_for_extension_array_stack(arr, 3, 2) 
    array(['a', 'd', 'b', 'e', 'c', 'f'], dtype='&lt;U1') 
    &quot;&quot;&quot;</span>
    <span class="s3"># final take to get the order correct.</span>
    <span class="s3"># idx is an indexer like</span>
    <span class="s3"># [c0r0, c1r0, c2r0, ...,</span>
    <span class="s3">#  c0r1, c1r1, c2r1, ...]</span>
    <span class="s1">idx = np.arange(n_rows * n_columns).reshape(n_columns</span><span class="s0">, </span><span class="s1">n_rows).T.ravel()</span>
    <span class="s0">return </span><span class="s1">arr.take(idx)</span>


<span class="s0">def </span><span class="s1">stack_v3(frame: DataFrame</span><span class="s0">, </span><span class="s1">level: list[int]) -&gt; Series | DataFrame:</span>
    <span class="s0">if </span><span class="s1">frame.columns.nunique() != len(frame.columns):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Columns with duplicate values are not supported in stack&quot;</span><span class="s1">)</span>

    <span class="s3"># If we need to drop `level` from columns, it needs to be in descending order</span>
    <span class="s1">drop_levnums = sorted(level</span><span class="s0">, </span><span class="s1">reverse=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">stack_cols = frame.columns._drop_level_numbers(</span>
        <span class="s1">[k </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(frame.columns.nlevels) </span><span class="s0">if </span><span class="s1">k </span><span class="s0">not in </span><span class="s1">level][::-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s0">if </span><span class="s1">len(level) &gt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s3"># Arrange columns in the order we want to take them, e.g. level=[2, 0, 1]</span>
        <span class="s1">sorter = np.argsort(level)</span>
        <span class="s1">ordered_stack_cols = stack_cols._reorder_ilevels(sorter)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">ordered_stack_cols = stack_cols</span>

    <span class="s1">stack_cols_unique = stack_cols.unique()</span>
    <span class="s1">ordered_stack_cols_unique = ordered_stack_cols.unique()</span>

    <span class="s3"># Grab data for each unique index to be stacked</span>
    <span class="s1">buf = []</span>
    <span class="s0">for </span><span class="s1">idx </span><span class="s0">in </span><span class="s1">stack_cols_unique:</span>
        <span class="s0">if </span><span class="s1">len(frame.columns) == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">data = frame.copy()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s3"># Take the data from frame corresponding to this idx value</span>
            <span class="s0">if </span><span class="s1">len(level) == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">idx = (idx</span><span class="s0">,</span><span class="s1">)</span>
            <span class="s1">gen = iter(idx)</span>
            <span class="s1">column_indexer = tuple(</span>
                <span class="s1">next(gen) </span><span class="s0">if </span><span class="s1">k </span><span class="s0">in </span><span class="s1">level </span><span class="s0">else </span><span class="s1">slice(</span><span class="s0">None</span><span class="s1">)</span>
                <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(frame.columns.nlevels)</span>
            <span class="s1">)</span>
            <span class="s1">data = frame.loc[:</span><span class="s0">, </span><span class="s1">column_indexer]</span>

        <span class="s0">if </span><span class="s1">len(level) &lt; frame.columns.nlevels:</span>
            <span class="s1">data.columns = data.columns._drop_level_numbers(drop_levnums)</span>
        <span class="s0">elif </span><span class="s1">stack_cols.nlevels == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">data.ndim == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">data.name = </span><span class="s4">0</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">data.columns = RangeIndex(len(data.columns))</span>
        <span class="s1">buf.append(data)</span>

    <span class="s1">result: Series | DataFrame</span>
    <span class="s0">if </span><span class="s1">len(buf) &gt; </span><span class="s4">0 </span><span class="s0">and not </span><span class="s1">frame.empty:</span>
        <span class="s1">result = concat(buf)</span>
        <span class="s1">ratio = len(result) // len(frame)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s3"># input is empty</span>
        <span class="s0">if </span><span class="s1">len(level) &lt; frame.columns.nlevels:</span>
            <span class="s3"># concat column order may be different from dropping the levels</span>
            <span class="s1">new_columns = frame.columns._drop_level_numbers(drop_levnums).unique()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">new_columns = [</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">result = DataFrame(columns=new_columns</span><span class="s0">, </span><span class="s1">dtype=frame._values.dtype)</span>
        <span class="s1">ratio = </span><span class="s4">0</span>

    <span class="s0">if </span><span class="s1">len(level) &lt; frame.columns.nlevels:</span>
        <span class="s3"># concat column order may be different from dropping the levels</span>
        <span class="s1">desired_columns = frame.columns._drop_level_numbers(drop_levnums).unique()</span>
        <span class="s0">if not </span><span class="s1">result.columns.equals(desired_columns):</span>
            <span class="s1">result = result[desired_columns]</span>

    <span class="s3"># Construct the correct MultiIndex by combining the frame's index and</span>
    <span class="s3"># stacked columns.</span>
    <span class="s1">index_levels: list | FrozenList</span>
    <span class="s0">if </span><span class="s1">isinstance(frame.index</span><span class="s0">, </span><span class="s1">MultiIndex):</span>
        <span class="s1">index_levels = frame.index.levels</span>
        <span class="s1">index_codes = list(np.tile(frame.index.codes</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">ratio)))</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">index_levels = [frame.index.unique()]</span>
        <span class="s1">codes = factorize(frame.index)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">index_codes = list(np.tile(codes</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">ratio)))</span>
    <span class="s0">if </span><span class="s1">isinstance(stack_cols</span><span class="s0">, </span><span class="s1">MultiIndex):</span>
        <span class="s1">column_levels = ordered_stack_cols.levels</span>
        <span class="s1">column_codes = ordered_stack_cols.drop_duplicates().codes</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">column_levels = [ordered_stack_cols.unique()]</span>
        <span class="s1">column_codes = [factorize(ordered_stack_cols_unique</span><span class="s0">, </span><span class="s1">use_na_sentinel=</span><span class="s0">False</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]]</span>
    <span class="s1">column_codes = [np.repeat(codes</span><span class="s0">, </span><span class="s1">len(frame)) </span><span class="s0">for </span><span class="s1">codes </span><span class="s0">in </span><span class="s1">column_codes]</span>
    <span class="s1">result.index = MultiIndex(</span>
        <span class="s1">levels=index_levels + column_levels</span><span class="s0">,</span>
        <span class="s1">codes=index_codes + column_codes</span><span class="s0">,</span>
        <span class="s1">names=frame.index.names + list(ordered_stack_cols.names)</span><span class="s0">,</span>
        <span class="s1">verify_integrity=</span><span class="s0">False,</span>
    <span class="s1">)</span>

    <span class="s3"># sort result, but faster than calling sort_index since we know the order we need</span>
    <span class="s1">len_df = len(frame)</span>
    <span class="s1">n_uniques = len(ordered_stack_cols_unique)</span>
    <span class="s1">indexer = np.arange(n_uniques)</span>
    <span class="s1">idxs = np.tile(len_df * indexer</span><span class="s0">, </span><span class="s1">len_df) + np.repeat(np.arange(len_df)</span><span class="s0">, </span><span class="s1">n_uniques)</span>
    <span class="s1">result = result.take(idxs)</span>

    <span class="s3"># Reshape/rename if needed and dropna</span>
    <span class="s0">if </span><span class="s1">result.ndim == </span><span class="s4">2 </span><span class="s0">and </span><span class="s1">frame.columns.nlevels == len(level):</span>
        <span class="s0">if </span><span class="s1">len(result.columns) == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">result = Series(index=result.index)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">result = result.iloc[:</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span>
    <span class="s0">if </span><span class="s1">result.ndim == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">result.name = </span><span class="s0">None</span>

    <span class="s0">return </span><span class="s1">result</span>
</pre>
</body>
</html>