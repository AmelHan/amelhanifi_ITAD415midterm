<html>
<head>
<title>dynamic_factor.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
dynamic_factor.py</font>
</center></td></tr></table>
<pre><span class="s0"># -*- coding: utf-8 -*-</span>
<span class="s2">&quot;&quot;&quot; 
Dynamic factor model 
 
Author: Chad Fulton 
License: Simplified-BSD 
&quot;&quot;&quot;</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">.mlemodel </span><span class="s3">import </span><span class="s1">MLEModel</span><span class="s3">, </span><span class="s1">MLEResults</span><span class="s3">, </span><span class="s1">MLEResultsWrapper</span>
<span class="s3">from </span><span class="s1">.tools </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">is_invertible</span><span class="s3">, </span><span class="s1">prepare_exog</span><span class="s3">,</span>
    <span class="s1">constrain_stationary_univariate</span><span class="s3">, </span><span class="s1">unconstrain_stationary_univariate</span><span class="s3">,</span>
    <span class="s1">constrain_stationary_multivariate</span><span class="s3">, </span><span class="s1">unconstrain_stationary_multivariate</span>
<span class="s1">)</span>
<span class="s3">from </span><span class="s1">statsmodels.multivariate.pca </span><span class="s3">import </span><span class="s1">PCA</span>
<span class="s3">from </span><span class="s1">statsmodels.regression.linear_model </span><span class="s3">import </span><span class="s1">OLS</span>
<span class="s3">from </span><span class="s1">statsmodels.tsa.vector_ar.var_model </span><span class="s3">import </span><span class="s1">VAR</span>
<span class="s3">from </span><span class="s1">statsmodels.tsa.arima.model </span><span class="s3">import </span><span class="s1">ARIMA</span>
<span class="s3">from </span><span class="s1">statsmodels.tools.tools </span><span class="s3">import </span><span class="s1">Bunch</span>
<span class="s3">from </span><span class="s1">statsmodels.tools.data </span><span class="s3">import </span><span class="s1">_is_using_pandas</span>
<span class="s3">from </span><span class="s1">statsmodels.tsa.tsatools </span><span class="s3">import </span><span class="s1">lagmat</span>
<span class="s3">from </span><span class="s1">statsmodels.tools.decorators </span><span class="s3">import </span><span class="s1">cache_readonly</span>
<span class="s3">import </span><span class="s1">statsmodels.base.wrapper </span><span class="s3">as </span><span class="s1">wrap</span>
<span class="s3">from </span><span class="s1">statsmodels.compat.pandas </span><span class="s3">import </span><span class="s1">Appender</span>


<span class="s3">class </span><span class="s1">DynamicFactor(MLEModel):</span>
    <span class="s2">r&quot;&quot;&quot; 
    Dynamic factor model 
 
    Parameters 
    ---------- 
    endog : array_like 
        The observed time-series process :math:`y` 
    exog : array_like, optional 
        Array of exogenous regressors for the observation equation, shaped 
        nobs x k_exog. 
    k_factors : int 
        The number of unobserved factors. 
    factor_order : int 
        The order of the vector autoregression followed by the factors. 
    error_cov_type : {'scalar', 'diagonal', 'unstructured'}, optional 
        The structure of the covariance matrix of the observation error term, 
        where &quot;unstructured&quot; puts no restrictions on the matrix, &quot;diagonal&quot; 
        requires it to be any diagonal matrix (uncorrelated errors), and 
        &quot;scalar&quot; requires it to be a scalar times the identity matrix. Default 
        is &quot;diagonal&quot;. 
    error_order : int, optional 
        The order of the vector autoregression followed by the observation 
        error component. Default is None, corresponding to white noise errors. 
    error_var : bool, optional 
        Whether or not to model the errors jointly via a vector autoregression, 
        rather than as individual autoregressions. Has no effect unless 
        `error_order` is set. Default is False. 
    enforce_stationarity : bool, optional 
        Whether or not to transform the AR parameters to enforce stationarity 
        in the autoregressive component of the model. Default is True. 
    **kwargs 
        Keyword arguments may be used to provide default values for state space 
        matrices or for Kalman filtering options. See `Representation`, and 
        `KalmanFilter` for more details. 
 
    Attributes 
    ---------- 
    exog : array_like, optional 
        Array of exogenous regressors for the observation equation, shaped 
        nobs x k_exog. 
    k_factors : int 
        The number of unobserved factors. 
    factor_order : int 
        The order of the vector autoregression followed by the factors. 
    error_cov_type : {'diagonal', 'unstructured'} 
        The structure of the covariance matrix of the error term, where 
        &quot;unstructured&quot; puts no restrictions on the matrix and &quot;diagonal&quot; 
        requires it to be a diagonal matrix (uncorrelated errors). 
    error_order : int 
        The order of the vector autoregression followed by the observation 
        error component. 
    error_var : bool 
        Whether or not to model the errors jointly via a vector autoregression, 
        rather than as individual autoregressions. Has no effect unless 
        `error_order` is set. 
    enforce_stationarity : bool, optional 
        Whether or not to transform the AR parameters to enforce stationarity 
        in the autoregressive component of the model. Default is True. 
 
    Notes 
    ----- 
    The dynamic factor model considered here is in the so-called static form, 
    and is specified: 
 
    .. math:: 
 
        y_t &amp; = \Lambda f_t + B x_t + u_t \\ 
        f_t &amp; = A_1 f_{t-1} + \dots + A_p f_{t-p} + \eta_t \\ 
        u_t &amp; = C_1 u_{t-1} + \dots + C_q u_{t-q} + \varepsilon_t 
 
    where there are `k_endog` observed series and `k_factors` unobserved 
    factors. Thus :math:`y_t` is a `k_endog` x 1 vector and :math:`f_t` is a 
    `k_factors` x 1 vector. 
 
    :math:`x_t` are optional exogenous vectors, shaped `k_exog` x 1. 
 
    :math:`\eta_t` and :math:`\varepsilon_t` are white noise error terms. In 
    order to identify the factors, :math:`Var(\eta_t) = I`. Denote 
    :math:`Var(\varepsilon_t) \equiv \Sigma`. 
 
    Options related to the unobserved factors: 
 
    - `k_factors`: this is the dimension of the vector :math:`f_t`, above. 
      To exclude factors completely, set `k_factors = 0`. 
    - `factor_order`: this is the number of lags to include in the factor 
      evolution equation, and corresponds to :math:`p`, above. To have static 
      factors, set `factor_order = 0`. 
 
    Options related to the observation error term :math:`u_t`: 
 
    - `error_order`: the number of lags to include in the error evolution 
      equation; corresponds to :math:`q`, above. To have white noise errors, 
      set `error_order = 0` (this is the default). 
    - `error_cov_type`: this controls the form of the covariance matrix 
      :math:`\Sigma`. If it is &quot;dscalar&quot;, then :math:`\Sigma = \sigma^2 I`. If 
      it is &quot;diagonal&quot;, then 
      :math:`\Sigma = \text{diag}(\sigma_1^2, \dots, \sigma_n^2)`. If it is 
      &quot;unstructured&quot;, then :math:`\Sigma` is any valid variance / covariance 
      matrix (i.e. symmetric and positive definite). 
    - `error_var`: this controls whether or not the errors evolve jointly 
      according to a VAR(q), or individually according to separate AR(q) 
      processes. In terms of the formulation above, if `error_var = False`, 
      then the matrices :math:C_i` are diagonal, otherwise they are general 
      VAR matrices. 
 
    References 
    ---------- 
    .. [*] LÃ¼tkepohl, Helmut. 2007. 
       New Introduction to Multiple Time Series Analysis. 
       Berlin: Springer. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">endog</span><span class="s3">, </span><span class="s1">k_factors</span><span class="s3">, </span><span class="s1">factor_order</span><span class="s3">, </span><span class="s1">exog=</span><span class="s3">None,</span>
                 <span class="s1">error_order=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">error_var=</span><span class="s3">False, </span><span class="s1">error_cov_type=</span><span class="s5">'diagonal'</span><span class="s3">,</span>
                 <span class="s1">enforce_stationarity=</span><span class="s3">True, </span><span class="s1">**kwargs):</span>

        <span class="s0"># Model properties</span>
        <span class="s1">self.enforce_stationarity = enforce_stationarity</span>

        <span class="s0"># Factor-related properties</span>
        <span class="s1">self.k_factors = k_factors</span>
        <span class="s1">self.factor_order = factor_order</span>

        <span class="s0"># Error-related properties</span>
        <span class="s1">self.error_order = error_order</span>
        <span class="s1">self.error_var = error_var </span><span class="s3">and </span><span class="s1">error_order &gt; </span><span class="s4">0</span>
        <span class="s1">self.error_cov_type = error_cov_type</span>

        <span class="s0"># Exogenous data</span>
        <span class="s1">(self.k_exog</span><span class="s3">, </span><span class="s1">exog) = prepare_exog(exog)</span>

        <span class="s0"># Note: at some point in the future might add state regression, as in</span>
        <span class="s0"># SARIMAX.</span>
        <span class="s1">self.mle_regression = self.k_exog &gt; </span><span class="s4">0</span>

        <span class="s0"># We need to have an array or pandas at this point</span>
        <span class="s3">if not </span><span class="s1">_is_using_pandas(endog</span><span class="s3">, None</span><span class="s1">):</span>
            <span class="s1">endog = np.asanyarray(endog</span><span class="s3">, </span><span class="s1">order=</span><span class="s5">'C'</span><span class="s1">)</span>

        <span class="s0"># Save some useful model orders, internally used</span>
        <span class="s1">k_endog = endog.shape[</span><span class="s4">1</span><span class="s1">] </span><span class="s3">if </span><span class="s1">endog.ndim &gt; </span><span class="s4">1 </span><span class="s3">else </span><span class="s4">1</span>
        <span class="s1">self._factor_order = max(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">self.factor_order) * self.k_factors</span>
        <span class="s1">self._error_order = self.error_order * k_endog</span>

        <span class="s0"># Calculate the number of states</span>
        <span class="s1">k_states = self._factor_order</span>
        <span class="s1">k_posdef = self.k_factors</span>
        <span class="s3">if </span><span class="s1">self.error_order &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">k_states += self._error_order</span>
            <span class="s1">k_posdef += k_endog</span>

        <span class="s0"># We can still estimate the model with no dynamic state (e.g. SUR), we</span>
        <span class="s0"># just need to have one state that does nothing.</span>
        <span class="s1">self._unused_state = </span><span class="s3">False</span>
        <span class="s3">if </span><span class="s1">k_states == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">k_states = </span><span class="s4">1</span>
            <span class="s1">k_posdef = </span><span class="s4">1</span>
            <span class="s1">self._unused_state = </span><span class="s3">True</span>

        <span class="s0"># Test for non-multivariate endog</span>
        <span class="s3">if </span><span class="s1">k_endog &lt; </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'The dynamic factors model is only valid for'</span>
                             <span class="s5">' multivariate time series.'</span><span class="s1">)</span>

        <span class="s0"># Test for too many factors</span>
        <span class="s3">if </span><span class="s1">self.k_factors &gt;= k_endog:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'Number of factors must be less than the number'</span>
                             <span class="s5">' of endogenous variables.'</span><span class="s1">)</span>

        <span class="s0"># Test for invalid error_cov_type</span>
        <span class="s3">if </span><span class="s1">self.error_cov_type </span><span class="s3">not in </span><span class="s1">[</span><span class="s5">'scalar'</span><span class="s3">, </span><span class="s5">'diagonal'</span><span class="s3">, </span><span class="s5">'unstructured'</span><span class="s1">]:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'Invalid error covariance matrix type'</span>
                             <span class="s5">' specification.'</span><span class="s1">)</span>

        <span class="s0"># By default, initialize as stationary</span>
        <span class="s1">kwargs.setdefault(</span><span class="s5">'initialization'</span><span class="s3">, </span><span class="s5">'stationary'</span><span class="s1">)</span>

        <span class="s0"># Initialize the state space model</span>
        <span class="s1">super(DynamicFactor</span><span class="s3">, </span><span class="s1">self).__init__(</span>
            <span class="s1">endog</span><span class="s3">, </span><span class="s1">exog=exog</span><span class="s3">, </span><span class="s1">k_states=k_states</span><span class="s3">, </span><span class="s1">k_posdef=k_posdef</span><span class="s3">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>

        <span class="s0"># Set as time-varying model if we have exog</span>
        <span class="s3">if </span><span class="s1">self.k_exog &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">self.ssm._time_invariant = </span><span class="s3">False</span>

        <span class="s0"># Initialize the components</span>
        <span class="s1">self.parameters = {}</span>
        <span class="s1">self._initialize_loadings()</span>
        <span class="s1">self._initialize_exog()</span>
        <span class="s1">self._initialize_error_cov()</span>
        <span class="s1">self._initialize_factor_transition()</span>
        <span class="s1">self._initialize_error_transition()</span>
        <span class="s1">self.k_params = sum(self.parameters.values())</span>

        <span class="s0"># Cache parameter vector slices</span>
        <span class="s3">def </span><span class="s1">_slice(key</span><span class="s3">, </span><span class="s1">offset):</span>
            <span class="s1">length = self.parameters[key]</span>
            <span class="s1">param_slice = np.s_[offset:offset + length]</span>
            <span class="s1">offset += length</span>
            <span class="s3">return </span><span class="s1">param_slice</span><span class="s3">, </span><span class="s1">offset</span>

        <span class="s1">offset = </span><span class="s4">0</span>
        <span class="s1">self._params_loadings</span><span class="s3">, </span><span class="s1">offset = _slice(</span><span class="s5">'factor_loadings'</span><span class="s3">, </span><span class="s1">offset)</span>
        <span class="s1">self._params_exog</span><span class="s3">, </span><span class="s1">offset = _slice(</span><span class="s5">'exog'</span><span class="s3">, </span><span class="s1">offset)</span>
        <span class="s1">self._params_error_cov</span><span class="s3">, </span><span class="s1">offset = _slice(</span><span class="s5">'error_cov'</span><span class="s3">, </span><span class="s1">offset)</span>
        <span class="s1">self._params_factor_transition</span><span class="s3">, </span><span class="s1">offset = (</span>
            <span class="s1">_slice(</span><span class="s5">'factor_transition'</span><span class="s3">, </span><span class="s1">offset))</span>
        <span class="s1">self._params_error_transition</span><span class="s3">, </span><span class="s1">offset = (</span>
            <span class="s1">_slice(</span><span class="s5">'error_transition'</span><span class="s3">, </span><span class="s1">offset))</span>

        <span class="s0"># Update _init_keys attached by super</span>
        <span class="s1">self._init_keys += [</span><span class="s5">'k_factors'</span><span class="s3">, </span><span class="s5">'factor_order'</span><span class="s3">, </span><span class="s5">'error_order'</span><span class="s3">,</span>
                            <span class="s5">'error_var'</span><span class="s3">, </span><span class="s5">'error_cov_type'</span><span class="s3">,</span>
                            <span class="s5">'enforce_stationarity'</span><span class="s1">] + list(kwargs.keys())</span>

    <span class="s3">def </span><span class="s1">_initialize_loadings(self):</span>
        <span class="s0"># Initialize the parameters</span>
        <span class="s1">self.parameters[</span><span class="s5">'factor_loadings'</span><span class="s1">] = self.k_endog * self.k_factors</span>

        <span class="s0"># Setup fixed components of state space matrices</span>
        <span class="s3">if </span><span class="s1">self.error_order &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">start = self._factor_order</span>
            <span class="s1">end = self._factor_order + self.k_endog</span>
            <span class="s1">self.ssm[</span><span class="s5">'design'</span><span class="s3">, </span><span class="s1">:</span><span class="s3">, </span><span class="s1">start:end] = np.eye(self.k_endog)</span>

        <span class="s0"># Setup indices of state space matrices</span>
        <span class="s1">self._idx_loadings = np.s_[</span><span class="s5">'design'</span><span class="s3">, </span><span class="s1">:</span><span class="s3">, </span><span class="s1">:self.k_factors]</span>

    <span class="s3">def </span><span class="s1">_initialize_exog(self):</span>
        <span class="s0"># Initialize the parameters</span>
        <span class="s1">self.parameters[</span><span class="s5">'exog'</span><span class="s1">] = self.k_exog * self.k_endog</span>

        <span class="s0"># If we have exog effects, then the obs intercept needs to be</span>
        <span class="s0"># time-varying</span>
        <span class="s3">if </span><span class="s1">self.k_exog &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">self.ssm[</span><span class="s5">'obs_intercept'</span><span class="s1">] = np.zeros((self.k_endog</span><span class="s3">, </span><span class="s1">self.nobs))</span>

        <span class="s0"># Setup indices of state space matrices</span>
        <span class="s1">self._idx_exog = np.s_[</span><span class="s5">'obs_intercept'</span><span class="s3">, </span><span class="s1">:self.k_endog</span><span class="s3">, </span><span class="s1">:]</span>

    <span class="s3">def </span><span class="s1">_initialize_error_cov(self):</span>
        <span class="s3">if </span><span class="s1">self.error_cov_type == </span><span class="s5">'scalar'</span><span class="s1">:</span>
            <span class="s1">self._initialize_error_cov_diagonal(scalar=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s3">elif </span><span class="s1">self.error_cov_type == </span><span class="s5">'diagonal'</span><span class="s1">:</span>
            <span class="s1">self._initialize_error_cov_diagonal(scalar=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s3">elif </span><span class="s1">self.error_cov_type == </span><span class="s5">'unstructured'</span><span class="s1">:</span>
            <span class="s1">self._initialize_error_cov_unstructured()</span>

    <span class="s3">def </span><span class="s1">_initialize_error_cov_diagonal(self</span><span class="s3">, </span><span class="s1">scalar=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s0"># Initialize the parameters</span>
        <span class="s1">self.parameters[</span><span class="s5">'error_cov'</span><span class="s1">] = </span><span class="s4">1 </span><span class="s3">if </span><span class="s1">scalar </span><span class="s3">else </span><span class="s1">self.k_endog</span>

        <span class="s0"># Setup fixed components of state space matrices</span>

        <span class="s0"># Setup indices of state space matrices</span>
        <span class="s1">k_endog = self.k_endog</span>
        <span class="s1">k_factors = self.k_factors</span>
        <span class="s1">idx = np.diag_indices(k_endog)</span>
        <span class="s3">if </span><span class="s1">self.error_order &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">matrix = </span><span class="s5">'state_cov'</span>
            <span class="s1">idx = (idx[</span><span class="s4">0</span><span class="s1">] + k_factors</span><span class="s3">, </span><span class="s1">idx[</span><span class="s4">1</span><span class="s1">] + k_factors)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">matrix = </span><span class="s5">'obs_cov'</span>
        <span class="s1">self._idx_error_cov = (matrix</span><span class="s3">,</span><span class="s1">) + idx</span>

    <span class="s3">def </span><span class="s1">_initialize_error_cov_unstructured(self):</span>
        <span class="s0"># Initialize the parameters</span>
        <span class="s1">k_endog = self.k_endog</span>
        <span class="s1">self.parameters[</span><span class="s5">'error_cov'</span><span class="s1">] = int(k_endog * (k_endog + </span><span class="s4">1</span><span class="s1">) / </span><span class="s4">2</span><span class="s1">)</span>

        <span class="s0"># Setup fixed components of state space matrices</span>

        <span class="s0"># Setup indices of state space matrices</span>
        <span class="s1">self._idx_lower_error_cov = np.tril_indices(self.k_endog)</span>
        <span class="s3">if </span><span class="s1">self.error_order &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">start = self.k_factors</span>
            <span class="s1">end = self.k_factors + self.k_endog</span>
            <span class="s1">self._idx_error_cov = (</span>
                <span class="s1">np.s_[</span><span class="s5">'state_cov'</span><span class="s3">, </span><span class="s1">start:end</span><span class="s3">, </span><span class="s1">start:end])</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self._idx_error_cov = np.s_[</span><span class="s5">'obs_cov'</span><span class="s3">, </span><span class="s1">:</span><span class="s3">, </span><span class="s1">:]</span>

    <span class="s3">def </span><span class="s1">_initialize_factor_transition(self):</span>
        <span class="s1">order = self.factor_order * self.k_factors</span>
        <span class="s1">k_factors = self.k_factors</span>

        <span class="s0"># Initialize the parameters</span>
        <span class="s1">self.parameters[</span><span class="s5">'factor_transition'</span><span class="s1">] = (</span>
            <span class="s1">self.factor_order * self.k_factors**</span><span class="s4">2</span><span class="s1">)</span>

        <span class="s0"># Setup fixed components of state space matrices</span>
        <span class="s0"># VAR(p) for factor transition</span>
        <span class="s3">if </span><span class="s1">self.k_factors &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">self.factor_order &gt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">self.ssm[</span><span class="s5">'transition'</span><span class="s3">, </span><span class="s1">k_factors:order</span><span class="s3">, </span><span class="s1">:order - k_factors] = (</span>
                    <span class="s1">np.eye(order - k_factors))</span>

            <span class="s1">self.ssm[</span><span class="s5">'selection'</span><span class="s3">, </span><span class="s1">:k_factors</span><span class="s3">, </span><span class="s1">:k_factors] = np.eye(k_factors)</span>
            <span class="s0"># Identification requires constraining the state covariance to an</span>
            <span class="s0"># identity matrix</span>
            <span class="s1">self.ssm[</span><span class="s5">'state_cov'</span><span class="s3">, </span><span class="s1">:k_factors</span><span class="s3">, </span><span class="s1">:k_factors] = np.eye(k_factors)</span>

        <span class="s0"># Setup indices of state space matrices</span>
        <span class="s1">self._idx_factor_transition = np.s_[</span><span class="s5">'transition'</span><span class="s3">, </span><span class="s1">:k_factors</span><span class="s3">, </span><span class="s1">:order]</span>

    <span class="s3">def </span><span class="s1">_initialize_error_transition(self):</span>
        <span class="s0"># Initialize the appropriate situation</span>
        <span class="s3">if </span><span class="s1">self.error_order == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">self._initialize_error_transition_white_noise()</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># Generic setup fixed components of state space matrices</span>
            <span class="s0"># VAR(q) for error transition</span>
            <span class="s0"># (in the individual AR case, we still have the VAR(q) companion</span>
            <span class="s0"># matrix structure, but force the coefficient matrices to be</span>
            <span class="s0"># diagonal)</span>
            <span class="s1">k_endog = self.k_endog</span>
            <span class="s1">k_factors = self.k_factors</span>
            <span class="s1">_factor_order = self._factor_order</span>
            <span class="s1">_error_order = self._error_order</span>
            <span class="s1">_slice = np.s_[</span><span class="s5">'selection'</span><span class="s3">,</span>
                           <span class="s1">_factor_order:_factor_order + k_endog</span><span class="s3">,</span>
                           <span class="s1">k_factors:k_factors + k_endog]</span>
            <span class="s1">self.ssm[_slice] = np.eye(k_endog)</span>
            <span class="s1">_slice = np.s_[</span>
                <span class="s5">'transition'</span><span class="s3">,</span>
                <span class="s1">_factor_order + k_endog:_factor_order + _error_order</span><span class="s3">,</span>
                <span class="s1">_factor_order:_factor_order + _error_order - k_endog]</span>
            <span class="s1">self.ssm[_slice] = np.eye(_error_order - k_endog)</span>

            <span class="s0"># Now specialized setups</span>
            <span class="s3">if </span><span class="s1">self.error_var:</span>
                <span class="s1">self._initialize_error_transition_var()</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self._initialize_error_transition_individual()</span>

    <span class="s3">def </span><span class="s1">_initialize_error_transition_white_noise(self):</span>
        <span class="s0"># Initialize the parameters</span>
        <span class="s1">self.parameters[</span><span class="s5">'error_transition'</span><span class="s1">] = </span><span class="s4">0</span>

        <span class="s0"># No fixed components of state space matrices</span>

        <span class="s0"># Setup indices of state space matrices (just an empty slice)</span>
        <span class="s1">self._idx_error_transition = np.s_[</span><span class="s5">'transition'</span><span class="s3">, </span><span class="s4">0</span><span class="s1">:</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">:</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">_initialize_error_transition_var(self):</span>
        <span class="s1">k_endog = self.k_endog</span>
        <span class="s1">_factor_order = self._factor_order</span>
        <span class="s1">_error_order = self._error_order</span>

        <span class="s0"># Initialize the parameters</span>
        <span class="s1">self.parameters[</span><span class="s5">'error_transition'</span><span class="s1">] = _error_order * k_endog</span>

        <span class="s0"># Fixed components already setup above</span>

        <span class="s0"># Setup indices of state space matrices</span>
        <span class="s0"># Here we want to set all of the elements of the coefficient matrices,</span>
        <span class="s0"># the same as in a VAR specification</span>
        <span class="s1">self._idx_error_transition = np.s_[</span>
            <span class="s5">'transition'</span><span class="s3">,</span>
            <span class="s1">_factor_order:_factor_order + k_endog</span><span class="s3">,</span>
            <span class="s1">_factor_order:_factor_order + _error_order]</span>

    <span class="s3">def </span><span class="s1">_initialize_error_transition_individual(self):</span>
        <span class="s1">k_endog = self.k_endog</span>
        <span class="s1">_error_order = self._error_order</span>

        <span class="s0"># Initialize the parameters</span>
        <span class="s1">self.parameters[</span><span class="s5">'error_transition'</span><span class="s1">] = _error_order</span>

        <span class="s0"># Fixed components already setup above</span>

        <span class="s0"># Setup indices of state space matrices</span>
        <span class="s0"># Here we want to set only the diagonal elements of the coefficient</span>
        <span class="s0"># matrices, and we want to set them in order by equation, not by</span>
        <span class="s0"># matrix (i.e. set the first element of the first matrix's diagonal,</span>
        <span class="s0"># then set the first element of the second matrix's diagonal, then...)</span>

        <span class="s0"># The basic setup is a tiled list of diagonal indices, one for each</span>
        <span class="s0"># coefficient matrix</span>
        <span class="s1">idx = np.tile(np.diag_indices(k_endog)</span><span class="s3">, </span><span class="s1">self.error_order)</span>
        <span class="s0"># Now we need to shift the rows down to the correct location</span>
        <span class="s1">row_shift = self._factor_order</span>
        <span class="s0"># And we need to shift the columns in an increasing way</span>
        <span class="s1">col_inc = self._factor_order + np.repeat(</span>
            <span class="s1">[i * k_endog </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(self.error_order)]</span><span class="s3">, </span><span class="s1">k_endog)</span>
        <span class="s1">idx[</span><span class="s4">0</span><span class="s1">] += row_shift</span>
        <span class="s1">idx[</span><span class="s4">1</span><span class="s1">] += col_inc</span>

        <span class="s0"># Make a copy (without the row shift) so that we can easily get the</span>
        <span class="s0"># diagonal parameters back out of a generic coefficients matrix array</span>
        <span class="s1">idx_diag = idx.copy()</span>
        <span class="s1">idx_diag[</span><span class="s4">0</span><span class="s1">] -= row_shift</span>
        <span class="s1">idx_diag[</span><span class="s4">1</span><span class="s1">] -= self._factor_order</span>
        <span class="s1">idx_diag = idx_diag[:</span><span class="s3">, </span><span class="s1">np.lexsort((idx_diag[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">idx_diag[</span><span class="s4">0</span><span class="s1">]))]</span>
        <span class="s1">self._idx_error_diag = (idx_diag[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">idx_diag[</span><span class="s4">1</span><span class="s1">])</span>

        <span class="s0"># Finally, we want to fill the entries in in the correct order, which</span>
        <span class="s0"># is to say we want to fill in lexicographically, first by row then by</span>
        <span class="s0"># column</span>
        <span class="s1">idx = idx[:</span><span class="s3">, </span><span class="s1">np.lexsort((idx[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">idx[</span><span class="s4">0</span><span class="s1">]))]</span>
        <span class="s1">self._idx_error_transition = np.s_[</span><span class="s5">'transition'</span><span class="s3">, </span><span class="s1">idx[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">idx[</span><span class="s4">1</span><span class="s1">]]</span>

    <span class="s3">def </span><span class="s1">clone(self</span><span class="s3">, </span><span class="s1">endog</span><span class="s3">, </span><span class="s1">exog=</span><span class="s3">None, </span><span class="s1">**kwargs):</span>
        <span class="s3">return </span><span class="s1">self._clone_from_init_kwds(endog</span><span class="s3">, </span><span class="s1">exog=exog</span><span class="s3">, </span><span class="s1">**kwargs)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">_res_classes(self):</span>
        <span class="s3">return </span><span class="s1">{</span><span class="s5">'fit'</span><span class="s1">: (DynamicFactorResults</span><span class="s3">, </span><span class="s1">DynamicFactorResultsWrapper)}</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">start_params(self):</span>
        <span class="s1">params = np.zeros(self.k_params</span><span class="s3">, </span><span class="s1">dtype=np.float64)</span>

        <span class="s1">endog = self.endog.copy()</span>
        <span class="s1">mask = ~np.any(np.isnan(endog)</span><span class="s3">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">endog = endog[mask]</span>
        <span class="s3">if </span><span class="s1">self.k_exog &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">exog = self.exog[mask]</span>

        <span class="s0"># 1. Factor loadings (estimated via PCA)</span>
        <span class="s3">if </span><span class="s1">self.k_factors &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s0"># Use principal components + OLS as starting values</span>
            <span class="s1">res_pca = PCA(endog</span><span class="s3">, </span><span class="s1">ncomp=self.k_factors)</span>
            <span class="s1">mod_ols = OLS(endog</span><span class="s3">, </span><span class="s1">res_pca.factors)</span>
            <span class="s1">res_ols = mod_ols.fit()</span>

            <span class="s0"># Using OLS params for the loadings tends to gives higher starting</span>
            <span class="s0"># log-likelihood.</span>
            <span class="s1">params[self._params_loadings] = res_ols.params.T.ravel()</span>
            <span class="s0"># params[self._params_loadings] = res_pca.loadings.ravel()</span>

            <span class="s0"># However, using res_ols.resid tends to causes non-invertible</span>
            <span class="s0"># starting VAR coefficients for error VARs</span>
            <span class="s0"># endog = res_ols.resid</span>
            <span class="s1">endog = endog - np.dot(res_pca.factors</span><span class="s3">, </span><span class="s1">res_pca.loadings.T)</span>

        <span class="s0"># 2. Exog (OLS on residuals)</span>
        <span class="s3">if </span><span class="s1">self.k_exog &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">mod_ols = OLS(endog</span><span class="s3">, </span><span class="s1">exog=exog)</span>
            <span class="s1">res_ols = mod_ols.fit()</span>
            <span class="s0"># In the form: beta.x1.y1, beta.x2.y1, beta.x1.y2, ...</span>
            <span class="s1">params[self._params_exog] = res_ols.params.T.ravel()</span>
            <span class="s1">endog = res_ols.resid</span>

        <span class="s0"># 3. Factors (VAR on res_pca.factors)</span>
        <span class="s1">stationary = </span><span class="s3">True</span>
        <span class="s3">if </span><span class="s1">self.k_factors &gt; </span><span class="s4">1 </span><span class="s3">and </span><span class="s1">self.factor_order &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s0"># 3a. VAR transition (OLS on factors estimated via PCA)</span>
            <span class="s1">mod_factors = VAR(res_pca.factors)</span>
            <span class="s1">res_factors = mod_factors.fit(maxlags=self.factor_order</span><span class="s3">, </span><span class="s1">ic=</span><span class="s3">None,</span>
                                          <span class="s1">trend=</span><span class="s5">'n'</span><span class="s1">)</span>
            <span class="s0"># Save the parameters</span>
            <span class="s1">params[self._params_factor_transition] = (</span>
                <span class="s1">res_factors.params.T.ravel())</span>

            <span class="s0"># Test for stationarity</span>
            <span class="s1">coefficient_matrices = (</span>
                <span class="s1">params[self._params_factor_transition].reshape(</span>
                    <span class="s1">self.k_factors * self.factor_order</span><span class="s3">, </span><span class="s1">self.k_factors</span>
                <span class="s1">).T</span>
            <span class="s1">).reshape(self.k_factors</span><span class="s3">, </span><span class="s1">self.k_factors</span><span class="s3">, </span><span class="s1">self.factor_order).T</span>

            <span class="s1">stationary = is_invertible([</span><span class="s4">1</span><span class="s1">] + list(-coefficient_matrices))</span>
        <span class="s3">elif </span><span class="s1">self.k_factors &gt; </span><span class="s4">0 </span><span class="s3">and </span><span class="s1">self.factor_order &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s0"># 3b. AR transition</span>
            <span class="s1">Y = res_pca.factors[self.factor_order:]</span>
            <span class="s1">X = lagmat(res_pca.factors</span><span class="s3">, </span><span class="s1">self.factor_order</span><span class="s3">, </span><span class="s1">trim=</span><span class="s5">'both'</span><span class="s1">)</span>
            <span class="s1">params_ar = np.linalg.pinv(X).dot(Y)</span>
            <span class="s1">stationary = is_invertible(np.r_[</span><span class="s4">1</span><span class="s3">, </span><span class="s1">-params_ar.squeeze()])</span>
            <span class="s1">params[self._params_factor_transition] = params_ar[:</span><span class="s3">, </span><span class="s4">0</span><span class="s1">]</span>

        <span class="s0"># Check for stationarity</span>
        <span class="s3">if not </span><span class="s1">stationary </span><span class="s3">and </span><span class="s1">self.enforce_stationarity:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'Non-stationary starting autoregressive'</span>
                             <span class="s5">' parameters found with `enforce_stationarity`'</span>
                             <span class="s5">' set to True.'</span><span class="s1">)</span>

        <span class="s0"># 4. Errors</span>
        <span class="s3">if </span><span class="s1">self.error_order == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">self.error_cov_type == </span><span class="s5">'scalar'</span><span class="s1">:</span>
                <span class="s1">params[self._params_error_cov] = endog.var(axis=</span><span class="s4">0</span><span class="s1">).mean()</span>
            <span class="s3">elif </span><span class="s1">self.error_cov_type == </span><span class="s5">'diagonal'</span><span class="s1">:</span>
                <span class="s1">params[self._params_error_cov] = endog.var(axis=</span><span class="s4">0</span><span class="s1">)</span>
            <span class="s3">elif </span><span class="s1">self.error_cov_type == </span><span class="s5">'unstructured'</span><span class="s1">:</span>
                <span class="s1">cov_factor = np.diag(endog.std(axis=</span><span class="s4">0</span><span class="s1">))</span>
                <span class="s1">params[self._params_error_cov] = (</span>
                    <span class="s1">cov_factor[self._idx_lower_error_cov].ravel())</span>
        <span class="s3">elif </span><span class="s1">self.error_var:</span>
            <span class="s1">mod_errors = VAR(endog)</span>
            <span class="s1">res_errors = mod_errors.fit(maxlags=self.error_order</span><span class="s3">, </span><span class="s1">ic=</span><span class="s3">None,</span>
                                        <span class="s1">trend=</span><span class="s5">'n'</span><span class="s1">)</span>

            <span class="s0"># Test for stationarity</span>
            <span class="s1">coefficient_matrices = (</span>
                <span class="s1">np.array(res_errors.params.T).ravel().reshape(</span>
                    <span class="s1">self.k_endog * self.error_order</span><span class="s3">, </span><span class="s1">self.k_endog</span>
                <span class="s1">).T</span>
            <span class="s1">).reshape(self.k_endog</span><span class="s3">, </span><span class="s1">self.k_endog</span><span class="s3">, </span><span class="s1">self.error_order).T</span>

            <span class="s1">stationary = is_invertible([</span><span class="s4">1</span><span class="s1">] + list(-coefficient_matrices))</span>
            <span class="s3">if not </span><span class="s1">stationary </span><span class="s3">and </span><span class="s1">self.enforce_stationarity:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'Non-stationary starting error autoregressive'</span>
                                 <span class="s5">' parameters found with'</span>
                                 <span class="s5">' `enforce_stationarity` set to True.'</span><span class="s1">)</span>

            <span class="s0"># Get the error autoregressive parameters</span>
            <span class="s1">params[self._params_error_transition] = (</span>
                    <span class="s1">np.array(res_errors.params.T).ravel())</span>

            <span class="s0"># Get the error covariance parameters</span>
            <span class="s3">if </span><span class="s1">self.error_cov_type == </span><span class="s5">'scalar'</span><span class="s1">:</span>
                <span class="s1">params[self._params_error_cov] = (</span>
                    <span class="s1">res_errors.sigma_u.diagonal().mean())</span>
            <span class="s3">elif </span><span class="s1">self.error_cov_type == </span><span class="s5">'diagonal'</span><span class="s1">:</span>
                <span class="s1">params[self._params_error_cov] = res_errors.sigma_u.diagonal()</span>
            <span class="s3">elif </span><span class="s1">self.error_cov_type == </span><span class="s5">'unstructured'</span><span class="s1">:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">cov_factor = np.linalg.cholesky(res_errors.sigma_u)</span>
                <span class="s3">except </span><span class="s1">np.linalg.LinAlgError:</span>
                    <span class="s1">cov_factor = np.eye(res_errors.sigma_u.shape[</span><span class="s4">0</span><span class="s1">]) * (</span>
                        <span class="s1">res_errors.sigma_u.diagonal().mean()**</span><span class="s4">0.5</span><span class="s1">)</span>
                <span class="s1">cov_factor = np.eye(res_errors.sigma_u.shape[</span><span class="s4">0</span><span class="s1">]) * (</span>
                    <span class="s1">res_errors.sigma_u.diagonal().mean()**</span><span class="s4">0.5</span><span class="s1">)</span>
                <span class="s1">params[self._params_error_cov] = (</span>
                    <span class="s1">cov_factor[self._idx_lower_error_cov].ravel())</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">error_ar_params = []</span>
            <span class="s1">error_cov_params = []</span>
            <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(self.k_endog):</span>
                <span class="s1">mod_error = ARIMA(endog[:</span><span class="s3">, </span><span class="s1">i]</span><span class="s3">, </span><span class="s1">order=(self.error_order</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span><span class="s3">,</span>
                                  <span class="s1">trend=</span><span class="s5">'n'</span><span class="s3">, </span><span class="s1">enforce_stationarity=</span><span class="s3">True</span><span class="s1">)</span>
                <span class="s1">res_error = mod_error.fit(method=</span><span class="s5">'burg'</span><span class="s1">)</span>
                <span class="s1">error_ar_params += res_error.params[:self.error_order].tolist()</span>
                <span class="s1">error_cov_params += res_error.params[-</span><span class="s4">1</span><span class="s1">:].tolist()</span>

            <span class="s1">params[self._params_error_transition] = np.r_[error_ar_params]</span>
            <span class="s1">params[self._params_error_cov] = np.r_[error_cov_params]</span>

        <span class="s3">return </span><span class="s1">params</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">param_names(self):</span>
        <span class="s1">param_names = []</span>
        <span class="s1">endog_names = self.endog_names</span>

        <span class="s0"># 1. Factor loadings</span>
        <span class="s1">param_names += [</span>
            <span class="s5">'loading.f%d.%s' </span><span class="s1">% (j+</span><span class="s4">1</span><span class="s3">, </span><span class="s1">endog_names[i])</span>
            <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(self.k_endog)</span>
            <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range(self.k_factors)</span>
        <span class="s1">]</span>

        <span class="s0"># 2. Exog</span>
        <span class="s0"># Recall these are in the form: beta.x1.y1, beta.x2.y1, beta.x1.y2, ...</span>
        <span class="s1">param_names += [</span>
            <span class="s5">'beta.%s.%s' </span><span class="s1">% (self.exog_names[j]</span><span class="s3">, </span><span class="s1">endog_names[i])</span>
            <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(self.k_endog)</span>
            <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range(self.k_exog)</span>
        <span class="s1">]</span>

        <span class="s0"># 3. Error covariances</span>
        <span class="s3">if </span><span class="s1">self.error_cov_type == </span><span class="s5">'scalar'</span><span class="s1">:</span>
            <span class="s1">param_names += [</span><span class="s5">'sigma2'</span><span class="s1">]</span>
        <span class="s3">elif </span><span class="s1">self.error_cov_type == </span><span class="s5">'diagonal'</span><span class="s1">:</span>
            <span class="s1">param_names += [</span>
                <span class="s5">'sigma2.%s' </span><span class="s1">% endog_names[i]</span>
                <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(self.k_endog)</span>
            <span class="s1">]</span>
        <span class="s3">elif </span><span class="s1">self.error_cov_type == </span><span class="s5">'unstructured'</span><span class="s1">:</span>
            <span class="s1">param_names += [</span>
                <span class="s5">'cov.chol[%d,%d]' </span><span class="s1">% (i + </span><span class="s4">1</span><span class="s3">, </span><span class="s1">j + </span><span class="s4">1</span><span class="s1">)</span>
                <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(self.k_endog)</span>
                <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range(i+</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">]</span>

        <span class="s0"># 4. Factor transition VAR</span>
        <span class="s1">param_names += [</span>
            <span class="s5">'L%d.f%d.f%d' </span><span class="s1">% (i+</span><span class="s4">1</span><span class="s3">, </span><span class="s1">k+</span><span class="s4">1</span><span class="s3">, </span><span class="s1">j+</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range(self.k_factors)</span>
            <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(self.factor_order)</span>
            <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">range(self.k_factors)</span>
        <span class="s1">]</span>

        <span class="s0"># 5. Error transition VAR</span>
        <span class="s3">if </span><span class="s1">self.error_var:</span>
            <span class="s1">param_names += [</span>
                <span class="s5">'L%d.e(%s).e(%s)' </span><span class="s1">% (i+</span><span class="s4">1</span><span class="s3">, </span><span class="s1">endog_names[k]</span><span class="s3">, </span><span class="s1">endog_names[j])</span>
                <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range(self.k_endog)</span>
                <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(self.error_order)</span>
                <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">range(self.k_endog)</span>
            <span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">param_names += [</span>
                <span class="s5">'L%d.e(%s).e(%s)' </span><span class="s1">% (i+</span><span class="s4">1</span><span class="s3">, </span><span class="s1">endog_names[j]</span><span class="s3">, </span><span class="s1">endog_names[j])</span>
                <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range(self.k_endog)</span>
                <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(self.error_order)</span>
            <span class="s1">]</span>

        <span class="s3">return </span><span class="s1">param_names</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">state_names(self):</span>
        <span class="s1">names = []</span>
        <span class="s1">endog_names = self.endog_names</span>

        <span class="s0"># Factors and lags</span>
        <span class="s1">names += [</span>
            <span class="s1">((</span><span class="s5">'f%d' </span><span class="s1">% (j + </span><span class="s4">1</span><span class="s1">)) </span><span class="s3">if </span><span class="s1">i == </span><span class="s4">0 </span><span class="s3">else </span><span class="s1">(</span><span class="s5">'f%d.L%d' </span><span class="s1">% (j + </span><span class="s4">1</span><span class="s3">, </span><span class="s1">i)))</span>
            <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(max(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">self.factor_order))</span>
            <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range(self.k_factors)]</span>

        <span class="s3">if </span><span class="s1">self.error_order &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">names += [</span>
                <span class="s1">((</span><span class="s5">'e(%s)' </span><span class="s1">% endog_names[j]) </span><span class="s3">if </span><span class="s1">i == </span><span class="s4">0</span>
                 <span class="s3">else </span><span class="s1">(</span><span class="s5">'e(%s).L%d' </span><span class="s1">% (endog_names[j]</span><span class="s3">, </span><span class="s1">i)))</span>
                <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(self.error_order)</span>
                <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range(self.k_endog)]</span>

        <span class="s3">if </span><span class="s1">self._unused_state:</span>
            <span class="s1">names += [</span><span class="s5">'dummy'</span><span class="s1">]</span>

        <span class="s3">return </span><span class="s1">names</span>

    <span class="s3">def </span><span class="s1">transform_params(self</span><span class="s3">, </span><span class="s1">unconstrained):</span>
        <span class="s2">&quot;&quot;&quot; 
        Transform unconstrained parameters used by the optimizer to constrained 
        parameters used in likelihood evaluation 
 
        Parameters 
        ---------- 
        unconstrained : array_like 
            Array of unconstrained parameters used by the optimizer, to be 
            transformed. 
 
        Returns 
        ------- 
        constrained : array_like 
            Array of constrained parameters which may be used in likelihood 
            evaluation. 
 
        Notes 
        ----- 
        Constrains the factor transition to be stationary and variances to be 
        positive. 
        &quot;&quot;&quot;</span>
        <span class="s1">unconstrained = np.array(unconstrained</span><span class="s3">, </span><span class="s1">ndmin=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">dtype = unconstrained.dtype</span>
        <span class="s1">constrained = np.zeros(unconstrained.shape</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

        <span class="s0"># 1. Factor loadings</span>
        <span class="s0"># The factor loadings do not need to be adjusted</span>
        <span class="s1">constrained[self._params_loadings] = (</span>
            <span class="s1">unconstrained[self._params_loadings])</span>

        <span class="s0"># 2. Exog</span>
        <span class="s0"># The regression coefficients do not need to be adjusted</span>
        <span class="s1">constrained[self._params_exog] = (</span>
            <span class="s1">unconstrained[self._params_exog])</span>

        <span class="s0"># 3. Error covariances</span>
        <span class="s0"># If we have variances, force them to be positive</span>
        <span class="s3">if </span><span class="s1">self.error_cov_type </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'scalar'</span><span class="s3">, </span><span class="s5">'diagonal'</span><span class="s1">]:</span>
            <span class="s1">constrained[self._params_error_cov] = (</span>
                <span class="s1">unconstrained[self._params_error_cov]**</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s0"># Otherwise, nothing needs to be done</span>
        <span class="s3">elif </span><span class="s1">self.error_cov_type == </span><span class="s5">'unstructured'</span><span class="s1">:</span>
            <span class="s1">constrained[self._params_error_cov] = (</span>
                <span class="s1">unconstrained[self._params_error_cov])</span>

        <span class="s0"># 4. Factor transition VAR</span>
        <span class="s0"># VAR transition: optionally force to be stationary</span>
        <span class="s3">if </span><span class="s1">self.enforce_stationarity </span><span class="s3">and </span><span class="s1">self.factor_order &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s0"># Transform the parameters</span>
            <span class="s1">unconstrained_matrices = (</span>
                <span class="s1">unconstrained[self._params_factor_transition].reshape(</span>
                    <span class="s1">self.k_factors</span><span class="s3">, </span><span class="s1">self._factor_order))</span>
            <span class="s0"># This is always an identity matrix, but because the transform</span>
            <span class="s0"># done prior to update (where the ssm representation matrices</span>
            <span class="s0"># change), it may be complex</span>
            <span class="s1">cov = self.ssm[</span><span class="s5">'state_cov'</span><span class="s3">, </span><span class="s1">:self.k_factors</span><span class="s3">, </span><span class="s1">:self.k_factors].real</span>
            <span class="s1">coefficient_matrices</span><span class="s3">, </span><span class="s1">variance = (</span>
                <span class="s1">constrain_stationary_multivariate(unconstrained_matrices</span><span class="s3">, </span><span class="s1">cov))</span>
            <span class="s1">constrained[self._params_factor_transition] = (</span>
                <span class="s1">coefficient_matrices.ravel())</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">constrained[self._params_factor_transition] = (</span>
                <span class="s1">unconstrained[self._params_factor_transition])</span>

        <span class="s0"># 5. Error transition VAR</span>
        <span class="s0"># VAR transition: optionally force to be stationary</span>
        <span class="s3">if </span><span class="s1">self.enforce_stationarity </span><span class="s3">and </span><span class="s1">self.error_order &gt; </span><span class="s4">0</span><span class="s1">:</span>

            <span class="s0"># Joint VAR specification</span>
            <span class="s3">if </span><span class="s1">self.error_var:</span>
                <span class="s1">unconstrained_matrices = (</span>
                    <span class="s1">unconstrained[self._params_error_transition].reshape(</span>
                        <span class="s1">self.k_endog</span><span class="s3">, </span><span class="s1">self._error_order))</span>
                <span class="s1">start = self.k_factors</span>
                <span class="s1">end = self.k_factors + self.k_endog</span>
                <span class="s1">cov = self.ssm[</span><span class="s5">'state_cov'</span><span class="s3">, </span><span class="s1">start:end</span><span class="s3">, </span><span class="s1">start:end].real</span>
                <span class="s1">coefficient_matrices</span><span class="s3">, </span><span class="s1">variance = (</span>
                    <span class="s1">constrain_stationary_multivariate(</span>
                        <span class="s1">unconstrained_matrices</span><span class="s3">, </span><span class="s1">cov))</span>
                <span class="s1">constrained[self._params_error_transition] = (</span>
                    <span class="s1">coefficient_matrices.ravel())</span>
            <span class="s0"># Separate AR specifications</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">coefficients = (</span>
                    <span class="s1">unconstrained[self._params_error_transition].copy())</span>
                <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(self.k_endog):</span>
                    <span class="s1">start = i * self.error_order</span>
                    <span class="s1">end = (i + </span><span class="s4">1</span><span class="s1">) * self.error_order</span>
                    <span class="s1">coefficients[start:end] = constrain_stationary_univariate(</span>
                        <span class="s1">coefficients[start:end])</span>
                <span class="s1">constrained[self._params_error_transition] = coefficients</span>

        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">constrained[self._params_error_transition] = (</span>
                <span class="s1">unconstrained[self._params_error_transition])</span>

        <span class="s3">return </span><span class="s1">constrained</span>

    <span class="s3">def </span><span class="s1">untransform_params(self</span><span class="s3">, </span><span class="s1">constrained):</span>
        <span class="s2">&quot;&quot;&quot; 
        Transform constrained parameters used in likelihood evaluation 
        to unconstrained parameters used by the optimizer. 
 
        Parameters 
        ---------- 
        constrained : array_like 
            Array of constrained parameters used in likelihood evaluation, to 
            be transformed. 
 
        Returns 
        ------- 
        unconstrained : array_like 
            Array of unconstrained parameters used by the optimizer. 
        &quot;&quot;&quot;</span>
        <span class="s1">constrained = np.array(constrained</span><span class="s3">, </span><span class="s1">ndmin=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">dtype = constrained.dtype</span>
        <span class="s1">unconstrained = np.zeros(constrained.shape</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

        <span class="s0"># 1. Factor loadings</span>
        <span class="s0"># The factor loadings do not need to be adjusted</span>
        <span class="s1">unconstrained[self._params_loadings] = (</span>
            <span class="s1">constrained[self._params_loadings])</span>

        <span class="s0"># 2. Exog</span>
        <span class="s0"># The regression coefficients do not need to be adjusted</span>
        <span class="s1">unconstrained[self._params_exog] = (</span>
            <span class="s1">constrained[self._params_exog])</span>

        <span class="s0"># 3. Error covariances</span>
        <span class="s0"># If we have variances, force them to be positive</span>
        <span class="s3">if </span><span class="s1">self.error_cov_type </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'scalar'</span><span class="s3">, </span><span class="s5">'diagonal'</span><span class="s1">]:</span>
            <span class="s1">unconstrained[self._params_error_cov] = (</span>
                <span class="s1">constrained[self._params_error_cov]**</span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s0"># Otherwise, nothing needs to be done</span>
        <span class="s3">elif </span><span class="s1">self.error_cov_type == </span><span class="s5">'unstructured'</span><span class="s1">:</span>
            <span class="s1">unconstrained[self._params_error_cov] = (</span>
                <span class="s1">constrained[self._params_error_cov])</span>

        <span class="s0"># 3. Factor transition VAR</span>
        <span class="s0"># VAR transition: optionally force to be stationary</span>
        <span class="s3">if </span><span class="s1">self.enforce_stationarity </span><span class="s3">and </span><span class="s1">self.factor_order &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s0"># Transform the parameters</span>
            <span class="s1">constrained_matrices = (</span>
                <span class="s1">constrained[self._params_factor_transition].reshape(</span>
                    <span class="s1">self.k_factors</span><span class="s3">, </span><span class="s1">self._factor_order))</span>
            <span class="s1">cov = self.ssm[</span><span class="s5">'state_cov'</span><span class="s3">, </span><span class="s1">:self.k_factors</span><span class="s3">, </span><span class="s1">:self.k_factors].real</span>
            <span class="s1">coefficient_matrices</span><span class="s3">, </span><span class="s1">variance = (</span>
                <span class="s1">unconstrain_stationary_multivariate(</span>
                    <span class="s1">constrained_matrices</span><span class="s3">, </span><span class="s1">cov))</span>
            <span class="s1">unconstrained[self._params_factor_transition] = (</span>
                <span class="s1">coefficient_matrices.ravel())</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">unconstrained[self._params_factor_transition] = (</span>
                <span class="s1">constrained[self._params_factor_transition])</span>

        <span class="s0"># 5. Error transition VAR</span>
        <span class="s0"># VAR transition: optionally force to be stationary</span>
        <span class="s3">if </span><span class="s1">self.enforce_stationarity </span><span class="s3">and </span><span class="s1">self.error_order &gt; </span><span class="s4">0</span><span class="s1">:</span>

            <span class="s0"># Joint VAR specification</span>
            <span class="s3">if </span><span class="s1">self.error_var:</span>
                <span class="s1">constrained_matrices = (</span>
                    <span class="s1">constrained[self._params_error_transition].reshape(</span>
                        <span class="s1">self.k_endog</span><span class="s3">, </span><span class="s1">self._error_order))</span>
                <span class="s1">start = self.k_factors</span>
                <span class="s1">end = self.k_factors + self.k_endog</span>
                <span class="s1">cov = self.ssm[</span><span class="s5">'state_cov'</span><span class="s3">, </span><span class="s1">start:end</span><span class="s3">, </span><span class="s1">start:end].real</span>
                <span class="s1">coefficient_matrices</span><span class="s3">, </span><span class="s1">variance = (</span>
                    <span class="s1">unconstrain_stationary_multivariate(</span>
                        <span class="s1">constrained_matrices</span><span class="s3">, </span><span class="s1">cov))</span>
                <span class="s1">unconstrained[self._params_error_transition] = (</span>
                    <span class="s1">coefficient_matrices.ravel())</span>
            <span class="s0"># Separate AR specifications</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">coefficients = (</span>
                    <span class="s1">constrained[self._params_error_transition].copy())</span>
                <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(self.k_endog):</span>
                    <span class="s1">start = i * self.error_order</span>
                    <span class="s1">end = (i + </span><span class="s4">1</span><span class="s1">) * self.error_order</span>
                    <span class="s1">coefficients[start:end] = (</span>
                        <span class="s1">unconstrain_stationary_univariate(</span>
                            <span class="s1">coefficients[start:end]))</span>
                <span class="s1">unconstrained[self._params_error_transition] = coefficients</span>

        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">unconstrained[self._params_error_transition] = (</span>
                <span class="s1">constrained[self._params_error_transition])</span>

        <span class="s3">return </span><span class="s1">unconstrained</span>

    <span class="s3">def </span><span class="s1">_validate_can_fix_params(self</span><span class="s3">, </span><span class="s1">param_names):</span>
        <span class="s1">super(DynamicFactor</span><span class="s3">, </span><span class="s1">self)._validate_can_fix_params(param_names)</span>

        <span class="s1">ix = np.cumsum(list(self.parameters.values()))[:-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">(_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">factor_transition_names</span><span class="s3">, </span><span class="s1">error_transition_names) = [</span>
            <span class="s1">arr.tolist() </span><span class="s3">for </span><span class="s1">arr </span><span class="s3">in </span><span class="s1">np.array_split(self.param_names</span><span class="s3">, </span><span class="s1">ix)]</span>

        <span class="s3">if </span><span class="s1">self.enforce_stationarity </span><span class="s3">and </span><span class="s1">self.factor_order &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">self.k_factors &gt; </span><span class="s4">1 </span><span class="s3">or </span><span class="s1">self.factor_order &gt; </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">fix_all = param_names.issuperset(factor_transition_names)</span>
                <span class="s1">fix_any = (</span>
                    <span class="s1">len(param_names.intersection(factor_transition_names)) &gt; </span><span class="s4">0</span><span class="s1">)</span>
                <span class="s3">if </span><span class="s1">fix_any </span><span class="s3">and not </span><span class="s1">fix_all:</span>
                    <span class="s3">raise </span><span class="s1">ValueError(</span>
                        <span class="s5">'Cannot fix individual factor transition parameters'</span>
                        <span class="s5">' when `enforce_stationarity=True`. In this case,'</span>
                        <span class="s5">' must either fix all factor transition parameters or'</span>
                        <span class="s5">' none.'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">self.enforce_stationarity </span><span class="s3">and </span><span class="s1">self.error_order &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">self.error_var </span><span class="s3">or </span><span class="s1">self.error_order &gt; </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">fix_all = param_names.issuperset(error_transition_names)</span>
                <span class="s1">fix_any = (</span>
                    <span class="s1">len(param_names.intersection(error_transition_names)) &gt; </span><span class="s4">0</span><span class="s1">)</span>
                <span class="s3">if </span><span class="s1">fix_any </span><span class="s3">and not </span><span class="s1">fix_all:</span>
                    <span class="s3">raise </span><span class="s1">ValueError(</span>
                        <span class="s5">'Cannot fix individual error transition parameters'</span>
                        <span class="s5">' when `enforce_stationarity=True`. In this case,'</span>
                        <span class="s5">' must either fix all error transition parameters or'</span>
                        <span class="s5">' none.'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">update(self</span><span class="s3">, </span><span class="s1">params</span><span class="s3">, </span><span class="s1">transformed=</span><span class="s3">True, </span><span class="s1">includes_fixed=</span><span class="s3">False,</span>
               <span class="s1">complex_step=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Update the parameters of the model 
 
        Updates the representation matrices to fill in the new parameter 
        values. 
 
        Parameters 
        ---------- 
        params : array_like 
            Array of new parameters. 
        transformed : bool, optional 
            Whether or not `params` is already transformed. If set to False, 
            `transform_params` is called. Default is True.. 
 
        Returns 
        ------- 
        params : array_like 
            Array of parameters. 
 
        Notes 
        ----- 
        Let `n = k_endog`, `m = k_factors`, and `p = factor_order`. Then the 
        `params` vector has length 
        :math:`[n \times m] + [n] + [m^2 \times p]`. 
        It is expanded in the following way: 
 
        - The first :math:`n \times m` parameters fill out the factor loading 
          matrix, starting from the [0,0] entry and then proceeding along rows. 
          These parameters are not modified in `transform_params`. 
        - The next :math:`n` parameters provide variances for the error_cov 
          errors in the observation equation. They fill in the diagonal of the 
          observation covariance matrix, and are constrained to be positive by 
          `transofrm_params`. 
        - The next :math:`m^2 \times p` parameters are used to create the `p` 
          coefficient matrices for the vector autoregression describing the 
          factor transition. They are transformed in `transform_params` to 
          enforce stationarity of the VAR(p). They are placed so as to make 
          the transition matrix a companion matrix for the VAR. In particular, 
          we assume that the first :math:`m^2` parameters fill the first 
          coefficient matrix (starting at [0,0] and filling along rows), the 
          second :math:`m^2` parameters fill the second matrix, etc. 
        &quot;&quot;&quot;</span>
        <span class="s1">params = self.handle_params(params</span><span class="s3">, </span><span class="s1">transformed=transformed</span><span class="s3">,</span>
                                    <span class="s1">includes_fixed=includes_fixed)</span>

        <span class="s0"># 1. Factor loadings</span>
        <span class="s0"># Update the design / factor loading matrix</span>
        <span class="s1">self.ssm[self._idx_loadings] = (</span>
            <span class="s1">params[self._params_loadings].reshape(self.k_endog</span><span class="s3">, </span><span class="s1">self.k_factors)</span>
        <span class="s1">)</span>

        <span class="s0"># 2. Exog</span>
        <span class="s3">if </span><span class="s1">self.k_exog &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">exog_params = params[self._params_exog].reshape(</span>
                <span class="s1">self.k_endog</span><span class="s3">, </span><span class="s1">self.k_exog).T</span>
            <span class="s1">self.ssm[self._idx_exog] = np.dot(self.exog</span><span class="s3">, </span><span class="s1">exog_params).T</span>

        <span class="s0"># 3. Error covariances</span>
        <span class="s3">if </span><span class="s1">self.error_cov_type </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'scalar'</span><span class="s3">, </span><span class="s5">'diagonal'</span><span class="s1">]:</span>
            <span class="s1">self.ssm[self._idx_error_cov] = (</span>
                <span class="s1">params[self._params_error_cov])</span>
        <span class="s3">elif </span><span class="s1">self.error_cov_type == </span><span class="s5">'unstructured'</span><span class="s1">:</span>
            <span class="s1">error_cov_lower = np.zeros((self.k_endog</span><span class="s3">, </span><span class="s1">self.k_endog)</span><span class="s3">,</span>
                                       <span class="s1">dtype=params.dtype)</span>
            <span class="s1">error_cov_lower[self._idx_lower_error_cov] = (</span>
                <span class="s1">params[self._params_error_cov])</span>
            <span class="s1">self.ssm[self._idx_error_cov] = (</span>
                <span class="s1">np.dot(error_cov_lower</span><span class="s3">, </span><span class="s1">error_cov_lower.T))</span>

        <span class="s0"># 4. Factor transition VAR</span>
        <span class="s1">self.ssm[self._idx_factor_transition] = (</span>
            <span class="s1">params[self._params_factor_transition].reshape(</span>
                <span class="s1">self.k_factors</span><span class="s3">, </span><span class="s1">self.factor_order * self.k_factors))</span>

        <span class="s0"># 5. Error transition VAR</span>
        <span class="s3">if </span><span class="s1">self.error_var:</span>
            <span class="s1">self.ssm[self._idx_error_transition] = (</span>
                <span class="s1">params[self._params_error_transition].reshape(</span>
                    <span class="s1">self.k_endog</span><span class="s3">, </span><span class="s1">self._error_order))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.ssm[self._idx_error_transition] = (</span>
                <span class="s1">params[self._params_error_transition])</span>


<span class="s3">class </span><span class="s1">DynamicFactorResults(MLEResults):</span>
    <span class="s2">&quot;&quot;&quot; 
    Class to hold results from fitting an DynamicFactor model. 
 
    Parameters 
    ---------- 
    model : DynamicFactor instance 
        The fitted model instance 
 
    Attributes 
    ---------- 
    specification : dictionary 
        Dictionary including all attributes from the DynamicFactor model 
        instance. 
    coefficient_matrices_var : ndarray 
        Array containing autoregressive lag polynomial coefficient matrices, 
        ordered from lowest degree to highest. 
 
    See Also 
    -------- 
    statsmodels.tsa.statespace.kalman_filter.FilterResults 
    statsmodels.tsa.statespace.mlemodel.MLEResults 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">model</span><span class="s3">, </span><span class="s1">params</span><span class="s3">, </span><span class="s1">filter_results</span><span class="s3">, </span><span class="s1">cov_type=</span><span class="s3">None,</span>
                 <span class="s1">**kwargs):</span>
        <span class="s1">super(DynamicFactorResults</span><span class="s3">, </span><span class="s1">self).__init__(model</span><span class="s3">, </span><span class="s1">params</span><span class="s3">,</span>
                                                   <span class="s1">filter_results</span><span class="s3">, </span><span class="s1">cov_type</span><span class="s3">,</span>
                                                   <span class="s1">**kwargs)</span>

        <span class="s1">self.df_resid = np.inf  </span><span class="s0"># attribute required for wald tests</span>

        <span class="s1">self.specification = Bunch(**{</span>
            <span class="s0"># Model properties</span>
            <span class="s5">'k_endog'</span><span class="s1">: self.model.k_endog</span><span class="s3">,</span>
            <span class="s5">'enforce_stationarity'</span><span class="s1">: self.model.enforce_stationarity</span><span class="s3">,</span>

            <span class="s0"># Factor-related properties</span>
            <span class="s5">'k_factors'</span><span class="s1">: self.model.k_factors</span><span class="s3">,</span>
            <span class="s5">'factor_order'</span><span class="s1">: self.model.factor_order</span><span class="s3">,</span>

            <span class="s0"># Error-related properties</span>
            <span class="s5">'error_order'</span><span class="s1">: self.model.error_order</span><span class="s3">,</span>
            <span class="s5">'error_var'</span><span class="s1">: self.model.error_var</span><span class="s3">,</span>
            <span class="s5">'error_cov_type'</span><span class="s1">: self.model.error_cov_type</span><span class="s3">,</span>

            <span class="s0"># Other properties</span>
            <span class="s5">'k_exog'</span><span class="s1">: self.model.k_exog</span>
        <span class="s1">})</span>

        <span class="s0"># Polynomials / coefficient matrices</span>
        <span class="s1">self.coefficient_matrices_var = </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">self.model.factor_order &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">ar_params = (</span>
                <span class="s1">np.array(self.params[self.model._params_factor_transition]))</span>
            <span class="s1">k_factors = self.model.k_factors</span>
            <span class="s1">factor_order = self.model.factor_order</span>
            <span class="s1">self.coefficient_matrices_var = (</span>
                <span class="s1">ar_params.reshape(k_factors * factor_order</span><span class="s3">, </span><span class="s1">k_factors).T</span>
            <span class="s1">).reshape(k_factors</span><span class="s3">, </span><span class="s1">k_factors</span><span class="s3">, </span><span class="s1">factor_order).T</span>

        <span class="s1">self.coefficient_matrices_error = </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">self.model.error_order &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">ar_params = (</span>
                <span class="s1">np.array(self.params[self.model._params_error_transition]))</span>
            <span class="s1">k_endog = self.model.k_endog</span>
            <span class="s1">error_order = self.model.error_order</span>
            <span class="s3">if </span><span class="s1">self.model.error_var:</span>
                <span class="s1">self.coefficient_matrices_error = (</span>
                    <span class="s1">ar_params.reshape(k_endog * error_order</span><span class="s3">, </span><span class="s1">k_endog).T</span>
                <span class="s1">).reshape(k_endog</span><span class="s3">, </span><span class="s1">k_endog</span><span class="s3">, </span><span class="s1">error_order).T</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">mat = np.zeros((k_endog</span><span class="s3">, </span><span class="s1">k_endog * error_order))</span>
                <span class="s1">mat[self.model._idx_error_diag] = ar_params</span>
                <span class="s1">self.coefficient_matrices_error = (</span>
                    <span class="s1">mat.T.reshape(error_order</span><span class="s3">, </span><span class="s1">k_endog</span><span class="s3">, </span><span class="s1">k_endog))</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">factors(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Estimates of unobserved factors 
 
        Returns 
        ------- 
        out : Bunch 
            Has the following attributes shown in Notes. 
 
        Notes 
        ----- 
        The output is a bunch of the following format: 
 
        - `filtered`: a time series array with the filtered estimate of 
          the component 
        - `filtered_cov`: a time series array with the filtered estimate of 
          the variance/covariance of the component 
        - `smoothed`: a time series array with the smoothed estimate of 
          the component 
        - `smoothed_cov`: a time series array with the smoothed estimate of 
          the variance/covariance of the component 
        - `offset`: an integer giving the offset in the state vector where 
          this component begins 
        &quot;&quot;&quot;</span>
        <span class="s0"># If present, level is always the first component of the state vector</span>
        <span class="s1">out = </span><span class="s3">None</span>
        <span class="s1">spec = self.specification</span>
        <span class="s3">if </span><span class="s1">spec.k_factors &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">offset = </span><span class="s4">0</span>
            <span class="s1">end = spec.k_factors</span>
            <span class="s1">res = self.filter_results</span>
            <span class="s1">out = Bunch(</span>
                <span class="s1">filtered=res.filtered_state[offset:end]</span><span class="s3">,</span>
                <span class="s1">filtered_cov=res.filtered_state_cov[offset:end</span><span class="s3">, </span><span class="s1">offset:end]</span><span class="s3">,</span>
                <span class="s1">smoothed=</span><span class="s3">None, </span><span class="s1">smoothed_cov=</span><span class="s3">None,</span>
                <span class="s1">offset=offset)</span>
            <span class="s3">if </span><span class="s1">self.smoothed_state </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">out.smoothed = self.smoothed_state[offset:end]</span>
            <span class="s3">if </span><span class="s1">self.smoothed_state_cov </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">out.smoothed_cov = (</span>
                    <span class="s1">self.smoothed_state_cov[offset:end</span><span class="s3">, </span><span class="s1">offset:end])</span>
        <span class="s3">return </span><span class="s1">out</span>

    <span class="s1">@cache_readonly</span>
    <span class="s3">def </span><span class="s1">coefficients_of_determination(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Coefficients of determination (:math:`R^2`) from regressions of 
        individual estimated factors on endogenous variables. 
 
        Returns 
        ------- 
        coefficients_of_determination : ndarray 
            A `k_endog` x `k_factors` array, where 
            `coefficients_of_determination[i, j]` represents the :math:`R^2` 
            value from a regression of factor `j` and a constant on endogenous 
            variable `i`. 
 
        Notes 
        ----- 
        Although it can be difficult to interpret the estimated factor loadings 
        and factors, it is often helpful to use the coefficients of 
        determination from univariate regressions to assess the importance of 
        each factor in explaining the variation in each endogenous variable. 
 
        In models with many variables and factors, this can sometimes lend 
        interpretation to the factors (for example sometimes one factor will 
        load primarily on real variables and another on nominal variables). 
 
        See Also 
        -------- 
        plot_coefficients_of_determination 
        &quot;&quot;&quot;</span>
        <span class="s3">from </span><span class="s1">statsmodels.tools </span><span class="s3">import </span><span class="s1">add_constant</span>
        <span class="s1">spec = self.specification</span>
        <span class="s1">coefficients = np.zeros((spec.k_endog</span><span class="s3">, </span><span class="s1">spec.k_factors))</span>
        <span class="s1">which = </span><span class="s5">'filtered' </span><span class="s3">if </span><span class="s1">self.smoothed_state </span><span class="s3">is None else </span><span class="s5">'smoothed'</span>

        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(spec.k_factors):</span>
            <span class="s1">exog = add_constant(self.factors[which][i])</span>
            <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range(spec.k_endog):</span>
                <span class="s1">endog = self.filter_results.endog[j]</span>
                <span class="s1">coefficients[j</span><span class="s3">, </span><span class="s1">i] = OLS(endog</span><span class="s3">, </span><span class="s1">exog).fit().rsquared</span>

        <span class="s3">return </span><span class="s1">coefficients</span>

    <span class="s3">def </span><span class="s1">plot_coefficients_of_determination(self</span><span class="s3">, </span><span class="s1">endog_labels=</span><span class="s3">None,</span>
                                           <span class="s1">fig=</span><span class="s3">None, </span><span class="s1">figsize=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Plot the coefficients of determination 
 
        Parameters 
        ---------- 
        endog_labels : bool, optional 
            Whether or not to label the endogenous variables along the x-axis 
            of the plots. Default is to include labels if there are 5 or fewer 
            endogenous variables. 
        fig : Figure, optional 
            If given, subplots are created in this figure instead of in a new 
            figure. Note that the grid will be created in the provided 
            figure using `fig.add_subplot()`. 
        figsize : tuple, optional 
            If a figure is created, this argument allows specifying a size. 
            The tuple is (width, height). 
 
        Notes 
        ----- 
 
        Produces a `k_factors` x 1 plot grid. The `i`th plot shows a bar plot 
        of the coefficients of determination associated with factor `i`. The 
        endogenous variables are arranged along the x-axis according to their 
        position in the `endog` array. 
 
        See Also 
        -------- 
        coefficients_of_determination 
        &quot;&quot;&quot;</span>
        <span class="s3">from </span><span class="s1">statsmodels.graphics.utils </span><span class="s3">import </span><span class="s1">_import_mpl</span><span class="s3">, </span><span class="s1">create_mpl_fig</span>
        <span class="s1">_import_mpl()</span>
        <span class="s1">fig = create_mpl_fig(fig</span><span class="s3">, </span><span class="s1">figsize)</span>

        <span class="s1">spec = self.specification</span>

        <span class="s0"># Should we label endogenous variables?</span>
        <span class="s3">if </span><span class="s1">endog_labels </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">endog_labels = spec.k_endog &lt;= </span><span class="s4">5</span>

        <span class="s0"># Plot the coefficients of determination</span>
        <span class="s1">coefficients_of_determination = self.coefficients_of_determination</span>
        <span class="s1">plot_idx = </span><span class="s4">1</span>
        <span class="s1">locations = np.arange(spec.k_endog)</span>
        <span class="s3">for </span><span class="s1">coeffs </span><span class="s3">in </span><span class="s1">coefficients_of_determination.T:</span>
            <span class="s0"># Create the new axis</span>
            <span class="s1">ax = fig.add_subplot(spec.k_factors</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s1">plot_idx)</span>
            <span class="s1">ax.set_ylim((</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s1">))</span>
            <span class="s1">ax.set(title=</span><span class="s5">'Factor %i' </span><span class="s1">% plot_idx</span><span class="s3">, </span><span class="s1">ylabel=</span><span class="s5">r'$R^2$'</span><span class="s1">)</span>
            <span class="s1">bars = ax.bar(locations</span><span class="s3">, </span><span class="s1">coeffs)</span>

            <span class="s3">if </span><span class="s1">endog_labels:</span>
                <span class="s1">width = bars[</span><span class="s4">0</span><span class="s1">].get_width()</span>
                <span class="s1">ax.xaxis.set_ticks(locations + width / </span><span class="s4">2</span><span class="s1">)</span>
                <span class="s1">ax.xaxis.set_ticklabels(self.model.endog_names)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">ax.set(xlabel=</span><span class="s5">'Endogenous variables'</span><span class="s1">)</span>
                <span class="s1">ax.xaxis.set_ticks([])</span>

            <span class="s1">plot_idx += </span><span class="s4">1</span>

        <span class="s3">return </span><span class="s1">fig</span>

    <span class="s1">@Appender(MLEResults.summary.__doc__)</span>
    <span class="s3">def </span><span class="s1">summary(self</span><span class="s3">, </span><span class="s1">alpha=</span><span class="s4">.05</span><span class="s3">, </span><span class="s1">start=</span><span class="s3">None, </span><span class="s1">separate_params=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s3">from </span><span class="s1">statsmodels.iolib.summary </span><span class="s3">import </span><span class="s1">summary_params</span>
        <span class="s1">spec = self.specification</span>

        <span class="s0"># Create the model name</span>
        <span class="s1">model_name = []</span>
        <span class="s3">if </span><span class="s1">spec.k_factors &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">spec.factor_order &gt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">model_type = (</span><span class="s5">'DynamicFactor(factors=%d, order=%d)' </span><span class="s1">%</span>
                              <span class="s1">(spec.k_factors</span><span class="s3">, </span><span class="s1">spec.factor_order))</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">model_type = </span><span class="s5">'StaticFactor(factors=%d)' </span><span class="s1">% spec.k_factors</span>

            <span class="s1">model_name.append(model_type)</span>
            <span class="s3">if </span><span class="s1">spec.k_exog &gt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">model_name.append(</span><span class="s5">'%d regressors' </span><span class="s1">% spec.k_exog)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">model_name.append(</span><span class="s5">'SUR(%d regressors)' </span><span class="s1">% spec.k_exog)</span>

        <span class="s3">if </span><span class="s1">spec.error_order &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">error_type = </span><span class="s5">'VAR' </span><span class="s3">if </span><span class="s1">spec.error_var </span><span class="s3">else </span><span class="s5">'AR'</span>
            <span class="s1">model_name.append(</span><span class="s5">'%s(%d) errors' </span><span class="s1">% (error_type</span><span class="s3">, </span><span class="s1">spec.error_order))</span>

        <span class="s1">summary = super(DynamicFactorResults</span><span class="s3">, </span><span class="s1">self).summary(</span>
            <span class="s1">alpha=alpha</span><span class="s3">, </span><span class="s1">start=start</span><span class="s3">, </span><span class="s1">model_name=model_name</span><span class="s3">,</span>
            <span class="s1">display_params=</span><span class="s3">not </span><span class="s1">separate_params</span>
        <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">separate_params:</span>
            <span class="s1">indices = np.arange(len(self.params))</span>

            <span class="s3">def </span><span class="s1">make_table(self</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">, </span><span class="s1">title</span><span class="s3">, </span><span class="s1">strip_end=</span><span class="s3">True</span><span class="s1">):</span>
                <span class="s1">res = (self</span><span class="s3">, </span><span class="s1">self.params[mask]</span><span class="s3">, </span><span class="s1">self.bse[mask]</span><span class="s3">,</span>
                       <span class="s1">self.zvalues[mask]</span><span class="s3">, </span><span class="s1">self.pvalues[mask]</span><span class="s3">,</span>
                       <span class="s1">self.conf_int(alpha)[mask])</span>

                <span class="s1">param_names = [</span>
                    <span class="s5">'.'</span><span class="s1">.join(name.split(</span><span class="s5">'.'</span><span class="s1">)[:-</span><span class="s4">1</span><span class="s1">]) </span><span class="s3">if </span><span class="s1">strip_end </span><span class="s3">else </span><span class="s1">name</span>
                    <span class="s3">for </span><span class="s1">name </span><span class="s3">in</span>
                    <span class="s1">np.array(self.data.param_names)[mask].tolist()</span>
                <span class="s1">]</span>

                <span class="s3">return </span><span class="s1">summary_params(res</span><span class="s3">, </span><span class="s1">yname=</span><span class="s3">None, </span><span class="s1">xname=param_names</span><span class="s3">,</span>
                                      <span class="s1">alpha=alpha</span><span class="s3">, </span><span class="s1">use_t=</span><span class="s3">False, </span><span class="s1">title=title)</span>

            <span class="s1">k_endog = self.model.k_endog</span>
            <span class="s1">k_exog = self.model.k_exog</span>
            <span class="s1">k_factors = self.model.k_factors</span>
            <span class="s1">factor_order = self.model.factor_order</span>
            <span class="s1">_factor_order = self.model._factor_order</span>
            <span class="s1">_error_order = self.model._error_order</span>

            <span class="s0"># Add parameter tables for each endogenous variable</span>
            <span class="s1">loading_indices = indices[self.model._params_loadings]</span>
            <span class="s1">loading_masks = []</span>
            <span class="s1">exog_indices = indices[self.model._params_exog]</span>
            <span class="s1">exog_masks = []</span>
            <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(k_endog):</span>
                <span class="s0"># 1. Factor loadings</span>
                <span class="s0"># Recall these are in the form:</span>
                <span class="s0"># 'loading.f1.y1', 'loading.f2.y1', 'loading.f1.y2', ...</span>

                <span class="s1">loading_mask = (</span>
                    <span class="s1">loading_indices[i * k_factors:(i + </span><span class="s4">1</span><span class="s1">) * k_factors])</span>
                <span class="s1">loading_masks.append(loading_mask)</span>

                <span class="s0"># 2. Exog</span>
                <span class="s0"># Recall these are in the form:</span>
                <span class="s0"># beta.x1.y1, beta.x2.y1, beta.x1.y2, ...</span>
                <span class="s1">exog_mask = exog_indices[i * k_exog:(i + </span><span class="s4">1</span><span class="s1">) * k_exog]</span>
                <span class="s1">exog_masks.append(exog_mask)</span>

                <span class="s0"># Create the table</span>
                <span class="s1">mask = np.concatenate([loading_mask</span><span class="s3">, </span><span class="s1">exog_mask])</span>
                <span class="s1">title = </span><span class="s5">&quot;Results for equation %s&quot; </span><span class="s1">% self.model.endog_names[i]</span>
                <span class="s1">table = make_table(self</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">, </span><span class="s1">title)</span>
                <span class="s1">summary.tables.append(table)</span>

            <span class="s0"># Add parameter tables for each factor</span>
            <span class="s1">factor_indices = indices[self.model._params_factor_transition]</span>
            <span class="s1">factor_masks = []</span>
            <span class="s3">if </span><span class="s1">factor_order &gt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(k_factors):</span>
                    <span class="s1">start = i * _factor_order</span>
                    <span class="s1">factor_mask = factor_indices[start: start + _factor_order]</span>
                    <span class="s1">factor_masks.append(factor_mask)</span>

                    <span class="s0"># Create the table</span>
                    <span class="s1">title = </span><span class="s5">&quot;Results for factor equation f%d&quot; </span><span class="s1">% (i+</span><span class="s4">1</span><span class="s1">)</span>
                    <span class="s1">table = make_table(self</span><span class="s3">, </span><span class="s1">factor_mask</span><span class="s3">, </span><span class="s1">title)</span>
                    <span class="s1">summary.tables.append(table)</span>

            <span class="s0"># Add parameter tables for error transitions</span>
            <span class="s1">error_masks = []</span>
            <span class="s3">if </span><span class="s1">spec.error_order &gt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">error_indices = indices[self.model._params_error_transition]</span>
                <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(k_endog):</span>
                    <span class="s3">if </span><span class="s1">spec.error_var:</span>
                        <span class="s1">start = i * _error_order</span>
                        <span class="s1">end = (i + </span><span class="s4">1</span><span class="s1">) * _error_order</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">start = i * spec.error_order</span>
                        <span class="s1">end = (i + </span><span class="s4">1</span><span class="s1">) * spec.error_order</span>

                    <span class="s1">error_mask = error_indices[start:end]</span>
                    <span class="s1">error_masks.append(error_mask)</span>

                    <span class="s0"># Create the table</span>
                    <span class="s1">title = (</span><span class="s5">&quot;Results for error equation e(%s)&quot; </span><span class="s1">%</span>
                             <span class="s1">self.model.endog_names[i])</span>
                    <span class="s1">table = make_table(self</span><span class="s3">, </span><span class="s1">error_mask</span><span class="s3">, </span><span class="s1">title)</span>
                    <span class="s1">summary.tables.append(table)</span>

            <span class="s0"># Error covariance terms</span>
            <span class="s1">error_cov_mask = indices[self.model._params_error_cov]</span>
            <span class="s1">table = make_table(self</span><span class="s3">, </span><span class="s1">error_cov_mask</span><span class="s3">,</span>
                               <span class="s5">&quot;Error covariance matrix&quot;</span><span class="s3">, </span><span class="s1">strip_end=</span><span class="s3">False</span><span class="s1">)</span>
            <span class="s1">summary.tables.append(table)</span>

            <span class="s0"># Add a table for all other parameters</span>
            <span class="s1">masks = []</span>
            <span class="s3">for </span><span class="s1">m </span><span class="s3">in </span><span class="s1">(loading_masks</span><span class="s3">, </span><span class="s1">exog_masks</span><span class="s3">, </span><span class="s1">factor_masks</span><span class="s3">,</span>
                      <span class="s1">error_masks</span><span class="s3">, </span><span class="s1">[error_cov_mask]):</span>
                <span class="s1">m = np.array(m).flatten()</span>
                <span class="s3">if </span><span class="s1">len(m) &gt; </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s1">masks.append(m)</span>
            <span class="s1">masks = np.concatenate(masks)</span>
            <span class="s1">inverse_mask = np.array(list(set(indices).difference(set(masks))))</span>
            <span class="s3">if </span><span class="s1">len(inverse_mask) &gt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">table = make_table(self</span><span class="s3">, </span><span class="s1">inverse_mask</span><span class="s3">, </span><span class="s5">&quot;Other parameters&quot;</span><span class="s3">,</span>
                                   <span class="s1">strip_end=</span><span class="s3">False</span><span class="s1">)</span>
                <span class="s1">summary.tables.append(table)</span>

        <span class="s3">return </span><span class="s1">summary</span>


<span class="s3">class </span><span class="s1">DynamicFactorResultsWrapper(MLEResultsWrapper):</span>
    <span class="s1">_attrs = {}</span>
    <span class="s1">_wrap_attrs = wrap.union_dicts(MLEResultsWrapper._wrap_attrs</span><span class="s3">,</span>
                                   <span class="s1">_attrs)</span>
    <span class="s1">_methods = {}</span>
    <span class="s1">_wrap_methods = wrap.union_dicts(MLEResultsWrapper._wrap_methods</span><span class="s3">,</span>
                                     <span class="s1">_methods)</span>
<span class="s1">wrap.populate_wrapper(DynamicFactorResultsWrapper</span><span class="s3">,  </span><span class="s0"># noqa:E305</span>
                      <span class="s1">DynamicFactorResults)</span>
</pre>
</body>
</html>