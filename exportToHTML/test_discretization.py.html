<html>
<head>
<title>test_discretization.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_discretization.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">import </span><span class="s1">scipy.sparse </span><span class="s0">as </span><span class="s1">sp</span>

<span class="s0">from </span><span class="s1">sklearn </span><span class="s0">import </span><span class="s1">clone</span>
<span class="s0">from </span><span class="s1">sklearn.preprocessing </span><span class="s0">import </span><span class="s1">KBinsDiscretizer</span><span class="s0">, </span><span class="s1">OneHotEncoder</span>
<span class="s0">from </span><span class="s1">sklearn.utils._testing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">assert_allclose</span><span class="s0">,</span>
    <span class="s1">assert_allclose_dense_sparse</span><span class="s0">,</span>
    <span class="s1">assert_array_almost_equal</span><span class="s0">,</span>
    <span class="s1">assert_array_equal</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s1">X = [[-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1.5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2.5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">3.5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">4.5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]]</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;strategy, expected, sample_weight&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s3">&quot;uniform&quot;</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]]</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">&quot;kmeans&quot;</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]]</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">&quot;quantile&quot;</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]]</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;quantile&quot;</span><span class="s0">,</span>
            <span class="s1">[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;quantile&quot;</span><span class="s0">,</span>
            <span class="s1">[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;quantile&quot;</span><span class="s0">,</span>
            <span class="s1">[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;kmeans&quot;</span><span class="s0">,</span>
            <span class="s1">[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;kmeans&quot;</span><span class="s0">,</span>
            <span class="s1">[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s4"># TODO(1.5) remove warning filter when kbd's subsample default is changed</span>
<span class="s1">@pytest.mark.filterwarnings(</span><span class="s3">&quot;ignore:In version 1.5 onwards, subsample=200_000&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_fit_transform(strategy</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">sample_weight):</span>
    <span class="s1">est = KBinsDiscretizer(n_bins=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">encode=</span><span class="s3">&quot;ordinal&quot;</span><span class="s0">, </span><span class="s1">strategy=strategy)</span>
    <span class="s1">est.fit(X</span><span class="s0">, </span><span class="s1">sample_weight=sample_weight)</span>
    <span class="s1">assert_array_equal(expected</span><span class="s0">, </span><span class="s1">est.transform(X))</span>


<span class="s0">def </span><span class="s1">test_valid_n_bins():</span>
    <span class="s1">KBinsDiscretizer(n_bins=</span><span class="s2">2</span><span class="s1">).fit_transform(X)</span>
    <span class="s1">KBinsDiscretizer(n_bins=np.array([</span><span class="s2">2</span><span class="s1">])[</span><span class="s2">0</span><span class="s1">]).fit_transform(X)</span>
    <span class="s0">assert </span><span class="s1">KBinsDiscretizer(n_bins=</span><span class="s2">2</span><span class="s1">).fit(X).n_bins_.dtype == np.dtype(int)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;strategy&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;uniform&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_kbinsdiscretizer_wrong_strategy_with_weights(strategy):</span>
    <span class="s5">&quot;&quot;&quot;Check that we raise an error when the wrong strategy is used.&quot;&quot;&quot;</span>
    <span class="s1">sample_weight = np.ones(shape=(len(X)))</span>
    <span class="s1">est = KBinsDiscretizer(n_bins=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">strategy=strategy)</span>
    <span class="s1">err_msg = (</span>
        <span class="s3">&quot;`sample_weight` was provided but it cannot be used with strategy='uniform'.&quot;</span>
    <span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=err_msg):</span>
        <span class="s1">est.fit(X</span><span class="s0">, </span><span class="s1">sample_weight=sample_weight)</span>


<span class="s0">def </span><span class="s1">test_invalid_n_bins_array():</span>
    <span class="s4"># Bad shape</span>
    <span class="s1">n_bins = np.full((</span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span><span class="s0">, </span><span class="s2">2.0</span><span class="s1">)</span>
    <span class="s1">est = KBinsDiscretizer(n_bins=n_bins)</span>
    <span class="s1">err_msg = </span><span class="s3">r&quot;n_bins must be a scalar or array of shape \(n_features,\).&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=err_msg):</span>
        <span class="s1">est.fit_transform(X)</span>

    <span class="s4"># Incorrect number of features</span>
    <span class="s1">n_bins = [</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span>
    <span class="s1">est = KBinsDiscretizer(n_bins=n_bins)</span>
    <span class="s1">err_msg = </span><span class="s3">r&quot;n_bins must be a scalar or array of shape \(n_features,\).&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=err_msg):</span>
        <span class="s1">est.fit_transform(X)</span>

    <span class="s4"># Bad bin values</span>
    <span class="s1">n_bins = [</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span>
    <span class="s1">est = KBinsDiscretizer(n_bins=n_bins)</span>
    <span class="s1">err_msg = (</span>
        <span class="s3">&quot;KBinsDiscretizer received an invalid number of bins &quot;</span>
        <span class="s3">&quot;at indices 0, 3. Number of bins must be at least 2, &quot;</span>
        <span class="s3">&quot;and must be an int.&quot;</span>
    <span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=err_msg):</span>
        <span class="s1">est.fit_transform(X)</span>

    <span class="s4"># Float bin values</span>
    <span class="s1">n_bins = [</span><span class="s2">2.1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2.1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span>
    <span class="s1">est = KBinsDiscretizer(n_bins=n_bins)</span>
    <span class="s1">err_msg = (</span>
        <span class="s3">&quot;KBinsDiscretizer received an invalid number of bins &quot;</span>
        <span class="s3">&quot;at indices 0, 2. Number of bins must be at least 2, &quot;</span>
        <span class="s3">&quot;and must be an int.&quot;</span>
    <span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=err_msg):</span>
        <span class="s1">est.fit_transform(X)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;strategy, expected, sample_weight&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s3">&quot;uniform&quot;</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]]</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">&quot;kmeans&quot;</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]]</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">&quot;quantile&quot;</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]]</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;quantile&quot;</span><span class="s0">,</span>
            <span class="s1">[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;quantile&quot;</span><span class="s0">,</span>
            <span class="s1">[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s4"># (</span>
        <span class="s4">#     &quot;quantile&quot;,</span>
        <span class="s4">#     [[0, 0, 0, 0], [0, 1, 1, 1], [1, 2, 2, 2], [1, 2, 2, 2]],</span>
        <span class="s4">#     [1, 1, 1, 1],</span>
        <span class="s4"># ),</span>
        <span class="s4">#</span>
        <span class="s4"># TODO: This test case above aims to test if the case where an array of</span>
        <span class="s4">#       ones passed in sample_weight parameter is equal to the case when</span>
        <span class="s4">#       sample_weight is None.</span>
        <span class="s4">#       Unfortunately, the behavior of `_weighted_percentile` when</span>
        <span class="s4">#       `sample_weight = [1, 1, 1, 1]` are currently not equivalent.</span>
        <span class="s4">#       This problem has been addressed in issue :</span>
        <span class="s4">#       https://github.com/scikit-learn/scikit-learn/issues/17370</span>
        <span class="s1">(</span>
            <span class="s3">&quot;kmeans&quot;</span><span class="s0">,</span>
            <span class="s1">[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s4"># TODO(1.5) remove warning filter when kbd's subsample default is changed</span>
<span class="s1">@pytest.mark.filterwarnings(</span><span class="s3">&quot;ignore:In version 1.5 onwards, subsample=200_000&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_fit_transform_n_bins_array(strategy</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">sample_weight):</span>
    <span class="s1">est = KBinsDiscretizer(</span>
        <span class="s1">n_bins=[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">encode=</span><span class="s3">&quot;ordinal&quot;</span><span class="s0">, </span><span class="s1">strategy=strategy</span>
    <span class="s1">).fit(X</span><span class="s0">, </span><span class="s1">sample_weight=sample_weight)</span>
    <span class="s1">assert_array_equal(expected</span><span class="s0">, </span><span class="s1">est.transform(X))</span>

    <span class="s4"># test the shape of bin_edges_</span>
    <span class="s1">n_features = np.array(X).shape[</span><span class="s2">1</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">est.bin_edges_.shape == (n_features</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">bin_edges</span><span class="s0">, </span><span class="s1">n_bins </span><span class="s0">in </span><span class="s1">zip(est.bin_edges_</span><span class="s0">, </span><span class="s1">est.n_bins_):</span>
        <span class="s0">assert </span><span class="s1">bin_edges.shape == (n_bins + </span><span class="s2">1</span><span class="s0">,</span><span class="s1">)</span>


<span class="s1">@pytest.mark.filterwarnings(</span><span class="s3">&quot;ignore: Bins whose width are too small&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_kbinsdiscretizer_effect_sample_weight():</span>
    <span class="s5">&quot;&quot;&quot;Check the impact of `sample_weight` one computed quantiles.&quot;&quot;&quot;</span>
    <span class="s1">X = np.array([[-</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">500</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1000</span><span class="s1">]])</span>
    <span class="s4"># add a large number of bins such that each sample with a non-null weight</span>
    <span class="s4"># will be used as bin edge</span>
    <span class="s1">est = KBinsDiscretizer(n_bins=</span><span class="s2">10</span><span class="s0">, </span><span class="s1">encode=</span><span class="s3">&quot;ordinal&quot;</span><span class="s0">, </span><span class="s1">strategy=</span><span class="s3">&quot;quantile&quot;</span><span class="s1">)</span>
    <span class="s1">est.fit(X</span><span class="s0">, </span><span class="s1">sample_weight=[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
    <span class="s1">assert_allclose(est.bin_edges_[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
    <span class="s1">assert_allclose(est.transform(X)</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2.0</span><span class="s1">]])</span>


<span class="s4"># TODO(1.5) remove warning filter when kbd's subsample default is changed</span>
<span class="s1">@pytest.mark.filterwarnings(</span><span class="s3">&quot;ignore:In version 1.5 onwards, subsample=200_000&quot;</span><span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;strategy&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;kmeans&quot;</span><span class="s0">, </span><span class="s3">&quot;quantile&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_kbinsdiscretizer_no_mutating_sample_weight(strategy):</span>
    <span class="s5">&quot;&quot;&quot;Make sure that `sample_weight` is not changed in place.&quot;&quot;&quot;</span>
    <span class="s1">est = KBinsDiscretizer(n_bins=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">encode=</span><span class="s3">&quot;ordinal&quot;</span><span class="s0">, </span><span class="s1">strategy=strategy)</span>
    <span class="s1">sample_weight = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
    <span class="s1">sample_weight_copy = np.copy(sample_weight)</span>
    <span class="s1">est.fit(X</span><span class="s0">, </span><span class="s1">sample_weight=sample_weight)</span>
    <span class="s1">assert_allclose(sample_weight</span><span class="s0">, </span><span class="s1">sample_weight_copy)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;strategy&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;uniform&quot;</span><span class="s0">, </span><span class="s3">&quot;kmeans&quot;</span><span class="s0">, </span><span class="s3">&quot;quantile&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_same_min_max(strategy):</span>
    <span class="s1">warnings.simplefilter(</span><span class="s3">&quot;always&quot;</span><span class="s1">)</span>
    <span class="s1">X = np.array([[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]])</span>
    <span class="s1">est = KBinsDiscretizer(strategy=strategy</span><span class="s0">, </span><span class="s1">n_bins=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">encode=</span><span class="s3">&quot;ordinal&quot;</span><span class="s1">)</span>
    <span class="s1">warning_message = </span><span class="s3">&quot;Feature 0 is constant and will be replaced with 0.&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=warning_message):</span>
        <span class="s1">est.fit(X)</span>
    <span class="s0">assert </span><span class="s1">est.n_bins_[</span><span class="s2">0</span><span class="s1">] == </span><span class="s2">1</span>
    <span class="s4"># replace the feature with zeros</span>
    <span class="s1">Xt = est.transform(X)</span>
    <span class="s1">assert_array_equal(Xt[:</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.zeros(X.shape[</span><span class="s2">0</span><span class="s1">]))</span>


<span class="s0">def </span><span class="s1">test_transform_1d_behavior():</span>
    <span class="s1">X = np.arange(</span><span class="s2">4</span><span class="s1">)</span>
    <span class="s1">est = KBinsDiscretizer(n_bins=</span><span class="s2">2</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">est.fit(X)</span>

    <span class="s1">est = KBinsDiscretizer(n_bins=</span><span class="s2">2</span><span class="s1">)</span>
    <span class="s1">est.fit(X.reshape(-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">))</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">est.transform(X)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;i&quot;</span><span class="s0">, </span><span class="s1">range(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">9</span><span class="s1">))</span>
<span class="s0">def </span><span class="s1">test_numeric_stability(i):</span>
    <span class="s1">X_init = np.array([</span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">4.0</span><span class="s0">, </span><span class="s2">6.0</span><span class="s0">, </span><span class="s2">8.0</span><span class="s0">, </span><span class="s2">10.0</span><span class="s1">]).reshape(-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">Xt_expected = np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]).reshape(-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>

    <span class="s4"># Test up to discretizing nano units</span>
    <span class="s1">X = X_init / </span><span class="s2">10</span><span class="s1">**i</span>
    <span class="s1">Xt = KBinsDiscretizer(n_bins=</span><span class="s2">2</span><span class="s0">, </span><span class="s1">encode=</span><span class="s3">&quot;ordinal&quot;</span><span class="s1">).fit_transform(X)</span>
    <span class="s1">assert_array_equal(Xt_expected</span><span class="s0">, </span><span class="s1">Xt)</span>


<span class="s0">def </span><span class="s1">test_encode_options():</span>
    <span class="s1">est = KBinsDiscretizer(n_bins=[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">encode=</span><span class="s3">&quot;ordinal&quot;</span><span class="s1">).fit(X)</span>
    <span class="s1">Xt_1 = est.transform(X)</span>
    <span class="s1">est = KBinsDiscretizer(n_bins=[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">encode=</span><span class="s3">&quot;onehot-dense&quot;</span><span class="s1">).fit(X)</span>
    <span class="s1">Xt_2 = est.transform(X)</span>
    <span class="s0">assert not </span><span class="s1">sp.issparse(Xt_2)</span>
    <span class="s1">assert_array_equal(</span>
        <span class="s1">OneHotEncoder(</span>
            <span class="s1">categories=[np.arange(i) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">sparse_output=</span><span class="s0">False</span>
        <span class="s1">).fit_transform(Xt_1)</span><span class="s0">,</span>
        <span class="s1">Xt_2</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">est = KBinsDiscretizer(n_bins=[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">encode=</span><span class="s3">&quot;onehot&quot;</span><span class="s1">).fit(X)</span>
    <span class="s1">Xt_3 = est.transform(X)</span>
    <span class="s0">assert </span><span class="s1">sp.issparse(Xt_3)</span>
    <span class="s1">assert_array_equal(</span>
        <span class="s1">OneHotEncoder(</span>
            <span class="s1">categories=[np.arange(i) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">sparse_output=</span><span class="s0">True</span>
        <span class="s1">)</span>
        <span class="s1">.fit_transform(Xt_1)</span>
        <span class="s1">.toarray()</span><span class="s0">,</span>
        <span class="s1">Xt_3.toarray()</span><span class="s0">,</span>
    <span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;strategy, expected_2bins, expected_3bins, expected_5bins&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s3">&quot;uniform&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">&quot;kmeans&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">&quot;quantile&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s1">])</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s4"># TODO(1.5) remove warning filter when kbd's subsample default is changed</span>
<span class="s1">@pytest.mark.filterwarnings(</span><span class="s3">&quot;ignore:In version 1.5 onwards, subsample=200_000&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_nonuniform_strategies(</span>
    <span class="s1">strategy</span><span class="s0">, </span><span class="s1">expected_2bins</span><span class="s0">, </span><span class="s1">expected_3bins</span><span class="s0">, </span><span class="s1">expected_5bins</span>
<span class="s1">):</span>
    <span class="s1">X = np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">9</span><span class="s0">, </span><span class="s2">10</span><span class="s1">]).reshape(-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>

    <span class="s4"># with 2 bins</span>
    <span class="s1">est = KBinsDiscretizer(n_bins=</span><span class="s2">2</span><span class="s0">, </span><span class="s1">strategy=strategy</span><span class="s0">, </span><span class="s1">encode=</span><span class="s3">&quot;ordinal&quot;</span><span class="s1">)</span>
    <span class="s1">Xt = est.fit_transform(X)</span>
    <span class="s1">assert_array_equal(expected_2bins</span><span class="s0">, </span><span class="s1">Xt.ravel())</span>

    <span class="s4"># with 3 bins</span>
    <span class="s1">est = KBinsDiscretizer(n_bins=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">strategy=strategy</span><span class="s0">, </span><span class="s1">encode=</span><span class="s3">&quot;ordinal&quot;</span><span class="s1">)</span>
    <span class="s1">Xt = est.fit_transform(X)</span>
    <span class="s1">assert_array_equal(expected_3bins</span><span class="s0">, </span><span class="s1">Xt.ravel())</span>

    <span class="s4"># with 5 bins</span>
    <span class="s1">est = KBinsDiscretizer(n_bins=</span><span class="s2">5</span><span class="s0">, </span><span class="s1">strategy=strategy</span><span class="s0">, </span><span class="s1">encode=</span><span class="s3">&quot;ordinal&quot;</span><span class="s1">)</span>
    <span class="s1">Xt = est.fit_transform(X)</span>
    <span class="s1">assert_array_equal(expected_5bins</span><span class="s0">, </span><span class="s1">Xt.ravel())</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;strategy, expected_inv&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span>
            <span class="s3">&quot;uniform&quot;</span><span class="s0">,</span>
            <span class="s1">[</span>
                <span class="s1">[-</span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">2.0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3.5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.5</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[-</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">3.0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2.5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.5</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">4.0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">4.0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">1.5</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;kmeans&quot;</span><span class="s0">,</span>
            <span class="s1">[</span>
                <span class="s1">[-</span><span class="s2">1.375</span><span class="s0">, </span><span class="s2">2.125</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3.375</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.5625</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[-</span><span class="s2">1.375</span><span class="s0">, </span><span class="s2">2.125</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3.375</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.5625</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[-</span><span class="s2">0.125</span><span class="s0">, </span><span class="s2">3.375</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2.125</span><span class="s0">, </span><span class="s2">0.5625</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">0.75</span><span class="s0">, </span><span class="s2">4.25</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.25</span><span class="s0">, </span><span class="s2">1.625</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;quantile&quot;</span><span class="s0">,</span>
            <span class="s1">[</span>
                <span class="s1">[-</span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">2.0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3.5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.75</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[-</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">3.0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2.5</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">4.0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">1.25</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">4.0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">1.25</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s4"># TODO(1.5) remove warning filter when kbd's subsample default is changed</span>
<span class="s1">@pytest.mark.filterwarnings(</span><span class="s3">&quot;ignore:In version 1.5 onwards, subsample=200_000&quot;</span><span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;encode&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;ordinal&quot;</span><span class="s0">, </span><span class="s3">&quot;onehot&quot;</span><span class="s0">, </span><span class="s3">&quot;onehot-dense&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_inverse_transform(strategy</span><span class="s0">, </span><span class="s1">encode</span><span class="s0">, </span><span class="s1">expected_inv):</span>
    <span class="s1">kbd = KBinsDiscretizer(n_bins=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">strategy=strategy</span><span class="s0">, </span><span class="s1">encode=encode)</span>
    <span class="s1">Xt = kbd.fit_transform(X)</span>
    <span class="s1">Xinv = kbd.inverse_transform(Xt)</span>
    <span class="s1">assert_array_almost_equal(expected_inv</span><span class="s0">, </span><span class="s1">Xinv)</span>


<span class="s4"># TODO(1.5) remove warning filter when kbd's subsample default is changed</span>
<span class="s1">@pytest.mark.filterwarnings(</span><span class="s3">&quot;ignore:In version 1.5 onwards, subsample=200_000&quot;</span><span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;strategy&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;uniform&quot;</span><span class="s0">, </span><span class="s3">&quot;kmeans&quot;</span><span class="s0">, </span><span class="s3">&quot;quantile&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_transform_outside_fit_range(strategy):</span>
    <span class="s1">X = np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])[:</span><span class="s0">, None</span><span class="s1">]</span>
    <span class="s1">kbd = KBinsDiscretizer(n_bins=</span><span class="s2">4</span><span class="s0">, </span><span class="s1">strategy=strategy</span><span class="s0">, </span><span class="s1">encode=</span><span class="s3">&quot;ordinal&quot;</span><span class="s1">)</span>
    <span class="s1">kbd.fit(X)</span>

    <span class="s1">X2 = np.array([-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">5</span><span class="s1">])[:</span><span class="s0">, None</span><span class="s1">]</span>
    <span class="s1">X2t = kbd.transform(X2)</span>
    <span class="s1">assert_array_equal(X2t.max(axis=</span><span class="s2">0</span><span class="s1">) + </span><span class="s2">1</span><span class="s0">, </span><span class="s1">kbd.n_bins_)</span>
    <span class="s1">assert_array_equal(X2t.min(axis=</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">test_overwrite():</span>
    <span class="s1">X = np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])[:</span><span class="s0">, None</span><span class="s1">]</span>
    <span class="s1">X_before = X.copy()</span>

    <span class="s1">est = KBinsDiscretizer(n_bins=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">encode=</span><span class="s3">&quot;ordinal&quot;</span><span class="s1">)</span>
    <span class="s1">Xt = est.fit_transform(X)</span>
    <span class="s1">assert_array_equal(X</span><span class="s0">, </span><span class="s1">X_before)</span>

    <span class="s1">Xt_before = Xt.copy()</span>
    <span class="s1">Xinv = est.inverse_transform(Xt)</span>
    <span class="s1">assert_array_equal(Xt</span><span class="s0">, </span><span class="s1">Xt_before)</span>
    <span class="s1">assert_array_equal(Xinv</span><span class="s0">, </span><span class="s1">np.array([[</span><span class="s2">0.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2.5</span><span class="s1">]]))</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;strategy, expected_bin_edges&quot;</span><span class="s0">, </span><span class="s1">[(</span><span class="s3">&quot;quantile&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span><span class="s0">, </span><span class="s1">(</span><span class="s3">&quot;kmeans&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])]</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_redundant_bins(strategy</span><span class="s0">, </span><span class="s1">expected_bin_edges):</span>
    <span class="s1">X = [[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s1">]]</span>
    <span class="s1">kbd = KBinsDiscretizer(n_bins=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">strategy=strategy)</span>
    <span class="s1">warning_message = </span><span class="s3">&quot;Consider decreasing the number of bins.&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=warning_message):</span>
        <span class="s1">kbd.fit(X)</span>
    <span class="s1">assert_array_almost_equal(kbd.bin_edges_[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">expected_bin_edges)</span>


<span class="s0">def </span><span class="s1">test_percentile_numeric_stability():</span>
    <span class="s1">X = np.array([</span><span class="s2">0.05</span><span class="s0">, </span><span class="s2">0.05</span><span class="s0">, </span><span class="s2">0.95</span><span class="s1">]).reshape(-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">bin_edges = np.array([</span><span class="s2">0.05</span><span class="s0">, </span><span class="s2">0.23</span><span class="s0">, </span><span class="s2">0.41</span><span class="s0">, </span><span class="s2">0.59</span><span class="s0">, </span><span class="s2">0.77</span><span class="s0">, </span><span class="s2">0.95</span><span class="s1">])</span>
    <span class="s1">Xt = np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]).reshape(-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">kbd = KBinsDiscretizer(n_bins=</span><span class="s2">10</span><span class="s0">, </span><span class="s1">encode=</span><span class="s3">&quot;ordinal&quot;</span><span class="s0">, </span><span class="s1">strategy=</span><span class="s3">&quot;quantile&quot;</span><span class="s1">)</span>
    <span class="s1">warning_message = </span><span class="s3">&quot;Consider decreasing the number of bins.&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=warning_message):</span>
        <span class="s1">kbd.fit(X)</span>

    <span class="s1">assert_array_almost_equal(kbd.bin_edges_[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">bin_edges)</span>
    <span class="s1">assert_array_almost_equal(kbd.transform(X)</span><span class="s0">, </span><span class="s1">Xt)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;in_dtype&quot;</span><span class="s0">, </span><span class="s1">[np.float16</span><span class="s0">, </span><span class="s1">np.float32</span><span class="s0">, </span><span class="s1">np.float64])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;out_dtype&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, </span><span class="s1">np.float32</span><span class="s0">, </span><span class="s1">np.float64])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;encode&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;ordinal&quot;</span><span class="s0">, </span><span class="s3">&quot;onehot&quot;</span><span class="s0">, </span><span class="s3">&quot;onehot-dense&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_consistent_dtype(in_dtype</span><span class="s0">, </span><span class="s1">out_dtype</span><span class="s0">, </span><span class="s1">encode):</span>
    <span class="s1">X_input = np.array(X</span><span class="s0">, </span><span class="s1">dtype=in_dtype)</span>
    <span class="s1">kbd = KBinsDiscretizer(n_bins=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">encode=encode</span><span class="s0">, </span><span class="s1">dtype=out_dtype)</span>
    <span class="s1">kbd.fit(X_input)</span>

    <span class="s4"># test output dtype</span>
    <span class="s0">if </span><span class="s1">out_dtype </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">expected_dtype = out_dtype</span>
    <span class="s0">elif </span><span class="s1">out_dtype </span><span class="s0">is None and </span><span class="s1">X_input.dtype == np.float16:</span>
        <span class="s4"># wrong numeric input dtype are cast in np.float64</span>
        <span class="s1">expected_dtype = np.float64</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">expected_dtype = X_input.dtype</span>
    <span class="s1">Xt = kbd.transform(X_input)</span>
    <span class="s0">assert </span><span class="s1">Xt.dtype == expected_dtype</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;input_dtype&quot;</span><span class="s0">, </span><span class="s1">[np.float16</span><span class="s0">, </span><span class="s1">np.float32</span><span class="s0">, </span><span class="s1">np.float64])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;encode&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;ordinal&quot;</span><span class="s0">, </span><span class="s3">&quot;onehot&quot;</span><span class="s0">, </span><span class="s3">&quot;onehot-dense&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_32_equal_64(input_dtype</span><span class="s0">, </span><span class="s1">encode):</span>
    <span class="s4"># TODO this check is redundant with common checks and can be removed</span>
    <span class="s4">#  once #16290 is merged</span>
    <span class="s1">X_input = np.array(X</span><span class="s0">, </span><span class="s1">dtype=input_dtype)</span>

    <span class="s4"># 32 bit output</span>
    <span class="s1">kbd_32 = KBinsDiscretizer(n_bins=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">encode=encode</span><span class="s0">, </span><span class="s1">dtype=np.float32)</span>
    <span class="s1">kbd_32.fit(X_input)</span>
    <span class="s1">Xt_32 = kbd_32.transform(X_input)</span>

    <span class="s4"># 64 bit output</span>
    <span class="s1">kbd_64 = KBinsDiscretizer(n_bins=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">encode=encode</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
    <span class="s1">kbd_64.fit(X_input)</span>
    <span class="s1">Xt_64 = kbd_64.transform(X_input)</span>

    <span class="s1">assert_allclose_dense_sparse(Xt_32</span><span class="s0">, </span><span class="s1">Xt_64)</span>


<span class="s0">def </span><span class="s1">test_kbinsdiscretizer_subsample_default():</span>
    <span class="s4"># Since the size of X is small (&lt; 2e5), subsampling will not take place.</span>
    <span class="s1">X = np.array([-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1.5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]).reshape(-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">kbd_default = KBinsDiscretizer(n_bins=</span><span class="s2">10</span><span class="s0">, </span><span class="s1">encode=</span><span class="s3">&quot;ordinal&quot;</span><span class="s0">, </span><span class="s1">strategy=</span><span class="s3">&quot;quantile&quot;</span><span class="s1">)</span>
    <span class="s1">kbd_default.fit(X)</span>

    <span class="s1">kbd_without_subsampling = clone(kbd_default)</span>
    <span class="s1">kbd_without_subsampling.set_params(subsample=</span><span class="s0">None</span><span class="s1">)</span>
    <span class="s1">kbd_without_subsampling.fit(X)</span>

    <span class="s0">for </span><span class="s1">bin_kbd_default</span><span class="s0">, </span><span class="s1">bin_kbd_with_subsampling </span><span class="s0">in </span><span class="s1">zip(</span>
        <span class="s1">kbd_default.bin_edges_[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">kbd_without_subsampling.bin_edges_[</span><span class="s2">0</span><span class="s1">]</span>
    <span class="s1">):</span>
        <span class="s1">np.testing.assert_allclose(bin_kbd_default</span><span class="s0">, </span><span class="s1">bin_kbd_with_subsampling)</span>
    <span class="s0">assert </span><span class="s1">kbd_default.bin_edges_.shape == kbd_without_subsampling.bin_edges_.shape</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;encode, expected_names&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span>
            <span class="s3">&quot;onehot&quot;</span><span class="s0">,</span>
            <span class="s1">[</span>
                <span class="s3">f&quot;feat</span><span class="s0">{</span><span class="s1">col_id</span><span class="s0">}</span><span class="s3">_</span><span class="s0">{</span><span class="s1">float(bin_id)</span><span class="s0">}</span><span class="s3">&quot;</span>
                <span class="s0">for </span><span class="s1">col_id </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">3</span><span class="s1">)</span>
                <span class="s0">for </span><span class="s1">bin_id </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">4</span><span class="s1">)</span>
            <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;onehot-dense&quot;</span><span class="s0">,</span>
            <span class="s1">[</span>
                <span class="s3">f&quot;feat</span><span class="s0">{</span><span class="s1">col_id</span><span class="s0">}</span><span class="s3">_</span><span class="s0">{</span><span class="s1">float(bin_id)</span><span class="s0">}</span><span class="s3">&quot;</span>
                <span class="s0">for </span><span class="s1">col_id </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">3</span><span class="s1">)</span>
                <span class="s0">for </span><span class="s1">bin_id </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">4</span><span class="s1">)</span>
            <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">&quot;ordinal&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">f&quot;feat</span><span class="s0">{</span><span class="s1">col_id</span><span class="s0">}</span><span class="s3">&quot; </span><span class="s0">for </span><span class="s1">col_id </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">3</span><span class="s1">)])</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_kbinsdiscrtizer_get_feature_names_out(encode</span><span class="s0">, </span><span class="s1">expected_names):</span>
    <span class="s5">&quot;&quot;&quot;Check get_feature_names_out for different settings. 
    Non-regression test for #22731 
    &quot;&quot;&quot;</span>
    <span class="s1">X = [[-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]]</span>

    <span class="s1">kbd = KBinsDiscretizer(n_bins=</span><span class="s2">4</span><span class="s0">, </span><span class="s1">encode=encode).fit(X)</span>
    <span class="s1">Xt = kbd.transform(X)</span>

    <span class="s1">input_features = [</span><span class="s3">f&quot;feat</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s3">&quot; </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">3</span><span class="s1">)]</span>
    <span class="s1">output_names = kbd.get_feature_names_out(input_features)</span>
    <span class="s0">assert </span><span class="s1">Xt.shape[</span><span class="s2">1</span><span class="s1">] == output_names.shape[</span><span class="s2">0</span><span class="s1">]</span>

    <span class="s1">assert_array_equal(output_names</span><span class="s0">, </span><span class="s1">expected_names)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;strategy&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;uniform&quot;</span><span class="s0">, </span><span class="s3">&quot;kmeans&quot;</span><span class="s0">, </span><span class="s3">&quot;quantile&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_kbinsdiscretizer_subsample(strategy</span><span class="s0">, </span><span class="s1">global_random_seed):</span>
    <span class="s4"># Check that the bin edges are almost the same when subsampling is used.</span>
    <span class="s1">X = np.random.RandomState(global_random_seed).random_sample((</span><span class="s2">100000</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)) + </span><span class="s2">1</span>

    <span class="s1">kbd_subsampling = KBinsDiscretizer(</span>
        <span class="s1">strategy=strategy</span><span class="s0">, </span><span class="s1">subsample=</span><span class="s2">50000</span><span class="s0">, </span><span class="s1">random_state=global_random_seed</span>
    <span class="s1">)</span>
    <span class="s1">kbd_subsampling.fit(X)</span>

    <span class="s1">kbd_no_subsampling = clone(kbd_subsampling)</span>
    <span class="s1">kbd_no_subsampling.set_params(subsample=</span><span class="s0">None</span><span class="s1">)</span>
    <span class="s1">kbd_no_subsampling.fit(X)</span>

    <span class="s4"># We use a large tolerance because we can't expect the bin edges to be exactly the</span>
    <span class="s4"># same when subsampling is used.</span>
    <span class="s1">assert_allclose(</span>
        <span class="s1">kbd_subsampling.bin_edges_[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">kbd_no_subsampling.bin_edges_[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-2</span>
    <span class="s1">)</span>


<span class="s4"># TODO(1.5) remove this test</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;strategy&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;uniform&quot;</span><span class="s0">, </span><span class="s3">&quot;kmeans&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_kbd_subsample_warning(strategy):</span>
    <span class="s4"># Check the future warning for the change of default of subsample</span>
    <span class="s1">X = np.random.RandomState(</span><span class="s2">0</span><span class="s1">).random_sample((</span><span class="s2">100</span><span class="s0">, </span><span class="s2">1</span><span class="s1">))</span>

    <span class="s1">kbd = KBinsDiscretizer(strategy=strategy</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s2">0</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.warns(FutureWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;subsample=200_000 will be used by default&quot;</span><span class="s1">):</span>
        <span class="s1">kbd.fit(X)</span>
</pre>
</body>
</html>