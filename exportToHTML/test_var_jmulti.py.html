<html>
<head>
<title>test_var_jmulti.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_var_jmulti.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">assert_</span><span class="s0">, </span><span class="s1">assert_allclose</span><span class="s0">, </span><span class="s1">assert_raises</span>

<span class="s0">import </span><span class="s1">statsmodels.datasets.macrodata.data </span><span class="s0">as </span><span class="s1">macro</span>
<span class="s0">from </span><span class="s1">statsmodels.tsa.vector_ar.tests.JMulTi_results.parse_jmulti_vecm_output </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">sublists</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">statsmodels.tsa.vector_ar.var_model </span><span class="s0">import </span><span class="s1">VAR</span>

<span class="s0">from </span><span class="s1">.JMulTi_results.parse_jmulti_var_output </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">dt_s_tup_to_string</span><span class="s0">,</span>
    <span class="s1">load_results_jmulti</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s1">atol = </span><span class="s2">0.001  </span><span class="s3"># absolute tolerance</span>
<span class="s1">rtol = </span><span class="s2">0.01  </span><span class="s3"># relative tolerance</span>
<span class="s1">datasets = []</span>
<span class="s1">data = {}</span>
<span class="s1">results_ref = {}</span>
<span class="s1">results_sm = {}</span>

<span class="s1">debug_mode = </span><span class="s0">False</span>
<span class="s1">dont_test_se_t_p = </span><span class="s0">False</span>
<span class="s1">deterministic_terms_list = [</span><span class="s4">&quot;nc&quot;</span><span class="s0">, </span><span class="s4">&quot;c&quot;</span><span class="s0">, </span><span class="s4">&quot;ct&quot;</span><span class="s1">]</span>
<span class="s1">seasonal_list = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span>
<span class="s1">dt_s_list = [</span>
    <span class="s1">(det</span><span class="s0">, </span><span class="s1">s) </span><span class="s0">for </span><span class="s1">det </span><span class="s0">in </span><span class="s1">deterministic_terms_list </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">seasonal_list</span>
<span class="s1">]</span>
<span class="s1">all_tests = [</span>
    <span class="s4">&quot;coefs&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;det&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;Sigma_u&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;log_like&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;fc&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;causality&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;impulse-response&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;lag order&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;test normality&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;whiteness&quot;</span><span class="s0">,</span>
    <span class="s4">&quot;exceptions&quot;</span><span class="s0">,</span>
<span class="s1">]</span>
<span class="s1">to_test = all_tests  </span><span class="s3"># [&quot;coefs&quot;, &quot;det&quot;, &quot;Sigma_u&quot;, &quot;log_like&quot;, &quot;fc&quot;, &quot;causality&quot;]  # all_tests</span>


<span class="s0">def </span><span class="s1">load_data(dataset</span><span class="s0">, </span><span class="s1">data_dict):</span>
    <span class="s1">dtset = dataset.load_pandas()</span>
    <span class="s1">variables = dataset.variable_names</span>
    <span class="s1">loaded = dtset.data[variables].astype(float).values</span>
    <span class="s1">data_dict[dataset] = loaded.reshape((-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">len(variables)))</span>


<span class="s0">def </span><span class="s1">reorder_jmultis_det_terms(jmulti_output</span><span class="s0">, </span><span class="s1">constant</span><span class="s0">, </span><span class="s1">seasons):</span>
    <span class="s5">&quot;&quot;&quot; 
    In case of seasonal terms and a trend term we have to reorder them to make 
    the outputs from JMulTi and statsmodels comparable. 
    JMulTi's ordering is: [constant], [seasonal terms], [trend term] while 
    in statsmodels it is: [constant], [trend term], [seasonal terms] 
 
    Parameters 
    ---------- 
    jmulti_output : ndarray (neqs x number_of_deterministic_terms) 
 
    constant : bool 
        Indicates whether there is a constant term or not in jmulti_output. 
    seasons : int 
        Number of seasons in the model. That means there are seasons-1 
        columns for seasonal terms in jmulti_output 
 
    Returns 
    ------- 
    reordered : ndarray (neqs x number_of_deterministic_terms) 
        jmulti_output reordered such that the order of deterministic terms 
        matches that of statsmodels. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">seasons == </span><span class="s2">0</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">jmulti_output</span>
    <span class="s1">constant = int(constant)</span>
    <span class="s1">const_column = jmulti_output[:</span><span class="s0">, </span><span class="s1">:constant]</span>
    <span class="s1">season_columns = jmulti_output[:</span><span class="s0">, </span><span class="s1">constant : constant + seasons - </span><span class="s2">1</span><span class="s1">].copy()</span>
    <span class="s1">trend_columns = jmulti_output[:</span><span class="s0">, </span><span class="s1">constant + seasons - </span><span class="s2">1 </span><span class="s1">:].copy()</span>
    <span class="s0">return </span><span class="s1">np.hstack((const_column</span><span class="s0">, </span><span class="s1">trend_columns</span><span class="s0">, </span><span class="s1">season_columns))</span>


<span class="s0">def </span><span class="s1">generate_exog_from_season(seasons</span><span class="s0">, </span><span class="s1">endog_len):</span>
    <span class="s5">&quot;&quot;&quot; 
    Translate seasons to exog matrix. 
 
    Parameters 
    ---------- 
    seasons : int 
        Number of seasons. 
    endog_len : int 
        Number of observations. 
 
    Returns 
    ------- 
    exog : ndarray or None 
        If seasonal deterministic terms exist, the corresponding exog-matrix is 
        returned. 
        Otherwise, None is returned. 
    &quot;&quot;&quot;</span>

    <span class="s1">exog_stack = []</span>
    <span class="s0">if </span><span class="s1">seasons &gt; </span><span class="s2">0</span><span class="s1">:</span>
        <span class="s1">season_exog = np.zeros((seasons - </span><span class="s2">1</span><span class="s0">, </span><span class="s1">endog_len))</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(seasons - </span><span class="s2">1</span><span class="s1">):</span>
            <span class="s1">season_exog[i</span><span class="s0">, </span><span class="s1">i::seasons] = </span><span class="s2">1</span>
        <span class="s3"># season_exog = season_exog[:, ::-1]</span>
        <span class="s3"># season_exog = np.hstack((season_exog[:, 3:4],</span>
        <span class="s3">#   season_exog[:, :-1]))</span>
        <span class="s3"># season_exog = np.hstack((season_exog[:, 2:4],</span>
        <span class="s3">#                          season_exog[:, :-2]))</span>
        <span class="s3"># season_exog = np.hstack((season_exog[:, 1:4], season_exog[:, :-3]))</span>
        <span class="s3"># season_exog[1] = -season_exog[1]</span>
        <span class="s3"># the following line is commented out because seasonal terms are</span>
        <span class="s3"># *not* centered in JMulTi's VAR-framework (in contrast to VECM)</span>
        <span class="s3"># season_exog -= 1 / seasons</span>
        <span class="s1">season_exog = season_exog.T</span>
        <span class="s1">exog_stack.append(season_exog)</span>
    <span class="s0">if </span><span class="s1">exog_stack != []:</span>
        <span class="s1">exog = np.column_stack(exog_stack)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">exog = </span><span class="s0">None</span>
    <span class="s0">return </span><span class="s1">exog</span>


<span class="s0">def </span><span class="s1">load_results_statsmodels(dataset):</span>
    <span class="s1">results_per_deterministic_terms = dict.fromkeys(dt_s_list)</span>
    <span class="s0">for </span><span class="s1">dt_s_tup </span><span class="s0">in </span><span class="s1">dt_s_list:</span>
        <span class="s1">endog = data[dataset]</span>
        <span class="s1">exog = generate_exog_from_season(dt_s_tup[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">len(endog))</span>

        <span class="s1">model = VAR(endog</span><span class="s0">, </span><span class="s1">exog)</span>
        <span class="s1">trend = dt_s_tup[</span><span class="s2">0</span><span class="s1">] </span><span class="s0">if </span><span class="s1">dt_s_tup[</span><span class="s2">0</span><span class="s1">] != </span><span class="s4">&quot;nc&quot; </span><span class="s0">else </span><span class="s4">&quot;n&quot;</span>
        <span class="s1">results_per_deterministic_terms[dt_s_tup] = model.fit(</span>
            <span class="s1">maxlags=</span><span class="s2">4</span><span class="s0">, </span><span class="s1">trend=trend</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">&quot;ols&quot;</span>
        <span class="s1">)</span>
    <span class="s0">return </span><span class="s1">results_per_deterministic_terms</span>


<span class="s0">def </span><span class="s1">build_err_msg(ds</span><span class="s0">, </span><span class="s1">dt_s</span><span class="s0">, </span><span class="s1">parameter_str):</span>
    <span class="s1">dt = dt_s_tup_to_string(dt_s)</span>
    <span class="s1">seasons = dt_s[</span><span class="s2">1</span><span class="s1">]</span>
    <span class="s1">err_msg = </span><span class="s4">&quot;Error in &quot; </span><span class="s1">+ parameter_str + </span><span class="s4">&quot; for:</span><span class="s0">\n</span><span class="s4">&quot;</span>
    <span class="s1">err_msg += </span><span class="s4">&quot;- Dataset: &quot; </span><span class="s1">+ ds.__str__() + </span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot;</span>
    <span class="s1">err_msg += </span><span class="s4">&quot;- Deterministic terms: &quot;</span>
    <span class="s1">err_msg += dt_s[</span><span class="s2">0</span><span class="s1">] </span><span class="s0">if </span><span class="s1">dt != </span><span class="s4">&quot;nc&quot; </span><span class="s0">else </span><span class="s4">&quot;no det. terms&quot;</span>
    <span class="s0">if </span><span class="s1">seasons &gt; </span><span class="s2">0</span><span class="s1">:</span>
        <span class="s1">err_msg += </span><span class="s4">&quot;, seasons: &quot; </span><span class="s1">+ str(seasons)</span>
    <span class="s0">return </span><span class="s1">err_msg</span>


<span class="s0">def </span><span class="s1">setup():</span>
    <span class="s1">datasets.append(macro)  </span><span class="s3"># TODO: append more data sets for more test cases.</span>

    <span class="s0">for </span><span class="s1">ds </span><span class="s0">in </span><span class="s1">datasets:</span>
        <span class="s1">load_data(ds</span><span class="s0">, </span><span class="s1">data)</span>
        <span class="s1">results_ref[ds] = load_results_jmulti(ds</span><span class="s0">, </span><span class="s1">dt_s_list)</span>
        <span class="s1">results_sm[ds] = load_results_statsmodels(ds)</span>


<span class="s1">setup()</span>


<span class="s0">def </span><span class="s1">test_ols_coefs():</span>
    <span class="s0">if </span><span class="s1">debug_mode:</span>
        <span class="s0">if </span><span class="s4">&quot;coefs&quot; </span><span class="s0">not in </span><span class="s1">to_test:</span>
            <span class="s0">return</span>
        <span class="s1">print(</span><span class="s4">&quot;</span><span class="s0">\n\n</span><span class="s4">ESTIMATED PARAMETER MATRICES FOR LAGGED ENDOG&quot;</span><span class="s0">, </span><span class="s1">end=</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">ds </span><span class="s0">in </span><span class="s1">datasets:</span>
        <span class="s0">for </span><span class="s1">dt_s </span><span class="s0">in </span><span class="s1">dt_s_list:</span>
            <span class="s0">if </span><span class="s1">debug_mode:</span>
                <span class="s1">print(</span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot; </span><span class="s1">+ dt_s_tup_to_string(dt_s) + </span><span class="s4">&quot;: &quot;</span><span class="s0">, </span><span class="s1">end=</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>

            <span class="s3"># estimated parameter vector</span>
            <span class="s1">err_msg = build_err_msg(ds</span><span class="s0">, </span><span class="s1">dt_s</span><span class="s0">, </span><span class="s4">&quot;PARAMETER MATRICES ENDOG&quot;</span><span class="s1">)</span>
            <span class="s1">obtained = np.hstack(results_sm[ds][dt_s].coefs)</span>
            <span class="s1">desired = results_ref[ds][dt_s][</span><span class="s4">&quot;est&quot;</span><span class="s1">][</span><span class="s4">&quot;Lagged endogenous term&quot;</span><span class="s1">]</span>
            <span class="s1">assert_allclose(obtained</span><span class="s0">, </span><span class="s1">desired</span><span class="s0">, </span><span class="s1">rtol</span><span class="s0">, </span><span class="s1">atol</span><span class="s0">, False, </span><span class="s1">err_msg)</span>
            <span class="s0">if </span><span class="s1">debug_mode </span><span class="s0">and </span><span class="s1">dont_test_se_t_p:</span>
                <span class="s0">continue</span>
            <span class="s3"># standard errors</span>
            <span class="s1">obt = results_sm[ds][dt_s].stderr_endog_lagged</span>
            <span class="s1">des = results_ref[ds][dt_s][</span><span class="s4">&quot;se&quot;</span><span class="s1">][</span><span class="s4">&quot;Lagged endogenous term&quot;</span><span class="s1">].T</span>
            <span class="s1">assert_allclose(</span>
                <span class="s1">obt</span><span class="s0">, </span><span class="s1">des</span><span class="s0">, </span><span class="s1">rtol</span><span class="s0">, </span><span class="s1">atol</span><span class="s0">, False, </span><span class="s4">&quot;STANDARD ERRORS</span><span class="s0">\n</span><span class="s4">&quot; </span><span class="s1">+ err_msg</span>
            <span class="s1">)</span>
            <span class="s3"># t-values</span>
            <span class="s1">obt = results_sm[ds][dt_s].tvalues_endog_lagged</span>
            <span class="s1">des = results_ref[ds][dt_s][</span><span class="s4">&quot;t&quot;</span><span class="s1">][</span><span class="s4">&quot;Lagged endogenous term&quot;</span><span class="s1">].T</span>
            <span class="s1">assert_allclose(</span>
                <span class="s1">obt</span><span class="s0">, </span><span class="s1">des</span><span class="s0">, </span><span class="s1">rtol</span><span class="s0">, </span><span class="s1">atol</span><span class="s0">, False, </span><span class="s4">&quot;t-VALUES</span><span class="s0">\n</span><span class="s4">&quot; </span><span class="s1">+ err_msg</span>
            <span class="s1">)</span>
            <span class="s3"># p-values</span>
            <span class="s1">obt = results_sm[ds][dt_s].pvalues_endog_lagged</span>
            <span class="s1">des = results_ref[ds][dt_s][</span><span class="s4">&quot;p&quot;</span><span class="s1">][</span><span class="s4">&quot;Lagged endogenous term&quot;</span><span class="s1">].T</span>
            <span class="s1">assert_allclose(</span>
                <span class="s1">obt</span><span class="s0">, </span><span class="s1">des</span><span class="s0">, </span><span class="s1">rtol</span><span class="s0">, </span><span class="s1">atol</span><span class="s0">, False, </span><span class="s4">&quot;p-VALUES</span><span class="s0">\n</span><span class="s4">&quot; </span><span class="s1">+ err_msg</span>
            <span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_ols_det_terms():</span>
    <span class="s0">if </span><span class="s1">debug_mode:</span>
        <span class="s0">if </span><span class="s4">&quot;det&quot; </span><span class="s0">not in </span><span class="s1">to_test:</span>
            <span class="s0">return</span>
        <span class="s1">print(</span><span class="s4">&quot;</span><span class="s0">\n\n</span><span class="s4">ESTIMATED PARAMETERS FOR DETERMINISTIC TERMS&quot;</span><span class="s0">, </span><span class="s1">end=</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">ds </span><span class="s0">in </span><span class="s1">datasets:</span>
        <span class="s0">for </span><span class="s1">dt_s </span><span class="s0">in </span><span class="s1">dt_s_list:</span>
            <span class="s0">if </span><span class="s1">debug_mode:</span>
                <span class="s1">print(</span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot; </span><span class="s1">+ dt_s_tup_to_string(dt_s) + </span><span class="s4">&quot;: &quot;</span><span class="s0">, </span><span class="s1">end=</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>

            <span class="s1">err_msg = build_err_msg(ds</span><span class="s0">, </span><span class="s1">dt_s</span><span class="s0">, </span><span class="s4">&quot;PARAMETER MATRICES EXOG&quot;</span><span class="s1">)</span>
            <span class="s1">det_key_ref = </span><span class="s4">&quot;Deterministic term&quot;</span>
            <span class="s3"># If there are no det. terms, just make sure we do not compute any:</span>
            <span class="s0">if </span><span class="s1">det_key_ref </span><span class="s0">not in </span><span class="s1">results_ref[ds][dt_s][</span><span class="s4">&quot;est&quot;</span><span class="s1">].keys():</span>
                <span class="s1">assert_(</span>
                    <span class="s1">(</span>
                        <span class="s1">results_sm[ds][dt_s].coefs_exog.size == </span><span class="s2">0</span>
                        <span class="s0">and </span><span class="s1">results_sm[ds][dt_s].stderr_dt.size == </span><span class="s2">0</span>
                        <span class="s0">and </span><span class="s1">results_sm[ds][dt_s].tvalues_dt.size == </span><span class="s2">0</span>
                        <span class="s0">and </span><span class="s1">results_sm[ds][dt_s].pvalues_dt.size == </span><span class="s2">0</span>
                    <span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">err_msg</span><span class="s0">,</span>
                <span class="s1">)</span>
                <span class="s0">continue</span>
            <span class="s1">obtained = results_sm[ds][dt_s].coefs_exog</span>
            <span class="s1">desired = results_ref[ds][dt_s][</span><span class="s4">&quot;est&quot;</span><span class="s1">][det_key_ref]</span>
            <span class="s1">desired = reorder_jmultis_det_terms(</span>
                <span class="s1">desired</span><span class="s0">, </span><span class="s1">dt_s[</span><span class="s2">0</span><span class="s1">].startswith(</span><span class="s4">&quot;c&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dt_s[</span><span class="s2">1</span><span class="s1">]</span>
            <span class="s1">)</span>
            <span class="s1">assert_allclose(obtained</span><span class="s0">, </span><span class="s1">desired</span><span class="s0">, </span><span class="s1">rtol</span><span class="s0">, </span><span class="s1">atol</span><span class="s0">, False, </span><span class="s1">err_msg)</span>
            <span class="s0">if </span><span class="s1">debug_mode </span><span class="s0">and </span><span class="s1">dont_test_se_t_p:</span>
                <span class="s0">continue</span>
            <span class="s3"># standard errors</span>
            <span class="s1">obt = results_sm[ds][dt_s].stderr_dt</span>
            <span class="s1">des = results_ref[ds][dt_s][</span><span class="s4">&quot;se&quot;</span><span class="s1">][det_key_ref]</span>
            <span class="s1">des = reorder_jmultis_det_terms(</span>
                <span class="s1">des</span><span class="s0">, </span><span class="s1">dt_s[</span><span class="s2">0</span><span class="s1">].startswith(</span><span class="s4">&quot;c&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dt_s[</span><span class="s2">1</span><span class="s1">]</span>
            <span class="s1">).T</span>
            <span class="s1">assert_allclose(</span>
                <span class="s1">obt</span><span class="s0">, </span><span class="s1">des</span><span class="s0">, </span><span class="s1">rtol</span><span class="s0">, </span><span class="s1">atol</span><span class="s0">, False, </span><span class="s4">&quot;STANDARD ERRORS</span><span class="s0">\n</span><span class="s4">&quot; </span><span class="s1">+ err_msg</span>
            <span class="s1">)</span>
            <span class="s3"># t-values</span>
            <span class="s1">obt = results_sm[ds][dt_s].tvalues_dt</span>
            <span class="s1">des = results_ref[ds][dt_s][</span><span class="s4">&quot;t&quot;</span><span class="s1">][det_key_ref]</span>
            <span class="s1">des = reorder_jmultis_det_terms(</span>
                <span class="s1">des</span><span class="s0">, </span><span class="s1">dt_s[</span><span class="s2">0</span><span class="s1">].startswith(</span><span class="s4">&quot;c&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dt_s[</span><span class="s2">1</span><span class="s1">]</span>
            <span class="s1">).T</span>
            <span class="s1">assert_allclose(</span>
                <span class="s1">obt</span><span class="s0">, </span><span class="s1">des</span><span class="s0">, </span><span class="s1">rtol</span><span class="s0">, </span><span class="s1">atol</span><span class="s0">, False, </span><span class="s4">&quot;t-VALUES</span><span class="s0">\n</span><span class="s4">&quot; </span><span class="s1">+ err_msg</span>
            <span class="s1">)</span>
            <span class="s3"># p-values</span>
            <span class="s1">obt = results_sm[ds][dt_s].pvalues_dt</span>
            <span class="s1">des = results_ref[ds][dt_s][</span><span class="s4">&quot;p&quot;</span><span class="s1">][det_key_ref]</span>
            <span class="s1">des = reorder_jmultis_det_terms(</span>
                <span class="s1">des</span><span class="s0">, </span><span class="s1">dt_s[</span><span class="s2">0</span><span class="s1">].startswith(</span><span class="s4">&quot;c&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dt_s[</span><span class="s2">1</span><span class="s1">]</span>
            <span class="s1">).T</span>
            <span class="s1">assert_allclose(</span>
                <span class="s1">obt</span><span class="s0">, </span><span class="s1">des</span><span class="s0">, </span><span class="s1">rtol</span><span class="s0">, </span><span class="s1">atol</span><span class="s0">, False, </span><span class="s4">&quot;p-VALUES</span><span class="s0">\n</span><span class="s4">&quot; </span><span class="s1">+ err_msg</span>
            <span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_ols_sigma():</span>
    <span class="s0">if </span><span class="s1">debug_mode:</span>
        <span class="s0">if </span><span class="s4">&quot;Sigma_u&quot; </span><span class="s0">not in </span><span class="s1">to_test:</span>
            <span class="s0">return</span>
        <span class="s1">print(</span><span class="s4">&quot;</span><span class="s0">\n\n</span><span class="s4">SIGMA_U&quot;</span><span class="s0">, </span><span class="s1">end=</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">ds </span><span class="s0">in </span><span class="s1">datasets:</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">dt_s_list:</span>
            <span class="s0">if </span><span class="s1">debug_mode:</span>
                <span class="s1">print(</span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot; </span><span class="s1">+ dt_s_tup_to_string(dt) + </span><span class="s4">&quot;: &quot;</span><span class="s0">, </span><span class="s1">end=</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>

            <span class="s1">err_msg = build_err_msg(ds</span><span class="s0">, </span><span class="s1">dt</span><span class="s0">, </span><span class="s4">&quot;Sigma_u&quot;</span><span class="s1">)</span>
            <span class="s1">obtained = results_sm[ds][dt].sigma_u</span>
            <span class="s1">desired = results_ref[ds][dt][</span><span class="s4">&quot;est&quot;</span><span class="s1">][</span><span class="s4">&quot;Sigma_u&quot;</span><span class="s1">]</span>
            <span class="s1">assert_allclose(obtained</span><span class="s0">, </span><span class="s1">desired</span><span class="s0">, </span><span class="s1">rtol</span><span class="s0">, </span><span class="s1">atol</span><span class="s0">, False, </span><span class="s1">err_msg)</span>


<span class="s0">def </span><span class="s1">test_log_like():</span>
    <span class="s0">if </span><span class="s1">debug_mode:</span>
        <span class="s0">if </span><span class="s4">&quot;log_like&quot; </span><span class="s0">not in </span><span class="s1">to_test:</span>
            <span class="s0">return</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">print(</span><span class="s4">&quot;</span><span class="s0">\n\n</span><span class="s4">LOG LIKELIHOOD&quot;</span><span class="s0">, </span><span class="s1">end=</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">ds </span><span class="s0">in </span><span class="s1">datasets:</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">dt_s_list:</span>
            <span class="s0">if </span><span class="s1">debug_mode:</span>
                <span class="s1">print(</span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot; </span><span class="s1">+ dt_s_tup_to_string(dt) + </span><span class="s4">&quot;: &quot;</span><span class="s0">, </span><span class="s1">end=</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>

            <span class="s1">err_msg = build_err_msg(ds</span><span class="s0">, </span><span class="s1">dt</span><span class="s0">, </span><span class="s4">&quot;Log Likelihood&quot;</span><span class="s1">)</span>
            <span class="s1">obtained = results_sm[ds][dt].llf</span>
            <span class="s1">desired = results_ref[ds][dt][</span><span class="s4">&quot;log_like&quot;</span><span class="s1">]</span>
            <span class="s1">assert_allclose(obtained</span><span class="s0">, </span><span class="s1">desired</span><span class="s0">, </span><span class="s1">rtol</span><span class="s0">, </span><span class="s1">atol</span><span class="s0">, False, </span><span class="s1">err_msg)</span>


<span class="s0">def </span><span class="s1">test_fc():</span>
    <span class="s0">if </span><span class="s1">debug_mode:</span>
        <span class="s0">if </span><span class="s4">&quot;fc&quot; </span><span class="s0">not in </span><span class="s1">to_test:</span>
            <span class="s0">return</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">print(</span><span class="s4">&quot;</span><span class="s0">\n\n</span><span class="s4">FORECAST&quot;</span><span class="s0">, </span><span class="s1">end=</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">ds </span><span class="s0">in </span><span class="s1">datasets:</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">dt_s_list:</span>
            <span class="s0">if </span><span class="s1">debug_mode:</span>
                <span class="s1">print(</span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot; </span><span class="s1">+ dt_s_tup_to_string(dt) + </span><span class="s4">&quot;: &quot;</span><span class="s0">, </span><span class="s1">end=</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
            <span class="s1">steps = </span><span class="s2">5  </span><span class="s3"># parsed JMulTi output comprises 5 steps</span>
            <span class="s1">last_observations = results_sm[ds][dt].endog[</span>
                <span class="s1">-results_sm[ds][dt].k_ar :</span>
            <span class="s1">]</span>
            <span class="s1">seasons = dt[</span><span class="s2">1</span><span class="s1">]</span>
            <span class="s0">if </span><span class="s1">seasons == </span><span class="s2">0</span><span class="s1">:</span>
                <span class="s1">exog_future = </span><span class="s0">None</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">exog_future = np.zeros((steps</span><span class="s0">, </span><span class="s1">seasons - </span><span class="s2">1</span><span class="s1">))</span>
                <span class="s3"># the following line is appropriate only if the last</span>
                <span class="s3"># observation was in the next to last season (this is the case</span>
                <span class="s3"># for macrodata)</span>
                <span class="s1">exog_future[</span><span class="s2">1</span><span class="s1">:seasons] = np.identity(seasons - </span><span class="s2">1</span><span class="s1">)</span>
            <span class="s1">err_msg = build_err_msg(ds</span><span class="s0">, </span><span class="s1">dt</span><span class="s0">, </span><span class="s4">&quot;FORECAST&quot;</span><span class="s1">)</span>
            <span class="s3"># test point forecast functionality of forecast method</span>
            <span class="s1">obtained = results_sm[ds][dt].forecast(</span>
                <span class="s1">y=last_observations</span><span class="s0">, </span><span class="s1">steps=steps</span><span class="s0">, </span><span class="s1">exog_future=exog_future</span>
            <span class="s1">)</span>
            <span class="s1">desired = results_ref[ds][dt][</span><span class="s4">&quot;fc&quot;</span><span class="s1">][</span><span class="s4">&quot;fc&quot;</span><span class="s1">]</span>
            <span class="s1">assert_allclose(obtained</span><span class="s0">, </span><span class="s1">desired</span><span class="s0">, </span><span class="s1">rtol</span><span class="s0">, </span><span class="s1">atol</span><span class="s0">, False, </span><span class="s1">err_msg)</span>

            <span class="s3"># test forecast method with confidence interval calculation</span>
            <span class="s1">err_msg = build_err_msg(ds</span><span class="s0">, </span><span class="s1">dt</span><span class="s0">, </span><span class="s4">&quot;FORECAST WITH INTERVALS&quot;</span><span class="s1">)</span>
            <span class="s1">obtained = results_sm[ds][dt].forecast_interval(</span>
                <span class="s1">y=last_observations</span><span class="s0">,</span>
                <span class="s1">steps=steps</span><span class="s0">,</span>
                <span class="s1">alpha=</span><span class="s2">0.05</span><span class="s0">,</span>
                <span class="s1">exog_future=exog_future</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s1">obt = obtained[</span><span class="s2">0</span><span class="s1">]  </span><span class="s3"># forecast</span>
            <span class="s1">obt_l = obtained[</span><span class="s2">1</span><span class="s1">]  </span><span class="s3"># lower bound</span>
            <span class="s1">obt_u = obtained[</span><span class="s2">2</span><span class="s1">]  </span><span class="s3"># upper bound</span>
            <span class="s1">des = results_ref[ds][dt][</span><span class="s4">&quot;fc&quot;</span><span class="s1">][</span><span class="s4">&quot;fc&quot;</span><span class="s1">]</span>
            <span class="s1">des_l = results_ref[ds][dt][</span><span class="s4">&quot;fc&quot;</span><span class="s1">][</span><span class="s4">&quot;lower&quot;</span><span class="s1">]</span>
            <span class="s1">des_u = results_ref[ds][dt][</span><span class="s4">&quot;fc&quot;</span><span class="s1">][</span><span class="s4">&quot;upper&quot;</span><span class="s1">]</span>
            <span class="s1">assert_allclose(obt</span><span class="s0">, </span><span class="s1">des</span><span class="s0">, </span><span class="s1">rtol</span><span class="s0">, </span><span class="s1">atol</span><span class="s0">, False, </span><span class="s1">err_msg)</span>
            <span class="s1">assert_allclose(obt_l</span><span class="s0">, </span><span class="s1">des_l</span><span class="s0">, </span><span class="s1">rtol</span><span class="s0">, </span><span class="s1">atol</span><span class="s0">, False, </span><span class="s1">err_msg)</span>
            <span class="s1">assert_allclose(obt_u</span><span class="s0">, </span><span class="s1">des_u</span><span class="s0">, </span><span class="s1">rtol</span><span class="s0">, </span><span class="s1">atol</span><span class="s0">, False, </span><span class="s1">err_msg)</span>


<span class="s0">def </span><span class="s1">test_causality():  </span><span class="s3"># test Granger- and instantaneous causality</span>
    <span class="s0">if </span><span class="s1">debug_mode:</span>
        <span class="s0">if </span><span class="s4">&quot;causality&quot; </span><span class="s0">not in </span><span class="s1">to_test:</span>
            <span class="s0">return</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">print(</span><span class="s4">&quot;</span><span class="s0">\n\n</span><span class="s4">CAUSALITY&quot;</span><span class="s0">, </span><span class="s1">end=</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">ds </span><span class="s0">in </span><span class="s1">datasets:</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">dt_s_list:</span>
            <span class="s0">if </span><span class="s1">debug_mode:</span>
                <span class="s1">print(</span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot; </span><span class="s1">+ dt_s_tup_to_string(dt) + </span><span class="s4">&quot;: &quot;</span><span class="s0">, </span><span class="s1">end=</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>

            <span class="s1">err_msg_g_p = build_err_msg(ds</span><span class="s0">, </span><span class="s1">dt</span><span class="s0">, </span><span class="s4">&quot;GRANGER CAUS. - p-VALUE&quot;</span><span class="s1">)</span>
            <span class="s1">err_msg_g_t = build_err_msg(ds</span><span class="s0">, </span><span class="s1">dt</span><span class="s0">, </span><span class="s4">&quot;GRANGER CAUS. - TEST STAT.&quot;</span><span class="s1">)</span>
            <span class="s1">err_msg_i_p = build_err_msg(ds</span><span class="s0">, </span><span class="s1">dt</span><span class="s0">, </span><span class="s4">&quot;INSTANT. CAUS. - p-VALUE&quot;</span><span class="s1">)</span>
            <span class="s1">err_msg_i_t = build_err_msg(ds</span><span class="s0">, </span><span class="s1">dt</span><span class="s0">, </span><span class="s4">&quot;INSTANT. CAUS. - TEST STAT.&quot;</span><span class="s1">)</span>
            <span class="s1">v_ind = range(len(ds.variable_names))</span>
            <span class="s0">for </span><span class="s1">causing_ind </span><span class="s0">in </span><span class="s1">sublists(v_ind</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">len(v_ind) - </span><span class="s2">1</span><span class="s1">):</span>
                <span class="s1">causing_names = [</span><span class="s4">&quot;y&quot; </span><span class="s1">+ str(i + </span><span class="s2">1</span><span class="s1">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">causing_ind]</span>
                <span class="s1">causing_key = tuple(ds.variable_names[i] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">causing_ind)</span>

                <span class="s1">caused_ind = [i </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">v_ind </span><span class="s0">if </span><span class="s1">i </span><span class="s0">not in </span><span class="s1">causing_ind]</span>
                <span class="s1">caused_names = [</span><span class="s4">&quot;y&quot; </span><span class="s1">+ str(i + </span><span class="s2">1</span><span class="s1">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">caused_ind]</span>
                <span class="s1">caused_key = tuple(ds.variable_names[i] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">caused_ind)</span>

                <span class="s3"># test Granger-causality ######################################</span>
                <span class="s1">granger_sm_ind = results_sm[ds][dt].test_causality(</span>
                    <span class="s1">caused_ind</span><span class="s0">, </span><span class="s1">causing_ind</span>
                <span class="s1">)</span>
                <span class="s1">granger_sm_str = results_sm[ds][dt].test_causality(</span>
                    <span class="s1">caused_names</span><span class="s0">, </span><span class="s1">causing_names</span>
                <span class="s1">)</span>

                <span class="s3"># test test-statistic for Granger non-causality:</span>
                <span class="s1">g_t_obt = granger_sm_ind.test_statistic</span>
                <span class="s1">g_t_des = results_ref[ds][dt][</span><span class="s4">&quot;granger_caus&quot;</span><span class="s1">][</span><span class="s4">&quot;test_stat&quot;</span><span class="s1">][</span>
                    <span class="s1">(causing_key</span><span class="s0">, </span><span class="s1">caused_key)</span>
                <span class="s1">]</span>
                <span class="s1">assert_allclose(</span>
                    <span class="s1">g_t_obt</span><span class="s0">, </span><span class="s1">g_t_des</span><span class="s0">, </span><span class="s1">rtol</span><span class="s0">, </span><span class="s1">atol</span><span class="s0">, False, </span><span class="s1">err_msg_g_t</span>
                <span class="s1">)</span>
                <span class="s3"># check whether string sequences as args work in the same way:</span>
                <span class="s1">g_t_obt_str = granger_sm_str.test_statistic</span>
                <span class="s1">assert_allclose(</span>
                    <span class="s1">g_t_obt_str</span><span class="s0">,</span>
                    <span class="s1">g_t_obt</span><span class="s0">,</span>
                    <span class="s2">1e-07</span><span class="s0">,</span>
                    <span class="s2">0</span><span class="s0">,</span>
                    <span class="s0">False,</span>
                    <span class="s1">err_msg_g_t</span>
                    <span class="s1">+ </span><span class="s4">&quot; - sequences of integers and &quot;</span><span class="s1">.upper()</span>
                    <span class="s1">+ </span><span class="s4">&quot;strings as arguments do not yield the same result!&quot;</span><span class="s1">.upper()</span><span class="s0">,</span>
                <span class="s1">)</span>
                <span class="s3"># check if int (e.g. 0) as index and list of int ([0]) yield</span>
                <span class="s3"># the same result:</span>
                <span class="s0">if </span><span class="s1">len(causing_ind) == </span><span class="s2">1 </span><span class="s0">or </span><span class="s1">len(caused_ind) == </span><span class="s2">1</span><span class="s1">:</span>
                    <span class="s1">ci = (</span>
                        <span class="s1">causing_ind[</span><span class="s2">0</span><span class="s1">]</span>
                        <span class="s0">if </span><span class="s1">len(causing_ind) == </span><span class="s2">1</span>
                        <span class="s0">else </span><span class="s1">causing_ind</span>
                    <span class="s1">)</span>
                    <span class="s1">ce = caused_ind[</span><span class="s2">0</span><span class="s1">] </span><span class="s0">if </span><span class="s1">len(caused_ind) == </span><span class="s2">1 </span><span class="s0">else </span><span class="s1">caused_ind</span>
                    <span class="s1">granger_sm_single_ind = results_sm[ds][dt].test_causality(</span>
                        <span class="s1">ce</span><span class="s0">, </span><span class="s1">ci</span>
                    <span class="s1">)</span>
                    <span class="s1">g_t_obt_single = granger_sm_single_ind.test_statistic</span>
                    <span class="s1">assert_allclose(</span>
                        <span class="s1">g_t_obt_single</span><span class="s0">,</span>
                        <span class="s1">g_t_obt</span><span class="s0">,</span>
                        <span class="s2">1e-07</span><span class="s0">,</span>
                        <span class="s2">0</span><span class="s0">,</span>
                        <span class="s0">False,</span>
                        <span class="s1">err_msg_g_t</span>
                        <span class="s1">+ </span><span class="s4">&quot; - list of int and int as &quot;</span><span class="s1">.upper()</span>
                        <span class="s1">+ </span><span class="s4">&quot;argument do not yield the same result!&quot;</span><span class="s1">.upper()</span><span class="s0">,</span>
                    <span class="s1">)</span>

                <span class="s3"># test p-value for Granger non-causality:</span>
                <span class="s1">g_p_obt = granger_sm_ind.pvalue</span>
                <span class="s1">g_p_des = results_ref[ds][dt][</span><span class="s4">&quot;granger_caus&quot;</span><span class="s1">][</span><span class="s4">&quot;p&quot;</span><span class="s1">][</span>
                    <span class="s1">(causing_key</span><span class="s0">, </span><span class="s1">caused_key)</span>
                <span class="s1">]</span>
                <span class="s1">assert_allclose(</span>
                    <span class="s1">g_p_obt</span><span class="s0">, </span><span class="s1">g_p_des</span><span class="s0">, </span><span class="s1">rtol</span><span class="s0">, </span><span class="s1">atol</span><span class="s0">, False, </span><span class="s1">err_msg_g_p</span>
                <span class="s1">)</span>
                <span class="s3"># check whether string sequences as args work in the same way:</span>
                <span class="s1">g_p_obt_str = granger_sm_str.pvalue</span>
                <span class="s1">assert_allclose(</span>
                    <span class="s1">g_p_obt_str</span><span class="s0">,</span>
                    <span class="s1">g_p_obt</span><span class="s0">,</span>
                    <span class="s2">1e-07</span><span class="s0">,</span>
                    <span class="s2">0</span><span class="s0">,</span>
                    <span class="s0">False,</span>
                    <span class="s1">err_msg_g_t</span>
                    <span class="s1">+ </span><span class="s4">&quot; - sequences of integers and &quot;</span><span class="s1">.upper()</span>
                    <span class="s1">+ </span><span class="s4">&quot;strings as arguments do not yield the same result!&quot;</span><span class="s1">.upper()</span><span class="s0">,</span>
                <span class="s1">)</span>
                <span class="s3"># check if int (e.g. 0) as index and list of int ([0]) yield</span>
                <span class="s3"># the same result:</span>
                <span class="s0">if </span><span class="s1">len(causing_ind) == </span><span class="s2">1</span><span class="s1">:</span>
                    <span class="s1">g_p_obt_single = granger_sm_single_ind.pvalue</span>
                    <span class="s1">assert_allclose(</span>
                        <span class="s1">g_p_obt_single</span><span class="s0">,</span>
                        <span class="s1">g_p_obt</span><span class="s0">,</span>
                        <span class="s2">1e-07</span><span class="s0">,</span>
                        <span class="s2">0</span><span class="s0">,</span>
                        <span class="s0">False,</span>
                        <span class="s1">err_msg_g_t</span>
                        <span class="s1">+ </span><span class="s4">&quot; - list of int and int as &quot;</span><span class="s1">.upper()</span>
                        <span class="s1">+ </span><span class="s4">&quot;argument do not yield the same result!&quot;</span><span class="s1">.upper()</span><span class="s0">,</span>
                    <span class="s1">)</span>

                <span class="s3"># test instantaneous causality ################################</span>
                <span class="s1">inst_sm_ind = results_sm[ds][dt].test_inst_causality(</span>
                    <span class="s1">causing_ind</span>
                <span class="s1">)</span>
                <span class="s1">inst_sm_str = results_sm[ds][dt].test_inst_causality(</span>
                    <span class="s1">causing_names</span>
                <span class="s1">)</span>
                <span class="s3"># test test-statistic for instantaneous non-causality</span>
                <span class="s1">t_obt = inst_sm_ind.test_statistic</span>
                <span class="s1">t_des = results_ref[ds][dt][</span><span class="s4">&quot;inst_caus&quot;</span><span class="s1">][</span><span class="s4">&quot;test_stat&quot;</span><span class="s1">][</span>
                    <span class="s1">(causing_key</span><span class="s0">, </span><span class="s1">caused_key)</span>
                <span class="s1">]</span>
                <span class="s1">assert_allclose(t_obt</span><span class="s0">, </span><span class="s1">t_des</span><span class="s0">, </span><span class="s1">rtol</span><span class="s0">, </span><span class="s1">atol</span><span class="s0">, False, </span><span class="s1">err_msg_i_t)</span>
                <span class="s3"># check whether string sequences as args work in the same way:</span>
                <span class="s1">t_obt_str = inst_sm_str.test_statistic</span>
                <span class="s1">assert_allclose(</span>
                    <span class="s1">t_obt_str</span><span class="s0">,</span>
                    <span class="s1">t_obt</span><span class="s0">,</span>
                    <span class="s2">1e-07</span><span class="s0">,</span>
                    <span class="s2">0</span><span class="s0">,</span>
                    <span class="s0">False,</span>
                    <span class="s1">err_msg_i_t</span>
                    <span class="s1">+ </span><span class="s4">&quot; - sequences of integers and &quot;</span><span class="s1">.upper()</span>
                    <span class="s1">+ </span><span class="s4">&quot;strings as arguments do not yield the same result!&quot;</span><span class="s1">.upper()</span><span class="s0">,</span>
                <span class="s1">)</span>
                <span class="s3"># check if int (e.g. 0) as index and list of int ([0]) yield</span>
                <span class="s3"># the same result:</span>
                <span class="s0">if </span><span class="s1">len(causing_ind) == </span><span class="s2">1</span><span class="s1">:</span>
                    <span class="s1">inst_sm_single_ind = results_sm[ds][</span>
                        <span class="s1">dt</span>
                    <span class="s1">].test_inst_causality(causing_ind[</span><span class="s2">0</span><span class="s1">])</span>
                    <span class="s1">t_obt_single = inst_sm_single_ind.test_statistic</span>
                    <span class="s1">assert_allclose(</span>
                        <span class="s1">t_obt_single</span><span class="s0">,</span>
                        <span class="s1">t_obt</span><span class="s0">,</span>
                        <span class="s2">1e-07</span><span class="s0">,</span>
                        <span class="s2">0</span><span class="s0">,</span>
                        <span class="s0">False,</span>
                        <span class="s1">err_msg_i_t</span>
                        <span class="s1">+ </span><span class="s4">&quot; - list of int and int as &quot;</span><span class="s1">.upper()</span>
                        <span class="s1">+ </span><span class="s4">&quot;argument do not yield the same result!&quot;</span><span class="s1">.upper()</span><span class="s0">,</span>
                    <span class="s1">)</span>

                <span class="s3"># test p-value for instantaneous non-causality</span>
                <span class="s1">p_obt = (</span>
                    <span class="s1">results_sm[ds][dt].test_inst_causality(causing_ind).pvalue</span>
                <span class="s1">)</span>
                <span class="s1">p_des = results_ref[ds][dt][</span><span class="s4">&quot;inst_caus&quot;</span><span class="s1">][</span><span class="s4">&quot;p&quot;</span><span class="s1">][</span>
                    <span class="s1">(causing_key</span><span class="s0">, </span><span class="s1">caused_key)</span>
                <span class="s1">]</span>
                <span class="s1">assert_allclose(p_obt</span><span class="s0">, </span><span class="s1">p_des</span><span class="s0">, </span><span class="s1">rtol</span><span class="s0">, </span><span class="s1">atol</span><span class="s0">, False, </span><span class="s1">err_msg_i_p)</span>
                <span class="s3"># check whether string sequences as args work in the same way:</span>
                <span class="s1">p_obt_str = inst_sm_str.pvalue</span>
                <span class="s1">assert_allclose(</span>
                    <span class="s1">p_obt_str</span><span class="s0">,</span>
                    <span class="s1">p_obt</span><span class="s0">,</span>
                    <span class="s2">1e-07</span><span class="s0">,</span>
                    <span class="s2">0</span><span class="s0">,</span>
                    <span class="s0">False,</span>
                    <span class="s1">err_msg_i_p</span>
                    <span class="s1">+ </span><span class="s4">&quot; - sequences of integers and &quot;</span><span class="s1">.upper()</span>
                    <span class="s1">+ </span><span class="s4">&quot;strings as arguments do not yield the same result!&quot;</span><span class="s1">.upper()</span><span class="s0">,</span>
                <span class="s1">)</span>
                <span class="s3"># check if int (e.g. 0) as index and list of int ([0]) yield</span>
                <span class="s3"># the same result:</span>
                <span class="s0">if </span><span class="s1">len(causing_ind) == </span><span class="s2">1</span><span class="s1">:</span>
                    <span class="s1">inst_sm_single_ind = results_sm[ds][</span>
                        <span class="s1">dt</span>
                    <span class="s1">].test_inst_causality(causing_ind[</span><span class="s2">0</span><span class="s1">])</span>
                    <span class="s1">p_obt_single = inst_sm_single_ind.pvalue</span>
                    <span class="s1">assert_allclose(</span>
                        <span class="s1">p_obt_single</span><span class="s0">,</span>
                        <span class="s1">p_obt</span><span class="s0">,</span>
                        <span class="s2">1e-07</span><span class="s0">,</span>
                        <span class="s2">0</span><span class="s0">,</span>
                        <span class="s0">False,</span>
                        <span class="s1">err_msg_i_p</span>
                        <span class="s1">+ </span><span class="s4">&quot; - list of int and int as &quot;</span><span class="s1">.upper()</span>
                        <span class="s1">+ </span><span class="s4">&quot;argument do not yield the same result!&quot;</span><span class="s1">.upper()</span><span class="s0">,</span>
                    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_impulse_response():</span>
    <span class="s0">if </span><span class="s1">debug_mode:</span>
        <span class="s0">if </span><span class="s4">&quot;impulse-response&quot; </span><span class="s0">not in </span><span class="s1">to_test:</span>
            <span class="s0">return</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">print(</span><span class="s4">&quot;</span><span class="s0">\n\n</span><span class="s4">IMPULSE-RESPONSE&quot;</span><span class="s0">, </span><span class="s1">end=</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">ds </span><span class="s0">in </span><span class="s1">datasets:</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">dt_s_list:</span>
            <span class="s0">if </span><span class="s1">debug_mode:</span>
                <span class="s1">print(</span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot; </span><span class="s1">+ dt_s_tup_to_string(dt) + </span><span class="s4">&quot;: &quot;</span><span class="s0">, </span><span class="s1">end=</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
            <span class="s1">err_msg = build_err_msg(ds</span><span class="s0">, </span><span class="s1">dt</span><span class="s0">, </span><span class="s4">&quot;IMULSE-RESPONSE&quot;</span><span class="s1">)</span>
            <span class="s1">periods = </span><span class="s2">20</span>
            <span class="s1">obtained_all = results_sm[ds][dt].irf(periods=periods).irfs</span>
            <span class="s3"># flatten inner arrays to make them comparable to parsed results:</span>
            <span class="s1">obtained_all = obtained_all.reshape(periods + </span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">)</span>
            <span class="s1">desired_all = results_ref[ds][dt][</span><span class="s4">&quot;ir&quot;</span><span class="s1">]</span>
            <span class="s1">assert_allclose(</span>
                <span class="s1">obtained_all</span><span class="s0">, </span><span class="s1">desired_all</span><span class="s0">, </span><span class="s1">rtol</span><span class="s0">, </span><span class="s1">atol</span><span class="s0">, False, </span><span class="s1">err_msg</span>
            <span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_lag_order_selection():</span>
    <span class="s0">if </span><span class="s1">debug_mode:</span>
        <span class="s0">if </span><span class="s4">&quot;lag order&quot; </span><span class="s0">not in </span><span class="s1">to_test:</span>
            <span class="s0">return</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">print(</span><span class="s4">&quot;</span><span class="s0">\n\n</span><span class="s4">LAG ORDER SELECTION&quot;</span><span class="s0">, </span><span class="s1">end=</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">ds </span><span class="s0">in </span><span class="s1">datasets:</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">dt_s_list:</span>
            <span class="s0">if </span><span class="s1">debug_mode:</span>
                <span class="s1">print(</span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot; </span><span class="s1">+ dt_s_tup_to_string(dt) + </span><span class="s4">&quot;: &quot;</span><span class="s0">, </span><span class="s1">end=</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
            <span class="s1">endog_tot = data[ds]</span>
            <span class="s1">exog = generate_exog_from_season(dt[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">len(endog_tot))</span>
            <span class="s1">model = VAR(endog_tot</span><span class="s0">, </span><span class="s1">exog)</span>
            <span class="s1">trend = </span><span class="s4">&quot;n&quot; </span><span class="s0">if </span><span class="s1">dt[</span><span class="s2">0</span><span class="s1">] == </span><span class="s4">&quot;nc&quot; </span><span class="s0">else </span><span class="s1">dt[</span><span class="s2">0</span><span class="s1">]</span>
            <span class="s1">obtained_all = model.select_order(</span><span class="s2">10</span><span class="s0">, </span><span class="s1">trend=trend)</span>
            <span class="s0">for </span><span class="s1">ic </span><span class="s0">in </span><span class="s1">[</span><span class="s4">&quot;aic&quot;</span><span class="s0">, </span><span class="s4">&quot;fpe&quot;</span><span class="s0">, </span><span class="s4">&quot;hqic&quot;</span><span class="s0">, </span><span class="s4">&quot;bic&quot;</span><span class="s1">]:</span>
                <span class="s1">err_msg = build_err_msg(</span>
                    <span class="s1">ds</span><span class="s0">, </span><span class="s1">dt</span><span class="s0">, </span><span class="s4">&quot;LAG ORDER SELECTION - &quot; </span><span class="s1">+ ic.upper()</span>
                <span class="s1">)</span>
                <span class="s1">obtained = getattr(obtained_all</span><span class="s0">, </span><span class="s1">ic)</span>
                <span class="s1">desired = results_ref[ds][dt][</span><span class="s4">&quot;lagorder&quot;</span><span class="s1">][ic]</span>
                <span class="s1">assert_allclose(obtained</span><span class="s0">, </span><span class="s1">desired</span><span class="s0">, </span><span class="s1">rtol</span><span class="s0">, </span><span class="s1">atol</span><span class="s0">, False, </span><span class="s1">err_msg)</span>


<span class="s0">def </span><span class="s1">test_normality():</span>
    <span class="s0">if </span><span class="s1">debug_mode:</span>
        <span class="s0">if </span><span class="s4">&quot;test normality&quot; </span><span class="s0">not in </span><span class="s1">to_test:</span>
            <span class="s0">return</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">print(</span><span class="s4">&quot;</span><span class="s0">\n\n</span><span class="s4">TEST NON-NORMALITY&quot;</span><span class="s0">, </span><span class="s1">end=</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">ds </span><span class="s0">in </span><span class="s1">datasets:</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">dt_s_list:</span>
            <span class="s0">if </span><span class="s1">debug_mode:</span>
                <span class="s1">print(</span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot; </span><span class="s1">+ dt_s_tup_to_string(dt) + </span><span class="s4">&quot;: &quot;</span><span class="s0">, </span><span class="s1">end=</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>

            <span class="s1">obtained = results_sm[ds][dt].test_normality(signif=</span><span class="s2">0.05</span><span class="s1">)</span>
            <span class="s1">err_msg = build_err_msg(ds</span><span class="s0">, </span><span class="s1">dt</span><span class="s0">, </span><span class="s4">&quot;TEST NON-NORMALITY - STATISTIC&quot;</span><span class="s1">)</span>
            <span class="s1">obt_statistic = obtained.test_statistic</span>
            <span class="s1">des_statistic = results_ref[ds][dt][</span><span class="s4">&quot;test_norm&quot;</span><span class="s1">][</span>
                <span class="s4">&quot;joint_test_statistic&quot;</span>
            <span class="s1">]</span>
            <span class="s1">assert_allclose(</span>
                <span class="s1">obt_statistic</span><span class="s0">, </span><span class="s1">des_statistic</span><span class="s0">, </span><span class="s1">rtol</span><span class="s0">, </span><span class="s1">atol</span><span class="s0">, False, </span><span class="s1">err_msg</span>
            <span class="s1">)</span>
            <span class="s1">err_msg = build_err_msg(ds</span><span class="s0">, </span><span class="s1">dt</span><span class="s0">, </span><span class="s4">&quot;TEST NON-NORMALITY - P-VALUE&quot;</span><span class="s1">)</span>
            <span class="s1">obt_pvalue = obtained.pvalue</span>
            <span class="s1">des_pvalue = results_ref[ds][dt][</span><span class="s4">&quot;test_norm&quot;</span><span class="s1">][</span><span class="s4">&quot;joint_pvalue&quot;</span><span class="s1">]</span>
            <span class="s1">assert_allclose(obt_pvalue</span><span class="s0">, </span><span class="s1">des_pvalue</span><span class="s0">, </span><span class="s1">rtol</span><span class="s0">, </span><span class="s1">atol</span><span class="s0">, False, </span><span class="s1">err_msg)</span>
            <span class="s3"># call methods to assure they do not raise exceptions</span>
            <span class="s1">obtained.summary()</span>
            <span class="s1">str(obtained)  </span><span class="s3"># __str__()</span>


<span class="s0">def </span><span class="s1">test_whiteness():</span>
    <span class="s0">if </span><span class="s1">debug_mode:</span>
        <span class="s0">if </span><span class="s4">&quot;whiteness&quot; </span><span class="s0">not in </span><span class="s1">to_test:</span>
            <span class="s0">return</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">print(</span><span class="s4">&quot;</span><span class="s0">\n\n</span><span class="s4">TEST WHITENESS OF RESIDUALS&quot;</span><span class="s0">, </span><span class="s1">end=</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">ds </span><span class="s0">in </span><span class="s1">datasets:</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">dt_s_list:</span>
            <span class="s0">if </span><span class="s1">debug_mode:</span>
                <span class="s1">print(</span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot; </span><span class="s1">+ dt_s_tup_to_string(dt) + </span><span class="s4">&quot;: &quot;</span><span class="s0">, </span><span class="s1">end=</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
            <span class="s1">lags = results_ref[ds][dt][</span><span class="s4">&quot;whiteness&quot;</span><span class="s1">][</span><span class="s4">&quot;tested order&quot;</span><span class="s1">]</span>

            <span class="s1">obtained = results_sm[ds][dt].test_whiteness(nlags=lags)</span>
            <span class="s3"># test statistic</span>
            <span class="s1">err_msg = build_err_msg(</span>
                <span class="s1">ds</span><span class="s0">, </span><span class="s1">dt</span><span class="s0">, </span><span class="s4">&quot;WHITENESS OF RESIDUALS - &quot; &quot;TEST STATISTIC&quot;</span>
            <span class="s1">)</span>
            <span class="s1">desired = results_ref[ds][dt][</span><span class="s4">&quot;whiteness&quot;</span><span class="s1">][</span><span class="s4">&quot;test statistic&quot;</span><span class="s1">]</span>
            <span class="s1">assert_allclose(</span>
                <span class="s1">obtained.test_statistic</span><span class="s0">, </span><span class="s1">desired</span><span class="s0">, </span><span class="s1">rtol</span><span class="s0">, </span><span class="s1">atol</span><span class="s0">, False, </span><span class="s1">err_msg</span>
            <span class="s1">)</span>
            <span class="s3"># p-value</span>
            <span class="s1">err_msg = build_err_msg(</span>
                <span class="s1">ds</span><span class="s0">, </span><span class="s1">dt</span><span class="s0">, </span><span class="s4">&quot;WHITENESS OF RESIDUALS - &quot; &quot;P-VALUE&quot;</span>
            <span class="s1">)</span>
            <span class="s1">desired = results_ref[ds][dt][</span><span class="s4">&quot;whiteness&quot;</span><span class="s1">][</span><span class="s4">&quot;p-value&quot;</span><span class="s1">]</span>
            <span class="s1">assert_allclose(</span>
                <span class="s1">obtained.pvalue</span><span class="s0">, </span><span class="s1">desired</span><span class="s0">, </span><span class="s1">rtol</span><span class="s0">, </span><span class="s1">atol</span><span class="s0">, False, </span><span class="s1">err_msg</span>
            <span class="s1">)</span>

            <span class="s1">obtained = results_sm[ds][dt].test_whiteness(</span>
                <span class="s1">nlags=lags</span><span class="s0">, </span><span class="s1">adjusted=</span><span class="s0">True</span>
            <span class="s1">)</span>
            <span class="s3"># test statistic (adjusted Portmanteau test)</span>
            <span class="s1">err_msg = build_err_msg(</span>
                <span class="s1">ds</span><span class="s0">,</span>
                <span class="s1">dt</span><span class="s0">,</span>
                <span class="s4">&quot;WHITENESS OF RESIDUALS - &quot; &quot;TEST STATISTIC (ADJUSTED TEST)&quot;</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s1">desired = results_ref[ds][dt][</span><span class="s4">&quot;whiteness&quot;</span><span class="s1">][</span><span class="s4">&quot;test statistic adj.&quot;</span><span class="s1">]</span>
            <span class="s1">assert_allclose(</span>
                <span class="s1">obtained.test_statistic</span><span class="s0">, </span><span class="s1">desired</span><span class="s0">, </span><span class="s1">rtol</span><span class="s0">, </span><span class="s1">atol</span><span class="s0">, False, </span><span class="s1">err_msg</span>
            <span class="s1">)</span>
            <span class="s3"># p-value (adjusted Portmanteau test)</span>
            <span class="s1">err_msg = build_err_msg(</span>
                <span class="s1">ds</span><span class="s0">, </span><span class="s1">dt</span><span class="s0">, </span><span class="s4">&quot;WHITENESS OF RESIDUALS - &quot; &quot;P-VALUE (ADJUSTED TEST)&quot;</span>
            <span class="s1">)</span>
            <span class="s1">desired = results_ref[ds][dt][</span><span class="s4">&quot;whiteness&quot;</span><span class="s1">][</span><span class="s4">&quot;p-value adjusted&quot;</span><span class="s1">]</span>
            <span class="s1">assert_allclose(</span>
                <span class="s1">obtained.pvalue</span><span class="s0">, </span><span class="s1">desired</span><span class="s0">, </span><span class="s1">rtol</span><span class="s0">, </span><span class="s1">atol</span><span class="s0">, False, </span><span class="s1">err_msg</span>
            <span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_exceptions():</span>
    <span class="s0">if </span><span class="s1">debug_mode:</span>
        <span class="s0">if </span><span class="s4">&quot;exceptions&quot; </span><span class="s0">not in </span><span class="s1">to_test:</span>
            <span class="s0">return</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">print(</span><span class="s4">&quot;</span><span class="s0">\n\n</span><span class="s4">EXCEPTIONS</span><span class="s0">\n</span><span class="s4">&quot;</span><span class="s0">, </span><span class="s1">end=</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">ds </span><span class="s0">in </span><span class="s1">datasets:</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">dt_s_list:</span>
            <span class="s0">if </span><span class="s1">debug_mode:</span>
                <span class="s1">print(</span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot; </span><span class="s1">+ dt_s_tup_to_string(dt) + </span><span class="s4">&quot;: &quot;</span><span class="s0">, </span><span class="s1">end=</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>

            <span class="s3"># instant causality:</span>
            <span class="s3">### 0&lt;signif&lt;1</span>
            <span class="s1">assert_raises(</span>
                <span class="s1">ValueError</span><span class="s0">, </span><span class="s1">results_sm[ds][dt].test_inst_causality</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span>
            <span class="s1">)  </span><span class="s3"># this means signif=0</span>
            <span class="s3">### causing must be int, str or iterable of int or str</span>
            <span class="s1">assert_raises(</span>
                <span class="s1">TypeError</span><span class="s0">, </span><span class="s1">results_sm[ds][dt].test_inst_causality</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.5</span><span class="s1">]</span>
            <span class="s1">)  </span><span class="s3"># 0.5 not an int</span>
</pre>
</body>
</html>