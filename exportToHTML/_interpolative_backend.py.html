<html>
<head>
<title>_interpolative_backend.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_interpolative_backend.py</font>
</center></td></tr></table>
<pre><span class="s0">#******************************************************************************</span>
<span class="s0">#   Copyright (C) 2013 Kenneth L. Ho</span>
<span class="s0">#</span>
<span class="s0">#   Redistribution and use in source and binary forms, with or without</span>
<span class="s0">#   modification, are permitted provided that the following conditions are met:</span>
<span class="s0">#</span>
<span class="s0">#   Redistributions of source code must retain the above copyright notice, this</span>
<span class="s0">#   list of conditions and the following disclaimer. Redistributions in binary</span>
<span class="s0">#   form must reproduce the above copyright notice, this list of conditions and</span>
<span class="s0">#   the following disclaimer in the documentation and/or other materials</span>
<span class="s0">#   provided with the distribution.</span>
<span class="s0">#</span>
<span class="s0">#   None of the names of the copyright holders may be used to endorse or</span>
<span class="s0">#   promote products derived from this software without specific prior written</span>
<span class="s0">#   permission.</span>
<span class="s0">#</span>
<span class="s0">#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span class="s0">#   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="s0">#   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="s0">#   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE</span>
<span class="s0">#   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="s0">#   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="s0">#   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="s0">#   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<span class="s0">#   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span class="s0">#   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="s0">#   POSSIBILITY OF SUCH DAMAGE.</span>
<span class="s0">#******************************************************************************</span>

<span class="s2">&quot;&quot;&quot; 
Direct wrappers for Fortran `id_dist` backend. 
&quot;&quot;&quot;</span>

<span class="s3">import </span><span class="s1">scipy.linalg._interpolative </span><span class="s3">as </span><span class="s1">_id</span>
<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>

<span class="s1">_RETCODE_ERROR = RuntimeError(</span><span class="s4">&quot;nonzero return code&quot;</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">_asfortranarray_copy(A):</span>
    <span class="s2">&quot;&quot;&quot; 
    Same as np.asfortranarray, but ensure a copy 
    &quot;&quot;&quot;</span>
    <span class="s1">A = np.asarray(A)</span>
    <span class="s3">if </span><span class="s1">A.flags.f_contiguous:</span>
        <span class="s1">A = A.copy(order=</span><span class="s4">&quot;F&quot;</span><span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">A = np.asfortranarray(A)</span>
    <span class="s3">return </span><span class="s1">A</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># id_rand.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">id_srand(n):</span>
    <span class="s2">&quot;&quot;&quot; 
    Generate standard uniform pseudorandom numbers via a very efficient lagged 
    Fibonacci method. 
 
    :param n: 
        Number of pseudorandom numbers to generate. 
    :type n: int 
 
    :return: 
        Pseudorandom numbers. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_id.id_srand(n)</span>


<span class="s3">def </span><span class="s1">id_srandi(t):</span>
    <span class="s2">&quot;&quot;&quot; 
    Initialize seed values for :func:`id_srand` (any appropriately random 
    numbers will do). 
 
    :param t: 
        Array of 55 seed values. 
    :type t: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">t = np.asfortranarray(t)</span>
    <span class="s1">_id.id_srandi(t)</span>


<span class="s3">def </span><span class="s1">id_srando():</span>
    <span class="s2">&quot;&quot;&quot; 
    Reset seed values to their original values. 
    &quot;&quot;&quot;</span>
    <span class="s1">_id.id_srando()</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idd_frm.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">idd_frm(n</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">x):</span>
    <span class="s2">&quot;&quot;&quot; 
    Transform real vector via a composition of Rokhlin's random transform, 
    random subselection, and an FFT. 
 
    In contrast to :func:`idd_sfrm`, this routine works best when the length of 
    the transformed vector is the power-of-two integer output by 
    :func:`idd_frmi`, or when the length is not specified but instead 
    determined a posteriori from the output. The returned transformed vector is 
    randomly permuted. 
 
    :param n: 
        Greatest power-of-two integer satisfying `n &lt;= x.size` as obtained from 
        :func:`idd_frmi`; `n` is also the length of the output vector. 
    :type n: int 
    :param w: 
        Initialization array constructed by :func:`idd_frmi`. 
    :type w: :class:`numpy.ndarray` 
    :param x: 
        Vector to be transformed. 
    :type x: :class:`numpy.ndarray` 
 
    :return: 
        Transformed vector. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_id.idd_frm(n</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">x)</span>


<span class="s3">def </span><span class="s1">idd_sfrm(l</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">x):</span>
    <span class="s2">&quot;&quot;&quot; 
    Transform real vector via a composition of Rokhlin's random transform, 
    random subselection, and an FFT. 
 
    In contrast to :func:`idd_frm`, this routine works best when the length of 
    the transformed vector is known a priori. 
 
    :param l: 
        Length of transformed vector, satisfying `l &lt;= n`. 
    :type l: int 
    :param n: 
        Greatest power-of-two integer satisfying `n &lt;= x.size` as obtained from 
        :func:`idd_sfrmi`. 
    :type n: int 
    :param w: 
        Initialization array constructed by :func:`idd_sfrmi`. 
    :type w: :class:`numpy.ndarray` 
    :param x: 
        Vector to be transformed. 
    :type x: :class:`numpy.ndarray` 
 
    :return: 
        Transformed vector. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_id.idd_sfrm(l</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">x)</span>


<span class="s3">def </span><span class="s1">idd_frmi(m):</span>
    <span class="s2">&quot;&quot;&quot; 
    Initialize data for :func:`idd_frm`. 
 
    :param m: 
        Length of vector to be transformed. 
    :type m: int 
 
    :return: 
        Greatest power-of-two integer `n` satisfying `n &lt;= m`. 
    :rtype: int 
    :return: 
        Initialization array to be used by :func:`idd_frm`. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_id.idd_frmi(m)</span>


<span class="s3">def </span><span class="s1">idd_sfrmi(l</span><span class="s3">, </span><span class="s1">m):</span>
    <span class="s2">&quot;&quot;&quot; 
    Initialize data for :func:`idd_sfrm`. 
 
    :param l: 
        Length of output transformed vector. 
    :type l: int 
    :param m: 
        Length of the vector to be transformed. 
    :type m: int 
 
    :return: 
        Greatest power-of-two integer `n` satisfying `n &lt;= m`. 
    :rtype: int 
    :return: 
        Initialization array to be used by :func:`idd_sfrm`. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_id.idd_sfrmi(l</span><span class="s3">, </span><span class="s1">m)</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idd_id.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">iddp_id(eps</span><span class="s3">, </span><span class="s1">A):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute ID of a real matrix to a specified relative precision. 
 
    :param eps: 
        Relative precision. 
    :type eps: float 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
 
    :return: 
        Rank of ID. 
    :rtype: int 
    :return: 
        Column index array. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Interpolation coefficients. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A = _asfortranarray_copy(A)</span>
    <span class="s1">k</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">rnorms = _id.iddp_id(eps</span><span class="s3">, </span><span class="s1">A)</span>
    <span class="s1">n = A.shape[</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">proj = A.T.ravel()[:k*(n-k)].reshape((k</span><span class="s3">, </span><span class="s1">n-k)</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">k</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">proj</span>


<span class="s3">def </span><span class="s1">iddr_id(A</span><span class="s3">, </span><span class="s1">k):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute ID of a real matrix to a specified rank. 
 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
    :param k: 
        Rank of ID. 
    :type k: int 
 
    :return: 
        Column index array. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Interpolation coefficients. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A = _asfortranarray_copy(A)</span>
    <span class="s1">idx</span><span class="s3">, </span><span class="s1">rnorms = _id.iddr_id(A</span><span class="s3">, </span><span class="s1">k)</span>
    <span class="s1">n = A.shape[</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">proj = A.T.ravel()[:k*(n-k)].reshape((k</span><span class="s3">, </span><span class="s1">n-k)</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">proj</span>


<span class="s3">def </span><span class="s1">idd_reconid(B</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">proj):</span>
    <span class="s2">&quot;&quot;&quot; 
    Reconstruct matrix from real ID. 
 
    :param B: 
        Skeleton matrix. 
    :type B: :class:`numpy.ndarray` 
    :param idx: 
        Column index array. 
    :type idx: :class:`numpy.ndarray` 
    :param proj: 
        Interpolation coefficients. 
    :type proj: :class:`numpy.ndarray` 
 
    :return: 
        Reconstructed matrix. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">B = np.asfortranarray(B)</span>
    <span class="s3">if </span><span class="s1">proj.size &gt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">_id.idd_reconid(B</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">proj)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">B[:</span><span class="s3">, </span><span class="s1">np.argsort(idx)]</span>


<span class="s3">def </span><span class="s1">idd_reconint(idx</span><span class="s3">, </span><span class="s1">proj):</span>
    <span class="s2">&quot;&quot;&quot; 
    Reconstruct interpolation matrix from real ID. 
 
    :param idx: 
        Column index array. 
    :type idx: :class:`numpy.ndarray` 
    :param proj: 
        Interpolation coefficients. 
    :type proj: :class:`numpy.ndarray` 
 
    :return: 
        Interpolation matrix. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_id.idd_reconint(idx</span><span class="s3">, </span><span class="s1">proj)</span>


<span class="s3">def </span><span class="s1">idd_copycols(A</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">idx):</span>
    <span class="s2">&quot;&quot;&quot; 
    Reconstruct skeleton matrix from real ID. 
 
    :param A: 
        Original matrix. 
    :type A: :class:`numpy.ndarray` 
    :param k: 
        Rank of ID. 
    :type k: int 
    :param idx: 
        Column index array. 
    :type idx: :class:`numpy.ndarray` 
 
    :return: 
        Skeleton matrix. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A = np.asfortranarray(A)</span>
    <span class="s3">return </span><span class="s1">_id.idd_copycols(A</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">idx)</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idd_id2svd.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">idd_id2svd(B</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">proj):</span>
    <span class="s2">&quot;&quot;&quot; 
    Convert real ID to SVD. 
 
    :param B: 
        Skeleton matrix. 
    :type B: :class:`numpy.ndarray` 
    :param idx: 
        Column index array. 
    :type idx: :class:`numpy.ndarray` 
    :param proj: 
        Interpolation coefficients. 
    :type proj: :class:`numpy.ndarray` 
 
    :return: 
        Left singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Right singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Singular values. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">B = np.asfortranarray(B)</span>
    <span class="s1">U</span><span class="s3">, </span><span class="s1">V</span><span class="s3">, </span><span class="s1">S</span><span class="s3">, </span><span class="s1">ier = _id.idd_id2svd(B</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">proj)</span>
    <span class="s3">if </span><span class="s1">ier:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s3">return </span><span class="s1">U</span><span class="s3">, </span><span class="s1">V</span><span class="s3">, </span><span class="s1">S</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idd_snorm.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">idd_snorm(m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">matvect</span><span class="s3">, </span><span class="s1">matvec</span><span class="s3">, </span><span class="s1">its=</span><span class="s5">20</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Estimate spectral norm of a real matrix by the randomized power method. 
 
    :param m: 
        Matrix row dimension. 
    :type m: int 
    :param n: 
        Matrix column dimension. 
    :type n: int 
    :param matvect: 
        Function to apply the matrix transpose to a vector, with call signature 
        `y = matvect(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matvect: function 
    :param matvec: 
        Function to apply the matrix to a vector, with call signature 
        `y = matvec(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matvec: function 
    :param its: 
        Number of power method iterations. 
    :type its: int 
 
    :return: 
        Spectral norm estimate. 
    :rtype: float 
    &quot;&quot;&quot;</span>
    <span class="s1">snorm</span><span class="s3">, </span><span class="s1">v = _id.idd_snorm(m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">matvect</span><span class="s3">, </span><span class="s1">matvec</span><span class="s3">, </span><span class="s1">its)</span>
    <span class="s3">return </span><span class="s1">snorm</span>


<span class="s3">def </span><span class="s1">idd_diffsnorm(m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">matvect</span><span class="s3">, </span><span class="s1">matvect2</span><span class="s3">, </span><span class="s1">matvec</span><span class="s3">, </span><span class="s1">matvec2</span><span class="s3">, </span><span class="s1">its=</span><span class="s5">20</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Estimate spectral norm of the difference of two real matrices by the 
    randomized power method. 
 
    :param m: 
        Matrix row dimension. 
    :type m: int 
    :param n: 
        Matrix column dimension. 
    :type n: int 
    :param matvect: 
        Function to apply the transpose of the first matrix to a vector, with 
        call signature `y = matvect(x)`, where `x` and `y` are the input and 
        output vectors, respectively. 
    :type matvect: function 
    :param matvect2: 
        Function to apply the transpose of the second matrix to a vector, with 
        call signature `y = matvect2(x)`, where `x` and `y` are the input and 
        output vectors, respectively. 
    :type matvect2: function 
    :param matvec: 
        Function to apply the first matrix to a vector, with call signature 
        `y = matvec(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matvec: function 
    :param matvec2: 
        Function to apply the second matrix to a vector, with call signature 
        `y = matvec2(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matvec2: function 
    :param its: 
        Number of power method iterations. 
    :type its: int 
 
    :return: 
        Spectral norm estimate of matrix difference. 
    :rtype: float 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_id.idd_diffsnorm(m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">matvect</span><span class="s3">, </span><span class="s1">matvect2</span><span class="s3">, </span><span class="s1">matvec</span><span class="s3">, </span><span class="s1">matvec2</span><span class="s3">, </span><span class="s1">its)</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idd_svd.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">iddr_svd(A</span><span class="s3">, </span><span class="s1">k):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute SVD of a real matrix to a specified rank. 
 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
    :param k: 
        Rank of SVD. 
    :type k: int 
 
    :return: 
        Left singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Right singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Singular values. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A = np.asfortranarray(A)</span>
    <span class="s1">U</span><span class="s3">, </span><span class="s1">V</span><span class="s3">, </span><span class="s1">S</span><span class="s3">, </span><span class="s1">ier = _id.iddr_svd(A</span><span class="s3">, </span><span class="s1">k)</span>
    <span class="s3">if </span><span class="s1">ier:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s3">return </span><span class="s1">U</span><span class="s3">, </span><span class="s1">V</span><span class="s3">, </span><span class="s1">S</span>


<span class="s3">def </span><span class="s1">iddp_svd(eps</span><span class="s3">, </span><span class="s1">A):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute SVD of a real matrix to a specified relative precision. 
 
    :param eps: 
        Relative precision. 
    :type eps: float 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
 
    :return: 
        Left singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Right singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Singular values. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A = np.asfortranarray(A)</span>
    <span class="s1">m</span><span class="s3">, </span><span class="s1">n = A.shape</span>
    <span class="s1">k</span><span class="s3">, </span><span class="s1">iU</span><span class="s3">, </span><span class="s1">iV</span><span class="s3">, </span><span class="s1">iS</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">ier = _id.iddp_svd(eps</span><span class="s3">, </span><span class="s1">A)</span>
    <span class="s3">if </span><span class="s1">ier:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s1">U = w[iU-</span><span class="s5">1</span><span class="s1">:iU+m*k-</span><span class="s5">1</span><span class="s1">].reshape((m</span><span class="s3">, </span><span class="s1">k)</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s1">V = w[iV-</span><span class="s5">1</span><span class="s1">:iV+n*k-</span><span class="s5">1</span><span class="s1">].reshape((n</span><span class="s3">, </span><span class="s1">k)</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s1">S = w[iS-</span><span class="s5">1</span><span class="s1">:iS+k-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s3">return </span><span class="s1">U</span><span class="s3">, </span><span class="s1">V</span><span class="s3">, </span><span class="s1">S</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># iddp_aid.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">iddp_aid(eps</span><span class="s3">, </span><span class="s1">A):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute ID of a real matrix to a specified relative precision using random 
    sampling. 
 
    :param eps: 
        Relative precision. 
    :type eps: float 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
 
    :return: 
        Rank of ID. 
    :rtype: int 
    :return: 
        Column index array. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Interpolation coefficients. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A = np.asfortranarray(A)</span>
    <span class="s1">m</span><span class="s3">, </span><span class="s1">n = A.shape</span>
    <span class="s1">n2</span><span class="s3">, </span><span class="s1">w = idd_frmi(m)</span>
    <span class="s1">proj = np.empty(n*(</span><span class="s5">2</span><span class="s1">*n2 + </span><span class="s5">1</span><span class="s1">) + n2 + </span><span class="s5">1</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s1">k</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">proj = _id.iddp_aid(eps</span><span class="s3">, </span><span class="s1">A</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">proj)</span>
    <span class="s1">proj = proj[:k*(n-k)].reshape((k</span><span class="s3">, </span><span class="s1">n-k)</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">k</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">proj</span>


<span class="s3">def </span><span class="s1">idd_estrank(eps</span><span class="s3">, </span><span class="s1">A):</span>
    <span class="s2">&quot;&quot;&quot; 
    Estimate rank of a real matrix to a specified relative precision using 
    random sampling. 
 
    The output rank is typically about 8 higher than the actual rank. 
 
    :param eps: 
        Relative precision. 
    :type eps: float 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
 
    :return: 
        Rank estimate. 
    :rtype: int 
    &quot;&quot;&quot;</span>
    <span class="s1">A = np.asfortranarray(A)</span>
    <span class="s1">m</span><span class="s3">, </span><span class="s1">n = A.shape</span>
    <span class="s1">n2</span><span class="s3">, </span><span class="s1">w = idd_frmi(m)</span>
    <span class="s1">ra = np.empty(n*n2 + (n + </span><span class="s5">1</span><span class="s1">)*(n2 + </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s1">k</span><span class="s3">, </span><span class="s1">ra = _id.idd_estrank(eps</span><span class="s3">, </span><span class="s1">A</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">ra)</span>
    <span class="s3">return </span><span class="s1">k</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># iddp_asvd.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">iddp_asvd(eps</span><span class="s3">, </span><span class="s1">A):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute SVD of a real matrix to a specified relative precision using random 
    sampling. 
 
    :param eps: 
        Relative precision. 
    :type eps: float 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
 
    :return: 
        Left singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Right singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Singular values. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A = np.asfortranarray(A)</span>
    <span class="s1">m</span><span class="s3">, </span><span class="s1">n = A.shape</span>
    <span class="s1">n2</span><span class="s3">, </span><span class="s1">winit = _id.idd_frmi(m)</span>
    <span class="s1">w = np.empty(</span>
        <span class="s1">max((min(m</span><span class="s3">, </span><span class="s1">n) + </span><span class="s5">1</span><span class="s1">)*(</span><span class="s5">3</span><span class="s1">*m + </span><span class="s5">5</span><span class="s1">*n + </span><span class="s5">1</span><span class="s1">) + </span><span class="s5">25</span><span class="s1">*min(m</span><span class="s3">, </span><span class="s1">n)**</span><span class="s5">2</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s5">2</span><span class="s1">*n + </span><span class="s5">1</span><span class="s1">)*(n2 + </span><span class="s5">1</span><span class="s1">))</span><span class="s3">,</span>
        <span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s1">k</span><span class="s3">, </span><span class="s1">iU</span><span class="s3">, </span><span class="s1">iV</span><span class="s3">, </span><span class="s1">iS</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">ier = _id.iddp_asvd(eps</span><span class="s3">, </span><span class="s1">A</span><span class="s3">, </span><span class="s1">winit</span><span class="s3">, </span><span class="s1">w)</span>
    <span class="s3">if </span><span class="s1">ier:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s1">U = w[iU-</span><span class="s5">1</span><span class="s1">:iU+m*k-</span><span class="s5">1</span><span class="s1">].reshape((m</span><span class="s3">, </span><span class="s1">k)</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s1">V = w[iV-</span><span class="s5">1</span><span class="s1">:iV+n*k-</span><span class="s5">1</span><span class="s1">].reshape((n</span><span class="s3">, </span><span class="s1">k)</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s1">S = w[iS-</span><span class="s5">1</span><span class="s1">:iS+k-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s3">return </span><span class="s1">U</span><span class="s3">, </span><span class="s1">V</span><span class="s3">, </span><span class="s1">S</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># iddp_rid.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">iddp_rid(eps</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">matvect):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute ID of a real matrix to a specified relative precision using random 
    matrix-vector multiplication. 
 
    :param eps: 
        Relative precision. 
    :type eps: float 
    :param m: 
        Matrix row dimension. 
    :type m: int 
    :param n: 
        Matrix column dimension. 
    :type n: int 
    :param matvect: 
        Function to apply the matrix transpose to a vector, with call signature 
        `y = matvect(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matvect: function 
 
    :return: 
        Rank of ID. 
    :rtype: int 
    :return: 
        Column index array. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Interpolation coefficients. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">proj = np.empty(m + </span><span class="s5">1 </span><span class="s1">+ </span><span class="s5">2</span><span class="s1">*n*(min(m</span><span class="s3">, </span><span class="s1">n) + </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s1">k</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">proj</span><span class="s3">, </span><span class="s1">ier = _id.iddp_rid(eps</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">matvect</span><span class="s3">, </span><span class="s1">proj)</span>
    <span class="s3">if </span><span class="s1">ier != </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s1">proj = proj[:k*(n-k)].reshape((k</span><span class="s3">, </span><span class="s1">n-k)</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">k</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">proj</span>


<span class="s3">def </span><span class="s1">idd_findrank(eps</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">matvect):</span>
    <span class="s2">&quot;&quot;&quot; 
    Estimate rank of a real matrix to a specified relative precision using 
    random matrix-vector multiplication. 
 
    :param eps: 
        Relative precision. 
    :type eps: float 
    :param m: 
        Matrix row dimension. 
    :type m: int 
    :param n: 
        Matrix column dimension. 
    :type n: int 
    :param matvect: 
        Function to apply the matrix transpose to a vector, with call signature 
        `y = matvect(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matvect: function 
 
    :return: 
        Rank estimate. 
    :rtype: int 
    &quot;&quot;&quot;</span>
    <span class="s1">k</span><span class="s3">, </span><span class="s1">ra</span><span class="s3">, </span><span class="s1">ier = _id.idd_findrank(eps</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">matvect)</span>
    <span class="s3">if </span><span class="s1">ier:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s3">return </span><span class="s1">k</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># iddp_rsvd.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">iddp_rsvd(eps</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">matvect</span><span class="s3">, </span><span class="s1">matvec):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute SVD of a real matrix to a specified relative precision using random 
    matrix-vector multiplication. 
 
    :param eps: 
        Relative precision. 
    :type eps: float 
    :param m: 
        Matrix row dimension. 
    :type m: int 
    :param n: 
        Matrix column dimension. 
    :type n: int 
    :param matvect: 
        Function to apply the matrix transpose to a vector, with call signature 
        `y = matvect(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matvect: function 
    :param matvec: 
        Function to apply the matrix to a vector, with call signature 
        `y = matvec(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matvec: function 
 
    :return: 
        Left singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Right singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Singular values. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">k</span><span class="s3">, </span><span class="s1">iU</span><span class="s3">, </span><span class="s1">iV</span><span class="s3">, </span><span class="s1">iS</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">ier = _id.iddp_rsvd(eps</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">matvect</span><span class="s3">, </span><span class="s1">matvec)</span>
    <span class="s3">if </span><span class="s1">ier:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s1">U = w[iU-</span><span class="s5">1</span><span class="s1">:iU+m*k-</span><span class="s5">1</span><span class="s1">].reshape((m</span><span class="s3">, </span><span class="s1">k)</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s1">V = w[iV-</span><span class="s5">1</span><span class="s1">:iV+n*k-</span><span class="s5">1</span><span class="s1">].reshape((n</span><span class="s3">, </span><span class="s1">k)</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s1">S = w[iS-</span><span class="s5">1</span><span class="s1">:iS+k-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s3">return </span><span class="s1">U</span><span class="s3">, </span><span class="s1">V</span><span class="s3">, </span><span class="s1">S</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># iddr_aid.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">iddr_aid(A</span><span class="s3">, </span><span class="s1">k):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute ID of a real matrix to a specified rank using random sampling. 
 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
    :param k: 
        Rank of ID. 
    :type k: int 
 
    :return: 
        Column index array. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Interpolation coefficients. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A = np.asfortranarray(A)</span>
    <span class="s1">m</span><span class="s3">, </span><span class="s1">n = A.shape</span>
    <span class="s1">w = iddr_aidi(m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">k)</span>
    <span class="s1">idx</span><span class="s3">, </span><span class="s1">proj = _id.iddr_aid(A</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">w)</span>
    <span class="s3">if </span><span class="s1">k == n:</span>
        <span class="s1">proj = np.empty((k</span><span class="s3">, </span><span class="s1">n-k)</span><span class="s3">, </span><span class="s1">dtype=</span><span class="s4">'float64'</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">proj = proj.reshape((k</span><span class="s3">, </span><span class="s1">n-k)</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">proj</span>


<span class="s3">def </span><span class="s1">iddr_aidi(m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">k):</span>
    <span class="s2">&quot;&quot;&quot; 
    Initialize array for :func:`iddr_aid`. 
 
    :param m: 
        Matrix row dimension. 
    :type m: int 
    :param n: 
        Matrix column dimension. 
    :type n: int 
    :param k: 
        Rank of ID. 
    :type k: int 
 
    :return: 
        Initialization array to be used by :func:`iddr_aid`. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_id.iddr_aidi(m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">k)</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># iddr_asvd.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">iddr_asvd(A</span><span class="s3">, </span><span class="s1">k):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute SVD of a real matrix to a specified rank using random sampling. 
 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
    :param k: 
        Rank of SVD. 
    :type k: int 
 
    :return: 
        Left singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Right singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Singular values. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A = np.asfortranarray(A)</span>
    <span class="s1">m</span><span class="s3">, </span><span class="s1">n = A.shape</span>
    <span class="s1">w = np.empty((</span><span class="s5">2</span><span class="s1">*k + </span><span class="s5">28</span><span class="s1">)*m + (</span><span class="s5">6</span><span class="s1">*k + </span><span class="s5">21</span><span class="s1">)*n + </span><span class="s5">25</span><span class="s1">*k**</span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">100</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s1">w_ = iddr_aidi(m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">k)</span>
    <span class="s1">w[:w_.size] = w_</span>
    <span class="s1">U</span><span class="s3">, </span><span class="s1">V</span><span class="s3">, </span><span class="s1">S</span><span class="s3">, </span><span class="s1">ier = _id.iddr_asvd(A</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">w)</span>
    <span class="s3">if </span><span class="s1">ier != </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s3">return </span><span class="s1">U</span><span class="s3">, </span><span class="s1">V</span><span class="s3">, </span><span class="s1">S</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># iddr_rid.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">iddr_rid(m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">matvect</span><span class="s3">, </span><span class="s1">k):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute ID of a real matrix to a specified rank using random matrix-vector 
    multiplication. 
 
    :param m: 
        Matrix row dimension. 
    :type m: int 
    :param n: 
        Matrix column dimension. 
    :type n: int 
    :param matvect: 
        Function to apply the matrix transpose to a vector, with call signature 
        `y = matvect(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matvect: function 
    :param k: 
        Rank of ID. 
    :type k: int 
 
    :return: 
        Column index array. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Interpolation coefficients. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">idx</span><span class="s3">, </span><span class="s1">proj = _id.iddr_rid(m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">matvect</span><span class="s3">, </span><span class="s1">k)</span>
    <span class="s1">proj = proj[:k*(n-k)].reshape((k</span><span class="s3">, </span><span class="s1">n-k)</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">proj</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># iddr_rsvd.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">iddr_rsvd(m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">matvect</span><span class="s3">, </span><span class="s1">matvec</span><span class="s3">, </span><span class="s1">k):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute SVD of a real matrix to a specified rank using random matrix-vector 
    multiplication. 
 
    :param m: 
        Matrix row dimension. 
    :type m: int 
    :param n: 
        Matrix column dimension. 
    :type n: int 
    :param matvect: 
        Function to apply the matrix transpose to a vector, with call signature 
        `y = matvect(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matvect: function 
    :param matvec: 
        Function to apply the matrix to a vector, with call signature 
        `y = matvec(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matvec: function 
    :param k: 
        Rank of SVD. 
    :type k: int 
 
    :return: 
        Left singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Right singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Singular values. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">U</span><span class="s3">, </span><span class="s1">V</span><span class="s3">, </span><span class="s1">S</span><span class="s3">, </span><span class="s1">ier = _id.iddr_rsvd(m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">matvect</span><span class="s3">, </span><span class="s1">matvec</span><span class="s3">, </span><span class="s1">k)</span>
    <span class="s3">if </span><span class="s1">ier != </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s3">return </span><span class="s1">U</span><span class="s3">, </span><span class="s1">V</span><span class="s3">, </span><span class="s1">S</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idz_frm.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">idz_frm(n</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">x):</span>
    <span class="s2">&quot;&quot;&quot; 
    Transform complex vector via a composition of Rokhlin's random transform, 
    random subselection, and an FFT. 
 
    In contrast to :func:`idz_sfrm`, this routine works best when the length of 
    the transformed vector is the power-of-two integer output by 
    :func:`idz_frmi`, or when the length is not specified but instead 
    determined a posteriori from the output. The returned transformed vector is 
    randomly permuted. 
 
    :param n: 
        Greatest power-of-two integer satisfying `n &lt;= x.size` as obtained from 
        :func:`idz_frmi`; `n` is also the length of the output vector. 
    :type n: int 
    :param w: 
        Initialization array constructed by :func:`idz_frmi`. 
    :type w: :class:`numpy.ndarray` 
    :param x: 
        Vector to be transformed. 
    :type x: :class:`numpy.ndarray` 
 
    :return: 
        Transformed vector. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_id.idz_frm(n</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">x)</span>


<span class="s3">def </span><span class="s1">idz_sfrm(l</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">x):</span>
    <span class="s2">&quot;&quot;&quot; 
    Transform complex vector via a composition of Rokhlin's random transform, 
    random subselection, and an FFT. 
 
    In contrast to :func:`idz_frm`, this routine works best when the length of 
    the transformed vector is known a priori. 
 
    :param l: 
        Length of transformed vector, satisfying `l &lt;= n`. 
    :type l: int 
    :param n: 
        Greatest power-of-two integer satisfying `n &lt;= x.size` as obtained from 
        :func:`idz_sfrmi`. 
    :type n: int 
    :param w: 
        Initialization array constructed by :func:`idd_sfrmi`. 
    :type w: :class:`numpy.ndarray` 
    :param x: 
        Vector to be transformed. 
    :type x: :class:`numpy.ndarray` 
 
    :return: 
        Transformed vector. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_id.idz_sfrm(l</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">x)</span>


<span class="s3">def </span><span class="s1">idz_frmi(m):</span>
    <span class="s2">&quot;&quot;&quot; 
    Initialize data for :func:`idz_frm`. 
 
    :param m: 
        Length of vector to be transformed. 
    :type m: int 
 
    :return: 
        Greatest power-of-two integer `n` satisfying `n &lt;= m`. 
    :rtype: int 
    :return: 
        Initialization array to be used by :func:`idz_frm`. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_id.idz_frmi(m)</span>


<span class="s3">def </span><span class="s1">idz_sfrmi(l</span><span class="s3">, </span><span class="s1">m):</span>
    <span class="s2">&quot;&quot;&quot; 
    Initialize data for :func:`idz_sfrm`. 
 
    :param l: 
        Length of output transformed vector. 
    :type l: int 
    :param m: 
        Length of the vector to be transformed. 
    :type m: int 
 
    :return: 
        Greatest power-of-two integer `n` satisfying `n &lt;= m`. 
    :rtype: int 
    :return: 
        Initialization array to be used by :func:`idz_sfrm`. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_id.idz_sfrmi(l</span><span class="s3">, </span><span class="s1">m)</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idz_id.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">idzp_id(eps</span><span class="s3">, </span><span class="s1">A):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute ID of a complex matrix to a specified relative precision. 
 
    :param eps: 
        Relative precision. 
    :type eps: float 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
 
    :return: 
        Rank of ID. 
    :rtype: int 
    :return: 
        Column index array. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Interpolation coefficients. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A = _asfortranarray_copy(A)</span>
    <span class="s1">k</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">rnorms = _id.idzp_id(eps</span><span class="s3">, </span><span class="s1">A)</span>
    <span class="s1">n = A.shape[</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">proj = A.T.ravel()[:k*(n-k)].reshape((k</span><span class="s3">, </span><span class="s1">n-k)</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">k</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">proj</span>


<span class="s3">def </span><span class="s1">idzr_id(A</span><span class="s3">, </span><span class="s1">k):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute ID of a complex matrix to a specified rank. 
 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
    :param k: 
        Rank of ID. 
    :type k: int 
 
    :return: 
        Column index array. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Interpolation coefficients. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A = _asfortranarray_copy(A)</span>
    <span class="s1">idx</span><span class="s3">, </span><span class="s1">rnorms = _id.idzr_id(A</span><span class="s3">, </span><span class="s1">k)</span>
    <span class="s1">n = A.shape[</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">proj = A.T.ravel()[:k*(n-k)].reshape((k</span><span class="s3">, </span><span class="s1">n-k)</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">proj</span>


<span class="s3">def </span><span class="s1">idz_reconid(B</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">proj):</span>
    <span class="s2">&quot;&quot;&quot; 
    Reconstruct matrix from complex ID. 
 
    :param B: 
        Skeleton matrix. 
    :type B: :class:`numpy.ndarray` 
    :param idx: 
        Column index array. 
    :type idx: :class:`numpy.ndarray` 
    :param proj: 
        Interpolation coefficients. 
    :type proj: :class:`numpy.ndarray` 
 
    :return: 
        Reconstructed matrix. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">B = np.asfortranarray(B)</span>
    <span class="s3">if </span><span class="s1">proj.size &gt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">_id.idz_reconid(B</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">proj)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">B[:</span><span class="s3">, </span><span class="s1">np.argsort(idx)]</span>


<span class="s3">def </span><span class="s1">idz_reconint(idx</span><span class="s3">, </span><span class="s1">proj):</span>
    <span class="s2">&quot;&quot;&quot; 
    Reconstruct interpolation matrix from complex ID. 
 
    :param idx: 
        Column index array. 
    :type idx: :class:`numpy.ndarray` 
    :param proj: 
        Interpolation coefficients. 
    :type proj: :class:`numpy.ndarray` 
 
    :return: 
        Interpolation matrix. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_id.idz_reconint(idx</span><span class="s3">, </span><span class="s1">proj)</span>


<span class="s3">def </span><span class="s1">idz_copycols(A</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">idx):</span>
    <span class="s2">&quot;&quot;&quot; 
    Reconstruct skeleton matrix from complex ID. 
 
    :param A: 
        Original matrix. 
    :type A: :class:`numpy.ndarray` 
    :param k: 
        Rank of ID. 
    :type k: int 
    :param idx: 
        Column index array. 
    :type idx: :class:`numpy.ndarray` 
 
    :return: 
        Skeleton matrix. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A = np.asfortranarray(A)</span>
    <span class="s3">return </span><span class="s1">_id.idz_copycols(A</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">idx)</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idz_id2svd.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">idz_id2svd(B</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">proj):</span>
    <span class="s2">&quot;&quot;&quot; 
    Convert complex ID to SVD. 
 
    :param B: 
        Skeleton matrix. 
    :type B: :class:`numpy.ndarray` 
    :param idx: 
        Column index array. 
    :type idx: :class:`numpy.ndarray` 
    :param proj: 
        Interpolation coefficients. 
    :type proj: :class:`numpy.ndarray` 
 
    :return: 
        Left singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Right singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Singular values. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">B = np.asfortranarray(B)</span>
    <span class="s1">U</span><span class="s3">, </span><span class="s1">V</span><span class="s3">, </span><span class="s1">S</span><span class="s3">, </span><span class="s1">ier = _id.idz_id2svd(B</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">proj)</span>
    <span class="s3">if </span><span class="s1">ier:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s3">return </span><span class="s1">U</span><span class="s3">, </span><span class="s1">V</span><span class="s3">, </span><span class="s1">S</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idz_snorm.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">idz_snorm(m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">matveca</span><span class="s3">, </span><span class="s1">matvec</span><span class="s3">, </span><span class="s1">its=</span><span class="s5">20</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Estimate spectral norm of a complex matrix by the randomized power method. 
 
    :param m: 
        Matrix row dimension. 
    :type m: int 
    :param n: 
        Matrix column dimension. 
    :type n: int 
    :param matveca: 
        Function to apply the matrix adjoint to a vector, with call signature 
        `y = matveca(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matveca: function 
    :param matvec: 
        Function to apply the matrix to a vector, with call signature 
        `y = matvec(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matvec: function 
    :param its: 
        Number of power method iterations. 
    :type its: int 
 
    :return: 
        Spectral norm estimate. 
    :rtype: float 
    &quot;&quot;&quot;</span>
    <span class="s1">snorm</span><span class="s3">, </span><span class="s1">v = _id.idz_snorm(m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">matveca</span><span class="s3">, </span><span class="s1">matvec</span><span class="s3">, </span><span class="s1">its)</span>
    <span class="s3">return </span><span class="s1">snorm</span>


<span class="s3">def </span><span class="s1">idz_diffsnorm(m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">matveca</span><span class="s3">, </span><span class="s1">matveca2</span><span class="s3">, </span><span class="s1">matvec</span><span class="s3">, </span><span class="s1">matvec2</span><span class="s3">, </span><span class="s1">its=</span><span class="s5">20</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Estimate spectral norm of the difference of two complex matrices by the 
    randomized power method. 
 
    :param m: 
        Matrix row dimension. 
    :type m: int 
    :param n: 
        Matrix column dimension. 
    :type n: int 
    :param matveca: 
        Function to apply the adjoint of the first matrix to a vector, with 
        call signature `y = matveca(x)`, where `x` and `y` are the input and 
        output vectors, respectively. 
    :type matveca: function 
    :param matveca2: 
        Function to apply the adjoint of the second matrix to a vector, with 
        call signature `y = matveca2(x)`, where `x` and `y` are the input and 
        output vectors, respectively. 
    :type matveca2: function 
    :param matvec: 
        Function to apply the first matrix to a vector, with call signature 
        `y = matvec(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matvec: function 
    :param matvec2: 
        Function to apply the second matrix to a vector, with call signature 
        `y = matvec2(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matvec2: function 
    :param its: 
        Number of power method iterations. 
    :type its: int 
 
    :return: 
        Spectral norm estimate of matrix difference. 
    :rtype: float 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_id.idz_diffsnorm(m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">matveca</span><span class="s3">, </span><span class="s1">matveca2</span><span class="s3">, </span><span class="s1">matvec</span><span class="s3">, </span><span class="s1">matvec2</span><span class="s3">, </span><span class="s1">its)</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idz_svd.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">idzr_svd(A</span><span class="s3">, </span><span class="s1">k):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute SVD of a complex matrix to a specified rank. 
 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
    :param k: 
        Rank of SVD. 
    :type k: int 
 
    :return: 
        Left singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Right singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Singular values. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A = np.asfortranarray(A)</span>
    <span class="s1">U</span><span class="s3">, </span><span class="s1">V</span><span class="s3">, </span><span class="s1">S</span><span class="s3">, </span><span class="s1">ier = _id.idzr_svd(A</span><span class="s3">, </span><span class="s1">k)</span>
    <span class="s3">if </span><span class="s1">ier:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s3">return </span><span class="s1">U</span><span class="s3">, </span><span class="s1">V</span><span class="s3">, </span><span class="s1">S</span>


<span class="s3">def </span><span class="s1">idzp_svd(eps</span><span class="s3">, </span><span class="s1">A):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute SVD of a complex matrix to a specified relative precision. 
 
    :param eps: 
        Relative precision. 
    :type eps: float 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
 
    :return: 
        Left singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Right singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Singular values. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A = np.asfortranarray(A)</span>
    <span class="s1">m</span><span class="s3">, </span><span class="s1">n = A.shape</span>
    <span class="s1">k</span><span class="s3">, </span><span class="s1">iU</span><span class="s3">, </span><span class="s1">iV</span><span class="s3">, </span><span class="s1">iS</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">ier = _id.idzp_svd(eps</span><span class="s3">, </span><span class="s1">A)</span>
    <span class="s3">if </span><span class="s1">ier:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s1">U = w[iU-</span><span class="s5">1</span><span class="s1">:iU+m*k-</span><span class="s5">1</span><span class="s1">].reshape((m</span><span class="s3">, </span><span class="s1">k)</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s1">V = w[iV-</span><span class="s5">1</span><span class="s1">:iV+n*k-</span><span class="s5">1</span><span class="s1">].reshape((n</span><span class="s3">, </span><span class="s1">k)</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s1">S = w[iS-</span><span class="s5">1</span><span class="s1">:iS+k-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s3">return </span><span class="s1">U</span><span class="s3">, </span><span class="s1">V</span><span class="s3">, </span><span class="s1">S</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idzp_aid.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">idzp_aid(eps</span><span class="s3">, </span><span class="s1">A):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute ID of a complex matrix to a specified relative precision using 
    random sampling. 
 
    :param eps: 
        Relative precision. 
    :type eps: float 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
 
    :return: 
        Rank of ID. 
    :rtype: int 
    :return: 
        Column index array. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Interpolation coefficients. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A = np.asfortranarray(A)</span>
    <span class="s1">m</span><span class="s3">, </span><span class="s1">n = A.shape</span>
    <span class="s1">n2</span><span class="s3">, </span><span class="s1">w = idz_frmi(m)</span>
    <span class="s1">proj = np.empty(n*(</span><span class="s5">2</span><span class="s1">*n2 + </span><span class="s5">1</span><span class="s1">) + n2 + </span><span class="s5">1</span><span class="s3">, </span><span class="s1">dtype=</span><span class="s4">'complex128'</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s1">k</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">proj = _id.idzp_aid(eps</span><span class="s3">, </span><span class="s1">A</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">proj)</span>
    <span class="s1">proj = proj[:k*(n-k)].reshape((k</span><span class="s3">, </span><span class="s1">n-k)</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">k</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">proj</span>


<span class="s3">def </span><span class="s1">idz_estrank(eps</span><span class="s3">, </span><span class="s1">A):</span>
    <span class="s2">&quot;&quot;&quot; 
    Estimate rank of a complex matrix to a specified relative precision using 
    random sampling. 
 
    The output rank is typically about 8 higher than the actual rank. 
 
    :param eps: 
        Relative precision. 
    :type eps: float 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
 
    :return: 
        Rank estimate. 
    :rtype: int 
    &quot;&quot;&quot;</span>
    <span class="s1">A = np.asfortranarray(A)</span>
    <span class="s1">m</span><span class="s3">, </span><span class="s1">n = A.shape</span>
    <span class="s1">n2</span><span class="s3">, </span><span class="s1">w = idz_frmi(m)</span>
    <span class="s1">ra = np.empty(n*n2 + (n + </span><span class="s5">1</span><span class="s1">)*(n2 + </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">dtype=</span><span class="s4">'complex128'</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s1">k</span><span class="s3">, </span><span class="s1">ra = _id.idz_estrank(eps</span><span class="s3">, </span><span class="s1">A</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">ra)</span>
    <span class="s3">return </span><span class="s1">k</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idzp_asvd.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">idzp_asvd(eps</span><span class="s3">, </span><span class="s1">A):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute SVD of a complex matrix to a specified relative precision using 
    random sampling. 
 
    :param eps: 
        Relative precision. 
    :type eps: float 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
 
    :return: 
        Left singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Right singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Singular values. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A = np.asfortranarray(A)</span>
    <span class="s1">m</span><span class="s3">, </span><span class="s1">n = A.shape</span>
    <span class="s1">n2</span><span class="s3">, </span><span class="s1">winit = _id.idz_frmi(m)</span>
    <span class="s1">w = np.empty(</span>
        <span class="s1">max((min(m</span><span class="s3">, </span><span class="s1">n) + </span><span class="s5">1</span><span class="s1">)*(</span><span class="s5">3</span><span class="s1">*m + </span><span class="s5">5</span><span class="s1">*n + </span><span class="s5">11</span><span class="s1">) + </span><span class="s5">8</span><span class="s1">*min(m</span><span class="s3">, </span><span class="s1">n)**</span><span class="s5">2</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s5">2</span><span class="s1">*n + </span><span class="s5">1</span><span class="s1">)*(n2 + </span><span class="s5">1</span><span class="s1">))</span><span class="s3">,</span>
        <span class="s1">dtype=np.complex128</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s1">k</span><span class="s3">, </span><span class="s1">iU</span><span class="s3">, </span><span class="s1">iV</span><span class="s3">, </span><span class="s1">iS</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">ier = _id.idzp_asvd(eps</span><span class="s3">, </span><span class="s1">A</span><span class="s3">, </span><span class="s1">winit</span><span class="s3">, </span><span class="s1">w)</span>
    <span class="s3">if </span><span class="s1">ier:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s1">U = w[iU-</span><span class="s5">1</span><span class="s1">:iU+m*k-</span><span class="s5">1</span><span class="s1">].reshape((m</span><span class="s3">, </span><span class="s1">k)</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s1">V = w[iV-</span><span class="s5">1</span><span class="s1">:iV+n*k-</span><span class="s5">1</span><span class="s1">].reshape((n</span><span class="s3">, </span><span class="s1">k)</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s1">S = w[iS-</span><span class="s5">1</span><span class="s1">:iS+k-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s3">return </span><span class="s1">U</span><span class="s3">, </span><span class="s1">V</span><span class="s3">, </span><span class="s1">S</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idzp_rid.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">idzp_rid(eps</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">matveca):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute ID of a complex matrix to a specified relative precision using 
    random matrix-vector multiplication. 
 
    :param eps: 
        Relative precision. 
    :type eps: float 
    :param m: 
        Matrix row dimension. 
    :type m: int 
    :param n: 
        Matrix column dimension. 
    :type n: int 
    :param matveca: 
        Function to apply the matrix adjoint to a vector, with call signature 
        `y = matveca(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matveca: function 
 
    :return: 
        Rank of ID. 
    :rtype: int 
    :return: 
        Column index array. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Interpolation coefficients. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">proj = np.empty(</span>
        <span class="s1">m + </span><span class="s5">1 </span><span class="s1">+ </span><span class="s5">2</span><span class="s1">*n*(min(m</span><span class="s3">, </span><span class="s1">n) + </span><span class="s5">1</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">dtype=np.complex128</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s1">k</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">proj</span><span class="s3">, </span><span class="s1">ier = _id.idzp_rid(eps</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">matveca</span><span class="s3">, </span><span class="s1">proj)</span>
    <span class="s3">if </span><span class="s1">ier:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s1">proj = proj[:k*(n-k)].reshape((k</span><span class="s3">, </span><span class="s1">n-k)</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">k</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">proj</span>


<span class="s3">def </span><span class="s1">idz_findrank(eps</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">matveca):</span>
    <span class="s2">&quot;&quot;&quot; 
    Estimate rank of a complex matrix to a specified relative precision using 
    random matrix-vector multiplication. 
 
    :param eps: 
        Relative precision. 
    :type eps: float 
    :param m: 
        Matrix row dimension. 
    :type m: int 
    :param n: 
        Matrix column dimension. 
    :type n: int 
    :param matveca: 
        Function to apply the matrix adjoint to a vector, with call signature 
        `y = matveca(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matveca: function 
 
    :return: 
        Rank estimate. 
    :rtype: int 
    &quot;&quot;&quot;</span>
    <span class="s1">k</span><span class="s3">, </span><span class="s1">ra</span><span class="s3">, </span><span class="s1">ier = _id.idz_findrank(eps</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">matveca)</span>
    <span class="s3">if </span><span class="s1">ier:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s3">return </span><span class="s1">k</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idzp_rsvd.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">idzp_rsvd(eps</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">matveca</span><span class="s3">, </span><span class="s1">matvec):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute SVD of a complex matrix to a specified relative precision using 
    random matrix-vector multiplication. 
 
    :param eps: 
        Relative precision. 
    :type eps: float 
    :param m: 
        Matrix row dimension. 
    :type m: int 
    :param n: 
        Matrix column dimension. 
    :type n: int 
    :param matveca: 
        Function to apply the matrix adjoint to a vector, with call signature 
        `y = matveca(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matveca: function 
    :param matvec: 
        Function to apply the matrix to a vector, with call signature 
        `y = matvec(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matvec: function 
 
    :return: 
        Left singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Right singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Singular values. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">k</span><span class="s3">, </span><span class="s1">iU</span><span class="s3">, </span><span class="s1">iV</span><span class="s3">, </span><span class="s1">iS</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">ier = _id.idzp_rsvd(eps</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">matveca</span><span class="s3">, </span><span class="s1">matvec)</span>
    <span class="s3">if </span><span class="s1">ier:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s1">U = w[iU-</span><span class="s5">1</span><span class="s1">:iU+m*k-</span><span class="s5">1</span><span class="s1">].reshape((m</span><span class="s3">, </span><span class="s1">k)</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s1">V = w[iV-</span><span class="s5">1</span><span class="s1">:iV+n*k-</span><span class="s5">1</span><span class="s1">].reshape((n</span><span class="s3">, </span><span class="s1">k)</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s1">S = w[iS-</span><span class="s5">1</span><span class="s1">:iS+k-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s3">return </span><span class="s1">U</span><span class="s3">, </span><span class="s1">V</span><span class="s3">, </span><span class="s1">S</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idzr_aid.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">idzr_aid(A</span><span class="s3">, </span><span class="s1">k):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute ID of a complex matrix to a specified rank using random sampling. 
 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
    :param k: 
        Rank of ID. 
    :type k: int 
 
    :return: 
        Column index array. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Interpolation coefficients. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A = np.asfortranarray(A)</span>
    <span class="s1">m</span><span class="s3">, </span><span class="s1">n = A.shape</span>
    <span class="s1">w = idzr_aidi(m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">k)</span>
    <span class="s1">idx</span><span class="s3">, </span><span class="s1">proj = _id.idzr_aid(A</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">w)</span>
    <span class="s3">if </span><span class="s1">k == n:</span>
        <span class="s1">proj = np.empty((k</span><span class="s3">, </span><span class="s1">n-k)</span><span class="s3">, </span><span class="s1">dtype=</span><span class="s4">'complex128'</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">proj = proj.reshape((k</span><span class="s3">, </span><span class="s1">n-k)</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">proj</span>


<span class="s3">def </span><span class="s1">idzr_aidi(m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">k):</span>
    <span class="s2">&quot;&quot;&quot; 
    Initialize array for :func:`idzr_aid`. 
 
    :param m: 
        Matrix row dimension. 
    :type m: int 
    :param n: 
        Matrix column dimension. 
    :type n: int 
    :param k: 
        Rank of ID. 
    :type k: int 
 
    :return: 
        Initialization array to be used by :func:`idzr_aid`. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_id.idzr_aidi(m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">k)</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idzr_asvd.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">idzr_asvd(A</span><span class="s3">, </span><span class="s1">k):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute SVD of a complex matrix to a specified rank using random sampling. 
 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
    :param k: 
        Rank of SVD. 
    :type k: int 
 
    :return: 
        Left singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Right singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Singular values. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A = np.asfortranarray(A)</span>
    <span class="s1">m</span><span class="s3">, </span><span class="s1">n = A.shape</span>
    <span class="s1">w = np.empty(</span>
        <span class="s1">(</span><span class="s5">2</span><span class="s1">*k + </span><span class="s5">22</span><span class="s1">)*m + (</span><span class="s5">6</span><span class="s1">*k + </span><span class="s5">21</span><span class="s1">)*n + </span><span class="s5">8</span><span class="s1">*k**</span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">10</span><span class="s1">*k + </span><span class="s5">90</span><span class="s3">,</span>
        <span class="s1">dtype=</span><span class="s4">'complex128'</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s1">w_ = idzr_aidi(m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">k)</span>
    <span class="s1">w[:w_.size] = w_</span>
    <span class="s1">U</span><span class="s3">, </span><span class="s1">V</span><span class="s3">, </span><span class="s1">S</span><span class="s3">, </span><span class="s1">ier = _id.idzr_asvd(A</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">w)</span>
    <span class="s3">if </span><span class="s1">ier:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s3">return </span><span class="s1">U</span><span class="s3">, </span><span class="s1">V</span><span class="s3">, </span><span class="s1">S</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idzr_rid.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">idzr_rid(m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">matveca</span><span class="s3">, </span><span class="s1">k):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute ID of a complex matrix to a specified rank using random 
    matrix-vector multiplication. 
 
    :param m: 
        Matrix row dimension. 
    :type m: int 
    :param n: 
        Matrix column dimension. 
    :type n: int 
    :param matveca: 
        Function to apply the matrix adjoint to a vector, with call signature 
        `y = matveca(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matveca: function 
    :param k: 
        Rank of ID. 
    :type k: int 
 
    :return: 
        Column index array. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Interpolation coefficients. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">idx</span><span class="s3">, </span><span class="s1">proj = _id.idzr_rid(m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">matveca</span><span class="s3">, </span><span class="s1">k)</span>
    <span class="s1">proj = proj[:k*(n-k)].reshape((k</span><span class="s3">, </span><span class="s1">n-k)</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">proj</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idzr_rsvd.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">idzr_rsvd(m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">matveca</span><span class="s3">, </span><span class="s1">matvec</span><span class="s3">, </span><span class="s1">k):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute SVD of a complex matrix to a specified rank using random 
    matrix-vector multiplication. 
 
    :param m: 
        Matrix row dimension. 
    :type m: int 
    :param n: 
        Matrix column dimension. 
    :type n: int 
    :param matveca: 
        Function to apply the matrix adjoint to a vector, with call signature 
        `y = matveca(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matveca: function 
    :param matvec: 
        Function to apply the matrix to a vector, with call signature 
        `y = matvec(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matvec: function 
    :param k: 
        Rank of SVD. 
    :type k: int 
 
    :return: 
        Left singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Right singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Singular values. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">U</span><span class="s3">, </span><span class="s1">V</span><span class="s3">, </span><span class="s1">S</span><span class="s3">, </span><span class="s1">ier = _id.idzr_rsvd(m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">matveca</span><span class="s3">, </span><span class="s1">matvec</span><span class="s3">, </span><span class="s1">k)</span>
    <span class="s3">if </span><span class="s1">ier:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s3">return </span><span class="s1">U</span><span class="s3">, </span><span class="s1">V</span><span class="s3">, </span><span class="s1">S</span>
</pre>
</body>
</html>