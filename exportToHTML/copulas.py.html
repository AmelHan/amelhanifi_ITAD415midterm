<html>
<head>
<title>copulas.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
copulas.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
 
Which Archimedean is Best? 
Extreme Value copulas formulas are based on Genest 2009 
 
References 
---------- 
 
Genest, C., 2009. Rank-based inference for bivariate extreme-value 
copulas. The Annals of Statistics, 37(5), pp.2990-3022. 
 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">abc </span><span class="s2">import </span><span class="s1">ABC</span><span class="s2">, </span><span class="s1">abstractmethod</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">stats</span>

<span class="s2">from </span><span class="s1">statsmodels.graphics </span><span class="s2">import </span><span class="s1">utils</span>


<span class="s2">class </span><span class="s1">CopulaDistribution:</span>
    <span class="s0">&quot;&quot;&quot;Multivariate copula distribution 
 
    Parameters 
    ---------- 
    copula : str, instance of copula class 
        String name or instance of a copula class 
    marginals : list of distribution instances 
        Marginal distributions. 
    copargs : tuple 
        Parameters for copula 
 
    Notes 
    ----- 
    Status: experimental, argument handling may still change 
 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">copula</span><span class="s2">, </span><span class="s1">marginals</span><span class="s2">, </span><span class="s1">cop_args=()):</span>

        <span class="s1">self.copula = copula</span>

        <span class="s3"># no checking done on marginals</span>
        <span class="s1">self.marginals = marginals</span>
        <span class="s1">self.cop_args = cop_args</span>
        <span class="s1">self.k_vars = len(marginals)</span>

    <span class="s2">def </span><span class="s1">rvs(self</span><span class="s2">, </span><span class="s1">nobs=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">cop_args=</span><span class="s2">None, </span><span class="s1">marg_args=</span><span class="s2">None, </span><span class="s1">random_state=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Draw `n` in the half-open interval ``[0, 1)``. 
 
        Sample the joint distribution. 
 
        Parameters 
        ---------- 
        nobs : int, optional 
            Number of samples to generate in the parameter space. 
            Default is 1. 
        cop_args : tuple 
            Copula parameters. If None, then the copula parameters will be 
            taken from the ``cop_args`` attribute created when initiializing 
            the instance. 
        marg_args : list of tuples 
            Parameters for the marginal distributions. It can be None if none 
            of the marginal distributions have parameters, otherwise it needs 
            to be a list of tuples with the same length has the number of 
            marginal distributions. The list can contain empty tuples for 
            marginal distributions that do not take parameter arguments. 
        random_state : {None, int, numpy.random.Generator}, optional 
            If `seed` is None then the legacy singleton NumPy generator. 
            This will change after 0.13 to use a fresh NumPy ``Generator``, 
            so you should explicitly pass a seeded ``Generator`` if you 
            need reproducible results. 
            If `seed` is an int, a new ``Generator`` instance is used, 
            seeded with `seed`. 
            If `seed` is already a ``Generator`` instance then that instance is 
            used. 
 
        Returns 
        ------- 
        sample : array_like (n, d) 
            Sample from the joint distribution. 
 
        Notes 
        ----- 
        The random samples are generated by creating a sample with uniform 
        margins from the copula, and using ``ppf`` to convert uniform margins 
        to the one specified by the marginal distribution. 
 
        See Also 
        -------- 
        statsmodels.tools.rng_qrng.check_random_state 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">cop_args </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">cop_args = self.cop_args</span>
        <span class="s2">if </span><span class="s1">marg_args </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">marg_args = [()] * self.k_vars</span>

        <span class="s1">sample = self.copula.rvs(nobs=nobs</span><span class="s2">, </span><span class="s1">args=cop_args</span><span class="s2">,</span>
                                 <span class="s1">random_state=random_state)</span>

        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">dist </span><span class="s2">in </span><span class="s1">enumerate(self.marginals):</span>
            <span class="s1">sample[:</span><span class="s2">, </span><span class="s1">i] = dist.ppf(</span><span class="s4">0.5 </span><span class="s1">+ (</span><span class="s4">1 </span><span class="s1">- </span><span class="s4">1e-10</span><span class="s1">) * (sample[:</span><span class="s2">, </span><span class="s1">i] - </span><span class="s4">0.5</span><span class="s1">)</span><span class="s2">,</span>
                                    <span class="s1">*marg_args[i])</span>
        <span class="s2">return </span><span class="s1">sample</span>

    <span class="s2">def </span><span class="s1">cdf(self</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">cop_args=</span><span class="s2">None, </span><span class="s1">marg_args=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;CDF of copula distribution. 
 
        Parameters 
        ---------- 
        y : array_like 
            Values of random variable at which to evaluate cdf. 
            If 2-dimensional, then components of multivariate random variable 
            need to be in columns 
        cop_args : tuple 
            Copula parameters. If None, then the copula parameters will be 
            taken from the ``cop_args`` attribute created when initiializing 
            the instance. 
        marg_args : list of tuples 
            Parameters for the marginal distributions. It can be None if none 
            of the marginal distributions have parameters, otherwise it needs 
            to be a list of tuples with the same length has the number of 
            marginal distributions. The list can contain empty tuples for 
            marginal distributions that do not take parameter arguments. 
 
        Returns 
        ------- 
        cdf values 
 
        &quot;&quot;&quot;</span>
        <span class="s1">y = np.asarray(y)</span>
        <span class="s2">if </span><span class="s1">cop_args </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">cop_args = self.cop_args</span>
        <span class="s2">if </span><span class="s1">marg_args </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">marg_args = [()] * y.shape[-</span><span class="s4">1</span><span class="s1">]</span>

        <span class="s1">cdf_marg = []</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.k_vars):</span>
            <span class="s1">cdf_marg.append(self.marginals[i].cdf(y[...</span><span class="s2">, </span><span class="s1">i]</span><span class="s2">, </span><span class="s1">*marg_args[i]))</span>

        <span class="s1">u = np.column_stack(cdf_marg)</span>
        <span class="s2">if </span><span class="s1">y.ndim == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">u = u.squeeze()</span>
        <span class="s2">return </span><span class="s1">self.copula.cdf(u</span><span class="s2">, </span><span class="s1">cop_args)</span>

    <span class="s2">def </span><span class="s1">pdf(self</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">cop_args=</span><span class="s2">None, </span><span class="s1">marg_args=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;PDF of copula distribution. 
 
        Parameters 
        ---------- 
        y : array_like 
            Values of random variable at which to evaluate cdf. 
            If 2-dimensional, then components of multivariate random variable 
            need to be in columns 
        cop_args : tuple 
            Copula parameters. If None, then the copula parameters will be 
            taken from the ``cop_args`` attribute created when initiializing 
            the instance. 
        marg_args : list of tuples 
            Parameters for the marginal distributions. It can be None if none 
            of the marginal distributions have parameters, otherwise it needs 
            to be a list of tuples with the same length has the number of 
            marginal distributions. The list can contain empty tuples for 
            marginal distributions that do not take parameter arguments. 
 
        Returns 
        ------- 
        pdf values 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">np.exp(self.logpdf(y</span><span class="s2">, </span><span class="s1">cop_args=cop_args</span><span class="s2">, </span><span class="s1">marg_args=marg_args))</span>

    <span class="s2">def </span><span class="s1">logpdf(self</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">cop_args=</span><span class="s2">None, </span><span class="s1">marg_args=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Log-pdf of copula distribution. 
 
        Parameters 
        ---------- 
        y : array_like 
            Values of random variable at which to evaluate cdf. 
            If 2-dimensional, then components of multivariate random variable 
            need to be in columns 
        cop_args : tuple 
            Copula parameters. If None, then the copula parameters will be 
            taken from the ``cop_args`` attribute creating when initiializing 
            the instance. 
        marg_args : list of tuples 
            Parameters for the marginal distributions. It can be None if none 
            of the marginal distributions have parameters, otherwise it needs 
            to be a list of tuples with the same length has the number of 
            marginal distributions. The list can contain empty tuples for 
            marginal distributions that do not take parameter arguments. 
 
        Returns 
        ------- 
        log-pdf values 
 
        &quot;&quot;&quot;</span>
        <span class="s1">y = np.asarray(y)</span>
        <span class="s2">if </span><span class="s1">cop_args </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">cop_args = self.cop_args</span>
        <span class="s2">if </span><span class="s1">marg_args </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">marg_args = tuple([()] * y.shape[-</span><span class="s4">1</span><span class="s1">])</span>

        <span class="s1">lpdf = </span><span class="s4">0.0</span>
        <span class="s1">cdf_marg = []</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.k_vars):</span>
            <span class="s1">lpdf += self.marginals[i].logpdf(y[...</span><span class="s2">, </span><span class="s1">i]</span><span class="s2">, </span><span class="s1">*marg_args[i])</span>
            <span class="s1">cdf_marg.append(self.marginals[i].cdf(y[...</span><span class="s2">, </span><span class="s1">i]</span><span class="s2">, </span><span class="s1">*marg_args[i]))</span>

        <span class="s1">u = np.column_stack(cdf_marg)</span>
        <span class="s2">if </span><span class="s1">y.ndim == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">u = u.squeeze()</span>

        <span class="s1">lpdf += self.copula.logpdf(u</span><span class="s2">, </span><span class="s1">cop_args)</span>
        <span class="s2">return </span><span class="s1">lpdf</span>


<span class="s2">class </span><span class="s1">Copula(ABC):</span>
    <span class="s0">r&quot;&quot;&quot;A generic Copula class meant for subclassing. 
 
    Notes 
    ----- 
    A function :math:`\phi` on :math:`[0, \infty]` is the Laplace-Stieltjes 
    transform of a distribution function if and only if :math:`\phi` is 
    completely monotone and :math:`\phi(0) = 1` [2]_. 
 
    The following algorithm for sampling a ``d``-dimensional exchangeable 
    Archimedean copula with generator :math:`\phi` is due to Marshall, Olkin 
    (1988) [1]_, where :math:`LS^{−1}(\phi)` denotes the inverse 
    Laplace-Stieltjes transform of :math:`\phi`. 
 
    From a mixture representation with respect to :math:`F`, the following 
    algorithm may be derived for sampling Archimedean copulas, see [1]_. 
 
    1. Sample :math:`V \sim F = LS^{−1}(\phi)`. 
    2. Sample i.i.d. :math:`X_i \sim U[0,1], i \in \{1,...,d\}`. 
    3. Return:math:`(U_1,..., U_d)`, where :math:`U_i = \phi(−\log(X_i)/V), i 
       \in \{1, ...,d\}`. 
 
    Detailed properties of each copula can be found in [3]_. 
 
    Instances of the class can access the attributes: ``rng`` for the random 
    number generator (used for the ``seed``). 
 
    **Subclassing** 
 
    When subclassing `Copula` to create a new copula, ``__init__`` and 
    ``random`` must be redefined. 
 
    * ``__init__(theta)``: If the copula 
      does not take advantage of a ``theta``, this parameter can be omitted. 
    * ``random(n, random_state)``: draw ``n`` from the copula. 
    * ``pdf(x)``: PDF from the copula. 
    * ``cdf(x)``: CDF from the copula. 
 
    References 
    ---------- 
    .. [1] Marshall AW, Olkin I. “Families of Multivariate Distributions”, 
      Journal of the American Statistical Association, 83, 834–841, 1988. 
    .. [2] Marius Hofert. &quot;Sampling Archimedean copulas&quot;, 
      Universität Ulm, 2008. 
    .. rvs[3] Harry Joe. &quot;Dependence Modeling with Copulas&quot;, Monographs on 
      Statistics and Applied Probability 134, 2015. 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">k_dim=</span><span class="s4">2</span><span class="s1">):</span>
        <span class="s1">self.k_dim = k_dim</span>

    <span class="s2">def </span><span class="s1">rvs(self</span><span class="s2">, </span><span class="s1">nobs=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">args=()</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Draw `n` in the half-open interval ``[0, 1)``. 
 
        Marginals are uniformly distributed. 
 
        Parameters 
        ---------- 
        nobs : int, optional 
            Number of samples to generate from the copula. Default is 1. 
        args : tuple 
            Arguments for copula parameters. The number of arguments depends 
            on the copula. 
        random_state : {None, int, numpy.random.Generator}, optional 
            If `seed` is None then the legacy singleton NumPy generator. 
            This will change after 0.13 to use a fresh NumPy ``Generator``, 
            so you should explicitly pass a seeded ``Generator`` if you 
            need reproducible results. 
            If `seed` is an int, a new ``Generator`` instance is used, 
            seeded with `seed`. 
            If `seed` is already a ``Generator`` instance then that instance is 
            used. 
 
        Returns 
        ------- 
        sample : array_like (nobs, d) 
            Sample from the copula. 
 
        See Also 
        -------- 
        statsmodels.tools.rng_qrng.check_random_state 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s1">@abstractmethod</span>
    <span class="s2">def </span><span class="s1">pdf(self</span><span class="s2">, </span><span class="s1">u</span><span class="s2">, </span><span class="s1">args=()):</span>
        <span class="s0">&quot;&quot;&quot;Probability density function of copula. 
 
        Parameters 
        ---------- 
        u : array_like, 2-D 
            Points of random variables in unit hypercube at which method is 
            evaluated. 
            The second (or last) dimension should be the same as the dimension 
            of the random variable, e.g. 2 for bivariate copula. 
        args : tuple 
            Arguments for copula parameters. The number of arguments depends 
            on the copula. 
 
        Returns 
        ------- 
        pdf : ndarray, (nobs, k_dim) 
            Copula pdf evaluated at points ``u``. 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">logpdf(self</span><span class="s2">, </span><span class="s1">u</span><span class="s2">, </span><span class="s1">args=()):</span>
        <span class="s0">&quot;&quot;&quot;Log of copula pdf, loglikelihood. 
 
        Parameters 
        ---------- 
        u : array_like, 2-D 
            Points of random variables in unit hypercube at which method is 
            evaluated. 
            The second (or last) dimension should be the same as the dimension 
            of the random variable, e.g. 2 for bivariate copula. 
        args : tuple 
            Arguments for copula parameters. The number of arguments depends 
            on the copula. 
 
        Returns 
        ------- 
        cdf : ndarray, (nobs, k_dim) 
            Copula log-pdf evaluated at points ``u``. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">np.log(self.pdf(u</span><span class="s2">, </span><span class="s1">*args))</span>

    <span class="s1">@abstractmethod</span>
    <span class="s2">def </span><span class="s1">cdf(self</span><span class="s2">, </span><span class="s1">u</span><span class="s2">, </span><span class="s1">args=()):</span>
        <span class="s0">&quot;&quot;&quot;Cumulative distribution function evaluated at points u. 
 
        Parameters 
        ---------- 
        u : array_like, 2-D 
            Points of random variables in unit hypercube at which method is 
            evaluated. 
            The second (or last) dimension should be the same as the dimension 
            of the random variable, e.g. 2 for bivariate copula. 
        args : tuple 
            Arguments for copula parameters. The number of arguments depends 
            on the copula. 
 
        Returns 
        ------- 
        cdf : ndarray, (nobs, k_dim) 
            Copula cdf evaluated at points ``u``. 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">plot_scatter(self</span><span class="s2">, </span><span class="s1">sample=</span><span class="s2">None, </span><span class="s1">nobs=</span><span class="s4">500</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s2">None, </span><span class="s1">ax=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Sample the copula and plot. 
 
        Parameters 
        ---------- 
        sample : array-like, optional 
            The sample to plot.  If not provided (the default), a sample 
            is generated. 
        nobs : int, optional 
            Number of samples to generate from the copula. 
        random_state : {None, int, numpy.random.Generator}, optional 
            If `seed` is None then the legacy singleton NumPy generator. 
            This will change after 0.13 to use a fresh NumPy ``Generator``, 
            so you should explicitly pass a seeded ``Generator`` if you 
            need reproducible results. 
            If `seed` is an int, a new ``Generator`` instance is used, 
            seeded with `seed`. 
            If `seed` is already a ``Generator`` instance then that instance is 
            used. 
        ax : AxesSubplot, optional 
            If given, this subplot is used to plot in instead of a new figure 
            being created. 
 
        Returns 
        ------- 
        fig : Figure 
            If `ax` is None, the created figure.  Otherwise the figure to which 
            `ax` is connected. 
        sample : array_like (n, d) 
            Sample from the copula. 
 
        See Also 
        -------- 
        statsmodels.tools.rng_qrng.check_random_state 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.k_dim != </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Can only plot 2-dimensional Copula.&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">sample </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">sample = self.rvs(nobs=nobs</span><span class="s2">, </span><span class="s1">random_state=random_state)</span>

        <span class="s1">fig</span><span class="s2">, </span><span class="s1">ax = utils.create_mpl_ax(ax)</span>
        <span class="s1">ax.scatter(sample[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">sample[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">ax.set_xlabel(</span><span class="s5">'u'</span><span class="s1">)</span>
        <span class="s1">ax.set_ylabel(</span><span class="s5">'v'</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">fig</span><span class="s2">, </span><span class="s1">sample</span>

    <span class="s2">def </span><span class="s1">plot_pdf(self</span><span class="s2">, </span><span class="s1">ticks_nbr=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">ax=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Plot the PDF. 
 
        Parameters 
        ---------- 
        ticks_nbr : int, optional 
            Number of color isolines for the PDF. Default is 10. 
        ax : AxesSubplot, optional 
            If given, this subplot is used to plot in instead of a new figure 
            being created. 
 
        Returns 
        ------- 
        fig : Figure 
            If `ax` is None, the created figure.  Otherwise the figure to which 
            `ax` is connected. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">matplotlib </span><span class="s2">import </span><span class="s1">pyplot </span><span class="s2">as </span><span class="s1">plt</span>
        <span class="s2">if </span><span class="s1">self.k_dim != </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s2">import </span><span class="s1">warnings</span>
            <span class="s1">warnings.warn(</span><span class="s5">&quot;Plotting 2-dimensional Copula.&quot;</span><span class="s1">)</span>

        <span class="s1">n_samples = </span><span class="s4">100</span>

        <span class="s1">eps = </span><span class="s4">1e-4</span>
        <span class="s1">uu</span><span class="s2">, </span><span class="s1">vv = np.meshgrid(np.linspace(eps</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">- eps</span><span class="s2">, </span><span class="s1">n_samples)</span><span class="s2">,</span>
                             <span class="s1">np.linspace(eps</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">- eps</span><span class="s2">, </span><span class="s1">n_samples))</span>
        <span class="s1">points = np.vstack([uu.ravel()</span><span class="s2">, </span><span class="s1">vv.ravel()]).T</span>

        <span class="s1">data = self.pdf(points).T.reshape(uu.shape)</span>
        <span class="s1">min_ = np.nanpercentile(data</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">max_ = np.nanpercentile(data</span><span class="s2">, </span><span class="s4">95</span><span class="s1">)</span>

        <span class="s1">fig</span><span class="s2">, </span><span class="s1">ax = utils.create_mpl_ax(ax)</span>

        <span class="s1">vticks = np.linspace(min_</span><span class="s2">, </span><span class="s1">max_</span><span class="s2">, </span><span class="s1">num=ticks_nbr)</span>
        <span class="s1">range_cbar = [min_</span><span class="s2">, </span><span class="s1">max_]</span>
        <span class="s1">cs = ax.contourf(uu</span><span class="s2">, </span><span class="s1">vv</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">vticks</span><span class="s2">,</span>
                         <span class="s1">antialiased=</span><span class="s2">True, </span><span class="s1">vmin=range_cbar[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                         <span class="s1">vmax=range_cbar[</span><span class="s4">1</span><span class="s1">])</span>

        <span class="s1">ax.set_xlabel(</span><span class="s5">&quot;u&quot;</span><span class="s1">)</span>
        <span class="s1">ax.set_ylabel(</span><span class="s5">&quot;v&quot;</span><span class="s1">)</span>
        <span class="s1">ax.set_xlim(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">ax.set_ylim(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">ax.set_aspect(</span><span class="s5">'equal'</span><span class="s1">)</span>
        <span class="s1">cbar = plt.colorbar(cs</span><span class="s2">, </span><span class="s1">ticks=vticks)</span>
        <span class="s1">cbar.set_label(</span><span class="s5">'p'</span><span class="s1">)</span>
        <span class="s1">fig.tight_layout()</span>

        <span class="s2">return </span><span class="s1">fig</span>

    <span class="s2">def </span><span class="s1">tau_simulated(self</span><span class="s2">, </span><span class="s1">nobs=</span><span class="s4">1024</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Kendall's tau based on simulated samples. 
 
        Returns 
        ------- 
        tau : float 
            Kendall's tau. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">x = self.rvs(nobs</span><span class="s2">, </span><span class="s1">random_state=random_state)</span>
        <span class="s2">return </span><span class="s1">stats.kendalltau(x[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">fit_corr_param(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s0">&quot;&quot;&quot;Copula correlation parameter using Kendall's tau of sample data. 
 
        Parameters 
        ---------- 
        data : array_like 
            Sample data used to fit `theta` using Kendall's tau. 
 
        Returns 
        ------- 
        corr_param : float 
            Correlation parameter of the copula, ``theta`` in Archimedean and 
            pearson correlation in elliptical. 
            If k_dim &gt; 2, then average tau is used. 
        &quot;&quot;&quot;</span>
        <span class="s1">x = np.asarray(data)</span>

        <span class="s2">if </span><span class="s1">x.shape[</span><span class="s4">1</span><span class="s1">] == </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s1">tau = stats.kendalltau(x[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">k = self.k_dim</span>
            <span class="s1">taus = [stats.kendalltau(x[...</span><span class="s2">, </span><span class="s1">i]</span><span class="s2">, </span><span class="s1">x[...</span><span class="s2">, </span><span class="s1">j])[</span><span class="s4">0</span><span class="s1">]</span>
                    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(k) </span><span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(i+</span><span class="s4">1</span><span class="s2">, </span><span class="s1">k)]</span>
            <span class="s1">tau = np.mean(taus)</span>
        <span class="s2">return </span><span class="s1">self._arg_from_tau(tau)</span>

    <span class="s2">def </span><span class="s1">_arg_from_tau(self</span><span class="s2">, </span><span class="s1">tau):</span>
        <span class="s0">&quot;&quot;&quot;Compute correlation parameter from tau. 
 
        Parameters 
        ---------- 
        tau : float 
            Kendall's tau. 
 
        Returns 
        ------- 
        corr_param : float 
            Correlation parameter of the copula, ``theta`` in Archimedean and 
            pearson correlation in elliptical. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>
</pre>
</body>
</html>