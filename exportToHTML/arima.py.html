<html>
<head>
<title>arima.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
arima.py</font>
</center></td></tr></table>
<pre><span class="s0">'''ARMA process and estimation with scipy.signal.lfilter 
 
2009-09-06: copied from try_signal.py 
    reparameterized same as signal.lfilter (positive coefficients) 
 
 
Notes 
----- 
* pretty fast 
* checked with Monte Carlo and cross comparison with statsmodels yule_walker 
  for AR numbers are close but not identical to yule_walker 
  not compared to other statistics packages, no degrees of freedom correction 
* ARMA(2,2) estimation (in Monte Carlo) requires longer time series to estimate parameters 
  without large variance. There might be different ARMA parameters 
  with similar impulse response function that cannot be well 
  distinguished with small samples (e.g. 100 observations) 
* good for one time calculations for entire time series, not for recursive  
  prediction 
* class structure not very clean yet 
* many one-liners with scipy.signal, but takes time to figure out usage 
* missing result statistics, e.g. t-values, but standard errors in examples 
* no criteria for choice of number of lags 
* no constant term in ARMA process 
* no integration, differencing for ARIMA 
* written without textbook, works but not sure about everything 
  briefly checked and it looks to be standard least squares, see below 
 
* theoretical autocorrelation function of general ARMA  
  Done, relatively easy to guess solution, time consuming to get 
  theoretical test cases,  
  example file contains explicit formulas for acovf of MA(1), MA(2) and ARMA(1,1) 
 
* two names for lag polynomials ar = rhoy, ma = rhoe ? 
  
 
Properties:  
Judge, ... (1985): The Theory and Practise of Econometrics 
 
BigJudge p. 237ff: 
If the time series process is a stationary ARMA(p,q), then 
minimizing the sum of squares is asymptoticaly (as T-&gt; inf) 
equivalent to the exact Maximum Likelihood Estimator 
 
Because Least Squares conditional on the initial information 
does not use all information, in small samples exact MLE can  
be better. 
 
Without the normality assumption, the least squares estimator  
is still consistent under suitable conditions, however not 
efficient 
 
Author: josefpktd 
License: BSD 
'''</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">signal</span><span class="s2">, </span><span class="s1">optimize</span>

<span class="s2">class </span><span class="s1">ARIMA(object):</span>
    <span class="s0">'''currently ARMA only, no differencing used - no I 
     
    parameterized as 
         rhoy(L) y_t = rhoe(L) eta_t 
 
    A instance of this class preserves state, so new class instances should 
    be created for different examples 
    '''</span>
    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s2">pass</span>
    <span class="s2">def </span><span class="s1">fit(self</span><span class="s2">,</span><span class="s1">x</span><span class="s2">,</span><span class="s1">p</span><span class="s2">,</span><span class="s1">q</span><span class="s2">, </span><span class="s1">rhoy0=</span><span class="s2">None, </span><span class="s1">rhoe0=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">'''estimate lag coefficients of ARMA orocess by least squares 
         
        Parameters 
        ---------- 
            x : array, 1d 
                time series data  
            p : int 
                number of AR lags to estimate 
            q : int 
                number of MA lags to estimate 
            rhoy0, rhoe0 : array_like (optional) 
                starting values for estimation 
                 
        Returns 
        ------- 
            rh, cov_x, infodict, mesg, ier : output of scipy.optimize.leastsq 
            rh : 
                estimate of lag parameters, concatenated [rhoy, rhoe] 
            cov_x : 
                unscaled (!) covariance matrix of coefficient estimates 
         
         
        '''</span>
        <span class="s2">def </span><span class="s1">errfn( rho):</span>
            <span class="s3">#rhoy, rhoe = rho</span>
            <span class="s1">rhoy = np.concatenate(([</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rho[:p]))</span>
            <span class="s1">rhoe = np.concatenate(([</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rho[p:]))</span>
            <span class="s1">etahatr = signal.lfilter(rhoy</span><span class="s2">, </span><span class="s1">rhoe</span><span class="s2">, </span><span class="s1">x)</span>
            <span class="s3">#print rho,np.sum(etahatr*etahatr)</span>
            <span class="s2">return </span><span class="s1">etahatr</span>
        
        <span class="s2">if </span><span class="s1">rhoy0 </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">rhoy0 = </span><span class="s4">0.5 </span><span class="s1">* np.ones(p)</span>
        <span class="s2">if </span><span class="s1">rhoe0 </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">rhoe0 = </span><span class="s4">0.5 </span><span class="s1">* np.ones(q)</span>
        <span class="s1">usels = </span><span class="s2">True</span>
        <span class="s2">if </span><span class="s1">usels:</span>
            <span class="s1">rh</span><span class="s2">, </span><span class="s1">cov_x</span><span class="s2">, </span><span class="s1">infodict</span><span class="s2">, </span><span class="s1">mesg</span><span class="s2">, </span><span class="s1">ier = \</span>
               <span class="s1">optimize.leastsq(errfn</span><span class="s2">, </span><span class="s1">np.r_[rhoy0</span><span class="s2">, </span><span class="s1">rhoe0]</span><span class="s2">,</span><span class="s1">ftol=</span><span class="s4">1e-10</span><span class="s2">,</span><span class="s1">full_output=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># fmin_bfgs is slow or doesn't work yet</span>
            <span class="s1">errfnsum = </span><span class="s2">lambda </span><span class="s1">rho : np.sum(errfn(rho)**</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s3">#xopt, {fopt, gopt, Hopt, func_calls, grad_calls</span>
            <span class="s1">rh</span><span class="s2">,</span><span class="s1">fopt</span><span class="s2">, </span><span class="s1">gopt</span><span class="s2">, </span><span class="s1">cov_x</span><span class="s2">, </span><span class="s1">_</span><span class="s2">,</span><span class="s1">_</span><span class="s2">, </span><span class="s1">ier = \</span>
                <span class="s1">optimize.fmin_bfgs(errfnsum</span><span class="s2">, </span><span class="s1">np.r_[rhoy0</span><span class="s2">, </span><span class="s1">rhoe0]</span><span class="s2">, </span><span class="s1">maxiter=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">full_output=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">infodict</span><span class="s2">, </span><span class="s1">mesg = </span><span class="s2">None, None</span>
        <span class="s1">self.rh = rh</span>
        <span class="s1">self.rhoy = np.concatenate(([</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rh[:p]))</span>
        <span class="s1">self.rhoe = np.concatenate(([</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rh[p:])) </span><span class="s3">#rh[-q:])) doesnt work for q=0</span>
        <span class="s1">self.error_estimate = errfn(rh)</span>
        <span class="s2">return </span><span class="s1">rh</span><span class="s2">, </span><span class="s1">cov_x</span><span class="s2">, </span><span class="s1">infodict</span><span class="s2">, </span><span class="s1">mesg</span><span class="s2">, </span><span class="s1">ier</span>
        
    <span class="s2">def </span><span class="s1">errfn(self</span><span class="s2">, </span><span class="s1">rho=</span><span class="s2">None, </span><span class="s1">p=</span><span class="s2">None, </span><span class="s1">x=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">''' duplicate -&gt; remove one 
        '''</span>
        <span class="s3">#rhoy, rhoe = rho</span>
        <span class="s2">if not </span><span class="s1">rho </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">rhoy = np.concatenate(([</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,  </span><span class="s1">rho[:p]))</span>
            <span class="s1">rhoe = np.concatenate(([</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,  </span><span class="s1">rho[p:]))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">rhoy = self.rhoy</span>
            <span class="s1">rhoe = self.rhoe         </span>
        <span class="s1">etahatr = signal.lfilter(rhoy</span><span class="s2">, </span><span class="s1">rhoe</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s3">#print rho,np.sum(etahatr*etahatr)</span>
        <span class="s2">return </span><span class="s1">etahatr</span>
        
    <span class="s2">def </span><span class="s1">predicted(self</span><span class="s2">, </span><span class="s1">rhoy=</span><span class="s2">None, </span><span class="s1">rhoe=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">'''past predicted values of time series  
        just added, not checked yet 
        '''</span>
        <span class="s2">if </span><span class="s1">rhoy </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">rhoy = self.rhoy</span>
        <span class="s2">if </span><span class="s1">rhoe </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">rhoe = self.rhoe</span>
        <span class="s2">return </span><span class="s1">self.x + self.error_estimate</span>
    
    <span class="s2">def </span><span class="s1">forecast(self</span><span class="s2">, </span><span class="s1">ar=</span><span class="s2">None, </span><span class="s1">ma=</span><span class="s2">None, </span><span class="s1">nperiod=</span><span class="s4">10</span><span class="s1">):</span>
        <span class="s1">eta = np.r_[self.error_estimate</span><span class="s2">, </span><span class="s1">np.zeros(nperiod)]</span>
        <span class="s2">if </span><span class="s1">ar </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">ar = self.rhoy</span>
        <span class="s2">if </span><span class="s1">ma </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">ma = self.rhoe</span>
        <span class="s2">return </span><span class="s1">signal.lfilter(ma</span><span class="s2">, </span><span class="s1">ar</span><span class="s2">, </span><span class="s1">eta)      </span>

    <span class="s2">def </span><span class="s1">generate_sample(self</span><span class="s2">, </span><span class="s1">ar</span><span class="s2">, </span><span class="s1">ma</span><span class="s2">, </span><span class="s1">nsample</span><span class="s2">, </span><span class="s1">std=</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s1">eta = std * np.random.randn(nsample)</span>
        <span class="s2">return </span><span class="s1">signal.lfilter(ma</span><span class="s2">, </span><span class="s1">ar</span><span class="s2">, </span><span class="s1">eta)</span>

<span class="s2">def </span><span class="s1">arma_generate_sample(ar</span><span class="s2">, </span><span class="s1">ma</span><span class="s2">, </span><span class="s1">nsample</span><span class="s2">, </span><span class="s1">sigma=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">distrvs=np.random.randn):</span>
    <span class="s0">'''generate an random sample of an ARMA process 
 
    Parameters 
    ---------- 
    ar : array_like, 1d 
        coefficient for autoregressive lag polynomial, including zero lag 
    ma : array_like, 1d 
        coefficient for moving-average lag polynomial, including zero lag 
    nsample : int 
        length of simulated time series 
    sigma : float 
        standard deviation of noise 
    distrvs : function, random number generator 
        function that generates the random numbers, and takes sample size 
        as argument 
        default: np.random.randn 
        TODO: change to size argument 
  
 
    Returns 
    ------- 
    acovf : array 
        autocovariance of ARMA process given by ar, ma 
 
 
    '''</span>
    <span class="s1">eta = sigma * distrvs(nsample)</span>
    <span class="s2">return </span><span class="s1">signal.lfilter(ma</span><span class="s2">, </span><span class="s1">ar</span><span class="s2">, </span><span class="s1">eta)</span>

<span class="s2">def </span><span class="s1">arma_acovf(ar</span><span class="s2">, </span><span class="s1">ma</span><span class="s2">, </span><span class="s1">nobs=</span><span class="s4">10</span><span class="s1">):</span>
    <span class="s0">'''theoretical autocovariance function of ARMA process 
 
    Parameters 
    ---------- 
    ar : array_like, 1d 
        coefficient for autoregressive lag polynomial, including zero lag 
    ma : array_like, 1d 
        coefficient for moving-average lag polynomial, including zero lag 
 
    Returns 
    ------- 
    acovf : array 
        autocovariance of ARMA process given by ar, ma 
 
    See Also 
    -------- 
    arma_acf 
    acovf 
     
 
    Notes 
    ----- 
    tries to do some crude numerical speed improvements for cases 
    with high persistance. 
    '''</span>
    <span class="s3">#increase length of impulse response for AR closer to 1</span>
    <span class="s3">#maybe cheap/fast enough to always keep nobs for ir large</span>
    <span class="s2">if </span><span class="s1">np.abs(np.sum(ar)-</span><span class="s4">1</span><span class="s1">) &gt; </span><span class="s4">0.9</span><span class="s1">:</span>
        <span class="s1">nobs_ir = </span><span class="s4">1000</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">nobs_ir = </span><span class="s4">100</span>
    <span class="s1">ir = arma_impulse_response(ar</span><span class="s2">, </span><span class="s1">ma</span><span class="s2">, </span><span class="s1">nobs=nobs_ir)</span>
    <span class="s3">#better save than sorry (?), I have no idea about the required precision</span>
    <span class="s3">#only checked for AR(1)</span>
    <span class="s2">while </span><span class="s1">ir[-</span><span class="s4">1</span><span class="s1">] &gt; </span><span class="s4">5</span><span class="s1">*</span><span class="s4">1e-5</span><span class="s1">:</span>
        <span class="s1">nobs *= </span><span class="s4">10</span>
        <span class="s1">ir = arma_impulse_response(ar</span><span class="s2">, </span><span class="s1">ma</span><span class="s2">, </span><span class="s1">nobs=nobs)</span>
    <span class="s3">#again no idea where the speed break points are:</span>
    <span class="s2">if </span><span class="s1">nobs_ir &gt; </span><span class="s4">50000 </span><span class="s2">and </span><span class="s1">nobs &lt; </span><span class="s4">1001</span><span class="s1">:</span>
        <span class="s1">acovf = np.array([np.dot(ir[:nobs-t]</span><span class="s2">, </span><span class="s1">ir[t:nobs]) </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">10</span><span class="s1">)])</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">acovf = np.correlate(ir</span><span class="s2">,</span><span class="s1">ir</span><span class="s2">,</span><span class="s5">'full'</span><span class="s1">)[len(ir)-</span><span class="s4">1</span><span class="s1">:]</span>
    <span class="s2">return </span><span class="s1">acovf[:nobs]</span>

<span class="s2">def </span><span class="s1">arma_acf(ar</span><span class="s2">, </span><span class="s1">ma</span><span class="s2">, </span><span class="s1">nobs=</span><span class="s4">10</span><span class="s1">):</span>
    <span class="s0">'''theoretical autocovariance function of ARMA process 
 
    Parameters 
    ---------- 
    ar : array_like, 1d 
        coefficient for autoregressive lag polynomial, including zero lag 
    ma : array_like, 1d 
        coefficient for moving-average lag polynomial, including zero lag 
 
    Returns 
    ------- 
    acovf : array 
        autocovariance of ARMA process given by ar, ma 
 
 
    See Also 
    -------- 
    arma_acovf 
    acf 
    acovf 
     
    '''</span>
    <span class="s1">acovf = arma_acovf(ar</span><span class="s2">, </span><span class="s1">ma</span><span class="s2">, </span><span class="s1">nobs)</span>
    <span class="s2">return </span><span class="s1">acovf/acovf[</span><span class="s4">0</span><span class="s1">]</span>

<span class="s2">def </span><span class="s1">arma_impulse_response(ar</span><span class="s2">, </span><span class="s1">ma</span><span class="s2">, </span><span class="s1">nobs=</span><span class="s4">100</span><span class="s1">):</span>
    <span class="s0">'''get the impulse response function (MA representation) for ARMA process 
 
    Parameters 
    ---------- 
    ma : array_like, 1d 
        moving average lag polynomial 
    ar : array_like, 1d 
        auto regressive lag polynomial 
    nobs : int 
        number of observations to calculate 
 
    Returns 
    ------- 
    ir : array, 1d 
        impulse response function with nobs elements 
    `    
 
    Notes 
    ----- 
    This is the same as finding the MA representation of an ARMA(p,q). 
    By reversing the role of ar and ma in the function arguments, the 
    returned result is the AR representation of an ARMA(p,q), i.e 
 
    ma_representation = arma_impulse_response(ar, ma, nobs=100) 
    ar_representation = arma_impulse_response(ma, ar, nobs=100) 
 
    fully tested against matlab 
     
    Examples 
    -------- 
    AR(1) 
    &gt;&gt;&gt; arma_impulse_response([1.0, -0.8], [1.], nobs=10) 
    array([ 1.        ,  0.8       ,  0.64      ,  0.512     ,  0.4096    , 
            0.32768   ,  0.262144  ,  0.2097152 ,  0.16777216,  0.13421773]) 
     
    this is the same as 
    &gt;&gt;&gt; 0.8**np.arange(10) 
    array([ 1.        ,  0.8       ,  0.64      ,  0.512     ,  0.4096    , 
            0.32768   ,  0.262144  ,  0.2097152 ,  0.16777216,  0.13421773]) 
 
    MA(2) 
    &gt;&gt;&gt; arma_impulse_response([1.0], [1., 0.5, 0.2], nobs=10) 
    array([ 1. ,  0.5,  0.2,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ]) 
 
    ARMA(1,2) 
    &gt;&gt;&gt; arma_impulse_response([1.0, -0.8], [1., 0.5, 0.2], nobs=10) 
    array([ 1.        ,  1.3       ,  1.24      ,  0.992     ,  0.7936    , 
            0.63488   ,  0.507904  ,  0.4063232 ,  0.32505856,  0.26004685]) 
 
 
    '''</span>
    <span class="s1">impulse = np.zeros(nobs)</span>
    <span class="s1">impulse[</span><span class="s4">0</span><span class="s1">] = </span><span class="s4">1.</span>
    <span class="s2">return </span><span class="s1">signal.lfilter(ma</span><span class="s2">, </span><span class="s1">ar</span><span class="s2">, </span><span class="s1">impulse)</span>

<span class="s3">#alias, easier to remember</span>
<span class="s1">arma2ma = arma_impulse_response</span>

<span class="s3">#alias, easier to remember</span>
<span class="s2">def </span><span class="s1">arma2ar(ar</span><span class="s2">, </span><span class="s1">ma</span><span class="s2">, </span><span class="s1">nobs=</span><span class="s4">100</span><span class="s1">):</span>
    <span class="s0">'''get the AR representation of an ARMA process 
 
    Parameters 
    ---------- 
    ar : array_like, 1d 
        auto regressive lag polynomial 
    ma : array_like, 1d 
        moving average lag polynomial 
    nobs : int 
        number of observations to calculate 
 
    Returns 
    ------- 
    ar : array, 1d 
        coefficients of AR lag polynomial with nobs elements 
    `    
 
    Notes 
    ----- 
    This is just an alias for 
     
    ``ar_representation = arma_impulse_response(ma, ar, nobs=100)`` 
 
    fully tested against matlab 
     
    Examples 
    -------- 
 
    '''</span>
    <span class="s2">return </span><span class="s1">arma_impulse_response(ma</span><span class="s2">, </span><span class="s1">ar</span><span class="s2">, </span><span class="s1">nobs=</span><span class="s4">100</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">lpol2index(ar):</span>
    <span class="s0">'''remove zeros from lagpolynomial, squeezed representation with index 
 
    Parameters 
    ---------- 
    ar : array_like 
        coefficients of lag polynomial 
 
    Returns 
    ------- 
    coeffs : array 
        non-zero coefficients of lag polynomial 
    index : array 
        index (lags) of lagpolynomial with non-zero elements 
    '''</span>

    <span class="s1">index = np.nonzero(ar)</span>
    <span class="s1">coeffs = ar[index]</span>
    <span class="s2">return </span><span class="s1">coeffs</span><span class="s2">, </span><span class="s1">index</span>

<span class="s2">def </span><span class="s1">index2lpol(coeffs</span><span class="s2">, </span><span class="s1">index):</span>
    <span class="s0">'''expand coefficients to lag poly 
 
    Parameters 
    ---------- 
    coeffs : array 
        non-zero coefficients of lag polynomial 
    index : array 
        index (lags) of lagpolynomial with non-zero elements     
    ar : array_like 
        coefficients of lag polynomial 
 
    Returns 
    ------- 
    ar : array_like 
        coefficients of lag polynomial 
 
    '''</span>
    <span class="s1">n = max(index)</span>
    <span class="s1">ar = np.zeros(n)</span>
    <span class="s1">ar[index] = coeffs</span>
    <span class="s2">return </span><span class="s1">ar</span>

    
<span class="s2">def </span><span class="s1">deconvolve(num</span><span class="s2">, </span><span class="s1">den</span><span class="s2">, </span><span class="s1">n=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Deconvolves divisor out of signal, division of polynomials for n terms 
 
    calculates den^{-1} * num 
 
    Parameters 
    ---------- 
    num : array_like 
        signal or lag polynomial 
    denom : array_like 
        coefficients of lag polynomial (linear filter) 
    n : None or int 
        number of terms of quotient 
 
    Returns 
    ------- 
    quot : array 
        quotient or filtered series 
    rem : array 
        remainder 
 
    Notes 
    ----- 
    If num is a time series, then this applies the linear filter den^{-1}. 
    If both num and den are both lagpolynomials, then this calculates the 
    quotient polynomial for n terms and also returns the remainder. 
         
    This is copied from scipy.signal.signaltools and added n as optional 
    parameter. 
     
    &quot;&quot;&quot;</span>
    <span class="s1">num = np.atleast_1d(num)</span>
    <span class="s1">den = np.atleast_1d(den)</span>
    <span class="s1">N = len(num)</span>
    <span class="s1">D = len(den)</span>
    <span class="s2">if </span><span class="s1">D &gt; N </span><span class="s2">and </span><span class="s1">n </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">quot = [];</span>
        <span class="s1">rem = num;</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">n </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">n = N-D+</span><span class="s4">1</span>
        <span class="s1">input = np.zeros(n</span><span class="s2">, </span><span class="s1">float)</span>
        <span class="s1">input[</span><span class="s4">0</span><span class="s1">] = </span><span class="s4">1</span>
        <span class="s1">quot = signal.lfilter(num</span><span class="s2">, </span><span class="s1">den</span><span class="s2">, </span><span class="s1">input)</span>
        <span class="s1">num_approx = signal.convolve(den</span><span class="s2">, </span><span class="s1">quot</span><span class="s2">, </span><span class="s1">mode=</span><span class="s5">'full'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">len(num) &lt; len(num_approx):  </span><span class="s3"># 1d only ?</span>
            <span class="s1">num = np.concatenate((num</span><span class="s2">, </span><span class="s1">np.zeros(len(num_approx)-len(num))))</span>
        <span class="s1">rem = num - num_approx</span>
    <span class="s2">return </span><span class="s1">quot</span><span class="s2">, </span><span class="s1">rem</span>



<span class="s2">def </span><span class="s1">mcarma22(niter=</span><span class="s4">10</span><span class="s1">):</span>
    <span class="s0">'''run Monte Carlo for ARMA(2,2) 
     
    DGP parameters currently hard coded 
    also sample size `nsample` 
 
    was not a self contained function, used instances from outer scope 
      now corrected 
     
    '''</span>
    <span class="s1">nsample = </span><span class="s4">1000</span>
    <span class="s3">#ar = [1.0, 0, 0]</span>
    <span class="s1">ar = [</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.75</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.1</span><span class="s1">]</span>
    <span class="s3">#ma = [1.0, 0, 0]</span>
    <span class="s1">ma = [</span><span class="s4">1.0</span><span class="s2">,  </span><span class="s4">0.3</span><span class="s2">,  </span><span class="s4">0.2</span><span class="s1">]</span>
    <span class="s1">results = []</span>
    <span class="s1">results_bse = []</span>
    <span class="s1">arest = ARIMA()</span>
    <span class="s1">arest2 = ARIMA()</span>
    <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(niter):</span>
        <span class="s1">y2 = arma_generate_sample(ar</span><span class="s2">,</span><span class="s1">ma</span><span class="s2">,</span><span class="s1">nsample</span><span class="s2">,</span><span class="s4">0.1</span><span class="s1">)</span>
        <span class="s1">rhohat2a</span><span class="s2">, </span><span class="s1">cov_x2a</span><span class="s2">, </span><span class="s1">infodict</span><span class="s2">, </span><span class="s1">mesg</span><span class="s2">, </span><span class="s1">ier = arest2.fit(y2</span><span class="s2">,</span><span class="s4">2</span><span class="s2">,</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">results.append(rhohat2a)</span>
        <span class="s1">err2a = arest2.errfn(x=y2)</span>
        <span class="s1">sige2a = np.sqrt(np.dot(err2a</span><span class="s2">,</span><span class="s1">err2a)/nsample)</span>
        <span class="s1">results_bse.append(sige2a * np.sqrt(np.diag(cov_x2a)))</span>
    <span class="s2">return </span><span class="s1">np.r_[ar[</span><span class="s4">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">ma[</span><span class="s4">1</span><span class="s1">:]]</span><span class="s2">, </span><span class="s1">np.array(results)</span><span class="s2">, </span><span class="s1">np.array(results_bse)</span>

      
<span class="s1">__all__ = [</span><span class="s5">'ARIMA'</span><span class="s2">, </span><span class="s5">'arma_acf'</span><span class="s2">, </span><span class="s5">'arma_acovf'</span><span class="s2">, </span><span class="s5">'arma_generate_sample'</span><span class="s2">,</span>
           <span class="s5">'arma_impulse_response'</span><span class="s2">, </span><span class="s5">'arma2ar'</span><span class="s2">, </span><span class="s5">'arma2ma'</span><span class="s2">, </span><span class="s5">'deconvolve'</span><span class="s2">,</span>
           <span class="s5">'lpol2index'</span><span class="s2">, </span><span class="s5">'index2lpol'</span><span class="s1">]</span>


<span class="s2">if </span><span class="s1">__name__ == </span><span class="s5">'__main__'</span><span class="s1">:</span>
    <span class="s1">print mcarma22()</span>

    
    <span class="s3"># Simulate AR(1)</span>
    <span class="s3">#--------------</span>
    <span class="s3"># ar * y = ma * eta</span>
    <span class="s1">ar = [</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.8</span><span class="s1">]</span>
    <span class="s1">ma = [</span><span class="s4">1.0</span><span class="s1">]</span>
    
    <span class="s3"># generate AR data</span>
    <span class="s1">eta = </span><span class="s4">0.1 </span><span class="s1">* np.random.randn(</span><span class="s4">1000</span><span class="s1">)</span>
    <span class="s1">yar1 = signal.lfilter(ar</span><span class="s2">, </span><span class="s1">ma</span><span class="s2">, </span><span class="s1">eta)</span>
    
    <span class="s1">print </span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">Example 0&quot;</span>
    <span class="s1">arest = ARIMA()</span>
    <span class="s1">rhohat</span><span class="s2">, </span><span class="s1">cov_x</span><span class="s2">, </span><span class="s1">infodict</span><span class="s2">, </span><span class="s1">mesg</span><span class="s2">, </span><span class="s1">ier = arest.fit(yar1</span><span class="s2">,</span><span class="s4">1</span><span class="s2">,</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">print rhohat</span>
    <span class="s1">print cov_x</span>
    
    <span class="s1">print </span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">Example 1&quot;</span>
    <span class="s1">ar = [</span><span class="s4">1.0</span><span class="s2">,  </span><span class="s1">-</span><span class="s4">0.8</span><span class="s1">]</span>
    <span class="s1">ma = [</span><span class="s4">1.0</span><span class="s2">,  </span><span class="s4">0.5</span><span class="s1">]</span>
    <span class="s1">y1 = arest.generate_sample(ar</span><span class="s2">,</span><span class="s1">ma</span><span class="s2">,</span><span class="s4">1000</span><span class="s2">,</span><span class="s4">0.1</span><span class="s1">)</span>
    <span class="s1">rhohat1</span><span class="s2">, </span><span class="s1">cov_x1</span><span class="s2">, </span><span class="s1">infodict</span><span class="s2">, </span><span class="s1">mesg</span><span class="s2">, </span><span class="s1">ier = arest.fit(y1</span><span class="s2">,</span><span class="s4">1</span><span class="s2">,</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">print rhohat1</span>
    <span class="s1">print cov_x1</span>
    <span class="s1">err1 = arest.errfn(x=y1)</span>
    <span class="s1">print np.var(err1)</span>
    <span class="s2">import </span><span class="s1">scikits.statsmodels </span><span class="s2">as </span><span class="s1">sm</span>
    <span class="s1">print sm.regression.yule_walker(y1</span><span class="s2">, </span><span class="s1">order=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">inv=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s1">print </span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">Example 2&quot;</span>
    <span class="s1">arest2 = ARIMA()</span>
    <span class="s1">nsample = </span><span class="s4">1000</span>
    <span class="s1">ar = [</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.6</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.1</span><span class="s1">]</span>
    <span class="s1">ma = [</span><span class="s4">1.0</span><span class="s2">,  </span><span class="s4">0.3</span><span class="s2">,  </span><span class="s4">0.2</span><span class="s1">]</span>
    <span class="s1">y2 = arest2.generate_sample(ar</span><span class="s2">,</span><span class="s1">ma</span><span class="s2">,</span><span class="s1">nsample</span><span class="s2">,</span><span class="s4">0.1</span><span class="s1">)</span>
    <span class="s1">rhohat2</span><span class="s2">, </span><span class="s1">cov_x2</span><span class="s2">, </span><span class="s1">infodict</span><span class="s2">, </span><span class="s1">mesg</span><span class="s2">, </span><span class="s1">ier = arest2.fit(y2</span><span class="s2">,</span><span class="s4">1</span><span class="s2">,</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">print rhohat2</span>
    <span class="s1">print cov_x2</span>
    <span class="s1">err2 = arest.errfn(x=y2)</span>
    <span class="s1">print np.var(err2)</span>
    <span class="s1">print arest2.rhoy</span>
    <span class="s1">print arest2.rhoe</span>
    <span class="s1">print </span><span class="s5">&quot;true&quot;</span>
    <span class="s1">print ar</span>
    <span class="s1">print ma</span>
    <span class="s1">rhohat2a</span><span class="s2">, </span><span class="s1">cov_x2a</span><span class="s2">, </span><span class="s1">infodict</span><span class="s2">, </span><span class="s1">mesg</span><span class="s2">, </span><span class="s1">ier = arest2.fit(y2</span><span class="s2">,</span><span class="s4">2</span><span class="s2">,</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">print rhohat2a</span>
    <span class="s1">print cov_x2a</span>
    <span class="s1">err2a = arest.errfn(x=y2)</span>
    <span class="s1">print np.var(err2a)</span>
    <span class="s1">print arest2.rhoy</span>
    <span class="s1">print arest2.rhoe</span>
    <span class="s1">print </span><span class="s5">&quot;true&quot;</span>
    <span class="s1">print ar</span>
    <span class="s1">print ma</span>

    <span class="s1">print sm.regression.yule_walker(y2</span><span class="s2">, </span><span class="s1">order=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">inv=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s1">print </span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">Example 20&quot;</span>
    <span class="s1">arest20 = ARIMA()</span>
    <span class="s1">nsample = </span><span class="s4">1000</span>
    <span class="s1">ar = [</span><span class="s4">1.0</span><span class="s1">]</span><span class="s3">#, -0.8, -0.4]</span>
    <span class="s1">ma = [</span><span class="s4">1.0</span><span class="s2">,  </span><span class="s4">0.5</span><span class="s2">,  </span><span class="s4">0.2</span><span class="s1">]</span>
    <span class="s1">y3 = arest20.generate_sample(ar</span><span class="s2">,</span><span class="s1">ma</span><span class="s2">,</span><span class="s1">nsample</span><span class="s2">,</span><span class="s4">0.01</span><span class="s1">)</span>
    <span class="s1">rhohat3</span><span class="s2">, </span><span class="s1">cov_x3</span><span class="s2">, </span><span class="s1">infodict</span><span class="s2">, </span><span class="s1">mesg</span><span class="s2">, </span><span class="s1">ier = arest20.fit(y3</span><span class="s2">,</span><span class="s4">2</span><span class="s2">,</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">print rhohat3</span>
    <span class="s1">print cov_x3</span>
    <span class="s1">err3 = arest20.errfn(x=y3)</span>
    <span class="s1">print np.var(err3)</span>
    <span class="s1">print np.sqrt(np.dot(err3</span><span class="s2">,</span><span class="s1">err3)/nsample)</span>
    <span class="s1">print arest20.rhoy</span>
    <span class="s1">print arest20.rhoe</span>
    <span class="s1">print </span><span class="s5">&quot;true&quot;</span>
    <span class="s1">print ar</span>
    <span class="s1">print ma </span>
    
    <span class="s1">rhohat3a</span><span class="s2">, </span><span class="s1">cov_x3a</span><span class="s2">, </span><span class="s1">infodict</span><span class="s2">, </span><span class="s1">mesg</span><span class="s2">, </span><span class="s1">ier = arest20.fit(y3</span><span class="s2">,</span><span class="s4">0</span><span class="s2">,</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">print rhohat3a</span>
    <span class="s1">print cov_x3a</span>
    <span class="s1">err3a = arest20.errfn(x=y3)</span>
    <span class="s1">print np.var(err3a)</span>
    <span class="s1">print np.sqrt(np.dot(err3a</span><span class="s2">,</span><span class="s1">err3a)/nsample)</span>
    <span class="s1">print arest20.rhoy</span>
    <span class="s1">print arest20.rhoe </span>
    <span class="s1">print </span><span class="s5">&quot;true&quot;</span>
    <span class="s1">print ar</span>
    <span class="s1">print ma</span>
   
    <span class="s1">print sm.regression.yule_walker(y3</span><span class="s2">, </span><span class="s1">order=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">inv=</span><span class="s2">True</span><span class="s1">)    </span>

    <span class="s1">print </span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">Example 02&quot;</span>
    <span class="s1">arest02 = ARIMA()</span>
    <span class="s1">nsample = </span><span class="s4">1000</span>
    <span class="s1">ar = [</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.8</span><span class="s2">, </span><span class="s4">0.4</span><span class="s1">] </span><span class="s3">#-0.8, -0.4]</span>
    <span class="s1">ma = [</span><span class="s4">1.0</span><span class="s1">]</span><span class="s3">#,  0.8,  0.4]</span>
    <span class="s1">y4 = arest02.generate_sample(ar</span><span class="s2">,</span><span class="s1">ma</span><span class="s2">,</span><span class="s1">nsample)</span>
    <span class="s1">rhohat4</span><span class="s2">, </span><span class="s1">cov_x4</span><span class="s2">, </span><span class="s1">infodict</span><span class="s2">, </span><span class="s1">mesg</span><span class="s2">, </span><span class="s1">ier = arest02.fit(y4</span><span class="s2">,</span><span class="s4">2</span><span class="s2">,</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">print rhohat4</span>
    <span class="s1">print cov_x4</span>
    <span class="s1">err4 = arest02.errfn(x=y4)</span>
    <span class="s1">print np.var(err4)</span>
    <span class="s1">sige = np.sqrt(np.dot(err4</span><span class="s2">,</span><span class="s1">err4)/nsample)</span>
    <span class="s1">print sige</span>
    <span class="s1">print sige * np.sqrt(np.diag(cov_x4))</span>
    <span class="s1">print np.sqrt(np.diag(cov_x4))</span>
    <span class="s1">print arest02.rhoy</span>
    <span class="s1">print arest02.rhoe </span>
    <span class="s1">print </span><span class="s5">&quot;true&quot;</span>
    <span class="s1">print ar</span>
    <span class="s1">print ma </span>
    
    <span class="s1">rhohat4a</span><span class="s2">, </span><span class="s1">cov_x4a</span><span class="s2">, </span><span class="s1">infodict</span><span class="s2">, </span><span class="s1">mesg</span><span class="s2">, </span><span class="s1">ier = arest02.fit(y4</span><span class="s2">,</span><span class="s4">0</span><span class="s2">,</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">print rhohat4a</span>
    <span class="s1">print cov_x4a</span>
    <span class="s1">err4a = arest02.errfn(x=y4)</span>
    <span class="s1">print np.var(err4a)</span>
    <span class="s1">sige = np.sqrt(np.dot(err4a</span><span class="s2">,</span><span class="s1">err4a)/nsample)</span>
    <span class="s1">print sige</span>
    <span class="s1">print sige * np.sqrt(np.diag(cov_x4a))</span>
    <span class="s1">print np.sqrt(np.diag(cov_x4a))</span>
    <span class="s1">print arest02.rhoy</span>
    <span class="s1">print arest02.rhoe  </span>
    <span class="s1">print </span><span class="s5">&quot;true&quot;</span>
    <span class="s1">print ar</span>
    <span class="s1">print ma</span>
    <span class="s2">import </span><span class="s1">scikits.statsmodels </span><span class="s2">as </span><span class="s1">sm</span>
    <span class="s1">print sm.regression.yule_walker(y4</span><span class="s2">, </span><span class="s1">order=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">method=</span><span class="s5">'mle'</span><span class="s2">, </span><span class="s1">inv=</span><span class="s2">True</span><span class="s1">)  </span>

    <span class="s2">def </span><span class="s1">mc_summary(res</span><span class="s2">, </span><span class="s1">rt=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">rt </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">rt = np.zeros(res.shape[</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">print </span><span class="s5">'RMSE'</span>
        <span class="s1">print np.sqrt(((res-rt)**</span><span class="s4">2</span><span class="s1">).mean(</span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">print </span><span class="s5">'mean bias'</span>
        <span class="s1">print (res-rt).mean(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">print </span><span class="s5">'median bias'</span>
        <span class="s1">print np.median((res-rt)</span><span class="s2">,</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">print </span><span class="s5">'median bias percent'</span>
        <span class="s1">print np.median((res-rt)/rt*</span><span class="s4">100</span><span class="s2">,</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">print </span><span class="s5">'median absolute error'</span>
        <span class="s1">print np.median(np.abs(res-rt)</span><span class="s2">,</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">print </span><span class="s5">'positive error fraction'</span>
        <span class="s1">print (res &gt; rt).mean(</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s1">run_mc = </span><span class="s2">True</span><span class="s3">#False</span>
    <span class="s2">if </span><span class="s1">run_mc:</span>
        <span class="s2">import </span><span class="s1">time</span>
        <span class="s1">t0 = time.time()</span>
        <span class="s1">rt</span><span class="s2">, </span><span class="s1">res_rho</span><span class="s2">, </span><span class="s1">res_bse = mcarma22(niter=</span><span class="s4">1000</span><span class="s1">)</span>
        <span class="s1">print </span><span class="s5">'elapsed time for Monte Carlo'</span><span class="s2">, </span><span class="s1">time.time()-t0</span>
        <span class="s3"># 20 seconds for ARMA(2,2), 1000 iterations with 1000 observations</span>
        <span class="s1">sige2a = np.sqrt(np.dot(err2a</span><span class="s2">,</span><span class="s1">err2a)/nsample)</span>
        <span class="s1">print </span><span class="s5">'</span><span class="s2">\n</span><span class="s5">bse of one sample'</span>
        <span class="s1">print sige2a * np.sqrt(np.diag(cov_x2a))</span>
        <span class="s1">print </span><span class="s5">'</span><span class="s2">\n</span><span class="s5">MC of rho versus true'</span>
        <span class="s1">mc_summary(res_rho</span><span class="s2">, </span><span class="s1">rt)</span>
        <span class="s1">print </span><span class="s5">'</span><span class="s2">\n</span><span class="s5">MC of bse versus zero'</span>
        <span class="s1">mc_summary(res_bse)</span>
        <span class="s1">print </span><span class="s5">'</span><span class="s2">\n</span><span class="s5">MC of bse versus std'</span>
        <span class="s1">mc_summary(res_bse</span><span class="s2">, </span><span class="s1">res_rho.std(</span><span class="s4">0</span><span class="s1">))</span>
    
    <span class="s2">import </span><span class="s1">matplotlib.pyplot </span><span class="s2">as </span><span class="s1">plt</span>
    <span class="s1">plt.plot(arest2.forecast()[-</span><span class="s4">100</span><span class="s1">:])</span>
    <span class="s3">#plt.show()</span>

    <span class="s1">ar1</span><span class="s2">, </span><span class="s1">ar2 = ([</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">])</span>
    <span class="s1">ar2 = [</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">lagpolyproduct = np.convolve(ar1</span><span class="s2">, </span><span class="s1">ar2)</span>
    <span class="s1">print deconvolve(lagpolyproduct</span><span class="s2">, </span><span class="s1">ar2</span><span class="s2">, </span><span class="s1">n=</span><span class="s2">None</span><span class="s1">)</span>
    <span class="s1">print signal.deconvolve(lagpolyproduct</span><span class="s2">, </span><span class="s1">ar2)</span>
    <span class="s1">print deconvolve(lagpolyproduct</span><span class="s2">, </span><span class="s1">ar2</span><span class="s2">, </span><span class="s1">n=</span><span class="s4">10</span><span class="s1">)</span>

</pre>
</body>
</html>