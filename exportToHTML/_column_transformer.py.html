<html>
<head>
<title>_column_transformer.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_column_transformer.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
The :mod:`sklearn.compose._column_transformer` module implements utilities 
to work with heterogeneous data and to apply different transformers to 
different columns. 
&quot;&quot;&quot;</span>
<span class="s2"># Author: Andreas Mueller</span>
<span class="s2">#         Joris Van den Bossche</span>
<span class="s2"># License: BSD</span>
<span class="s3">from </span><span class="s1">collections </span><span class="s3">import </span><span class="s1">Counter</span>
<span class="s3">from </span><span class="s1">itertools </span><span class="s3">import </span><span class="s1">chain</span>
<span class="s3">from </span><span class="s1">numbers </span><span class="s3">import </span><span class="s1">Integral</span><span class="s3">, </span><span class="s1">Real</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">scipy </span><span class="s3">import </span><span class="s1">sparse</span>

<span class="s3">from </span><span class="s1">..base </span><span class="s3">import </span><span class="s1">TransformerMixin</span><span class="s3">, </span><span class="s1">_fit_context</span><span class="s3">, </span><span class="s1">clone</span>
<span class="s3">from </span><span class="s1">..pipeline </span><span class="s3">import </span><span class="s1">_fit_transform_one</span><span class="s3">, </span><span class="s1">_name_estimators</span><span class="s3">, </span><span class="s1">_transform_one</span>
<span class="s3">from </span><span class="s1">..preprocessing </span><span class="s3">import </span><span class="s1">FunctionTransformer</span>
<span class="s3">from </span><span class="s1">..utils </span><span class="s3">import </span><span class="s1">Bunch</span><span class="s3">, </span><span class="s1">_get_column_indices</span><span class="s3">, </span><span class="s1">_safe_indexing</span><span class="s3">, </span><span class="s1">check_pandas_support</span>
<span class="s3">from </span><span class="s1">..utils._estimator_html_repr </span><span class="s3">import </span><span class="s1">_VisualBlock</span>
<span class="s3">from </span><span class="s1">..utils._param_validation </span><span class="s3">import </span><span class="s1">HasMethods</span><span class="s3">, </span><span class="s1">Hidden</span><span class="s3">, </span><span class="s1">Interval</span><span class="s3">, </span><span class="s1">StrOptions</span>
<span class="s3">from </span><span class="s1">..utils._set_output </span><span class="s3">import </span><span class="s1">_get_output_config</span><span class="s3">, </span><span class="s1">_safe_set_output</span>
<span class="s3">from </span><span class="s1">..utils.metaestimators </span><span class="s3">import </span><span class="s1">_BaseComposition</span>
<span class="s3">from </span><span class="s1">..utils.parallel </span><span class="s3">import </span><span class="s1">Parallel</span><span class="s3">, </span><span class="s1">delayed</span>
<span class="s3">from </span><span class="s1">..utils.validation </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">_check_feature_names_in</span><span class="s3">,</span>
    <span class="s1">_num_samples</span><span class="s3">,</span>
    <span class="s1">check_array</span><span class="s3">,</span>
    <span class="s1">check_is_fitted</span><span class="s3">,</span>
<span class="s1">)</span>

<span class="s1">__all__ = [</span><span class="s4">&quot;ColumnTransformer&quot;</span><span class="s3">, </span><span class="s4">&quot;make_column_transformer&quot;</span><span class="s3">, </span><span class="s4">&quot;make_column_selector&quot;</span><span class="s1">]</span>


<span class="s1">_ERR_MSG_1DCOLUMN = (</span>
    <span class="s4">&quot;1D data passed to a transformer that expects 2D data. &quot;</span>
    <span class="s4">&quot;Try to specify the column selection as a list of one &quot;</span>
    <span class="s4">&quot;item instead of a scalar.&quot;</span>
<span class="s1">)</span>


<span class="s3">class </span><span class="s1">ColumnTransformer(TransformerMixin</span><span class="s3">, </span><span class="s1">_BaseComposition):</span>
    <span class="s0">&quot;&quot;&quot;Applies transformers to columns of an array or pandas DataFrame. 
 
    This estimator allows different columns or column subsets of the input 
    to be transformed separately and the features generated by each transformer 
    will be concatenated to form a single feature space. 
    This is useful for heterogeneous or columnar data, to combine several 
    feature extraction mechanisms or transformations into a single transformer. 
 
    Read more in the :ref:`User Guide &lt;column_transformer&gt;`. 
 
    .. versionadded:: 0.20 
 
    Parameters 
    ---------- 
    transformers : list of tuples 
        List of (name, transformer, columns) tuples specifying the 
        transformer objects to be applied to subsets of the data. 
 
        name : str 
            Like in Pipeline and FeatureUnion, this allows the transformer and 
            its parameters to be set using ``set_params`` and searched in grid 
            search. 
        transformer : {'drop', 'passthrough'} or estimator 
            Estimator must support :term:`fit` and :term:`transform`. 
            Special-cased strings 'drop' and 'passthrough' are accepted as 
            well, to indicate to drop the columns or to pass them through 
            untransformed, respectively. 
        columns :  str, array-like of str, int, array-like of int, \ 
                array-like of bool, slice or callable 
            Indexes the data on its second axis. Integers are interpreted as 
            positional columns, while strings can reference DataFrame columns 
            by name.  A scalar string or int should be used where 
            ``transformer`` expects X to be a 1d array-like (vector), 
            otherwise a 2d array will be passed to the transformer. 
            A callable is passed the input data `X` and can return any of the 
            above. To select multiple columns by name or dtype, you can use 
            :obj:`make_column_selector`. 
 
    remainder : {'drop', 'passthrough'} or estimator, default='drop' 
        By default, only the specified columns in `transformers` are 
        transformed and combined in the output, and the non-specified 
        columns are dropped. (default of ``'drop'``). 
        By specifying ``remainder='passthrough'``, all remaining columns that 
        were not specified in `transformers`, but present in the data passed 
        to `fit` will be automatically passed through. This subset of columns 
        is concatenated with the output of the transformers. For dataframes, 
        extra columns not seen during `fit` will be excluded from the output 
        of `transform`. 
        By setting ``remainder`` to be an estimator, the remaining 
        non-specified columns will use the ``remainder`` estimator. The 
        estimator must support :term:`fit` and :term:`transform`. 
        Note that using this feature requires that the DataFrame columns 
        input at :term:`fit` and :term:`transform` have identical order. 
 
    sparse_threshold : float, default=0.3 
        If the output of the different transformers contains sparse matrices, 
        these will be stacked as a sparse matrix if the overall density is 
        lower than this value. Use ``sparse_threshold=0`` to always return 
        dense.  When the transformed output consists of all dense data, the 
        stacked result will be dense, and this keyword will be ignored. 
 
    n_jobs : int, default=None 
        Number of jobs to run in parallel. 
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. 
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;` 
        for more details. 
 
    transformer_weights : dict, default=None 
        Multiplicative weights for features per transformer. The output of the 
        transformer is multiplied by these weights. Keys are transformer names, 
        values the weights. 
 
    verbose : bool, default=False 
        If True, the time elapsed while fitting each transformer will be 
        printed as it is completed. 
 
    verbose_feature_names_out : bool, default=True 
        If True, :meth:`ColumnTransformer.get_feature_names_out` will prefix 
        all feature names with the name of the transformer that generated that 
        feature. 
        If False, :meth:`ColumnTransformer.get_feature_names_out` will not 
        prefix any feature names and will error if feature names are not 
        unique. 
 
        .. versionadded:: 1.0 
 
    Attributes 
    ---------- 
    transformers_ : list 
        The collection of fitted transformers as tuples of 
        (name, fitted_transformer, column). `fitted_transformer` can be an 
        estimator, 'drop', or 'passthrough'. In case there were no columns 
        selected, this will be the unfitted transformer. 
        If there are remaining columns, the final element is a tuple of the 
        form: 
        ('remainder', transformer, remaining_columns) corresponding to the 
        ``remainder`` parameter. If there are remaining columns, then 
        ``len(transformers_)==len(transformers)+1``, otherwise 
        ``len(transformers_)==len(transformers)``. 
 
    named_transformers_ : :class:`~sklearn.utils.Bunch` 
        Read-only attribute to access any transformer by given name. 
        Keys are transformer names and values are the fitted transformer 
        objects. 
 
    sparse_output_ : bool 
        Boolean flag indicating whether the output of ``transform`` is a 
        sparse matrix or a dense numpy array, which depends on the output 
        of the individual transformers and the `sparse_threshold` keyword. 
 
    output_indices_ : dict 
        A dictionary from each transformer name to a slice, where the slice 
        corresponds to indices in the transformed output. This is useful to 
        inspect which transformer is responsible for which transformed 
        feature(s). 
 
        .. versionadded:: 1.0 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. Only defined if the 
        underlying transformers expose such an attribute when fit. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
        .. versionadded:: 1.0 
 
    See Also 
    -------- 
    make_column_transformer : Convenience function for 
        combining the outputs of multiple transformer objects applied to 
        column subsets of the original feature space. 
    make_column_selector : Convenience function for selecting 
        columns based on datatype or the columns name with a regex pattern. 
 
    Notes 
    ----- 
    The order of the columns in the transformed feature matrix follows the 
    order of how the columns are specified in the `transformers` list. 
    Columns of the original feature matrix that are not specified are 
    dropped from the resulting transformed feature matrix, unless specified 
    in the `passthrough` keyword. Those columns specified with `passthrough` 
    are added at the right to the output of the transformers. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn.compose import ColumnTransformer 
    &gt;&gt;&gt; from sklearn.preprocessing import Normalizer 
    &gt;&gt;&gt; ct = ColumnTransformer( 
    ...     [(&quot;norm1&quot;, Normalizer(norm='l1'), [0, 1]), 
    ...      (&quot;norm2&quot;, Normalizer(norm='l1'), slice(2, 4))]) 
    &gt;&gt;&gt; X = np.array([[0., 1., 2., 2.], 
    ...               [1., 1., 0., 1.]]) 
    &gt;&gt;&gt; # Normalizer scales each row of X to unit norm. A separate scaling 
    &gt;&gt;&gt; # is applied for the two first and two last elements of each 
    &gt;&gt;&gt; # row independently. 
    &gt;&gt;&gt; ct.fit_transform(X) 
    array([[0. , 1. , 0.5, 0.5], 
           [0.5, 0.5, 0. , 1. ]]) 
 
    :class:`ColumnTransformer` can be configured with a transformer that requires 
    a 1d array by setting the column to a string: 
 
    &gt;&gt;&gt; from sklearn.feature_extraction import FeatureHasher 
    &gt;&gt;&gt; from sklearn.preprocessing import MinMaxScaler 
    &gt;&gt;&gt; import pandas as pd   # doctest: +SKIP 
    &gt;&gt;&gt; X = pd.DataFrame({ 
    ...     &quot;documents&quot;: [&quot;First item&quot;, &quot;second one here&quot;, &quot;Is this the last?&quot;], 
    ...     &quot;width&quot;: [3, 4, 5], 
    ... })  # doctest: +SKIP 
    &gt;&gt;&gt; # &quot;documents&quot; is a string which configures ColumnTransformer to 
    &gt;&gt;&gt; # pass the documents column as a 1d array to the FeatureHasher 
    &gt;&gt;&gt; ct = ColumnTransformer( 
    ...     [(&quot;text_preprocess&quot;, FeatureHasher(input_type=&quot;string&quot;), &quot;documents&quot;), 
    ...      (&quot;num_preprocess&quot;, MinMaxScaler(), [&quot;width&quot;])]) 
    &gt;&gt;&gt; X_trans = ct.fit_transform(X)  # doctest: +SKIP 
 
    For a more detailed example of usage, see 
    :ref:`sphx_glr_auto_examples_compose_plot_column_transformer_mixed_types.py`. 
    &quot;&quot;&quot;</span>

    <span class="s1">_required_parameters = [</span><span class="s4">&quot;transformers&quot;</span><span class="s1">]</span>

    <span class="s1">_parameter_constraints: dict = {</span>
        <span class="s4">&quot;transformers&quot;</span><span class="s1">: [list</span><span class="s3">, </span><span class="s1">Hidden(tuple)]</span><span class="s3">,</span>
        <span class="s4">&quot;remainder&quot;</span><span class="s1">: [</span>
            <span class="s1">StrOptions({</span><span class="s4">&quot;drop&quot;</span><span class="s3">, </span><span class="s4">&quot;passthrough&quot;</span><span class="s1">})</span><span class="s3">,</span>
            <span class="s1">HasMethods([</span><span class="s4">&quot;fit&quot;</span><span class="s3">, </span><span class="s4">&quot;transform&quot;</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">HasMethods([</span><span class="s4">&quot;fit_transform&quot;</span><span class="s3">, </span><span class="s4">&quot;transform&quot;</span><span class="s1">])</span><span class="s3">,</span>
        <span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;sparse_threshold&quot;</span><span class="s1">: [Interval(Real</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">closed=</span><span class="s4">&quot;both&quot;</span><span class="s1">)]</span><span class="s3">,</span>
        <span class="s4">&quot;n_jobs&quot;</span><span class="s1">: [Integral</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;transformer_weights&quot;</span><span class="s1">: [dict</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;verbose&quot;</span><span class="s1">: [</span><span class="s4">&quot;verbose&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;verbose_feature_names_out&quot;</span><span class="s1">: [</span><span class="s4">&quot;boolean&quot;</span><span class="s1">]</span><span class="s3">,</span>
    <span class="s1">}</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">transformers</span><span class="s3">,</span>
        <span class="s1">*</span><span class="s3">,</span>
        <span class="s1">remainder=</span><span class="s4">&quot;drop&quot;</span><span class="s3">,</span>
        <span class="s1">sparse_threshold=</span><span class="s5">0.3</span><span class="s3">,</span>
        <span class="s1">n_jobs=</span><span class="s3">None,</span>
        <span class="s1">transformer_weights=</span><span class="s3">None,</span>
        <span class="s1">verbose=</span><span class="s3">False,</span>
        <span class="s1">verbose_feature_names_out=</span><span class="s3">True,</span>
    <span class="s1">):</span>
        <span class="s1">self.transformers = transformers</span>
        <span class="s1">self.remainder = remainder</span>
        <span class="s1">self.sparse_threshold = sparse_threshold</span>
        <span class="s1">self.n_jobs = n_jobs</span>
        <span class="s1">self.transformer_weights = transformer_weights</span>
        <span class="s1">self.verbose = verbose</span>
        <span class="s1">self.verbose_feature_names_out = verbose_feature_names_out</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">_transformers(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Internal list of transformer only containing the name and 
        transformers, dropping the columns. This is for the implementation 
        of get_params via BaseComposition._get_params which expects lists 
        of tuples of len 2. 
        &quot;&quot;&quot;</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">[(name</span><span class="s3">, </span><span class="s1">trans) </span><span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">trans</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">self.transformers]</span>
        <span class="s3">except </span><span class="s1">(TypeError</span><span class="s3">, </span><span class="s1">ValueError):</span>
            <span class="s3">return </span><span class="s1">self.transformers</span>

    <span class="s1">@_transformers.setter</span>
    <span class="s3">def </span><span class="s1">_transformers(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">self.transformers = [</span>
                <span class="s1">(name</span><span class="s3">, </span><span class="s1">trans</span><span class="s3">, </span><span class="s1">col)</span>
                <span class="s3">for </span><span class="s1">((name</span><span class="s3">, </span><span class="s1">trans)</span><span class="s3">, </span><span class="s1">(_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">col)) </span><span class="s3">in </span><span class="s1">zip(value</span><span class="s3">, </span><span class="s1">self.transformers)</span>
            <span class="s1">]</span>
        <span class="s3">except </span><span class="s1">(TypeError</span><span class="s3">, </span><span class="s1">ValueError):</span>
            <span class="s1">self.transformers = value</span>

    <span class="s3">def </span><span class="s1">set_output(self</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">transform=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Set the output container when `&quot;transform&quot;` and `&quot;fit_transform&quot;` are called. 
 
        Calling `set_output` will set the output of all estimators in `transformers` 
        and `transformers_`. 
 
        Parameters 
        ---------- 
        transform : {&quot;default&quot;, &quot;pandas&quot;}, default=None 
            Configure output of `transform` and `fit_transform`. 
 
            - `&quot;default&quot;`: Default output format of a transformer 
            - `&quot;pandas&quot;`: DataFrame output 
            - `None`: Transform configuration is unchanged 
 
        Returns 
        ------- 
        self : estimator instance 
            Estimator instance. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().set_output(transform=transform)</span>

        <span class="s1">transformers = (</span>
            <span class="s1">trans</span>
            <span class="s3">for </span><span class="s1">_</span><span class="s3">, </span><span class="s1">trans</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">chain(</span>
                <span class="s1">self.transformers</span><span class="s3">, </span><span class="s1">getattr(self</span><span class="s3">, </span><span class="s4">&quot;transformers_&quot;</span><span class="s3">, </span><span class="s1">[])</span>
            <span class="s1">)</span>
            <span class="s3">if </span><span class="s1">trans </span><span class="s3">not in </span><span class="s1">{</span><span class="s4">&quot;passthrough&quot;</span><span class="s3">, </span><span class="s4">&quot;drop&quot;</span><span class="s1">}</span>
        <span class="s1">)</span>
        <span class="s3">for </span><span class="s1">trans </span><span class="s3">in </span><span class="s1">transformers:</span>
            <span class="s1">_safe_set_output(trans</span><span class="s3">, </span><span class="s1">transform=transform)</span>

        <span class="s3">if </span><span class="s1">self.remainder </span><span class="s3">not in </span><span class="s1">{</span><span class="s4">&quot;passthrough&quot;</span><span class="s3">, </span><span class="s4">&quot;drop&quot;</span><span class="s1">}:</span>
            <span class="s1">_safe_set_output(self.remainder</span><span class="s3">, </span><span class="s1">transform=transform)</span>

        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">get_params(self</span><span class="s3">, </span><span class="s1">deep=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Get parameters for this estimator. 
 
        Returns the parameters given in the constructor as well as the 
        estimators contained within the `transformers` of the 
        `ColumnTransformer`. 
 
        Parameters 
        ---------- 
        deep : bool, default=True 
            If True, will return the parameters for this estimator and 
            contained subobjects that are estimators. 
 
        Returns 
        ------- 
        params : dict 
            Parameter names mapped to their values. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._get_params(</span><span class="s4">&quot;_transformers&quot;</span><span class="s3">, </span><span class="s1">deep=deep)</span>

    <span class="s3">def </span><span class="s1">set_params(self</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot;Set the parameters of this estimator. 
 
        Valid parameter keys can be listed with ``get_params()``. Note that you 
        can directly set the parameters of the estimators contained in 
        `transformers` of `ColumnTransformer`. 
 
        Parameters 
        ---------- 
        **kwargs : dict 
            Estimator parameters. 
 
        Returns 
        ------- 
        self : ColumnTransformer 
            This estimator. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._set_params(</span><span class="s4">&quot;_transformers&quot;</span><span class="s3">, </span><span class="s1">**kwargs)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_iter(self</span><span class="s3">, </span><span class="s1">fitted=</span><span class="s3">False, </span><span class="s1">replace_strings=</span><span class="s3">False, </span><span class="s1">column_as_strings=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Generate (name, trans, column, weight) tuples. 
 
        If fitted=True, use the fitted transformers, else use the 
        user specified transformers updated with converted column names 
        and potentially appended with transformer for remainder. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">fitted:</span>
            <span class="s3">if </span><span class="s1">replace_strings:</span>
                <span class="s2"># Replace &quot;passthrough&quot; with the fitted version in</span>
                <span class="s2"># _name_to_fitted_passthrough</span>
                <span class="s3">def </span><span class="s1">replace_passthrough(name</span><span class="s3">, </span><span class="s1">trans</span><span class="s3">, </span><span class="s1">columns):</span>
                    <span class="s3">if </span><span class="s1">name </span><span class="s3">not in </span><span class="s1">self._name_to_fitted_passthrough:</span>
                        <span class="s3">return </span><span class="s1">name</span><span class="s3">, </span><span class="s1">trans</span><span class="s3">, </span><span class="s1">columns</span>
                    <span class="s3">return </span><span class="s1">name</span><span class="s3">, </span><span class="s1">self._name_to_fitted_passthrough[name]</span><span class="s3">, </span><span class="s1">columns</span>

                <span class="s1">transformers = [</span>
                    <span class="s1">replace_passthrough(*trans) </span><span class="s3">for </span><span class="s1">trans </span><span class="s3">in </span><span class="s1">self.transformers_</span>
                <span class="s1">]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">transformers = self.transformers_</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s2"># interleave the validated column specifiers</span>
            <span class="s1">transformers = [</span>
                <span class="s1">(name</span><span class="s3">, </span><span class="s1">trans</span><span class="s3">, </span><span class="s1">column)</span>
                <span class="s3">for </span><span class="s1">(name</span><span class="s3">, </span><span class="s1">trans</span><span class="s3">, </span><span class="s1">_)</span><span class="s3">, </span><span class="s1">column </span><span class="s3">in </span><span class="s1">zip(self.transformers</span><span class="s3">, </span><span class="s1">self._columns)</span>
            <span class="s1">]</span>
            <span class="s2"># add transformer tuple for remainder</span>
            <span class="s3">if </span><span class="s1">self._remainder[</span><span class="s5">2</span><span class="s1">]:</span>
                <span class="s1">transformers = chain(transformers</span><span class="s3">, </span><span class="s1">[self._remainder])</span>
        <span class="s1">get_weight = (self.transformer_weights </span><span class="s3">or </span><span class="s1">{}).get</span>

        <span class="s1">output_config = _get_output_config(</span><span class="s4">&quot;transform&quot;</span><span class="s3">, </span><span class="s1">self)</span>
        <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">trans</span><span class="s3">, </span><span class="s1">columns </span><span class="s3">in </span><span class="s1">transformers:</span>
            <span class="s3">if </span><span class="s1">replace_strings:</span>
                <span class="s2"># replace 'passthrough' with identity transformer and</span>
                <span class="s2"># skip in case of 'drop'</span>
                <span class="s3">if </span><span class="s1">trans == </span><span class="s4">&quot;passthrough&quot;</span><span class="s1">:</span>
                    <span class="s1">trans = FunctionTransformer(</span>
                        <span class="s1">accept_sparse=</span><span class="s3">True,</span>
                        <span class="s1">check_inverse=</span><span class="s3">False,</span>
                        <span class="s1">feature_names_out=</span><span class="s4">&quot;one-to-one&quot;</span><span class="s3">,</span>
                    <span class="s1">).set_output(transform=output_config[</span><span class="s4">&quot;dense&quot;</span><span class="s1">])</span>
                <span class="s3">elif </span><span class="s1">trans == </span><span class="s4">&quot;drop&quot;</span><span class="s1">:</span>
                    <span class="s3">continue</span>
                <span class="s3">elif </span><span class="s1">_is_empty_column_selection(columns):</span>
                    <span class="s3">continue</span>

            <span class="s3">if </span><span class="s1">column_as_strings:</span>
                <span class="s2"># Convert all columns to using their string labels</span>
                <span class="s1">columns_is_scalar = np.isscalar(columns)</span>

                <span class="s1">indices = self._transformer_to_input_indices[name]</span>
                <span class="s1">columns = self.feature_names_in_[indices]</span>

                <span class="s3">if </span><span class="s1">columns_is_scalar:</span>
                    <span class="s2"># selection is done with one dimension</span>
                    <span class="s1">columns = columns[</span><span class="s5">0</span><span class="s1">]</span>

            <span class="s3">yield </span><span class="s1">(name</span><span class="s3">, </span><span class="s1">trans</span><span class="s3">, </span><span class="s1">columns</span><span class="s3">, </span><span class="s1">get_weight(name))</span>

    <span class="s3">def </span><span class="s1">_validate_transformers(self):</span>
        <span class="s3">if not </span><span class="s1">self.transformers:</span>
            <span class="s3">return</span>

        <span class="s1">names</span><span class="s3">, </span><span class="s1">transformers</span><span class="s3">, </span><span class="s1">_ = zip(*self.transformers)</span>

        <span class="s2"># validate names</span>
        <span class="s1">self._validate_names(names)</span>

        <span class="s2"># validate estimators</span>
        <span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">transformers:</span>
            <span class="s3">if </span><span class="s1">t </span><span class="s3">in </span><span class="s1">(</span><span class="s4">&quot;drop&quot;</span><span class="s3">, </span><span class="s4">&quot;passthrough&quot;</span><span class="s1">):</span>
                <span class="s3">continue</span>
            <span class="s3">if not </span><span class="s1">(hasattr(t</span><span class="s3">, </span><span class="s4">&quot;fit&quot;</span><span class="s1">) </span><span class="s3">or </span><span class="s1">hasattr(t</span><span class="s3">, </span><span class="s4">&quot;fit_transform&quot;</span><span class="s1">)) </span><span class="s3">or not </span><span class="s1">hasattr(</span>
                <span class="s1">t</span><span class="s3">, </span><span class="s4">&quot;transform&quot;</span>
            <span class="s1">):</span>
                <span class="s2"># Used to validate the transformers in the `transformers` list</span>
                <span class="s3">raise </span><span class="s1">TypeError(</span>
                    <span class="s4">&quot;All estimators should implement fit and &quot;</span>
                    <span class="s4">&quot;transform, or can be 'drop' or 'passthrough' &quot;</span>
                    <span class="s4">&quot;specifiers. '%s' (type %s) doesn't.&quot; </span><span class="s1">% (t</span><span class="s3">, </span><span class="s1">type(t))</span>
                <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_validate_column_callables(self</span><span class="s3">, </span><span class="s1">X):</span>
        <span class="s0">&quot;&quot;&quot; 
        Converts callable column specifications. 
        &quot;&quot;&quot;</span>
        <span class="s1">all_columns = []</span>
        <span class="s1">transformer_to_input_indices = {}</span>
        <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">columns </span><span class="s3">in </span><span class="s1">self.transformers:</span>
            <span class="s3">if </span><span class="s1">callable(columns):</span>
                <span class="s1">columns = columns(X)</span>
            <span class="s1">all_columns.append(columns)</span>
            <span class="s1">transformer_to_input_indices[name] = _get_column_indices(X</span><span class="s3">, </span><span class="s1">columns)</span>

        <span class="s1">self._columns = all_columns</span>
        <span class="s1">self._transformer_to_input_indices = transformer_to_input_indices</span>

    <span class="s3">def </span><span class="s1">_validate_remainder(self</span><span class="s3">, </span><span class="s1">X):</span>
        <span class="s0">&quot;&quot;&quot; 
        Validates ``remainder`` and defines ``_remainder`` targeting 
        the remaining columns. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._n_features = X.shape[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">cols = set(chain(*self._transformer_to_input_indices.values()))</span>
        <span class="s1">remaining = sorted(set(range(self._n_features)) - cols)</span>
        <span class="s1">self._remainder = (</span><span class="s4">&quot;remainder&quot;</span><span class="s3">, </span><span class="s1">self.remainder</span><span class="s3">, </span><span class="s1">remaining)</span>
        <span class="s1">self._transformer_to_input_indices[</span><span class="s4">&quot;remainder&quot;</span><span class="s1">] = remaining</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">named_transformers_(self):</span>
        <span class="s0">&quot;&quot;&quot;Access the fitted transformer by name. 
 
        Read-only attribute to access any transformer by given name. 
        Keys are transformer names and values are the fitted transformer 
        objects. 
        &quot;&quot;&quot;</span>
        <span class="s2"># Use Bunch object to improve autocomplete</span>
        <span class="s3">return </span><span class="s1">Bunch(**{name: trans </span><span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">trans</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">self.transformers_})</span>

    <span class="s3">def </span><span class="s1">_get_feature_name_out_for_transformer(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">trans</span><span class="s3">, </span><span class="s1">column</span><span class="s3">, </span><span class="s1">feature_names_in</span>
    <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Gets feature names of transformer. 
 
        Used in conjunction with self._iter(fitted=True) in get_feature_names_out. 
        &quot;&quot;&quot;</span>
        <span class="s1">column_indices = self._transformer_to_input_indices[name]</span>
        <span class="s1">names = feature_names_in[column_indices]</span>
        <span class="s3">if </span><span class="s1">trans == </span><span class="s4">&quot;drop&quot; </span><span class="s3">or </span><span class="s1">_is_empty_column_selection(column):</span>
            <span class="s3">return</span>
        <span class="s3">elif </span><span class="s1">trans == </span><span class="s4">&quot;passthrough&quot;</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">names</span>

        <span class="s2"># An actual transformer</span>
        <span class="s3">if not </span><span class="s1">hasattr(trans</span><span class="s3">, </span><span class="s4">&quot;get_feature_names_out&quot;</span><span class="s1">):</span>
            <span class="s3">raise </span><span class="s1">AttributeError(</span>
                <span class="s4">f&quot;Transformer </span><span class="s3">{</span><span class="s1">name</span><span class="s3">} </span><span class="s4">(type </span><span class="s3">{</span><span class="s1">type(trans).__name__</span><span class="s3">}</span><span class="s4">) does &quot;</span>
                <span class="s4">&quot;not provide get_feature_names_out.&quot;</span>
            <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">trans.get_feature_names_out(names)</span>

    <span class="s3">def </span><span class="s1">get_feature_names_out(self</span><span class="s3">, </span><span class="s1">input_features=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Get output feature names for transformation. 
 
        Parameters 
        ---------- 
        input_features : array-like of str or None, default=None 
            Input features. 
 
            - If `input_features` is `None`, then `feature_names_in_` is 
              used as feature names in. If `feature_names_in_` is not defined, 
              then the following input feature names are generated: 
              `[&quot;x0&quot;, &quot;x1&quot;, ..., &quot;x(n_features_in_ - 1)&quot;]`. 
            - If `input_features` is an array-like, then `input_features` must 
              match `feature_names_in_` if `feature_names_in_` is defined. 
 
        Returns 
        ------- 
        feature_names_out : ndarray of str objects 
            Transformed feature names. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted(self)</span>
        <span class="s1">input_features = _check_feature_names_in(self</span><span class="s3">, </span><span class="s1">input_features)</span>

        <span class="s2"># List of tuples (name, feature_names_out)</span>
        <span class="s1">transformer_with_feature_names_out = []</span>
        <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">trans</span><span class="s3">, </span><span class="s1">column</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">self._iter(fitted=</span><span class="s3">True</span><span class="s1">):</span>
            <span class="s1">feature_names_out = self._get_feature_name_out_for_transformer(</span>
                <span class="s1">name</span><span class="s3">, </span><span class="s1">trans</span><span class="s3">, </span><span class="s1">column</span><span class="s3">, </span><span class="s1">input_features</span>
            <span class="s1">)</span>
            <span class="s3">if </span><span class="s1">feature_names_out </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">continue</span>
            <span class="s1">transformer_with_feature_names_out.append((name</span><span class="s3">, </span><span class="s1">feature_names_out))</span>

        <span class="s3">if not </span><span class="s1">transformer_with_feature_names_out:</span>
            <span class="s2"># No feature names</span>
            <span class="s3">return </span><span class="s1">np.array([]</span><span class="s3">, </span><span class="s1">dtype=object)</span>

        <span class="s3">return </span><span class="s1">self._add_prefix_for_feature_names_out(</span>
            <span class="s1">transformer_with_feature_names_out</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_add_prefix_for_feature_names_out(self</span><span class="s3">, </span><span class="s1">transformer_with_feature_names_out):</span>
        <span class="s0">&quot;&quot;&quot;Add prefix for feature names out that includes the transformer names. 
 
        Parameters 
        ---------- 
        transformer_with_feature_names_out : list of tuples of (str, array-like of str) 
            The tuple consistent of the transformer's name and its feature names out. 
 
        Returns 
        ------- 
        feature_names_out : ndarray of shape (n_features,), dtype=str 
            Transformed feature names. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self.verbose_feature_names_out:</span>
            <span class="s2"># Prefix the feature names out with the transformers name</span>
            <span class="s1">names = list(</span>
                <span class="s1">chain.from_iterable(</span>
                    <span class="s1">(</span><span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">__</span><span class="s3">{</span><span class="s1">i</span><span class="s3">}</span><span class="s4">&quot; </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">feature_names_out)</span>
                    <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">feature_names_out </span><span class="s3">in </span><span class="s1">transformer_with_feature_names_out</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s3">return </span><span class="s1">np.asarray(names</span><span class="s3">, </span><span class="s1">dtype=object)</span>

        <span class="s2"># verbose_feature_names_out is False</span>
        <span class="s2"># Check that names are all unique without a prefix</span>
        <span class="s1">feature_names_count = Counter(</span>
            <span class="s1">chain.from_iterable(s </span><span class="s3">for </span><span class="s1">_</span><span class="s3">, </span><span class="s1">s </span><span class="s3">in </span><span class="s1">transformer_with_feature_names_out)</span>
        <span class="s1">)</span>
        <span class="s1">top_6_overlap = [</span>
            <span class="s1">name </span><span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">count </span><span class="s3">in </span><span class="s1">feature_names_count.most_common(</span><span class="s5">6</span><span class="s1">) </span><span class="s3">if </span><span class="s1">count &gt; </span><span class="s5">1</span>
        <span class="s1">]</span>
        <span class="s1">top_6_overlap.sort()</span>
        <span class="s3">if </span><span class="s1">top_6_overlap:</span>
            <span class="s3">if </span><span class="s1">len(top_6_overlap) == </span><span class="s5">6</span><span class="s1">:</span>
                <span class="s2"># There are more than 5 overlapping names, we only show the 5</span>
                <span class="s2"># of the feature names</span>
                <span class="s1">names_repr = str(top_6_overlap[:</span><span class="s5">5</span><span class="s1">])[:-</span><span class="s5">1</span><span class="s1">] + </span><span class="s4">&quot;, ...]&quot;</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">names_repr = str(top_6_overlap)</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">f&quot;Output feature names: </span><span class="s3">{</span><span class="s1">names_repr</span><span class="s3">} </span><span class="s4">are not unique. Please set &quot;</span>
                <span class="s4">&quot;verbose_feature_names_out=True to add prefixes to feature names&quot;</span>
            <span class="s1">)</span>

        <span class="s3">return </span><span class="s1">np.concatenate(</span>
            <span class="s1">[name </span><span class="s3">for </span><span class="s1">_</span><span class="s3">, </span><span class="s1">name </span><span class="s3">in </span><span class="s1">transformer_with_feature_names_out]</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_update_fitted_transformers(self</span><span class="s3">, </span><span class="s1">transformers):</span>
        <span class="s2"># transformers are fitted; excludes 'drop' cases</span>
        <span class="s1">fitted_transformers = iter(transformers)</span>
        <span class="s1">transformers_ = []</span>
        <span class="s1">self._name_to_fitted_passthrough = {}</span>

        <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">old</span><span class="s3">, </span><span class="s1">column</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">self._iter():</span>
            <span class="s3">if </span><span class="s1">old == </span><span class="s4">&quot;drop&quot;</span><span class="s1">:</span>
                <span class="s1">trans = </span><span class="s4">&quot;drop&quot;</span>
            <span class="s3">elif </span><span class="s1">old == </span><span class="s4">&quot;passthrough&quot;</span><span class="s1">:</span>
                <span class="s2"># FunctionTransformer is present in list of transformers,</span>
                <span class="s2"># so get next transformer, but save original string</span>
                <span class="s1">func_transformer = next(fitted_transformers)</span>
                <span class="s1">trans = </span><span class="s4">&quot;passthrough&quot;</span>

                <span class="s2"># The fitted FunctionTransformer is saved in another attribute,</span>
                <span class="s2"># so it can be used during transform for set_output.</span>
                <span class="s1">self._name_to_fitted_passthrough[name] = func_transformer</span>
            <span class="s3">elif </span><span class="s1">_is_empty_column_selection(column):</span>
                <span class="s1">trans = old</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">trans = next(fitted_transformers)</span>
            <span class="s1">transformers_.append((name</span><span class="s3">, </span><span class="s1">trans</span><span class="s3">, </span><span class="s1">column))</span>

        <span class="s2"># sanity check that transformers is exhausted</span>
        <span class="s3">assert not </span><span class="s1">list(fitted_transformers)</span>
        <span class="s1">self.transformers_ = transformers_</span>

    <span class="s3">def </span><span class="s1">_validate_output(self</span><span class="s3">, </span><span class="s1">result):</span>
        <span class="s0">&quot;&quot;&quot; 
        Ensure that the output of each transformer is 2D. Otherwise 
        hstack can raise an error or produce incorrect results. 
        &quot;&quot;&quot;</span>
        <span class="s1">names = [</span>
            <span class="s1">name </span><span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">self._iter(fitted=</span><span class="s3">True, </span><span class="s1">replace_strings=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s1">]</span>
        <span class="s3">for </span><span class="s1">Xs</span><span class="s3">, </span><span class="s1">name </span><span class="s3">in </span><span class="s1">zip(result</span><span class="s3">, </span><span class="s1">names):</span>
            <span class="s3">if not </span><span class="s1">getattr(Xs</span><span class="s3">, </span><span class="s4">&quot;ndim&quot;</span><span class="s3">, </span><span class="s5">0</span><span class="s1">) == </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;The output of the '{0}' transformer should be 2D (scipy &quot;</span>
                    <span class="s4">&quot;matrix, array, or pandas DataFrame).&quot;</span><span class="s1">.format(name)</span>
                <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_record_output_indices(self</span><span class="s3">, </span><span class="s1">Xs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Record which transformer produced which column. 
        &quot;&quot;&quot;</span>
        <span class="s1">idx = </span><span class="s5">0</span>
        <span class="s1">self.output_indices_ = {}</span>

        <span class="s3">for </span><span class="s1">transformer_idx</span><span class="s3">, </span><span class="s1">(name</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_) </span><span class="s3">in </span><span class="s1">enumerate(</span>
            <span class="s1">self._iter(fitted=</span><span class="s3">True, </span><span class="s1">replace_strings=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s1">n_columns = Xs[transformer_idx].shape[</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">self.output_indices_[name] = slice(idx</span><span class="s3">, </span><span class="s1">idx + n_columns)</span>
            <span class="s1">idx += n_columns</span>

        <span class="s2"># `_iter` only generates transformers that have a non empty</span>
        <span class="s2"># selection. Here we set empty slices for transformers that</span>
        <span class="s2"># generate no output, which are safe for indexing</span>
        <span class="s1">all_names = [t[</span><span class="s5">0</span><span class="s1">] </span><span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">self.transformers] + [</span><span class="s4">&quot;remainder&quot;</span><span class="s1">]</span>
        <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">all_names:</span>
            <span class="s3">if </span><span class="s1">name </span><span class="s3">not in </span><span class="s1">self.output_indices_:</span>
                <span class="s1">self.output_indices_[name] = slice(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_log_message(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">total):</span>
        <span class="s3">if not </span><span class="s1">self.verbose:</span>
            <span class="s3">return None</span>
        <span class="s3">return </span><span class="s4">&quot;(%d of %d) Processing %s&quot; </span><span class="s1">% (idx</span><span class="s3">, </span><span class="s1">total</span><span class="s3">, </span><span class="s1">name)</span>

    <span class="s3">def </span><span class="s1">_fit_transform(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">fitted=</span><span class="s3">False, </span><span class="s1">column_as_strings=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Private function to fit and/or transform on demand. 
 
        Return value (transformers and/or transformed X data) depends 
        on the passed function. 
        ``fitted=True`` ensures the fitted transformers are used. 
        &quot;&quot;&quot;</span>
        <span class="s1">transformers = list(</span>
            <span class="s1">self._iter(</span>
                <span class="s1">fitted=fitted</span><span class="s3">, </span><span class="s1">replace_strings=</span><span class="s3">True, </span><span class="s1">column_as_strings=column_as_strings</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">Parallel(n_jobs=self.n_jobs)(</span>
                <span class="s1">delayed(func)(</span>
                    <span class="s1">transformer=clone(trans) </span><span class="s3">if not </span><span class="s1">fitted </span><span class="s3">else </span><span class="s1">trans</span><span class="s3">,</span>
                    <span class="s1">X=_safe_indexing(X</span><span class="s3">, </span><span class="s1">column</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">1</span><span class="s1">)</span><span class="s3">,</span>
                    <span class="s1">y=y</span><span class="s3">,</span>
                    <span class="s1">weight=weight</span><span class="s3">,</span>
                    <span class="s1">message_clsname=</span><span class="s4">&quot;ColumnTransformer&quot;</span><span class="s3">,</span>
                    <span class="s1">message=self._log_message(name</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">len(transformers))</span><span class="s3">,</span>
                <span class="s1">)</span>
                <span class="s3">for </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">(name</span><span class="s3">, </span><span class="s1">trans</span><span class="s3">, </span><span class="s1">column</span><span class="s3">, </span><span class="s1">weight) </span><span class="s3">in </span><span class="s1">enumerate(transformers</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s3">except </span><span class="s1">ValueError </span><span class="s3">as </span><span class="s1">e:</span>
            <span class="s3">if </span><span class="s4">&quot;Expected 2D array, got 1D array instead&quot; </span><span class="s3">in </span><span class="s1">str(e):</span>
                <span class="s3">raise </span><span class="s1">ValueError(_ERR_MSG_1DCOLUMN) </span><span class="s3">from </span><span class="s1">e</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise</span>

    <span class="s3">def </span><span class="s1">fit(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Fit all transformers using X. 
 
        Parameters 
        ---------- 
        X : {array-like, dataframe} of shape (n_samples, n_features) 
            Input data, of which specified subsets are used to fit the 
            transformers. 
 
        y : array-like of shape (n_samples,...), default=None 
            Targets for supervised learning. 
 
        Returns 
        ------- 
        self : ColumnTransformer 
            This estimator. 
        &quot;&quot;&quot;</span>
        <span class="s2"># we use fit_transform to make sure to set sparse_output_ (for which we</span>
        <span class="s2"># need the transformed data) to have consistent output type in predict</span>
        <span class="s1">self.fit_transform(X</span><span class="s3">, </span><span class="s1">y=y)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s1">@_fit_context(</span>
        <span class="s2"># estimators in ColumnTransformer.transformers are not validated yet</span>
        <span class="s1">prefer_skip_nested_validation=</span><span class="s3">False</span>
    <span class="s1">)</span>
    <span class="s3">def </span><span class="s1">fit_transform(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Fit all transformers, transform the data and concatenate results. 
 
        Parameters 
        ---------- 
        X : {array-like, dataframe} of shape (n_samples, n_features) 
            Input data, of which specified subsets are used to fit the 
            transformers. 
 
        y : array-like of shape (n_samples,), default=None 
            Targets for supervised learning. 
 
        Returns 
        ------- 
        X_t : {array-like, sparse matrix} of \ 
                shape (n_samples, sum_n_components) 
            Horizontally stacked results of transformers. sum_n_components is the 
            sum of n_components (output dimension) over transformers. If 
            any result is a sparse matrix, everything will be converted to 
            sparse matrices. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._check_feature_names(X</span><span class="s3">, </span><span class="s1">reset=</span><span class="s3">True</span><span class="s1">)</span>

        <span class="s1">X = _check_X(X)</span>
        <span class="s2"># set n_features_in_ attribute</span>
        <span class="s1">self._check_n_features(X</span><span class="s3">, </span><span class="s1">reset=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s1">self._validate_transformers()</span>
        <span class="s1">self._validate_column_callables(X)</span>
        <span class="s1">self._validate_remainder(X)</span>

        <span class="s1">result = self._fit_transform(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">_fit_transform_one)</span>

        <span class="s3">if not </span><span class="s1">result:</span>
            <span class="s1">self._update_fitted_transformers([])</span>
            <span class="s2"># All transformers are None</span>
            <span class="s3">return </span><span class="s1">np.zeros((X.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s5">0</span><span class="s1">))</span>

        <span class="s1">Xs</span><span class="s3">, </span><span class="s1">transformers = zip(*result)</span>

        <span class="s2"># determine if concatenated output will be sparse or not</span>
        <span class="s3">if </span><span class="s1">any(sparse.issparse(X) </span><span class="s3">for </span><span class="s1">X </span><span class="s3">in </span><span class="s1">Xs):</span>
            <span class="s1">nnz = sum(X.nnz </span><span class="s3">if </span><span class="s1">sparse.issparse(X) </span><span class="s3">else </span><span class="s1">X.size </span><span class="s3">for </span><span class="s1">X </span><span class="s3">in </span><span class="s1">Xs)</span>
            <span class="s1">total = sum(</span>
                <span class="s1">X.shape[</span><span class="s5">0</span><span class="s1">] * X.shape[</span><span class="s5">1</span><span class="s1">] </span><span class="s3">if </span><span class="s1">sparse.issparse(X) </span><span class="s3">else </span><span class="s1">X.size </span><span class="s3">for </span><span class="s1">X </span><span class="s3">in </span><span class="s1">Xs</span>
            <span class="s1">)</span>
            <span class="s1">density = nnz / total</span>
            <span class="s1">self.sparse_output_ = density &lt; self.sparse_threshold</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.sparse_output_ = </span><span class="s3">False</span>

        <span class="s1">self._update_fitted_transformers(transformers)</span>
        <span class="s1">self._validate_output(Xs)</span>
        <span class="s1">self._record_output_indices(Xs)</span>

        <span class="s3">return </span><span class="s1">self._hstack(list(Xs))</span>

    <span class="s3">def </span><span class="s1">transform(self</span><span class="s3">, </span><span class="s1">X):</span>
        <span class="s0">&quot;&quot;&quot;Transform X separately by each transformer, concatenate results. 
 
        Parameters 
        ---------- 
        X : {array-like, dataframe} of shape (n_samples, n_features) 
            The data to be transformed by subset. 
 
        Returns 
        ------- 
        X_t : {array-like, sparse matrix} of \ 
                shape (n_samples, sum_n_components) 
            Horizontally stacked results of transformers. sum_n_components is the 
            sum of n_components (output dimension) over transformers. If 
            any result is a sparse matrix, everything will be converted to 
            sparse matrices. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted(self)</span>
        <span class="s1">X = _check_X(X)</span>

        <span class="s1">fit_dataframe_and_transform_dataframe = hasattr(</span>
            <span class="s1">self</span><span class="s3">, </span><span class="s4">&quot;feature_names_in_&quot;</span>
        <span class="s1">) </span><span class="s3">and </span><span class="s1">hasattr(X</span><span class="s3">, </span><span class="s4">&quot;columns&quot;</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">fit_dataframe_and_transform_dataframe:</span>
            <span class="s1">named_transformers = self.named_transformers_</span>
            <span class="s2"># check that all names seen in fit are in transform, unless</span>
            <span class="s2"># they were dropped</span>
            <span class="s1">non_dropped_indices = [</span>
                <span class="s1">ind</span>
                <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">ind </span><span class="s3">in </span><span class="s1">self._transformer_to_input_indices.items()</span>
                <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">named_transformers</span>
                <span class="s3">and </span><span class="s1">isinstance(named_transformers[name]</span><span class="s3">, </span><span class="s1">str)</span>
                <span class="s3">and </span><span class="s1">named_transformers[name] != </span><span class="s4">&quot;drop&quot;</span>
            <span class="s1">]</span>

            <span class="s1">all_indices = set(chain(*non_dropped_indices))</span>
            <span class="s1">all_names = set(self.feature_names_in_[ind] </span><span class="s3">for </span><span class="s1">ind </span><span class="s3">in </span><span class="s1">all_indices)</span>

            <span class="s1">diff = all_names - set(X.columns)</span>
            <span class="s3">if </span><span class="s1">diff:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;columns are missing: </span><span class="s3">{</span><span class="s1">diff</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s2"># ndarray was used for fitting or transforming, thus we only</span>
            <span class="s2"># check that n_features_in_ is consistent</span>
            <span class="s1">self._check_n_features(X</span><span class="s3">, </span><span class="s1">reset=</span><span class="s3">False</span><span class="s1">)</span>

        <span class="s1">Xs = self._fit_transform(</span>
            <span class="s1">X</span><span class="s3">,</span>
            <span class="s3">None,</span>
            <span class="s1">_transform_one</span><span class="s3">,</span>
            <span class="s1">fitted=</span><span class="s3">True,</span>
            <span class="s1">column_as_strings=fit_dataframe_and_transform_dataframe</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s1">self._validate_output(Xs)</span>

        <span class="s3">if not </span><span class="s1">Xs:</span>
            <span class="s2"># All transformers are None</span>
            <span class="s3">return </span><span class="s1">np.zeros((X.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s5">0</span><span class="s1">))</span>

        <span class="s3">return </span><span class="s1">self._hstack(list(Xs))</span>

    <span class="s3">def </span><span class="s1">_hstack(self</span><span class="s3">, </span><span class="s1">Xs):</span>
        <span class="s0">&quot;&quot;&quot;Stacks Xs horizontally. 
 
        This allows subclasses to control the stacking behavior, while reusing 
        everything else from ColumnTransformer. 
 
        Parameters 
        ---------- 
        Xs : list of {array-like, sparse matrix, dataframe} 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self.sparse_output_:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s2"># since all columns should be numeric before stacking them</span>
                <span class="s2"># in a sparse matrix, `check_array` is used for the</span>
                <span class="s2"># dtype conversion if necessary.</span>
                <span class="s1">converted_Xs = [</span>
                    <span class="s1">check_array(X</span><span class="s3">, </span><span class="s1">accept_sparse=</span><span class="s3">True, </span><span class="s1">force_all_finite=</span><span class="s3">False</span><span class="s1">)</span>
                    <span class="s3">for </span><span class="s1">X </span><span class="s3">in </span><span class="s1">Xs</span>
                <span class="s1">]</span>
            <span class="s3">except </span><span class="s1">ValueError </span><span class="s3">as </span><span class="s1">e:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;For a sparse output, all columns should &quot;</span>
                    <span class="s4">&quot;be a numeric or convertible to a numeric.&quot;</span>
                <span class="s1">) </span><span class="s3">from </span><span class="s1">e</span>

            <span class="s3">return </span><span class="s1">sparse.hstack(converted_Xs).tocsr()</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">Xs = [f.toarray() </span><span class="s3">if </span><span class="s1">sparse.issparse(f) </span><span class="s3">else </span><span class="s1">f </span><span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">Xs]</span>
            <span class="s1">config = _get_output_config(</span><span class="s4">&quot;transform&quot;</span><span class="s3">, </span><span class="s1">self)</span>
            <span class="s3">if </span><span class="s1">config[</span><span class="s4">&quot;dense&quot;</span><span class="s1">] == </span><span class="s4">&quot;pandas&quot; </span><span class="s3">and </span><span class="s1">all(hasattr(X</span><span class="s3">, </span><span class="s4">&quot;iloc&quot;</span><span class="s1">) </span><span class="s3">for </span><span class="s1">X </span><span class="s3">in </span><span class="s1">Xs):</span>
                <span class="s1">pd = check_pandas_support(</span><span class="s4">&quot;transform&quot;</span><span class="s1">)</span>
                <span class="s1">output = pd.concat(Xs</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">1</span><span class="s1">)</span>

                <span class="s1">output_samples = output.shape[</span><span class="s5">0</span><span class="s1">]</span>
                <span class="s3">if </span><span class="s1">any(_num_samples(X) != output_samples </span><span class="s3">for </span><span class="s1">X </span><span class="s3">in </span><span class="s1">Xs):</span>
                    <span class="s3">raise </span><span class="s1">ValueError(</span>
                        <span class="s4">&quot;Concatenating DataFrames from the transformer's output lead to&quot;</span>
                        <span class="s4">&quot; an inconsistent number of samples. The output may have Pandas&quot;</span>
                        <span class="s4">&quot; Indexes that do not match.&quot;</span>
                    <span class="s1">)</span>

                <span class="s2"># If all transformers define `get_feature_names_out`, then transform</span>
                <span class="s2"># will adjust the column names to be consistent with</span>
                <span class="s2"># verbose_feature_names_out. Here we prefix the feature names if</span>
                <span class="s2"># verbose_feature_names_out=True.</span>

                <span class="s3">if not </span><span class="s1">self.verbose_feature_names_out:</span>
                    <span class="s3">return </span><span class="s1">output</span>

                <span class="s1">transformer_names = [</span>
                    <span class="s1">t[</span><span class="s5">0</span><span class="s1">] </span><span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">self._iter(fitted=</span><span class="s3">True, </span><span class="s1">replace_strings=</span><span class="s3">True</span><span class="s1">)</span>
                <span class="s1">]</span>
                <span class="s2"># Selection of columns might be empty.</span>
                <span class="s2"># Hence feature names are filtered for non-emptiness.</span>
                <span class="s1">feature_names_outs = [X.columns </span><span class="s3">for </span><span class="s1">X </span><span class="s3">in </span><span class="s1">Xs </span><span class="s3">if </span><span class="s1">X.shape[</span><span class="s5">1</span><span class="s1">] != </span><span class="s5">0</span><span class="s1">]</span>
                <span class="s1">names_out = self._add_prefix_for_feature_names_out(</span>
                    <span class="s1">list(zip(transformer_names</span><span class="s3">, </span><span class="s1">feature_names_outs))</span>
                <span class="s1">)</span>
                <span class="s1">output.columns = names_out</span>
                <span class="s3">return </span><span class="s1">output</span>

            <span class="s3">return </span><span class="s1">np.hstack(Xs)</span>

    <span class="s3">def </span><span class="s1">_sk_visual_block_(self):</span>
        <span class="s3">if </span><span class="s1">isinstance(self.remainder</span><span class="s3">, </span><span class="s1">str) </span><span class="s3">and </span><span class="s1">self.remainder == </span><span class="s4">&quot;drop&quot;</span><span class="s1">:</span>
            <span class="s1">transformers = self.transformers</span>
        <span class="s3">elif </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s4">&quot;_remainder&quot;</span><span class="s1">):</span>
            <span class="s1">remainder_columns = self._remainder[</span><span class="s5">2</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">hasattr(self</span><span class="s3">, </span><span class="s4">&quot;feature_names_in_&quot;</span><span class="s1">)</span>
                <span class="s3">and </span><span class="s1">remainder_columns</span>
                <span class="s3">and not </span><span class="s1">all(isinstance(col</span><span class="s3">, </span><span class="s1">str) </span><span class="s3">for </span><span class="s1">col </span><span class="s3">in </span><span class="s1">remainder_columns)</span>
            <span class="s1">):</span>
                <span class="s1">remainder_columns = self.feature_names_in_[remainder_columns].tolist()</span>
            <span class="s1">transformers = chain(</span>
                <span class="s1">self.transformers</span><span class="s3">, </span><span class="s1">[(</span><span class="s4">&quot;remainder&quot;</span><span class="s3">, </span><span class="s1">self.remainder</span><span class="s3">, </span><span class="s1">remainder_columns)]</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">transformers = chain(self.transformers</span><span class="s3">, </span><span class="s1">[(</span><span class="s4">&quot;remainder&quot;</span><span class="s3">, </span><span class="s1">self.remainder</span><span class="s3">, </span><span class="s4">&quot;&quot;</span><span class="s1">)])</span>

        <span class="s1">names</span><span class="s3">, </span><span class="s1">transformers</span><span class="s3">, </span><span class="s1">name_details = zip(*transformers)</span>
        <span class="s3">return </span><span class="s1">_VisualBlock(</span>
            <span class="s4">&quot;parallel&quot;</span><span class="s3">, </span><span class="s1">transformers</span><span class="s3">, </span><span class="s1">names=names</span><span class="s3">, </span><span class="s1">name_details=name_details</span>
        <span class="s1">)</span>


<span class="s3">def </span><span class="s1">_check_X(X):</span>
    <span class="s0">&quot;&quot;&quot;Use check_array only on lists and other non-array-likes / sparse&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">hasattr(X</span><span class="s3">, </span><span class="s4">&quot;__array__&quot;</span><span class="s1">) </span><span class="s3">or </span><span class="s1">sparse.issparse(X):</span>
        <span class="s3">return </span><span class="s1">X</span>
    <span class="s3">return </span><span class="s1">check_array(X</span><span class="s3">, </span><span class="s1">force_all_finite=</span><span class="s4">&quot;allow-nan&quot;</span><span class="s3">, </span><span class="s1">dtype=object)</span>


<span class="s3">def </span><span class="s1">_is_empty_column_selection(column):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return True if the column selection is empty (empty list or all-False 
    boolean array). 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">hasattr(column</span><span class="s3">, </span><span class="s4">&quot;dtype&quot;</span><span class="s1">) </span><span class="s3">and </span><span class="s1">np.issubdtype(column.dtype</span><span class="s3">, </span><span class="s1">np.bool_):</span>
        <span class="s3">return not </span><span class="s1">column.any()</span>
    <span class="s3">elif </span><span class="s1">hasattr(column</span><span class="s3">, </span><span class="s4">&quot;__len__&quot;</span><span class="s1">):</span>
        <span class="s3">return </span><span class="s1">(</span>
            <span class="s1">len(column) == </span><span class="s5">0</span>
            <span class="s3">or </span><span class="s1">all(isinstance(col</span><span class="s3">, </span><span class="s1">bool) </span><span class="s3">for </span><span class="s1">col </span><span class="s3">in </span><span class="s1">column)</span>
            <span class="s3">and not </span><span class="s1">any(column)</span>
        <span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return False</span>


<span class="s3">def </span><span class="s1">_get_transformer_list(estimators):</span>
    <span class="s0">&quot;&quot;&quot; 
    Construct (name, trans, column) tuples from list 
 
    &quot;&quot;&quot;</span>
    <span class="s1">transformers</span><span class="s3">, </span><span class="s1">columns = zip(*estimators)</span>
    <span class="s1">names</span><span class="s3">, </span><span class="s1">_ = zip(*_name_estimators(transformers))</span>

    <span class="s1">transformer_list = list(zip(names</span><span class="s3">, </span><span class="s1">transformers</span><span class="s3">, </span><span class="s1">columns))</span>
    <span class="s3">return </span><span class="s1">transformer_list</span>


<span class="s2"># This function is not validated using validate_params because</span>
<span class="s2"># it's just a factory for ColumnTransformer.</span>
<span class="s3">def </span><span class="s1">make_column_transformer(</span>
    <span class="s1">*transformers</span><span class="s3">,</span>
    <span class="s1">remainder=</span><span class="s4">&quot;drop&quot;</span><span class="s3">,</span>
    <span class="s1">sparse_threshold=</span><span class="s5">0.3</span><span class="s3">,</span>
    <span class="s1">n_jobs=</span><span class="s3">None,</span>
    <span class="s1">verbose=</span><span class="s3">False,</span>
    <span class="s1">verbose_feature_names_out=</span><span class="s3">True,</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Construct a ColumnTransformer from the given transformers. 
 
    This is a shorthand for the ColumnTransformer constructor; it does not 
    require, and does not permit, naming the transformers. Instead, they will 
    be given names automatically based on their types. It also does not allow 
    weighting with ``transformer_weights``. 
 
    Read more in the :ref:`User Guide &lt;make_column_transformer&gt;`. 
 
    Parameters 
    ---------- 
    *transformers : tuples 
        Tuples of the form (transformer, columns) specifying the 
        transformer objects to be applied to subsets of the data. 
 
        transformer : {'drop', 'passthrough'} or estimator 
            Estimator must support :term:`fit` and :term:`transform`. 
            Special-cased strings 'drop' and 'passthrough' are accepted as 
            well, to indicate to drop the columns or to pass them through 
            untransformed, respectively. 
        columns : str,  array-like of str, int, array-like of int, slice, \ 
                array-like of bool or callable 
            Indexes the data on its second axis. Integers are interpreted as 
            positional columns, while strings can reference DataFrame columns 
            by name. A scalar string or int should be used where 
            ``transformer`` expects X to be a 1d array-like (vector), 
            otherwise a 2d array will be passed to the transformer. 
            A callable is passed the input data `X` and can return any of the 
            above. To select multiple columns by name or dtype, you can use 
            :obj:`make_column_selector`. 
 
    remainder : {'drop', 'passthrough'} or estimator, default='drop' 
        By default, only the specified columns in `transformers` are 
        transformed and combined in the output, and the non-specified 
        columns are dropped. (default of ``'drop'``). 
        By specifying ``remainder='passthrough'``, all remaining columns that 
        were not specified in `transformers` will be automatically passed 
        through. This subset of columns is concatenated with the output of 
        the transformers. 
        By setting ``remainder`` to be an estimator, the remaining 
        non-specified columns will use the ``remainder`` estimator. The 
        estimator must support :term:`fit` and :term:`transform`. 
 
    sparse_threshold : float, default=0.3 
        If the transformed output consists of a mix of sparse and dense data, 
        it will be stacked as a sparse matrix if the density is lower than this 
        value. Use ``sparse_threshold=0`` to always return dense. 
        When the transformed output consists of all sparse or all dense data, 
        the stacked result will be sparse or dense, respectively, and this 
        keyword will be ignored. 
 
    n_jobs : int, default=None 
        Number of jobs to run in parallel. 
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. 
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;` 
        for more details. 
 
    verbose : bool, default=False 
        If True, the time elapsed while fitting each transformer will be 
        printed as it is completed. 
 
    verbose_feature_names_out : bool, default=True 
        If True, :meth:`ColumnTransformer.get_feature_names_out` will prefix 
        all feature names with the name of the transformer that generated that 
        feature. 
        If False, :meth:`ColumnTransformer.get_feature_names_out` will not 
        prefix any feature names and will error if feature names are not 
        unique. 
 
        .. versionadded:: 1.0 
 
    Returns 
    ------- 
    ct : ColumnTransformer 
        Returns a :class:`ColumnTransformer` object. 
 
    See Also 
    -------- 
    ColumnTransformer : Class that allows combining the 
        outputs of multiple transformer objects used on column subsets 
        of the data into a single feature space. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.preprocessing import StandardScaler, OneHotEncoder 
    &gt;&gt;&gt; from sklearn.compose import make_column_transformer 
    &gt;&gt;&gt; make_column_transformer( 
    ...     (StandardScaler(), ['numerical_column']), 
    ...     (OneHotEncoder(), ['categorical_column'])) 
    ColumnTransformer(transformers=[('standardscaler', StandardScaler(...), 
                                     ['numerical_column']), 
                                    ('onehotencoder', OneHotEncoder(...), 
                                     ['categorical_column'])]) 
    &quot;&quot;&quot;</span>
    <span class="s2"># transformer_weights keyword is not passed through because the user</span>
    <span class="s2"># would need to know the automatically generated names of the transformers</span>
    <span class="s1">transformer_list = _get_transformer_list(transformers)</span>
    <span class="s3">return </span><span class="s1">ColumnTransformer(</span>
        <span class="s1">transformer_list</span><span class="s3">,</span>
        <span class="s1">n_jobs=n_jobs</span><span class="s3">,</span>
        <span class="s1">remainder=remainder</span><span class="s3">,</span>
        <span class="s1">sparse_threshold=sparse_threshold</span><span class="s3">,</span>
        <span class="s1">verbose=verbose</span><span class="s3">,</span>
        <span class="s1">verbose_feature_names_out=verbose_feature_names_out</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s3">class </span><span class="s1">make_column_selector:</span>
    <span class="s0">&quot;&quot;&quot;Create a callable to select columns to be used with 
    :class:`ColumnTransformer`. 
 
    :func:`make_column_selector` can select columns based on datatype or the 
    columns name with a regex. When using multiple selection criteria, **all** 
    criteria must match for a column to be selected. 
 
    For an example of how to use :func:`make_column_selector` within a 
    :class:`ColumnTransformer` to select columns based on data type (i.e. 
    `dtype`), refer to 
    :ref:`sphx_glr_auto_examples_compose_plot_column_transformer_mixed_types.py`. 
 
    Parameters 
    ---------- 
    pattern : str, default=None 
        Name of columns containing this regex pattern will be included. If 
        None, column selection will not be selected based on pattern. 
 
    dtype_include : column dtype or list of column dtypes, default=None 
        A selection of dtypes to include. For more details, see 
        :meth:`pandas.DataFrame.select_dtypes`. 
 
    dtype_exclude : column dtype or list of column dtypes, default=None 
        A selection of dtypes to exclude. For more details, see 
        :meth:`pandas.DataFrame.select_dtypes`. 
 
    Returns 
    ------- 
    selector : callable 
        Callable for column selection to be used by a 
        :class:`ColumnTransformer`. 
 
    See Also 
    -------- 
    ColumnTransformer : Class that allows combining the 
        outputs of multiple transformer objects used on column subsets 
        of the data into a single feature space. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.preprocessing import StandardScaler, OneHotEncoder 
    &gt;&gt;&gt; from sklearn.compose import make_column_transformer 
    &gt;&gt;&gt; from sklearn.compose import make_column_selector 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import pandas as pd  # doctest: +SKIP 
    &gt;&gt;&gt; X = pd.DataFrame({'city': ['London', 'London', 'Paris', 'Sallisaw'], 
    ...                   'rating': [5, 3, 4, 5]})  # doctest: +SKIP 
    &gt;&gt;&gt; ct = make_column_transformer( 
    ...       (StandardScaler(), 
    ...        make_column_selector(dtype_include=np.number)),  # rating 
    ...       (OneHotEncoder(), 
    ...        make_column_selector(dtype_include=object)))  # city 
    &gt;&gt;&gt; ct.fit_transform(X)  # doctest: +SKIP 
    array([[ 0.90453403,  1.        ,  0.        ,  0.        ], 
           [-1.50755672,  1.        ,  0.        ,  0.        ], 
           [-0.30151134,  0.        ,  1.        ,  0.        ], 
           [ 0.90453403,  0.        ,  0.        ,  1.        ]]) 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">pattern=</span><span class="s3">None, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">dtype_include=</span><span class="s3">None, </span><span class="s1">dtype_exclude=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">self.pattern = pattern</span>
        <span class="s1">self.dtype_include = dtype_include</span>
        <span class="s1">self.dtype_exclude = dtype_exclude</span>

    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">df):</span>
        <span class="s0">&quot;&quot;&quot;Callable for column selection to be used by a 
        :class:`ColumnTransformer`. 
 
        Parameters 
        ---------- 
        df : dataframe of shape (n_features, n_samples) 
            DataFrame to select columns from. 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">hasattr(df</span><span class="s3">, </span><span class="s4">&quot;iloc&quot;</span><span class="s1">):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;make_column_selector can only be applied to pandas dataframes&quot;</span>
            <span class="s1">)</span>
        <span class="s1">df_row = df.iloc[:</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">self.dtype_include </span><span class="s3">is not None or </span><span class="s1">self.dtype_exclude </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">df_row = df_row.select_dtypes(</span>
                <span class="s1">include=self.dtype_include</span><span class="s3">, </span><span class="s1">exclude=self.dtype_exclude</span>
            <span class="s1">)</span>
        <span class="s1">cols = df_row.columns</span>
        <span class="s3">if </span><span class="s1">self.pattern </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">cols = cols[cols.str.contains(self.pattern</span><span class="s3">, </span><span class="s1">regex=</span><span class="s3">True</span><span class="s1">)]</span>
        <span class="s3">return </span><span class="s1">cols.tolist()</span>
</pre>
</body>
</html>