<html>
<head>
<title>scales.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
scales.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">from </span><span class="s1">copy </span><span class="s0">import </span><span class="s1">copy</span>
<span class="s0">from </span><span class="s1">collections.abc </span><span class="s0">import </span><span class="s1">Sequence</span>
<span class="s0">from </span><span class="s1">dataclasses </span><span class="s0">import </span><span class="s1">dataclass</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">partial</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Any</span><span class="s0">, </span><span class="s1">Callable</span><span class="s0">, </span><span class="s1">Tuple</span><span class="s0">, </span><span class="s1">Optional</span><span class="s0">, </span><span class="s1">ClassVar</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">matplotlib </span><span class="s0">as </span><span class="s1">mpl</span>
<span class="s0">from </span><span class="s1">matplotlib.ticker </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Locator</span><span class="s0">,</span>
    <span class="s1">Formatter</span><span class="s0">,</span>
    <span class="s1">AutoLocator</span><span class="s0">,</span>
    <span class="s1">AutoMinorLocator</span><span class="s0">,</span>
    <span class="s1">FixedLocator</span><span class="s0">,</span>
    <span class="s1">LinearLocator</span><span class="s0">,</span>
    <span class="s1">LogLocator</span><span class="s0">,</span>
    <span class="s1">SymmetricalLogLocator</span><span class="s0">,</span>
    <span class="s1">MaxNLocator</span><span class="s0">,</span>
    <span class="s1">MultipleLocator</span><span class="s0">,</span>
    <span class="s1">EngFormatter</span><span class="s0">,</span>
    <span class="s1">FuncFormatter</span><span class="s0">,</span>
    <span class="s1">LogFormatterSciNotation</span><span class="s0">,</span>
    <span class="s1">ScalarFormatter</span><span class="s0">,</span>
    <span class="s1">StrMethodFormatter</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">matplotlib.dates </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">AutoDateLocator</span><span class="s0">,</span>
    <span class="s1">AutoDateFormatter</span><span class="s0">,</span>
    <span class="s1">ConciseDateFormatter</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">matplotlib.axis </span><span class="s0">import </span><span class="s1">Axis</span>
<span class="s0">from </span><span class="s1">matplotlib.scale </span><span class="s0">import </span><span class="s1">ScaleBase</span>
<span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">Series</span>

<span class="s0">from </span><span class="s1">seaborn._core.rules </span><span class="s0">import </span><span class="s1">categorical_order</span>
<span class="s0">from </span><span class="s1">seaborn._core.typing </span><span class="s0">import </span><span class="s1">Default</span><span class="s0">, </span><span class="s1">default</span>

<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s0">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s0">from </span><span class="s1">seaborn._core.plot </span><span class="s0">import </span><span class="s1">Plot</span>
    <span class="s0">from </span><span class="s1">seaborn._core.properties </span><span class="s0">import </span><span class="s1">Property</span>
    <span class="s0">from </span><span class="s1">numpy.typing </span><span class="s0">import </span><span class="s1">ArrayLike</span><span class="s0">, </span><span class="s1">NDArray</span>

    <span class="s1">TransFuncs = Tuple[</span>
        <span class="s1">Callable[[ArrayLike]</span><span class="s0">, </span><span class="s1">ArrayLike]</span><span class="s0">, </span><span class="s1">Callable[[ArrayLike]</span><span class="s0">, </span><span class="s1">ArrayLike]</span>
    <span class="s1">]</span>

    <span class="s2"># TODO Reverting typing to Any as it was proving too complicated to</span>
    <span class="s2"># work out the right way to communicate the types to mypy. Revisit!</span>
    <span class="s1">Pipeline = Sequence[Optional[Callable[[Any]</span><span class="s0">, </span><span class="s1">Any]]]</span>


<span class="s0">class </span><span class="s1">Scale:</span>
    <span class="s3">&quot;&quot;&quot;Base class for objects that map data values to visual properties.&quot;&quot;&quot;</span>

    <span class="s1">values: tuple | str | list | dict | </span><span class="s0">None</span>

    <span class="s1">_priority: ClassVar[int]</span>
    <span class="s1">_pipeline: Pipeline</span>
    <span class="s1">_matplotlib_scale: ScaleBase</span>
    <span class="s1">_spacer: staticmethod</span>
    <span class="s1">_legend: tuple[list[Any]</span><span class="s0">, </span><span class="s1">list[str]] | </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">__post_init__(self):</span>

        <span class="s1">self._tick_params = </span><span class="s0">None</span>
        <span class="s1">self._label_params = </span><span class="s0">None</span>
        <span class="s1">self._legend = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">tick(self):</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s0">def </span><span class="s1">label(self):</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s0">def </span><span class="s1">_get_locators(self):</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s0">def </span><span class="s1">_get_formatter(self</span><span class="s0">, </span><span class="s1">locator: Locator | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s0">def </span><span class="s1">_get_scale(self</span><span class="s0">, </span><span class="s1">name: str</span><span class="s0">, </span><span class="s1">forward: Callable</span><span class="s0">, </span><span class="s1">inverse: Callable):</span>

        <span class="s1">major_locator</span><span class="s0">, </span><span class="s1">minor_locator = self._get_locators(**self._tick_params)</span>
        <span class="s1">major_formatter = self._get_formatter(major_locator</span><span class="s0">, </span><span class="s1">**self._label_params)</span>

        <span class="s0">class </span><span class="s1">InternalScale(mpl.scale.FuncScale):</span>
            <span class="s0">def </span><span class="s1">set_default_locators_and_formatters(self</span><span class="s0">, </span><span class="s1">axis):</span>
                <span class="s1">axis.set_major_locator(major_locator)</span>
                <span class="s0">if </span><span class="s1">minor_locator </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s1">axis.set_minor_locator(minor_locator)</span>
                <span class="s1">axis.set_major_formatter(major_formatter)</span>

        <span class="s0">return </span><span class="s1">InternalScale(name</span><span class="s0">, </span><span class="s1">(forward</span><span class="s0">, </span><span class="s1">inverse))</span>

    <span class="s0">def </span><span class="s1">_spacing(self</span><span class="s0">, </span><span class="s1">x: Series) -&gt; float:</span>
        <span class="s1">space = self._spacer(x)</span>
        <span class="s0">if </span><span class="s1">np.isnan(space):</span>
            <span class="s2"># This happens when there is no variance in the orient coordinate data</span>
            <span class="s2"># Not exactly clear what the right default is, but 1 seems reasonable?</span>
            <span class="s0">return </span><span class="s4">1</span>
        <span class="s0">return </span><span class="s1">space</span>

    <span class="s0">def </span><span class="s1">_setup(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">data: Series</span><span class="s0">, </span><span class="s1">prop: Property</span><span class="s0">, </span><span class="s1">axis: Axis | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">) -&gt; Scale:</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s0">def </span><span class="s1">_finalize(self</span><span class="s0">, </span><span class="s1">p: Plot</span><span class="s0">, </span><span class="s1">axis: Axis) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Perform scale-specific axis tweaks after adding artists.&quot;&quot;&quot;</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">data: Series) -&gt; ArrayLike:</span>

        <span class="s1">trans_data: Series | NDArray | list</span>

        <span class="s2"># TODO sometimes we need to handle scalars (e.g. for Line)</span>
        <span class="s2"># but what is the best way to do that?</span>
        <span class="s1">scalar_data = np.isscalar(data)</span>
        <span class="s0">if </span><span class="s1">scalar_data:</span>
            <span class="s1">trans_data = np.array([data])</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">trans_data = data</span>

        <span class="s0">for </span><span class="s1">func </span><span class="s0">in </span><span class="s1">self._pipeline:</span>
            <span class="s0">if </span><span class="s1">func </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">trans_data = func(trans_data)</span>

        <span class="s0">if </span><span class="s1">scalar_data:</span>
            <span class="s0">return </span><span class="s1">trans_data[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">trans_data</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_identity():</span>

        <span class="s0">class </span><span class="s1">Identity(Scale):</span>
            <span class="s1">_pipeline = []</span>
            <span class="s1">_spacer = </span><span class="s0">None</span>
            <span class="s1">_legend = </span><span class="s0">None</span>
            <span class="s1">_matplotlib_scale = </span><span class="s0">None</span>

        <span class="s0">return </span><span class="s1">Identity()</span>


<span class="s1">@dataclass</span>
<span class="s0">class </span><span class="s1">Boolean(Scale):</span>
    <span class="s3">&quot;&quot;&quot; 
    A scale with a discrete domain of True and False values. 
 
    The behavior is similar to the :class:`Nominal` scale, but property 
    mappings and legends will use a [True, False] ordering rather than 
    a sort using numeric rules. Coordinate variables accomplish this by 
    inverting axis limits so as to maintain underlying numeric positioning. 
    Input data are cast to boolean values, respecting missing data. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">values: tuple | list | dict | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>

    <span class="s1">_priority: ClassVar[int] = </span><span class="s4">3</span>

    <span class="s0">def </span><span class="s1">_setup(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">data: Series</span><span class="s0">, </span><span class="s1">prop: Property</span><span class="s0">, </span><span class="s1">axis: Axis | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">) -&gt; Scale:</span>

        <span class="s1">new = copy(self)</span>
        <span class="s0">if </span><span class="s1">new._tick_params </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">new = new.tick()</span>
        <span class="s0">if </span><span class="s1">new._label_params </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">new = new.label()</span>

        <span class="s0">def </span><span class="s1">na_safe_cast(x):</span>
            <span class="s2"># TODO this doesn't actually need to be a closure</span>
            <span class="s0">if </span><span class="s1">np.isscalar(x):</span>
                <span class="s0">return </span><span class="s1">float(bool(x))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">hasattr(x</span><span class="s0">, </span><span class="s5">&quot;notna&quot;</span><span class="s1">):</span>
                    <span class="s2"># Handle pd.NA; np&lt;&gt;pd interop with NA is tricky</span>
                    <span class="s1">use = x.notna().to_numpy()</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">use = np.isfinite(x)</span>
                <span class="s1">out = np.full(len(x)</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">dtype=float)</span>
                <span class="s1">out[use] = x[use].astype(bool).astype(float)</span>
                <span class="s0">return </span><span class="s1">out</span>

        <span class="s1">new._pipeline = [na_safe_cast</span><span class="s0">, </span><span class="s1">prop.get_mapping(new</span><span class="s0">, </span><span class="s1">data)]</span>
        <span class="s1">new._spacer = _default_spacer</span>
        <span class="s0">if </span><span class="s1">prop.legend:</span>
            <span class="s1">new._legend = [</span><span class="s0">True, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">&quot;True&quot;</span><span class="s0">, </span><span class="s5">&quot;False&quot;</span><span class="s1">]</span>

        <span class="s1">forward</span><span class="s0">, </span><span class="s1">inverse = _make_identity_transforms()</span>
        <span class="s1">mpl_scale = new._get_scale(str(data.name)</span><span class="s0">, </span><span class="s1">forward</span><span class="s0">, </span><span class="s1">inverse)</span>

        <span class="s1">axis = PseudoAxis(mpl_scale) </span><span class="s0">if </span><span class="s1">axis </span><span class="s0">is None else </span><span class="s1">axis</span>
        <span class="s1">mpl_scale.set_default_locators_and_formatters(axis)</span>
        <span class="s1">new._matplotlib_scale = mpl_scale</span>

        <span class="s0">return </span><span class="s1">new</span>

    <span class="s0">def </span><span class="s1">_finalize(self</span><span class="s0">, </span><span class="s1">p: Plot</span><span class="s0">, </span><span class="s1">axis: Axis) -&gt; </span><span class="s0">None</span><span class="s1">:</span>

        <span class="s2"># We want values to appear in a True, False order but also want</span>
        <span class="s2"># True/False to be drawn at 1/0 positions respectively to avoid nasty</span>
        <span class="s2"># surprises if additional artists are added through the matplotlib API.</span>
        <span class="s2"># We accomplish this using axis inversion akin to what we do in Nominal.</span>

        <span class="s1">ax = axis.axes</span>
        <span class="s1">name = axis.axis_name</span>
        <span class="s1">axis.grid(</span><span class="s0">False, </span><span class="s1">which=</span><span class="s5">&quot;both&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">name </span><span class="s0">not in </span><span class="s1">p._limits:</span>
            <span class="s1">nticks = len(axis.get_major_ticks())</span>
            <span class="s1">lo</span><span class="s0">, </span><span class="s1">hi = -</span><span class="s4">.5</span><span class="s0">, </span><span class="s1">nticks - </span><span class="s4">.5</span>
            <span class="s0">if </span><span class="s1">name == </span><span class="s5">&quot;x&quot;</span><span class="s1">:</span>
                <span class="s1">lo</span><span class="s0">, </span><span class="s1">hi = hi</span><span class="s0">, </span><span class="s1">lo</span>
            <span class="s1">set_lim = getattr(ax</span><span class="s0">, </span><span class="s5">f&quot;set_</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s5">lim&quot;</span><span class="s1">)</span>
            <span class="s1">set_lim(lo</span><span class="s0">, </span><span class="s1">hi</span><span class="s0">, </span><span class="s1">auto=</span><span class="s0">None</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">tick(self</span><span class="s0">, </span><span class="s1">locator: Locator | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">new = copy(self)</span>
        <span class="s1">new._tick_params = {</span><span class="s5">&quot;locator&quot;</span><span class="s1">: locator}</span>
        <span class="s0">return </span><span class="s1">new</span>

    <span class="s0">def </span><span class="s1">label(self</span><span class="s0">, </span><span class="s1">formatter: Formatter | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">new = copy(self)</span>
        <span class="s1">new._label_params = {</span><span class="s5">&quot;formatter&quot;</span><span class="s1">: formatter}</span>
        <span class="s0">return </span><span class="s1">new</span>

    <span class="s0">def </span><span class="s1">_get_locators(self</span><span class="s0">, </span><span class="s1">locator):</span>
        <span class="s0">if </span><span class="s1">locator </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">locator</span>
        <span class="s0">return </span><span class="s1">FixedLocator([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">])</span><span class="s0">, None</span>

    <span class="s0">def </span><span class="s1">_get_formatter(self</span><span class="s0">, </span><span class="s1">locator</span><span class="s0">, </span><span class="s1">formatter):</span>
        <span class="s0">if </span><span class="s1">formatter </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">formatter</span>
        <span class="s0">return </span><span class="s1">FuncFormatter(</span><span class="s0">lambda </span><span class="s1">x</span><span class="s0">, </span><span class="s1">_: str(bool(x)))</span>


<span class="s1">@dataclass</span>
<span class="s0">class </span><span class="s1">Nominal(Scale):</span>
    <span class="s3">&quot;&quot;&quot; 
    A categorical scale without relative importance / magnitude. 
    &quot;&quot;&quot;</span>
    <span class="s2"># Categorical (convert to strings), un-sortable</span>

    <span class="s1">values: tuple | str | list | dict | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>
    <span class="s1">order: list | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>

    <span class="s1">_priority: ClassVar[int] = </span><span class="s4">4</span>

    <span class="s0">def </span><span class="s1">_setup(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">data: Series</span><span class="s0">, </span><span class="s1">prop: Property</span><span class="s0">, </span><span class="s1">axis: Axis | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">) -&gt; Scale:</span>

        <span class="s1">new = copy(self)</span>
        <span class="s0">if </span><span class="s1">new._tick_params </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">new = new.tick()</span>
        <span class="s0">if </span><span class="s1">new._label_params </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">new = new.label()</span>

        <span class="s2"># TODO flexibility over format() which isn't great for numbers / dates</span>
        <span class="s1">stringify = np.vectorize(format</span><span class="s0">, </span><span class="s1">otypes=[</span><span class="s5">&quot;object&quot;</span><span class="s1">])</span>

        <span class="s1">units_seed = categorical_order(data</span><span class="s0">, </span><span class="s1">new.order)</span>

        <span class="s2"># TODO move to Nominal._get_scale?</span>
        <span class="s2"># TODO this needs some more complicated rethinking about how to pass</span>
        <span class="s2"># a unit dictionary down to these methods, along with how much we want</span>
        <span class="s2"># to invest in their API. What is it useful for tick() to do here?</span>
        <span class="s2"># (Ordinal may be different if we draw that contrast).</span>
        <span class="s2"># Any customization we do to allow, e.g., label wrapping will probably</span>
        <span class="s2"># require defining our own Formatter subclass.</span>
        <span class="s2"># We could also potentially implement auto-wrapping in an Axis subclass</span>
        <span class="s2"># (see Axis.draw ... it already is computing the bboxes).</span>
        <span class="s2"># major_locator, minor_locator = new._get_locators(**new._tick_params)</span>
        <span class="s2"># major_formatter = new._get_formatter(major_locator, **new._label_params)</span>

        <span class="s0">class </span><span class="s1">CatScale(mpl.scale.LinearScale):</span>
            <span class="s1">name = </span><span class="s0">None  </span><span class="s2"># To work around mpl&lt;3.4 compat issues</span>

            <span class="s0">def </span><span class="s1">set_default_locators_and_formatters(self</span><span class="s0">, </span><span class="s1">axis):</span>
                <span class="s1">...</span>
                <span class="s2"># axis.set_major_locator(major_locator)</span>
                <span class="s2"># if minor_locator is not None:</span>
                <span class="s2">#     axis.set_minor_locator(minor_locator)</span>
                <span class="s2"># axis.set_major_formatter(major_formatter)</span>

        <span class="s1">mpl_scale = CatScale(data.name)</span>
        <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">axis = PseudoAxis(mpl_scale)</span>

            <span class="s2"># TODO Currently just used in non-Coordinate contexts, but should</span>
            <span class="s2"># we use this to (A) set the padding we want for categorial plots</span>
            <span class="s2"># and (B) allow the values parameter for a Coordinate to set xlim/ylim</span>
            <span class="s1">axis.set_view_interval(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">len(units_seed) - </span><span class="s4">1</span><span class="s1">)</span>

        <span class="s1">new._matplotlib_scale = mpl_scale</span>

        <span class="s2"># TODO array cast necessary to handle float/int mixture, which we need</span>
        <span class="s2"># to solve in a more systematic way probably</span>
        <span class="s2"># (i.e. if we have [1, 2.5], do we want [1.0, 2.5]? Unclear)</span>
        <span class="s1">axis.update_units(stringify(np.array(units_seed)))</span>

        <span class="s2"># TODO define this more centrally</span>
        <span class="s0">def </span><span class="s1">convert_units(x):</span>
            <span class="s2"># TODO only do this with explicit order?</span>
            <span class="s2"># (But also category dtype?)</span>
            <span class="s2"># TODO isin fails when units_seed mixes numbers and strings (numpy error?)</span>
            <span class="s2"># but np.isin also does not seem any faster? (Maybe not broadcasting in C)</span>
            <span class="s2"># keep = x.isin(units_seed)</span>
            <span class="s1">keep = np.array([x_ </span><span class="s0">in </span><span class="s1">units_seed </span><span class="s0">for </span><span class="s1">x_ </span><span class="s0">in </span><span class="s1">x]</span><span class="s0">, </span><span class="s1">bool)</span>
            <span class="s1">out = np.full(len(x)</span><span class="s0">, </span><span class="s1">np.nan)</span>
            <span class="s1">out[keep] = axis.convert_units(stringify(x[keep]))</span>
            <span class="s0">return </span><span class="s1">out</span>

        <span class="s1">new._pipeline = [convert_units</span><span class="s0">, </span><span class="s1">prop.get_mapping(new</span><span class="s0">, </span><span class="s1">data)]</span>
        <span class="s1">new._spacer = _default_spacer</span>

        <span class="s0">if </span><span class="s1">prop.legend:</span>
            <span class="s1">new._legend = units_seed</span><span class="s0">, </span><span class="s1">list(stringify(units_seed))</span>

        <span class="s0">return </span><span class="s1">new</span>

    <span class="s0">def </span><span class="s1">_finalize(self</span><span class="s0">, </span><span class="s1">p: Plot</span><span class="s0">, </span><span class="s1">axis: Axis) -&gt; </span><span class="s0">None</span><span class="s1">:</span>

        <span class="s1">ax = axis.axes</span>
        <span class="s1">name = axis.axis_name</span>
        <span class="s1">axis.grid(</span><span class="s0">False, </span><span class="s1">which=</span><span class="s5">&quot;both&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">name </span><span class="s0">not in </span><span class="s1">p._limits:</span>
            <span class="s1">nticks = len(axis.get_major_ticks())</span>
            <span class="s1">lo</span><span class="s0">, </span><span class="s1">hi = -</span><span class="s4">.5</span><span class="s0">, </span><span class="s1">nticks - </span><span class="s4">.5</span>
            <span class="s0">if </span><span class="s1">name == </span><span class="s5">&quot;y&quot;</span><span class="s1">:</span>
                <span class="s1">lo</span><span class="s0">, </span><span class="s1">hi = hi</span><span class="s0">, </span><span class="s1">lo</span>
            <span class="s1">set_lim = getattr(ax</span><span class="s0">, </span><span class="s5">f&quot;set_</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s5">lim&quot;</span><span class="s1">)</span>
            <span class="s1">set_lim(lo</span><span class="s0">, </span><span class="s1">hi</span><span class="s0">, </span><span class="s1">auto=</span><span class="s0">None</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">tick(self</span><span class="s0">, </span><span class="s1">locator: Locator | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s1">) -&gt; Nominal:</span>
        <span class="s3">&quot;&quot;&quot; 
        Configure the selection of ticks for the scale's axis or legend. 
 
        .. note:: 
            This API is under construction and will be enhanced over time. 
            At the moment, it is probably not very useful. 
 
        Parameters 
        ---------- 
        locator : :class:`matplotlib.ticker.Locator` subclass 
            Pre-configured matplotlib locator; other parameters will not be used. 
 
        Returns 
        ------- 
        Copy of self with new tick configuration. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">new = copy(self)</span>
        <span class="s1">new._tick_params = {</span><span class="s5">&quot;locator&quot;</span><span class="s1">: locator}</span>
        <span class="s0">return </span><span class="s1">new</span>

    <span class="s0">def </span><span class="s1">label(self</span><span class="s0">, </span><span class="s1">formatter: Formatter | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s1">) -&gt; Nominal:</span>
        <span class="s3">&quot;&quot;&quot; 
        Configure the selection of labels for the scale's axis or legend. 
 
        .. note:: 
            This API is under construction and will be enhanced over time. 
            At the moment, it is probably not very useful. 
 
        Parameters 
        ---------- 
        formatter : :class:`matplotlib.ticker.Formatter` subclass 
            Pre-configured matplotlib formatter; other parameters will not be used. 
 
        Returns 
        ------- 
        scale 
            Copy of self with new tick configuration. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">new = copy(self)</span>
        <span class="s1">new._label_params = {</span><span class="s5">&quot;formatter&quot;</span><span class="s1">: formatter}</span>
        <span class="s0">return </span><span class="s1">new</span>

    <span class="s0">def </span><span class="s1">_get_locators(self</span><span class="s0">, </span><span class="s1">locator):</span>

        <span class="s0">if </span><span class="s1">locator </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">locator</span><span class="s0">, None</span>

        <span class="s1">locator = mpl.category.StrCategoryLocator({})</span>

        <span class="s0">return </span><span class="s1">locator</span><span class="s0">, None</span>

    <span class="s0">def </span><span class="s1">_get_formatter(self</span><span class="s0">, </span><span class="s1">locator</span><span class="s0">, </span><span class="s1">formatter):</span>

        <span class="s0">if </span><span class="s1">formatter </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">formatter</span>

        <span class="s1">formatter = mpl.category.StrCategoryFormatter({})</span>

        <span class="s0">return </span><span class="s1">formatter</span>


<span class="s1">@dataclass</span>
<span class="s0">class </span><span class="s1">Ordinal(Scale):</span>
    <span class="s2"># Categorical (convert to strings), sortable, can skip ticklabels</span>
    <span class="s1">...</span>


<span class="s1">@dataclass</span>
<span class="s0">class </span><span class="s1">Discrete(Scale):</span>
    <span class="s2"># Numeric, integral, can skip ticks/ticklabels</span>
    <span class="s1">...</span>


<span class="s1">@dataclass</span>
<span class="s0">class </span><span class="s1">ContinuousBase(Scale):</span>

    <span class="s1">values: tuple | str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>
    <span class="s1">norm: tuple | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">_setup(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">data: Series</span><span class="s0">, </span><span class="s1">prop: Property</span><span class="s0">, </span><span class="s1">axis: Axis | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">) -&gt; Scale:</span>

        <span class="s1">new = copy(self)</span>
        <span class="s0">if </span><span class="s1">new._tick_params </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">new = new.tick()</span>
        <span class="s0">if </span><span class="s1">new._label_params </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">new = new.label()</span>

        <span class="s1">forward</span><span class="s0">, </span><span class="s1">inverse = new._get_transform()</span>

        <span class="s1">mpl_scale = new._get_scale(str(data.name)</span><span class="s0">, </span><span class="s1">forward</span><span class="s0">, </span><span class="s1">inverse)</span>

        <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">axis = PseudoAxis(mpl_scale)</span>
            <span class="s1">axis.update_units(data)</span>

        <span class="s1">mpl_scale.set_default_locators_and_formatters(axis)</span>
        <span class="s1">new._matplotlib_scale = mpl_scale</span>

        <span class="s1">normalize: Optional[Callable[[ArrayLike]</span><span class="s0">, </span><span class="s1">ArrayLike]]</span>
        <span class="s0">if </span><span class="s1">prop.normed:</span>
            <span class="s0">if </span><span class="s1">new.norm </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">vmin</span><span class="s0">, </span><span class="s1">vmax = data.min()</span><span class="s0">, </span><span class="s1">data.max()</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">vmin</span><span class="s0">, </span><span class="s1">vmax = new.norm</span>
            <span class="s1">vmin</span><span class="s0">, </span><span class="s1">vmax = map(float</span><span class="s0">, </span><span class="s1">axis.convert_units((vmin</span><span class="s0">, </span><span class="s1">vmax)))</span>
            <span class="s1">a = forward(vmin)</span>
            <span class="s1">b = forward(vmax) - forward(vmin)</span>

            <span class="s0">def </span><span class="s1">normalize(x):</span>
                <span class="s0">return </span><span class="s1">(x - a) / b</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">normalize = vmin = vmax = </span><span class="s0">None</span>

        <span class="s1">new._pipeline = [</span>
            <span class="s1">axis.convert_units</span><span class="s0">,</span>
            <span class="s1">forward</span><span class="s0">,</span>
            <span class="s1">normalize</span><span class="s0">,</span>
            <span class="s1">prop.get_mapping(new</span><span class="s0">, </span><span class="s1">data)</span>
        <span class="s1">]</span>

        <span class="s0">def </span><span class="s1">spacer(x):</span>
            <span class="s1">x = x.dropna().unique()</span>
            <span class="s0">if </span><span class="s1">len(x) &lt; </span><span class="s4">2</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">np.nan</span>
            <span class="s0">return </span><span class="s1">np.min(np.diff(np.sort(x)))</span>
        <span class="s1">new._spacer = spacer</span>

        <span class="s2"># TODO How to allow disabling of legend for all uses of property?</span>
        <span class="s2"># Could add a Scale parameter, or perhaps Scale.suppress()?</span>
        <span class="s2"># Are there other useful parameters that would be in Scale.legend()</span>
        <span class="s2"># besides allowing Scale.legend(False)?</span>
        <span class="s0">if </span><span class="s1">prop.legend:</span>
            <span class="s1">axis.set_view_interval(vmin</span><span class="s0">, </span><span class="s1">vmax)</span>
            <span class="s1">locs = axis.major.locator()</span>
            <span class="s1">locs = locs[(vmin &lt;= locs) &amp; (locs &lt;= vmax)]</span>
            <span class="s2"># Avoid having an offset / scientific notation in a legend</span>
            <span class="s2"># as we don't represent that anywhere so it ends up incorrect.</span>
            <span class="s2"># This could become an option (e.g. Continuous.label(offset=True))</span>
            <span class="s2"># in which case we would need to figure out how to show it.</span>
            <span class="s0">if </span><span class="s1">hasattr(axis.major.formatter</span><span class="s0">, </span><span class="s5">&quot;set_useOffset&quot;</span><span class="s1">):</span>
                <span class="s1">axis.major.formatter.set_useOffset(</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">hasattr(axis.major.formatter</span><span class="s0">, </span><span class="s5">&quot;set_scientific&quot;</span><span class="s1">):</span>
                <span class="s1">axis.major.formatter.set_scientific(</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">labels = axis.major.formatter.format_ticks(locs)</span>
            <span class="s1">new._legend = list(locs)</span><span class="s0">, </span><span class="s1">list(labels)</span>

        <span class="s0">return </span><span class="s1">new</span>

    <span class="s0">def </span><span class="s1">_get_transform(self):</span>

        <span class="s1">arg = self.trans</span>

        <span class="s0">def </span><span class="s1">get_param(method</span><span class="s0">, </span><span class="s1">default):</span>
            <span class="s0">if </span><span class="s1">arg == method:</span>
                <span class="s0">return </span><span class="s1">default</span>
            <span class="s0">return </span><span class="s1">float(arg[len(method):])</span>

        <span class="s0">if </span><span class="s1">arg </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">_make_identity_transforms()</span>
        <span class="s0">elif </span><span class="s1">isinstance(arg</span><span class="s0">, </span><span class="s1">tuple):</span>
            <span class="s0">return </span><span class="s1">arg</span>
        <span class="s0">elif </span><span class="s1">isinstance(arg</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s0">if </span><span class="s1">arg == </span><span class="s5">&quot;ln&quot;</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">_make_log_transforms()</span>
            <span class="s0">elif </span><span class="s1">arg == </span><span class="s5">&quot;logit&quot;</span><span class="s1">:</span>
                <span class="s1">base = get_param(</span><span class="s5">&quot;logit&quot;</span><span class="s0">, </span><span class="s4">10</span><span class="s1">)</span>
                <span class="s0">return </span><span class="s1">_make_logit_transforms(base)</span>
            <span class="s0">elif </span><span class="s1">arg.startswith(</span><span class="s5">&quot;log&quot;</span><span class="s1">):</span>
                <span class="s1">base = get_param(</span><span class="s5">&quot;log&quot;</span><span class="s0">, </span><span class="s4">10</span><span class="s1">)</span>
                <span class="s0">return </span><span class="s1">_make_log_transforms(base)</span>
            <span class="s0">elif </span><span class="s1">arg.startswith(</span><span class="s5">&quot;symlog&quot;</span><span class="s1">):</span>
                <span class="s1">c = get_param(</span><span class="s5">&quot;symlog&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
                <span class="s0">return </span><span class="s1">_make_symlog_transforms(c)</span>
            <span class="s0">elif </span><span class="s1">arg.startswith(</span><span class="s5">&quot;pow&quot;</span><span class="s1">):</span>
                <span class="s1">exp = get_param(</span><span class="s5">&quot;pow&quot;</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
                <span class="s0">return </span><span class="s1">_make_power_transforms(exp)</span>
            <span class="s0">elif </span><span class="s1">arg == </span><span class="s5">&quot;sqrt&quot;</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">_make_sqrt_transforms()</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">f&quot;Unknown value provided for trans: </span><span class="s0">{</span><span class="s1">arg</span><span class="s0">!r}</span><span class="s5">&quot;</span><span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s0">class </span><span class="s1">Continuous(ContinuousBase):</span>
    <span class="s3">&quot;&quot;&quot; 
    A numeric scale supporting norms and functional transforms. 
    &quot;&quot;&quot;</span>
    <span class="s1">values: tuple | str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>
    <span class="s1">trans: str | TransFuncs | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>

    <span class="s2"># TODO Add this to deal with outliers?</span>
    <span class="s2"># outside: Literal[&quot;keep&quot;, &quot;drop&quot;, &quot;clip&quot;] = &quot;keep&quot;</span>

    <span class="s1">_priority: ClassVar[int] = </span><span class="s4">1</span>

    <span class="s0">def </span><span class="s1">tick(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">locator: Locator | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None, </span><span class="s1">*</span><span class="s0">,</span>
        <span class="s1">at: Sequence[float] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">upto: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">count: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">every: float | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">between: tuple[float</span><span class="s0">, </span><span class="s1">float] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">minor: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">) -&gt; Continuous:</span>
        <span class="s3">&quot;&quot;&quot; 
        Configure the selection of ticks for the scale's axis or legend. 
 
        Parameters 
        ---------- 
        locator : :class:`matplotlib.ticker.Locator` subclass 
            Pre-configured matplotlib locator; other parameters will not be used. 
        at : sequence of floats 
            Place ticks at these specific locations (in data units). 
        upto : int 
            Choose &quot;nice&quot; locations for ticks, but do not exceed this number. 
        count : int 
            Choose exactly this number of ticks, bounded by `between` or axis limits. 
        every : float 
            Choose locations at this interval of separation (in data units). 
        between : pair of floats 
            Bound upper / lower ticks when using `every` or `count`. 
        minor : int 
            Number of unlabeled ticks to draw between labeled &quot;major&quot; ticks. 
 
        Returns 
        ------- 
        scale 
            Copy of self with new tick configuration. 
 
        &quot;&quot;&quot;</span>
        <span class="s2"># Input checks</span>
        <span class="s0">if </span><span class="s1">locator </span><span class="s0">is not None and not </span><span class="s1">isinstance(locator</span><span class="s0">, </span><span class="s1">Locator):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s5">f&quot;Tick locator must be an instance of </span><span class="s0">{</span><span class="s1">Locator</span><span class="s0">!r}</span><span class="s5">, &quot;</span>
                <span class="s5">f&quot;not </span><span class="s0">{</span><span class="s1">type(locator)</span><span class="s0">!r}</span><span class="s5">.&quot;</span>
            <span class="s1">)</span>
        <span class="s1">log_base</span><span class="s0">, </span><span class="s1">symlog_thresh = self._parse_for_log_params(self.trans)</span>
        <span class="s0">if </span><span class="s1">log_base </span><span class="s0">or </span><span class="s1">symlog_thresh:</span>
            <span class="s0">if </span><span class="s1">count </span><span class="s0">is not None and </span><span class="s1">between </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">RuntimeError(</span><span class="s5">&quot;`count` requires `between` with log transform.&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">every </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">RuntimeError(</span><span class="s5">&quot;`every` not supported with log transform.&quot;</span><span class="s1">)</span>

        <span class="s1">new = copy(self)</span>
        <span class="s1">new._tick_params = {</span>
            <span class="s5">&quot;locator&quot;</span><span class="s1">: locator</span><span class="s0">,</span>
            <span class="s5">&quot;at&quot;</span><span class="s1">: at</span><span class="s0">,</span>
            <span class="s5">&quot;upto&quot;</span><span class="s1">: upto</span><span class="s0">,</span>
            <span class="s5">&quot;count&quot;</span><span class="s1">: count</span><span class="s0">,</span>
            <span class="s5">&quot;every&quot;</span><span class="s1">: every</span><span class="s0">,</span>
            <span class="s5">&quot;between&quot;</span><span class="s1">: between</span><span class="s0">,</span>
            <span class="s5">&quot;minor&quot;</span><span class="s1">: minor</span><span class="s0">,</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">new</span>

    <span class="s0">def </span><span class="s1">label(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">formatter: Formatter | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None, </span><span class="s1">*</span><span class="s0">,</span>
        <span class="s1">like: str | Callable | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">base: int | </span><span class="s0">None </span><span class="s1">| Default = default</span><span class="s0">,</span>
        <span class="s1">unit: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">) -&gt; Continuous:</span>
        <span class="s3">&quot;&quot;&quot; 
        Configure the appearance of tick labels for the scale's axis or legend. 
 
        Parameters 
        ---------- 
        formatter : :class:`matplotlib.ticker.Formatter` subclass 
            Pre-configured formatter to use; other parameters will be ignored. 
        like : str or callable 
            Either a format pattern (e.g., `&quot;.2f&quot;`), a format string with fields named 
            `x` and/or `pos` (e.g., `&quot;${x:.2f}&quot;`), or a callable with a signature like 
            `f(x: float, pos: int) -&gt; str`. In the latter variants, `x` is passed as the 
            tick value and `pos` is passed as the tick index. 
        base : number 
            Use log formatter (with scientific notation) having this value as the base. 
            Set to `None` to override the default formatter with a log transform. 
        unit : str or (str, str) tuple 
            Use  SI prefixes with these units (e.g., with `unit=&quot;g&quot;`, a tick value 
            of 5000 will appear as `5 kg`). When a tuple, the first element gives the 
            separator between the number and unit. 
 
        Returns 
        ------- 
        scale 
            Copy of self with new label configuration. 
 
        &quot;&quot;&quot;</span>
        <span class="s2"># Input checks</span>
        <span class="s0">if </span><span class="s1">formatter </span><span class="s0">is not None and not </span><span class="s1">isinstance(formatter</span><span class="s0">, </span><span class="s1">Formatter):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s5">f&quot;Label formatter must be an instance of </span><span class="s0">{</span><span class="s1">Formatter</span><span class="s0">!r}</span><span class="s5">, &quot;</span>
                <span class="s5">f&quot;not </span><span class="s0">{</span><span class="s1">type(formatter)</span><span class="s0">!r}</span><span class="s5">&quot;</span>
            <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">like </span><span class="s0">is not None and not </span><span class="s1">(isinstance(like</span><span class="s0">, </span><span class="s1">str) </span><span class="s0">or </span><span class="s1">callable(like)):</span>
            <span class="s1">msg = </span><span class="s5">f&quot;`like` must be a string or callable, not </span><span class="s0">{</span><span class="s1">type(like).__name__</span><span class="s0">}</span><span class="s5">.&quot;</span>
            <span class="s0">raise </span><span class="s1">TypeError(msg)</span>

        <span class="s1">new = copy(self)</span>
        <span class="s1">new._label_params = {</span>
            <span class="s5">&quot;formatter&quot;</span><span class="s1">: formatter</span><span class="s0">,</span>
            <span class="s5">&quot;like&quot;</span><span class="s1">: like</span><span class="s0">,</span>
            <span class="s5">&quot;base&quot;</span><span class="s1">: base</span><span class="s0">,</span>
            <span class="s5">&quot;unit&quot;</span><span class="s1">: unit</span><span class="s0">,</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">new</span>

    <span class="s0">def </span><span class="s1">_parse_for_log_params(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">trans: str | TransFuncs | </span><span class="s0">None</span>
    <span class="s1">) -&gt; tuple[float | </span><span class="s0">None, </span><span class="s1">float | </span><span class="s0">None</span><span class="s1">]:</span>

        <span class="s1">log_base = symlog_thresh = </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">isinstance(trans</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s1">m = re.match(</span><span class="s5">r&quot;^log(\d*)&quot;</span><span class="s0">, </span><span class="s1">trans)</span>
            <span class="s0">if </span><span class="s1">m </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">log_base = float(m[</span><span class="s4">1</span><span class="s1">] </span><span class="s0">or </span><span class="s4">10</span><span class="s1">)</span>
            <span class="s1">m = re.match(</span><span class="s5">r&quot;symlog(\d*)&quot;</span><span class="s0">, </span><span class="s1">trans)</span>
            <span class="s0">if </span><span class="s1">m </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">symlog_thresh = float(m[</span><span class="s4">1</span><span class="s1">] </span><span class="s0">or </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">log_base</span><span class="s0">, </span><span class="s1">symlog_thresh</span>

    <span class="s0">def </span><span class="s1">_get_locators(self</span><span class="s0">, </span><span class="s1">locator</span><span class="s0">, </span><span class="s1">at</span><span class="s0">, </span><span class="s1">upto</span><span class="s0">, </span><span class="s1">count</span><span class="s0">, </span><span class="s1">every</span><span class="s0">, </span><span class="s1">between</span><span class="s0">, </span><span class="s1">minor):</span>

        <span class="s1">log_base</span><span class="s0">, </span><span class="s1">symlog_thresh = self._parse_for_log_params(self.trans)</span>

        <span class="s0">if </span><span class="s1">locator </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">major_locator = locator</span>

        <span class="s0">elif </span><span class="s1">upto </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">log_base:</span>
                <span class="s1">major_locator = LogLocator(base=log_base</span><span class="s0">, </span><span class="s1">numticks=upto)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">major_locator = MaxNLocator(upto</span><span class="s0">, </span><span class="s1">steps=[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1.5</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">2.5</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">10</span><span class="s1">])</span>

        <span class="s0">elif </span><span class="s1">count </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">between </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s2"># This is rarely useful (unless you are setting limits)</span>
                <span class="s1">major_locator = LinearLocator(count)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">log_base </span><span class="s0">or </span><span class="s1">symlog_thresh:</span>
                    <span class="s1">forward</span><span class="s0">, </span><span class="s1">inverse = self._get_transform()</span>
                    <span class="s1">lo</span><span class="s0">, </span><span class="s1">hi = forward(between)</span>
                    <span class="s1">ticks = inverse(np.linspace(lo</span><span class="s0">, </span><span class="s1">hi</span><span class="s0">, </span><span class="s1">num=count))</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">ticks = np.linspace(*between</span><span class="s0">, </span><span class="s1">num=count)</span>
                <span class="s1">major_locator = FixedLocator(ticks)</span>

        <span class="s0">elif </span><span class="s1">every </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">between </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">major_locator = MultipleLocator(every)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">lo</span><span class="s0">, </span><span class="s1">hi = between</span>
                <span class="s1">ticks = np.arange(lo</span><span class="s0">, </span><span class="s1">hi + every</span><span class="s0">, </span><span class="s1">every)</span>
                <span class="s1">major_locator = FixedLocator(ticks)</span>

        <span class="s0">elif </span><span class="s1">at </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">major_locator = FixedLocator(at)</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">log_base:</span>
                <span class="s1">major_locator = LogLocator(log_base)</span>
            <span class="s0">elif </span><span class="s1">symlog_thresh:</span>
                <span class="s1">major_locator = SymmetricalLogLocator(linthresh=symlog_thresh</span><span class="s0">, </span><span class="s1">base=</span><span class="s4">10</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">major_locator = AutoLocator()</span>

        <span class="s0">if </span><span class="s1">minor </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">minor_locator = LogLocator(log_base</span><span class="s0">, </span><span class="s1">subs=</span><span class="s0">None</span><span class="s1">) </span><span class="s0">if </span><span class="s1">log_base </span><span class="s0">else None</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">log_base:</span>
                <span class="s1">subs = np.linspace(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">log_base</span><span class="s0">, </span><span class="s1">minor + </span><span class="s4">2</span><span class="s1">)[</span><span class="s4">1</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">]</span>
                <span class="s1">minor_locator = LogLocator(log_base</span><span class="s0">, </span><span class="s1">subs=subs)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">minor_locator = AutoMinorLocator(minor + </span><span class="s4">1</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s1">major_locator</span><span class="s0">, </span><span class="s1">minor_locator</span>

    <span class="s0">def </span><span class="s1">_get_formatter(self</span><span class="s0">, </span><span class="s1">locator</span><span class="s0">, </span><span class="s1">formatter</span><span class="s0">, </span><span class="s1">like</span><span class="s0">, </span><span class="s1">base</span><span class="s0">, </span><span class="s1">unit):</span>

        <span class="s1">log_base</span><span class="s0">, </span><span class="s1">symlog_thresh = self._parse_for_log_params(self.trans)</span>
        <span class="s0">if </span><span class="s1">base </span><span class="s0">is </span><span class="s1">default:</span>
            <span class="s0">if </span><span class="s1">symlog_thresh:</span>
                <span class="s1">log_base = </span><span class="s4">10</span>
            <span class="s1">base = log_base</span>

        <span class="s0">if </span><span class="s1">formatter </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">formatter</span>

        <span class="s0">if </span><span class="s1">like </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">isinstance(like</span><span class="s0">, </span><span class="s1">str):</span>
                <span class="s0">if </span><span class="s5">&quot;{x&quot; </span><span class="s0">in </span><span class="s1">like </span><span class="s0">or </span><span class="s5">&quot;{pos&quot; </span><span class="s0">in </span><span class="s1">like:</span>
                    <span class="s1">fmt = like</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">fmt = </span><span class="s5">f&quot;</span><span class="s0">{{</span><span class="s5">x:</span><span class="s0">{</span><span class="s1">like</span><span class="s0">}}}</span><span class="s5">&quot;</span>
                <span class="s1">formatter = StrMethodFormatter(fmt)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">formatter = FuncFormatter(like)</span>

        <span class="s0">elif </span><span class="s1">base </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s2"># We could add other log options if necessary</span>
            <span class="s1">formatter = LogFormatterSciNotation(base)</span>

        <span class="s0">elif </span><span class="s1">unit </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">isinstance(unit</span><span class="s0">, </span><span class="s1">tuple):</span>
                <span class="s1">sep</span><span class="s0">, </span><span class="s1">unit = unit</span>
            <span class="s0">elif not </span><span class="s1">unit:</span>
                <span class="s1">sep = </span><span class="s5">&quot;&quot;</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">sep = </span><span class="s5">&quot; &quot;</span>
            <span class="s1">formatter = EngFormatter(unit</span><span class="s0">, </span><span class="s1">sep=sep)</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">formatter = ScalarFormatter()</span>

        <span class="s0">return </span><span class="s1">formatter</span>


<span class="s1">@dataclass</span>
<span class="s0">class </span><span class="s1">Temporal(ContinuousBase):</span>
    <span class="s3">&quot;&quot;&quot; 
    A scale for date/time data. 
    &quot;&quot;&quot;</span>
    <span class="s2"># TODO date: bool?</span>
    <span class="s2"># For when we only care about the time component, would affect</span>
    <span class="s2"># default formatter and norm conversion. Should also happen in</span>
    <span class="s2"># Property.default_scale. The alternative was having distinct</span>
    <span class="s2"># Calendric / Temporal scales, but that feels a bit fussy, and it</span>
    <span class="s2"># would get in the way of using first-letter shorthands because</span>
    <span class="s2"># Calendric and Continuous would collide. Still, we haven't implemented</span>
    <span class="s2"># those yet, and having a clear distinction betewen date(time) / time</span>
    <span class="s2"># may be more useful.</span>

    <span class="s1">trans = </span><span class="s0">None</span>

    <span class="s1">_priority: ClassVar[int] = </span><span class="s4">2</span>

    <span class="s0">def </span><span class="s1">tick(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">locator: Locator | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None, </span><span class="s1">*</span><span class="s0">,</span>
        <span class="s1">upto: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">) -&gt; Temporal:</span>
        <span class="s3">&quot;&quot;&quot; 
        Configure the selection of ticks for the scale's axis or legend. 
 
        .. note:: 
            This API is under construction and will be enhanced over time. 
 
        Parameters 
        ---------- 
        locator : :class:`matplotlib.ticker.Locator` subclass 
            Pre-configured matplotlib locator; other parameters will not be used. 
        upto : int 
            Choose &quot;nice&quot; locations for ticks, but do not exceed this number. 
 
        Returns 
        ------- 
        scale 
            Copy of self with new tick configuration. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">locator </span><span class="s0">is not None and not </span><span class="s1">isinstance(locator</span><span class="s0">, </span><span class="s1">Locator):</span>
            <span class="s1">err = (</span>
                <span class="s5">f&quot;Tick locator must be an instance of </span><span class="s0">{</span><span class="s1">Locator</span><span class="s0">!r}</span><span class="s5">, &quot;</span>
                <span class="s5">f&quot;not </span><span class="s0">{</span><span class="s1">type(locator)</span><span class="s0">!r}</span><span class="s5">.&quot;</span>
            <span class="s1">)</span>
            <span class="s0">raise </span><span class="s1">TypeError(err)</span>

        <span class="s1">new = copy(self)</span>
        <span class="s1">new._tick_params = {</span><span class="s5">&quot;locator&quot;</span><span class="s1">: locator</span><span class="s0">, </span><span class="s5">&quot;upto&quot;</span><span class="s1">: upto}</span>
        <span class="s0">return </span><span class="s1">new</span>

    <span class="s0">def </span><span class="s1">label(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">formatter: Formatter | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None, </span><span class="s1">*</span><span class="s0">,</span>
        <span class="s1">concise: bool = </span><span class="s0">False,</span>
    <span class="s1">) -&gt; Temporal:</span>
        <span class="s3">&quot;&quot;&quot; 
        Configure the appearance of tick labels for the scale's axis or legend. 
 
        .. note:: 
            This API is under construction and will be enhanced over time. 
 
        Parameters 
        ---------- 
        formatter : :class:`matplotlib.ticker.Formatter` subclass 
            Pre-configured formatter to use; other parameters will be ignored. 
        concise : bool 
            If True, use :class:`matplotlib.dates.ConciseDateFormatter` to make 
            the tick labels as compact as possible. 
 
        Returns 
        ------- 
        scale 
            Copy of self with new label configuration. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">new = copy(self)</span>
        <span class="s1">new._label_params = {</span><span class="s5">&quot;formatter&quot;</span><span class="s1">: formatter</span><span class="s0">, </span><span class="s5">&quot;concise&quot;</span><span class="s1">: concise}</span>
        <span class="s0">return </span><span class="s1">new</span>

    <span class="s0">def </span><span class="s1">_get_locators(self</span><span class="s0">, </span><span class="s1">locator</span><span class="s0">, </span><span class="s1">upto):</span>

        <span class="s0">if </span><span class="s1">locator </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">major_locator = locator</span>
        <span class="s0">elif </span><span class="s1">upto </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">major_locator = AutoDateLocator(minticks=</span><span class="s4">2</span><span class="s0">, </span><span class="s1">maxticks=upto)</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">major_locator = AutoDateLocator(minticks=</span><span class="s4">2</span><span class="s0">, </span><span class="s1">maxticks=</span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">minor_locator = </span><span class="s0">None</span>

        <span class="s0">return </span><span class="s1">major_locator</span><span class="s0">, </span><span class="s1">minor_locator</span>

    <span class="s0">def </span><span class="s1">_get_formatter(self</span><span class="s0">, </span><span class="s1">locator</span><span class="s0">, </span><span class="s1">formatter</span><span class="s0">, </span><span class="s1">concise):</span>

        <span class="s0">if </span><span class="s1">formatter </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">formatter</span>

        <span class="s0">if </span><span class="s1">concise:</span>
            <span class="s2"># TODO ideally we would have concise coordinate ticks,</span>
            <span class="s2"># but full semantic ticks. Is that possible?</span>
            <span class="s1">formatter = ConciseDateFormatter(locator)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">formatter = AutoDateFormatter(locator)</span>

        <span class="s0">return </span><span class="s1">formatter</span>


<span class="s2"># ----------------------------------------------------------------------------------- #</span>


<span class="s2"># TODO Have this separate from Temporal or have Temporal(date=True) or similar?</span>
<span class="s2"># class Calendric(Scale):</span>

<span class="s2"># TODO Needed? Or handle this at layer (in stat or as param, eg binning=)</span>
<span class="s2"># class Binned(Scale):</span>

<span class="s2"># TODO any need for color-specific scales?</span>
<span class="s2"># class Sequential(Continuous):</span>
<span class="s2"># class Diverging(Continuous):</span>
<span class="s2"># class Qualitative(Nominal):</span>


<span class="s2"># ----------------------------------------------------------------------------------- #</span>


<span class="s0">class </span><span class="s1">PseudoAxis:</span>
    <span class="s3">&quot;&quot;&quot; 
    Internal class implementing minimal interface equivalent to matplotlib Axis. 
 
    Coordinate variables are typically scaled by attaching the Axis object from 
    the figure where the plot will end up. Matplotlib has no similar concept of 
    and axis for the other mappable variables (color, etc.), but to simplify the 
    code, this object acts like an Axis and can be used to scale other variables. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">axis_name = </span><span class="s5">&quot;&quot;  </span><span class="s2"># Matplotlib requirement but not actually used</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">scale):</span>

        <span class="s1">self.converter = </span><span class="s0">None</span>
        <span class="s1">self.units = </span><span class="s0">None</span>
        <span class="s1">self.scale = scale</span>
        <span class="s1">self.major = mpl.axis.Ticker()</span>
        <span class="s1">self.minor = mpl.axis.Ticker()</span>

        <span class="s2"># It appears that this needs to be initialized this way on matplotlib 3.1,</span>
        <span class="s2"># but not later versions. It is unclear whether there are any issues with it.</span>
        <span class="s1">self._data_interval = </span><span class="s0">None, None</span>

        <span class="s1">scale.set_default_locators_and_formatters(self)</span>
        <span class="s2"># self.set_default_intervals()  Is this ever needed?</span>

    <span class="s0">def </span><span class="s1">set_view_interval(self</span><span class="s0">, </span><span class="s1">vmin</span><span class="s0">, </span><span class="s1">vmax):</span>
        <span class="s1">self._view_interval = vmin</span><span class="s0">, </span><span class="s1">vmax</span>

    <span class="s0">def </span><span class="s1">get_view_interval(self):</span>
        <span class="s0">return </span><span class="s1">self._view_interval</span>

    <span class="s2"># TODO do we want to distinguish view/data intervals? e.g. for a legend</span>
    <span class="s2"># we probably want to represent the full range of the data values, but</span>
    <span class="s2"># still norm the colormap. If so, we'll need to track data range separately</span>
    <span class="s2"># from the norm, which we currently don't do.</span>

    <span class="s0">def </span><span class="s1">set_data_interval(self</span><span class="s0">, </span><span class="s1">vmin</span><span class="s0">, </span><span class="s1">vmax):</span>
        <span class="s1">self._data_interval = vmin</span><span class="s0">, </span><span class="s1">vmax</span>

    <span class="s0">def </span><span class="s1">get_data_interval(self):</span>
        <span class="s0">return </span><span class="s1">self._data_interval</span>

    <span class="s0">def </span><span class="s1">get_tick_space(self):</span>
        <span class="s2"># TODO how to do this in a configurable / auto way?</span>
        <span class="s2"># Would be cool to have legend density adapt to figure size, etc.</span>
        <span class="s0">return </span><span class="s4">5</span>

    <span class="s0">def </span><span class="s1">set_major_locator(self</span><span class="s0">, </span><span class="s1">locator):</span>
        <span class="s1">self.major.locator = locator</span>
        <span class="s1">locator.set_axis(self)</span>

    <span class="s0">def </span><span class="s1">set_major_formatter(self</span><span class="s0">, </span><span class="s1">formatter):</span>
        <span class="s1">self.major.formatter = formatter</span>
        <span class="s1">formatter.set_axis(self)</span>

    <span class="s0">def </span><span class="s1">set_minor_locator(self</span><span class="s0">, </span><span class="s1">locator):</span>
        <span class="s1">self.minor.locator = locator</span>
        <span class="s1">locator.set_axis(self)</span>

    <span class="s0">def </span><span class="s1">set_minor_formatter(self</span><span class="s0">, </span><span class="s1">formatter):</span>
        <span class="s1">self.minor.formatter = formatter</span>
        <span class="s1">formatter.set_axis(self)</span>

    <span class="s0">def </span><span class="s1">set_units(self</span><span class="s0">, </span><span class="s1">units):</span>
        <span class="s1">self.units = units</span>

    <span class="s0">def </span><span class="s1">update_units(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s3">&quot;&quot;&quot;Pass units to the internal converter, potentially updating its mapping.&quot;&quot;&quot;</span>
        <span class="s1">self.converter = mpl.units.registry.get_converter(x)</span>
        <span class="s0">if </span><span class="s1">self.converter </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.converter.default_units(x</span><span class="s0">, </span><span class="s1">self)</span>

            <span class="s1">info = self.converter.axisinfo(self.units</span><span class="s0">, </span><span class="s1">self)</span>

            <span class="s0">if </span><span class="s1">info </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">return</span>
            <span class="s0">if </span><span class="s1">info.majloc </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">self.set_major_locator(info.majloc)</span>
            <span class="s0">if </span><span class="s1">info.majfmt </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">self.set_major_formatter(info.majfmt)</span>

            <span class="s2"># This is in matplotlib method; do we need this?</span>
            <span class="s2"># self.set_default_intervals()</span>

    <span class="s0">def </span><span class="s1">convert_units(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s3">&quot;&quot;&quot;Return a numeric representation of the input data.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">np.issubdtype(np.asarray(x).dtype</span><span class="s0">, </span><span class="s1">np.number):</span>
            <span class="s0">return </span><span class="s1">x</span>
        <span class="s0">elif </span><span class="s1">self.converter </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">x</span>
        <span class="s0">return </span><span class="s1">self.converter.convert(x</span><span class="s0">, </span><span class="s1">self.units</span><span class="s0">, </span><span class="s1">self)</span>

    <span class="s0">def </span><span class="s1">get_scale(self):</span>
        <span class="s2"># Note that matplotlib actually returns a string here!</span>
        <span class="s2"># (e.g., with a log scale, axis.get_scale() returns &quot;log&quot;)</span>
        <span class="s2"># Currently we just hit it with minor ticks where it checks for</span>
        <span class="s2"># scale == &quot;log&quot;. I'm not sure how you'd actually use log-scale</span>
        <span class="s2"># minor &quot;ticks&quot; in a legend context, so this is fine....</span>
        <span class="s0">return </span><span class="s1">self.scale</span>

    <span class="s0">def </span><span class="s1">get_majorticklocs(self):</span>
        <span class="s0">return </span><span class="s1">self.major.locator()</span>


<span class="s2"># ------------------------------------------------------------------------------------ #</span>
<span class="s2"># Transform function creation</span>


<span class="s0">def </span><span class="s1">_make_identity_transforms() -&gt; TransFuncs:</span>

    <span class="s0">def </span><span class="s1">identity(x):</span>
        <span class="s0">return </span><span class="s1">x</span>

    <span class="s0">return </span><span class="s1">identity</span><span class="s0">, </span><span class="s1">identity</span>


<span class="s0">def </span><span class="s1">_make_logit_transforms(base: float | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s1">) -&gt; TransFuncs:</span>

    <span class="s1">log</span><span class="s0">, </span><span class="s1">exp = _make_log_transforms(base)</span>

    <span class="s0">def </span><span class="s1">logit(x):</span>
        <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s5">&quot;ignore&quot;</span><span class="s0">, </span><span class="s1">divide=</span><span class="s5">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s0">return </span><span class="s1">log(x) - log(</span><span class="s4">1 </span><span class="s1">- x)</span>

    <span class="s0">def </span><span class="s1">expit(x):</span>
        <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s5">&quot;ignore&quot;</span><span class="s0">, </span><span class="s1">divide=</span><span class="s5">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s0">return </span><span class="s1">exp(x) / (</span><span class="s4">1 </span><span class="s1">+ exp(x))</span>

    <span class="s0">return </span><span class="s1">logit</span><span class="s0">, </span><span class="s1">expit</span>


<span class="s0">def </span><span class="s1">_make_log_transforms(base: float | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s1">) -&gt; TransFuncs:</span>

    <span class="s1">fs: TransFuncs</span>
    <span class="s0">if </span><span class="s1">base </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">fs = np.log</span><span class="s0">, </span><span class="s1">np.exp</span>
    <span class="s0">elif </span><span class="s1">base == </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s1">fs = np.log2</span><span class="s0">, </span><span class="s1">partial(np.power</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">base == </span><span class="s4">10</span><span class="s1">:</span>
        <span class="s1">fs = np.log10</span><span class="s0">, </span><span class="s1">partial(np.power</span><span class="s0">, </span><span class="s4">10</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">def </span><span class="s1">forward(x):</span>
            <span class="s0">return </span><span class="s1">np.log(x) / np.log(base)</span>
        <span class="s1">fs = forward</span><span class="s0">, </span><span class="s1">partial(np.power</span><span class="s0">, </span><span class="s1">base)</span>

    <span class="s0">def </span><span class="s1">log(x: ArrayLike) -&gt; ArrayLike:</span>
        <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s5">&quot;ignore&quot;</span><span class="s0">, </span><span class="s1">divide=</span><span class="s5">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s0">return </span><span class="s1">fs[</span><span class="s4">0</span><span class="s1">](x)</span>

    <span class="s0">def </span><span class="s1">exp(x: ArrayLike) -&gt; ArrayLike:</span>
        <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s5">&quot;ignore&quot;</span><span class="s0">, </span><span class="s1">divide=</span><span class="s5">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s0">return </span><span class="s1">fs[</span><span class="s4">1</span><span class="s1">](x)</span>

    <span class="s0">return </span><span class="s1">log</span><span class="s0">, </span><span class="s1">exp</span>


<span class="s0">def </span><span class="s1">_make_symlog_transforms(c: float = </span><span class="s4">1</span><span class="s0">, </span><span class="s1">base: float = </span><span class="s4">10</span><span class="s1">) -&gt; TransFuncs:</span>

    <span class="s2"># From https://iopscience.iop.org/article/10.1088/0957-0233/24/2/027001</span>

    <span class="s2"># Note: currently not using base because we only get</span>
    <span class="s2"># one parameter from the string, and are using c (this is consistent with d3)</span>

    <span class="s1">log</span><span class="s0">, </span><span class="s1">exp = _make_log_transforms(base)</span>

    <span class="s0">def </span><span class="s1">symlog(x):</span>
        <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s5">&quot;ignore&quot;</span><span class="s0">, </span><span class="s1">divide=</span><span class="s5">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s0">return </span><span class="s1">np.sign(x) * log(</span><span class="s4">1 </span><span class="s1">+ np.abs(np.divide(x</span><span class="s0">, </span><span class="s1">c)))</span>

    <span class="s0">def </span><span class="s1">symexp(x):</span>
        <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s5">&quot;ignore&quot;</span><span class="s0">, </span><span class="s1">divide=</span><span class="s5">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s0">return </span><span class="s1">np.sign(x) * c * (exp(np.abs(x)) - </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">symlog</span><span class="s0">, </span><span class="s1">symexp</span>


<span class="s0">def </span><span class="s1">_make_sqrt_transforms() -&gt; TransFuncs:</span>

    <span class="s0">def </span><span class="s1">sqrt(x):</span>
        <span class="s0">return </span><span class="s1">np.sign(x) * np.sqrt(np.abs(x))</span>

    <span class="s0">def </span><span class="s1">square(x):</span>
        <span class="s0">return </span><span class="s1">np.sign(x) * np.square(x)</span>

    <span class="s0">return </span><span class="s1">sqrt</span><span class="s0">, </span><span class="s1">square</span>


<span class="s0">def </span><span class="s1">_make_power_transforms(exp: float) -&gt; TransFuncs:</span>

    <span class="s0">def </span><span class="s1">forward(x):</span>
        <span class="s0">return </span><span class="s1">np.sign(x) * np.power(np.abs(x)</span><span class="s0">, </span><span class="s1">exp)</span>

    <span class="s0">def </span><span class="s1">inverse(x):</span>
        <span class="s0">return </span><span class="s1">np.sign(x) * np.power(np.abs(x)</span><span class="s0">, </span><span class="s4">1 </span><span class="s1">/ exp)</span>

    <span class="s0">return </span><span class="s1">forward</span><span class="s0">, </span><span class="s1">inverse</span>


<span class="s0">def </span><span class="s1">_default_spacer(x: Series) -&gt; float:</span>
    <span class="s0">return </span><span class="s4">1</span>
</pre>
</body>
</html>