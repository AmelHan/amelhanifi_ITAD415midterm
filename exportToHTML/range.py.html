<html>
<head>
<title>range.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
range.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">from </span><span class="s1">collections.abc </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Hashable</span><span class="s0">,</span>
    <span class="s1">Iterator</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">datetime </span><span class="s0">import </span><span class="s1">timedelta</span>
<span class="s0">import </span><span class="s1">operator</span>
<span class="s0">from </span><span class="s1">sys </span><span class="s0">import </span><span class="s1">getsizeof</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s0">,</span>
    <span class="s1">Any</span><span class="s0">,</span>
    <span class="s1">Callable</span><span class="s0">,</span>
    <span class="s1">cast</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">pandas._libs </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">index </span><span class="s0">as </span><span class="s1">libindex</span><span class="s0">,</span>
    <span class="s1">lib</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas._libs.algos </span><span class="s0">import </span><span class="s1">unique_deltas</span>
<span class="s0">from </span><span class="s1">pandas._libs.lib </span><span class="s0">import </span><span class="s1">no_default</span>
<span class="s0">from </span><span class="s1">pandas.compat.numpy </span><span class="s0">import </span><span class="s1">function </span><span class="s0">as </span><span class="s1">nv</span>
<span class="s0">from </span><span class="s1">pandas.util._decorators </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">cache_readonly</span><span class="s0">,</span>
    <span class="s1">doc</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">ensure_platform_int</span><span class="s0">,</span>
    <span class="s1">ensure_python_int</span><span class="s0">,</span>
    <span class="s1">is_float</span><span class="s0">,</span>
    <span class="s1">is_integer</span><span class="s0">,</span>
    <span class="s1">is_scalar</span><span class="s0">,</span>
    <span class="s1">is_signed_integer_dtype</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.generic </span><span class="s0">import </span><span class="s1">ABCTimedeltaIndex</span>

<span class="s0">from </span><span class="s1">pandas.core </span><span class="s0">import </span><span class="s1">ops</span>
<span class="s0">import </span><span class="s1">pandas.core.common </span><span class="s0">as </span><span class="s1">com</span>
<span class="s0">from </span><span class="s1">pandas.core.construction </span><span class="s0">import </span><span class="s1">extract_array</span>
<span class="s0">import </span><span class="s1">pandas.core.indexes.base </span><span class="s0">as </span><span class="s1">ibase</span>
<span class="s0">from </span><span class="s1">pandas.core.indexes.base </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Index</span><span class="s0">,</span>
    <span class="s1">maybe_extract_name</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.ops.common </span><span class="s0">import </span><span class="s1">unpack_zerodim_and_defer</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s0">from </span><span class="s1">pandas._typing </span><span class="s0">import </span><span class="s1">(</span>
        <span class="s1">Axis</span><span class="s0">,</span>
        <span class="s1">Dtype</span><span class="s0">,</span>
        <span class="s1">NaPosition</span><span class="s0">,</span>
        <span class="s1">Self</span><span class="s0">,</span>
        <span class="s1">npt</span><span class="s0">,</span>
    <span class="s1">)</span>
<span class="s1">_empty_range = range(</span><span class="s2">0</span><span class="s1">)</span>
<span class="s1">_dtype_int64 = np.dtype(np.int64)</span>


<span class="s0">class </span><span class="s1">RangeIndex(Index):</span>
    <span class="s3">&quot;&quot;&quot; 
    Immutable Index implementing a monotonic integer range. 
 
    RangeIndex is a memory-saving special case of an Index limited to representing 
    monotonic ranges with a 64-bit dtype. Using RangeIndex may in some instances 
    improve computing speed. 
 
    This is the default index type used 
    by DataFrame and Series when no explicit index is provided by the user. 
 
    Parameters 
    ---------- 
    start : int (default: 0), range, or other RangeIndex instance 
        If int and &quot;stop&quot; is not given, interpreted as &quot;stop&quot; instead. 
    stop : int (default: 0) 
    step : int (default: 1) 
    dtype : np.int64 
        Unused, accepted for homogeneity with other index types. 
    copy : bool, default False 
        Unused, accepted for homogeneity with other index types. 
    name : object, optional 
        Name to be stored in the index. 
 
    Attributes 
    ---------- 
    start 
    stop 
    step 
 
    Methods 
    ------- 
    from_range 
 
    See Also 
    -------- 
    Index : The base pandas Index type. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; list(pd.RangeIndex(5)) 
    [0, 1, 2, 3, 4] 
 
    &gt;&gt;&gt; list(pd.RangeIndex(-2, 4)) 
    [-2, -1, 0, 1, 2, 3] 
 
    &gt;&gt;&gt; list(pd.RangeIndex(0, 10, 2)) 
    [0, 2, 4, 6, 8] 
 
    &gt;&gt;&gt; list(pd.RangeIndex(2, -10, -3)) 
    [2, -1, -4, -7] 
 
    &gt;&gt;&gt; list(pd.RangeIndex(0)) 
    [] 
 
    &gt;&gt;&gt; list(pd.RangeIndex(1, 0)) 
    [] 
    &quot;&quot;&quot;</span>

    <span class="s1">_typ = </span><span class="s4">&quot;rangeindex&quot;</span>
    <span class="s1">_dtype_validation_metadata = (is_signed_integer_dtype</span><span class="s0">, </span><span class="s4">&quot;signed integer&quot;</span><span class="s1">)</span>
    <span class="s1">_range: range</span>
    <span class="s1">_values: np.ndarray</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_engine_type(self) -&gt; type[libindex.Int64Engine]:</span>
        <span class="s0">return </span><span class="s1">libindex.Int64Engine</span>

    <span class="s5"># --------------------------------------------------------------------</span>
    <span class="s5"># Constructors</span>

    <span class="s0">def </span><span class="s1">__new__(</span>
        <span class="s1">cls</span><span class="s0">,</span>
        <span class="s1">start=</span><span class="s0">None,</span>
        <span class="s1">stop=</span><span class="s0">None,</span>
        <span class="s1">step=</span><span class="s0">None,</span>
        <span class="s1">dtype: Dtype | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">copy: bool = </span><span class="s0">False,</span>
        <span class="s1">name: Hashable | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">) -&gt; RangeIndex:</span>
        <span class="s1">cls._validate_dtype(dtype)</span>
        <span class="s1">name = maybe_extract_name(name</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">cls)</span>

        <span class="s5"># RangeIndex</span>
        <span class="s0">if </span><span class="s1">isinstance(start</span><span class="s0">, </span><span class="s1">RangeIndex):</span>
            <span class="s0">return </span><span class="s1">start.copy(name=name)</span>
        <span class="s0">elif </span><span class="s1">isinstance(start</span><span class="s0">, </span><span class="s1">range):</span>
            <span class="s0">return </span><span class="s1">cls._simple_new(start</span><span class="s0">, </span><span class="s1">name=name)</span>

        <span class="s5"># validate the arguments</span>
        <span class="s0">if </span><span class="s1">com.all_none(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">step):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;RangeIndex(...) must be called with integers&quot;</span><span class="s1">)</span>

        <span class="s1">start = ensure_python_int(start) </span><span class="s0">if </span><span class="s1">start </span><span class="s0">is not None else </span><span class="s2">0</span>

        <span class="s0">if </span><span class="s1">stop </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">start</span><span class="s0">, </span><span class="s1">stop = </span><span class="s2">0</span><span class="s0">, </span><span class="s1">start</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">stop = ensure_python_int(stop)</span>

        <span class="s1">step = ensure_python_int(step) </span><span class="s0">if </span><span class="s1">step </span><span class="s0">is not None else </span><span class="s2">1</span>
        <span class="s0">if </span><span class="s1">step == </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Step must not be zero&quot;</span><span class="s1">)</span>

        <span class="s1">rng = range(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">step)</span>
        <span class="s0">return </span><span class="s1">cls._simple_new(rng</span><span class="s0">, </span><span class="s1">name=name)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_range(cls</span><span class="s0">, </span><span class="s1">data: range</span><span class="s0">, </span><span class="s1">name=</span><span class="s0">None, </span><span class="s1">dtype: Dtype | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s1">) -&gt; Self:</span>
        <span class="s3">&quot;&quot;&quot; 
        Create :class:`pandas.RangeIndex` from a ``range`` object. 
 
        Returns 
        ------- 
        RangeIndex 
 
        Examples 
        -------- 
        &gt;&gt;&gt; pd.RangeIndex.from_range(range(5)) 
        RangeIndex(start=0, stop=5, step=1) 
 
        &gt;&gt;&gt; pd.RangeIndex.from_range(range(2, -10, -3)) 
        RangeIndex(start=2, stop=-10, step=-3) 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance(data</span><span class="s0">, </span><span class="s1">range):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">cls.__name__</span><span class="s0">}</span><span class="s4">(...) must be called with object coercible to a &quot;</span>
                <span class="s4">f&quot;range, </span><span class="s0">{</span><span class="s1">repr(data)</span><span class="s0">} </span><span class="s4">was passed&quot;</span>
            <span class="s1">)</span>
        <span class="s1">cls._validate_dtype(dtype)</span>
        <span class="s0">return </span><span class="s1">cls._simple_new(data</span><span class="s0">, </span><span class="s1">name=name)</span>

    <span class="s5">#  error: Argument 1 of &quot;_simple_new&quot; is incompatible with supertype &quot;Index&quot;;</span>
    <span class="s5">#  supertype defines the argument type as</span>
    <span class="s5">#  &quot;Union[ExtensionArray, ndarray[Any, Any]]&quot;  [override]</span>
    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">_simple_new(  </span><span class="s5"># type: ignore[override]</span>
        <span class="s1">cls</span><span class="s0">, </span><span class="s1">values: range</span><span class="s0">, </span><span class="s1">name: Hashable | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>
    <span class="s1">) -&gt; Self:</span>
        <span class="s1">result = object.__new__(cls)</span>

        <span class="s0">assert </span><span class="s1">isinstance(values</span><span class="s0">, </span><span class="s1">range)</span>

        <span class="s1">result._range = values</span>
        <span class="s1">result._name = name</span>
        <span class="s1">result._cache = {}</span>
        <span class="s1">result._reset_identity()</span>
        <span class="s1">result._references = </span><span class="s0">None</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">_validate_dtype(cls</span><span class="s0">, </span><span class="s1">dtype: Dtype | </span><span class="s0">None</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">dtype </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return</span>

        <span class="s1">validation_func</span><span class="s0">, </span><span class="s1">expected = cls._dtype_validation_metadata</span>
        <span class="s0">if not </span><span class="s1">validation_func(dtype):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s4">f&quot;Incorrect `dtype` passed: expected </span><span class="s0">{</span><span class="s1">expected</span><span class="s0">}</span><span class="s4">, received </span><span class="s0">{</span><span class="s1">dtype</span><span class="s0">}</span><span class="s4">&quot;</span>
            <span class="s1">)</span>

    <span class="s5"># --------------------------------------------------------------------</span>

    <span class="s5"># error: Return type &quot;Type[Index]&quot; of &quot;_constructor&quot; incompatible with return</span>
    <span class="s5"># type &quot;Type[RangeIndex]&quot; in supertype &quot;Index&quot;</span>
    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">_constructor(self) -&gt; type[Index]:  </span><span class="s5"># type: ignore[override]</span>
        <span class="s3">&quot;&quot;&quot;return the class to use for construction&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">Index</span>

    <span class="s5"># error: Signature of &quot;_data&quot; incompatible with supertype &quot;Index&quot;</span>
    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">_data(self) -&gt; np.ndarray:  </span><span class="s5"># type: ignore[override]</span>
        <span class="s3">&quot;&quot;&quot; 
        An int array that for performance reasons is created only when needed. 
 
        The constructed array is saved in ``_cache``. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">np.arange(self.start</span><span class="s0">, </span><span class="s1">self.stop</span><span class="s0">, </span><span class="s1">self.step</span><span class="s0">, </span><span class="s1">dtype=np.int64)</span>

    <span class="s0">def </span><span class="s1">_get_data_as_items(self):</span>
        <span class="s3">&quot;&quot;&quot;return a list of tuples of start, stop, step&quot;&quot;&quot;</span>
        <span class="s1">rng = self._range</span>
        <span class="s0">return </span><span class="s1">[(</span><span class="s4">&quot;start&quot;</span><span class="s0">, </span><span class="s1">rng.start)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">&quot;stop&quot;</span><span class="s0">, </span><span class="s1">rng.stop)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">&quot;step&quot;</span><span class="s0">, </span><span class="s1">rng.step)]</span>

    <span class="s0">def </span><span class="s1">__reduce__(self):</span>
        <span class="s1">d = {</span><span class="s4">&quot;name&quot;</span><span class="s1">: self._name}</span>
        <span class="s1">d.update(dict(self._get_data_as_items()))</span>
        <span class="s0">return </span><span class="s1">ibase._new_Index</span><span class="s0">, </span><span class="s1">(type(self)</span><span class="s0">, </span><span class="s1">d)</span><span class="s0">, None</span>

    <span class="s5"># --------------------------------------------------------------------</span>
    <span class="s5"># Rendering Methods</span>

    <span class="s0">def </span><span class="s1">_format_attrs(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Return a list of tuples of the (attr, formatted_value) 
        &quot;&quot;&quot;</span>
        <span class="s1">attrs = self._get_data_as_items()</span>
        <span class="s0">if </span><span class="s1">self._name </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">attrs.append((</span><span class="s4">&quot;name&quot;</span><span class="s0">, </span><span class="s1">ibase.default_pprint(self._name)))</span>
        <span class="s0">return </span><span class="s1">attrs</span>

    <span class="s0">def </span><span class="s1">_format_data(self</span><span class="s0">, </span><span class="s1">name=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s5"># we are formatting thru the attributes</span>
        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">_format_with_header(self</span><span class="s0">, </span><span class="s1">header: list[str]</span><span class="s0">, </span><span class="s1">na_rep: str) -&gt; list[str]:</span>
        <span class="s5"># Equivalent to Index implementation, but faster</span>
        <span class="s0">if not </span><span class="s1">len(self._range):</span>
            <span class="s0">return </span><span class="s1">header</span>
        <span class="s1">first_val_str = str(self._range[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">last_val_str = str(self._range[-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">max_length = max(len(first_val_str)</span><span class="s0">, </span><span class="s1">len(last_val_str))</span>

        <span class="s0">return </span><span class="s1">header + [</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">x</span><span class="s0">:</span><span class="s4">&lt;</span><span class="s0">{</span><span class="s1">max_length</span><span class="s0">}}</span><span class="s4">&quot; </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">self._range]</span>

    <span class="s5"># --------------------------------------------------------------------</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">start(self) -&gt; int:</span>
        <span class="s3">&quot;&quot;&quot; 
        The value of the `start` parameter (``0`` if this was not supplied). 
 
        Examples 
        -------- 
        &gt;&gt;&gt; idx = pd.RangeIndex(5) 
        &gt;&gt;&gt; idx.start 
        0 
 
        &gt;&gt;&gt; idx = pd.RangeIndex(2, -10, -3) 
        &gt;&gt;&gt; idx.start 
        2 
        &quot;&quot;&quot;</span>
        <span class="s5"># GH 25710</span>
        <span class="s0">return </span><span class="s1">self._range.start</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">stop(self) -&gt; int:</span>
        <span class="s3">&quot;&quot;&quot; 
        The value of the `stop` parameter. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; idx = pd.RangeIndex(5) 
        &gt;&gt;&gt; idx.stop 
        5 
 
        &gt;&gt;&gt; idx = pd.RangeIndex(2, -10, -3) 
        &gt;&gt;&gt; idx.stop 
        -10 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._range.stop</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">step(self) -&gt; int:</span>
        <span class="s3">&quot;&quot;&quot; 
        The value of the `step` parameter (``1`` if this was not supplied). 
 
        Examples 
        -------- 
        &gt;&gt;&gt; idx = pd.RangeIndex(5) 
        &gt;&gt;&gt; idx.step 
        1 
 
        &gt;&gt;&gt; idx = pd.RangeIndex(2, -10, -3) 
        &gt;&gt;&gt; idx.step 
        -3 
 
        Even if :class:`pandas.RangeIndex` is empty, ``step`` is still ``1`` if 
        not supplied. 
 
        &gt;&gt;&gt; idx = pd.RangeIndex(1, 0) 
        &gt;&gt;&gt; idx.step 
        1 
        &quot;&quot;&quot;</span>
        <span class="s5"># GH 25710</span>
        <span class="s0">return </span><span class="s1">self._range.step</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">nbytes(self) -&gt; int:</span>
        <span class="s3">&quot;&quot;&quot; 
        Return the number of bytes in the underlying data. 
        &quot;&quot;&quot;</span>
        <span class="s1">rng = self._range</span>
        <span class="s0">return </span><span class="s1">getsizeof(rng) + sum(</span>
            <span class="s1">getsizeof(getattr(rng</span><span class="s0">, </span><span class="s1">attr_name))</span>
            <span class="s0">for </span><span class="s1">attr_name </span><span class="s0">in </span><span class="s1">[</span><span class="s4">&quot;start&quot;</span><span class="s0">, </span><span class="s4">&quot;stop&quot;</span><span class="s0">, </span><span class="s4">&quot;step&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">memory_usage(self</span><span class="s0">, </span><span class="s1">deep: bool = </span><span class="s0">False</span><span class="s1">) -&gt; int:</span>
        <span class="s3">&quot;&quot;&quot; 
        Memory usage of my values 
 
        Parameters 
        ---------- 
        deep : bool 
            Introspect the data deeply, interrogate 
            `object` dtypes for system-level memory consumption 
 
        Returns 
        ------- 
        bytes used 
 
        Notes 
        ----- 
        Memory usage does not include memory consumed by elements that 
        are not components of the array if deep=False 
 
        See Also 
        -------- 
        numpy.ndarray.nbytes 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.nbytes</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">dtype(self) -&gt; np.dtype:</span>
        <span class="s0">return </span><span class="s1">_dtype_int64</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">is_unique(self) -&gt; bool:</span>
        <span class="s3">&quot;&quot;&quot;return if the index has unique values&quot;&quot;&quot;</span>
        <span class="s0">return True</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">is_monotonic_increasing(self) -&gt; bool:</span>
        <span class="s0">return </span><span class="s1">self._range.step &gt; </span><span class="s2">0 </span><span class="s0">or </span><span class="s1">len(self) &lt;= </span><span class="s2">1</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">is_monotonic_decreasing(self) -&gt; bool:</span>
        <span class="s0">return </span><span class="s1">self._range.step &lt; </span><span class="s2">0 </span><span class="s0">or </span><span class="s1">len(self) &lt;= </span><span class="s2">1</span>

    <span class="s0">def </span><span class="s1">__contains__(self</span><span class="s0">, </span><span class="s1">key: Any) -&gt; bool:</span>
        <span class="s1">hash(key)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">key = ensure_python_int(key)</span>
        <span class="s0">except </span><span class="s1">TypeError:</span>
            <span class="s0">return False</span>
        <span class="s0">return </span><span class="s1">key </span><span class="s0">in </span><span class="s1">self._range</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">inferred_type(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s4">&quot;integer&quot;</span>

    <span class="s5"># --------------------------------------------------------------------</span>
    <span class="s5"># Indexing Methods</span>

    <span class="s1">@doc(Index.get_loc)</span>
    <span class="s0">def </span><span class="s1">get_loc(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s0">if </span><span class="s1">is_integer(key) </span><span class="s0">or </span><span class="s1">(is_float(key) </span><span class="s0">and </span><span class="s1">key.is_integer()):</span>
            <span class="s1">new_key = int(key)</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">self._range.index(new_key)</span>
            <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">err:</span>
                <span class="s0">raise </span><span class="s1">KeyError(key) </span><span class="s0">from </span><span class="s1">err</span>
        <span class="s0">if </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">Hashable):</span>
            <span class="s0">raise </span><span class="s1">KeyError(key)</span>
        <span class="s1">self._check_indexing_error(key)</span>
        <span class="s0">raise </span><span class="s1">KeyError(key)</span>

    <span class="s0">def </span><span class="s1">_get_indexer(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">target: Index</span><span class="s0">,</span>
        <span class="s1">method: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">limit: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">tolerance=</span><span class="s0">None,</span>
    <span class="s1">) -&gt; npt.NDArray[np.intp]:</span>
        <span class="s0">if </span><span class="s1">com.any_not_none(method</span><span class="s0">, </span><span class="s1">tolerance</span><span class="s0">, </span><span class="s1">limit):</span>
            <span class="s0">return </span><span class="s1">super()._get_indexer(</span>
                <span class="s1">target</span><span class="s0">, </span><span class="s1">method=method</span><span class="s0">, </span><span class="s1">tolerance=tolerance</span><span class="s0">, </span><span class="s1">limit=limit</span>
            <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">self.step &gt; </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s1">start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">step = self.start</span><span class="s0">, </span><span class="s1">self.stop</span><span class="s0">, </span><span class="s1">self.step</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s5"># GH 28678: work on reversed range for simplicity</span>
            <span class="s1">reverse = self._range[::-</span><span class="s2">1</span><span class="s1">]</span>
            <span class="s1">start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">step = reverse.start</span><span class="s0">, </span><span class="s1">reverse.stop</span><span class="s0">, </span><span class="s1">reverse.step</span>

        <span class="s1">target_array = np.asarray(target)</span>
        <span class="s1">locs = target_array - start</span>
        <span class="s1">valid = (locs % step == </span><span class="s2">0</span><span class="s1">) &amp; (locs &gt;= </span><span class="s2">0</span><span class="s1">) &amp; (target_array &lt; stop)</span>
        <span class="s1">locs[~valid] = -</span><span class="s2">1</span>
        <span class="s1">locs[valid] = locs[valid] / step</span>

        <span class="s0">if </span><span class="s1">step != self.step:</span>
            <span class="s5"># We reversed this range: transform to original locs</span>
            <span class="s1">locs[valid] = len(self) - </span><span class="s2">1 </span><span class="s1">- locs[valid]</span>
        <span class="s0">return </span><span class="s1">ensure_platform_int(locs)</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">_should_fallback_to_positional(self) -&gt; bool:</span>
        <span class="s3">&quot;&quot;&quot; 
        Should an integer key be treated as positional? 
        &quot;&quot;&quot;</span>
        <span class="s0">return False</span>

    <span class="s5"># --------------------------------------------------------------------</span>

    <span class="s0">def </span><span class="s1">tolist(self) -&gt; list[int]:</span>
        <span class="s0">return </span><span class="s1">list(self._range)</span>

    <span class="s1">@doc(Index.__iter__)</span>
    <span class="s0">def </span><span class="s1">__iter__(self) -&gt; Iterator[int]:</span>
        <span class="s0">yield from </span><span class="s1">self._range</span>

    <span class="s1">@doc(Index._shallow_copy)</span>
    <span class="s0">def </span><span class="s1">_shallow_copy(self</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">name: Hashable = no_default):</span>
        <span class="s1">name = self._name </span><span class="s0">if </span><span class="s1">name </span><span class="s0">is </span><span class="s1">no_default </span><span class="s0">else </span><span class="s1">name</span>

        <span class="s0">if </span><span class="s1">values.dtype.kind == </span><span class="s4">&quot;f&quot;</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">Index(values</span><span class="s0">, </span><span class="s1">name=name</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s5"># GH 46675 &amp; 43885: If values is equally spaced, return a</span>
        <span class="s5"># more memory-compact RangeIndex instead of Index with 64-bit dtype</span>
        <span class="s1">unique_diffs = unique_deltas(values)</span>
        <span class="s0">if </span><span class="s1">len(unique_diffs) == </span><span class="s2">1 </span><span class="s0">and </span><span class="s1">unique_diffs[</span><span class="s2">0</span><span class="s1">] != </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s1">diff = unique_diffs[</span><span class="s2">0</span><span class="s1">]</span>
            <span class="s1">new_range = range(values[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">values[-</span><span class="s2">1</span><span class="s1">] + diff</span><span class="s0">, </span><span class="s1">diff)</span>
            <span class="s0">return </span><span class="s1">type(self)._simple_new(new_range</span><span class="s0">, </span><span class="s1">name=name)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self._constructor._simple_new(values</span><span class="s0">, </span><span class="s1">name=name)</span>

    <span class="s0">def </span><span class="s1">_view(self) -&gt; Self:</span>
        <span class="s1">result = type(self)._simple_new(self._range</span><span class="s0">, </span><span class="s1">name=self._name)</span>
        <span class="s1">result._cache = self._cache</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s1">@doc(Index.copy)</span>
    <span class="s0">def </span><span class="s1">copy(self</span><span class="s0">, </span><span class="s1">name: Hashable | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None, </span><span class="s1">deep: bool = </span><span class="s0">False</span><span class="s1">) -&gt; Self:</span>
        <span class="s1">name = self._validate_names(name=name</span><span class="s0">, </span><span class="s1">deep=deep)[</span><span class="s2">0</span><span class="s1">]</span>
        <span class="s1">new_index = self._rename(name=name)</span>
        <span class="s0">return </span><span class="s1">new_index</span>

    <span class="s0">def </span><span class="s1">_minmax(self</span><span class="s0">, </span><span class="s1">meth: str):</span>
        <span class="s1">no_steps = len(self) - </span><span class="s2">1</span>
        <span class="s0">if </span><span class="s1">no_steps == -</span><span class="s2">1</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">np.nan</span>
        <span class="s0">elif </span><span class="s1">(meth == </span><span class="s4">&quot;min&quot; </span><span class="s0">and </span><span class="s1">self.step &gt; </span><span class="s2">0</span><span class="s1">) </span><span class="s0">or </span><span class="s1">(meth == </span><span class="s4">&quot;max&quot; </span><span class="s0">and </span><span class="s1">self.step &lt; </span><span class="s2">0</span><span class="s1">):</span>
            <span class="s0">return </span><span class="s1">self.start</span>

        <span class="s0">return </span><span class="s1">self.start + self.step * no_steps</span>

    <span class="s0">def </span><span class="s1">min(self</span><span class="s0">, </span><span class="s1">axis=</span><span class="s0">None, </span><span class="s1">skipna: bool = </span><span class="s0">True, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs) -&gt; int:</span>
        <span class="s3">&quot;&quot;&quot;The minimum value of the RangeIndex&quot;&quot;&quot;</span>
        <span class="s1">nv.validate_minmax_axis(axis)</span>
        <span class="s1">nv.validate_min(args</span><span class="s0">, </span><span class="s1">kwargs)</span>
        <span class="s0">return </span><span class="s1">self._minmax(</span><span class="s4">&quot;min&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">max(self</span><span class="s0">, </span><span class="s1">axis=</span><span class="s0">None, </span><span class="s1">skipna: bool = </span><span class="s0">True, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs) -&gt; int:</span>
        <span class="s3">&quot;&quot;&quot;The maximum value of the RangeIndex&quot;&quot;&quot;</span>
        <span class="s1">nv.validate_minmax_axis(axis)</span>
        <span class="s1">nv.validate_max(args</span><span class="s0">, </span><span class="s1">kwargs)</span>
        <span class="s0">return </span><span class="s1">self._minmax(</span><span class="s4">&quot;max&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">argsort(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs) -&gt; npt.NDArray[np.intp]:</span>
        <span class="s3">&quot;&quot;&quot; 
        Returns the indices that would sort the index and its 
        underlying data. 
 
        Returns 
        ------- 
        np.ndarray[np.intp] 
 
        See Also 
        -------- 
        numpy.ndarray.argsort 
        &quot;&quot;&quot;</span>
        <span class="s1">ascending = kwargs.pop(</span><span class="s4">&quot;ascending&quot;</span><span class="s0">, True</span><span class="s1">)  </span><span class="s5"># EA compat</span>
        <span class="s1">kwargs.pop(</span><span class="s4">&quot;kind&quot;</span><span class="s0">, None</span><span class="s1">)  </span><span class="s5"># e.g. &quot;mergesort&quot; is irrelevant</span>
        <span class="s1">nv.validate_argsort(args</span><span class="s0">, </span><span class="s1">kwargs)</span>

        <span class="s0">if </span><span class="s1">self._range.step &gt; </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s1">result = np.arange(len(self)</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">result = np.arange(len(self) - </span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>

        <span class="s0">if not </span><span class="s1">ascending:</span>
            <span class="s1">result = result[::-</span><span class="s2">1</span><span class="s1">]</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">factorize(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">sort: bool = </span><span class="s0">False,</span>
        <span class="s1">use_na_sentinel: bool = </span><span class="s0">True,</span>
    <span class="s1">) -&gt; tuple[npt.NDArray[np.intp]</span><span class="s0">, </span><span class="s1">RangeIndex]:</span>
        <span class="s1">codes = np.arange(len(self)</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>
        <span class="s1">uniques = self</span>
        <span class="s0">if </span><span class="s1">sort </span><span class="s0">and </span><span class="s1">self.step &lt; </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s1">codes = codes[::-</span><span class="s2">1</span><span class="s1">]</span>
            <span class="s1">uniques = uniques[::-</span><span class="s2">1</span><span class="s1">]</span>
        <span class="s0">return </span><span class="s1">codes</span><span class="s0">, </span><span class="s1">uniques</span>

    <span class="s0">def </span><span class="s1">equals(self</span><span class="s0">, </span><span class="s1">other: object) -&gt; bool:</span>
        <span class="s3">&quot;&quot;&quot; 
        Determines if two Index objects contain the same elements. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">RangeIndex):</span>
            <span class="s0">return </span><span class="s1">self._range == other._range</span>
        <span class="s0">return </span><span class="s1">super().equals(other)</span>

    <span class="s0">def </span><span class="s1">sort_values(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">return_indexer: bool = </span><span class="s0">False,</span>
        <span class="s1">ascending: bool = </span><span class="s0">True,</span>
        <span class="s1">na_position: NaPosition = </span><span class="s4">&quot;last&quot;</span><span class="s0">,</span>
        <span class="s1">key: Callable | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">):</span>
        <span class="s0">if </span><span class="s1">key </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">super().sort_values(</span>
                <span class="s1">return_indexer=return_indexer</span><span class="s0">,</span>
                <span class="s1">ascending=ascending</span><span class="s0">,</span>
                <span class="s1">na_position=na_position</span><span class="s0">,</span>
                <span class="s1">key=key</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">sorted_index = self</span>
            <span class="s1">inverse_indexer = </span><span class="s0">False</span>
            <span class="s0">if </span><span class="s1">ascending:</span>
                <span class="s0">if </span><span class="s1">self.step &lt; </span><span class="s2">0</span><span class="s1">:</span>
                    <span class="s1">sorted_index = self[::-</span><span class="s2">1</span><span class="s1">]</span>
                    <span class="s1">inverse_indexer = </span><span class="s0">True</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">self.step &gt; </span><span class="s2">0</span><span class="s1">:</span>
                    <span class="s1">sorted_index = self[::-</span><span class="s2">1</span><span class="s1">]</span>
                    <span class="s1">inverse_indexer = </span><span class="s0">True</span>

        <span class="s0">if </span><span class="s1">return_indexer:</span>
            <span class="s0">if </span><span class="s1">inverse_indexer:</span>
                <span class="s1">rng = range(len(self) - </span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">rng = range(len(self))</span>
            <span class="s0">return </span><span class="s1">sorted_index</span><span class="s0">, </span><span class="s1">RangeIndex(rng)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">sorted_index</span>

    <span class="s5"># --------------------------------------------------------------------</span>
    <span class="s5"># Set Operations</span>

    <span class="s0">def </span><span class="s1">_intersection(self</span><span class="s0">, </span><span class="s1">other: Index</span><span class="s0">, </span><span class="s1">sort: bool = </span><span class="s0">False</span><span class="s1">):</span>
        <span class="s5"># caller is responsible for checking self and other are both non-empty</span>

        <span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">RangeIndex):</span>
            <span class="s0">return </span><span class="s1">super()._intersection(other</span><span class="s0">, </span><span class="s1">sort=sort)</span>

        <span class="s1">first = self._range[::-</span><span class="s2">1</span><span class="s1">] </span><span class="s0">if </span><span class="s1">self.step &lt; </span><span class="s2">0 </span><span class="s0">else </span><span class="s1">self._range</span>
        <span class="s1">second = other._range[::-</span><span class="s2">1</span><span class="s1">] </span><span class="s0">if </span><span class="s1">other.step &lt; </span><span class="s2">0 </span><span class="s0">else </span><span class="s1">other._range</span>

        <span class="s5"># check whether intervals intersect</span>
        <span class="s5"># deals with in- and decreasing ranges</span>
        <span class="s1">int_low = max(first.start</span><span class="s0">, </span><span class="s1">second.start)</span>
        <span class="s1">int_high = min(first.stop</span><span class="s0">, </span><span class="s1">second.stop)</span>
        <span class="s0">if </span><span class="s1">int_high &lt;= int_low:</span>
            <span class="s0">return </span><span class="s1">self._simple_new(_empty_range)</span>

        <span class="s5"># Method hint: linear Diophantine equation</span>
        <span class="s5"># solve intersection problem</span>
        <span class="s5"># performance hint: for identical step sizes, could use</span>
        <span class="s5"># cheaper alternative</span>
        <span class="s1">gcd</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">_ = self._extended_gcd(first.step</span><span class="s0">, </span><span class="s1">second.step)</span>

        <span class="s5"># check whether element sets intersect</span>
        <span class="s0">if </span><span class="s1">(first.start - second.start) % gcd:</span>
            <span class="s0">return </span><span class="s1">self._simple_new(_empty_range)</span>

        <span class="s5"># calculate parameters for the RangeIndex describing the</span>
        <span class="s5"># intersection disregarding the lower bounds</span>
        <span class="s1">tmp_start = first.start + (second.start - first.start) * first.step // gcd * s</span>
        <span class="s1">new_step = first.step * second.step // gcd</span>
        <span class="s1">new_range = range(tmp_start</span><span class="s0">, </span><span class="s1">int_high</span><span class="s0">, </span><span class="s1">new_step)</span>
        <span class="s1">new_index = self._simple_new(new_range)</span>

        <span class="s5"># adjust index to limiting interval</span>
        <span class="s1">new_start = new_index._min_fitting_element(int_low)</span>
        <span class="s1">new_range = range(new_start</span><span class="s0">, </span><span class="s1">new_index.stop</span><span class="s0">, </span><span class="s1">new_index.step)</span>
        <span class="s1">new_index = self._simple_new(new_range)</span>

        <span class="s0">if </span><span class="s1">(self.step &lt; </span><span class="s2">0 </span><span class="s0">and </span><span class="s1">other.step &lt; </span><span class="s2">0</span><span class="s1">) </span><span class="s0">is not </span><span class="s1">(new_index.step &lt; </span><span class="s2">0</span><span class="s1">):</span>
            <span class="s1">new_index = new_index[::-</span><span class="s2">1</span><span class="s1">]</span>

        <span class="s0">if </span><span class="s1">sort </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">new_index = new_index.sort_values()</span>

        <span class="s0">return </span><span class="s1">new_index</span>

    <span class="s0">def </span><span class="s1">_min_fitting_element(self</span><span class="s0">, </span><span class="s1">lower_limit: int) -&gt; int:</span>
        <span class="s3">&quot;&quot;&quot;Returns the smallest element greater than or equal to the limit&quot;&quot;&quot;</span>
        <span class="s1">no_steps = -(-(lower_limit - self.start) // abs(self.step))</span>
        <span class="s0">return </span><span class="s1">self.start + abs(self.step) * no_steps</span>

    <span class="s0">def </span><span class="s1">_extended_gcd(self</span><span class="s0">, </span><span class="s1">a: int</span><span class="s0">, </span><span class="s1">b: int) -&gt; tuple[int</span><span class="s0">, </span><span class="s1">int</span><span class="s0">, </span><span class="s1">int]:</span>
        <span class="s3">&quot;&quot;&quot; 
        Extended Euclidean algorithms to solve Bezout's identity: 
           a*x + b*y = gcd(x, y) 
        Finds one particular solution for x, y: s, t 
        Returns: gcd, s, t 
        &quot;&quot;&quot;</span>
        <span class="s1">s</span><span class="s0">, </span><span class="s1">old_s = </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span>
        <span class="s1">t</span><span class="s0">, </span><span class="s1">old_t = </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span>
        <span class="s1">r</span><span class="s0">, </span><span class="s1">old_r = b</span><span class="s0">, </span><span class="s1">a</span>
        <span class="s0">while </span><span class="s1">r:</span>
            <span class="s1">quotient = old_r // r</span>
            <span class="s1">old_r</span><span class="s0">, </span><span class="s1">r = r</span><span class="s0">, </span><span class="s1">old_r - quotient * r</span>
            <span class="s1">old_s</span><span class="s0">, </span><span class="s1">s = s</span><span class="s0">, </span><span class="s1">old_s - quotient * s</span>
            <span class="s1">old_t</span><span class="s0">, </span><span class="s1">t = t</span><span class="s0">, </span><span class="s1">old_t - quotient * t</span>
        <span class="s0">return </span><span class="s1">old_r</span><span class="s0">, </span><span class="s1">old_s</span><span class="s0">, </span><span class="s1">old_t</span>

    <span class="s0">def </span><span class="s1">_range_in_self(self</span><span class="s0">, </span><span class="s1">other: range) -&gt; bool:</span>
        <span class="s3">&quot;&quot;&quot;Check if other range is contained in self&quot;&quot;&quot;</span>
        <span class="s5"># https://stackoverflow.com/a/32481015</span>
        <span class="s0">if not </span><span class="s1">other:</span>
            <span class="s0">return True</span>
        <span class="s0">if not </span><span class="s1">self._range:</span>
            <span class="s0">return False</span>
        <span class="s0">if </span><span class="s1">len(other) &gt; </span><span class="s2">1 </span><span class="s0">and </span><span class="s1">other.step % self._range.step:</span>
            <span class="s0">return False</span>
        <span class="s0">return </span><span class="s1">other.start </span><span class="s0">in </span><span class="s1">self._range </span><span class="s0">and </span><span class="s1">other[-</span><span class="s2">1</span><span class="s1">] </span><span class="s0">in </span><span class="s1">self._range</span>

    <span class="s0">def </span><span class="s1">_union(self</span><span class="s0">, </span><span class="s1">other: Index</span><span class="s0">, </span><span class="s1">sort: bool | </span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Form the union of two Index objects and sorts if possible 
 
        Parameters 
        ---------- 
        other : Index or array-like 
 
        sort : bool or None, default None 
            Whether to sort (monotonically increasing) the resulting index. 
            ``sort=None|True`` returns a ``RangeIndex`` if possible or a sorted 
            ``Index`` with a int64 dtype if not. 
            ``sort=False`` can return a ``RangeIndex`` if self is monotonically 
            increasing and other is fully contained in self. Otherwise, returns 
            an unsorted ``Index`` with an int64 dtype. 
 
        Returns 
        ------- 
        union : Index 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">RangeIndex):</span>
            <span class="s0">if </span><span class="s1">sort </span><span class="s0">in </span><span class="s1">(</span><span class="s0">None, True</span><span class="s1">) </span><span class="s0">or </span><span class="s1">(</span>
                <span class="s1">sort </span><span class="s0">is False and </span><span class="s1">self.step &gt; </span><span class="s2">0 </span><span class="s0">and </span><span class="s1">self._range_in_self(other._range)</span>
            <span class="s1">):</span>
                <span class="s5"># GH 47557: Can still return a RangeIndex</span>
                <span class="s5"># if other range in self and sort=False</span>
                <span class="s1">start_s</span><span class="s0">, </span><span class="s1">step_s = self.start</span><span class="s0">, </span><span class="s1">self.step</span>
                <span class="s1">end_s = self.start + self.step * (len(self) - </span><span class="s2">1</span><span class="s1">)</span>
                <span class="s1">start_o</span><span class="s0">, </span><span class="s1">step_o = other.start</span><span class="s0">, </span><span class="s1">other.step</span>
                <span class="s1">end_o = other.start + other.step * (len(other) - </span><span class="s2">1</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">self.step &lt; </span><span class="s2">0</span><span class="s1">:</span>
                    <span class="s1">start_s</span><span class="s0">, </span><span class="s1">step_s</span><span class="s0">, </span><span class="s1">end_s = end_s</span><span class="s0">, </span><span class="s1">-step_s</span><span class="s0">, </span><span class="s1">start_s</span>
                <span class="s0">if </span><span class="s1">other.step &lt; </span><span class="s2">0</span><span class="s1">:</span>
                    <span class="s1">start_o</span><span class="s0">, </span><span class="s1">step_o</span><span class="s0">, </span><span class="s1">end_o = end_o</span><span class="s0">, </span><span class="s1">-step_o</span><span class="s0">, </span><span class="s1">start_o</span>
                <span class="s0">if </span><span class="s1">len(self) == </span><span class="s2">1 </span><span class="s0">and </span><span class="s1">len(other) == </span><span class="s2">1</span><span class="s1">:</span>
                    <span class="s1">step_s = step_o = abs(self.start - other.start)</span>
                <span class="s0">elif </span><span class="s1">len(self) == </span><span class="s2">1</span><span class="s1">:</span>
                    <span class="s1">step_s = step_o</span>
                <span class="s0">elif </span><span class="s1">len(other) == </span><span class="s2">1</span><span class="s1">:</span>
                    <span class="s1">step_o = step_s</span>
                <span class="s1">start_r = min(start_s</span><span class="s0">, </span><span class="s1">start_o)</span>
                <span class="s1">end_r = max(end_s</span><span class="s0">, </span><span class="s1">end_o)</span>
                <span class="s0">if </span><span class="s1">step_o == step_s:</span>
                    <span class="s0">if </span><span class="s1">(</span>
                        <span class="s1">(start_s - start_o) % step_s == </span><span class="s2">0</span>
                        <span class="s0">and </span><span class="s1">(start_s - end_o) &lt;= step_s</span>
                        <span class="s0">and </span><span class="s1">(start_o - end_s) &lt;= step_s</span>
                    <span class="s1">):</span>
                        <span class="s0">return </span><span class="s1">type(self)(start_r</span><span class="s0">, </span><span class="s1">end_r + step_s</span><span class="s0">, </span><span class="s1">step_s)</span>
                    <span class="s0">if </span><span class="s1">(</span>
                        <span class="s1">(step_s % </span><span class="s2">2 </span><span class="s1">== </span><span class="s2">0</span><span class="s1">)</span>
                        <span class="s0">and </span><span class="s1">(abs(start_s - start_o) == step_s / </span><span class="s2">2</span><span class="s1">)</span>
                        <span class="s0">and </span><span class="s1">(abs(end_s - end_o) == step_s / </span><span class="s2">2</span><span class="s1">)</span>
                    <span class="s1">):</span>
                        <span class="s5"># e.g. range(0, 10, 2) and range(1, 11, 2)</span>
                        <span class="s5">#  but not range(0, 20, 4) and range(1, 21, 4) GH#44019</span>
                        <span class="s0">return </span><span class="s1">type(self)(start_r</span><span class="s0">, </span><span class="s1">end_r + step_s / </span><span class="s2">2</span><span class="s0">, </span><span class="s1">step_s / </span><span class="s2">2</span><span class="s1">)</span>

                <span class="s0">elif </span><span class="s1">step_o % step_s == </span><span class="s2">0</span><span class="s1">:</span>
                    <span class="s0">if </span><span class="s1">(</span>
                        <span class="s1">(start_o - start_s) % step_s == </span><span class="s2">0</span>
                        <span class="s0">and </span><span class="s1">(start_o + step_s &gt;= start_s)</span>
                        <span class="s0">and </span><span class="s1">(end_o - step_s &lt;= end_s)</span>
                    <span class="s1">):</span>
                        <span class="s0">return </span><span class="s1">type(self)(start_r</span><span class="s0">, </span><span class="s1">end_r + step_s</span><span class="s0">, </span><span class="s1">step_s)</span>
                <span class="s0">elif </span><span class="s1">step_s % step_o == </span><span class="s2">0</span><span class="s1">:</span>
                    <span class="s0">if </span><span class="s1">(</span>
                        <span class="s1">(start_s - start_o) % step_o == </span><span class="s2">0</span>
                        <span class="s0">and </span><span class="s1">(start_s + step_o &gt;= start_o)</span>
                        <span class="s0">and </span><span class="s1">(end_s - step_o &lt;= end_o)</span>
                    <span class="s1">):</span>
                        <span class="s0">return </span><span class="s1">type(self)(start_r</span><span class="s0">, </span><span class="s1">end_r + step_o</span><span class="s0">, </span><span class="s1">step_o)</span>

        <span class="s0">return </span><span class="s1">super()._union(other</span><span class="s0">, </span><span class="s1">sort=sort)</span>

    <span class="s0">def </span><span class="s1">_difference(self</span><span class="s0">, </span><span class="s1">other</span><span class="s0">, </span><span class="s1">sort=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s5"># optimized set operation if we have another RangeIndex</span>
        <span class="s1">self._validate_sort_keyword(sort)</span>
        <span class="s1">self._assert_can_do_setop(other)</span>
        <span class="s1">other</span><span class="s0">, </span><span class="s1">result_name = self._convert_can_do_setop(other)</span>

        <span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">RangeIndex):</span>
            <span class="s0">return </span><span class="s1">super()._difference(other</span><span class="s0">, </span><span class="s1">sort=sort)</span>

        <span class="s0">if </span><span class="s1">sort </span><span class="s0">is not False and </span><span class="s1">self.step &lt; </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self[::-</span><span class="s2">1</span><span class="s1">]._difference(other)</span>

        <span class="s1">res_name = ops.get_op_result_name(self</span><span class="s0">, </span><span class="s1">other)</span>

        <span class="s1">first = self._range[::-</span><span class="s2">1</span><span class="s1">] </span><span class="s0">if </span><span class="s1">self.step &lt; </span><span class="s2">0 </span><span class="s0">else </span><span class="s1">self._range</span>
        <span class="s1">overlap = self.intersection(other)</span>
        <span class="s0">if </span><span class="s1">overlap.step &lt; </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s1">overlap = overlap[::-</span><span class="s2">1</span><span class="s1">]</span>

        <span class="s0">if </span><span class="s1">len(overlap) == </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.rename(name=res_name)</span>
        <span class="s0">if </span><span class="s1">len(overlap) == len(self):</span>
            <span class="s0">return </span><span class="s1">self[:</span><span class="s2">0</span><span class="s1">].rename(res_name)</span>

        <span class="s5"># overlap.step will always be a multiple of self.step (see _intersection)</span>

        <span class="s0">if </span><span class="s1">len(overlap) == </span><span class="s2">1</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">overlap[</span><span class="s2">0</span><span class="s1">] == self[</span><span class="s2">0</span><span class="s1">]:</span>
                <span class="s0">return </span><span class="s1">self[</span><span class="s2">1</span><span class="s1">:]</span>

            <span class="s0">elif </span><span class="s1">overlap[</span><span class="s2">0</span><span class="s1">] == self[-</span><span class="s2">1</span><span class="s1">]:</span>
                <span class="s0">return </span><span class="s1">self[:-</span><span class="s2">1</span><span class="s1">]</span>

            <span class="s0">elif </span><span class="s1">len(self) == </span><span class="s2">3 </span><span class="s0">and </span><span class="s1">overlap[</span><span class="s2">0</span><span class="s1">] == self[</span><span class="s2">1</span><span class="s1">]:</span>
                <span class="s0">return </span><span class="s1">self[::</span><span class="s2">2</span><span class="s1">]</span>

            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">super()._difference(other</span><span class="s0">, </span><span class="s1">sort=sort)</span>

        <span class="s0">elif </span><span class="s1">len(overlap) == </span><span class="s2">2 </span><span class="s0">and </span><span class="s1">overlap[</span><span class="s2">0</span><span class="s1">] == first[</span><span class="s2">0</span><span class="s1">] </span><span class="s0">and </span><span class="s1">overlap[-</span><span class="s2">1</span><span class="s1">] == first[-</span><span class="s2">1</span><span class="s1">]:</span>
            <span class="s5"># e.g. range(-8, 20, 7) and range(13, -9, -3)</span>
            <span class="s0">return </span><span class="s1">self[</span><span class="s2">1</span><span class="s1">:-</span><span class="s2">1</span><span class="s1">]</span>

        <span class="s0">if </span><span class="s1">overlap.step == first.step:</span>
            <span class="s0">if </span><span class="s1">overlap[</span><span class="s2">0</span><span class="s1">] == first.start:</span>
                <span class="s5"># The difference is everything after the intersection</span>
                <span class="s1">new_rng = range(overlap[-</span><span class="s2">1</span><span class="s1">] + first.step</span><span class="s0">, </span><span class="s1">first.stop</span><span class="s0">, </span><span class="s1">first.step)</span>
            <span class="s0">elif </span><span class="s1">overlap[-</span><span class="s2">1</span><span class="s1">] == first[-</span><span class="s2">1</span><span class="s1">]:</span>
                <span class="s5"># The difference is everything before the intersection</span>
                <span class="s1">new_rng = range(first.start</span><span class="s0">, </span><span class="s1">overlap[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">first.step)</span>
            <span class="s0">elif </span><span class="s1">overlap._range == first[</span><span class="s2">1</span><span class="s1">:-</span><span class="s2">1</span><span class="s1">]:</span>
                <span class="s5"># e.g. range(4) and range(1, 3)</span>
                <span class="s1">step = len(first) - </span><span class="s2">1</span>
                <span class="s1">new_rng = first[::step]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s5"># The difference is not range-like</span>
                <span class="s5"># e.g. range(1, 10, 1) and range(3, 7, 1)</span>
                <span class="s0">return </span><span class="s1">super()._difference(other</span><span class="s0">, </span><span class="s1">sort=sort)</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s5"># We must have len(self) &gt; 1, bc we ruled out above</span>
            <span class="s5">#  len(overlap) == 0 and len(overlap) == len(self)</span>
            <span class="s0">assert </span><span class="s1">len(self) &gt; </span><span class="s2">1</span>

            <span class="s0">if </span><span class="s1">overlap.step == first.step * </span><span class="s2">2</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">overlap[</span><span class="s2">0</span><span class="s1">] == first[</span><span class="s2">0</span><span class="s1">] </span><span class="s0">and </span><span class="s1">overlap[-</span><span class="s2">1</span><span class="s1">] </span><span class="s0">in </span><span class="s1">(first[-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">first[-</span><span class="s2">2</span><span class="s1">]):</span>
                    <span class="s5"># e.g. range(1, 10, 1) and range(1, 10, 2)</span>
                    <span class="s1">new_rng = first[</span><span class="s2">1</span><span class="s1">::</span><span class="s2">2</span><span class="s1">]</span>

                <span class="s0">elif </span><span class="s1">overlap[</span><span class="s2">0</span><span class="s1">] == first[</span><span class="s2">1</span><span class="s1">] </span><span class="s0">and </span><span class="s1">overlap[-</span><span class="s2">1</span><span class="s1">] </span><span class="s0">in </span><span class="s1">(first[-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">first[-</span><span class="s2">2</span><span class="s1">]):</span>
                    <span class="s5"># e.g. range(1, 10, 1) and range(2, 10, 2)</span>
                    <span class="s1">new_rng = first[::</span><span class="s2">2</span><span class="s1">]</span>

                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s5"># We can get here with  e.g. range(20) and range(0, 10, 2)</span>
                    <span class="s0">return </span><span class="s1">super()._difference(other</span><span class="s0">, </span><span class="s1">sort=sort)</span>

            <span class="s0">else</span><span class="s1">:</span>
                <span class="s5"># e.g. range(10) and range(0, 10, 3)</span>
                <span class="s0">return </span><span class="s1">super()._difference(other</span><span class="s0">, </span><span class="s1">sort=sort)</span>

        <span class="s1">new_index = type(self)._simple_new(new_rng</span><span class="s0">, </span><span class="s1">name=res_name)</span>
        <span class="s0">if </span><span class="s1">first </span><span class="s0">is not </span><span class="s1">self._range:</span>
            <span class="s1">new_index = new_index[::-</span><span class="s2">1</span><span class="s1">]</span>

        <span class="s0">return </span><span class="s1">new_index</span>

    <span class="s0">def </span><span class="s1">symmetric_difference(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">other</span><span class="s0">, </span><span class="s1">result_name: Hashable | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None, </span><span class="s1">sort=</span><span class="s0">None</span>
    <span class="s1">):</span>
        <span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">RangeIndex) </span><span class="s0">or </span><span class="s1">sort </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">super().symmetric_difference(other</span><span class="s0">, </span><span class="s1">result_name</span><span class="s0">, </span><span class="s1">sort)</span>

        <span class="s1">left = self.difference(other)</span>
        <span class="s1">right = other.difference(self)</span>
        <span class="s1">result = left.union(right)</span>

        <span class="s0">if </span><span class="s1">result_name </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">result = result.rename(result_name)</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s5"># --------------------------------------------------------------------</span>

    <span class="s5"># error: Return type &quot;Index&quot; of &quot;delete&quot; incompatible with return type</span>
    <span class="s5">#  &quot;RangeIndex&quot; in supertype &quot;Index&quot;</span>
    <span class="s0">def </span><span class="s1">delete(self</span><span class="s0">, </span><span class="s1">loc) -&gt; Index:  </span><span class="s5"># type: ignore[override]</span>
        <span class="s5"># In some cases we can retain RangeIndex, see also</span>
        <span class="s5">#  DatetimeTimedeltaMixin._get_delete_Freq</span>
        <span class="s0">if </span><span class="s1">is_integer(loc):</span>
            <span class="s0">if </span><span class="s1">loc </span><span class="s0">in </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-len(self)):</span>
                <span class="s0">return </span><span class="s1">self[</span><span class="s2">1</span><span class="s1">:]</span>
            <span class="s0">if </span><span class="s1">loc </span><span class="s0">in </span><span class="s1">(-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">len(self) - </span><span class="s2">1</span><span class="s1">):</span>
                <span class="s0">return </span><span class="s1">self[:-</span><span class="s2">1</span><span class="s1">]</span>
            <span class="s0">if </span><span class="s1">len(self) == </span><span class="s2">3 </span><span class="s0">and </span><span class="s1">loc </span><span class="s0">in </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s1">):</span>
                <span class="s0">return </span><span class="s1">self[::</span><span class="s2">2</span><span class="s1">]</span>

        <span class="s0">elif </span><span class="s1">lib.is_list_like(loc):</span>
            <span class="s1">slc = lib.maybe_indices_to_slice(np.asarray(loc</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span><span class="s0">, </span><span class="s1">len(self))</span>

            <span class="s0">if </span><span class="s1">isinstance(slc</span><span class="s0">, </span><span class="s1">slice):</span>
                <span class="s5"># defer to RangeIndex._difference, which is optimized to return</span>
                <span class="s5">#  a RangeIndex whenever possible</span>
                <span class="s1">other = self[slc]</span>
                <span class="s0">return </span><span class="s1">self.difference(other</span><span class="s0">, </span><span class="s1">sort=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s1">super().delete(loc)</span>

    <span class="s0">def </span><span class="s1">insert(self</span><span class="s0">, </span><span class="s1">loc: int</span><span class="s0">, </span><span class="s1">item) -&gt; Index:</span>
        <span class="s0">if </span><span class="s1">len(self) </span><span class="s0">and </span><span class="s1">(is_integer(item) </span><span class="s0">or </span><span class="s1">is_float(item)):</span>
            <span class="s5"># We can retain RangeIndex is inserting at the beginning or end,</span>
            <span class="s5">#  or right in the middle.</span>
            <span class="s1">rng = self._range</span>
            <span class="s0">if </span><span class="s1">loc == </span><span class="s2">0 </span><span class="s0">and </span><span class="s1">item == self[</span><span class="s2">0</span><span class="s1">] - self.step:</span>
                <span class="s1">new_rng = range(rng.start - rng.step</span><span class="s0">, </span><span class="s1">rng.stop</span><span class="s0">, </span><span class="s1">rng.step)</span>
                <span class="s0">return </span><span class="s1">type(self)._simple_new(new_rng</span><span class="s0">, </span><span class="s1">name=self._name)</span>

            <span class="s0">elif </span><span class="s1">loc == len(self) </span><span class="s0">and </span><span class="s1">item == self[-</span><span class="s2">1</span><span class="s1">] + self.step:</span>
                <span class="s1">new_rng = range(rng.start</span><span class="s0">, </span><span class="s1">rng.stop + rng.step</span><span class="s0">, </span><span class="s1">rng.step)</span>
                <span class="s0">return </span><span class="s1">type(self)._simple_new(new_rng</span><span class="s0">, </span><span class="s1">name=self._name)</span>

            <span class="s0">elif </span><span class="s1">len(self) == </span><span class="s2">2 </span><span class="s0">and </span><span class="s1">item == self[</span><span class="s2">0</span><span class="s1">] + self.step / </span><span class="s2">2</span><span class="s1">:</span>
                <span class="s5"># e.g. inserting 1 into [0, 2]</span>
                <span class="s1">step = int(self.step / </span><span class="s2">2</span><span class="s1">)</span>
                <span class="s1">new_rng = range(self.start</span><span class="s0">, </span><span class="s1">self.stop</span><span class="s0">, </span><span class="s1">step)</span>
                <span class="s0">return </span><span class="s1">type(self)._simple_new(new_rng</span><span class="s0">, </span><span class="s1">name=self._name)</span>

        <span class="s0">return </span><span class="s1">super().insert(loc</span><span class="s0">, </span><span class="s1">item)</span>

    <span class="s0">def </span><span class="s1">_concat(self</span><span class="s0">, </span><span class="s1">indexes: list[Index]</span><span class="s0">, </span><span class="s1">name: Hashable) -&gt; Index:</span>
        <span class="s3">&quot;&quot;&quot; 
        Overriding parent method for the case of all RangeIndex instances. 
 
        When all members of &quot;indexes&quot; are of type RangeIndex: result will be 
        RangeIndex if possible, Index with a int64 dtype otherwise. E.g.: 
        indexes = [RangeIndex(3), RangeIndex(3, 6)] -&gt; RangeIndex(6) 
        indexes = [RangeIndex(3), RangeIndex(4, 6)] -&gt; Index([0,1,2,4,5], dtype='int64') 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">all(isinstance(x</span><span class="s0">, </span><span class="s1">RangeIndex) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">indexes):</span>
            <span class="s0">return </span><span class="s1">super()._concat(indexes</span><span class="s0">, </span><span class="s1">name)</span>

        <span class="s0">elif </span><span class="s1">len(indexes) == </span><span class="s2">1</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">indexes[</span><span class="s2">0</span><span class="s1">]</span>

        <span class="s1">rng_indexes = cast(list[RangeIndex]</span><span class="s0">, </span><span class="s1">indexes)</span>

        <span class="s1">start = step = next_ = </span><span class="s0">None</span>

        <span class="s5"># Filter the empty indexes</span>
        <span class="s1">non_empty_indexes = [obj </span><span class="s0">for </span><span class="s1">obj </span><span class="s0">in </span><span class="s1">rng_indexes </span><span class="s0">if </span><span class="s1">len(obj)]</span>

        <span class="s0">for </span><span class="s1">obj </span><span class="s0">in </span><span class="s1">non_empty_indexes:</span>
            <span class="s1">rng = obj._range</span>

            <span class="s0">if </span><span class="s1">start </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s5"># This is set by the first non-empty index</span>
                <span class="s1">start = rng.start</span>
                <span class="s0">if </span><span class="s1">step </span><span class="s0">is None and </span><span class="s1">len(rng) &gt; </span><span class="s2">1</span><span class="s1">:</span>
                    <span class="s1">step = rng.step</span>
            <span class="s0">elif </span><span class="s1">step </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s5"># First non-empty index had only one element</span>
                <span class="s0">if </span><span class="s1">rng.start == start:</span>
                    <span class="s1">values = np.concatenate([x._values </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">rng_indexes])</span>
                    <span class="s1">result = self._constructor(values)</span>
                    <span class="s0">return </span><span class="s1">result.rename(name)</span>

                <span class="s1">step = rng.start - start</span>

            <span class="s1">non_consecutive = (step != rng.step </span><span class="s0">and </span><span class="s1">len(rng) &gt; </span><span class="s2">1</span><span class="s1">) </span><span class="s0">or </span><span class="s1">(</span>
                <span class="s1">next_ </span><span class="s0">is not None and </span><span class="s1">rng.start != next_</span>
            <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">non_consecutive:</span>
                <span class="s1">result = self._constructor(</span>
                    <span class="s1">np.concatenate([x._values </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">rng_indexes])</span>
                <span class="s1">)</span>
                <span class="s0">return </span><span class="s1">result.rename(name)</span>

            <span class="s0">if </span><span class="s1">step </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">next_ = rng[-</span><span class="s2">1</span><span class="s1">] + step</span>

        <span class="s0">if </span><span class="s1">non_empty_indexes:</span>
            <span class="s5"># Get the stop value from &quot;next&quot; or alternatively</span>
            <span class="s5"># from the last non-empty index</span>
            <span class="s1">stop = non_empty_indexes[-</span><span class="s2">1</span><span class="s1">].stop </span><span class="s0">if </span><span class="s1">next_ </span><span class="s0">is None else </span><span class="s1">next_</span>
            <span class="s0">return </span><span class="s1">RangeIndex(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">step).rename(name)</span>

        <span class="s5"># Here all &quot;indexes&quot; had 0 length, i.e. were empty.</span>
        <span class="s5"># In this case return an empty range index.</span>
        <span class="s0">return </span><span class="s1">RangeIndex(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">).rename(name)</span>

    <span class="s0">def </span><span class="s1">__len__(self) -&gt; int:</span>
        <span class="s3">&quot;&quot;&quot; 
        return the length of the RangeIndex 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">len(self._range)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">size(self) -&gt; int:</span>
        <span class="s0">return </span><span class="s1">len(self)</span>

    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s3">&quot;&quot;&quot; 
        Conserve RangeIndex type for scalar and slice keys. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">slice):</span>
            <span class="s0">return </span><span class="s1">self._getitem_slice(key)</span>
        <span class="s0">elif </span><span class="s1">is_integer(key):</span>
            <span class="s1">new_key = int(key)</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">self._range[new_key]</span>
            <span class="s0">except </span><span class="s1">IndexError </span><span class="s0">as </span><span class="s1">err:</span>
                <span class="s0">raise </span><span class="s1">IndexError(</span>
                    <span class="s4">f&quot;index </span><span class="s0">{</span><span class="s1">key</span><span class="s0">} </span><span class="s4">is out of bounds for axis 0 with size </span><span class="s0">{</span><span class="s1">len(self)</span><span class="s0">}</span><span class="s4">&quot;</span>
                <span class="s1">) </span><span class="s0">from </span><span class="s1">err</span>
        <span class="s0">elif </span><span class="s1">is_scalar(key):</span>
            <span class="s0">raise </span><span class="s1">IndexError(</span>
                <span class="s4">&quot;only integers, slices (`:`), &quot;</span>
                <span class="s4">&quot;ellipsis (`...`), numpy.newaxis (`None`) &quot;</span>
                <span class="s4">&quot;and integer or boolean &quot;</span>
                <span class="s4">&quot;arrays are valid indices&quot;</span>
            <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">super().__getitem__(key)</span>

    <span class="s0">def </span><span class="s1">_getitem_slice(self</span><span class="s0">, </span><span class="s1">slobj: slice) -&gt; Self:</span>
        <span class="s3">&quot;&quot;&quot; 
        Fastpath for __getitem__ when we know we have a slice. 
        &quot;&quot;&quot;</span>
        <span class="s1">res = self._range[slobj]</span>
        <span class="s0">return </span><span class="s1">type(self)._simple_new(res</span><span class="s0">, </span><span class="s1">name=self._name)</span>

    <span class="s1">@unpack_zerodim_and_defer(</span><span class="s4">&quot;__floordiv__&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">__floordiv__(self</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s0">if </span><span class="s1">is_integer(other) </span><span class="s0">and </span><span class="s1">other != </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">len(self) == </span><span class="s2">0 </span><span class="s0">or </span><span class="s1">self.start % other == </span><span class="s2">0 </span><span class="s0">and </span><span class="s1">self.step % other == </span><span class="s2">0</span><span class="s1">:</span>
                <span class="s1">start = self.start // other</span>
                <span class="s1">step = self.step // other</span>
                <span class="s1">stop = start + len(self) * step</span>
                <span class="s1">new_range = range(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">step </span><span class="s0">or </span><span class="s2">1</span><span class="s1">)</span>
                <span class="s0">return </span><span class="s1">self._simple_new(new_range</span><span class="s0">, </span><span class="s1">name=self._name)</span>
            <span class="s0">if </span><span class="s1">len(self) == </span><span class="s2">1</span><span class="s1">:</span>
                <span class="s1">start = self.start // other</span>
                <span class="s1">new_range = range(start</span><span class="s0">, </span><span class="s1">start + </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
                <span class="s0">return </span><span class="s1">self._simple_new(new_range</span><span class="s0">, </span><span class="s1">name=self._name)</span>

        <span class="s0">return </span><span class="s1">super().__floordiv__(other)</span>

    <span class="s5"># --------------------------------------------------------------------</span>
    <span class="s5"># Reductions</span>

    <span class="s0">def </span><span class="s1">all(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs) -&gt; bool:</span>
        <span class="s0">return </span><span class="s2">0 </span><span class="s0">not in </span><span class="s1">self._range</span>

    <span class="s0">def </span><span class="s1">any(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs) -&gt; bool:</span>
        <span class="s0">return </span><span class="s1">any(self._range)</span>

    <span class="s5"># --------------------------------------------------------------------</span>

    <span class="s0">def </span><span class="s1">_cmp_method(self</span><span class="s0">, </span><span class="s1">other</span><span class="s0">, </span><span class="s1">op):</span>
        <span class="s0">if </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">RangeIndex) </span><span class="s0">and </span><span class="s1">self._range == other._range:</span>
            <span class="s5"># Both are immutable so if ._range attr. are equal, shortcut is possible</span>
            <span class="s0">return </span><span class="s1">super()._cmp_method(self</span><span class="s0">, </span><span class="s1">op)</span>
        <span class="s0">return </span><span class="s1">super()._cmp_method(other</span><span class="s0">, </span><span class="s1">op)</span>

    <span class="s0">def </span><span class="s1">_arith_method(self</span><span class="s0">, </span><span class="s1">other</span><span class="s0">, </span><span class="s1">op):</span>
        <span class="s3">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        other : Any 
        op : callable that accepts 2 params 
            perform the binary op 
        &quot;&quot;&quot;</span>

        <span class="s0">if </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">ABCTimedeltaIndex):</span>
            <span class="s5"># Defer to TimedeltaIndex implementation</span>
            <span class="s0">return </span><span class="s1">NotImplemented</span>
        <span class="s0">elif </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">(timedelta</span><span class="s0">, </span><span class="s1">np.timedelta64)):</span>
            <span class="s5"># GH#19333 is_integer evaluated True on timedelta64,</span>
            <span class="s5"># so we need to catch these explicitly</span>
            <span class="s0">return </span><span class="s1">super()._arith_method(other</span><span class="s0">, </span><span class="s1">op)</span>
        <span class="s0">elif </span><span class="s1">lib.is_np_dtype(getattr(other</span><span class="s0">, </span><span class="s4">&quot;dtype&quot;</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">, </span><span class="s4">&quot;m&quot;</span><span class="s1">):</span>
            <span class="s5"># Must be an np.ndarray; GH#22390</span>
            <span class="s0">return </span><span class="s1">super()._arith_method(other</span><span class="s0">, </span><span class="s1">op)</span>

        <span class="s0">if </span><span class="s1">op </span><span class="s0">in </span><span class="s1">[</span>
            <span class="s1">operator.pow</span><span class="s0">,</span>
            <span class="s1">ops.rpow</span><span class="s0">,</span>
            <span class="s1">operator.mod</span><span class="s0">,</span>
            <span class="s1">ops.rmod</span><span class="s0">,</span>
            <span class="s1">operator.floordiv</span><span class="s0">,</span>
            <span class="s1">ops.rfloordiv</span><span class="s0">,</span>
            <span class="s1">divmod</span><span class="s0">,</span>
            <span class="s1">ops.rdivmod</span><span class="s0">,</span>
        <span class="s1">]:</span>
            <span class="s0">return </span><span class="s1">super()._arith_method(other</span><span class="s0">, </span><span class="s1">op)</span>

        <span class="s1">step: Callable | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">op </span><span class="s0">in </span><span class="s1">[operator.mul</span><span class="s0">, </span><span class="s1">ops.rmul</span><span class="s0">, </span><span class="s1">operator.truediv</span><span class="s0">, </span><span class="s1">ops.rtruediv]:</span>
            <span class="s1">step = op</span>

        <span class="s5"># TODO: if other is a RangeIndex we may have more efficient options</span>
        <span class="s1">right = extract_array(other</span><span class="s0">, </span><span class="s1">extract_numpy=</span><span class="s0">True, </span><span class="s1">extract_range=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">left = self</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s5"># apply if we have an override</span>
            <span class="s0">if </span><span class="s1">step:</span>
                <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s4">&quot;ignore&quot;</span><span class="s1">):</span>
                    <span class="s1">rstep = step(left.step</span><span class="s0">, </span><span class="s1">right)</span>

                <span class="s5"># we don't have a representable op</span>
                <span class="s5"># so return a base index</span>
                <span class="s0">if not </span><span class="s1">is_integer(rstep) </span><span class="s0">or not </span><span class="s1">rstep:</span>
                    <span class="s0">raise </span><span class="s1">ValueError</span>

            <span class="s5"># GH#53255</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">rstep = -left.step </span><span class="s0">if </span><span class="s1">op == ops.rsub </span><span class="s0">else </span><span class="s1">left.step</span>

            <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s4">&quot;ignore&quot;</span><span class="s1">):</span>
                <span class="s1">rstart = op(left.start</span><span class="s0">, </span><span class="s1">right)</span>
                <span class="s1">rstop = op(left.stop</span><span class="s0">, </span><span class="s1">right)</span>

            <span class="s1">res_name = ops.get_op_result_name(self</span><span class="s0">, </span><span class="s1">other)</span>
            <span class="s1">result = type(self)(rstart</span><span class="s0">, </span><span class="s1">rstop</span><span class="s0">, </span><span class="s1">rstep</span><span class="s0">, </span><span class="s1">name=res_name)</span>

            <span class="s5"># for compat with numpy / Index with int64 dtype</span>
            <span class="s5"># even if we can represent as a RangeIndex, return</span>
            <span class="s5"># as a float64 Index if we have float-like descriptors</span>
            <span class="s0">if not </span><span class="s1">all(is_integer(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">[rstart</span><span class="s0">, </span><span class="s1">rstop</span><span class="s0">, </span><span class="s1">rstep]):</span>
                <span class="s1">result = result.astype(</span><span class="s4">&quot;float64&quot;</span><span class="s1">)</span>

            <span class="s0">return </span><span class="s1">result</span>

        <span class="s0">except </span><span class="s1">(ValueError</span><span class="s0">, </span><span class="s1">TypeError</span><span class="s0">, </span><span class="s1">ZeroDivisionError):</span>
            <span class="s5"># test_arithmetic_explicit_conversions</span>
            <span class="s0">return </span><span class="s1">super()._arith_method(other</span><span class="s0">, </span><span class="s1">op)</span>

    <span class="s0">def </span><span class="s1">take(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">indices</span><span class="s0">,</span>
        <span class="s1">axis: Axis = </span><span class="s2">0</span><span class="s0">,</span>
        <span class="s1">allow_fill: bool = </span><span class="s0">True,</span>
        <span class="s1">fill_value=</span><span class="s0">None,</span>
        <span class="s1">**kwargs</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s0">if </span><span class="s1">kwargs:</span>
            <span class="s1">nv.validate_take(()</span><span class="s0">, </span><span class="s1">kwargs)</span>
        <span class="s0">if </span><span class="s1">is_scalar(indices):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Expected indices to be array-like&quot;</span><span class="s1">)</span>
        <span class="s1">indices = ensure_platform_int(indices)</span>

        <span class="s5"># raise an exception if allow_fill is True and fill_value is not None</span>
        <span class="s1">self._maybe_disallow_fill(allow_fill</span><span class="s0">, </span><span class="s1">fill_value</span><span class="s0">, </span><span class="s1">indices)</span>

        <span class="s0">if </span><span class="s1">len(indices) == </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s1">taken = np.array([]</span><span class="s0">, </span><span class="s1">dtype=self.dtype)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">ind_max = indices.max()</span>
            <span class="s0">if </span><span class="s1">ind_max &gt;= len(self):</span>
                <span class="s0">raise </span><span class="s1">IndexError(</span>
                    <span class="s4">f&quot;index </span><span class="s0">{</span><span class="s1">ind_max</span><span class="s0">} </span><span class="s4">is out of bounds for axis 0 with size </span><span class="s0">{</span><span class="s1">len(self)</span><span class="s0">}</span><span class="s4">&quot;</span>
                <span class="s1">)</span>
            <span class="s1">ind_min = indices.min()</span>
            <span class="s0">if </span><span class="s1">ind_min &lt; -len(self):</span>
                <span class="s0">raise </span><span class="s1">IndexError(</span>
                    <span class="s4">f&quot;index </span><span class="s0">{</span><span class="s1">ind_min</span><span class="s0">} </span><span class="s4">is out of bounds for axis 0 with size </span><span class="s0">{</span><span class="s1">len(self)</span><span class="s0">}</span><span class="s4">&quot;</span>
                <span class="s1">)</span>
            <span class="s1">taken = indices.astype(self.dtype</span><span class="s0">, </span><span class="s1">casting=</span><span class="s4">&quot;safe&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">ind_min &lt; </span><span class="s2">0</span><span class="s1">:</span>
                <span class="s1">taken %= len(self)</span>
            <span class="s0">if </span><span class="s1">self.step != </span><span class="s2">1</span><span class="s1">:</span>
                <span class="s1">taken *= self.step</span>
            <span class="s0">if </span><span class="s1">self.start != </span><span class="s2">0</span><span class="s1">:</span>
                <span class="s1">taken += self.start</span>

        <span class="s5"># _constructor so RangeIndex-&gt; Index with an int64 dtype</span>
        <span class="s0">return </span><span class="s1">self._constructor._simple_new(taken</span><span class="s0">, </span><span class="s1">name=self.name)</span>
</pre>
</body>
</html>