<html>
<head>
<title>vecm.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
vecm.py</font>
</center></td></tr></table>
<pre><span class="s0"># -*- coding: utf-8 -*-</span>
<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">defaultdict</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy </span><span class="s2">import </span><span class="s1">hstack</span><span class="s2">, </span><span class="s1">vstack</span>
<span class="s2">from </span><span class="s1">numpy.linalg </span><span class="s2">import </span><span class="s1">inv</span><span class="s2">, </span><span class="s1">svd</span>
<span class="s2">import </span><span class="s1">scipy</span>
<span class="s2">import </span><span class="s1">scipy.stats</span>

<span class="s2">from </span><span class="s1">statsmodels.iolib.summary </span><span class="s2">import </span><span class="s1">Summary</span>
<span class="s2">from </span><span class="s1">statsmodels.iolib.table </span><span class="s2">import </span><span class="s1">SimpleTable</span>
<span class="s2">from </span><span class="s1">statsmodels.tools.decorators </span><span class="s2">import </span><span class="s1">cache_readonly</span>
<span class="s2">from </span><span class="s1">statsmodels.tools.sm_exceptions </span><span class="s2">import </span><span class="s1">HypothesisTestWarning</span>
<span class="s2">from </span><span class="s1">statsmodels.tools.validation </span><span class="s2">import </span><span class="s1">string_like</span>
<span class="s2">import </span><span class="s1">statsmodels.tsa.base.tsa_model </span><span class="s2">as </span><span class="s1">tsbase</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.coint_tables </span><span class="s2">import </span><span class="s1">c_sja</span><span class="s2">, </span><span class="s1">c_sjt</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.tsatools </span><span class="s2">import </span><span class="s1">duplication_matrix</span><span class="s2">, </span><span class="s1">lagmat</span><span class="s2">, </span><span class="s1">vec</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.vector_ar.hypothesis_test_results </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">CausalityTestResults</span><span class="s2">,</span>
    <span class="s1">WhitenessTestResults</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">statsmodels.tsa.vector_ar.irf </span><span class="s2">as </span><span class="s1">irf</span>
<span class="s2">import </span><span class="s1">statsmodels.tsa.vector_ar.plotting </span><span class="s2">as </span><span class="s1">plot</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.vector_ar.util </span><span class="s2">import </span><span class="s1">get_index</span><span class="s2">, </span><span class="s1">seasonal_dummies</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.vector_ar.var_model </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">VAR</span><span class="s2">,</span>
    <span class="s1">LagOrderResults</span><span class="s2">,</span>
    <span class="s1">_compute_acov</span><span class="s2">,</span>
    <span class="s1">forecast</span><span class="s2">,</span>
    <span class="s1">forecast_interval</span><span class="s2">,</span>
    <span class="s1">ma_rep</span><span class="s2">,</span>
    <span class="s1">orth_ma_rep</span><span class="s2">,</span>
    <span class="s1">test_normality</span><span class="s2">,</span>
<span class="s1">)</span>


<span class="s2">def </span><span class="s1">select_order(</span>
    <span class="s1">data</span><span class="s2">,</span>
    <span class="s1">maxlags: int</span><span class="s2">,</span>
    <span class="s1">deterministic: str = </span><span class="s3">&quot;n&quot;</span><span class="s2">,</span>
    <span class="s1">seasons: int = </span><span class="s4">0</span><span class="s2">,</span>
    <span class="s1">exog=</span><span class="s2">None,</span>
    <span class="s1">exog_coint=</span><span class="s2">None,</span>
<span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Compute lag order selections based on each of the available information 
    criteria. 
 
    Parameters 
    ---------- 
    data : array_like (nobs_tot x neqs) 
        The observed data. 
    maxlags : int 
        All orders until maxlag will be compared according to the information 
        criteria listed in the Results-section of this docstring. 
    deterministic : str {&quot;n&quot;, &quot;co&quot;, &quot;ci&quot;, &quot;lo&quot;, &quot;li&quot;} 
        * ``&quot;n&quot;`` - no deterministic terms 
        * ``&quot;co&quot;`` - constant outside the cointegration relation 
        * ``&quot;ci&quot;`` - constant within the cointegration relation 
        * ``&quot;lo&quot;`` - linear trend outside the cointegration relation 
        * ``&quot;li&quot;`` - linear trend within the cointegration relation 
 
        Combinations of these are possible (e.g. ``&quot;cili&quot;`` or ``&quot;colo&quot;`` for 
        linear trend with intercept). See the docstring of the 
        :class:`VECM`-class for more information. 
    seasons : int, default: 0 
        Number of periods in a seasonal cycle. 
    exog : ndarray (nobs_tot x neqs) or `None`, default: `None` 
        Deterministic terms outside the cointegration relation. 
    exog_coint : ndarray (nobs_tot x neqs) or `None`, default: `None` 
        Deterministic terms inside the cointegration relation. 
 
    Returns 
    ------- 
    selected_orders : :class:`statsmodels.tsa.vector_ar.var_model.LagOrderResults` 
    &quot;&quot;&quot;</span>
    <span class="s1">ic = defaultdict(list)</span>
    <span class="s1">deterministic = string_like(deterministic</span><span class="s2">, </span><span class="s3">&quot;deterministic&quot;</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">maxlags + </span><span class="s4">2</span><span class="s1">):  </span><span class="s0"># +2 because k_ar_VECM == k_ar_VAR - 1</span>
        <span class="s1">exogs = []</span>
        <span class="s2">if </span><span class="s3">&quot;co&quot; </span><span class="s2">in </span><span class="s1">deterministic </span><span class="s2">or </span><span class="s3">&quot;ci&quot; </span><span class="s2">in </span><span class="s1">deterministic:</span>
            <span class="s1">exogs.append(np.ones(len(data)).reshape(-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s3">&quot;lo&quot; </span><span class="s2">in </span><span class="s1">deterministic </span><span class="s2">or </span><span class="s3">&quot;li&quot; </span><span class="s2">in </span><span class="s1">deterministic:</span>
            <span class="s1">exogs.append(</span><span class="s4">1 </span><span class="s1">+ np.arange(len(data)).reshape(-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">exog_coint </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">exogs.append(exog_coint)</span>
        <span class="s2">if </span><span class="s1">seasons &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">exogs.append(</span>
                <span class="s1">seasonal_dummies(seasons</span><span class="s2">, </span><span class="s1">len(data)).reshape(-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">seasons - </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">exog </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">exogs.append(exog)</span>
        <span class="s1">exogs = hstack(exogs) </span><span class="s2">if </span><span class="s1">exogs </span><span class="s2">else None</span>
        <span class="s1">var_model = VAR(data</span><span class="s2">, </span><span class="s1">exogs)</span>
        <span class="s0"># exclude some periods ==&gt; same amount of data used for each lag order</span>
        <span class="s1">var_result = var_model._estimate_var(lags=p</span><span class="s2">, </span><span class="s1">offset=maxlags + </span><span class="s4">1 </span><span class="s1">- p)</span>

        <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">var_result.info_criteria.items():</span>
            <span class="s1">ic[k].append(v)</span>
    <span class="s0"># -1+1 in the following line is only here for clarification.</span>
    <span class="s0"># -1 because k_ar_VECM == k_ar_VAR - 1</span>
    <span class="s0"># +1 because p == index +1 (we start with p=1, not p=0)</span>
    <span class="s1">selected_orders = dict(</span>
        <span class="s1">(ic_name</span><span class="s2">, </span><span class="s1">np.array(ic_value).argmin() - </span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">ic_name</span><span class="s2">, </span><span class="s1">ic_value </span><span class="s2">in </span><span class="s1">ic.items()</span>
    <span class="s1">)</span>

    <span class="s2">return </span><span class="s1">LagOrderResults(ic</span><span class="s2">, </span><span class="s1">selected_orders</span><span class="s2">, True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_linear_trend(nobs</span><span class="s2">, </span><span class="s1">k_ar</span><span class="s2">, </span><span class="s1">coint=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Construct an ndarray representing a linear trend in a VECM. 
 
    Parameters 
    ---------- 
    nobs : int 
        Number of observations excluding the presample. 
    k_ar : int 
        Number of lags in levels. 
    coint : bool, default: False 
        If True (False), the returned array represents a linear trend inside 
        (outside) the cointegration relation. 
 
    Returns 
    ------- 
    ret : ndarray (nobs) 
        An ndarray representing a linear trend in a VECM 
 
    Notes 
    ----- 
    The returned array's size is nobs and not nobs_tot so it cannot be used to 
    construct the exog-argument of VECM's __init__ method. 
    &quot;&quot;&quot;</span>
    <span class="s1">ret = np.arange(nobs) + k_ar</span>
    <span class="s2">if not </span><span class="s1">coint:</span>
        <span class="s1">ret += </span><span class="s4">1</span>
    <span class="s2">return </span><span class="s1">ret</span>


<span class="s2">def </span><span class="s1">_num_det_vars(det_string</span><span class="s2">, </span><span class="s1">seasons=</span><span class="s4">0</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot;Gives the number of deterministic variables specified by det_string and 
    seasons. 
 
    Parameters 
    ---------- 
    det_string : str {&quot;n&quot;, &quot;co&quot;, &quot;ci&quot;, &quot;lo&quot;, &quot;li&quot;} 
        * &quot;n&quot; - no deterministic terms 
        * &quot;co&quot; - constant outside the cointegration relation 
        * &quot;ci&quot; - constant within the cointegration relation 
        * &quot;lo&quot; - linear trend outside the cointegration relation 
        * &quot;li&quot; - linear trend within the cointegration relation 
 
        Combinations of these are possible (e.g. &quot;cili&quot; or &quot;colo&quot; for linear 
        trend with intercept). See the docstring of the :class:`VECM`-class for 
        more information. 
    seasons : int 
        Number of periods in a seasonal cycle. 
 
    Returns 
    ------- 
    num : int 
        Number of deterministic terms and number dummy variables for seasonal 
        terms. 
    &quot;&quot;&quot;</span>
    <span class="s1">num = </span><span class="s4">0</span>
    <span class="s1">det_string = string_like(det_string</span><span class="s2">, </span><span class="s3">&quot;det_string&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s3">&quot;ci&quot; </span><span class="s2">in </span><span class="s1">det_string </span><span class="s2">or </span><span class="s3">&quot;co&quot; </span><span class="s2">in </span><span class="s1">det_string:</span>
        <span class="s1">num += </span><span class="s4">1</span>
    <span class="s2">if </span><span class="s3">&quot;li&quot; </span><span class="s2">in </span><span class="s1">det_string </span><span class="s2">or </span><span class="s3">&quot;lo&quot; </span><span class="s2">in </span><span class="s1">det_string:</span>
        <span class="s1">num += </span><span class="s4">1</span>
    <span class="s2">if </span><span class="s1">seasons &gt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">num += seasons - </span><span class="s4">1</span>
    <span class="s2">return </span><span class="s1">num</span>


<span class="s2">def </span><span class="s1">_deterministic_to_exog(</span>
    <span class="s1">deterministic</span><span class="s2">,</span>
    <span class="s1">seasons</span><span class="s2">,</span>
    <span class="s1">nobs_tot</span><span class="s2">,</span>
    <span class="s1">first_season=</span><span class="s4">0</span><span class="s2">,</span>
    <span class="s1">seasons_centered=</span><span class="s2">False,</span>
    <span class="s1">exog=</span><span class="s2">None,</span>
    <span class="s1">exog_coint=</span><span class="s2">None,</span>
<span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Translate all information about deterministic terms into a single array. 
 
    These information is taken from `deterministic` and `seasons` as well as 
    from the `exog` and `exog_coint` arrays. The resulting array form can then 
    be used e.g. in VAR's __init__ method. 
 
    Parameters 
    ---------- 
    deterministic : str 
        A string specifying the deterministic terms in the model. See VECM's 
        docstring for more information. 
    seasons : int 
        Number of periods in a seasonal cycle. 
    nobs_tot : int 
        Number of observations including the presample. 
    first_season : int, default: 0 
        Season of the first observation. 
    seasons_centered : bool, default: False 
        If True, the seasonal dummy variables are demeaned such that they are 
        orthogonal to an intercept term. 
    exog : ndarray (nobs_tot x #det_terms) or None, default: None 
        An ndarray representing deterministic terms outside the cointegration 
        relation. 
    exog_coint : ndarray (nobs_tot x #det_terms_coint) or None, default: None 
        An ndarray representing deterministic terms inside the cointegration 
        relation. 
 
    Returns 
    ------- 
    exog : ndarray or None 
        None, if the function's arguments do not contain deterministic terms. 
        Otherwise, an ndarray representing these deterministic terms. 
    &quot;&quot;&quot;</span>
    <span class="s1">exogs = []</span>
    <span class="s1">deterministic = string_like(deterministic</span><span class="s2">, </span><span class="s3">&quot;deterministic&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s3">&quot;co&quot; </span><span class="s2">in </span><span class="s1">deterministic </span><span class="s2">or </span><span class="s3">&quot;ci&quot; </span><span class="s2">in </span><span class="s1">deterministic:</span>
        <span class="s1">exogs.append(np.ones(nobs_tot))</span>
    <span class="s2">if </span><span class="s1">exog_coint </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">exogs.append(exog_coint)</span>
    <span class="s2">if </span><span class="s3">&quot;lo&quot; </span><span class="s2">in </span><span class="s1">deterministic </span><span class="s2">or </span><span class="s3">&quot;li&quot; </span><span class="s2">in </span><span class="s1">deterministic:</span>
        <span class="s1">exogs.append(np.arange(nobs_tot))</span>
    <span class="s2">if </span><span class="s1">seasons &gt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">exogs.append(</span>
            <span class="s1">seasonal_dummies(</span>
                <span class="s1">seasons</span><span class="s2">,</span>
                <span class="s1">nobs_tot</span><span class="s2">,</span>
                <span class="s1">first_period=first_season</span><span class="s2">,</span>
                <span class="s1">centered=seasons_centered</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
    <span class="s2">if </span><span class="s1">exog </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">exogs.append(exog)</span>
    <span class="s2">return </span><span class="s1">np.column_stack(exogs) </span><span class="s2">if </span><span class="s1">exogs </span><span class="s2">else None</span>


<span class="s2">def </span><span class="s1">_mat_sqrt(_2darray):</span>
    <span class="s5">&quot;&quot;&quot;Calculates the square root of a matrix. 
 
    Parameters 
    ---------- 
    _2darray : ndarray 
        A 2-dimensional ndarray representing a square matrix. 
 
    Returns 
    ------- 
    result : ndarray 
        Square root of the matrix given as function argument. 
    &quot;&quot;&quot;</span>
    <span class="s1">u_</span><span class="s2">, </span><span class="s1">s_</span><span class="s2">, </span><span class="s1">v_ = svd(_2darray</span><span class="s2">, </span><span class="s1">full_matrices=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">s_ = np.sqrt(s_)</span>
    <span class="s2">return </span><span class="s1">u_.dot(s_[:</span><span class="s2">, None</span><span class="s1">] * v_)</span>


<span class="s2">def </span><span class="s1">_endog_matrices(</span>
    <span class="s1">endog</span><span class="s2">,</span>
    <span class="s1">exog</span><span class="s2">,</span>
    <span class="s1">exog_coint</span><span class="s2">,</span>
    <span class="s1">diff_lags</span><span class="s2">,</span>
    <span class="s1">deterministic</span><span class="s2">,</span>
    <span class="s1">seasons=</span><span class="s4">0</span><span class="s2">,</span>
    <span class="s1">first_season=</span><span class="s4">0</span><span class="s2">,</span>
<span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Returns different matrices needed for parameter estimation. 
 
    Compare p. 186 in [1]_. The returned matrices consist of elements of the 
    data as well as elements representing deterministic terms. A tuple of 
    consisting of these matrices is returned. 
 
    Parameters 
    ---------- 
    endog : ndarray (neqs x nobs_tot) 
        The whole sample including the presample. 
    exog : ndarray (nobs_tot x neqs) or None 
        Deterministic terms outside the cointegration relation. 
    exog_coint : ndarray (nobs_tot x neqs) or None 
        Deterministic terms inside the cointegration relation. 
    diff_lags : int 
        Number of lags in the VEC representation. 
    deterministic : str {``&quot;n&quot;``, ``&quot;co&quot;``, ``&quot;ci&quot;``, ``&quot;lo&quot;``, ``&quot;li&quot;``} 
        * ``&quot;n&quot;`` - no deterministic terms 
        * ``&quot;co&quot;`` - constant outside the cointegration relation 
        * ``&quot;ci&quot;`` - constant within the cointegration relation 
        * ``&quot;lo&quot;`` - linear trend outside the cointegration relation 
        * ``&quot;li&quot;`` - linear trend within the cointegration relation 
 
        Combinations of these are possible (e.g. ``&quot;cili&quot;`` or ``&quot;colo&quot;`` for 
        linear trend with intercept). See the docstring of the 
        :class:`VECM`-class for more information. 
    seasons : int, default: 0 
        Number of periods in a seasonal cycle. 0 (default) means no seasons. 
    first_season : int, default: 0 
        The season of the first observation. `0` means first season, `1` means 
        second season, ..., `seasons-1` means the last season. 
 
    Returns 
    ------- 
    y_1_T : ndarray (neqs x nobs) 
        The (transposed) data without the presample. 
        `.. math:: (y_1, \\ldots, y_T) 
    delta_y_1_T : ndarray (neqs x nobs) 
        The first differences of endog. 
        `.. math:: (y_1, \\ldots, y_T) - (y_0, \\ldots, y_{T-1}) 
    y_lag1 : ndarray (neqs x nobs) 
        (dimensions assuming no deterministic terms are given) 
        Endog of the previous period (lag 1). 
        `.. math:: (y_0, \\ldots, y_{T-1}) 
    delta_x : ndarray (k_ar_diff*neqs x nobs) 
        (dimensions assuming no deterministic terms are given) 
        Lagged differenced endog, used as regressor for the short term 
        equation. 
 
    References 
    ---------- 
    .. [1] Lütkepohl, H. 2005. *New Introduction to Multiple Time Series Analysis*. Springer. 
    &quot;&quot;&quot;</span>
    <span class="s1">deterministic = string_like(deterministic</span><span class="s2">, </span><span class="s3">&quot;deterministic&quot;</span><span class="s1">)</span>
    <span class="s0"># p. 286:</span>
    <span class="s1">p = diff_lags + </span><span class="s4">1</span>
    <span class="s1">y = endog</span>
    <span class="s1">K = y.shape[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">y_1_T = y[:</span><span class="s2">, </span><span class="s1">p:]</span>
    <span class="s1">T = y_1_T.shape[</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">delta_y = np.diff(y)</span>
    <span class="s1">delta_y_1_T = delta_y[:</span><span class="s2">, </span><span class="s1">p - </span><span class="s4">1 </span><span class="s1">:]</span>

    <span class="s1">y_lag1 = y[:</span><span class="s2">, </span><span class="s1">p - </span><span class="s4">1 </span><span class="s1">: -</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s2">if </span><span class="s3">&quot;co&quot; </span><span class="s2">in </span><span class="s1">deterministic </span><span class="s2">and </span><span class="s3">&quot;ci&quot; </span><span class="s2">in </span><span class="s1">deterministic:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s3">&quot;Both 'co' and 'ci' as deterministic terms given. &quot;</span>
            <span class="s1">+ </span><span class="s3">&quot;Please choose one of the two.&quot;</span>
        <span class="s1">)</span>
    <span class="s1">y_lag1_stack = [y_lag1]</span>
    <span class="s2">if </span><span class="s3">&quot;ci&quot; </span><span class="s2">in </span><span class="s1">deterministic:  </span><span class="s0"># pp. 257, 299, 306, 307</span>
        <span class="s1">y_lag1_stack.append(np.ones(T))</span>
    <span class="s2">if </span><span class="s3">&quot;li&quot; </span><span class="s2">in </span><span class="s1">deterministic:  </span><span class="s0"># p. 299</span>
        <span class="s1">y_lag1_stack.append(_linear_trend(T</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">coint=</span><span class="s2">True</span><span class="s1">))</span>
    <span class="s2">if </span><span class="s1">exog_coint </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">y_lag1_stack.append(exog_coint[-T - </span><span class="s4">1 </span><span class="s1">: -</span><span class="s4">1</span><span class="s1">].T)</span>
    <span class="s1">y_lag1 = np.row_stack(y_lag1_stack)</span>

    <span class="s0"># p. 286:</span>
    <span class="s1">delta_x = np.zeros((diff_lags * K</span><span class="s2">, </span><span class="s1">T))</span>
    <span class="s2">if </span><span class="s1">diff_lags &gt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(delta_x.shape[</span><span class="s4">1</span><span class="s1">]):</span>
            <span class="s1">delta_x[:</span><span class="s2">, </span><span class="s1">j] = delta_y[</span>
                <span class="s1">:</span><span class="s2">, </span><span class="s1">j + p - </span><span class="s4">2 </span><span class="s1">: </span><span class="s2">None if </span><span class="s1">j - </span><span class="s4">1 </span><span class="s1">&lt; </span><span class="s4">0 </span><span class="s2">else </span><span class="s1">j - </span><span class="s4">1 </span><span class="s1">: -</span><span class="s4">1</span>
            <span class="s1">].T.reshape(K * (p - </span><span class="s4">1</span><span class="s1">))</span>
    <span class="s1">delta_x_stack = [delta_x]</span>
    <span class="s0"># p. 299, p. 303:</span>
    <span class="s2">if </span><span class="s3">&quot;co&quot; </span><span class="s2">in </span><span class="s1">deterministic:</span>
        <span class="s1">delta_x_stack.append(np.ones(T))</span>
    <span class="s2">if </span><span class="s1">seasons &gt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">delta_x_stack.append(</span>
            <span class="s1">seasonal_dummies(</span>
                <span class="s1">seasons</span><span class="s2">,</span>
                <span class="s1">delta_x.shape[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">first_period=first_season + diff_lags + </span><span class="s4">1</span><span class="s2">,</span>
                <span class="s1">centered=</span><span class="s2">True,</span>
            <span class="s1">).T</span>
        <span class="s1">)</span>
    <span class="s2">if </span><span class="s3">&quot;lo&quot; </span><span class="s2">in </span><span class="s1">deterministic:</span>
        <span class="s1">delta_x_stack.append(_linear_trend(T</span><span class="s2">, </span><span class="s1">p))</span>
    <span class="s2">if </span><span class="s1">exog </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">delta_x_stack.append(exog[-T:].T)</span>
    <span class="s1">delta_x = np.row_stack(delta_x_stack)</span>

    <span class="s2">return </span><span class="s1">y_1_T</span><span class="s2">, </span><span class="s1">delta_y_1_T</span><span class="s2">, </span><span class="s1">y_lag1</span><span class="s2">, </span><span class="s1">delta_x</span>


<span class="s2">def </span><span class="s1">_r_matrices(delta_y_1_T</span><span class="s2">, </span><span class="s1">y_lag1</span><span class="s2">, </span><span class="s1">delta_x):</span>
    <span class="s5">&quot;&quot;&quot;Returns two ndarrays needed for parameter estimation as well as the 
    calculation of standard errors. 
 
    Parameters 
    ---------- 
    delta_y_1_T : ndarray (neqs x nobs) 
        The first differences of endog. 
        `.. math:: (y_1, \\ldots, y_T) - (y_0, \\ldots, y_{T-1}) 
    y_lag1 : ndarray (neqs x nobs) 
        (dimensions assuming no deterministic terms are given) 
        Endog of the previous period (lag 1). 
        `.. math:: (y_0, \\ldots, y_{T-1}) 
    delta_x : ndarray (k_ar_diff*neqs x nobs) 
        (dimensions assuming no deterministic terms are given) 
        Lagged differenced endog, used as regressor for the short term 
        equation. 
 
    Returns 
    ------- 
    result : tuple 
        A tuple of two ndarrays. (See p. 292 in [1]_ for the definition of 
        R_0 and R_1.) 
 
    References 
    ---------- 
    .. [1] Lütkepohl, H. 2005. *New Introduction to Multiple Time Series Analysis*. Springer. 
    &quot;&quot;&quot;</span>

    <span class="s0"># todo: rewrite m such that a big (TxT) matrix is avoided</span>
    <span class="s1">nobs = y_lag1.shape[</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">m = np.identity(nobs) - (</span>
        <span class="s1">delta_x.T.dot(inv(delta_x.dot(delta_x.T))).dot(delta_x)</span>
    <span class="s1">)  </span><span class="s0"># p. 291</span>
    <span class="s1">r0 = delta_y_1_T.dot(m)  </span><span class="s0"># p. 292</span>
    <span class="s1">r1 = y_lag1.dot(m)</span>
    <span class="s2">return </span><span class="s1">r0</span><span class="s2">, </span><span class="s1">r1</span>


<span class="s2">def </span><span class="s1">_sij(delta_x</span><span class="s2">, </span><span class="s1">delta_y_1_T</span><span class="s2">, </span><span class="s1">y_lag1):</span>
    <span class="s5">&quot;&quot;&quot;Returns matrices and eigenvalues and -vectors used for parameter 
    estimation and the calculation of a models loglikelihood. 
 
    Parameters 
    ---------- 
    delta_x : ndarray (k_ar_diff*neqs x nobs) 
        (dimensions assuming no deterministic terms are given) 
    delta_y_1_T : ndarray (neqs x nobs) 
        :math:`(y_1, \\ldots, y_T) - (y_0, \\ldots, y_{T-1})` 
    y_lag1 : ndarray (neqs x nobs) 
        (dimensions assuming no deterministic terms are given) 
        :math:`(y_0, \\ldots, y_{T-1})` 
 
    Returns 
    ------- 
    result : tuple 
        A tuple of five ndarrays as well as eigenvalues and -vectors of a 
        certain (matrix) product of some of the returned ndarrays. 
        (See pp. 294-295 in [1]_ for more information on 
        :math:`S_0, S_1, \\lambda_i, \\v_i` for 
        :math:`i \\in \\{1, \\dots, K\\}`.) 
 
    References 
    ---------- 
    .. [1] Lütkepohl, H. 2005. *New Introduction to Multiple Time Series Analysis*. Springer. 
    &quot;&quot;&quot;</span>
    <span class="s1">nobs = y_lag1.shape[</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">r0</span><span class="s2">, </span><span class="s1">r1 = _r_matrices(delta_y_1_T</span><span class="s2">, </span><span class="s1">y_lag1</span><span class="s2">, </span><span class="s1">delta_x)</span>
    <span class="s1">s00 = np.dot(r0</span><span class="s2">, </span><span class="s1">r0.T) / nobs</span>
    <span class="s1">s01 = np.dot(r0</span><span class="s2">, </span><span class="s1">r1.T) / nobs</span>
    <span class="s1">s10 = s01.T</span>
    <span class="s1">s11 = np.dot(r1</span><span class="s2">, </span><span class="s1">r1.T) / nobs</span>
    <span class="s1">s11_ = inv(_mat_sqrt(s11))</span>
    <span class="s0"># p. 295:</span>
    <span class="s1">s01_s11_ = np.dot(s01</span><span class="s2">, </span><span class="s1">s11_)</span>
    <span class="s1">eig = np.linalg.eig(s01_s11_.T @ inv(s00) @ s01_s11_)</span>
    <span class="s1">lambd = eig[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">v = eig[</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s0"># reorder eig_vals to make them decreasing (and order eig_vecs accordingly)</span>
    <span class="s1">lambd_order = np.argsort(lambd)[::-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">lambd = lambd[lambd_order]</span>
    <span class="s1">v = v[:</span><span class="s2">, </span><span class="s1">lambd_order]</span>
    <span class="s2">return </span><span class="s1">s00</span><span class="s2">, </span><span class="s1">s01</span><span class="s2">, </span><span class="s1">s10</span><span class="s2">, </span><span class="s1">s11</span><span class="s2">, </span><span class="s1">s11_</span><span class="s2">, </span><span class="s1">lambd</span><span class="s2">, </span><span class="s1">v</span>


<span class="s2">class </span><span class="s1">CointRankResults:</span>
    <span class="s5">&quot;&quot;&quot;A class for holding the results from testing the cointegration rank. 
 
    Parameters 
    ---------- 
    rank : int (0 &lt;= `rank` &lt;= `neqs`) 
        The rank to choose according to the Johansen cointegration rank 
        test. 
    neqs : int 
        Number of variables in the time series. 
    test_stats : array_like (`rank` + 1 if `rank` &lt; `neqs` else `rank`) 
        A one-dimensional array-like object containing the test statistics of 
        the conducted tests. 
    crit_vals : array_like (`rank` +1 if `rank` &lt; `neqs` else `rank`) 
        A one-dimensional array-like object containing the critical values 
        corresponding to the entries in the `test_stats` argument. 
    method : str, {``&quot;trace&quot;``, ``&quot;maxeig&quot;``}, default: ``&quot;trace&quot;`` 
        If ``&quot;trace&quot;``, the trace test statistic is used. If ``&quot;maxeig&quot;``, the 
        maximum eigenvalue test statistic is used. 
    signif : float, {0.1, 0.05, 0.01}, default: 0.05 
        The test's significance level. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">rank</span><span class="s2">, </span><span class="s1">neqs</span><span class="s2">, </span><span class="s1">test_stats</span><span class="s2">, </span><span class="s1">crit_vals</span><span class="s2">, </span><span class="s1">method=</span><span class="s3">&quot;trace&quot;</span><span class="s2">, </span><span class="s1">signif=</span><span class="s4">0.05</span>
    <span class="s1">):</span>
        <span class="s1">self.rank = rank</span>
        <span class="s1">self.neqs = neqs</span>
        <span class="s1">self.r_1 = [</span>
            <span class="s1">neqs </span><span class="s2">if </span><span class="s1">method == </span><span class="s3">&quot;trace&quot; </span><span class="s2">else </span><span class="s1">i + </span><span class="s4">1</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(min(rank + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">neqs))</span>
        <span class="s1">]</span>
        <span class="s1">self.test_stats = test_stats</span>
        <span class="s1">self.crit_vals = crit_vals</span>
        <span class="s1">self.method = method</span>
        <span class="s1">self.signif = signif</span>

    <span class="s2">def </span><span class="s1">summary(self):</span>
        <span class="s1">headers = [</span><span class="s3">&quot;r_0&quot;</span><span class="s2">, </span><span class="s3">&quot;r_1&quot;</span><span class="s2">, </span><span class="s3">&quot;test statistic&quot;</span><span class="s2">, </span><span class="s3">&quot;critical value&quot;</span><span class="s1">]</span>
        <span class="s1">title = (</span>
            <span class="s3">&quot;Johansen cointegration test using &quot;</span>
            <span class="s1">+ (</span><span class="s3">&quot;trace&quot; </span><span class="s2">if </span><span class="s1">self.method == </span><span class="s3">&quot;trace&quot; </span><span class="s2">else </span><span class="s3">&quot;maximum eigenvalue&quot;</span><span class="s1">)</span>
            <span class="s1">+ </span><span class="s3">&quot; test statistic with {:.0%}&quot;</span><span class="s1">.format(self.signif)</span>
            <span class="s1">+ </span><span class="s3">&quot; significance level&quot;</span>
        <span class="s1">)</span>
        <span class="s1">num_tests = min(self.rank</span><span class="s2">, </span><span class="s1">self.neqs - </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">data = [</span>
            <span class="s1">[i</span><span class="s2">, </span><span class="s1">self.r_1[i]</span><span class="s2">, </span><span class="s1">self.test_stats[i]</span><span class="s2">, </span><span class="s1">self.crit_vals[i]]</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(num_tests + </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">]</span>
        <span class="s1">data_fmt = {</span>
            <span class="s3">&quot;data_fmts&quot;</span><span class="s1">: [</span><span class="s3">&quot;%s&quot;</span><span class="s2">, </span><span class="s3">&quot;%s&quot;</span><span class="s2">, </span><span class="s3">&quot;%#0.4g&quot;</span><span class="s2">, </span><span class="s3">&quot;%#0.4g&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s3">&quot;data_aligns&quot;</span><span class="s1">: </span><span class="s3">&quot;r&quot;</span><span class="s2">,</span>
        <span class="s1">}</span>
        <span class="s1">html_data_fmt = dict(data_fmt)</span>
        <span class="s1">html_data_fmt[</span><span class="s3">&quot;data_fmts&quot;</span><span class="s1">] = [</span>
            <span class="s3">&quot;&lt;td&gt;&quot; </span><span class="s1">+ i + </span><span class="s3">&quot;&lt;/td&gt;&quot; </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">html_data_fmt[</span><span class="s3">&quot;data_fmts&quot;</span><span class="s1">]</span>
        <span class="s1">]</span>
        <span class="s2">return </span><span class="s1">SimpleTable(</span>
            <span class="s1">data=data</span><span class="s2">,</span>
            <span class="s1">headers=headers</span><span class="s2">,</span>
            <span class="s1">title=title</span><span class="s2">,</span>
            <span class="s1">txt_fmt=data_fmt</span><span class="s2">,</span>
            <span class="s1">html_fmt=html_data_fmt</span><span class="s2">,</span>
            <span class="s1">ltx_fmt=data_fmt</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s1">self.summary().as_text()</span>


<span class="s2">def </span><span class="s1">select_coint_rank(</span>
    <span class="s1">endog</span><span class="s2">, </span><span class="s1">det_order</span><span class="s2">, </span><span class="s1">k_ar_diff</span><span class="s2">, </span><span class="s1">method=</span><span class="s3">&quot;trace&quot;</span><span class="s2">, </span><span class="s1">signif=</span><span class="s4">0.05</span>
<span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot;Calculate the cointegration rank of a VECM. 
 
    Parameters 
    ---------- 
    endog : array_like (nobs_tot x neqs) 
        The data with presample. 
    det_order : int 
        * -1 - no deterministic terms 
        * 0 - constant term 
        * 1 - linear trend 
    k_ar_diff : int, nonnegative 
        Number of lagged differences in the model. 
    method : str, {``&quot;trace&quot;``, ``&quot;maxeig&quot;``}, default: ``&quot;trace&quot;`` 
        If ``&quot;trace&quot;``, the trace test statistic is used. If ``&quot;maxeig&quot;``, the 
        maximum eigenvalue test statistic is used. 
    signif : float, {0.1, 0.05, 0.01}, default: 0.05 
        The test's significance level. 
 
    Returns 
    ------- 
    rank : :class:`CointRankResults` 
        A :class:`CointRankResults` object containing the cointegration rank suggested 
        by the test and allowing a summary to be printed. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">method </span><span class="s2">not in </span><span class="s1">[</span><span class="s3">&quot;trace&quot;</span><span class="s2">, </span><span class="s3">&quot;maxeig&quot;</span><span class="s1">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s3">&quot;The method argument has to be either 'trace' or&quot;</span>
            <span class="s3">&quot;'maximum eigenvalue'.&quot;</span>
        <span class="s1">)</span>

    <span class="s2">if </span><span class="s1">det_order </span><span class="s2">not in </span><span class="s1">[-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]:</span>
        <span class="s2">if </span><span class="s1">type(det_order) == int </span><span class="s2">and </span><span class="s1">det_order &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;A det_order greather than 1 is not supported.&quot;</span>
                <span class="s3">&quot;Use a value of -1, 0, or 1.&quot;</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;det_order must be -1, 0, or 1.&quot;</span><span class="s1">)</span>

    <span class="s1">possible_signif_values = [</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.05</span><span class="s2">, </span><span class="s4">0.01</span><span class="s1">]</span>
    <span class="s2">if </span><span class="s1">signif </span><span class="s2">not in </span><span class="s1">possible_signif_values:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s3">&quot;Please choose a significance level from {0.1, 0.05,&quot; &quot;0.01}&quot;</span>
        <span class="s1">)</span>

    <span class="s1">coint_result = coint_johansen(endog</span><span class="s2">, </span><span class="s1">det_order</span><span class="s2">, </span><span class="s1">k_ar_diff)</span>
    <span class="s1">test_stat = coint_result.lr1 </span><span class="s2">if </span><span class="s1">method == </span><span class="s3">&quot;trace&quot; </span><span class="s2">else </span><span class="s1">coint_result.lr2</span>
    <span class="s1">crit_vals = coint_result.cvt </span><span class="s2">if </span><span class="s1">method == </span><span class="s3">&quot;trace&quot; </span><span class="s2">else </span><span class="s1">coint_result.cvm</span>
    <span class="s1">signif_index = possible_signif_values.index(signif)</span>

    <span class="s1">neqs = endog.shape[</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">r_0 = </span><span class="s4">0  </span><span class="s0"># rank in null hypothesis</span>
    <span class="s2">while </span><span class="s1">r_0 &lt; neqs:</span>
        <span class="s2">if </span><span class="s1">test_stat[r_0] &lt; crit_vals[r_0</span><span class="s2">, </span><span class="s1">signif_index]:</span>
            <span class="s2">break  </span><span class="s0"># we accept current rank</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">r_0 += </span><span class="s4">1  </span><span class="s0"># we reject current rank and test next possible rank</span>

    <span class="s2">return </span><span class="s1">CointRankResults(</span>
        <span class="s1">r_0</span><span class="s2">,</span>
        <span class="s1">neqs</span><span class="s2">,</span>
        <span class="s1">test_stat[: r_0 + </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">crit_vals[: r_0 + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">signif_index]</span><span class="s2">,</span>
        <span class="s1">method</span><span class="s2">,</span>
        <span class="s1">signif</span><span class="s2">,</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">coint_johansen(endog</span><span class="s2">, </span><span class="s1">det_order</span><span class="s2">, </span><span class="s1">k_ar_diff):</span>
    <span class="s5">&quot;&quot;&quot; 
    Johansen cointegration test of the cointegration rank of a VECM 
 
    Parameters 
    ---------- 
    endog : array_like (nobs_tot x neqs) 
        Data to test 
    det_order : int 
        * -1 - no deterministic terms 
        * 0 - constant term 
        * 1 - linear trend 
    k_ar_diff : int, nonnegative 
        Number of lagged differences in the model. 
 
    Returns 
    ------- 
    result : JohansenTestResult 
        An object containing the test's results. The most important attributes 
        of the result class are: 
 
        * trace_stat and trace_stat_crit_vals 
        * max_eig_stat and max_eig_stat_crit_vals 
 
    Notes 
    ----- 
    The implementation might change to make more use of the existing VECM 
    framework. 
 
    See Also 
    -------- 
    statsmodels.tsa.vector_ar.vecm.select_coint_rank 
 
    References 
    ---------- 
    .. [1] Lütkepohl, H. 2005. New Introduction to Multiple Time Series 
        Analysis. Springer. 
    &quot;&quot;&quot;</span>
    <span class="s2">import </span><span class="s1">warnings</span>

    <span class="s2">if </span><span class="s1">det_order </span><span class="s2">not in </span><span class="s1">[-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]:</span>
        <span class="s1">warnings.warn(</span>
            <span class="s3">&quot;Critical values are only available for a det_order of &quot;</span>
            <span class="s3">&quot;-1, 0, or 1.&quot;</span><span class="s2">,</span>
            <span class="s1">category=HypothesisTestWarning</span><span class="s2">,</span>
            <span class="s1">stacklevel=</span><span class="s4">2</span><span class="s2">,</span>
        <span class="s1">)</span>
    <span class="s2">if </span><span class="s1">endog.shape[</span><span class="s4">1</span><span class="s1">] &gt; </span><span class="s4">12</span><span class="s1">:  </span><span class="s0"># todo: test with a time series of 13 variables</span>
        <span class="s1">warnings.warn(</span>
            <span class="s3">&quot;Critical values are only available for time series &quot;</span>
            <span class="s3">&quot;with 12 variables at most.&quot;</span><span class="s2">,</span>
            <span class="s1">category=HypothesisTestWarning</span><span class="s2">,</span>
            <span class="s1">stacklevel=</span><span class="s4">2</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">from </span><span class="s1">statsmodels.regression.linear_model </span><span class="s2">import </span><span class="s1">OLS</span>

    <span class="s2">def </span><span class="s1">detrend(y</span><span class="s2">, </span><span class="s1">order):</span>
        <span class="s2">if </span><span class="s1">order == -</span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">y</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">OLS(y</span><span class="s2">, </span><span class="s1">np.vander(np.linspace(-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">len(y))</span><span class="s2">, </span><span class="s1">order + </span><span class="s4">1</span><span class="s1">))</span>
            <span class="s1">.fit()</span>
            <span class="s1">.resid</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">resid(y</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">if </span><span class="s1">x.size == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">y</span>
        <span class="s1">r = y - np.dot(x</span><span class="s2">, </span><span class="s1">np.dot(np.linalg.pinv(x)</span><span class="s2">, </span><span class="s1">y))</span>
        <span class="s2">return </span><span class="s1">r</span>

    <span class="s1">endog = np.asarray(endog)</span>
    <span class="s1">nobs</span><span class="s2">, </span><span class="s1">neqs = endog.shape</span>

    <span class="s0"># why this?  f is detrend transformed series, det_order is detrend data</span>
    <span class="s2">if </span><span class="s1">det_order &gt; -</span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">f = </span><span class="s4">0</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">f = det_order</span>

    <span class="s1">endog = detrend(endog</span><span class="s2">, </span><span class="s1">det_order)</span>
    <span class="s1">dx = np.diff(endog</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">z = lagmat(dx</span><span class="s2">, </span><span class="s1">k_ar_diff)</span>
    <span class="s1">z = z[k_ar_diff:]</span>
    <span class="s1">z = detrend(z</span><span class="s2">, </span><span class="s1">f)</span>

    <span class="s1">dx = dx[k_ar_diff:]</span>

    <span class="s1">dx = detrend(dx</span><span class="s2">, </span><span class="s1">f)</span>
    <span class="s1">r0t = resid(dx</span><span class="s2">, </span><span class="s1">z)</span>
    <span class="s0"># GH 5731, [:-0] does not work, need [:t-0]</span>
    <span class="s1">lx = endog[: (endog.shape[</span><span class="s4">0</span><span class="s1">] - k_ar_diff)]</span>
    <span class="s1">lx = lx[</span><span class="s4">1</span><span class="s1">:]</span>
    <span class="s1">dx = detrend(lx</span><span class="s2">, </span><span class="s1">f)</span>
    <span class="s1">rkt = resid(dx</span><span class="s2">, </span><span class="s1">z)  </span><span class="s0"># level on lagged diffs</span>
    <span class="s0"># Level covariance after filtering k_ar_diff</span>
    <span class="s1">skk = np.dot(rkt.T</span><span class="s2">, </span><span class="s1">rkt) / rkt.shape[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s0"># Covariacne between filtered and unfiltered</span>
    <span class="s1">sk0 = np.dot(rkt.T</span><span class="s2">, </span><span class="s1">r0t) / rkt.shape[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">s00 = np.dot(r0t.T</span><span class="s2">, </span><span class="s1">r0t) / r0t.shape[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">sig = np.dot(sk0</span><span class="s2">, </span><span class="s1">np.dot(inv(s00)</span><span class="s2">, </span><span class="s1">sk0.T))</span>
    <span class="s1">tmp = inv(skk)</span>
    <span class="s1">au</span><span class="s2">, </span><span class="s1">du = np.linalg.eig(np.dot(tmp</span><span class="s2">, </span><span class="s1">sig))  </span><span class="s0"># au is eval, du is evec</span>

    <span class="s1">temp = inv(np.linalg.cholesky(np.dot(du.T</span><span class="s2">, </span><span class="s1">np.dot(skk</span><span class="s2">, </span><span class="s1">du))))</span>
    <span class="s1">dt = np.dot(du</span><span class="s2">, </span><span class="s1">temp)</span>

    <span class="s0"># JP: the next part can be done much  easier</span>
    <span class="s1">auind = np.argsort(au)</span>
    <span class="s1">aind = np.flipud(auind)</span>
    <span class="s1">a = au[aind]</span>
    <span class="s1">d = dt[:</span><span class="s2">, </span><span class="s1">aind]</span>
    <span class="s0"># Normalize by first non-zero element of d, usually [0, 0]</span>
    <span class="s0"># GH 5517</span>
    <span class="s1">non_zero_d = d.flat != </span><span class="s4">0</span>
    <span class="s2">if </span><span class="s1">np.any(non_zero_d):</span>
        <span class="s1">d *= np.sign(d.flat[non_zero_d][</span><span class="s4">0</span><span class="s1">])</span>

    <span class="s0">#  Compute the trace and max eigenvalue statistics</span>
    <span class="s1">lr1 = np.zeros(neqs)</span>
    <span class="s1">lr2 = np.zeros(neqs)</span>
    <span class="s1">cvm = np.zeros((neqs</span><span class="s2">, </span><span class="s4">3</span><span class="s1">))</span>
    <span class="s1">cvt = np.zeros((neqs</span><span class="s2">, </span><span class="s4">3</span><span class="s1">))</span>
    <span class="s1">iota = np.ones(neqs)</span>
    <span class="s1">t</span><span class="s2">, </span><span class="s1">junk = rkt.shape</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">neqs):</span>
        <span class="s1">tmp = np.log(iota - a)[i:]</span>
        <span class="s1">lr1[i] = -t * np.sum(tmp</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">lr2[i] = -t * np.log(</span><span class="s4">1 </span><span class="s1">- a[i])</span>
        <span class="s1">cvm[i</span><span class="s2">, </span><span class="s1">:] = c_sja(neqs - i</span><span class="s2">, </span><span class="s1">det_order)</span>
        <span class="s1">cvt[i</span><span class="s2">, </span><span class="s1">:] = c_sjt(neqs - i</span><span class="s2">, </span><span class="s1">det_order)</span>
        <span class="s1">aind[i] = i</span>

    <span class="s2">return </span><span class="s1">JohansenTestResult(rkt</span><span class="s2">, </span><span class="s1">r0t</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">lr1</span><span class="s2">, </span><span class="s1">lr2</span><span class="s2">, </span><span class="s1">cvt</span><span class="s2">, </span><span class="s1">cvm</span><span class="s2">, </span><span class="s1">aind)</span>


<span class="s2">class </span><span class="s1">JohansenTestResult:</span>
    <span class="s5">&quot;&quot;&quot; 
    Results class for Johansen's cointegration test 
 
    Notes 
    ----- 
    See p. 292 in [1]_ for r0t and rkt 
 
    References 
    ---------- 
    .. [1] Lütkepohl, H. 2005. New Introduction to Multiple Time Series 
        Analysis. Springer. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">rkt</span><span class="s2">, </span><span class="s1">r0t</span><span class="s2">, </span><span class="s1">eig</span><span class="s2">, </span><span class="s1">evec</span><span class="s2">, </span><span class="s1">lr1</span><span class="s2">, </span><span class="s1">lr2</span><span class="s2">, </span><span class="s1">cvt</span><span class="s2">, </span><span class="s1">cvm</span><span class="s2">, </span><span class="s1">ind):</span>
        <span class="s1">self._meth = </span><span class="s3">&quot;johansen&quot;</span>
        <span class="s1">self._rkt = rkt</span>
        <span class="s1">self._r0t = r0t</span>
        <span class="s1">self._eig = eig</span>
        <span class="s1">self._evec = evec</span>
        <span class="s1">self._lr1 = lr1</span>
        <span class="s1">self._lr2 = lr2</span>
        <span class="s1">self._cvt = cvt</span>
        <span class="s1">self._cvm = cvm</span>
        <span class="s1">self._ind = ind</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">rkt(self):</span>
        <span class="s5">&quot;&quot;&quot;Residuals for :math:`Y_{-1}`&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._rkt</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">r0t(self):</span>
        <span class="s5">&quot;&quot;&quot;Residuals for :math:`\\Delta Y`.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._r0t</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">eig(self):</span>
        <span class="s5">&quot;&quot;&quot;Eigenvalues of VECM coefficient matrix&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._eig</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">evec(self):</span>
        <span class="s5">&quot;&quot;&quot;Eigenvectors of VECM coefficient matrix&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._evec</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">trace_stat(self):</span>
        <span class="s5">&quot;&quot;&quot;Trace statistic&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._lr1</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">lr1(self):</span>
        <span class="s5">&quot;&quot;&quot;Trace statistic&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._lr1</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">max_eig_stat(self):</span>
        <span class="s5">&quot;&quot;&quot;Maximum eigenvalue statistic&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._lr2</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">lr2(self):</span>
        <span class="s5">&quot;&quot;&quot;Maximum eigenvalue statistic&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._lr2</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">trace_stat_crit_vals(self):</span>
        <span class="s5">&quot;&quot;&quot;Critical values (90%, 95%, 99%) of trace statistic&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._cvt</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">cvt(self):</span>
        <span class="s5">&quot;&quot;&quot;Critical values (90%, 95%, 99%) of trace statistic&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._cvt</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">cvm(self):</span>
        <span class="s5">&quot;&quot;&quot;Critical values (90%, 95%, 99%) of maximum eigenvalue statistic.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._cvm</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">max_eig_stat_crit_vals(self):</span>
        <span class="s5">&quot;&quot;&quot;Critical values (90%, 95%, 99%) of maximum eigenvalue statistic.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._cvm</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">ind(self):</span>
        <span class="s5">&quot;&quot;&quot;Order of eigenvalues&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._ind</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">meth(self):</span>
        <span class="s5">&quot;&quot;&quot;Test method&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._meth</span>


<span class="s2">class </span><span class="s1">VECM(tsbase.TimeSeriesModel):</span>
    <span class="s5">&quot;&quot;&quot; 
    Class representing a Vector Error Correction Model (VECM). 
 
    A VECM(:math:`k_{ar}-1`) has the following form 
 
    .. math:: \\Delta y_t = \\Pi y_{t-1} + \\Gamma_1 \\Delta y_{t-1} + \\ldots + \\Gamma_{k_{ar}-1} \\Delta y_{t-k_{ar}+1} + u_t 
 
    where 
 
    .. math:: \\Pi = \\alpha \\beta' 
 
    as described in chapter 7 of [1]_. 
 
    Parameters 
    ---------- 
    endog : array_like (nobs_tot x neqs) 
        2-d endogenous response variable. 
    exog : ndarray (nobs_tot x neqs) or None 
        Deterministic terms outside the cointegration relation. 
    exog_coint : ndarray (nobs_tot x neqs) or None 
        Deterministic terms inside the cointegration relation. 
    dates : array_like of datetime, optional 
        See :class:`statsmodels.tsa.base.tsa_model.TimeSeriesModel` for more 
        information. 
    freq : str, optional 
        See :class:`statsmodels.tsa.base.tsa_model.TimeSeriesModel` for more 
        information. 
    missing : str, optional 
        See :class:`statsmodels.base.model.Model` for more information. 
    k_ar_diff : int 
        Number of lagged differences in the model. Equals :math:`k_{ar} - 1` in 
        the formula above. 
    coint_rank : int 
        Cointegration rank, equals the rank of the matrix :math:`\\Pi` and the 
        number of columns of :math:`\\alpha` and :math:`\\beta`. 
    deterministic : str {``&quot;n&quot;``, ``&quot;co&quot;``, ``&quot;ci&quot;``, ``&quot;lo&quot;``, ``&quot;li&quot;``} 
        * ``&quot;n&quot;`` - no deterministic terms 
        * ``&quot;co&quot;`` - constant outside the cointegration relation 
        * ``&quot;ci&quot;`` - constant within the cointegration relation 
        * ``&quot;lo&quot;`` - linear trend outside the cointegration relation 
        * ``&quot;li&quot;`` - linear trend within the cointegration relation 
 
        Combinations of these are possible (e.g. ``&quot;cili&quot;`` or ``&quot;colo&quot;`` for 
        linear trend with intercept). When using a constant term you have to 
        choose whether you want to restrict it to the cointegration relation 
        (i.e. ``&quot;ci&quot;``) or leave it unrestricted (i.e. ``&quot;co&quot;``). Do not use 
        both ``&quot;ci&quot;`` and ``&quot;co&quot;``. The same applies for ``&quot;li&quot;`` and ``&quot;lo&quot;`` 
        when using a linear term. See the Notes-section for more information. 
    seasons : int, default: 0 
        Number of periods in a seasonal cycle. 0 means no seasons. 
    first_season : int, default: 0 
        Season of the first observation. 
 
    Notes 
    ----- 
    A VECM(:math:`k_{ar} - 1`) with deterministic terms has the form 
 
    .. math:: 
 
       \\Delta y_t = \\alpha \\begin{pmatrix}\\beta' &amp; \\eta'\\end{pmatrix} \\begin{pmatrix}y_{t-1}\\\\D^{co}_{t-1}\\end{pmatrix} + \\Gamma_1 \\Delta y_{t-1} + \\dots + \\Gamma_{k_{ar}-1} \\Delta y_{t-k_{ar}+1} + C D_t + u_t. 
 
    In :math:`D^{co}_{t-1}` we have the deterministic terms which are inside 
    the cointegration relation (or restricted to the cointegration relation). 
    :math:`\\eta` is the corresponding estimator. To pass a deterministic term 
    inside the cointegration relation, we can use the `exog_coint` argument. 
    For the two special cases of an intercept and a linear trend there exists 
    a simpler way to declare these terms: we can pass ``&quot;ci&quot;`` and ``&quot;li&quot;`` 
    respectively to the `deterministic` argument. So for an intercept inside 
    the cointegration relation we can either pass ``&quot;ci&quot;`` as `deterministic` 
    or `np.ones(len(data))` as `exog_coint` if `data` is passed as the 
    `endog` argument. This ensures that :math:`D_{t-1}^{co} = 1` for all 
    :math:`t`. 
 
    We can also use deterministic terms outside the cointegration relation. 
    These are defined in :math:`D_t` in the formula above with the 
    corresponding estimators in the matrix :math:`C`. We specify such terms by 
    passing them to the `exog` argument. For an intercept and/or linear trend 
    we again have the possibility to use `deterministic` alternatively. For 
    an intercept we pass ``&quot;co&quot;`` and for a linear trend we pass ``&quot;lo&quot;`` where 
    the `o` stands for `outside`. 
 
    The following table shows the five cases considered in [2]_. The last 
    column indicates which string to pass to the `deterministic` argument for 
    each of these cases. 
 
    ====  ===============================  ===================================  ============= 
    Case  Intercept                        Slope of the linear trend            `deterministic` 
    ====  ===============================  ===================================  ============= 
    I     0                                0                                    ``&quot;n&quot;`` 
    II    :math:`- \\alpha \\beta^T \\mu`     0                                    ``&quot;ci&quot;`` 
    III   :math:`\\neq 0`                   0                                    ``&quot;co&quot;`` 
    IV    :math:`\\neq 0`                   :math:`- \\alpha \\beta^T \\gamma`      ``&quot;coli&quot;`` 
    V     :math:`\\neq 0`                   :math:`\\neq 0`                       ``&quot;colo&quot;`` 
    ====  ===============================  ===================================  ============= 
 
    References 
    ---------- 
    .. [1] Lütkepohl, H. 2005. *New Introduction to Multiple Time Series Analysis*. Springer. 
 
    .. [2] Johansen, S. 1995. *Likelihood-Based Inference in Cointegrated * 
           *Vector Autoregressive Models*. Oxford University Press. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">endog</span><span class="s2">,</span>
        <span class="s1">exog=</span><span class="s2">None,</span>
        <span class="s1">exog_coint=</span><span class="s2">None,</span>
        <span class="s1">dates=</span><span class="s2">None,</span>
        <span class="s1">freq=</span><span class="s2">None,</span>
        <span class="s1">missing=</span><span class="s3">&quot;none&quot;</span><span class="s2">,</span>
        <span class="s1">k_ar_diff=</span><span class="s4">1</span><span class="s2">,</span>
        <span class="s1">coint_rank=</span><span class="s4">1</span><span class="s2">,</span>
        <span class="s1">deterministic=</span><span class="s3">&quot;n&quot;</span><span class="s2">,</span>
        <span class="s1">seasons=</span><span class="s4">0</span><span class="s2">,</span>
        <span class="s1">first_season=</span><span class="s4">0</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">dates</span><span class="s2">, </span><span class="s1">freq</span><span class="s2">, </span><span class="s1">missing=missing)</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">exog_coint </span><span class="s2">is not None</span>
            <span class="s2">and not </span><span class="s1">exog_coint.shape[</span><span class="s4">0</span><span class="s1">] == endog.shape[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;exog_coint must have as many rows as enodg_tot!&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.endog.ndim == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Only gave one variable to VECM&quot;</span><span class="s1">)</span>
        <span class="s1">self.y = self.endog.T</span>
        <span class="s1">self.exog_coint = exog_coint</span>
        <span class="s1">self.neqs = self.endog.shape[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">self.k_ar = k_ar_diff + </span><span class="s4">1</span>
        <span class="s1">self.k_ar_diff = k_ar_diff</span>
        <span class="s1">self.coint_rank = coint_rank</span>
        <span class="s1">self.deterministic = deterministic</span>
        <span class="s1">self.seasons = seasons</span>
        <span class="s1">self.first_season = first_season</span>
        <span class="s1">self.load_coef_repr = </span><span class="s3">&quot;ec&quot;  </span><span class="s0"># name for loading coef. (alpha) in summary</span>

    <span class="s2">def </span><span class="s1">fit(self</span><span class="s2">, </span><span class="s1">method=</span><span class="s3">&quot;ml&quot;</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Estimates the parameters of a VECM. 
 
        The estimation procedure is described on pp. 269-304 in [1]_. 
 
        Parameters 
        ---------- 
        method : str {&quot;ml&quot;}, default: &quot;ml&quot; 
            Estimation method to use. &quot;ml&quot; stands for Maximum Likelihood. 
 
        Returns 
        ------- 
        est : :class:`VECMResults` 
 
        References 
        ---------- 
        .. [1] Lütkepohl, H. 2005. *New Introduction to Multiple Time Series Analysis*. Springer. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">method == </span><span class="s3">&quot;ml&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._estimate_vecm_ml()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;%s not recognized, must be among %s&quot; </span><span class="s1">% (method</span><span class="s2">, </span><span class="s3">&quot;ml&quot;</span><span class="s1">)</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_estimate_vecm_ml(self):</span>
        <span class="s1">y_1_T</span><span class="s2">, </span><span class="s1">delta_y_1_T</span><span class="s2">, </span><span class="s1">y_lag1</span><span class="s2">, </span><span class="s1">delta_x = _endog_matrices(</span>
            <span class="s1">self.y</span><span class="s2">,</span>
            <span class="s1">self.exog</span><span class="s2">,</span>
            <span class="s1">self.exog_coint</span><span class="s2">,</span>
            <span class="s1">self.k_ar_diff</span><span class="s2">,</span>
            <span class="s1">self.deterministic</span><span class="s2">,</span>
            <span class="s1">self.seasons</span><span class="s2">,</span>
            <span class="s1">self.first_season</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">T = y_1_T.shape[</span><span class="s4">1</span><span class="s1">]</span>

        <span class="s1">s00</span><span class="s2">, </span><span class="s1">s01</span><span class="s2">, </span><span class="s1">s10</span><span class="s2">, </span><span class="s1">s11</span><span class="s2">, </span><span class="s1">s11_</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">v = _sij(delta_x</span><span class="s2">, </span><span class="s1">delta_y_1_T</span><span class="s2">, </span><span class="s1">y_lag1)</span>

        <span class="s1">beta_tilde = (v[:</span><span class="s2">, </span><span class="s1">: self.coint_rank].T.dot(s11_)).T</span>
        <span class="s1">beta_tilde = np.real_if_close(beta_tilde)</span>
        <span class="s0"># normalize beta tilde such that eye(r) forms the first r rows of it:</span>
        <span class="s1">beta_tilde = np.dot(beta_tilde</span><span class="s2">, </span><span class="s1">inv(beta_tilde[: self.coint_rank]))</span>
        <span class="s1">alpha_tilde = s01.dot(beta_tilde).dot(</span>
            <span class="s1">inv(beta_tilde.T.dot(s11).dot(beta_tilde))</span>
        <span class="s1">)</span>
        <span class="s1">gamma_tilde = (</span>
            <span class="s1">(delta_y_1_T - alpha_tilde.dot(beta_tilde.T).dot(y_lag1))</span>
            <span class="s1">.dot(delta_x.T)</span>
            <span class="s1">.dot(inv(np.dot(delta_x</span><span class="s2">, </span><span class="s1">delta_x.T)))</span>
        <span class="s1">)</span>
        <span class="s1">temp = (</span>
            <span class="s1">delta_y_1_T</span>
            <span class="s1">- alpha_tilde.dot(beta_tilde.T).dot(y_lag1)</span>
            <span class="s1">- gamma_tilde.dot(delta_x)</span>
        <span class="s1">)</span>
        <span class="s1">sigma_u_tilde = temp.dot(temp.T) / T</span>

        <span class="s2">return </span><span class="s1">VECMResults(</span>
            <span class="s1">self.y</span><span class="s2">,</span>
            <span class="s1">self.exog</span><span class="s2">,</span>
            <span class="s1">self.exog_coint</span><span class="s2">,</span>
            <span class="s1">self.k_ar</span><span class="s2">,</span>
            <span class="s1">self.coint_rank</span><span class="s2">,</span>
            <span class="s1">alpha_tilde</span><span class="s2">,</span>
            <span class="s1">beta_tilde</span><span class="s2">,</span>
            <span class="s1">gamma_tilde</span><span class="s2">,</span>
            <span class="s1">sigma_u_tilde</span><span class="s2">,</span>
            <span class="s1">deterministic=self.deterministic</span><span class="s2">,</span>
            <span class="s1">seasons=self.seasons</span><span class="s2">,</span>
            <span class="s1">delta_y_1_T=delta_y_1_T</span><span class="s2">,</span>
            <span class="s1">y_lag1=y_lag1</span><span class="s2">,</span>
            <span class="s1">delta_x=delta_x</span><span class="s2">,</span>
            <span class="s1">model=self</span><span class="s2">,</span>
            <span class="s1">names=self.endog_names</span><span class="s2">,</span>
            <span class="s1">dates=self.data.dates</span><span class="s2">,</span>
            <span class="s1">first_season=self.first_season</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_lagged_param_names(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns parameter names (for Gamma and deterministics) for the summary. 
 
        Returns 
        ------- 
        param_names : list of str 
            Returns a list of parameter names for the lagged endogenous 
            parameters which are called :math:`\\Gamma` in [1]_ 
            (see chapter 6). 
            If present in the model, also names for deterministic terms outside 
            the cointegration relation are returned. They name the elements of 
            the matrix C in [1]_ (p. 299). 
 
        References 
        ---------- 
        .. [1] Lütkepohl, H. 2005. *New Introduction to Multiple Time Series Analysis*. Springer. 
        &quot;&quot;&quot;</span>
        <span class="s1">param_names = []</span>

        <span class="s0"># 1. Deterministic terms outside cointegration relation</span>
        <span class="s2">if </span><span class="s3">&quot;co&quot; </span><span class="s2">in </span><span class="s1">self.deterministic:</span>
            <span class="s1">param_names += [</span><span class="s3">&quot;const.%s&quot; </span><span class="s1">% n </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">self.endog_names]</span>

        <span class="s2">if </span><span class="s1">self.seasons &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">param_names += [</span>
                <span class="s3">&quot;season%d.%s&quot; </span><span class="s1">% (s</span><span class="s2">, </span><span class="s1">n)</span>
                <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">self.seasons)</span>
                <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">self.endog_names</span>
            <span class="s1">]</span>

        <span class="s2">if </span><span class="s3">&quot;lo&quot; </span><span class="s2">in </span><span class="s1">self.deterministic:</span>
            <span class="s1">param_names += [</span><span class="s3">&quot;lin_trend.%s&quot; </span><span class="s1">% n </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">self.endog_names]</span>

        <span class="s2">if </span><span class="s1">self.exog </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">param_names += [</span>
                <span class="s3">&quot;exog%d.%s&quot; </span><span class="s1">% (exog_no</span><span class="s2">, </span><span class="s1">n)</span>
                <span class="s2">for </span><span class="s1">exog_no </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">self.exog.shape[</span><span class="s4">1</span><span class="s1">] + </span><span class="s4">1</span><span class="s1">)</span>
                <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">self.endog_names</span>
            <span class="s1">]</span>

        <span class="s0"># 2. lagged endogenous terms</span>
        <span class="s1">param_names += [</span>
            <span class="s3">&quot;L%d.%s.%s&quot; </span><span class="s1">% (i + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">n1</span><span class="s2">, </span><span class="s1">n2)</span>
            <span class="s2">for </span><span class="s1">n2 </span><span class="s2">in </span><span class="s1">self.endog_names</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.k_ar_diff)</span>
            <span class="s2">for </span><span class="s1">n1 </span><span class="s2">in </span><span class="s1">self.endog_names</span>
        <span class="s1">]</span>

        <span class="s2">return </span><span class="s1">param_names</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_load_coef_param_names(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns parameter names (for alpha) for the summary. 
 
        Returns 
        ------- 
        param_names : list of str 
            Returns a list of parameter names for the loading coefficients 
            which are called :math:`\\alpha` in [1]_ (see chapter 6). 
 
        References 
        ---------- 
        .. [1] Lütkepohl, H. 2005. *New Introduction to Multiple Time Series Analysis*. Springer. 
        &quot;&quot;&quot;</span>
        <span class="s1">param_names = []</span>

        <span class="s2">if </span><span class="s1">self.coint_rank == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return None</span>

        <span class="s0"># loading coefficients (alpha) # called &quot;ec&quot; in JMulTi, &quot;ECT&quot; in tsDyn,</span>
        <span class="s1">param_names += [  </span><span class="s0"># and &quot;_ce&quot; in Stata</span>
            <span class="s1">self.load_coef_repr + </span><span class="s3">&quot;%d.%s&quot; </span><span class="s1">% (i + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">self.endog_names[j])</span>
            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(self.neqs)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.coint_rank)</span>
        <span class="s1">]</span>

        <span class="s2">return </span><span class="s1">param_names</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_coint_param_names(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns parameter names (for beta and deterministics) for the summary. 
 
        Returns 
        ------- 
        param_names : list of str 
            Returns a list of parameter names for the cointegration matrix 
            as well as deterministic terms inside the cointegration relation 
            (if present in the model). 
        &quot;&quot;&quot;</span>
        <span class="s0"># 1. cointegration matrix/vector</span>
        <span class="s1">param_names = []</span>

        <span class="s1">param_names += [</span>
            <span class="s1">(</span><span class="s3">&quot;beta.%d.&quot; </span><span class="s1">+ self.load_coef_repr + </span><span class="s3">&quot;%d&quot;</span><span class="s1">) % (j + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">i + </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.coint_rank)</span>
            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(self.neqs)</span>
        <span class="s1">]</span>

        <span class="s0"># 2. deterministic terms inside cointegration relation</span>
        <span class="s2">if </span><span class="s3">&quot;ci&quot; </span><span class="s2">in </span><span class="s1">self.deterministic:</span>
            <span class="s1">param_names += [</span>
                <span class="s3">&quot;const.&quot; </span><span class="s1">+ self.load_coef_repr + </span><span class="s3">&quot;%d&quot; </span><span class="s1">% (i + </span><span class="s4">1</span><span class="s1">)</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.coint_rank)</span>
            <span class="s1">]</span>

        <span class="s2">if </span><span class="s3">&quot;li&quot; </span><span class="s2">in </span><span class="s1">self.deterministic:</span>
            <span class="s1">param_names += [</span>
                <span class="s3">&quot;lin_trend.&quot; </span><span class="s1">+ self.load_coef_repr + </span><span class="s3">&quot;%d&quot; </span><span class="s1">% (i + </span><span class="s4">1</span><span class="s1">)</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.coint_rank)</span>
            <span class="s1">]</span>

        <span class="s2">if </span><span class="s1">self.exog_coint </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">param_names += [</span>
                <span class="s3">&quot;exog_coint%d.%s&quot; </span><span class="s1">% (n + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">exog_no)</span>
                <span class="s2">for </span><span class="s1">exog_no </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">self.exog_coint.shape[</span><span class="s4">1</span><span class="s1">] + </span><span class="s4">1</span><span class="s1">)</span>
                <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(self.neqs)</span>
            <span class="s1">]</span>

        <span class="s2">return </span><span class="s1">param_names</span>


<span class="s2">class </span><span class="s1">VECMResults:</span>
    <span class="s5">&quot;&quot;&quot;Class for holding estimation related results of a vector error 
    correction model (VECM). 
 
    Parameters 
    ---------- 
    endog : ndarray (neqs x nobs_tot) 
        Array of observations. 
    exog : ndarray (nobs_tot x neqs) or `None` 
        Deterministic terms outside the cointegration relation. 
    exog_coint : ndarray (nobs_tot x neqs) or `None` 
        Deterministic terms inside the cointegration relation. 
    k_ar : int, &gt;= 1 
        Lags in the VAR representation. This implies that the number of lags in 
        the VEC representation (=lagged differences) equals :math:`k_{ar} - 1`. 
    coint_rank : int, 0 &lt;= `coint_rank` &lt;= neqs 
        Cointegration rank, equals the rank of the matrix :math:`\\Pi` and the 
        number of columns of :math:`\\alpha` and :math:`\\beta`. 
    alpha : ndarray (neqs x `coint_rank`) 
        Estimate for the parameter :math:`\\alpha` of a VECM. 
    beta : ndarray (neqs x `coint_rank`) 
        Estimate for the parameter :math:`\\beta` of a VECM. 
    gamma : ndarray (neqs x neqs*(k_ar-1)) 
        Array containing the estimates of the :math:`k_{ar}-1` parameter 
        matrices :math:`\\Gamma_1, \\dots, \\Gamma_{k_{ar}-1}` of a 
        VECM(:math:`k_{ar}-1`). The submatrices are stacked horizontally from 
        left to right. 
    sigma_u : ndarray (neqs x neqs) 
        Estimate of white noise process covariance matrix :math:`\\Sigma_u`. 
    deterministic : str {``&quot;n&quot;``, ``&quot;co&quot;``, ``&quot;ci&quot;``, ``&quot;lo&quot;``, ``&quot;li&quot;``} 
        * ``&quot;n&quot;`` - no deterministic terms 
        * ``&quot;co&quot;`` - constant outside the cointegration relation 
        * ``&quot;ci&quot;`` - constant within the cointegration relation 
        * ``&quot;lo&quot;`` - linear trend outside the cointegration relation 
        * ``&quot;li&quot;`` - linear trend within the cointegration relation 
 
        Combinations of these are possible (e.g. ``&quot;cili&quot;`` or ``&quot;colo&quot;`` for 
        linear trend with intercept). See the docstring of the 
        :class:`VECM`-class for more information. 
    seasons : int, default: 0 
        Number of periods in a seasonal cycle. 0 means no seasons. 
    first_season : int, default: 0 
        Season of the first observation. 
    delta_y_1_T : ndarray or `None`, default: `None` 
        Auxiliary array for internal computations. It will be calculated if 
        not given as parameter. 
    y_lag1 : ndarray or `None`, default: `None` 
        Auxiliary array for internal computations. It will be calculated if 
        not given as parameter. 
    delta_x : ndarray or `None`, default: `None` 
        Auxiliary array for internal computations. It will be calculated if 
        not given as parameter. 
    model : :class:`VECM` 
        An instance of the :class:`VECM`-class. 
    names : list of str 
        Each str in the list represents the name of a variable of the time 
        series. 
    dates : array_like 
        For example a DatetimeIndex of length nobs_tot. 
 
    Attributes 
    ---------- 
    nobs : int 
        Number of observations (excluding the presample). 
    model : see Parameters 
    y_all : see `endog` in Parameters 
    exog : see Parameters 
    exog_coint : see Parameters 
    names : see Parameters 
    dates : see Parameters 
    neqs : int 
        Number of variables in the time series. 
    k_ar : see Parameters 
    deterministic : see Parameters 
    seasons : see Parameters 
    first_season : see Parameters 
    alpha : see Parameters 
    beta : see Parameters 
    gamma : see Parameters 
    sigma_u : see Parameters 
    det_coef_coint : ndarray (#(determinist. terms inside the coint. rel.) x `coint_rank`) 
        Estimated coefficients for the all deterministic terms inside the 
        cointegration relation. 
    const_coint : ndarray (1 x `coint_rank`) 
        If there is a constant deterministic term inside the cointegration 
        relation, then `const_coint` is the first row of `det_coef_coint`. 
        Otherwise it's an ndarray of zeros. 
    lin_trend_coint : ndarray (1 x `coint_rank`) 
        If there is a linear deterministic term inside the cointegration 
        relation, then `lin_trend_coint` contains the corresponding estimated 
        coefficients. As such it represents the corresponding row of 
        `det_coef_coint`. If there is no linear deterministic term inside 
        the cointegration relation, then `lin_trend_coint` is an ndarray of 
        zeros. 
    exog_coint_coefs : ndarray (exog_coint.shape[1] x `coint_rank`) or `None` 
        If deterministic terms inside the cointegration relation are passed via 
        the `exog_coint` parameter, then `exog_coint_coefs` contains the 
        corresponding estimated coefficients. As such `exog_coint_coefs` 
        represents the last rows of `det_coef_coint`. 
        If no deterministic terms were passed via the `exog_coint` parameter, 
        this attribute is `None`. 
    det_coef : ndarray (neqs x #(deterministic terms outside the coint. rel.)) 
        Estimated coefficients for the all deterministic terms outside the 
        cointegration relation. 
    const : ndarray (neqs x 1) or (neqs x 0) 
        If a constant deterministic term outside the cointegration is specified 
        within the deterministic parameter, then `const` is the first column 
        of `det_coef_coint`. Otherwise it's an ndarray of size zero. 
    seasonal : ndarray (neqs x seasons) 
        If the `seasons` parameter is &gt; 0, then seasonal contains the 
        estimated coefficients corresponding to the seasonal terms. Otherwise 
        it's an ndarray of size zero. 
    lin_trend : ndarray (neqs x 1) or (neqs x 0) 
        If a linear deterministic term outside the cointegration is specified 
        within the deterministic parameter, then `lin_trend` contains the 
        corresponding estimated coefficients. As such it represents the 
        corresponding column of `det_coef_coint`. If there is no linear 
        deterministic term outside the cointegration relation, then 
        `lin_trend` is an ndarray of size zero. 
    exog_coefs : ndarray (neqs x exog_coefs.shape[1]) 
        If deterministic terms outside the cointegration relation are passed 
        via the `exog` parameter, then `exog_coefs` contains the 
        corresponding estimated coefficients. As such `exog_coefs` represents 
        the last columns of `det_coef`. 
        If no deterministic terms were passed via the `exog` parameter, this 
        attribute is an ndarray of size zero. 
    _delta_y_1_T : see delta_y_1_T in Parameters 
    _y_lag1 : see y_lag1 in Parameters 
    _delta_x : see delta_x in Parameters 
    coint_rank : int 
        Cointegration rank, equals the rank of the matrix :math:`\\Pi` and the 
        number of columns of :math:`\\alpha` and :math:`\\beta`. 
    llf : float 
        The model's log-likelihood. 
    cov_params : ndarray (d x d) 
        Covariance matrix of the parameters. The number of rows and columns, d 
        (used in the dimension specification of this argument), 
        is equal to neqs * (neqs+num_det_coef_coint + neqs*(k_ar-1)+number of 
        deterministic dummy variables outside the cointegration relation). For 
        the case with no deterministic terms this matrix is defined on p. 287 
        in [1]_ as :math:`\\Sigma_{co}` and its relationship to the 
        ML-estimators can be seen in eq. (7.2.21) on p. 296 in [1]_. 
    cov_params_wo_det : ndarray 
        Covariance matrix of the parameters 
        :math:`\\tilde{\\Pi}, \\tilde{\\Gamma}` where 
        :math:`\\tilde{\\Pi} = \\tilde{\\alpha} \\tilde{\\beta'}`. 
        Equals `cov_params` without the rows and columns related to 
        deterministic terms. This matrix is defined as :math:`\\Sigma_{co}` on 
        p. 287 in [1]_. 
    stderr_params : ndarray (d) 
        Array containing the standard errors of :math:`\\Pi`, :math:`\\Gamma`, 
        and estimated parameters related to deterministic terms. 
    stderr_coint : ndarray (neqs+num_det_coef_coint x `coint_rank`) 
        Array containing the standard errors of :math:`\\beta` and estimated 
        parameters related to deterministic terms inside the cointegration 
        relation. 
    stderr_alpha :  ndarray (neqs x `coint_rank`) 
        The standard errors of :math:`\\alpha`. 
    stderr_beta : ndarray (neqs x `coint_rank`) 
        The standard errors of :math:`\\beta`. 
    stderr_det_coef_coint : ndarray (num_det_coef_coint x `coint_rank`) 
        The standard errors of estimated the parameters related to 
        deterministic terms inside the cointegration relation. 
    stderr_gamma : ndarray (neqs x neqs*(k_ar-1)) 
        The standard errors of :math:`\\Gamma_1, \\ldots, \\Gamma_{k_{ar}-1}`. 
    stderr_det_coef : ndarray (neqs x det. terms outside the coint. relation) 
        The standard errors of estimated the parameters related to 
        deterministic terms outside the cointegration relation. 
    tvalues_alpha : ndarray (neqs x `coint_rank`) 
    tvalues_beta : ndarray (neqs x `coint_rank`) 
    tvalues_det_coef_coint : ndarray (num_det_coef_coint x `coint_rank`) 
    tvalues_gamma : ndarray (neqs x neqs*(k_ar-1)) 
    tvalues_det_coef : ndarray (neqs x det. terms outside the coint. relation) 
    pvalues_alpha : ndarray (neqs x `coint_rank`) 
    pvalues_beta : ndarray (neqs x `coint_rank`) 
    pvalues_det_coef_coint : ndarray (num_det_coef_coint x `coint_rank`) 
    pvalues_gamma : ndarray (neqs x neqs*(k_ar-1)) 
    pvalues_det_coef : ndarray (neqs x det. terms outside the coint. relation) 
    var_rep : (k_ar x neqs x neqs) 
        KxK parameter matrices :math:`A_i` of the corresponding VAR 
        representation. If the return value is assigned to a variable ``A``, 
        these matrices can be accessed via ``A[i]`` for 
        :math:`i=0, \\ldots, k_{ar}-1`. 
    cov_var_repr : ndarray (neqs**2 * k_ar x neqs**2 * k_ar) 
        This matrix is called :math:`\\Sigma^{co}_{\\alpha}` on p. 289 in [1]_. 
        It is needed e.g. for impulse-response-analysis. 
    fittedvalues : ndarray (nobs x neqs) 
        The predicted in-sample values of the models' endogenous variables. 
    resid : ndarray (nobs x neqs) 
        The residuals. 
 
    References 
    ---------- 
    .. [1] Lütkepohl, H. 2005. *New Introduction to Multiple Time Series Analysis*. Springer. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">endog</span><span class="s2">,</span>
        <span class="s1">exog</span><span class="s2">,</span>
        <span class="s1">exog_coint</span><span class="s2">,</span>
        <span class="s1">k_ar</span><span class="s2">,</span>
        <span class="s1">coint_rank</span><span class="s2">,</span>
        <span class="s1">alpha</span><span class="s2">,</span>
        <span class="s1">beta</span><span class="s2">,</span>
        <span class="s1">gamma</span><span class="s2">,</span>
        <span class="s1">sigma_u</span><span class="s2">,</span>
        <span class="s1">deterministic=</span><span class="s3">&quot;n&quot;</span><span class="s2">,</span>
        <span class="s1">seasons=</span><span class="s4">0</span><span class="s2">,</span>
        <span class="s1">first_season=</span><span class="s4">0</span><span class="s2">,</span>
        <span class="s1">delta_y_1_T=</span><span class="s2">None,</span>
        <span class="s1">y_lag1=</span><span class="s2">None,</span>
        <span class="s1">delta_x=</span><span class="s2">None,</span>
        <span class="s1">model=</span><span class="s2">None,</span>
        <span class="s1">names=</span><span class="s2">None,</span>
        <span class="s1">dates=</span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s1">self.model = model</span>
        <span class="s1">self.y_all = endog</span>
        <span class="s1">self.exog = exog</span>
        <span class="s1">self.exog_coint = exog_coint</span>
        <span class="s1">self.names = names</span>
        <span class="s1">self.dates = dates</span>
        <span class="s1">self.neqs = endog.shape[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">self.k_ar = k_ar</span>
        <span class="s1">deterministic = string_like(deterministic</span><span class="s2">, </span><span class="s3">&quot;deterministic&quot;</span><span class="s1">)</span>
        <span class="s1">self.deterministic = deterministic</span>
        <span class="s1">self.seasons = seasons</span>
        <span class="s1">self.first_season = first_season</span>

        <span class="s1">self.coint_rank = coint_rank</span>
        <span class="s2">if </span><span class="s1">alpha.dtype == np.complex128 </span><span class="s2">and </span><span class="s1">np.all(np.imag(alpha) == </span><span class="s4">0</span><span class="s1">):</span>
            <span class="s1">alpha = np.real_if_close(alpha)</span>
        <span class="s2">if </span><span class="s1">beta.dtype == np.complex128 </span><span class="s2">and </span><span class="s1">np.all(np.imag(beta) == </span><span class="s4">0</span><span class="s1">):</span>
            <span class="s1">beta = np.real_if_close(beta)</span>
        <span class="s2">if </span><span class="s1">gamma.dtype == np.complex128 </span><span class="s2">and </span><span class="s1">np.all(np.imag(gamma) == </span><span class="s4">0</span><span class="s1">):</span>
            <span class="s1">gamma = np.real_if_close(gamma)</span>

        <span class="s1">self.alpha = alpha</span>
        <span class="s1">self.beta</span><span class="s2">, </span><span class="s1">self.det_coef_coint = np.vsplit(beta</span><span class="s2">, </span><span class="s1">[self.neqs])</span>
        <span class="s1">self.gamma</span><span class="s2">, </span><span class="s1">self.det_coef = np.hsplit(</span>
            <span class="s1">gamma</span><span class="s2">, </span><span class="s1">[self.neqs * (self.k_ar - </span><span class="s4">1</span><span class="s1">)]</span>
        <span class="s1">)</span>

        <span class="s2">if </span><span class="s3">&quot;ci&quot; </span><span class="s2">in </span><span class="s1">deterministic:</span>
            <span class="s1">self.const_coint = self.det_coef_coint[:</span><span class="s4">1</span><span class="s2">, </span><span class="s1">:]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.const_coint = np.zeros(coint_rank).reshape((</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s3">&quot;li&quot; </span><span class="s2">in </span><span class="s1">deterministic:</span>
            <span class="s1">start = </span><span class="s4">1 </span><span class="s2">if </span><span class="s3">&quot;ci&quot; </span><span class="s2">in </span><span class="s1">deterministic </span><span class="s2">else </span><span class="s4">0</span>
            <span class="s1">self.lin_trend_coint = self.det_coef_coint[start : start + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">:]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.lin_trend_coint = np.zeros(coint_rank).reshape(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.exog_coint </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">start = (</span><span class="s3">&quot;ci&quot; </span><span class="s2">in </span><span class="s1">deterministic) + (</span><span class="s3">&quot;li&quot; </span><span class="s2">in </span><span class="s1">deterministic)</span>
            <span class="s1">self.exog_coint_coefs = self.det_coef_coint[start:</span><span class="s2">, </span><span class="s1">:]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.exog_coint_coefs = </span><span class="s2">None</span>

        <span class="s1">split_const_season = </span><span class="s4">1 </span><span class="s2">if </span><span class="s3">&quot;co&quot; </span><span class="s2">in </span><span class="s1">deterministic </span><span class="s2">else </span><span class="s4">0</span>
        <span class="s1">split_season_lin = split_const_season + (</span>
            <span class="s1">(seasons - </span><span class="s4">1</span><span class="s1">) </span><span class="s2">if </span><span class="s1">seasons </span><span class="s2">else </span><span class="s4">0</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s3">&quot;lo&quot; </span><span class="s2">in </span><span class="s1">deterministic:</span>
            <span class="s1">split_lin_exog = split_season_lin + </span><span class="s4">1</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">split_lin_exog = split_season_lin</span>
        <span class="s1">self.const</span><span class="s2">, </span><span class="s1">self.seasonal</span><span class="s2">, </span><span class="s1">self.lin_trend</span><span class="s2">, </span><span class="s1">self.exog_coefs = np.hsplit(</span>
            <span class="s1">self.det_coef</span><span class="s2">,</span>
            <span class="s1">[split_const_season</span><span class="s2">, </span><span class="s1">split_season_lin</span><span class="s2">, </span><span class="s1">split_lin_exog]</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s1">self.sigma_u = sigma_u</span>

        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">y_lag1 </span><span class="s2">is not None</span>
            <span class="s2">and </span><span class="s1">delta_x </span><span class="s2">is not None</span>
            <span class="s2">and </span><span class="s1">delta_y_1_T </span><span class="s2">is not None</span>
        <span class="s1">):</span>
            <span class="s1">self._delta_y_1_T = delta_y_1_T</span>
            <span class="s1">self._y_lag1 = y_lag1</span>
            <span class="s1">self._delta_x = delta_x</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">(</span>
                <span class="s1">_y_1_T</span><span class="s2">,</span>
                <span class="s1">self._delta_y_1_T</span><span class="s2">,</span>
                <span class="s1">self._y_lag1</span><span class="s2">,</span>
                <span class="s1">self._delta_x</span><span class="s2">,</span>
            <span class="s1">) = _endog_matrices(endog</span><span class="s2">, </span><span class="s1">self.exog</span><span class="s2">, </span><span class="s1">k_ar</span><span class="s2">, </span><span class="s1">deterministic</span><span class="s2">, </span><span class="s1">seasons)</span>
        <span class="s1">self.nobs = self._y_lag1.shape[</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">llf(self):  </span><span class="s0"># Lutkepohl p. 295 (7.2.20)</span>
        <span class="s5">&quot;&quot;&quot; 
        Compute the VECM's loglikelihood. 
        &quot;&quot;&quot;</span>
        <span class="s1">K = self.neqs</span>
        <span class="s1">T = self.nobs</span>
        <span class="s1">r = self.coint_rank</span>
        <span class="s1">s00</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">lambd</span><span class="s2">, </span><span class="s1">_ = _sij(</span>
            <span class="s1">self._delta_x</span><span class="s2">, </span><span class="s1">self._delta_y_1_T</span><span class="s2">, </span><span class="s1">self._y_lag1</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">-K * T * np.log(</span><span class="s4">2 </span><span class="s1">* np.pi) / </span><span class="s4">2</span>
            <span class="s1">- T * (np.log(np.linalg.det(s00)) + sum(np.log(</span><span class="s4">1 </span><span class="s1">- lambd)[:r])) / </span><span class="s4">2</span>
            <span class="s1">- K * T / </span><span class="s4">2</span>
        <span class="s1">)</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">_cov_sigma(self):</span>
        <span class="s1">sigma_u = self.sigma_u</span>
        <span class="s1">d = duplication_matrix(self.neqs)</span>
        <span class="s1">d_K_plus = np.linalg.pinv(d)</span>
        <span class="s0"># compare p. 93, 297 Lutkepohl (2005)</span>
        <span class="s2">return </span><span class="s4">2 </span><span class="s1">* (d_K_plus @ np.kron(sigma_u</span><span class="s2">, </span><span class="s1">sigma_u) @ d_K_plus.T)</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">cov_params_default(self):  </span><span class="s0"># p.296 (7.2.21)</span>
        <span class="s0"># Sigma_co described on p. 287</span>
        <span class="s1">beta = self.beta</span>
        <span class="s2">if </span><span class="s1">self.det_coef_coint.size &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">beta = vstack((beta</span><span class="s2">, </span><span class="s1">self.det_coef_coint))</span>
        <span class="s1">dt = self.deterministic</span>
        <span class="s1">num_det = (</span><span class="s3">&quot;co&quot; </span><span class="s2">in </span><span class="s1">dt) + (</span><span class="s3">&quot;lo&quot; </span><span class="s2">in </span><span class="s1">dt)</span>
        <span class="s1">num_det += (self.seasons - </span><span class="s4">1</span><span class="s1">) </span><span class="s2">if </span><span class="s1">self.seasons </span><span class="s2">else </span><span class="s4">0</span>
        <span class="s2">if </span><span class="s1">self.exog </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">num_det += self.exog.shape[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">b_id = scipy.linalg.block_diag(</span>
            <span class="s1">beta</span><span class="s2">, </span><span class="s1">np.identity(self.neqs * (self.k_ar - </span><span class="s4">1</span><span class="s1">) + num_det)</span>
        <span class="s1">)</span>

        <span class="s1">y_lag1 = self._y_lag1</span>
        <span class="s1">b_y = beta.T.dot(y_lag1)</span>
        <span class="s1">omega11 = b_y.dot(b_y.T)</span>
        <span class="s1">omega12 = b_y.dot(self._delta_x.T)</span>
        <span class="s1">omega21 = omega12.T</span>
        <span class="s1">omega22 = self._delta_x.dot(self._delta_x.T)</span>
        <span class="s1">omega = np.bmat([[omega11</span><span class="s2">, </span><span class="s1">omega12]</span><span class="s2">, </span><span class="s1">[omega21</span><span class="s2">, </span><span class="s1">omega22]]).A</span>

        <span class="s1">mat1 = b_id.dot(inv(omega)).dot(b_id.T)</span>
        <span class="s2">return </span><span class="s1">np.kron(mat1</span><span class="s2">, </span><span class="s1">self.sigma_u)</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">cov_params_wo_det(self):</span>
        <span class="s0"># rows &amp; cols to be dropped (related to deterministic terms inside the</span>
        <span class="s0"># cointegration relation)</span>
        <span class="s1">start_i = self.neqs ** </span><span class="s4">2  </span><span class="s0"># first elements belong to alpha @ beta.T</span>
        <span class="s1">end_i = start_i + self.neqs * self.det_coef_coint.shape[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">to_drop_i = np.arange(start_i</span><span class="s2">, </span><span class="s1">end_i)</span>

        <span class="s0"># rows &amp; cols to be dropped (related to deterministic terms outside of</span>
        <span class="s0"># the cointegration relation)</span>
        <span class="s1">cov = self.cov_params_default</span>
        <span class="s1">cov_size = len(cov)</span>
        <span class="s1">to_drop_o = np.arange(cov_size - self.det_coef.size</span><span class="s2">, </span><span class="s1">cov_size)</span>

        <span class="s1">to_drop = np.union1d(to_drop_i</span><span class="s2">, </span><span class="s1">to_drop_o)</span>

        <span class="s1">mask = np.ones(cov.shape</span><span class="s2">, </span><span class="s1">dtype=bool)</span>
        <span class="s1">mask[to_drop] = </span><span class="s2">False</span>
        <span class="s1">mask[:</span><span class="s2">, </span><span class="s1">to_drop] = </span><span class="s2">False</span>
        <span class="s1">cov_size_new = mask.sum(axis=</span><span class="s4">0</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">cov[mask].reshape((cov_size_new</span><span class="s2">, </span><span class="s1">cov_size_new))</span>

    <span class="s0"># standard errors:</span>
    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">stderr_params(self):</span>
        <span class="s2">return </span><span class="s1">np.sqrt(np.diag(self.cov_params_default))</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">stderr_coint(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Standard errors of beta and deterministic terms inside the 
        cointegration relation. 
 
        Notes 
        ----- 
        See p. 297 in [1]_. Using the rule 
 
        .. math:: 
 
           vec(B R) = (B' \\otimes I) vec(R) 
 
        for two matrices B and R which are compatible for multiplication. 
        This is rule (3) on p. 662 in [1]_. 
 
        References 
        ---------- 
        .. [1] Lütkepohl, H. 2005. *New Introduction to Multiple Time Series Analysis*. Springer. 
        &quot;&quot;&quot;</span>
        <span class="s1">r = self.coint_rank</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">r1 = _r_matrices(self._delta_y_1_T</span><span class="s2">, </span><span class="s1">self._y_lag1</span><span class="s2">, </span><span class="s1">self._delta_x)</span>
        <span class="s1">r12 = r1[r:]</span>
        <span class="s2">if </span><span class="s1">r12.size == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">np.zeros((r</span><span class="s2">, </span><span class="s1">r))</span>
        <span class="s1">mat1 = inv(r12.dot(r12.T))</span>
        <span class="s1">mat1 = np.kron(mat1.T</span><span class="s2">, </span><span class="s1">np.identity(r))</span>
        <span class="s1">det = self.det_coef_coint.shape[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">mat2 = np.kron(</span>
            <span class="s1">np.identity(self.neqs - r + det)</span><span class="s2">,</span>
            <span class="s1">inv(self.alpha.T @ inv(self.sigma_u) @ self.alpha)</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">first_rows = np.zeros((r</span><span class="s2">, </span><span class="s1">r))</span>
        <span class="s1">last_rows_1d = np.sqrt(np.diag(mat1.dot(mat2)))</span>
        <span class="s1">last_rows = last_rows_1d.reshape((self.neqs - r + det</span><span class="s2">, </span><span class="s1">r)</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">&quot;F&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">vstack((first_rows</span><span class="s2">, </span><span class="s1">last_rows))</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">stderr_alpha(self):</span>
        <span class="s1">ret_1dim = self.stderr_params[: self.alpha.size]</span>
        <span class="s2">return </span><span class="s1">ret_1dim.reshape(self.alpha.shape</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">&quot;F&quot;</span><span class="s1">)</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">stderr_beta(self):</span>
        <span class="s1">ret_1dim = self.stderr_coint[: self.beta.shape[</span><span class="s4">0</span><span class="s1">]]</span>
        <span class="s2">return </span><span class="s1">ret_1dim.reshape(self.beta.shape</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">&quot;F&quot;</span><span class="s1">)</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">stderr_det_coef_coint(self):</span>
        <span class="s2">if </span><span class="s1">self.det_coef_coint.size == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.det_coef_coint  </span><span class="s0"># 0-size array</span>
        <span class="s1">ret_1dim = self.stderr_coint[self.beta.shape[</span><span class="s4">0</span><span class="s1">] :]</span>
        <span class="s2">return </span><span class="s1">ret_1dim.reshape(self.det_coef_coint.shape</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">&quot;F&quot;</span><span class="s1">)</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">stderr_gamma(self):</span>
        <span class="s1">start = self.alpha.shape[</span><span class="s4">0</span><span class="s1">] * (</span>
            <span class="s1">self.beta.shape[</span><span class="s4">0</span><span class="s1">] + self.det_coef_coint.shape[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">ret_1dim = self.stderr_params[start : start + self.gamma.size]</span>
        <span class="s2">return </span><span class="s1">ret_1dim.reshape(self.gamma.shape</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">&quot;F&quot;</span><span class="s1">)</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">stderr_det_coef(self):</span>
        <span class="s2">if </span><span class="s1">self.det_coef.size == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.det_coef  </span><span class="s0"># 0-size array</span>
        <span class="s1">ret1_1dim = self.stderr_params[-self.det_coef.size :]</span>
        <span class="s2">return </span><span class="s1">ret1_1dim.reshape(self.det_coef.shape</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">&quot;F&quot;</span><span class="s1">)</span>

    <span class="s0"># t-values:</span>
    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">tvalues_alpha(self):</span>
        <span class="s2">return </span><span class="s1">self.alpha / self.stderr_alpha</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">tvalues_beta(self):</span>
        <span class="s1">r = self.coint_rank</span>
        <span class="s1">first_rows = np.zeros((r</span><span class="s2">, </span><span class="s1">r))</span>
        <span class="s1">last_rows = self.beta[r:] / self.stderr_beta[r:]</span>
        <span class="s2">return </span><span class="s1">vstack((first_rows</span><span class="s2">, </span><span class="s1">last_rows))</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">tvalues_det_coef_coint(self):</span>
        <span class="s2">if </span><span class="s1">self.det_coef_coint.size == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.det_coef_coint  </span><span class="s0"># 0-size array</span>
        <span class="s2">return </span><span class="s1">self.det_coef_coint / self.stderr_det_coef_coint</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">tvalues_gamma(self):</span>
        <span class="s2">return </span><span class="s1">self.gamma / self.stderr_gamma</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">tvalues_det_coef(self):</span>
        <span class="s2">if </span><span class="s1">self.det_coef.size == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.det_coef  </span><span class="s0"># 0-size array</span>
        <span class="s2">return </span><span class="s1">self.det_coef / self.stderr_det_coef</span>

    <span class="s0"># p-values:</span>
    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">pvalues_alpha(self):</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s4">1 </span><span class="s1">- scipy.stats.norm.cdf(abs(self.tvalues_alpha))) * </span><span class="s4">2</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">pvalues_beta(self):</span>
        <span class="s1">first_rows = np.zeros((self.coint_rank</span><span class="s2">, </span><span class="s1">self.coint_rank))</span>
        <span class="s1">tval_last = self.tvalues_beta[self.coint_rank :]</span>
        <span class="s1">last_rows = (</span><span class="s4">1 </span><span class="s1">- scipy.stats.norm.cdf(abs(tval_last))) * </span><span class="s4">2  </span><span class="s0"># student-t</span>
        <span class="s2">return </span><span class="s1">vstack((first_rows</span><span class="s2">, </span><span class="s1">last_rows))</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">pvalues_det_coef_coint(self):</span>
        <span class="s2">if </span><span class="s1">self.det_coef_coint.size == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.det_coef_coint  </span><span class="s0"># 0-size array</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s4">1 </span><span class="s1">- scipy.stats.norm.cdf(abs(self.tvalues_det_coef_coint))) * </span><span class="s4">2</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">pvalues_gamma(self):</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s4">1 </span><span class="s1">- scipy.stats.norm.cdf(abs(self.tvalues_gamma))) * </span><span class="s4">2</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">pvalues_det_coef(self):</span>
        <span class="s2">if </span><span class="s1">self.det_coef.size == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.det_coef  </span><span class="s0"># 0-size array</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s4">1 </span><span class="s1">- scipy.stats.norm.cdf(abs(self.tvalues_det_coef))) * </span><span class="s4">2</span>

    <span class="s0"># confidence intervals</span>
    <span class="s2">def </span><span class="s1">_make_conf_int(self</span><span class="s2">, </span><span class="s1">est</span><span class="s2">, </span><span class="s1">stderr</span><span class="s2">, </span><span class="s1">alpha):</span>
        <span class="s1">struct_arr = np.zeros(</span>
            <span class="s1">est.shape</span><span class="s2">, </span><span class="s1">dtype=[(</span><span class="s3">&quot;lower&quot;</span><span class="s2">, </span><span class="s1">float)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;upper&quot;</span><span class="s2">, </span><span class="s1">float)]</span>
        <span class="s1">)</span>
        <span class="s1">struct_arr[</span><span class="s3">&quot;lower&quot;</span><span class="s1">] = (</span>
            <span class="s1">est - scipy.stats.norm.ppf(</span><span class="s4">1 </span><span class="s1">- alpha / </span><span class="s4">2</span><span class="s1">) * stderr</span>
        <span class="s1">)</span>
        <span class="s1">struct_arr[</span><span class="s3">&quot;upper&quot;</span><span class="s1">] = (</span>
            <span class="s1">est + scipy.stats.norm.ppf(</span><span class="s4">1 </span><span class="s1">- alpha / </span><span class="s4">2</span><span class="s1">) * stderr</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">struct_arr</span>

    <span class="s2">def </span><span class="s1">conf_int_alpha(self</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s4">0.05</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">self._make_conf_int(self.alpha</span><span class="s2">, </span><span class="s1">self.stderr_alpha</span><span class="s2">, </span><span class="s1">alpha)</span>

    <span class="s2">def </span><span class="s1">conf_int_beta(self</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s4">0.05</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">self._make_conf_int(self.beta</span><span class="s2">, </span><span class="s1">self.stderr_beta</span><span class="s2">, </span><span class="s1">alpha)</span>

    <span class="s2">def </span><span class="s1">conf_int_det_coef_coint(self</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s4">0.05</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">self._make_conf_int(</span>
            <span class="s1">self.det_coef_coint</span><span class="s2">, </span><span class="s1">self.stderr_det_coef_coint</span><span class="s2">, </span><span class="s1">alpha</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">conf_int_gamma(self</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s4">0.05</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">self._make_conf_int(self.gamma</span><span class="s2">, </span><span class="s1">self.stderr_gamma</span><span class="s2">, </span><span class="s1">alpha)</span>

    <span class="s2">def </span><span class="s1">conf_int_det_coef(self</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s4">0.05</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">self._make_conf_int(self.det_coef</span><span class="s2">, </span><span class="s1">self.stderr_det_coef</span><span class="s2">, </span><span class="s1">alpha)</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">var_rep(self):</span>
        <span class="s1">pi = self.alpha.dot(self.beta.T)</span>
        <span class="s1">gamma = self.gamma</span>
        <span class="s1">K = self.neqs</span>
        <span class="s1">A = np.zeros((self.k_ar</span><span class="s2">, </span><span class="s1">K</span><span class="s2">, </span><span class="s1">K))</span>
        <span class="s1">A[</span><span class="s4">0</span><span class="s1">] = pi + np.identity(K)</span>
        <span class="s2">if </span><span class="s1">self.gamma.size &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">A[</span><span class="s4">0</span><span class="s1">] += gamma[:</span><span class="s2">, </span><span class="s1">:K]</span>
            <span class="s1">A[self.k_ar - </span><span class="s4">1</span><span class="s1">] = -gamma[:</span><span class="s2">, </span><span class="s1">K * (self.k_ar - </span><span class="s4">2</span><span class="s1">) :]</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">self.k_ar - </span><span class="s4">1</span><span class="s1">):</span>
                <span class="s1">A[i] = (</span>
                    <span class="s1">gamma[:</span><span class="s2">, </span><span class="s1">K * i : K * (i + </span><span class="s4">1</span><span class="s1">)]</span>
                    <span class="s1">- gamma[:</span><span class="s2">, </span><span class="s1">K * (i - </span><span class="s4">1</span><span class="s1">) : K * i]</span>
                <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">A</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">cov_var_repr(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Gives the covariance matrix of the corresponding VAR-representation. 
 
        More precisely, the covariance matrix of the vector consisting of the 
        columns of the corresponding VAR coefficient matrices (i.e. 
        vec(self.var_rep)). 
 
        Returns 
        ------- 
        cov : array (neqs**2 * k_ar x neqs**2 * k_ar) 
        &quot;&quot;&quot;</span>
        <span class="s0"># This implementation is using the fact that for a random variable x</span>
        <span class="s0"># with covariance matrix Sigma_x the following holds:</span>
        <span class="s0"># B @ x with B being a suitably sized matrix has the covariance matrix</span>
        <span class="s0"># B @ Sigma_x @ B.T. The arrays called vecm_var_transformation and</span>
        <span class="s0"># self.cov_params_wo_det in the code play the roles of B and Sigma_x</span>
        <span class="s0"># respectively. The elements of the random variable x are the elements</span>
        <span class="s0"># of the estimated matrices Pi (alpha @ beta.T) and Gamma.</span>
        <span class="s0"># Alternatively the following code (commented out) would yield the same</span>
        <span class="s0"># result (following p. 289 in Lutkepohl):</span>
        <span class="s0"># K, p = self.neqs, self.k_ar</span>
        <span class="s0"># w = np.identity(K * p)</span>
        <span class="s0"># w[np.arange(K, len(w)), np.arange(K, len(w))] *= (-1)</span>
        <span class="s0"># w[np.arange(K, len(w)), np.arange(len(w)-K)] = 1</span>
        <span class="s0">#</span>
        <span class="s0"># w_eye = np.kron(w, np.identity(K))</span>
        <span class="s0">#</span>
        <span class="s0"># return w_eye.T @ self.cov_params_default @ w_eye</span>

        <span class="s2">if </span><span class="s1">self.k_ar - </span><span class="s4">1 </span><span class="s1">== </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.cov_params_wo_det</span>

        <span class="s1">vecm_var_transformation = np.zeros(</span>
            <span class="s1">(self.neqs ** </span><span class="s4">2 </span><span class="s1">* self.k_ar</span><span class="s2">, </span><span class="s1">self.neqs ** </span><span class="s4">2 </span><span class="s1">* self.k_ar)</span>
        <span class="s1">)</span>
        <span class="s1">eye = np.identity(self.neqs ** </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s0"># for A_1:</span>
        <span class="s1">vecm_var_transformation[</span>
            <span class="s1">: self.neqs ** </span><span class="s4">2</span><span class="s2">, </span><span class="s1">: </span><span class="s4">2 </span><span class="s1">* self.neqs ** </span><span class="s4">2</span>
        <span class="s1">] = hstack((eye</span><span class="s2">, </span><span class="s1">eye))</span>
        <span class="s0"># for A_i, where i = 2, ..., k_ar-1</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">self.k_ar):</span>
            <span class="s1">start_row = self.neqs ** </span><span class="s4">2 </span><span class="s1">+ (i - </span><span class="s4">2</span><span class="s1">) * self.neqs ** </span><span class="s4">2</span>
            <span class="s1">start_col = self.neqs ** </span><span class="s4">2 </span><span class="s1">+ (i - </span><span class="s4">2</span><span class="s1">) * self.neqs ** </span><span class="s4">2</span>
            <span class="s1">vecm_var_transformation[</span>
                <span class="s1">start_row : start_row + self.neqs ** </span><span class="s4">2</span><span class="s2">,</span>
                <span class="s1">start_col : start_col + </span><span class="s4">2 </span><span class="s1">* self.neqs ** </span><span class="s4">2</span><span class="s2">,</span>
            <span class="s1">] = hstack((-eye</span><span class="s2">, </span><span class="s1">eye))</span>
        <span class="s0"># for A_p:</span>
        <span class="s1">vecm_var_transformation[-self.neqs ** </span><span class="s4">2 </span><span class="s1">:</span><span class="s2">, </span><span class="s1">-self.neqs ** </span><span class="s4">2 </span><span class="s1">:] = -eye</span>
        <span class="s1">vvt = vecm_var_transformation</span>
        <span class="s2">return </span><span class="s1">vvt @ self.cov_params_wo_det @ vvt.T</span>

    <span class="s2">def </span><span class="s1">ma_rep(self</span><span class="s2">, </span><span class="s1">maxn=</span><span class="s4">10</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">ma_rep(self.var_rep</span><span class="s2">, </span><span class="s1">maxn)</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">_chol_sigma_u(self):</span>
        <span class="s2">return </span><span class="s1">np.linalg.cholesky(self.sigma_u)</span>

    <span class="s2">def </span><span class="s1">orth_ma_rep(self</span><span class="s2">, </span><span class="s1">maxn=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">P=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Compute orthogonalized MA coefficient matrices. 
 
        For this purpose a matrix  P is used which fulfills 
        :math:`\\Sigma_u = PP^\\prime`. P defaults to the Cholesky 
        decomposition of :math:`\\Sigma_u` 
 
        Parameters 
        ---------- 
        maxn : int 
            Number of coefficient matrices to compute 
        P : ndarray (neqs x neqs), optional 
            Matrix such that :math:`\\Sigma_u = PP'`. Defaults to Cholesky 
            decomposition. 
 
        Returns 
        ------- 
        coefs : ndarray (maxn x neqs x neqs) 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">orth_ma_rep(self</span><span class="s2">, </span><span class="s1">maxn</span><span class="s2">, </span><span class="s1">P)</span>

    <span class="s2">def </span><span class="s1">predict(self</span><span class="s2">, </span><span class="s1">steps=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s2">None, </span><span class="s1">exog_fc=</span><span class="s2">None, </span><span class="s1">exog_coint_fc=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Calculate future values of the time series. 
 
        Parameters 
        ---------- 
        steps : int 
            Prediction horizon. 
        alpha : float, 0 &lt; `alpha` &lt; 1 or None 
            If None, compute point forecast only. 
            If float, compute confidence intervals too. In this case the 
            argument stands for the confidence level. 
        exog : ndarray (steps x self.exog.shape[1]) 
            If self.exog is not None, then information about the future values 
            of exog have to be passed via this parameter. The ndarray may be 
            larger in it's first dimension. In this case only the first steps 
            rows will be considered. 
 
        Returns 
        ------- 
        forecast - ndarray (steps x neqs) or three ndarrays 
            In case of a point forecast: each row of the returned ndarray 
            represents the forecast of the neqs variables for a specific 
            period. The first row (index [0]) is the forecast for the next 
            period, the last row (index [steps-1]) is the steps-periods-ahead- 
            forecast. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.exog </span><span class="s2">is not None and </span><span class="s1">exog_fc </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;exog_fc is None: Please pass the future values &quot;</span>
                <span class="s3">&quot;of the VECM's exog terms via the exog_fc &quot;</span>
                <span class="s3">&quot;argument!&quot;</span>
            <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.exog </span><span class="s2">is None and </span><span class="s1">exog_fc </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;This VECMResult-instance's exog attribute is &quot;</span>
                <span class="s3">&quot;None. Please do not pass a non-None value as the &quot;</span>
                <span class="s3">&quot;method's exog_fc-argument.&quot;</span>
            <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">exog_fc </span><span class="s2">is not None and </span><span class="s1">exog_fc.shape[</span><span class="s4">0</span><span class="s1">] &lt; steps:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;The argument exog_fc must have at least steps &quot;</span>
                <span class="s3">&quot;elements in its first dimension&quot;</span>
            <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self.exog_coint </span><span class="s2">is not None and </span><span class="s1">exog_coint_fc </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;exog_coint_fc is None: Please pass the future &quot;</span>
                <span class="s3">&quot;values of the VECM's exog_coint terms via the &quot;</span>
                <span class="s3">&quot;exog_coint_fc argument!&quot;</span>
            <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.exog_coint </span><span class="s2">is None and </span><span class="s1">exog_coint_fc </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;This VECMResult-instance's exog_coint attribute &quot;</span>
                <span class="s3">&quot;is None. Please do not pass a non-None value as &quot;</span>
                <span class="s3">&quot;the method's exog_coint_fc-argument.&quot;</span>
            <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">exog_coint_fc </span><span class="s2">is not None and </span><span class="s1">exog_coint_fc.shape[</span><span class="s4">0</span><span class="s1">] &lt; steps - </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;The argument exog_coint_fc must have at least &quot;</span>
                <span class="s3">&quot;steps elements in its first dimension&quot;</span>
            <span class="s1">)</span>

        <span class="s1">last_observations = self.y_all.T[-self.k_ar :]</span>
        <span class="s1">exog = []</span>
        <span class="s1">trend_coefs = []</span>

        <span class="s0"># adding deterministic terms outside cointegration relation</span>
        <span class="s1">exog_const = np.ones(steps)</span>
        <span class="s1">nobs_tot = self.nobs + self.k_ar</span>
        <span class="s2">if </span><span class="s1">self.const.size &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">exog.append(exog_const)</span>
            <span class="s1">trend_coefs.append(self.const.T)</span>

        <span class="s2">if </span><span class="s1">self.seasons &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">first_future_season = (self.first_season + nobs_tot) % self.seasons</span>
            <span class="s1">exog_seasonal = seasonal_dummies(</span>
                <span class="s1">self.seasons</span><span class="s2">, </span><span class="s1">steps</span><span class="s2">, </span><span class="s1">first_future_season</span><span class="s2">, True</span>
            <span class="s1">)</span>
            <span class="s1">exog.append(exog_seasonal)</span>
            <span class="s1">trend_coefs.append(self.seasonal.T)</span>

        <span class="s1">exog_lin_trend = _linear_trend(self.nobs</span><span class="s2">, </span><span class="s1">self.k_ar)</span>
        <span class="s1">exog_lin_trend = exog_lin_trend[-</span><span class="s4">1</span><span class="s1">] + </span><span class="s4">1 </span><span class="s1">+ np.arange(steps)</span>
        <span class="s2">if </span><span class="s1">self.lin_trend.size &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">exog.append(exog_lin_trend)</span>
            <span class="s1">trend_coefs.append(self.lin_trend.T)</span>

        <span class="s2">if </span><span class="s1">exog_fc </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">exog.append(exog_fc[:steps])</span>
            <span class="s1">trend_coefs.append(self.exog_coefs.T)</span>

        <span class="s0"># adding deterministic terms inside cointegration relation</span>
        <span class="s2">if </span><span class="s3">&quot;ci&quot; </span><span class="s2">in </span><span class="s1">self.deterministic:</span>
            <span class="s1">exog.append(exog_const)</span>
            <span class="s1">trend_coefs.append(self.alpha.dot(self.const_coint.T).T)</span>
        <span class="s1">exog_lin_trend_coint = _linear_trend(self.nobs</span><span class="s2">, </span><span class="s1">self.k_ar</span><span class="s2">, </span><span class="s1">coint=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">exog_lin_trend_coint = exog_lin_trend_coint[-</span><span class="s4">1</span><span class="s1">] + </span><span class="s4">1 </span><span class="s1">+ np.arange(steps)</span>
        <span class="s2">if </span><span class="s3">&quot;li&quot; </span><span class="s2">in </span><span class="s1">self.deterministic:</span>
            <span class="s1">exog.append(exog_lin_trend_coint)</span>
            <span class="s1">trend_coefs.append(self.alpha.dot(self.lin_trend_coint.T).T)</span>

        <span class="s2">if </span><span class="s1">exog_coint_fc </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">exog_coint_fc.ndim == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">exog_coint_fc = exog_coint_fc[:</span><span class="s2">, None</span><span class="s1">]  </span><span class="s0"># make 2-D</span>
            <span class="s1">exog_coint_fc = np.vstack(</span>
                <span class="s1">(self.exog_coint[-</span><span class="s4">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">exog_coint_fc[: steps - </span><span class="s4">1</span><span class="s1">])</span>
            <span class="s1">)</span>
            <span class="s1">exog.append(exog_coint_fc)</span>
            <span class="s1">trend_coefs.append(self.alpha.dot(self.exog_coint_coefs.T).T)</span>

        <span class="s0"># glueing all deterministics together</span>
        <span class="s1">exog = np.column_stack(exog) </span><span class="s2">if </span><span class="s1">exog != [] </span><span class="s2">else None</span>
        <span class="s2">if </span><span class="s1">trend_coefs != []:</span>
            <span class="s1">trend_coefs = np.row_stack(trend_coefs)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">trend_coefs = </span><span class="s2">None</span>

        <span class="s0"># call the forecasting function of the VAR-module</span>
        <span class="s2">if </span><span class="s1">alpha </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">forecast_interval(</span>
                <span class="s1">last_observations</span><span class="s2">,</span>
                <span class="s1">self.var_rep</span><span class="s2">,</span>
                <span class="s1">trend_coefs</span><span class="s2">,</span>
                <span class="s1">self.sigma_u</span><span class="s2">,</span>
                <span class="s1">steps</span><span class="s2">,</span>
                <span class="s1">alpha=alpha</span><span class="s2">,</span>
                <span class="s1">exog=exog</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">forecast(</span>
                <span class="s1">last_observations</span><span class="s2">, </span><span class="s1">self.var_rep</span><span class="s2">, </span><span class="s1">trend_coefs</span><span class="s2">, </span><span class="s1">steps</span><span class="s2">, </span><span class="s1">exog</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">plot_forecast(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">steps</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s4">0.05</span><span class="s2">, </span><span class="s1">plot_conf_int=</span><span class="s2">True, </span><span class="s1">n_last_obs=</span><span class="s2">None</span>
    <span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Plot the forecast. 
 
        Parameters 
        ---------- 
        steps : int 
            Prediction horizon. 
        alpha : float, 0 &lt; `alpha` &lt; 1 
            The confidence level. 
        plot_conf_int : bool, default: True 
            If True, plot bounds of confidence intervals. 
        n_last_obs : int or None, default: None 
            If int, restrict plotted history to n_last_obs observations. 
            If None, include the whole history in the plot. 
        &quot;&quot;&quot;</span>
        <span class="s1">mid</span><span class="s2">, </span><span class="s1">lower</span><span class="s2">, </span><span class="s1">upper = self.predict(steps</span><span class="s2">, </span><span class="s1">alpha=alpha)</span>

        <span class="s1">y = self.y_all.T</span>
        <span class="s1">y = y[self.k_ar :] </span><span class="s2">if </span><span class="s1">n_last_obs </span><span class="s2">is None else </span><span class="s1">y[-n_last_obs:]</span>
        <span class="s1">plot.plot_var_forc(</span>
            <span class="s1">y</span><span class="s2">,</span>
            <span class="s1">mid</span><span class="s2">,</span>
            <span class="s1">lower</span><span class="s2">,</span>
            <span class="s1">upper</span><span class="s2">,</span>
            <span class="s1">names=self.names</span><span class="s2">,</span>
            <span class="s1">plot_stderr=plot_conf_int</span><span class="s2">,</span>
            <span class="s1">legend_options={</span><span class="s3">&quot;loc&quot;</span><span class="s1">: </span><span class="s3">&quot;lower left&quot;</span><span class="s1">}</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_granger_causality(self</span><span class="s2">, </span><span class="s1">caused</span><span class="s2">, </span><span class="s1">causing=</span><span class="s2">None, </span><span class="s1">signif=</span><span class="s4">0.05</span><span class="s1">):</span>
        <span class="s5">r&quot;&quot;&quot; 
        Test for Granger-causality. 
 
        The concept of Granger-causality is described in chapter 7.6.3 of [1]_. 
        Test |H0|: &quot;The variables in `causing` do not Granger-cause those in 
        `caused`&quot; against  |H1|: &quot;`causing` is Granger-causal for 
        `caused`&quot;. 
 
        Parameters 
        ---------- 
        caused : int or str or sequence of int or str 
            If int or str, test whether the variable specified via this index 
            (int) or name (str) is Granger-caused by the variable(s) specified 
            by `causing`. 
            If a sequence of int or str, test whether the corresponding 
            variables are Granger-caused by the variable(s) specified 
            by `causing`. 
        causing : int or str or sequence of int or str or `None`, default: `None` 
            If int or str, test whether the variable specified via this index 
            (int) or name (str) is Granger-causing the variable(s) specified by 
            `caused`. 
            If a sequence of int or str, test whether the corresponding 
            variables are Granger-causing the variable(s) specified by 
            `caused`. 
            If `None`, `causing` is assumed to be the complement of 
            `caused` (the remaining variables of the system). 
        signif : float, 0 &lt; `signif` &lt; 1, default 5 % 
            Significance level for computing critical values for test, 
            defaulting to standard 0.05 level. 
 
        Returns 
        ------- 
        results : :class:`statsmodels.tsa.vector_ar.hypothesis_test_results.CausalityTestResults` 
 
        References 
        ---------- 
        .. [1] Lütkepohl, H. 2005. *New Introduction to Multiple Time Series Analysis*. Springer. 
 
        .. |H0| replace:: H\ :sub:`0` 
 
        .. |H1| replace:: H\ :sub:`1` 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">&lt; signif &lt; </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;signif has to be between 0 and 1&quot;</span><span class="s1">)</span>

        <span class="s1">allowed_types = (str</span><span class="s2">, </span><span class="s1">int)</span>

        <span class="s2">if </span><span class="s1">isinstance(caused</span><span class="s2">, </span><span class="s1">allowed_types):</span>
            <span class="s1">caused = [caused]</span>
        <span class="s2">if not </span><span class="s1">all(isinstance(c</span><span class="s2">, </span><span class="s1">allowed_types) </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">caused):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s3">&quot;caused has to be of type string or int (or a &quot;</span>
                <span class="s3">&quot;sequence of these types).&quot;</span>
            <span class="s1">)</span>
        <span class="s1">caused = [self.names[c] </span><span class="s2">if </span><span class="s1">type(c) == int </span><span class="s2">else </span><span class="s1">c </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">caused]</span>
        <span class="s1">caused_ind = [get_index(self.names</span><span class="s2">, </span><span class="s1">c) </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">caused]</span>

        <span class="s2">if </span><span class="s1">causing </span><span class="s2">is not None</span><span class="s1">:</span>

            <span class="s2">if </span><span class="s1">isinstance(causing</span><span class="s2">, </span><span class="s1">allowed_types):</span>
                <span class="s1">causing = [causing]</span>
            <span class="s2">if not </span><span class="s1">all(isinstance(c</span><span class="s2">, </span><span class="s1">allowed_types) </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">causing):</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span>
                    <span class="s3">&quot;causing has to be of type string or int (or &quot;</span>
                    <span class="s3">&quot;a sequence of these types) or None.&quot;</span>
                <span class="s1">)</span>
            <span class="s1">causing = [self.names[c] </span><span class="s2">if </span><span class="s1">type(c) == int </span><span class="s2">else </span><span class="s1">c </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">causing]</span>
            <span class="s1">causing_ind = [get_index(self.names</span><span class="s2">, </span><span class="s1">c) </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">causing]</span>

        <span class="s2">if </span><span class="s1">causing </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">causing_ind = [i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.neqs) </span><span class="s2">if </span><span class="s1">i </span><span class="s2">not in </span><span class="s1">caused_ind]</span>
            <span class="s1">causing = [self.names[c] </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">causing_ind]</span>

        <span class="s1">y</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">p = self.y_all</span><span class="s2">, </span><span class="s1">self.neqs</span><span class="s2">, </span><span class="s1">self.nobs - </span><span class="s4">1</span><span class="s2">, </span><span class="s1">self.k_ar + </span><span class="s4">1</span>
        <span class="s1">exog = _deterministic_to_exog(</span>
            <span class="s1">self.deterministic</span><span class="s2">,</span>
            <span class="s1">self.seasons</span><span class="s2">,</span>
            <span class="s1">nobs_tot=self.nobs + self.k_ar</span><span class="s2">,</span>
            <span class="s1">first_season=self.first_season</span><span class="s2">,</span>
            <span class="s1">seasons_centered=</span><span class="s2">True,</span>
            <span class="s1">exog=self.exog</span><span class="s2">,</span>
            <span class="s1">exog_coint=self.exog_coint</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">var_results = VAR(y.T</span><span class="s2">, </span><span class="s1">exog).fit(maxlags=p</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">&quot;n&quot;</span><span class="s1">)</span>

        <span class="s0"># num_restr is called N in Lutkepohl</span>
        <span class="s1">num_restr = len(causing) * len(caused) * (p - </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">num_det_terms = _num_det_vars(self.deterministic</span><span class="s2">, </span><span class="s1">self.seasons)</span>
        <span class="s2">if </span><span class="s1">self.exog </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">num_det_terms += self.exog.shape[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self.exog_coint </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">num_det_terms += self.exog_coint.shape[</span><span class="s4">1</span><span class="s1">]</span>

        <span class="s0"># Make restriction matrix</span>
        <span class="s1">C = np.zeros(</span>
            <span class="s1">(num_restr</span><span class="s2">, </span><span class="s1">k * num_det_terms + k ** </span><span class="s4">2 </span><span class="s1">* (p - </span><span class="s4">1</span><span class="s1">))</span><span class="s2">, </span><span class="s1">dtype=float</span>
        <span class="s1">)</span>
        <span class="s1">cols_det = k * num_det_terms</span>
        <span class="s1">row = </span><span class="s4">0</span>
        <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(p - </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s2">for </span><span class="s1">ing_ind </span><span class="s2">in </span><span class="s1">causing_ind:</span>
                <span class="s2">for </span><span class="s1">ed_ind </span><span class="s2">in </span><span class="s1">caused_ind:</span>
                    <span class="s1">C[row</span><span class="s2">, </span><span class="s1">cols_det + ed_ind + k * ing_ind + k ** </span><span class="s4">2 </span><span class="s1">* j] = </span><span class="s4">1</span>
                    <span class="s1">row += </span><span class="s4">1</span>
        <span class="s1">Ca = np.dot(C</span><span class="s2">, </span><span class="s1">vec(var_results.params[:-k].T))</span>

        <span class="s1">x_min_p_components = []</span>
        <span class="s2">if </span><span class="s1">exog </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">x_min_p_components.append(exog[-t:].T)</span>

        <span class="s1">x_min_p = np.zeros((k * p</span><span class="s2">, </span><span class="s1">t))</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(p - </span><span class="s4">1</span><span class="s1">):  </span><span class="s0"># fll first k * k_ar rows of x_min_p</span>
            <span class="s1">x_min_p[i * k : (i + </span><span class="s4">1</span><span class="s1">) * k</span><span class="s2">, </span><span class="s1">:] = (</span>
                <span class="s1">y[:</span><span class="s2">, </span><span class="s1">p - </span><span class="s4">1 </span><span class="s1">- i : -</span><span class="s4">1 </span><span class="s1">- i] - y[:</span><span class="s2">, </span><span class="s1">:-p]</span>
            <span class="s1">)</span>
        <span class="s1">x_min_p[-k:</span><span class="s2">, </span><span class="s1">:] = y[:</span><span class="s2">, </span><span class="s1">:-p]  </span><span class="s0"># fill last rows of x_min_p</span>
        <span class="s1">x_min_p_components.append(x_min_p)</span>

        <span class="s1">x_min_p = np.row_stack(x_min_p_components)</span>
        <span class="s1">x_x = np.dot(x_min_p</span><span class="s2">, </span><span class="s1">x_min_p.T)  </span><span class="s0"># k*k_ar x k*k_ar</span>
        <span class="s1">x_x_11 = inv(x_x)[</span>
            <span class="s1">: k * (p - </span><span class="s4">1</span><span class="s1">) + num_det_terms</span><span class="s2">, </span><span class="s1">: k * (p - </span><span class="s4">1</span><span class="s1">) + num_det_terms</span>
        <span class="s1">]  </span><span class="s0"># k*(k_ar-1) x k*(k_ar-1)</span>
        <span class="s0"># For VAR-models with parameter restrictions the denominator in the</span>
        <span class="s0"># calculation of sigma_u is nobs and not (nobs-k*k_ar-num_det_terms).</span>
        <span class="s0"># Testing for Granger-causality means testing for restricted</span>
        <span class="s0"># parameters, thus the former of the two denominators is used. As</span>
        <span class="s0"># Lutkepohl states, both variants of the estimated sigma_u are</span>
        <span class="s0"># possible. (see Lutkepohl, p.198)</span>
        <span class="s0"># The choice of the denominator T has also the advantage of getting the</span>
        <span class="s0"># same results as the reference software JMulTi.</span>
        <span class="s1">sigma_u = var_results.sigma_u * (t - k * p - num_det_terms) / t</span>
        <span class="s1">sig_alpha_min_p = t * np.kron(x_x_11</span><span class="s2">, </span><span class="s1">sigma_u)  </span><span class="s0"># k**2*(p-1)xk**2*(p-1)</span>
        <span class="s1">middle = inv(C @ sig_alpha_min_p @ C.T)</span>

        <span class="s1">wald_statistic = t * (Ca.T @ middle @ Ca)</span>
        <span class="s1">f_statistic = wald_statistic / num_restr</span>
        <span class="s1">df = (num_restr</span><span class="s2">, </span><span class="s1">k * var_results.df_resid)</span>
        <span class="s1">f_distribution = scipy.stats.f(*df)</span>

        <span class="s1">pvalue = f_distribution.sf(f_statistic)</span>
        <span class="s1">crit_value = f_distribution.ppf(</span><span class="s4">1 </span><span class="s1">- signif)</span>
        <span class="s2">return </span><span class="s1">CausalityTestResults(</span>
            <span class="s1">causing</span><span class="s2">,</span>
            <span class="s1">caused</span><span class="s2">,</span>
            <span class="s1">f_statistic</span><span class="s2">,</span>
            <span class="s1">crit_value</span><span class="s2">,</span>
            <span class="s1">pvalue</span><span class="s2">,</span>
            <span class="s1">df</span><span class="s2">,</span>
            <span class="s1">signif</span><span class="s2">,</span>
            <span class="s1">test=</span><span class="s3">&quot;granger&quot;</span><span class="s2">,</span>
            <span class="s1">method=</span><span class="s3">&quot;f&quot;</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_inst_causality(self</span><span class="s2">, </span><span class="s1">causing</span><span class="s2">, </span><span class="s1">signif=</span><span class="s4">0.05</span><span class="s1">):</span>
        <span class="s5">r&quot;&quot;&quot; 
        Test for instantaneous causality. 
 
        The concept of instantaneous causality is described in chapters 3.6.3 
        and 7.6.4 of [1]_. Test |H0|: &quot;No instantaneous causality between the 
        variables in `caused` and those in `causing`&quot; against |H1|: 
        &quot;Instantaneous causality between `caused` and `causing` exists&quot;. 
        Note that instantaneous causality is a symmetric relation 
        (i.e. if `causing` is &quot;instantaneously causing&quot; `caused`, then also 
        `caused` is &quot;instantaneously causing&quot; `causing`), thus the naming of 
        the parameters (which is chosen to be in accordance with 
        :meth:`test_granger_causality()`) may be misleading. 
 
        Parameters 
        ---------- 
        causing : int or str or sequence of int or str 
            If int or str, test whether the corresponding variable is causing 
            the variable(s) specified in caused. 
            If sequence of int or str, test whether the corresponding variables 
            are causing the variable(s) specified in caused. 
        signif : float, 0 &lt; `signif` &lt; 1, default 5 % 
            Significance level for computing critical values for test, 
            defaulting to standard 0.05 level. 
 
        Returns 
        ------- 
        results : :class:`statsmodels.tsa.vector_ar.hypothesis_test_results.CausalityTestResults` 
 
        Notes 
        ----- 
        This method is not returning the same result as `JMulTi`. This is 
        because the test is based on a VAR(k_ar) model in `statsmodels` (in 
        accordance to pp. 104, 320-321 in [1]_) whereas `JMulTi` seems to be 
        using a VAR(k_ar+1) model. Reducing the lag order by one in `JMulTi` 
        leads to equal results in `statsmodels` and `JMulTi`. 
 
        References 
        ---------- 
        .. [1] Lütkepohl, H. 2005. *New Introduction to Multiple Time Series Analysis*. Springer. 
 
        .. |H0| replace:: H\ :sub:`0` 
 
        .. |H1| replace:: H\ :sub:`1` 
        &quot;&quot;&quot;</span>
        <span class="s1">exog = _deterministic_to_exog(</span>
            <span class="s1">self.deterministic</span><span class="s2">,</span>
            <span class="s1">self.seasons</span><span class="s2">,</span>
            <span class="s1">nobs_tot=self.nobs + self.k_ar</span><span class="s2">,</span>
            <span class="s1">first_season=self.first_season</span><span class="s2">,</span>
            <span class="s1">seasons_centered=</span><span class="s2">True,</span>
            <span class="s1">exog=self.exog</span><span class="s2">,</span>
            <span class="s1">exog_coint=self.exog_coint</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s0"># Note: JMulTi seems to be using k_ar+1 instead of k_ar</span>
        <span class="s1">k</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">p = self.neqs</span><span class="s2">, </span><span class="s1">self.nobs</span><span class="s2">, </span><span class="s1">self.k_ar</span>
        <span class="s0"># fit with trend &quot;n&quot; because all trend information is already in exog</span>
        <span class="s1">var_results = VAR(self.y_all.T</span><span class="s2">, </span><span class="s1">exog).fit(maxlags=p</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">&quot;n&quot;</span><span class="s1">)</span>
        <span class="s1">var_results._results.names = self.names</span>
        <span class="s2">return </span><span class="s1">var_results.test_inst_causality(causing=causing</span><span class="s2">, </span><span class="s1">signif=signif)</span>

    <span class="s2">def </span><span class="s1">irf(self</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">irf.IRAnalysis(self</span><span class="s2">, </span><span class="s1">periods=periods</span><span class="s2">, </span><span class="s1">vecm=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">fittedvalues(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Return the in-sample values of endog calculated by the model. 
 
        Returns 
        ------- 
        fitted : array (nobs x neqs) 
            The predicted in-sample values of the models' endogenous variables. 
        &quot;&quot;&quot;</span>
        <span class="s1">beta = self.beta</span>
        <span class="s2">if </span><span class="s1">self.det_coef_coint.size &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">beta = vstack((beta</span><span class="s2">, </span><span class="s1">self.det_coef_coint))</span>
        <span class="s1">pi = np.dot(self.alpha</span><span class="s2">, </span><span class="s1">beta.T)</span>

        <span class="s1">gamma = self.gamma</span>
        <span class="s2">if </span><span class="s1">self.det_coef.size &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">gamma = hstack((gamma</span><span class="s2">, </span><span class="s1">self.det_coef))</span>
        <span class="s1">delta_y = np.dot(pi</span><span class="s2">, </span><span class="s1">self._y_lag1) + np.dot(gamma</span><span class="s2">, </span><span class="s1">self._delta_x)</span>
        <span class="s2">return </span><span class="s1">(delta_y + self._y_lag1[: self.neqs]).T</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">resid(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Return the difference between observed and fitted values. 
 
        Returns 
        ------- 
        resid : array (nobs x neqs) 
            The residuals. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.y_all.T[self.k_ar :] - self.fittedvalues</span>

    <span class="s2">def </span><span class="s1">test_normality(self</span><span class="s2">, </span><span class="s1">signif=</span><span class="s4">0.05</span><span class="s1">):</span>
        <span class="s5">r&quot;&quot;&quot; 
        Test assumption of normal-distributed errors using Jarque-Bera-style 
        omnibus :math:`\\chi^2` test. 
 
        Parameters 
        ---------- 
        signif : float 
            The test's significance level. 
 
        Returns 
        ------- 
        result : :class:`statsmodels.tsa.vector_ar.hypothesis_test_results.NormalityTestResults` 
 
        Notes 
        ----- 
        |H0| : data are generated by a Gaussian-distributed process 
 
        .. |H0| replace:: H\ :sub:`0` 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">test_normality(self</span><span class="s2">, </span><span class="s1">signif=signif)</span>

    <span class="s2">def </span><span class="s1">test_whiteness(self</span><span class="s2">, </span><span class="s1">nlags=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">signif=</span><span class="s4">0.05</span><span class="s2">, </span><span class="s1">adjusted=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Test the whiteness of the residuals using the Portmanteau test. 
 
        This test is described in [1]_, chapter 8.4.1. 
 
        Parameters 
        ---------- 
        nlags : int &gt; 0 
        signif : float, 0 &lt; `signif` &lt; 1 
        adjusted : bool, default False 
 
        Returns 
        ------- 
        result : :class:`statsmodels.tsa.vector_ar.hypothesis_test_results.WhitenessTestResults` 
 
        References 
        ---------- 
        .. [1] Lütkepohl, H. 2005. *New Introduction to Multiple Time Series Analysis*. Springer. 
        &quot;&quot;&quot;</span>

        <span class="s1">statistic = </span><span class="s4">0</span>
        <span class="s1">u = np.asarray(self.resid)</span>
        <span class="s1">acov_list = _compute_acov(u</span><span class="s2">, </span><span class="s1">nlags)</span>
        <span class="s0"># self.sigma_u instead of cov(0) is necessary to get the same</span>
        <span class="s0"># result as JMulTi. The difference between the two is that sigma_u is</span>
        <span class="s0"># calculated with the usual residuals while in cov(0) the</span>
        <span class="s0"># residuals are demeaned. To me JMulTi's behaviour seems a bit strange</span>
        <span class="s0"># because it uses the usual residuals here but demeaned residuals in</span>
        <span class="s0"># the calculation of autocovariances with lag &gt; 0. (used in the</span>
        <span class="s0"># argument of trace() four rows below this comment.)</span>
        <span class="s1">c0_inv = inv(self.sigma_u)  </span><span class="s0"># instead of inv(cov(0))</span>
        <span class="s2">if </span><span class="s1">c0_inv.dtype == np.complex128 </span><span class="s2">and </span><span class="s1">np.all(np.imag(c0_inv) == </span><span class="s4">0</span><span class="s1">):</span>
            <span class="s1">c0_inv = np.real(c0_inv)</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">nlags + </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">ct = acov_list[t]</span>
            <span class="s1">to_add = np.trace(ct.T @ c0_inv @ ct @ c0_inv)</span>
            <span class="s2">if </span><span class="s1">adjusted:</span>
                <span class="s1">to_add /= self.nobs - t</span>
            <span class="s1">statistic += to_add</span>
        <span class="s1">statistic *= self.nobs ** </span><span class="s4">2 </span><span class="s2">if </span><span class="s1">adjusted </span><span class="s2">else </span><span class="s1">self.nobs</span>

        <span class="s1">df = (</span>
            <span class="s1">self.neqs ** </span><span class="s4">2 </span><span class="s1">* (nlags - self.k_ar + </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">- self.neqs * self.coint_rank</span>
        <span class="s1">)</span>
        <span class="s1">dist = scipy.stats.chi2(df)</span>
        <span class="s1">pvalue = dist.sf(statistic)</span>
        <span class="s1">crit_value = dist.ppf(</span><span class="s4">1 </span><span class="s1">- signif)</span>

        <span class="s2">return </span><span class="s1">WhitenessTestResults(</span>
            <span class="s1">statistic</span><span class="s2">, </span><span class="s1">crit_value</span><span class="s2">, </span><span class="s1">pvalue</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">signif</span><span class="s2">, </span><span class="s1">nlags</span><span class="s2">, </span><span class="s1">adjusted</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">plot_data(self</span><span class="s2">, </span><span class="s1">with_presample=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Plot the input time series. 
 
        Parameters 
        ---------- 
        with_presample : bool, default: `False` 
            If `False`, the pre-sample data (the first `k_ar` values) will 
            not be plotted. 
        &quot;&quot;&quot;</span>
        <span class="s1">y = self.y_all </span><span class="s2">if </span><span class="s1">with_presample </span><span class="s2">else </span><span class="s1">self.y_all[:</span><span class="s2">, </span><span class="s1">self.k_ar :]</span>
        <span class="s1">names = self.names</span>
        <span class="s1">dates = self.dates </span><span class="s2">if </span><span class="s1">with_presample </span><span class="s2">else </span><span class="s1">self.dates[self.k_ar :]</span>
        <span class="s1">plot.plot_mts(y.T</span><span class="s2">, </span><span class="s1">names=names</span><span class="s2">, </span><span class="s1">index=dates)</span>

    <span class="s2">def </span><span class="s1">summary(self</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s4">0.05</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Return a summary of the estimation results. 
 
        Parameters 
        ---------- 
        alpha : float 0 &lt; `alpha` &lt; 1, default 0.05 
            Significance level of the shown confidence intervals. 
 
        Returns 
        ------- 
        summary : :class:`statsmodels.iolib.summary.Summary` 
            A summary containing information about estimated parameters. 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">statsmodels.iolib.summary </span><span class="s2">import </span><span class="s1">summary_params</span>

        <span class="s1">summary = Summary()</span>

        <span class="s2">def </span><span class="s1">make_table(</span>
            <span class="s1">self</span><span class="s2">,</span>
            <span class="s1">params</span><span class="s2">,</span>
            <span class="s1">std_err</span><span class="s2">,</span>
            <span class="s1">t_values</span><span class="s2">,</span>
            <span class="s1">p_values</span><span class="s2">,</span>
            <span class="s1">conf_int</span><span class="s2">,</span>
            <span class="s1">mask</span><span class="s2">,</span>
            <span class="s1">names</span><span class="s2">,</span>
            <span class="s1">title</span><span class="s2">,</span>
            <span class="s1">strip_end=</span><span class="s2">True,</span>
        <span class="s1">):</span>
            <span class="s1">res = (</span>
                <span class="s1">self</span><span class="s2">,</span>
                <span class="s1">params[mask]</span><span class="s2">,</span>
                <span class="s1">std_err[mask]</span><span class="s2">,</span>
                <span class="s1">t_values[mask]</span><span class="s2">,</span>
                <span class="s1">p_values[mask]</span><span class="s2">,</span>
                <span class="s1">conf_int[mask]</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s1">param_names = [</span>
                <span class="s3">&quot;.&quot;</span><span class="s1">.join(name.split(</span><span class="s3">&quot;.&quot;</span><span class="s1">)[:-</span><span class="s4">1</span><span class="s1">]) </span><span class="s2">if </span><span class="s1">strip_end </span><span class="s2">else </span><span class="s1">name</span>
                <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">np.array(names)[mask].tolist()</span>
            <span class="s1">]</span>
            <span class="s2">return </span><span class="s1">summary_params(</span>
                <span class="s1">res</span><span class="s2">,</span>
                <span class="s1">yname=</span><span class="s2">None,</span>
                <span class="s1">xname=param_names</span><span class="s2">,</span>
                <span class="s1">alpha=alpha</span><span class="s2">,</span>
                <span class="s1">use_t=</span><span class="s2">False,</span>
                <span class="s1">title=title</span><span class="s2">,</span>
            <span class="s1">)</span>

        <span class="s0"># ---------------------------------------------------------------------</span>
        <span class="s0"># Add tables with gamma and det_coef for each endogenous variable:</span>
        <span class="s1">lagged_params_components = []</span>
        <span class="s1">stderr_lagged_params_components = []</span>
        <span class="s1">tvalues_lagged_params_components = []</span>
        <span class="s1">pvalues_lagged_params_components = []</span>
        <span class="s1">conf_int_lagged_params_components = []</span>
        <span class="s2">if </span><span class="s1">self.det_coef.size &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">lagged_params_components.append(self.det_coef.flatten(order=</span><span class="s3">&quot;F&quot;</span><span class="s1">))</span>
            <span class="s1">stderr_lagged_params_components.append(</span>
                <span class="s1">self.stderr_det_coef.flatten(order=</span><span class="s3">&quot;F&quot;</span><span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s1">tvalues_lagged_params_components.append(</span>
                <span class="s1">self.tvalues_det_coef.flatten(order=</span><span class="s3">&quot;F&quot;</span><span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s1">pvalues_lagged_params_components.append(</span>
                <span class="s1">self.pvalues_det_coef.flatten(order=</span><span class="s3">&quot;F&quot;</span><span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s1">conf_int = self.conf_int_det_coef(alpha=alpha)</span>
            <span class="s1">lower = conf_int[</span><span class="s3">&quot;lower&quot;</span><span class="s1">].flatten(order=</span><span class="s3">&quot;F&quot;</span><span class="s1">)</span>
            <span class="s1">upper = conf_int[</span><span class="s3">&quot;upper&quot;</span><span class="s1">].flatten(order=</span><span class="s3">&quot;F&quot;</span><span class="s1">)</span>
            <span class="s1">conf_int_lagged_params_components.append(</span>
                <span class="s1">np.column_stack((lower</span><span class="s2">, </span><span class="s1">upper))</span>
            <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.k_ar - </span><span class="s4">1 </span><span class="s1">&gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">lagged_params_components.append(self.gamma.flatten())</span>
            <span class="s1">stderr_lagged_params_components.append(self.stderr_gamma.flatten())</span>
            <span class="s1">tvalues_lagged_params_components.append(</span>
                <span class="s1">self.tvalues_gamma.flatten()</span>
            <span class="s1">)</span>
            <span class="s1">pvalues_lagged_params_components.append(</span>
                <span class="s1">self.pvalues_gamma.flatten()</span>
            <span class="s1">)</span>
            <span class="s1">conf_int = self.conf_int_gamma(alpha=alpha)</span>
            <span class="s1">lower = conf_int[</span><span class="s3">&quot;lower&quot;</span><span class="s1">].flatten()</span>
            <span class="s1">upper = conf_int[</span><span class="s3">&quot;upper&quot;</span><span class="s1">].flatten()</span>
            <span class="s1">conf_int_lagged_params_components.append(</span>
                <span class="s1">np.column_stack((lower</span><span class="s2">, </span><span class="s1">upper))</span>
            <span class="s1">)</span>

        <span class="s0"># if gamma or det_coef exists, then make a summary-table for them:</span>
        <span class="s2">if </span><span class="s1">len(lagged_params_components) != </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">lagged_params = hstack(lagged_params_components)</span>
            <span class="s1">stderr_lagged_params = hstack(stderr_lagged_params_components)</span>
            <span class="s1">tvalues_lagged_params = hstack(tvalues_lagged_params_components)</span>
            <span class="s1">pvalues_lagged_params = hstack(pvalues_lagged_params_components)</span>
            <span class="s1">conf_int_lagged_params = vstack(conf_int_lagged_params_components)</span>

            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.neqs):</span>
                <span class="s1">masks = []</span>
                <span class="s1">offset = </span><span class="s4">0</span>
                <span class="s0"># 1. Deterministic terms outside cointegration relation</span>
                <span class="s2">if </span><span class="s3">&quot;co&quot; </span><span class="s2">in </span><span class="s1">self.deterministic:</span>
                    <span class="s1">masks.append(offset + np.array(i</span><span class="s2">, </span><span class="s1">ndmin=</span><span class="s4">1</span><span class="s1">))</span>
                    <span class="s1">offset += self.neqs</span>
                <span class="s2">if </span><span class="s1">self.seasons &gt; </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(self.seasons - </span><span class="s4">1</span><span class="s1">):</span>
                        <span class="s1">masks.append(offset + np.array(i</span><span class="s2">, </span><span class="s1">ndmin=</span><span class="s4">1</span><span class="s1">))</span>
                        <span class="s1">offset += self.neqs</span>
                <span class="s2">if </span><span class="s3">&quot;lo&quot; </span><span class="s2">in </span><span class="s1">self.deterministic:</span>
                    <span class="s1">masks.append(offset + np.array(i</span><span class="s2">, </span><span class="s1">ndmin=</span><span class="s4">1</span><span class="s1">))</span>
                    <span class="s1">offset += self.neqs</span>
                <span class="s2">if </span><span class="s1">self.exog </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(self.exog.shape[</span><span class="s4">1</span><span class="s1">]):</span>
                        <span class="s1">masks.append(offset + np.array(i</span><span class="s2">, </span><span class="s1">ndmin=</span><span class="s4">1</span><span class="s1">))</span>
                        <span class="s1">offset += self.neqs</span>
                <span class="s0"># 2. Lagged endogenous terms</span>
                <span class="s2">if </span><span class="s1">self.k_ar - </span><span class="s4">1 </span><span class="s1">&gt; </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s1">start = i * self.neqs * (self.k_ar - </span><span class="s4">1</span><span class="s1">)</span>
                    <span class="s1">end = (i + </span><span class="s4">1</span><span class="s1">) * self.neqs * (self.k_ar - </span><span class="s4">1</span><span class="s1">)</span>
                    <span class="s1">masks.append(offset + np.arange(start</span><span class="s2">, </span><span class="s1">end))</span>
                    <span class="s0"># offset += self.neqs**2 * (self.k_ar-1)</span>

                <span class="s0"># Create the table</span>
                <span class="s1">mask = np.concatenate(masks)</span>
                <span class="s1">eq_name = self.model.endog_names[i]</span>
                <span class="s1">title = (</span>
                    <span class="s3">&quot;Det. terms outside the coint. relation &quot;</span>
                    <span class="s1">+ </span><span class="s3">&quot;&amp; lagged endog. parameters for equation %s&quot; </span><span class="s1">% eq_name</span>
                <span class="s1">)</span>
                <span class="s1">table = make_table(</span>
                    <span class="s1">self</span><span class="s2">,</span>
                    <span class="s1">lagged_params</span><span class="s2">,</span>
                    <span class="s1">stderr_lagged_params</span><span class="s2">,</span>
                    <span class="s1">tvalues_lagged_params</span><span class="s2">,</span>
                    <span class="s1">pvalues_lagged_params</span><span class="s2">,</span>
                    <span class="s1">conf_int_lagged_params</span><span class="s2">,</span>
                    <span class="s1">mask</span><span class="s2">,</span>
                    <span class="s1">self.model._lagged_param_names</span><span class="s2">,</span>
                    <span class="s1">title</span><span class="s2">,</span>
                <span class="s1">)</span>
                <span class="s1">summary.tables.append(table)</span>

        <span class="s0"># ---------------------------------------------------------------------</span>
        <span class="s0"># Loading coefficients (alpha):</span>
        <span class="s1">a = self.alpha.flatten()</span>
        <span class="s1">se_a = self.stderr_alpha.flatten()</span>
        <span class="s1">t_a = self.tvalues_alpha.flatten()</span>
        <span class="s1">p_a = self.pvalues_alpha.flatten()</span>
        <span class="s1">ci_a = self.conf_int_alpha(alpha=alpha)</span>
        <span class="s1">lower = ci_a[</span><span class="s3">&quot;lower&quot;</span><span class="s1">].flatten()</span>
        <span class="s1">upper = ci_a[</span><span class="s3">&quot;upper&quot;</span><span class="s1">].flatten()</span>
        <span class="s1">ci_a = np.column_stack((lower</span><span class="s2">, </span><span class="s1">upper))</span>
        <span class="s1">a_names = self.model._load_coef_param_names</span>
        <span class="s1">alpha_masks = []</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.neqs):</span>
            <span class="s2">if </span><span class="s1">self.coint_rank &gt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">start = i * self.coint_rank</span>
                <span class="s1">end = start + self.coint_rank</span>
                <span class="s1">mask = np.arange(start</span><span class="s2">, </span><span class="s1">end)</span>

            <span class="s0"># Create the table</span>
            <span class="s1">alpha_masks.append(mask)</span>

            <span class="s1">eq_name = self.model.endog_names[i]</span>
            <span class="s1">title = </span><span class="s3">&quot;Loading coefficients (alpha) for equation %s&quot; </span><span class="s1">% eq_name</span>
            <span class="s1">table = make_table(</span>
                <span class="s1">self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">se_a</span><span class="s2">, </span><span class="s1">t_a</span><span class="s2">, </span><span class="s1">p_a</span><span class="s2">, </span><span class="s1">ci_a</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">, </span><span class="s1">a_names</span><span class="s2">, </span><span class="s1">title</span>
            <span class="s1">)</span>
            <span class="s1">summary.tables.append(table)</span>

        <span class="s0"># ---------------------------------------------------------------------</span>
        <span class="s0"># Cointegration matrix/vector (beta) and det. terms inside coint. rel.:</span>
        <span class="s1">coint_components = []</span>
        <span class="s1">stderr_coint_components = []</span>
        <span class="s1">tvalues_coint_components = []</span>
        <span class="s1">pvalues_coint_components = []</span>
        <span class="s1">conf_int_coint_components = []</span>
        <span class="s2">if </span><span class="s1">self.coint_rank &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">coint_components.append(self.beta.T.flatten())</span>
            <span class="s1">stderr_coint_components.append(self.stderr_beta.T.flatten())</span>
            <span class="s1">tvalues_coint_components.append(self.tvalues_beta.T.flatten())</span>
            <span class="s1">pvalues_coint_components.append(self.pvalues_beta.T.flatten())</span>
            <span class="s1">conf_int = self.conf_int_beta(alpha=alpha)</span>
            <span class="s1">lower = conf_int[</span><span class="s3">&quot;lower&quot;</span><span class="s1">].T.flatten()</span>
            <span class="s1">upper = conf_int[</span><span class="s3">&quot;upper&quot;</span><span class="s1">].T.flatten()</span>
            <span class="s1">conf_int_coint_components.append(np.column_stack((lower</span><span class="s2">, </span><span class="s1">upper)))</span>
        <span class="s2">if </span><span class="s1">self.det_coef_coint.size &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">coint_components.append(self.det_coef_coint.flatten())</span>
            <span class="s1">stderr_coint_components.append(</span>
                <span class="s1">self.stderr_det_coef_coint.flatten()</span>
            <span class="s1">)</span>
            <span class="s1">tvalues_coint_components.append(</span>
                <span class="s1">self.tvalues_det_coef_coint.flatten()</span>
            <span class="s1">)</span>
            <span class="s1">pvalues_coint_components.append(</span>
                <span class="s1">self.pvalues_det_coef_coint.flatten()</span>
            <span class="s1">)</span>
            <span class="s1">conf_int = self.conf_int_det_coef_coint(alpha=alpha)</span>
            <span class="s1">lower = conf_int[</span><span class="s3">&quot;lower&quot;</span><span class="s1">].flatten()</span>
            <span class="s1">upper = conf_int[</span><span class="s3">&quot;upper&quot;</span><span class="s1">].flatten()</span>
            <span class="s1">conf_int_coint_components.append(np.column_stack((lower</span><span class="s2">, </span><span class="s1">upper)))</span>
        <span class="s1">coint = hstack(coint_components)</span>
        <span class="s1">stderr_coint = hstack(stderr_coint_components)</span>
        <span class="s1">tvalues_coint = hstack(tvalues_coint_components)</span>
        <span class="s1">pvalues_coint = hstack(pvalues_coint_components)</span>
        <span class="s1">conf_int_coint = vstack(conf_int_coint_components)</span>
        <span class="s1">coint_names = self.model._coint_param_names</span>

        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.coint_rank):</span>
            <span class="s1">masks = []</span>
            <span class="s1">offset = </span><span class="s4">0</span>

            <span class="s0"># 1. Cointegration matrix (beta)</span>
            <span class="s2">if </span><span class="s1">self.coint_rank &gt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">start = i * self.neqs</span>
                <span class="s1">end = start + self.neqs</span>
                <span class="s1">masks.append(offset + np.arange(start</span><span class="s2">, </span><span class="s1">end))</span>
                <span class="s1">offset += self.neqs * self.coint_rank</span>

            <span class="s0"># 2. Deterministic terms inside cointegration relation</span>
            <span class="s2">if </span><span class="s3">&quot;ci&quot; </span><span class="s2">in </span><span class="s1">self.deterministic:</span>
                <span class="s1">masks.append(offset + np.array(i</span><span class="s2">, </span><span class="s1">ndmin=</span><span class="s4">1</span><span class="s1">))</span>
                <span class="s1">offset += self.coint_rank</span>
            <span class="s2">if </span><span class="s3">&quot;li&quot; </span><span class="s2">in </span><span class="s1">self.deterministic:</span>
                <span class="s1">masks.append(offset + np.array(i</span><span class="s2">, </span><span class="s1">ndmin=</span><span class="s4">1</span><span class="s1">))</span>
                <span class="s1">offset += self.coint_rank</span>
            <span class="s2">if </span><span class="s1">self.exog_coint </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(self.exog_coint.shape[</span><span class="s4">1</span><span class="s1">]):</span>
                    <span class="s1">masks.append(offset + np.array(i</span><span class="s2">, </span><span class="s1">ndmin=</span><span class="s4">1</span><span class="s1">))</span>
                    <span class="s1">offset += self.coint_rank</span>

            <span class="s0"># Create the table</span>
            <span class="s1">mask = np.concatenate(masks)</span>
            <span class="s1">title = (</span>
                <span class="s3">&quot;Cointegration relations for &quot;</span>
                <span class="s1">+ </span><span class="s3">&quot;loading-coefficients-column %d&quot; </span><span class="s1">% (i + </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s1">table = make_table(</span>
                <span class="s1">self</span><span class="s2">,</span>
                <span class="s1">coint</span><span class="s2">,</span>
                <span class="s1">stderr_coint</span><span class="s2">,</span>
                <span class="s1">tvalues_coint</span><span class="s2">,</span>
                <span class="s1">pvalues_coint</span><span class="s2">,</span>
                <span class="s1">conf_int_coint</span><span class="s2">,</span>
                <span class="s1">mask</span><span class="s2">,</span>
                <span class="s1">coint_names</span><span class="s2">,</span>
                <span class="s1">title</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s1">summary.tables.append(table)</span>

        <span class="s2">return </span><span class="s1">summary</span>
</pre>
</body>
</html>