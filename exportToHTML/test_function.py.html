<html>
<head>
<title>test_function.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_function.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">builtins</span>
<span class="s0">from </span><span class="s1">io </span><span class="s0">import </span><span class="s1">StringIO</span>
<span class="s0">import </span><span class="s1">re</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">from </span><span class="s1">pandas._libs </span><span class="s0">import </span><span class="s1">lib</span>
<span class="s0">from </span><span class="s1">pandas.errors </span><span class="s0">import </span><span class="s1">UnsupportedFunctionCall</span>

<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">DataFrame</span><span class="s0">,</span>
    <span class="s1">Index</span><span class="s0">,</span>
    <span class="s1">MultiIndex</span><span class="s0">,</span>
    <span class="s1">Series</span><span class="s0">,</span>
    <span class="s1">Timestamp</span><span class="s0">,</span>
    <span class="s1">date_range</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">pandas._testing </span><span class="s0">as </span><span class="s1">tm</span>
<span class="s0">from </span><span class="s1">pandas.tests.groupby </span><span class="s0">import </span><span class="s1">get_groupby_method_args</span>
<span class="s0">from </span><span class="s1">pandas.util </span><span class="s0">import </span><span class="s1">_test_decorators </span><span class="s0">as </span><span class="s1">td</span>


<span class="s1">@pytest.fixture(</span>
    <span class="s1">params=[np.int32</span><span class="s0">, </span><span class="s1">np.int64</span><span class="s0">, </span><span class="s1">np.float32</span><span class="s0">, </span><span class="s1">np.float64</span><span class="s0">, </span><span class="s2">&quot;Int64&quot;</span><span class="s0">, </span><span class="s2">&quot;Float64&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">ids=[</span><span class="s2">&quot;np.int32&quot;</span><span class="s0">, </span><span class="s2">&quot;np.int64&quot;</span><span class="s0">, </span><span class="s2">&quot;np.float32&quot;</span><span class="s0">, </span><span class="s2">&quot;np.float64&quot;</span><span class="s0">, </span><span class="s2">&quot;Int64&quot;</span><span class="s0">, </span><span class="s2">&quot;Float64&quot;</span><span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">dtypes_for_minmax(request):</span>
    <span class="s3">&quot;&quot;&quot; 
    Fixture of dtypes with min and max values used for testing 
    cummin and cummax 
    &quot;&quot;&quot;</span>
    <span class="s1">dtype = request.param</span>

    <span class="s1">np_type = dtype</span>
    <span class="s0">if </span><span class="s1">dtype == </span><span class="s2">&quot;Int64&quot;</span><span class="s1">:</span>
        <span class="s1">np_type = np.int64</span>
    <span class="s0">elif </span><span class="s1">dtype == </span><span class="s2">&quot;Float64&quot;</span><span class="s1">:</span>
        <span class="s1">np_type = np.float64</span>

    <span class="s1">min_val = (</span>
        <span class="s1">np.iinfo(np_type).min</span>
        <span class="s0">if </span><span class="s1">np.dtype(np_type).kind == </span><span class="s2">&quot;i&quot;</span>
        <span class="s0">else </span><span class="s1">np.finfo(np_type).min</span>
    <span class="s1">)</span>
    <span class="s1">max_val = (</span>
        <span class="s1">np.iinfo(np_type).max</span>
        <span class="s0">if </span><span class="s1">np.dtype(np_type).kind == </span><span class="s2">&quot;i&quot;</span>
        <span class="s0">else </span><span class="s1">np.finfo(np_type).max</span>
    <span class="s1">)</span>

    <span class="s0">return </span><span class="s1">(dtype</span><span class="s0">, </span><span class="s1">min_val</span><span class="s0">, </span><span class="s1">max_val)</span>


<span class="s0">def </span><span class="s1">test_intercept_builtin_sum():</span>
    <span class="s1">s = Series([</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">2.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3.0</span><span class="s1">])</span>
    <span class="s1">grouped = s.groupby([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s1">])</span>

    <span class="s1">msg = </span><span class="s2">&quot;using SeriesGroupBy.sum&quot;</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s5"># GH#53425</span>
        <span class="s1">result = grouped.agg(builtins.sum)</span>
    <span class="s1">msg = </span><span class="s2">&quot;using np.sum&quot;</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s5"># GH#53425</span>
        <span class="s1">result2 = grouped.apply(builtins.sum)</span>
    <span class="s1">expected = grouped.sum()</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
    <span class="s1">tm.assert_series_equal(result2</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;f&quot;</span><span class="s0">, </span><span class="s1">[max</span><span class="s0">, </span><span class="s1">min</span><span class="s0">, </span><span class="s1">sum])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;keys&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;jim&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;jim&quot;</span><span class="s0">, </span><span class="s2">&quot;joe&quot;</span><span class="s1">]])  </span><span class="s5"># Single key  # Multi-key</span>
<span class="s0">def </span><span class="s1">test_builtins_apply(keys</span><span class="s0">, </span><span class="s1">f):</span>
    <span class="s5"># see gh-8155</span>
    <span class="s1">rs = np.random.default_rng(</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">df = DataFrame(rs.integers(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">7</span><span class="s0">, </span><span class="s1">(</span><span class="s4">10</span><span class="s0">, </span><span class="s4">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;jim&quot;</span><span class="s0">, </span><span class="s2">&quot;joe&quot;</span><span class="s1">])</span>
    <span class="s1">df[</span><span class="s2">&quot;jolie&quot;</span><span class="s1">] = rs.standard_normal(</span><span class="s4">10</span><span class="s1">)</span>

    <span class="s1">gb = df.groupby(keys)</span>

    <span class="s1">fname = f.__name__</span>

    <span class="s1">warn = </span><span class="s0">None if </span><span class="s1">f </span><span class="s0">is not </span><span class="s1">sum </span><span class="s0">else </span><span class="s1">FutureWarning</span>
    <span class="s1">msg = </span><span class="s2">&quot;The behavior of DataFrame.sum with axis=None is deprecated&quot;</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(</span>
        <span class="s1">warn</span><span class="s0">, </span><span class="s1">match=msg</span><span class="s0">, </span><span class="s1">check_stacklevel=</span><span class="s0">False, </span><span class="s1">raise_on_extra_warnings=</span><span class="s0">False</span>
    <span class="s1">):</span>
        <span class="s5"># Also warns on deprecation GH#53425</span>
        <span class="s1">result = gb.apply(f)</span>
    <span class="s1">ngroups = len(df.drop_duplicates(subset=keys))</span>

    <span class="s1">assert_msg = </span><span class="s2">f&quot;invalid frame shape: </span><span class="s0">{</span><span class="s1">result.shape</span><span class="s0">} </span><span class="s2">(expected (</span><span class="s0">{</span><span class="s1">ngroups</span><span class="s0">}</span><span class="s2">, 3))&quot;</span>
    <span class="s0">assert </span><span class="s1">result.shape == (ngroups</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">assert_msg</span>

    <span class="s1">npfunc = </span><span class="s0">lambda </span><span class="s1">x: getattr(np</span><span class="s0">, </span><span class="s1">fname)(x</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)  </span><span class="s5"># numpy's equivalent function</span>
    <span class="s1">expected = gb.apply(npfunc)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">expected2 = gb.apply(</span><span class="s0">lambda </span><span class="s1">x: npfunc(x))</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected2)</span>

    <span class="s0">if </span><span class="s1">f != sum:</span>
        <span class="s1">expected = gb.agg(fname).reset_index()</span>
        <span class="s1">expected.set_index(keys</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True, </span><span class="s1">drop=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_dtype=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">tm.assert_series_equal(getattr(result</span><span class="s0">, </span><span class="s1">fname)(axis=</span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">getattr(df</span><span class="s0">, </span><span class="s1">fname)(axis=</span><span class="s4">0</span><span class="s1">))</span>


<span class="s0">class </span><span class="s1">TestNumericOnly:</span>
    <span class="s5"># make sure that we are passing thru kwargs to our agg functions</span>

    <span class="s1">@pytest.fixture</span>
    <span class="s0">def </span><span class="s1">df(self):</span>
        <span class="s5"># GH3668</span>
        <span class="s5"># GH5724</span>
        <span class="s1">df = DataFrame(</span>
            <span class="s1">{</span>
                <span class="s2">&quot;group&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;int&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;float&quot;</span><span class="s1">: [</span><span class="s4">4.0</span><span class="s0">, </span><span class="s4">5.0</span><span class="s0">, </span><span class="s4">6.0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;string&quot;</span><span class="s1">: list(</span><span class="s2">&quot;abc&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s2">&quot;category_string&quot;</span><span class="s1">: Series(list(</span><span class="s2">&quot;abc&quot;</span><span class="s1">)).astype(</span><span class="s2">&quot;category&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s2">&quot;category_int&quot;</span><span class="s1">: [</span><span class="s4">7</span><span class="s0">, </span><span class="s4">8</span><span class="s0">, </span><span class="s4">9</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;datetime&quot;</span><span class="s1">: date_range(</span><span class="s2">&quot;20130101&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s2">&quot;datetimetz&quot;</span><span class="s1">: date_range(</span><span class="s2">&quot;20130101&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;US/Eastern&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s2">&quot;timedelta&quot;</span><span class="s1">: pd.timedelta_range(</span><span class="s2">&quot;1 s&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;s&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">columns=[</span>
                <span class="s2">&quot;group&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;int&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;float&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;string&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;category_string&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;category_int&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;datetime&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;datetimetz&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;timedelta&quot;</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">df</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;method&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;mean&quot;</span><span class="s0">, </span><span class="s2">&quot;median&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_averages(self</span><span class="s0">, </span><span class="s1">df</span><span class="s0">, </span><span class="s1">method):</span>
        <span class="s5"># mean / median</span>
        <span class="s1">expected_columns_numeric = Index([</span><span class="s2">&quot;int&quot;</span><span class="s0">, </span><span class="s2">&quot;float&quot;</span><span class="s0">, </span><span class="s2">&quot;category_int&quot;</span><span class="s1">])</span>

        <span class="s1">gb = df.groupby(</span><span class="s2">&quot;group&quot;</span><span class="s1">)</span>
        <span class="s1">expected = DataFrame(</span>
            <span class="s1">{</span>
                <span class="s2">&quot;category_int&quot;</span><span class="s1">: [</span><span class="s4">7.5</span><span class="s0">, </span><span class="s4">9</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;float&quot;</span><span class="s1">: [</span><span class="s4">4.5</span><span class="s0">, </span><span class="s4">6.0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;timedelta&quot;</span><span class="s1">: [pd.Timedelta(</span><span class="s2">&quot;1.5s&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pd.Timedelta(</span><span class="s2">&quot;3s&quot;</span><span class="s1">)]</span><span class="s0">,</span>
                <span class="s2">&quot;int&quot;</span><span class="s1">: [</span><span class="s4">1.5</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;datetime&quot;</span><span class="s1">: [</span>
                    <span class="s1">Timestamp(</span><span class="s2">&quot;2013-01-01 12:00:00&quot;</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">Timestamp(</span><span class="s2">&quot;2013-01-03 00:00:00&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;datetimetz&quot;</span><span class="s1">: [</span>
                    <span class="s1">Timestamp(</span><span class="s2">&quot;2013-01-01 12:00:00&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;US/Eastern&quot;</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">Timestamp(</span><span class="s2">&quot;2013-01-03 00:00:00&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;US/Eastern&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">]</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">index=Index([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;group&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">columns=[</span>
                <span class="s2">&quot;int&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;float&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;category_int&quot;</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">result = getattr(gb</span><span class="s0">, </span><span class="s1">method)(numeric_only=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(result.reindex_like(expected)</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">expected_columns = expected.columns</span>

        <span class="s1">self._check(df</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">expected_columns</span><span class="s0">, </span><span class="s1">expected_columns_numeric)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;method&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;min&quot;</span><span class="s0">, </span><span class="s2">&quot;max&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_extrema(self</span><span class="s0">, </span><span class="s1">df</span><span class="s0">, </span><span class="s1">method):</span>
        <span class="s5"># TODO: min, max *should* handle</span>
        <span class="s5"># categorical (ordered) dtype</span>

        <span class="s1">expected_columns = Index(</span>
            <span class="s1">[</span>
                <span class="s2">&quot;int&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;float&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;string&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;category_int&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;datetime&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;datetimetz&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;timedelta&quot;</span><span class="s0">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">expected_columns_numeric = expected_columns</span>

        <span class="s1">self._check(df</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">expected_columns</span><span class="s0">, </span><span class="s1">expected_columns_numeric)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;method&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;first&quot;</span><span class="s0">, </span><span class="s2">&quot;last&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_first_last(self</span><span class="s0">, </span><span class="s1">df</span><span class="s0">, </span><span class="s1">method):</span>
        <span class="s1">expected_columns = Index(</span>
            <span class="s1">[</span>
                <span class="s2">&quot;int&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;float&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;string&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;category_string&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;category_int&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;datetime&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;datetimetz&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;timedelta&quot;</span><span class="s0">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">expected_columns_numeric = expected_columns</span>

        <span class="s1">self._check(df</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">expected_columns</span><span class="s0">, </span><span class="s1">expected_columns_numeric)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;method&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;sum&quot;</span><span class="s0">, </span><span class="s2">&quot;cumsum&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_sum_cumsum(self</span><span class="s0">, </span><span class="s1">df</span><span class="s0">, </span><span class="s1">method):</span>
        <span class="s1">expected_columns_numeric = Index([</span><span class="s2">&quot;int&quot;</span><span class="s0">, </span><span class="s2">&quot;float&quot;</span><span class="s0">, </span><span class="s2">&quot;category_int&quot;</span><span class="s1">])</span>
        <span class="s1">expected_columns = Index(</span>
            <span class="s1">[</span><span class="s2">&quot;int&quot;</span><span class="s0">, </span><span class="s2">&quot;float&quot;</span><span class="s0">, </span><span class="s2">&quot;string&quot;</span><span class="s0">, </span><span class="s2">&quot;category_int&quot;</span><span class="s0">, </span><span class="s2">&quot;timedelta&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">method == </span><span class="s2">&quot;cumsum&quot;</span><span class="s1">:</span>
            <span class="s5"># cumsum loses string</span>
            <span class="s1">expected_columns = Index([</span><span class="s2">&quot;int&quot;</span><span class="s0">, </span><span class="s2">&quot;float&quot;</span><span class="s0">, </span><span class="s2">&quot;category_int&quot;</span><span class="s0">, </span><span class="s2">&quot;timedelta&quot;</span><span class="s1">])</span>

        <span class="s1">self._check(df</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">expected_columns</span><span class="s0">, </span><span class="s1">expected_columns_numeric)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;method&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;prod&quot;</span><span class="s0">, </span><span class="s2">&quot;cumprod&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_prod_cumprod(self</span><span class="s0">, </span><span class="s1">df</span><span class="s0">, </span><span class="s1">method):</span>
        <span class="s1">expected_columns = Index([</span><span class="s2">&quot;int&quot;</span><span class="s0">, </span><span class="s2">&quot;float&quot;</span><span class="s0">, </span><span class="s2">&quot;category_int&quot;</span><span class="s1">])</span>
        <span class="s1">expected_columns_numeric = expected_columns</span>

        <span class="s1">self._check(df</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">expected_columns</span><span class="s0">, </span><span class="s1">expected_columns_numeric)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;method&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;cummin&quot;</span><span class="s0">, </span><span class="s2">&quot;cummax&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_cummin_cummax(self</span><span class="s0">, </span><span class="s1">df</span><span class="s0">, </span><span class="s1">method):</span>
        <span class="s5"># like min, max, but don't include strings</span>
        <span class="s1">expected_columns = Index(</span>
            <span class="s1">[</span><span class="s2">&quot;int&quot;</span><span class="s0">, </span><span class="s2">&quot;float&quot;</span><span class="s0">, </span><span class="s2">&quot;category_int&quot;</span><span class="s0">, </span><span class="s2">&quot;datetime&quot;</span><span class="s0">, </span><span class="s2">&quot;datetimetz&quot;</span><span class="s0">, </span><span class="s2">&quot;timedelta&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>

        <span class="s5"># GH#15561: numeric_only=False set by default like min/max</span>
        <span class="s1">expected_columns_numeric = expected_columns</span>

        <span class="s1">self._check(df</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">expected_columns</span><span class="s0">, </span><span class="s1">expected_columns_numeric)</span>

    <span class="s0">def </span><span class="s1">_check(self</span><span class="s0">, </span><span class="s1">df</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">expected_columns</span><span class="s0">, </span><span class="s1">expected_columns_numeric):</span>
        <span class="s1">gb = df.groupby(</span><span class="s2">&quot;group&quot;</span><span class="s1">)</span>

        <span class="s5"># object dtypes for transformations are not implemented in Cython and</span>
        <span class="s5"># have no Python fallback</span>
        <span class="s1">exception = NotImplementedError </span><span class="s0">if </span><span class="s1">method.startswith(</span><span class="s2">&quot;cum&quot;</span><span class="s1">) </span><span class="s0">else </span><span class="s1">TypeError</span>

        <span class="s0">if </span><span class="s1">method </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;min&quot;</span><span class="s0">, </span><span class="s2">&quot;max&quot;</span><span class="s0">, </span><span class="s2">&quot;cummin&quot;</span><span class="s0">, </span><span class="s2">&quot;cummax&quot;</span><span class="s0">, </span><span class="s2">&quot;cumsum&quot;</span><span class="s0">, </span><span class="s2">&quot;cumprod&quot;</span><span class="s1">):</span>
            <span class="s5"># The methods default to numeric_only=False and raise TypeError</span>
            <span class="s1">msg = </span><span class="s2">&quot;|&quot;</span><span class="s1">.join(</span>
                <span class="s1">[</span>
                    <span class="s2">&quot;Categorical is not ordered&quot;</span><span class="s0">,</span>
                    <span class="s2">f&quot;Cannot perform </span><span class="s0">{</span><span class="s1">method</span><span class="s0">} </span><span class="s2">with non-ordered Categorical&quot;</span><span class="s0">,</span>
                    <span class="s1">re.escape(</span><span class="s2">f&quot;agg function failed [how-&gt;</span><span class="s0">{</span><span class="s1">method</span><span class="s0">}</span><span class="s2">,dtype-&gt;object]&quot;</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s5"># cumsum/cummin/cummax/cumprod</span>
                    <span class="s2">&quot;function is not implemented for this dtype&quot;</span><span class="s0">,</span>
                <span class="s1">]</span>
            <span class="s1">)</span>
            <span class="s0">with </span><span class="s1">pytest.raises(exception</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">getattr(gb</span><span class="s0">, </span><span class="s1">method)()</span>
        <span class="s0">elif </span><span class="s1">method </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;sum&quot;</span><span class="s0">, </span><span class="s2">&quot;mean&quot;</span><span class="s0">, </span><span class="s2">&quot;median&quot;</span><span class="s0">, </span><span class="s2">&quot;prod&quot;</span><span class="s1">):</span>
            <span class="s1">msg = </span><span class="s2">&quot;|&quot;</span><span class="s1">.join(</span>
                <span class="s1">[</span>
                    <span class="s2">&quot;category type does not support sum operations&quot;</span><span class="s0">,</span>
                    <span class="s1">re.escape(</span><span class="s2">f&quot;agg function failed [how-&gt;</span><span class="s0">{</span><span class="s1">method</span><span class="s0">}</span><span class="s2">,dtype-&gt;object]&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">]</span>
            <span class="s1">)</span>
            <span class="s0">with </span><span class="s1">pytest.raises(exception</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">getattr(gb</span><span class="s0">, </span><span class="s1">method)()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">result = getattr(gb</span><span class="s0">, </span><span class="s1">method)()</span>
            <span class="s1">tm.assert_index_equal(result.columns</span><span class="s0">, </span><span class="s1">expected_columns_numeric)</span>

        <span class="s0">if </span><span class="s1">method </span><span class="s0">not in </span><span class="s1">(</span><span class="s2">&quot;first&quot;</span><span class="s0">, </span><span class="s2">&quot;last&quot;</span><span class="s1">):</span>
            <span class="s1">msg = </span><span class="s2">&quot;|&quot;</span><span class="s1">.join(</span>
                <span class="s1">[</span>
                    <span class="s2">&quot;Categorical is not ordered&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;category type does not support&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;function is not implemented for this dtype&quot;</span><span class="s0">,</span>
                    <span class="s2">f&quot;Cannot perform </span><span class="s0">{</span><span class="s1">method</span><span class="s0">} </span><span class="s2">with non-ordered Categorical&quot;</span><span class="s0">,</span>
                    <span class="s1">re.escape(</span><span class="s2">f&quot;agg function failed [how-&gt;</span><span class="s0">{</span><span class="s1">method</span><span class="s0">}</span><span class="s2">,dtype-&gt;object]&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">]</span>
            <span class="s1">)</span>
            <span class="s0">with </span><span class="s1">pytest.raises(exception</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">getattr(gb</span><span class="s0">, </span><span class="s1">method)(numeric_only=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">result = getattr(gb</span><span class="s0">, </span><span class="s1">method)(numeric_only=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">tm.assert_index_equal(result.columns</span><span class="s0">, </span><span class="s1">expected_columns)</span>


<span class="s0">class </span><span class="s1">TestGroupByNonCythonPaths:</span>
    <span class="s5"># GH#5610 non-cython calls should not include the grouper</span>
    <span class="s5"># Tests for code not expected to go through cython paths.</span>

    <span class="s1">@pytest.fixture</span>
    <span class="s0">def </span><span class="s1">df(self):</span>
        <span class="s1">df = DataFrame(</span>
            <span class="s1">[[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s2">&quot;foo&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s2">&quot;bar&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">3</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s2">&quot;baz&quot;</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">columns=[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;C&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">df</span>

    <span class="s1">@pytest.fixture</span>
    <span class="s0">def </span><span class="s1">gb(self</span><span class="s0">, </span><span class="s1">df):</span>
        <span class="s1">gb = df.groupby(</span><span class="s2">&quot;A&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">gb</span>

    <span class="s1">@pytest.fixture</span>
    <span class="s0">def </span><span class="s1">gni(self</span><span class="s0">, </span><span class="s1">df):</span>
        <span class="s1">gni = df.groupby(</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s1">as_index=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">gni</span>

    <span class="s0">def </span><span class="s1">test_describe(self</span><span class="s0">, </span><span class="s1">df</span><span class="s0">, </span><span class="s1">gb</span><span class="s0">, </span><span class="s1">gni):</span>
        <span class="s5"># describe</span>
        <span class="s1">expected_index = Index([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;A&quot;</span><span class="s1">)</span>
        <span class="s1">expected_col = MultiIndex(</span>
            <span class="s1">levels=[[</span><span class="s2">&quot;B&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;count&quot;</span><span class="s0">, </span><span class="s2">&quot;mean&quot;</span><span class="s0">, </span><span class="s2">&quot;std&quot;</span><span class="s0">, </span><span class="s2">&quot;min&quot;</span><span class="s0">, </span><span class="s2">&quot;25%&quot;</span><span class="s0">, </span><span class="s2">&quot;50%&quot;</span><span class="s0">, </span><span class="s2">&quot;75%&quot;</span><span class="s0">, </span><span class="s2">&quot;max&quot;</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">codes=[[</span><span class="s4">0</span><span class="s1">] * </span><span class="s4">8</span><span class="s0">, </span><span class="s1">list(range(</span><span class="s4">8</span><span class="s1">))]</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">expected = DataFrame(</span>
            <span class="s1">[</span>
                <span class="s1">[</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">2.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">2.0</span><span class="s0">, </span><span class="s4">2.0</span><span class="s0">, </span><span class="s4">2.0</span><span class="s0">, </span><span class="s4">2.0</span><span class="s0">, </span><span class="s4">2.0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s4">0.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
            <span class="s1">index=expected_index</span><span class="s0">,</span>
            <span class="s1">columns=expected_col</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">result = gb.describe()</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">expected = expected.reset_index()</span>
        <span class="s1">result = gni.describe()</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_cython_api2():</span>
    <span class="s5"># this takes the fast apply path</span>

    <span class="s5"># cumsum (GH5614)</span>
    <span class="s1">df = DataFrame([[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">9</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">9</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;C&quot;</span><span class="s1">])</span>
    <span class="s1">expected = DataFrame([[</span><span class="s4">2</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s4">9</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">4</span><span class="s0">, </span><span class="s4">9</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;C&quot;</span><span class="s1">])</span>
    <span class="s1">result = df.groupby(</span><span class="s2">&quot;A&quot;</span><span class="s1">).cumsum()</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s5"># GH 5755 - cumsum is a transformer and should ignore as_index</span>
    <span class="s1">result = df.groupby(</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s1">as_index=</span><span class="s0">False</span><span class="s1">).cumsum()</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s5"># GH 13994</span>
    <span class="s1">msg = </span><span class="s2">&quot;DataFrameGroupBy.cumsum with axis=1 is deprecated&quot;</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">result = df.groupby(</span><span class="s2">&quot;A&quot;</span><span class="s1">).cumsum(axis=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">expected = df.cumsum(axis=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">msg = </span><span class="s2">&quot;DataFrameGroupBy.cumprod with axis=1 is deprecated&quot;</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">result = df.groupby(</span><span class="s2">&quot;A&quot;</span><span class="s1">).cumprod(axis=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">expected = df.cumprod(axis=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_cython_median():</span>
    <span class="s1">arr = np.random.default_rng(</span><span class="s4">2</span><span class="s1">).standard_normal(</span><span class="s4">1000</span><span class="s1">)</span>
    <span class="s1">arr[::</span><span class="s4">2</span><span class="s1">] = np.nan</span>
    <span class="s1">df = DataFrame(arr)</span>

    <span class="s1">labels = np.random.default_rng(</span><span class="s4">2</span><span class="s1">).integers(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">50</span><span class="s0">, </span><span class="s1">size=</span><span class="s4">1000</span><span class="s1">).astype(float)</span>
    <span class="s1">labels[::</span><span class="s4">17</span><span class="s1">] = np.nan</span>

    <span class="s1">result = df.groupby(labels).median()</span>
    <span class="s1">msg = </span><span class="s2">&quot;using DataFrameGroupBy.median&quot;</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">exp = df.groupby(labels).agg(np.nanmedian)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">exp)</span>

    <span class="s1">df = DataFrame(np.random.default_rng(</span><span class="s4">2</span><span class="s1">).standard_normal((</span><span class="s4">1000</span><span class="s0">, </span><span class="s4">5</span><span class="s1">)))</span>
    <span class="s1">msg = </span><span class="s2">&quot;using DataFrameGroupBy.median&quot;</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">rs = df.groupby(labels).agg(np.median)</span>
    <span class="s1">xp = df.groupby(labels).median()</span>
    <span class="s1">tm.assert_frame_equal(rs</span><span class="s0">, </span><span class="s1">xp)</span>


<span class="s0">def </span><span class="s1">test_median_empty_bins(observed):</span>
    <span class="s1">df = DataFrame(np.random.default_rng(</span><span class="s4">2</span><span class="s1">).integers(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">44</span><span class="s0">, </span><span class="s4">500</span><span class="s1">))</span>

    <span class="s1">grps = range(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">55</span><span class="s0">, </span><span class="s4">5</span><span class="s1">)</span>
    <span class="s1">bins = pd.cut(df[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">grps)</span>

    <span class="s1">result = df.groupby(bins</span><span class="s0">, </span><span class="s1">observed=observed).median()</span>
    <span class="s1">expected = df.groupby(bins</span><span class="s0">, </span><span class="s1">observed=observed).agg(</span><span class="s0">lambda </span><span class="s1">x: x.median())</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;int8&quot;</span><span class="s0">, </span><span class="s2">&quot;int16&quot;</span><span class="s0">, </span><span class="s2">&quot;int32&quot;</span><span class="s0">, </span><span class="s2">&quot;int64&quot;</span><span class="s0">, </span><span class="s2">&quot;float32&quot;</span><span class="s0">, </span><span class="s2">&quot;float64&quot;</span><span class="s0">, </span><span class="s2">&quot;uint64&quot;</span><span class="s1">]</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;method,data&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s2">&quot;first&quot;</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;df&quot;</span><span class="s1">: [{</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s4">2</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s4">3</span><span class="s1">}]})</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;last&quot;</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;df&quot;</span><span class="s1">: [{</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s4">2</span><span class="s1">}</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s4">2</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s4">4</span><span class="s1">}]})</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;min&quot;</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;df&quot;</span><span class="s1">: [{</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s4">2</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s4">3</span><span class="s1">}]})</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;max&quot;</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;df&quot;</span><span class="s1">: [{</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s4">2</span><span class="s1">}</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s4">2</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s4">4</span><span class="s1">}]})</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;count&quot;</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;df&quot;</span><span class="s1">: [{</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s4">2</span><span class="s1">}</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s4">2</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s4">2</span><span class="s1">}]</span><span class="s0">, </span><span class="s2">&quot;out_type&quot;</span><span class="s1">: </span><span class="s2">&quot;int64&quot;</span><span class="s1">})</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_groupby_non_arithmetic_agg_types(dtype</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">data):</span>
    <span class="s5"># GH9311, GH6620</span>
    <span class="s1">df = DataFrame(</span>
        <span class="s1">[{</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s4">2</span><span class="s1">}</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s4">2</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s4">3</span><span class="s1">}</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s4">2</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s4">4</span><span class="s1">}]</span>
    <span class="s1">)</span>

    <span class="s1">df[</span><span class="s2">&quot;b&quot;</span><span class="s1">] = df.b.astype(dtype)</span>

    <span class="s0">if </span><span class="s2">&quot;args&quot; </span><span class="s0">not in </span><span class="s1">data:</span>
        <span class="s1">data[</span><span class="s2">&quot;args&quot;</span><span class="s1">] = []</span>

    <span class="s0">if </span><span class="s2">&quot;out_type&quot; </span><span class="s0">in </span><span class="s1">data:</span>
        <span class="s1">out_type = data[</span><span class="s2">&quot;out_type&quot;</span><span class="s1">]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">out_type = dtype</span>

    <span class="s1">exp = data[</span><span class="s2">&quot;df&quot;</span><span class="s1">]</span>
    <span class="s1">df_out = DataFrame(exp)</span>

    <span class="s1">df_out[</span><span class="s2">&quot;b&quot;</span><span class="s1">] = df_out.b.astype(out_type)</span>
    <span class="s1">df_out.set_index(</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s1">grpd = df.groupby(</span><span class="s2">&quot;a&quot;</span><span class="s1">)</span>
    <span class="s1">t = getattr(grpd</span><span class="s0">, </span><span class="s1">method)(*data[</span><span class="s2">&quot;args&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_frame_equal(t</span><span class="s0">, </span><span class="s1">df_out)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;i&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span>
            <span class="s1">Timestamp(</span><span class="s2">&quot;2011-01-15 12:50:28.502376&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">Timestamp(</span><span class="s2">&quot;2011-01-20 12:50:28.593448&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s4">24650000000000001</span><span class="s0">, </span><span class="s4">24650000000000002</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_groupby_non_arithmetic_agg_int_like_precision(i):</span>
    <span class="s5"># see gh-6620, gh-9311</span>
    <span class="s1">df = DataFrame([{</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: i[</span><span class="s4">0</span><span class="s1">]}</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: i[</span><span class="s4">1</span><span class="s1">]}])</span>

    <span class="s1">grp_exp = {</span>
        <span class="s2">&quot;first&quot;</span><span class="s1">: {</span><span class="s2">&quot;expected&quot;</span><span class="s1">: i[</span><span class="s4">0</span><span class="s1">]}</span><span class="s0">,</span>
        <span class="s2">&quot;last&quot;</span><span class="s1">: {</span><span class="s2">&quot;expected&quot;</span><span class="s1">: i[</span><span class="s4">1</span><span class="s1">]}</span><span class="s0">,</span>
        <span class="s2">&quot;min&quot;</span><span class="s1">: {</span><span class="s2">&quot;expected&quot;</span><span class="s1">: i[</span><span class="s4">0</span><span class="s1">]}</span><span class="s0">,</span>
        <span class="s2">&quot;max&quot;</span><span class="s1">: {</span><span class="s2">&quot;expected&quot;</span><span class="s1">: i[</span><span class="s4">1</span><span class="s1">]}</span><span class="s0">,</span>
        <span class="s2">&quot;nth&quot;</span><span class="s1">: {</span><span class="s2">&quot;expected&quot;</span><span class="s1">: i[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;args&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s1">]}</span><span class="s0">,</span>
        <span class="s2">&quot;count&quot;</span><span class="s1">: {</span><span class="s2">&quot;expected&quot;</span><span class="s1">: </span><span class="s4">2</span><span class="s1">}</span><span class="s0">,</span>
    <span class="s1">}</span>

    <span class="s0">for </span><span class="s1">method</span><span class="s0">, </span><span class="s1">data </span><span class="s0">in </span><span class="s1">grp_exp.items():</span>
        <span class="s0">if </span><span class="s2">&quot;args&quot; </span><span class="s0">not in </span><span class="s1">data:</span>
            <span class="s1">data[</span><span class="s2">&quot;args&quot;</span><span class="s1">] = []</span>

        <span class="s1">grouped = df.groupby(</span><span class="s2">&quot;a&quot;</span><span class="s1">)</span>
        <span class="s1">res = getattr(grouped</span><span class="s0">, </span><span class="s1">method)(*data[</span><span class="s2">&quot;args&quot;</span><span class="s1">])</span>

        <span class="s0">assert </span><span class="s1">res.iloc[</span><span class="s4">0</span><span class="s1">].b == data[</span><span class="s2">&quot;expected&quot;</span><span class="s1">]</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;func, values&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s2">&quot;idxmin&quot;</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;c_int&quot;</span><span class="s1">: [</span><span class="s4">0</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;c_float&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;c_date&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]})</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;idxmax&quot;</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;c_int&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;c_float&quot;</span><span class="s1">: [</span><span class="s4">0</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;c_date&quot;</span><span class="s1">: [</span><span class="s4">0</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]})</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;numeric_only&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_idxmin_idxmax_returns_int_types(func</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">numeric_only):</span>
    <span class="s5"># GH 25444</span>
    <span class="s1">df = DataFrame(</span>
        <span class="s1">{</span>
            <span class="s2">&quot;name&quot;</span><span class="s1">: [</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;c_int&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;c_float&quot;</span><span class="s1">: [</span><span class="s4">4.02</span><span class="s0">, </span><span class="s4">3.03</span><span class="s0">, </span><span class="s4">2.04</span><span class="s0">, </span><span class="s4">1.05</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;c_date&quot;</span><span class="s1">: [</span><span class="s2">&quot;2019&quot;</span><span class="s0">, </span><span class="s2">&quot;2018&quot;</span><span class="s0">, </span><span class="s2">&quot;2016&quot;</span><span class="s0">, </span><span class="s2">&quot;2017&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">df[</span><span class="s2">&quot;c_date&quot;</span><span class="s1">] = pd.to_datetime(df[</span><span class="s2">&quot;c_date&quot;</span><span class="s1">])</span>
    <span class="s1">df[</span><span class="s2">&quot;c_date_tz&quot;</span><span class="s1">] = df[</span><span class="s2">&quot;c_date&quot;</span><span class="s1">].dt.tz_localize(</span><span class="s2">&quot;US/Pacific&quot;</span><span class="s1">)</span>
    <span class="s1">df[</span><span class="s2">&quot;c_timedelta&quot;</span><span class="s1">] = df[</span><span class="s2">&quot;c_date&quot;</span><span class="s1">] - df[</span><span class="s2">&quot;c_date&quot;</span><span class="s1">].iloc[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">df[</span><span class="s2">&quot;c_period&quot;</span><span class="s1">] = df[</span><span class="s2">&quot;c_date&quot;</span><span class="s1">].dt.to_period(</span><span class="s2">&quot;W&quot;</span><span class="s1">)</span>
    <span class="s1">df[</span><span class="s2">&quot;c_Integer&quot;</span><span class="s1">] = df[</span><span class="s2">&quot;c_int&quot;</span><span class="s1">].astype(</span><span class="s2">&quot;Int64&quot;</span><span class="s1">)</span>
    <span class="s1">df[</span><span class="s2">&quot;c_Floating&quot;</span><span class="s1">] = df[</span><span class="s2">&quot;c_float&quot;</span><span class="s1">].astype(</span><span class="s2">&quot;Float64&quot;</span><span class="s1">)</span>

    <span class="s1">result = getattr(df.groupby(</span><span class="s2">&quot;name&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">func)(numeric_only=numeric_only)</span>

    <span class="s1">expected = DataFrame(values</span><span class="s0">, </span><span class="s1">index=Index([</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;name&quot;</span><span class="s1">))</span>
    <span class="s0">if </span><span class="s1">numeric_only:</span>
        <span class="s1">expected = expected.drop(columns=[</span><span class="s2">&quot;c_date&quot;</span><span class="s1">])</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">expected[</span><span class="s2">&quot;c_date_tz&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;c_date&quot;</span><span class="s1">]</span>
        <span class="s1">expected[</span><span class="s2">&quot;c_timedelta&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;c_date&quot;</span><span class="s1">]</span>
        <span class="s1">expected[</span><span class="s2">&quot;c_period&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;c_date&quot;</span><span class="s1">]</span>
    <span class="s1">expected[</span><span class="s2">&quot;c_Integer&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;c_int&quot;</span><span class="s1">]</span>
    <span class="s1">expected[</span><span class="s2">&quot;c_Floating&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;c_float&quot;</span><span class="s1">]</span>

    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_idxmin_idxmax_axis1():</span>
    <span class="s1">df = DataFrame(</span>
        <span class="s1">np.random.default_rng(</span><span class="s4">2</span><span class="s1">).standard_normal((</span><span class="s4">10</span><span class="s0">, </span><span class="s4">4</span><span class="s1">))</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;C&quot;</span><span class="s0">, </span><span class="s2">&quot;D&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">df[</span><span class="s2">&quot;A&quot;</span><span class="s1">] = [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s1">]</span>

    <span class="s1">gb = df.groupby(</span><span class="s2">&quot;A&quot;</span><span class="s1">)</span>

    <span class="s1">warn_msg = </span><span class="s2">&quot;DataFrameGroupBy.idxmax with axis=1 is deprecated&quot;</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=warn_msg):</span>
        <span class="s1">res = gb.idxmax(axis=</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s1">alt = df.iloc[:</span><span class="s0">, </span><span class="s4">1</span><span class="s1">:].idxmax(axis=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">indexer = res.index.get_level_values(</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s1">tm.assert_series_equal(alt[indexer]</span><span class="s0">, </span><span class="s1">res.droplevel(</span><span class="s2">&quot;A&quot;</span><span class="s1">))</span>

    <span class="s1">df[</span><span class="s2">&quot;E&quot;</span><span class="s1">] = date_range(</span><span class="s2">&quot;2016-01-01&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">)</span>
    <span class="s1">gb2 = df.groupby(</span><span class="s2">&quot;A&quot;</span><span class="s1">)</span>

    <span class="s1">msg = </span><span class="s2">&quot;'&gt;' not supported between instances of 'Timestamp' and 'float'&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=warn_msg):</span>
            <span class="s1">gb2.idxmax(axis=</span><span class="s4">1</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;numeric_only&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False, None</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_axis1_numeric_only(request</span><span class="s0">, </span><span class="s1">groupby_func</span><span class="s0">, </span><span class="s1">numeric_only):</span>
    <span class="s0">if </span><span class="s1">groupby_func </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;idxmax&quot;</span><span class="s0">, </span><span class="s2">&quot;idxmin&quot;</span><span class="s1">):</span>
        <span class="s1">pytest.skip(</span><span class="s2">&quot;idxmax and idx_min tested in test_idxmin_idxmax_axis1&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">groupby_func </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;corrwith&quot;</span><span class="s0">, </span><span class="s2">&quot;skew&quot;</span><span class="s1">):</span>
        <span class="s1">msg = </span><span class="s2">&quot;GH#47723 groupby.corrwith and skew do not correctly implement axis=1&quot;</span>
        <span class="s1">request.node.add_marker(pytest.mark.xfail(reason=msg))</span>

    <span class="s1">df = DataFrame(</span>
        <span class="s1">np.random.default_rng(</span><span class="s4">2</span><span class="s1">).standard_normal((</span><span class="s4">10</span><span class="s0">, </span><span class="s4">4</span><span class="s1">))</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;C&quot;</span><span class="s0">, </span><span class="s2">&quot;D&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">df[</span><span class="s2">&quot;E&quot;</span><span class="s1">] = </span><span class="s2">&quot;x&quot;</span>
    <span class="s1">groups = [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s1">]</span>
    <span class="s1">gb = df.groupby(groups)</span>
    <span class="s1">method = getattr(gb</span><span class="s0">, </span><span class="s1">groupby_func)</span>
    <span class="s1">args = get_groupby_method_args(groupby_func</span><span class="s0">, </span><span class="s1">df)</span>
    <span class="s1">kwargs = {</span><span class="s2">&quot;axis&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span>
    <span class="s0">if </span><span class="s1">numeric_only </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s5"># when numeric_only is None we don't pass any argument</span>
        <span class="s1">kwargs[</span><span class="s2">&quot;numeric_only&quot;</span><span class="s1">] = numeric_only</span>

    <span class="s5"># Functions without numeric_only and axis args</span>
    <span class="s1">no_args = (</span><span class="s2">&quot;cumprod&quot;</span><span class="s0">, </span><span class="s2">&quot;cumsum&quot;</span><span class="s0">, </span><span class="s2">&quot;diff&quot;</span><span class="s0">, </span><span class="s2">&quot;fillna&quot;</span><span class="s0">, </span><span class="s2">&quot;pct_change&quot;</span><span class="s0">, </span><span class="s2">&quot;rank&quot;</span><span class="s0">, </span><span class="s2">&quot;shift&quot;</span><span class="s1">)</span>
    <span class="s5"># Functions with axis args</span>
    <span class="s1">has_axis = (</span>
        <span class="s2">&quot;cumprod&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;cumsum&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;diff&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;pct_change&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;rank&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;shift&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;cummax&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;cummin&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;idxmin&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;idxmax&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;fillna&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">warn_msg = </span><span class="s2">f&quot;DataFrameGroupBy.</span><span class="s0">{</span><span class="s1">groupby_func</span><span class="s0">} </span><span class="s2">with axis=1 is deprecated&quot;</span>
    <span class="s0">if </span><span class="s1">numeric_only </span><span class="s0">is not None and </span><span class="s1">groupby_func </span><span class="s0">in </span><span class="s1">no_args:</span>
        <span class="s1">msg = </span><span class="s2">&quot;got an unexpected keyword argument 'numeric_only'&quot;</span>
        <span class="s0">if </span><span class="s1">groupby_func </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;cumprod&quot;</span><span class="s0">, </span><span class="s2">&quot;cumsum&quot;</span><span class="s1">]:</span>
            <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=warn_msg):</span>
                    <span class="s1">method(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">method(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">elif </span><span class="s1">groupby_func </span><span class="s0">not in </span><span class="s1">has_axis:</span>
        <span class="s1">msg = </span><span class="s2">&quot;got an unexpected keyword argument 'axis'&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">method(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s5"># fillna and shift are successful even on object dtypes</span>
    <span class="s0">elif </span><span class="s1">(numeric_only </span><span class="s0">is None or not </span><span class="s1">numeric_only) </span><span class="s0">and </span><span class="s1">groupby_func </span><span class="s0">not in </span><span class="s1">(</span>
        <span class="s2">&quot;fillna&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;shift&quot;</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s1">msgs = (</span>
            <span class="s5"># cummax, cummin, rank</span>
            <span class="s2">&quot;not supported between instances of&quot;</span><span class="s0">,</span>
            <span class="s5"># cumprod</span>
            <span class="s2">&quot;can't multiply sequence by non-int of type 'float'&quot;</span><span class="s0">,</span>
            <span class="s5"># cumsum, diff, pct_change</span>
            <span class="s2">&quot;unsupported operand type&quot;</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">f&quot;(</span><span class="s0">{</span><span class="s2">'|'</span><span class="s1">.join(msgs)</span><span class="s0">}</span><span class="s2">)&quot;</span><span class="s1">):</span>
            <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=warn_msg):</span>
                <span class="s1">method(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=warn_msg):</span>
            <span class="s1">result = method(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s1">df_expected = df.drop(columns=</span><span class="s2">&quot;E&quot;</span><span class="s1">).T </span><span class="s0">if </span><span class="s1">numeric_only </span><span class="s0">else </span><span class="s1">df.T</span>
        <span class="s1">expected = getattr(df_expected</span><span class="s0">, </span><span class="s1">groupby_func)(*args).T</span>
        <span class="s0">if </span><span class="s1">groupby_func == </span><span class="s2">&quot;shift&quot; </span><span class="s0">and not </span><span class="s1">numeric_only:</span>
            <span class="s5"># shift with axis=1 leaves the leftmost column as numeric</span>
            <span class="s5"># but transposing for expected gives us object dtype</span>
            <span class="s1">expected = expected.astype(float)</span>

        <span class="s1">tm.assert_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_groupby_cumprod():</span>
    <span class="s5"># GH 4095</span>
    <span class="s1">df = DataFrame({</span><span class="s2">&quot;key&quot;</span><span class="s1">: [</span><span class="s2">&quot;b&quot;</span><span class="s1">] * </span><span class="s4">10</span><span class="s0">, </span><span class="s2">&quot;value&quot;</span><span class="s1">: </span><span class="s4">2</span><span class="s1">})</span>

    <span class="s1">actual = df.groupby(</span><span class="s2">&quot;key&quot;</span><span class="s1">)[</span><span class="s2">&quot;value&quot;</span><span class="s1">].cumprod()</span>
    <span class="s1">expected = df.groupby(</span><span class="s2">&quot;key&quot;</span><span class="s0">, </span><span class="s1">group_keys=</span><span class="s0">False</span><span class="s1">)[</span><span class="s2">&quot;value&quot;</span><span class="s1">].apply(</span><span class="s0">lambda </span><span class="s1">x: x.cumprod())</span>
    <span class="s1">expected.name = </span><span class="s2">&quot;value&quot;</span>
    <span class="s1">tm.assert_series_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">df = DataFrame({</span><span class="s2">&quot;key&quot;</span><span class="s1">: [</span><span class="s2">&quot;b&quot;</span><span class="s1">] * </span><span class="s4">100</span><span class="s0">, </span><span class="s2">&quot;value&quot;</span><span class="s1">: </span><span class="s4">2</span><span class="s1">})</span>
    <span class="s1">df[</span><span class="s2">&quot;value&quot;</span><span class="s1">] = df[</span><span class="s2">&quot;value&quot;</span><span class="s1">].astype(float)</span>
    <span class="s1">actual = df.groupby(</span><span class="s2">&quot;key&quot;</span><span class="s1">)[</span><span class="s2">&quot;value&quot;</span><span class="s1">].cumprod()</span>
    <span class="s1">expected = df.groupby(</span><span class="s2">&quot;key&quot;</span><span class="s0">, </span><span class="s1">group_keys=</span><span class="s0">False</span><span class="s1">)[</span><span class="s2">&quot;value&quot;</span><span class="s1">].apply(</span><span class="s0">lambda </span><span class="s1">x: x.cumprod())</span>
    <span class="s1">expected.name = </span><span class="s2">&quot;value&quot;</span>
    <span class="s1">tm.assert_series_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_groupby_cumprod_overflow():</span>
    <span class="s5"># GH#37493 if we overflow we return garbage consistent with numpy</span>
    <span class="s1">df = DataFrame({</span><span class="s2">&quot;key&quot;</span><span class="s1">: [</span><span class="s2">&quot;b&quot;</span><span class="s1">] * </span><span class="s4">4</span><span class="s0">, </span><span class="s2">&quot;value&quot;</span><span class="s1">: </span><span class="s4">100_000</span><span class="s1">})</span>
    <span class="s1">actual = df.groupby(</span><span class="s2">&quot;key&quot;</span><span class="s1">)[</span><span class="s2">&quot;value&quot;</span><span class="s1">].cumprod()</span>
    <span class="s1">expected = Series(</span>
        <span class="s1">[</span><span class="s4">100_000</span><span class="s0">, </span><span class="s4">10_000_000_000</span><span class="s0">, </span><span class="s4">1_000_000_000_000_000</span><span class="s0">, </span><span class="s4">7766279631452241920</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">name=</span><span class="s2">&quot;value&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">numpy_result = df.groupby(</span><span class="s2">&quot;key&quot;</span><span class="s0">, </span><span class="s1">group_keys=</span><span class="s0">False</span><span class="s1">)[</span><span class="s2">&quot;value&quot;</span><span class="s1">].apply(</span>
        <span class="s0">lambda </span><span class="s1">x: x.cumprod()</span>
    <span class="s1">)</span>
    <span class="s1">numpy_result.name = </span><span class="s2">&quot;value&quot;</span>
    <span class="s1">tm.assert_series_equal(actual</span><span class="s0">, </span><span class="s1">numpy_result)</span>


<span class="s0">def </span><span class="s1">test_groupby_cumprod_nan_influences_other_columns():</span>
    <span class="s5"># GH#48064</span>
    <span class="s1">df = DataFrame(</span>
        <span class="s1">{</span>
            <span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s0">,</span>
            <span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;c&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3.0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">result = df.groupby(</span><span class="s2">&quot;a&quot;</span><span class="s1">).cumprod(numeric_only=</span><span class="s0">True, </span><span class="s1">skipna=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame({</span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">6.0</span><span class="s1">]})</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">scipy_sem(*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
    <span class="s0">from </span><span class="s1">scipy.stats </span><span class="s0">import </span><span class="s1">sem</span>

    <span class="s0">return </span><span class="s1">sem(*args</span><span class="s0">, </span><span class="s1">ddof=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">**kwargs)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;op,targop&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s2">&quot;mean&quot;</span><span class="s0">, </span><span class="s1">np.mean)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;median&quot;</span><span class="s0">, </span><span class="s1">np.median)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;std&quot;</span><span class="s0">, </span><span class="s1">np.std)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;var&quot;</span><span class="s0">, </span><span class="s1">np.var)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;sum&quot;</span><span class="s0">, </span><span class="s1">np.sum)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;prod&quot;</span><span class="s0">, </span><span class="s1">np.prod)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;min&quot;</span><span class="s0">, </span><span class="s1">np.min)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;max&quot;</span><span class="s0">, </span><span class="s1">np.max)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;first&quot;</span><span class="s0">, lambda </span><span class="s1">x: x.iloc[</span><span class="s4">0</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;last&quot;</span><span class="s0">, lambda </span><span class="s1">x: x.iloc[-</span><span class="s4">1</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;count&quot;</span><span class="s0">, </span><span class="s1">np.size)</span><span class="s0">,</span>
        <span class="s1">pytest.param(</span><span class="s2">&quot;sem&quot;</span><span class="s0">, </span><span class="s1">scipy_sem</span><span class="s0">, </span><span class="s1">marks=td.skip_if_no_scipy)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_ops_general(op</span><span class="s0">, </span><span class="s1">targop):</span>
    <span class="s1">df = DataFrame(np.random.default_rng(</span><span class="s4">2</span><span class="s1">).standard_normal(</span><span class="s4">1000</span><span class="s1">))</span>
    <span class="s1">labels = np.random.default_rng(</span><span class="s4">2</span><span class="s1">).integers(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">50</span><span class="s0">, </span><span class="s1">size=</span><span class="s4">1000</span><span class="s1">).astype(float)</span>

    <span class="s1">result = getattr(df.groupby(labels)</span><span class="s0">, </span><span class="s1">op)()</span>
    <span class="s1">warn = </span><span class="s0">None if </span><span class="s1">op </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;first&quot;</span><span class="s0">, </span><span class="s2">&quot;last&quot;</span><span class="s0">, </span><span class="s2">&quot;count&quot;</span><span class="s0">, </span><span class="s2">&quot;sem&quot;</span><span class="s1">) </span><span class="s0">else </span><span class="s1">FutureWarning</span>
    <span class="s1">msg = </span><span class="s2">f&quot;using DataFrameGroupBy.</span><span class="s0">{</span><span class="s1">op</span><span class="s0">}</span><span class="s2">&quot;</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(warn</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">expected = df.groupby(labels).agg(targop)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_max_nan_bug():</span>
    <span class="s1">raw = </span><span class="s2">&quot;&quot;&quot;,Date,app,File 
-04-23,2013-04-23 00:00:00,,log080001.log 
-05-06,2013-05-06 00:00:00,,log.log 
-05-07,2013-05-07 00:00:00,OE,xlsx&quot;&quot;&quot;</span>

    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(UserWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;Could not infer format&quot;</span><span class="s1">):</span>
        <span class="s1">df = pd.read_csv(StringIO(raw)</span><span class="s0">, </span><span class="s1">parse_dates=[</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">gb = df.groupby(</span><span class="s2">&quot;Date&quot;</span><span class="s1">)</span>
    <span class="s1">r = gb[[</span><span class="s2">&quot;File&quot;</span><span class="s1">]].max()</span>
    <span class="s1">e = gb[</span><span class="s2">&quot;File&quot;</span><span class="s1">].max().to_frame()</span>
    <span class="s1">tm.assert_frame_equal(r</span><span class="s0">, </span><span class="s1">e)</span>
    <span class="s0">assert not </span><span class="s1">r[</span><span class="s2">&quot;File&quot;</span><span class="s1">].isna().any()</span>


<span class="s0">def </span><span class="s1">test_nlargest():</span>
    <span class="s1">a = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">7</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">9</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">6</span><span class="s0">, </span><span class="s4">10</span><span class="s1">])</span>
    <span class="s1">b = Series(list(</span><span class="s2">&quot;a&quot; </span><span class="s1">* </span><span class="s4">5 </span><span class="s1">+ </span><span class="s2">&quot;b&quot; </span><span class="s1">* </span><span class="s4">5</span><span class="s1">))</span>
    <span class="s1">gb = a.groupby(b)</span>
    <span class="s1">r = gb.nlargest(</span><span class="s4">3</span><span class="s1">)</span>
    <span class="s1">e = Series(</span>
        <span class="s1">[</span><span class="s4">7</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">10</span><span class="s0">, </span><span class="s4">9</span><span class="s0">, </span><span class="s4">6</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">index=MultiIndex.from_arrays([list(</span><span class="s2">&quot;aaabbb&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s4">3</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">9</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">8</span><span class="s1">]])</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(r</span><span class="s0">, </span><span class="s1">e)</span>

    <span class="s1">a = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">gb = a.groupby(b)</span>
    <span class="s1">e = Series(</span>
        <span class="s1">[</span><span class="s4">3</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">index=MultiIndex.from_arrays([list(</span><span class="s2">&quot;aaabbb&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">6</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">7</span><span class="s1">]])</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(gb.nlargest(</span><span class="s4">3</span><span class="s0">, </span><span class="s1">keep=</span><span class="s2">&quot;last&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">e)</span>


<span class="s0">def </span><span class="s1">test_nlargest_mi_grouper():</span>
    <span class="s5"># see gh-21411</span>
    <span class="s1">npr = np.random.default_rng(</span><span class="s4">2</span><span class="s1">)</span>

    <span class="s1">dts = date_range(</span><span class="s2">&quot;20180101&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">)</span>
    <span class="s1">iterables = [dts</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;one&quot;</span><span class="s0">, </span><span class="s2">&quot;two&quot;</span><span class="s1">]]</span>

    <span class="s1">idx = MultiIndex.from_product(iterables</span><span class="s0">, </span><span class="s1">names=[</span><span class="s2">&quot;first&quot;</span><span class="s0">, </span><span class="s2">&quot;second&quot;</span><span class="s1">])</span>
    <span class="s1">s = Series(npr.standard_normal(</span><span class="s4">20</span><span class="s1">)</span><span class="s0">, </span><span class="s1">index=idx)</span>

    <span class="s1">result = s.groupby(</span><span class="s2">&quot;first&quot;</span><span class="s1">).nlargest(</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s1">exp_idx = MultiIndex.from_tuples(</span>
        <span class="s1">[</span>
            <span class="s1">(dts[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dts[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;one&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(dts[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dts[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;one&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(dts[</span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dts[</span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;one&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(dts[</span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dts[</span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;two&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(dts[</span><span class="s4">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dts[</span><span class="s4">4</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;one&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(dts[</span><span class="s4">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dts[</span><span class="s4">5</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;one&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(dts[</span><span class="s4">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dts[</span><span class="s4">6</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;one&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(dts[</span><span class="s4">7</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dts[</span><span class="s4">7</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;one&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(dts[</span><span class="s4">8</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dts[</span><span class="s4">8</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;one&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(dts[</span><span class="s4">9</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dts[</span><span class="s4">9</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;one&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">names=[</span><span class="s2">&quot;first&quot;</span><span class="s0">, </span><span class="s2">&quot;first&quot;</span><span class="s0">, </span><span class="s2">&quot;second&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">exp_values = [</span>
        <span class="s4">0.18905338179353307</span><span class="s0">,</span>
        <span class="s1">-</span><span class="s4">0.41306354339189344</span><span class="s0">,</span>
        <span class="s4">1.799707382720902</span><span class="s0">,</span>
        <span class="s4">0.7738065867276614</span><span class="s0">,</span>
        <span class="s4">0.28121066979764925</span><span class="s0">,</span>
        <span class="s4">0.9775674511260357</span><span class="s0">,</span>
        <span class="s1">-</span><span class="s4">0.3288239040579627</span><span class="s0">,</span>
        <span class="s4">0.45495807124085547</span><span class="s0">,</span>
        <span class="s4">0.5452887139646817</span><span class="s0">,</span>
        <span class="s4">0.12682784711186987</span><span class="s0">,</span>
    <span class="s1">]</span>

    <span class="s1">expected = Series(exp_values</span><span class="s0">, </span><span class="s1">index=exp_idx)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_exact=</span><span class="s0">False, </span><span class="s1">rtol=</span><span class="s4">1e-3</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_nsmallest():</span>
    <span class="s1">a = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">7</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">9</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">6</span><span class="s0">, </span><span class="s4">10</span><span class="s1">])</span>
    <span class="s1">b = Series(list(</span><span class="s2">&quot;a&quot; </span><span class="s1">* </span><span class="s4">5 </span><span class="s1">+ </span><span class="s2">&quot;b&quot; </span><span class="s1">* </span><span class="s4">5</span><span class="s1">))</span>
    <span class="s1">gb = a.groupby(b)</span>
    <span class="s1">r = gb.nsmallest(</span><span class="s4">3</span><span class="s1">)</span>
    <span class="s1">e = Series(</span>
        <span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">6</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">index=MultiIndex.from_arrays([list(</span><span class="s2">&quot;aaabbb&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">6</span><span class="s0">, </span><span class="s4">7</span><span class="s0">, </span><span class="s4">8</span><span class="s1">]])</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(r</span><span class="s0">, </span><span class="s1">e)</span>

    <span class="s1">a = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">gb = a.groupby(b)</span>
    <span class="s1">e = Series(</span>
        <span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">index=MultiIndex.from_arrays([list(</span><span class="s2">&quot;aaabbb&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s4">4</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">9</span><span class="s0">, </span><span class="s4">8</span><span class="s0">, </span><span class="s4">7</span><span class="s1">]])</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(gb.nsmallest(</span><span class="s4">3</span><span class="s0">, </span><span class="s1">keep=</span><span class="s2">&quot;last&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">e)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;data, groups&quot;</span><span class="s0">,</span>
    <span class="s1">[([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">([</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s1">])]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, </span><span class="s1">*tm.ALL_INT_NUMPY_DTYPES])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;method&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;nlargest&quot;</span><span class="s0">, </span><span class="s2">&quot;nsmallest&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_nlargest_and_smallest_noop(data</span><span class="s0">, </span><span class="s1">groups</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">method):</span>
    <span class="s5"># GH 15272, GH 16345, GH 29129</span>
    <span class="s5"># Test nlargest/smallest when it results in a noop,</span>
    <span class="s5"># i.e. input is sorted and group size &lt;= n</span>
    <span class="s0">if </span><span class="s1">dtype </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">data = np.array(data</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
    <span class="s0">if </span><span class="s1">method == </span><span class="s2">&quot;nlargest&quot;</span><span class="s1">:</span>
        <span class="s1">data = list(reversed(data))</span>
    <span class="s1">ser = Series(data</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;a&quot;</span><span class="s1">)</span>
    <span class="s1">result = getattr(ser.groupby(groups)</span><span class="s0">, </span><span class="s1">method)(n=</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">expidx = np.array(groups</span><span class="s0">, </span><span class="s1">dtype=int) </span><span class="s0">if </span><span class="s1">isinstance(groups</span><span class="s0">, </span><span class="s1">list) </span><span class="s0">else </span><span class="s1">groups</span>
    <span class="s1">expected = Series(data</span><span class="s0">, </span><span class="s1">index=MultiIndex.from_arrays([expidx</span><span class="s0">, </span><span class="s1">ser.index])</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;a&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;func&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;cumprod&quot;</span><span class="s0">, </span><span class="s2">&quot;cumsum&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_numpy_compat(func):</span>
    <span class="s5"># see gh-12811</span>
    <span class="s1">df = DataFrame({</span><span class="s2">&quot;A&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]})</span>
    <span class="s1">g = df.groupby(</span><span class="s2">&quot;A&quot;</span><span class="s1">)</span>

    <span class="s1">msg = </span><span class="s2">&quot;numpy operations are not valid with groupby&quot;</span>

    <span class="s0">with </span><span class="s1">pytest.raises(UnsupportedFunctionCall</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">getattr(g</span><span class="s0">, </span><span class="s1">func)(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(UnsupportedFunctionCall</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">getattr(g</span><span class="s0">, </span><span class="s1">func)(foo=</span><span class="s4">1</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_cummin(dtypes_for_minmax):</span>
    <span class="s1">dtype = dtypes_for_minmax[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">min_val = dtypes_for_minmax[</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s5"># GH 15048</span>
    <span class="s1">base_df = DataFrame({</span><span class="s2">&quot;A&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">: [</span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]})</span>
    <span class="s1">expected_mins = [</span><span class="s4">3</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span>

    <span class="s1">df = base_df.astype(dtype)</span>

    <span class="s1">expected = DataFrame({</span><span class="s2">&quot;B&quot;</span><span class="s1">: expected_mins}).astype(dtype)</span>
    <span class="s1">result = df.groupby(</span><span class="s2">&quot;A&quot;</span><span class="s1">).cummin()</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
    <span class="s1">result = df.groupby(</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s1">group_keys=</span><span class="s0">False</span><span class="s1">).B.apply(</span><span class="s0">lambda </span><span class="s1">x: x.cummin()).to_frame()</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s5"># Test w/ min value for dtype</span>
    <span class="s1">df.loc[[</span><span class="s4">2</span><span class="s0">, </span><span class="s4">6</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">] = min_val</span>
    <span class="s1">df.loc[[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">5</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">] = min_val + </span><span class="s4">1</span>
    <span class="s1">expected.loc[[</span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">6</span><span class="s0">, </span><span class="s4">7</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">] = min_val</span>
    <span class="s1">expected.loc[[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">5</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">] = min_val + </span><span class="s4">1  </span><span class="s5"># should not be rounded to min_val</span>
    <span class="s1">result = df.groupby(</span><span class="s2">&quot;A&quot;</span><span class="s1">).cummin()</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_exact=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">expected = (</span>
        <span class="s1">df.groupby(</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s1">group_keys=</span><span class="s0">False</span><span class="s1">).B.apply(</span><span class="s0">lambda </span><span class="s1">x: x.cummin()).to_frame()</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_exact=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s5"># Test nan in some values</span>
    <span class="s5"># Explicit cast to float to avoid implicit cast when setting nan</span>
    <span class="s1">base_df = base_df.astype({</span><span class="s2">&quot;B&quot;</span><span class="s1">: </span><span class="s2">&quot;float&quot;</span><span class="s1">})</span>
    <span class="s1">base_df.loc[[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">6</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">] = np.nan</span>
    <span class="s1">expected = DataFrame({</span><span class="s2">&quot;B&quot;</span><span class="s1">: [np.nan</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]})</span>
    <span class="s1">result = base_df.groupby(</span><span class="s2">&quot;A&quot;</span><span class="s1">).cummin()</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
    <span class="s1">expected = (</span>
        <span class="s1">base_df.groupby(</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s1">group_keys=</span><span class="s0">False</span><span class="s1">).B.apply(</span><span class="s0">lambda </span><span class="s1">x: x.cummin()).to_frame()</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s5"># GH 15561</span>
    <span class="s1">df = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: pd.to_datetime([</span><span class="s2">&quot;2001&quot;</span><span class="s1">])})</span>
    <span class="s1">expected = Series(pd.to_datetime(</span><span class="s2">&quot;2001&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">index=[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;b&quot;</span><span class="s1">)</span>

    <span class="s1">result = df.groupby(</span><span class="s2">&quot;a&quot;</span><span class="s1">)[</span><span class="s2">&quot;b&quot;</span><span class="s1">].cummin()</span>
    <span class="s1">tm.assert_series_equal(expected</span><span class="s0">, </span><span class="s1">result)</span>

    <span class="s5"># GH 15635</span>
    <span class="s1">df = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]})</span>
    <span class="s1">result = df.groupby(</span><span class="s2">&quot;a&quot;</span><span class="s1">).b.cummin()</span>
    <span class="s1">expected = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;b&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;method&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;cummin&quot;</span><span class="s0">, </span><span class="s2">&quot;cummax&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;UInt64&quot;</span><span class="s0">, </span><span class="s2">&quot;Int64&quot;</span><span class="s0">, </span><span class="s2">&quot;Float64&quot;</span><span class="s0">, </span><span class="s2">&quot;float&quot;</span><span class="s0">, </span><span class="s2">&quot;boolean&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_cummin_max_all_nan_column(method</span><span class="s0">, </span><span class="s1">dtype):</span>
    <span class="s1">base_df = DataFrame({</span><span class="s2">&quot;A&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">: [np.nan] * </span><span class="s4">8</span><span class="s1">})</span>
    <span class="s1">base_df[</span><span class="s2">&quot;B&quot;</span><span class="s1">] = base_df[</span><span class="s2">&quot;B&quot;</span><span class="s1">].astype(dtype)</span>
    <span class="s1">grouped = base_df.groupby(</span><span class="s2">&quot;A&quot;</span><span class="s1">)</span>

    <span class="s1">expected = DataFrame({</span><span class="s2">&quot;B&quot;</span><span class="s1">: [np.nan] * </span><span class="s4">8</span><span class="s1">}</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">result = getattr(grouped</span><span class="s0">, </span><span class="s1">method)()</span>
    <span class="s1">tm.assert_frame_equal(expected</span><span class="s0">, </span><span class="s1">result)</span>

    <span class="s1">result = getattr(grouped[</span><span class="s2">&quot;B&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">method)().to_frame()</span>
    <span class="s1">tm.assert_frame_equal(expected</span><span class="s0">, </span><span class="s1">result)</span>


<span class="s0">def </span><span class="s1">test_cummax(dtypes_for_minmax):</span>
    <span class="s1">dtype = dtypes_for_minmax[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">max_val = dtypes_for_minmax[</span><span class="s4">2</span><span class="s1">]</span>

    <span class="s5"># GH 15048</span>
    <span class="s1">base_df = DataFrame({</span><span class="s2">&quot;A&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">: [</span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]})</span>
    <span class="s1">expected_maxs = [</span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span>

    <span class="s1">df = base_df.astype(dtype)</span>

    <span class="s1">expected = DataFrame({</span><span class="s2">&quot;B&quot;</span><span class="s1">: expected_maxs}).astype(dtype)</span>
    <span class="s1">result = df.groupby(</span><span class="s2">&quot;A&quot;</span><span class="s1">).cummax()</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
    <span class="s1">result = df.groupby(</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s1">group_keys=</span><span class="s0">False</span><span class="s1">).B.apply(</span><span class="s0">lambda </span><span class="s1">x: x.cummax()).to_frame()</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s5"># Test w/ max value for dtype</span>
    <span class="s1">df.loc[[</span><span class="s4">2</span><span class="s0">, </span><span class="s4">6</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">] = max_val</span>
    <span class="s1">expected.loc[[</span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">6</span><span class="s0">, </span><span class="s4">7</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">] = max_val</span>
    <span class="s1">result = df.groupby(</span><span class="s2">&quot;A&quot;</span><span class="s1">).cummax()</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
    <span class="s1">expected = (</span>
        <span class="s1">df.groupby(</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s1">group_keys=</span><span class="s0">False</span><span class="s1">).B.apply(</span><span class="s0">lambda </span><span class="s1">x: x.cummax()).to_frame()</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s5"># Test nan in some values</span>
    <span class="s5"># Explicit cast to float to avoid implicit cast when setting nan</span>
    <span class="s1">base_df = base_df.astype({</span><span class="s2">&quot;B&quot;</span><span class="s1">: </span><span class="s2">&quot;float&quot;</span><span class="s1">})</span>
    <span class="s1">base_df.loc[[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">6</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">] = np.nan</span>
    <span class="s1">expected = DataFrame({</span><span class="s2">&quot;B&quot;</span><span class="s1">: [np.nan</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]})</span>
    <span class="s1">result = base_df.groupby(</span><span class="s2">&quot;A&quot;</span><span class="s1">).cummax()</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
    <span class="s1">expected = (</span>
        <span class="s1">base_df.groupby(</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s1">group_keys=</span><span class="s0">False</span><span class="s1">).B.apply(</span><span class="s0">lambda </span><span class="s1">x: x.cummax()).to_frame()</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s5"># GH 15561</span>
    <span class="s1">df = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: pd.to_datetime([</span><span class="s2">&quot;2001&quot;</span><span class="s1">])})</span>
    <span class="s1">expected = Series(pd.to_datetime(</span><span class="s2">&quot;2001&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">index=[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;b&quot;</span><span class="s1">)</span>

    <span class="s1">result = df.groupby(</span><span class="s2">&quot;a&quot;</span><span class="s1">)[</span><span class="s2">&quot;b&quot;</span><span class="s1">].cummax()</span>
    <span class="s1">tm.assert_series_equal(expected</span><span class="s0">, </span><span class="s1">result)</span>

    <span class="s5"># GH 15635</span>
    <span class="s1">df = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]})</span>
    <span class="s1">result = df.groupby(</span><span class="s2">&quot;a&quot;</span><span class="s1">).b.cummax()</span>
    <span class="s1">expected = Series([</span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;b&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_cummax_i8_at_implementation_bound():</span>
    <span class="s5"># the minimum value used to be treated as NPY_NAT+1 instead of NPY_NAT</span>
    <span class="s5">#  for int64 dtype GH#46382</span>
    <span class="s1">ser = Series([pd.NaT._value + n </span><span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">5</span><span class="s1">)])</span>
    <span class="s1">df = DataFrame({</span><span class="s2">&quot;A&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">: ser</span><span class="s0">, </span><span class="s2">&quot;C&quot;</span><span class="s1">: ser.view(</span><span class="s2">&quot;M8[ns]&quot;</span><span class="s1">)})</span>
    <span class="s1">gb = df.groupby(</span><span class="s2">&quot;A&quot;</span><span class="s1">)</span>

    <span class="s1">res = gb.cummax()</span>
    <span class="s1">exp = df[[</span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;C&quot;</span><span class="s1">]]</span>
    <span class="s1">tm.assert_frame_equal(res</span><span class="s0">, </span><span class="s1">exp)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;method&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;cummin&quot;</span><span class="s0">, </span><span class="s2">&quot;cummax&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;float&quot;</span><span class="s0">, </span><span class="s2">&quot;Int64&quot;</span><span class="s0">, </span><span class="s2">&quot;Float64&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;groups,expected_data&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, None, None</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, None, </span><span class="s4">2</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, None, None</span><span class="s1">])</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_cummin_max_skipna(method</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">groups</span><span class="s0">, </span><span class="s1">expected_data):</span>
    <span class="s5"># GH-34047</span>
    <span class="s1">df = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: Series([</span><span class="s4">1</span><span class="s0">, None, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dtype)})</span>
    <span class="s1">orig = df.copy()</span>
    <span class="s1">gb = df.groupby(groups)[</span><span class="s2">&quot;a&quot;</span><span class="s1">]</span>

    <span class="s1">result = getattr(gb</span><span class="s0">, </span><span class="s1">method)(skipna=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">expected = Series(expected_data</span><span class="s0">, </span><span class="s1">dtype=dtype</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;a&quot;</span><span class="s1">)</span>

    <span class="s5"># check we didn't accidentally alter df</span>
    <span class="s1">tm.assert_frame_equal(df</span><span class="s0">, </span><span class="s1">orig)</span>

    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;method&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;cummin&quot;</span><span class="s0">, </span><span class="s2">&quot;cummax&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_cummin_max_skipna_multiple_cols(method):</span>
    <span class="s5"># Ensure missing value in &quot;a&quot; doesn't cause &quot;b&quot; to be nan-filled</span>
    <span class="s1">df = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [np.nan</span><span class="s0">, </span><span class="s4">2.0</span><span class="s0">, </span><span class="s4">2.0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s4">2.0</span><span class="s0">, </span><span class="s4">2.0</span><span class="s0">, </span><span class="s4">2.0</span><span class="s1">]})</span>
    <span class="s1">gb = df.groupby([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">])[[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]]</span>

    <span class="s1">result = getattr(gb</span><span class="s0">, </span><span class="s1">method)(skipna=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s4">2.0</span><span class="s0">, </span><span class="s4">2.0</span><span class="s0">, </span><span class="s4">2.0</span><span class="s1">]})</span>

    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@td.skip_if_32bit</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;method&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;cummin&quot;</span><span class="s0">, </span><span class="s2">&quot;cummax&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;dtype,val&quot;</span><span class="s0">, </span><span class="s1">[(</span><span class="s2">&quot;UInt64&quot;</span><span class="s0">, </span><span class="s1">np.iinfo(</span><span class="s2">&quot;uint64&quot;</span><span class="s1">).max)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;Int64&quot;</span><span class="s0">, </span><span class="s4">2</span><span class="s1">**</span><span class="s4">53 </span><span class="s1">+ </span><span class="s4">1</span><span class="s1">)]</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_nullable_int_not_cast_as_float(method</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">val):</span>
    <span class="s1">data = [val</span><span class="s0">, </span><span class="s1">pd.NA]</span>
    <span class="s1">df = DataFrame({</span><span class="s2">&quot;grp&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: data}</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">grouped = df.groupby(</span><span class="s2">&quot;grp&quot;</span><span class="s1">)</span>

    <span class="s1">result = grouped.transform(method)</span>
    <span class="s1">expected = DataFrame({</span><span class="s2">&quot;b&quot;</span><span class="s1">: data}</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>

    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;in_vals, out_vals&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s5"># Basics: strictly increasing (T), strictly decreasing (F),</span>
        <span class="s5"># abs val increasing (F), non-strictly increasing (T)</span>
        <span class="s1">([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s1">-</span><span class="s4">6</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False, False, True</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s5"># Test with inf vals</span>
        <span class="s1">(</span>
            <span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2.1</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">11</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">-np.inf]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s0">True, False, True, False</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s5"># Test with nan vals; should always be False</span>
        <span class="s1">(</span>
            <span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s0">False, False, False, False</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_is_monotonic_increasing(in_vals</span><span class="s0">, </span><span class="s1">out_vals):</span>
    <span class="s5"># GH 17015</span>
    <span class="s1">source_dict = {</span>
        <span class="s2">&quot;A&quot;</span><span class="s1">: [</span><span class="s2">&quot;1&quot;</span><span class="s0">, </span><span class="s2">&quot;2&quot;</span><span class="s0">, </span><span class="s2">&quot;3&quot;</span><span class="s0">, </span><span class="s2">&quot;4&quot;</span><span class="s0">, </span><span class="s2">&quot;5&quot;</span><span class="s0">, </span><span class="s2">&quot;6&quot;</span><span class="s0">, </span><span class="s2">&quot;7&quot;</span><span class="s0">, </span><span class="s2">&quot;8&quot;</span><span class="s0">, </span><span class="s2">&quot;9&quot;</span><span class="s0">, </span><span class="s2">&quot;10&quot;</span><span class="s0">, </span><span class="s2">&quot;11&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s2">&quot;B&quot;</span><span class="s1">: [</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s2">&quot;C&quot;</span><span class="s1">: in_vals</span><span class="s0">,</span>
    <span class="s1">}</span>
    <span class="s1">df = DataFrame(source_dict)</span>
    <span class="s1">result = df.groupby(</span><span class="s2">&quot;B&quot;</span><span class="s1">).C.is_monotonic_increasing</span>
    <span class="s1">index = Index(list(</span><span class="s2">&quot;abcd&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;B&quot;</span><span class="s1">)</span>
    <span class="s1">expected = Series(index=index</span><span class="s0">, </span><span class="s1">data=out_vals</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;C&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s5"># Also check result equal to manually taking x.is_monotonic_increasing.</span>
    <span class="s1">expected = df.groupby([</span><span class="s2">&quot;B&quot;</span><span class="s1">]).C.apply(</span><span class="s0">lambda </span><span class="s1">x: x.is_monotonic_increasing)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;in_vals, out_vals&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s5"># Basics: strictly decreasing (T), strictly increasing (F),</span>
        <span class="s5"># abs val decreasing (F), non-strictly increasing (T)</span>
        <span class="s1">([</span><span class="s4">10</span><span class="s0">, </span><span class="s4">9</span><span class="s0">, </span><span class="s4">7</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s1">-</span><span class="s4">3</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False, False, True</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s5"># Test with inf vals</span>
        <span class="s1">(</span>
            <span class="s1">[np.inf</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s1">-</span><span class="s4">3</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s1">-</span><span class="s4">3</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s1">-np.inf]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s0">True, True, False, True</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s5"># Test with nan vals; should always be False</span>
        <span class="s1">(</span>
            <span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s0">False, False, False, False</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_is_monotonic_decreasing(in_vals</span><span class="s0">, </span><span class="s1">out_vals):</span>
    <span class="s5"># GH 17015</span>
    <span class="s1">source_dict = {</span>
        <span class="s2">&quot;A&quot;</span><span class="s1">: [</span><span class="s2">&quot;1&quot;</span><span class="s0">, </span><span class="s2">&quot;2&quot;</span><span class="s0">, </span><span class="s2">&quot;3&quot;</span><span class="s0">, </span><span class="s2">&quot;4&quot;</span><span class="s0">, </span><span class="s2">&quot;5&quot;</span><span class="s0">, </span><span class="s2">&quot;6&quot;</span><span class="s0">, </span><span class="s2">&quot;7&quot;</span><span class="s0">, </span><span class="s2">&quot;8&quot;</span><span class="s0">, </span><span class="s2">&quot;9&quot;</span><span class="s0">, </span><span class="s2">&quot;10&quot;</span><span class="s0">, </span><span class="s2">&quot;11&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s2">&quot;B&quot;</span><span class="s1">: [</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s2">&quot;C&quot;</span><span class="s1">: in_vals</span><span class="s0">,</span>
    <span class="s1">}</span>

    <span class="s1">df = DataFrame(source_dict)</span>
    <span class="s1">result = df.groupby(</span><span class="s2">&quot;B&quot;</span><span class="s1">).C.is_monotonic_decreasing</span>
    <span class="s1">index = Index(list(</span><span class="s2">&quot;abcd&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;B&quot;</span><span class="s1">)</span>
    <span class="s1">expected = Series(index=index</span><span class="s0">, </span><span class="s1">data=out_vals</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;C&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s5"># describe</span>
<span class="s5"># --------------------------------</span>


<span class="s0">def </span><span class="s1">test_apply_describe_bug(mframe):</span>
    <span class="s1">grouped = mframe.groupby(level=</span><span class="s2">&quot;first&quot;</span><span class="s1">)</span>
    <span class="s1">grouped.describe()  </span><span class="s5"># it works!</span>


<span class="s0">def </span><span class="s1">test_series_describe_multikey():</span>
    <span class="s1">ts = tm.makeTimeSeries()</span>
    <span class="s1">grouped = ts.groupby([</span><span class="s0">lambda </span><span class="s1">x: x.year</span><span class="s0">, lambda </span><span class="s1">x: x.month])</span>
    <span class="s1">result = grouped.describe()</span>
    <span class="s1">tm.assert_series_equal(result[</span><span class="s2">&quot;mean&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">grouped.mean()</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result[</span><span class="s2">&quot;std&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">grouped.std()</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result[</span><span class="s2">&quot;min&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">grouped.min()</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_series_describe_single():</span>
    <span class="s1">ts = tm.makeTimeSeries()</span>
    <span class="s1">grouped = ts.groupby(</span><span class="s0">lambda </span><span class="s1">x: x.month)</span>
    <span class="s1">result = grouped.apply(</span><span class="s0">lambda </span><span class="s1">x: x.describe())</span>
    <span class="s1">expected = grouped.describe().stack(future_stack=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;keys&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;key1&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;key1&quot;</span><span class="s0">, </span><span class="s2">&quot;key2&quot;</span><span class="s1">]])</span>
<span class="s0">def </span><span class="s1">test_series_describe_as_index(as_index</span><span class="s0">, </span><span class="s1">keys):</span>
    <span class="s5"># GH#49256</span>
    <span class="s1">df = DataFrame(</span>
        <span class="s1">{</span>
            <span class="s2">&quot;key1&quot;</span><span class="s1">: [</span><span class="s2">&quot;one&quot;</span><span class="s0">, </span><span class="s2">&quot;two&quot;</span><span class="s0">, </span><span class="s2">&quot;two&quot;</span><span class="s0">, </span><span class="s2">&quot;three&quot;</span><span class="s0">, </span><span class="s2">&quot;two&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;key2&quot;</span><span class="s1">: [</span><span class="s2">&quot;one&quot;</span><span class="s0">, </span><span class="s2">&quot;two&quot;</span><span class="s0">, </span><span class="s2">&quot;two&quot;</span><span class="s0">, </span><span class="s2">&quot;three&quot;</span><span class="s0">, </span><span class="s2">&quot;two&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;foo2&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">6</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">gb = df.groupby(keys</span><span class="s0">, </span><span class="s1">as_index=as_index)[</span><span class="s2">&quot;foo2&quot;</span><span class="s1">]</span>
    <span class="s1">result = gb.describe()</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">{</span>
            <span class="s2">&quot;key1&quot;</span><span class="s1">: [</span><span class="s2">&quot;one&quot;</span><span class="s0">, </span><span class="s2">&quot;three&quot;</span><span class="s0">, </span><span class="s2">&quot;two&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;count&quot;</span><span class="s1">: [</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;mean&quot;</span><span class="s1">: [</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">4.0</span><span class="s0">, </span><span class="s4">4.0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;std&quot;</span><span class="s1">: [np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">2.0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;min&quot;</span><span class="s1">: [</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">4.0</span><span class="s0">, </span><span class="s4">2.0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;25%&quot;</span><span class="s1">: [</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">4.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;50%&quot;</span><span class="s1">: [</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">4.0</span><span class="s0">, </span><span class="s4">4.0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;75%&quot;</span><span class="s1">: [</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">4.0</span><span class="s0">, </span><span class="s4">5.0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;max&quot;</span><span class="s1">: [</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">4.0</span><span class="s0">, </span><span class="s4">6.0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s0">if </span><span class="s1">len(keys) == </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s1">expected.insert(</span><span class="s4">1</span><span class="s0">, </span><span class="s2">&quot;key2&quot;</span><span class="s0">, </span><span class="s1">expected[</span><span class="s2">&quot;key1&quot;</span><span class="s1">])</span>
    <span class="s0">if </span><span class="s1">as_index:</span>
        <span class="s1">expected = expected.set_index(keys)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_series_index_name(df):</span>
    <span class="s1">grouped = df.loc[:</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;C&quot;</span><span class="s1">]].groupby(df[</span><span class="s2">&quot;A&quot;</span><span class="s1">])</span>
    <span class="s1">result = grouped.agg(</span><span class="s0">lambda </span><span class="s1">x: x.mean())</span>
    <span class="s0">assert </span><span class="s1">result.index.name == </span><span class="s2">&quot;A&quot;</span>


<span class="s0">def </span><span class="s1">test_frame_describe_multikey(tsframe):</span>
    <span class="s1">grouped = tsframe.groupby([</span><span class="s0">lambda </span><span class="s1">x: x.year</span><span class="s0">, lambda </span><span class="s1">x: x.month])</span>
    <span class="s1">result = grouped.describe()</span>
    <span class="s1">desc_groups = []</span>
    <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">tsframe:</span>
        <span class="s1">group = grouped[col].describe()</span>
        <span class="s5"># GH 17464 - Remove duplicate MultiIndex levels</span>
        <span class="s1">group_col = MultiIndex(</span>
            <span class="s1">levels=[[col]</span><span class="s0">, </span><span class="s1">group.columns]</span><span class="s0">,</span>
            <span class="s1">codes=[[</span><span class="s4">0</span><span class="s1">] * len(group.columns)</span><span class="s0">, </span><span class="s1">range(len(group.columns))]</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">group = DataFrame(group.values</span><span class="s0">, </span><span class="s1">columns=group_col</span><span class="s0">, </span><span class="s1">index=group.index)</span>
        <span class="s1">desc_groups.append(group)</span>
    <span class="s1">expected = pd.concat(desc_groups</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">msg = </span><span class="s2">&quot;DataFrame.groupby with axis=1 is deprecated&quot;</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">groupedT = tsframe.groupby({</span><span class="s2">&quot;A&quot;</span><span class="s1">: </span><span class="s4">0</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">: </span><span class="s4">0</span><span class="s0">, </span><span class="s2">&quot;C&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s0">, </span><span class="s2">&quot;D&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">result = groupedT.describe()</span>
    <span class="s1">expected = tsframe.describe().T</span>
    <span class="s5"># reverting the change from https://github.com/pandas-dev/pandas/pull/35441/</span>
    <span class="s1">expected.index = MultiIndex(</span>
        <span class="s1">levels=[[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">expected.index]</span><span class="s0">,</span>
        <span class="s1">codes=[[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">range(len(expected.index))]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_frame_describe_tupleindex():</span>
    <span class="s5"># GH 14848 - regression from 0.19.0 to 0.19.1</span>
    <span class="s1">df1 = DataFrame(</span>
        <span class="s1">{</span>
            <span class="s2">&quot;x&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">5</span><span class="s1">] * </span><span class="s4">3</span><span class="s0">,</span>
            <span class="s2">&quot;y&quot;</span><span class="s1">: [</span><span class="s4">10</span><span class="s0">, </span><span class="s4">20</span><span class="s0">, </span><span class="s4">30</span><span class="s0">, </span><span class="s4">40</span><span class="s0">, </span><span class="s4">50</span><span class="s1">] * </span><span class="s4">3</span><span class="s0">,</span>
            <span class="s2">&quot;z&quot;</span><span class="s1">: [</span><span class="s4">100</span><span class="s0">, </span><span class="s4">200</span><span class="s0">, </span><span class="s4">300</span><span class="s0">, </span><span class="s4">400</span><span class="s0">, </span><span class="s4">500</span><span class="s1">] * </span><span class="s4">3</span><span class="s0">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">df1[</span><span class="s2">&quot;k&quot;</span><span class="s1">] = [(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)] * </span><span class="s4">5</span>
    <span class="s1">df2 = df1.rename(columns={</span><span class="s2">&quot;k&quot;</span><span class="s1">: </span><span class="s2">&quot;key&quot;</span><span class="s1">})</span>
    <span class="s1">msg = </span><span class="s2">&quot;Names should be list-like for a MultiIndex&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">df1.groupby(</span><span class="s2">&quot;k&quot;</span><span class="s1">).describe()</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">df2.groupby(</span><span class="s2">&quot;key&quot;</span><span class="s1">).describe()</span>


<span class="s0">def </span><span class="s1">test_frame_describe_unstacked_format():</span>
    <span class="s5"># GH 4792</span>
    <span class="s1">prices = {</span>
        <span class="s1">Timestamp(</span><span class="s2">&quot;2011-01-06 10:59:05&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s0">None</span><span class="s1">): </span><span class="s4">24990</span><span class="s0">,</span>
        <span class="s1">Timestamp(</span><span class="s2">&quot;2011-01-06 12:43:33&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s0">None</span><span class="s1">): </span><span class="s4">25499</span><span class="s0">,</span>
        <span class="s1">Timestamp(</span><span class="s2">&quot;2011-01-06 12:54:09&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s0">None</span><span class="s1">): </span><span class="s4">25499</span><span class="s0">,</span>
    <span class="s1">}</span>
    <span class="s1">volumes = {</span>
        <span class="s1">Timestamp(</span><span class="s2">&quot;2011-01-06 10:59:05&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s0">None</span><span class="s1">): </span><span class="s4">1500000000</span><span class="s0">,</span>
        <span class="s1">Timestamp(</span><span class="s2">&quot;2011-01-06 12:43:33&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s0">None</span><span class="s1">): </span><span class="s4">5000000000</span><span class="s0">,</span>
        <span class="s1">Timestamp(</span><span class="s2">&quot;2011-01-06 12:54:09&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s0">None</span><span class="s1">): </span><span class="s4">100000000</span><span class="s0">,</span>
    <span class="s1">}</span>
    <span class="s1">df = DataFrame({</span><span class="s2">&quot;PRICE&quot;</span><span class="s1">: prices</span><span class="s0">, </span><span class="s2">&quot;VOLUME&quot;</span><span class="s1">: volumes})</span>
    <span class="s1">result = df.groupby(</span><span class="s2">&quot;PRICE&quot;</span><span class="s1">).VOLUME.describe()</span>
    <span class="s1">data = [</span>
        <span class="s1">df[df.PRICE == </span><span class="s4">24990</span><span class="s1">].VOLUME.describe().values.tolist()</span><span class="s0">,</span>
        <span class="s1">df[df.PRICE == </span><span class="s4">25499</span><span class="s1">].VOLUME.describe().values.tolist()</span><span class="s0">,</span>
    <span class="s1">]</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">data</span><span class="s0">,</span>
        <span class="s1">index=Index([</span><span class="s4">24990</span><span class="s0">, </span><span class="s4">25499</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;PRICE&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">columns=[</span><span class="s2">&quot;count&quot;</span><span class="s0">, </span><span class="s2">&quot;mean&quot;</span><span class="s0">, </span><span class="s2">&quot;std&quot;</span><span class="s0">, </span><span class="s2">&quot;min&quot;</span><span class="s0">, </span><span class="s2">&quot;25%&quot;</span><span class="s0">, </span><span class="s2">&quot;50%&quot;</span><span class="s0">, </span><span class="s2">&quot;75%&quot;</span><span class="s0">, </span><span class="s2">&quot;max&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.filterwarnings(</span>
    <span class="s2">&quot;ignore:&quot;</span>
    <span class="s2">&quot;indexing past lexsort depth may impact performance:&quot;</span>
    <span class="s2">&quot;pandas.errors.PerformanceWarning&quot;</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;as_index&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;keys&quot;</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">&quot;a1&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;a1&quot;</span><span class="s0">, </span><span class="s2">&quot;a2&quot;</span><span class="s1">]])</span>
<span class="s0">def </span><span class="s1">test_describe_with_duplicate_output_column_names(as_index</span><span class="s0">, </span><span class="s1">keys):</span>
    <span class="s5"># GH 35314</span>
    <span class="s1">df = DataFrame(</span>
        <span class="s1">{</span>
            <span class="s2">&quot;a1&quot;</span><span class="s1">: [</span><span class="s4">99</span><span class="s0">, </span><span class="s4">99</span><span class="s0">, </span><span class="s4">99</span><span class="s0">, </span><span class="s4">88</span><span class="s0">, </span><span class="s4">88</span><span class="s0">, </span><span class="s4">88</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;a2&quot;</span><span class="s1">: [</span><span class="s4">99</span><span class="s0">, </span><span class="s4">99</span><span class="s0">, </span><span class="s4">99</span><span class="s0">, </span><span class="s4">88</span><span class="s0">, </span><span class="s4">88</span><span class="s0">, </span><span class="s4">88</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">6</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;c&quot;</span><span class="s1">: [</span><span class="s4">10</span><span class="s0">, </span><span class="s4">20</span><span class="s0">, </span><span class="s4">30</span><span class="s0">, </span><span class="s4">40</span><span class="s0">, </span><span class="s4">50</span><span class="s0">, </span><span class="s4">60</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">columns=[</span><span class="s2">&quot;a1&quot;</span><span class="s0">, </span><span class="s2">&quot;a2&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">copy=</span><span class="s0">False,</span>
    <span class="s1">)</span>
    <span class="s0">if </span><span class="s1">keys == [</span><span class="s2">&quot;a1&quot;</span><span class="s1">]:</span>
        <span class="s1">df = df.drop(columns=</span><span class="s2">&quot;a2&quot;</span><span class="s1">)</span>

    <span class="s1">expected = (</span>
        <span class="s1">DataFrame.from_records(</span>
            <span class="s1">[</span>
                <span class="s1">(</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;count&quot;</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;mean&quot;</span><span class="s0">, </span><span class="s4">5.0</span><span class="s0">, </span><span class="s4">2.0</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;std&quot;</span><span class="s0">, </span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">1.0</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;min&quot;</span><span class="s0">, </span><span class="s4">4.0</span><span class="s0">, </span><span class="s4">1.0</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;25%&quot;</span><span class="s0">, </span><span class="s4">4.5</span><span class="s0">, </span><span class="s4">1.5</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;50%&quot;</span><span class="s0">, </span><span class="s4">5.0</span><span class="s0">, </span><span class="s4">2.0</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;75%&quot;</span><span class="s0">, </span><span class="s4">5.5</span><span class="s0">, </span><span class="s4">2.5</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;max&quot;</span><span class="s0">, </span><span class="s4">6.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;count&quot;</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;mean&quot;</span><span class="s0">, </span><span class="s4">5.0</span><span class="s0">, </span><span class="s4">2.0</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;std&quot;</span><span class="s0">, </span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">1.0</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;min&quot;</span><span class="s0">, </span><span class="s4">4.0</span><span class="s0">, </span><span class="s4">1.0</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;25%&quot;</span><span class="s0">, </span><span class="s4">4.5</span><span class="s0">, </span><span class="s4">1.5</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;50%&quot;</span><span class="s0">, </span><span class="s4">5.0</span><span class="s0">, </span><span class="s4">2.0</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;75%&quot;</span><span class="s0">, </span><span class="s4">5.5</span><span class="s0">, </span><span class="s4">2.5</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;max&quot;</span><span class="s0">, </span><span class="s4">6.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">.set_index([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">.T</span>
    <span class="s1">)</span>
    <span class="s1">expected.columns.names = [</span><span class="s0">None, None</span><span class="s1">]</span>
    <span class="s0">if </span><span class="s1">len(keys) == </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s1">expected.index = MultiIndex(</span>
            <span class="s1">levels=[[</span><span class="s4">88</span><span class="s0">, </span><span class="s4">99</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">88</span><span class="s0">, </span><span class="s4">99</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">codes=[[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">names=[</span><span class="s2">&quot;a1&quot;</span><span class="s0">, </span><span class="s2">&quot;a2&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">expected.index = Index([</span><span class="s4">88</span><span class="s0">, </span><span class="s4">99</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;a1&quot;</span><span class="s1">)</span>

    <span class="s0">if not </span><span class="s1">as_index:</span>
        <span class="s1">expected = expected.reset_index()</span>

    <span class="s1">result = df.groupby(keys</span><span class="s0">, </span><span class="s1">as_index=as_index).describe()</span>

    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_describe_duplicate_columns():</span>
    <span class="s5"># GH#50806</span>
    <span class="s1">df = DataFrame([[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]])</span>
    <span class="s1">df.columns = [</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">gb = df.groupby(df[</span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">result = gb.describe(percentiles=[])</span>

    <span class="s1">columns = [</span><span class="s2">&quot;count&quot;</span><span class="s0">, </span><span class="s2">&quot;mean&quot;</span><span class="s0">, </span><span class="s2">&quot;std&quot;</span><span class="s0">, </span><span class="s2">&quot;min&quot;</span><span class="s0">, </span><span class="s2">&quot;50%&quot;</span><span class="s0">, </span><span class="s2">&quot;max&quot;</span><span class="s1">]</span>
    <span class="s1">frames = [</span>
        <span class="s1">DataFrame([[</span><span class="s4">1.0</span><span class="s0">, </span><span class="s1">val</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">val</span><span class="s0">, </span><span class="s1">val</span><span class="s0">, </span><span class="s1">val]]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">columns=columns)</span>
        <span class="s0">for </span><span class="s1">val </span><span class="s0">in </span><span class="s1">(</span><span class="s4">0.0</span><span class="s0">, </span><span class="s4">2.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s1">)</span>
    <span class="s1">]</span>
    <span class="s1">expected = pd.concat(frames</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">expected.columns = MultiIndex(</span>
        <span class="s1">levels=[[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">columns]</span><span class="s0">,</span>
        <span class="s1">codes=[</span><span class="s4">6 </span><span class="s1">* [</span><span class="s4">0</span><span class="s1">] + </span><span class="s4">6 </span><span class="s1">* [</span><span class="s4">1</span><span class="s1">] + </span><span class="s4">6 </span><span class="s1">* [</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s4">3 </span><span class="s1">* list(range(</span><span class="s4">6</span><span class="s1">))]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">expected.index.names = [</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_groupby_mean_no_overflow():</span>
    <span class="s5"># Regression test for (#22487)</span>
    <span class="s1">df = DataFrame(</span>
        <span class="s1">{</span>
            <span class="s2">&quot;user&quot;</span><span class="s1">: [</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;connections&quot;</span><span class="s1">: [</span><span class="s4">4970</span><span class="s0">, </span><span class="s4">4749</span><span class="s0">, </span><span class="s4">4719</span><span class="s0">, </span><span class="s4">4704</span><span class="s0">, </span><span class="s4">18446744073699999744</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">df.groupby(</span><span class="s2">&quot;user&quot;</span><span class="s1">)[</span><span class="s2">&quot;connections&quot;</span><span class="s1">].mean()[</span><span class="s2">&quot;A&quot;</span><span class="s1">] == </span><span class="s4">3689348814740003840</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;values&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">{</span>
            <span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s0">, </span><span class="s1">pd.NA</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">pd.NA</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">pd.NA</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">{</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]}</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;function&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;mean&quot;</span><span class="s0">, </span><span class="s2">&quot;median&quot;</span><span class="s0">, </span><span class="s2">&quot;var&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_apply_to_nullable_integer_returns_float(values</span><span class="s0">, </span><span class="s1">function):</span>
    <span class="s5"># https://github.com/pandas-dev/pandas/issues/32219</span>
    <span class="s1">output = </span><span class="s4">0.5 </span><span class="s0">if </span><span class="s1">function == </span><span class="s2">&quot;var&quot; </span><span class="s0">else </span><span class="s4">1.5</span>
    <span class="s1">arr = np.array([output] * </span><span class="s4">3</span><span class="s0">, </span><span class="s1">dtype=float)</span>
    <span class="s1">idx = Index([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;Int64&quot;</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame({</span><span class="s2">&quot;b&quot;</span><span class="s1">: arr}</span><span class="s0">, </span><span class="s1">index=idx).astype(</span><span class="s2">&quot;Float64&quot;</span><span class="s1">)</span>

    <span class="s1">groups = DataFrame(values</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;Int64&quot;</span><span class="s1">).groupby(</span><span class="s2">&quot;a&quot;</span><span class="s1">)</span>

    <span class="s1">result = getattr(groups</span><span class="s0">, </span><span class="s1">function)()</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">result = groups.agg(function)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">result = groups.agg([function])</span>
    <span class="s1">expected.columns = MultiIndex.from_tuples([(</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s1">function)])</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;min_count&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">10</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_groupby_sum_mincount_boolean(min_count):</span>
    <span class="s1">b = </span><span class="s0">True</span>
    <span class="s1">a = </span><span class="s0">False</span>
    <span class="s1">na = np.nan</span>
    <span class="s1">dfg = pd.array([b</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">na</span><span class="s0">, </span><span class="s1">na</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;boolean&quot;</span><span class="s1">)</span>

    <span class="s1">df = DataFrame({</span><span class="s2">&quot;A&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">: dfg})</span>
    <span class="s1">result = df.groupby(</span><span class="s2">&quot;A&quot;</span><span class="s1">).sum(min_count=min_count)</span>
    <span class="s0">if </span><span class="s1">min_count == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">expected = DataFrame(</span>
            <span class="s1">{</span><span class="s2">&quot;B&quot;</span><span class="s1">: pd.array([</span><span class="s4">3</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;Int64&quot;</span><span class="s1">)}</span><span class="s0">,</span>
            <span class="s1">index=Index([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;A&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">expected = DataFrame(</span>
            <span class="s1">{</span><span class="s2">&quot;B&quot;</span><span class="s1">: pd.array([pd.NA] * </span><span class="s4">3</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;Int64&quot;</span><span class="s1">)}</span><span class="s0">,</span>
            <span class="s1">index=Index([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;A&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_groupby_sum_below_mincount_nullable_integer():</span>
    <span class="s5"># https://github.com/pandas-dev/pandas/issues/32861</span>
    <span class="s1">df = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">: [</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]}</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;Int64&quot;</span><span class="s1">)</span>
    <span class="s1">grouped = df.groupby(</span><span class="s2">&quot;a&quot;</span><span class="s1">)</span>
    <span class="s1">idx = Index([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;Int64&quot;</span><span class="s1">)</span>

    <span class="s1">result = grouped[</span><span class="s2">&quot;b&quot;</span><span class="s1">].sum(min_count=</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">expected = Series([pd.NA] * </span><span class="s4">3</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;Int64&quot;</span><span class="s0">, </span><span class="s1">index=idx</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;b&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">result = grouped.sum(min_count=</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame({</span><span class="s2">&quot;b&quot;</span><span class="s1">: [pd.NA] * </span><span class="s4">3</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">: [pd.NA] * </span><span class="s4">3</span><span class="s1">}</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;Int64&quot;</span><span class="s0">, </span><span class="s1">index=idx)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_mean_on_timedelta():</span>
    <span class="s5"># GH 17382</span>
    <span class="s1">df = DataFrame({</span><span class="s2">&quot;time&quot;</span><span class="s1">: pd.to_timedelta(range(</span><span class="s4">10</span><span class="s1">))</span><span class="s0">, </span><span class="s2">&quot;cat&quot;</span><span class="s1">: [</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">] * </span><span class="s4">5</span><span class="s1">})</span>
    <span class="s1">result = df.groupby(</span><span class="s2">&quot;cat&quot;</span><span class="s1">)[</span><span class="s2">&quot;time&quot;</span><span class="s1">].mean()</span>
    <span class="s1">expected = Series(</span>
        <span class="s1">pd.to_timedelta([</span><span class="s4">4</span><span class="s0">, </span><span class="s4">5</span><span class="s1">])</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;time&quot;</span><span class="s0">, </span><span class="s1">index=Index([</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;cat&quot;</span><span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_groupby_sum_timedelta_with_nat():</span>
    <span class="s5"># GH#42659</span>
    <span class="s1">df = DataFrame(</span>
        <span class="s1">{</span>
            <span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;b&quot;</span><span class="s1">: [pd.Timedelta(</span><span class="s2">&quot;1d&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pd.Timedelta(</span><span class="s2">&quot;2d&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pd.Timedelta(</span><span class="s2">&quot;3d&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pd.NaT]</span><span class="s0">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">td3 = pd.Timedelta(days=</span><span class="s4">3</span><span class="s1">)</span>

    <span class="s1">gb = df.groupby(</span><span class="s2">&quot;a&quot;</span><span class="s1">)</span>

    <span class="s1">res = gb.sum()</span>
    <span class="s1">expected = DataFrame({</span><span class="s2">&quot;b&quot;</span><span class="s1">: [td3</span><span class="s0">, </span><span class="s1">td3]}</span><span class="s0">, </span><span class="s1">index=Index([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;a&quot;</span><span class="s1">))</span>
    <span class="s1">tm.assert_frame_equal(res</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">res = gb[</span><span class="s2">&quot;b&quot;</span><span class="s1">].sum()</span>
    <span class="s1">tm.assert_series_equal(res</span><span class="s0">, </span><span class="s1">expected[</span><span class="s2">&quot;b&quot;</span><span class="s1">])</span>

    <span class="s1">res = gb[</span><span class="s2">&quot;b&quot;</span><span class="s1">].sum(min_count=</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">expected = Series([td3</span><span class="s0">, </span><span class="s1">pd.NaT]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;m8[ns]&quot;</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s1">index=expected.index)</span>
    <span class="s1">tm.assert_series_equal(res</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;kernel, has_arg&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s2">&quot;all&quot;</span><span class="s0">, False</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;any&quot;</span><span class="s0">, False</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;bfill&quot;</span><span class="s0">, False</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;corr&quot;</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;corrwith&quot;</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;cov&quot;</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;cummax&quot;</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;cummin&quot;</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;cumprod&quot;</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;cumsum&quot;</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;diff&quot;</span><span class="s0">, False</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;ffill&quot;</span><span class="s0">, False</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;fillna&quot;</span><span class="s0">, False</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;first&quot;</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;idxmax&quot;</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;idxmin&quot;</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;last&quot;</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;max&quot;</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;mean&quot;</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;median&quot;</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;min&quot;</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;nth&quot;</span><span class="s0">, False</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;nunique&quot;</span><span class="s0">, False</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;pct_change&quot;</span><span class="s0">, False</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;prod&quot;</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;quantile&quot;</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;sem&quot;</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;skew&quot;</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;std&quot;</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;sum&quot;</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;var&quot;</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;numeric_only&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False, </span><span class="s1">lib.no_default])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;keys&quot;</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">&quot;a1&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;a1&quot;</span><span class="s0">, </span><span class="s2">&quot;a2&quot;</span><span class="s1">]])</span>
<span class="s0">def </span><span class="s1">test_numeric_only(kernel</span><span class="s0">, </span><span class="s1">has_arg</span><span class="s0">, </span><span class="s1">numeric_only</span><span class="s0">, </span><span class="s1">keys):</span>
    <span class="s5"># GH#46072</span>
    <span class="s5"># drops_nuisance: Whether the op drops nuisance columns even when numeric_only=False</span>
    <span class="s5"># has_arg: Whether the op has a numeric_only arg</span>
    <span class="s1">df = DataFrame({</span><span class="s2">&quot;a1&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;a2&quot;</span><span class="s1">: [</span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;a3&quot;</span><span class="s1">: [</span><span class="s4">5</span><span class="s0">, </span><span class="s4">6</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s4">2 </span><span class="s1">* [object]})</span>

    <span class="s1">args = get_groupby_method_args(kernel</span><span class="s0">, </span><span class="s1">df)</span>
    <span class="s1">kwargs = {} </span><span class="s0">if </span><span class="s1">numeric_only </span><span class="s0">is </span><span class="s1">lib.no_default </span><span class="s0">else </span><span class="s1">{</span><span class="s2">&quot;numeric_only&quot;</span><span class="s1">: numeric_only}</span>

    <span class="s1">gb = df.groupby(keys)</span>
    <span class="s1">method = getattr(gb</span><span class="s0">, </span><span class="s1">kernel)</span>
    <span class="s0">if </span><span class="s1">has_arg </span><span class="s0">and </span><span class="s1">numeric_only </span><span class="s0">is True</span><span class="s1">:</span>
        <span class="s5"># Cases where b does not appear in the result</span>
        <span class="s1">result = method(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">assert </span><span class="s2">&quot;b&quot; </span><span class="s0">not in </span><span class="s1">result.columns</span>
    <span class="s0">elif </span><span class="s1">(</span>
        <span class="s5"># kernels that work on any dtype and have numeric_only arg</span>
        <span class="s1">kernel </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;first&quot;</span><span class="s0">, </span><span class="s2">&quot;last&quot;</span><span class="s1">)</span>
        <span class="s0">or </span><span class="s1">(</span>
            <span class="s5"># kernels that work on any dtype and don't have numeric_only arg</span>
            <span class="s1">kernel </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;any&quot;</span><span class="s0">, </span><span class="s2">&quot;all&quot;</span><span class="s0">, </span><span class="s2">&quot;bfill&quot;</span><span class="s0">, </span><span class="s2">&quot;ffill&quot;</span><span class="s0">, </span><span class="s2">&quot;fillna&quot;</span><span class="s0">, </span><span class="s2">&quot;nth&quot;</span><span class="s0">, </span><span class="s2">&quot;nunique&quot;</span><span class="s1">)</span>
            <span class="s0">and </span><span class="s1">numeric_only </span><span class="s0">is </span><span class="s1">lib.no_default</span>
        <span class="s1">)</span>
    <span class="s1">):</span>
        <span class="s1">result = method(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">assert </span><span class="s2">&quot;b&quot; </span><span class="s0">in </span><span class="s1">result.columns</span>
    <span class="s0">elif </span><span class="s1">has_arg:</span>
        <span class="s0">assert </span><span class="s1">numeric_only </span><span class="s0">is not True</span>
        <span class="s5"># kernels that are successful on any dtype were above; this will fail</span>

        <span class="s5"># object dtypes for transformations are not implemented in Cython and</span>
        <span class="s5"># have no Python fallback</span>
        <span class="s1">exception = NotImplementedError </span><span class="s0">if </span><span class="s1">kernel.startswith(</span><span class="s2">&quot;cum&quot;</span><span class="s1">) </span><span class="s0">else </span><span class="s1">TypeError</span>

        <span class="s1">msg = </span><span class="s2">&quot;|&quot;</span><span class="s1">.join(</span>
            <span class="s1">[</span>
                <span class="s2">&quot;not allowed for this dtype&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;cannot be performed against 'object' dtypes&quot;</span><span class="s0">,</span>
                <span class="s5"># On PY39 message is &quot;a number&quot;; on PY310 and after is &quot;a real number&quot;</span>
                <span class="s2">&quot;must be a string or a.* number&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;unsupported operand type&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;function is not implemented for this dtype&quot;</span><span class="s0">,</span>
                <span class="s1">re.escape(</span><span class="s2">f&quot;agg function failed [how-&gt;</span><span class="s0">{</span><span class="s1">kernel</span><span class="s0">}</span><span class="s2">,dtype-&gt;object]&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">kernel == </span><span class="s2">&quot;idxmin&quot;</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s2">&quot;'&lt;' not supported between instances of 'type' and 'type'&quot;</span>
        <span class="s0">elif </span><span class="s1">kernel == </span><span class="s2">&quot;idxmax&quot;</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s2">&quot;'&gt;' not supported between instances of 'type' and 'type'&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(exception</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">method(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">elif not </span><span class="s1">has_arg </span><span class="s0">and </span><span class="s1">numeric_only </span><span class="s0">is not </span><span class="s1">lib.no_default:</span>
        <span class="s0">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;got an unexpected keyword argument 'numeric_only'&quot;</span>
        <span class="s1">):</span>
            <span class="s1">method(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">assert </span><span class="s1">kernel </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;diff&quot;</span><span class="s0">, </span><span class="s2">&quot;pct_change&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">numeric_only </span><span class="s0">is </span><span class="s1">lib.no_default</span>
        <span class="s5"># Doesn't have numeric_only argument and fails on nuisance columns</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">r&quot;unsupported operand type&quot;</span><span class="s1">):</span>
            <span class="s1">method(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">[bool</span><span class="s0">, </span><span class="s1">int</span><span class="s0">, </span><span class="s1">float</span><span class="s0">, </span><span class="s1">object])</span>
<span class="s0">def </span><span class="s1">test_deprecate_numeric_only_series(dtype</span><span class="s0">, </span><span class="s1">groupby_func</span><span class="s0">, </span><span class="s1">request):</span>
    <span class="s5"># GH#46560</span>
    <span class="s1">grouper = [</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span>

    <span class="s1">ser = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">gb = ser.groupby(grouper)</span>

    <span class="s0">if </span><span class="s1">groupby_func == </span><span class="s2">&quot;corrwith&quot;</span><span class="s1">:</span>
        <span class="s5"># corrwith is not implemented on SeriesGroupBy</span>
        <span class="s0">assert not </span><span class="s1">hasattr(gb</span><span class="s0">, </span><span class="s1">groupby_func)</span>
        <span class="s0">return</span>

    <span class="s1">method = getattr(gb</span><span class="s0">, </span><span class="s1">groupby_func)</span>

    <span class="s1">expected_ser = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">expected_gb = expected_ser.groupby(grouper)</span>
    <span class="s1">expected_method = getattr(expected_gb</span><span class="s0">, </span><span class="s1">groupby_func)</span>

    <span class="s1">args = get_groupby_method_args(groupby_func</span><span class="s0">, </span><span class="s1">ser)</span>

    <span class="s1">fails_on_numeric_object = (</span>
        <span class="s2">&quot;corr&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;cov&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;cummax&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;cummin&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;cumprod&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;cumsum&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;quantile&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s5"># ops that give an object result on object input</span>
    <span class="s1">obj_result = (</span>
        <span class="s2">&quot;first&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;last&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;nth&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;bfill&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;ffill&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;shift&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;sum&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;diff&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;pct_change&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;var&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;mean&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;median&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;min&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;max&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;prod&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;skew&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s5"># Test default behavior; kernels that fail may be enabled in the future but kernels</span>
    <span class="s5"># that succeed should not be allowed to fail (without deprecation, at least)</span>
    <span class="s0">if </span><span class="s1">groupby_func </span><span class="s0">in </span><span class="s1">fails_on_numeric_object </span><span class="s0">and </span><span class="s1">dtype </span><span class="s0">is </span><span class="s1">object:</span>
        <span class="s0">if </span><span class="s1">groupby_func == </span><span class="s2">&quot;quantile&quot;</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s2">&quot;cannot be performed against 'object' dtypes&quot;</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s2">&quot;is not supported for object dtype&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">method(*args)</span>
    <span class="s0">elif </span><span class="s1">dtype </span><span class="s0">is </span><span class="s1">object:</span>
        <span class="s1">result = method(*args)</span>
        <span class="s1">expected = expected_method(*args)</span>
        <span class="s0">if </span><span class="s1">groupby_func </span><span class="s0">in </span><span class="s1">obj_result:</span>
            <span class="s1">expected = expected.astype(object)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">has_numeric_only = (</span>
        <span class="s2">&quot;first&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;last&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;max&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;mean&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;median&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;min&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;prod&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;quantile&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;sem&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;skew&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;std&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;sum&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;var&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;cummax&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;cummin&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;cumprod&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;cumsum&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">if </span><span class="s1">groupby_func </span><span class="s0">not in </span><span class="s1">has_numeric_only:</span>
        <span class="s1">msg = </span><span class="s2">&quot;got an unexpected keyword argument 'numeric_only'&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">method(*args</span><span class="s0">, </span><span class="s1">numeric_only=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">dtype </span><span class="s0">is </span><span class="s1">object:</span>
        <span class="s1">msg = </span><span class="s2">&quot;|&quot;</span><span class="s1">.join(</span>
            <span class="s1">[</span>
                <span class="s2">&quot;SeriesGroupBy.sem called with numeric_only=True and dtype object&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;Series.skew does not allow numeric_only=True with non-numeric&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;cum(sum|prod|min|max) is not supported for object dtype&quot;</span><span class="s0">,</span>
                <span class="s2">r&quot;Cannot use numeric_only=True with SeriesGroupBy\..* and non-numeric&quot;</span><span class="s0">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">method(*args</span><span class="s0">, </span><span class="s1">numeric_only=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">dtype == bool </span><span class="s0">and </span><span class="s1">groupby_func == </span><span class="s2">&quot;quantile&quot;</span><span class="s1">:</span>
        <span class="s1">msg = </span><span class="s2">&quot;Allowing bool dtype in SeriesGroupBy.quantile&quot;</span>
        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s5"># GH#51424</span>
            <span class="s1">result = method(*args</span><span class="s0">, </span><span class="s1">numeric_only=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">expected = method(*args</span><span class="s0">, </span><span class="s1">numeric_only=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">result = method(*args</span><span class="s0">, </span><span class="s1">numeric_only=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">expected = method(*args</span><span class="s0">, </span><span class="s1">numeric_only=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">[int</span><span class="s0">, </span><span class="s1">float</span><span class="s0">, </span><span class="s1">object])</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;kwargs&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">{</span><span class="s2">&quot;percentiles&quot;</span><span class="s1">: [</span><span class="s4">0.10</span><span class="s0">, </span><span class="s4">0.20</span><span class="s0">, </span><span class="s4">0.30</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;include&quot;</span><span class="s1">: </span><span class="s2">&quot;all&quot;</span><span class="s0">, </span><span class="s2">&quot;exclude&quot;</span><span class="s1">: </span><span class="s0">None</span><span class="s1">}</span><span class="s0">,</span>
        <span class="s1">{</span><span class="s2">&quot;percentiles&quot;</span><span class="s1">: [</span><span class="s4">0.10</span><span class="s0">, </span><span class="s4">0.20</span><span class="s0">, </span><span class="s4">0.30</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;include&quot;</span><span class="s1">: </span><span class="s0">None, </span><span class="s2">&quot;exclude&quot;</span><span class="s1">: [</span><span class="s2">&quot;int&quot;</span><span class="s1">]}</span><span class="s0">,</span>
        <span class="s1">{</span><span class="s2">&quot;percentiles&quot;</span><span class="s1">: [</span><span class="s4">0.10</span><span class="s0">, </span><span class="s4">0.20</span><span class="s0">, </span><span class="s4">0.30</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;include&quot;</span><span class="s1">: [</span><span class="s2">&quot;int&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;exclude&quot;</span><span class="s1">: </span><span class="s0">None</span><span class="s1">}</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_groupby_empty_dataset(dtype</span><span class="s0">, </span><span class="s1">kwargs):</span>
    <span class="s5"># GH#41575</span>
    <span class="s1">df = DataFrame([[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;C&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">df[</span><span class="s2">&quot;B&quot;</span><span class="s1">] = df[</span><span class="s2">&quot;B&quot;</span><span class="s1">].astype(int)</span>
    <span class="s1">df[</span><span class="s2">&quot;C&quot;</span><span class="s1">] = df[</span><span class="s2">&quot;C&quot;</span><span class="s1">].astype(float)</span>

    <span class="s1">result = df.iloc[:</span><span class="s4">0</span><span class="s1">].groupby(</span><span class="s2">&quot;A&quot;</span><span class="s1">).describe(**kwargs)</span>
    <span class="s1">expected = df.groupby(</span><span class="s2">&quot;A&quot;</span><span class="s1">).describe(**kwargs).reset_index(drop=</span><span class="s0">True</span><span class="s1">).iloc[:</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">result = df.iloc[:</span><span class="s4">0</span><span class="s1">].groupby(</span><span class="s2">&quot;A&quot;</span><span class="s1">).B.describe(**kwargs)</span>
    <span class="s1">expected = df.groupby(</span><span class="s2">&quot;A&quot;</span><span class="s1">).B.describe(**kwargs).reset_index(drop=</span><span class="s0">True</span><span class="s1">).iloc[:</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">expected.index = Index([])</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_corrwith_with_1_axis():</span>
    <span class="s5"># GH 47723</span>
    <span class="s1">df = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s4">3</span><span class="s0">, </span><span class="s4">7</span><span class="s0">, </span><span class="s4">4</span><span class="s1">]})</span>
    <span class="s1">gb = df.groupby(</span><span class="s2">&quot;a&quot;</span><span class="s1">)</span>

    <span class="s1">msg = </span><span class="s2">&quot;DataFrameGroupBy.corrwith with axis=1 is deprecated&quot;</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">result = gb.corrwith(df</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">index = Index(</span>
        <span class="s1">data=[(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)]</span><span class="s0">,</span>
        <span class="s1">name=(</span><span class="s2">&quot;a&quot;</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">expected = Series([np.nan] * </span><span class="s4">6</span><span class="s0">, </span><span class="s1">index=index)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_multiindex_group_all_columns_when_empty(groupby_func):</span>
    <span class="s5"># GH 32464</span>
    <span class="s1">df = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: []</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: []</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">: []}).set_index([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s1">gb = df.groupby([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">group_keys=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">method = getattr(gb</span><span class="s0">, </span><span class="s1">groupby_func)</span>
    <span class="s1">args = get_groupby_method_args(groupby_func</span><span class="s0">, </span><span class="s1">df)</span>

    <span class="s1">result = method(*args).index</span>
    <span class="s1">expected = df.index</span>
    <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_duplicate_columns(request</span><span class="s0">, </span><span class="s1">groupby_func</span><span class="s0">, </span><span class="s1">as_index):</span>
    <span class="s5"># GH#50806</span>
    <span class="s0">if </span><span class="s1">groupby_func == </span><span class="s2">&quot;corrwith&quot;</span><span class="s1">:</span>
        <span class="s1">msg = </span><span class="s2">&quot;GH#50845 - corrwith fails when there are duplicate columns&quot;</span>
        <span class="s1">request.node.add_marker(pytest.mark.xfail(reason=msg))</span>
    <span class="s1">df = DataFrame([[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">7</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">2</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">8</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=list(</span><span class="s2">&quot;abb&quot;</span><span class="s1">))</span>
    <span class="s1">args = get_groupby_method_args(groupby_func</span><span class="s0">, </span><span class="s1">df)</span>
    <span class="s1">gb = df.groupby(</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s1">as_index=as_index)</span>
    <span class="s1">result = getattr(gb</span><span class="s0">, </span><span class="s1">groupby_func)(*args)</span>

    <span class="s1">expected_df = df.set_axis([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">expected_args = get_groupby_method_args(groupby_func</span><span class="s0">, </span><span class="s1">expected_df)</span>
    <span class="s1">expected_gb = expected_df.groupby(</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s1">as_index=as_index)</span>
    <span class="s1">expected = getattr(expected_gb</span><span class="s0">, </span><span class="s1">groupby_func)(*expected_args)</span>
    <span class="s0">if </span><span class="s1">groupby_func </span><span class="s0">not in </span><span class="s1">(</span><span class="s2">&quot;size&quot;</span><span class="s0">, </span><span class="s2">&quot;ngroup&quot;</span><span class="s0">, </span><span class="s2">&quot;cumcount&quot;</span><span class="s1">):</span>
        <span class="s1">expected = expected.rename(columns={</span><span class="s2">&quot;c&quot;</span><span class="s1">: </span><span class="s2">&quot;b&quot;</span><span class="s1">})</span>
    <span class="s1">tm.assert_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;op&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s2">&quot;sum&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;prod&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;min&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;max&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;median&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;mean&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;skew&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;std&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;var&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;sem&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;axis&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;skipna&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;sort&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_regression_allowlist_methods(op</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">skipna</span><span class="s0">, </span><span class="s1">sort):</span>
    <span class="s5"># GH6944</span>
    <span class="s5"># GH 17537</span>
    <span class="s5"># explicitly test the allowlist methods</span>
    <span class="s1">raw_frame = DataFrame([</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s0">if </span><span class="s1">axis == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">frame = raw_frame</span>
        <span class="s1">msg = </span><span class="s2">&quot;The 'axis' keyword in DataFrame.groupby is deprecated and will be&quot;</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">frame = raw_frame.T</span>
        <span class="s1">msg = </span><span class="s2">&quot;DataFrame.groupby with axis=1 is deprecated&quot;</span>

    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">grouped = frame.groupby(level=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">axis=axis</span><span class="s0">, </span><span class="s1">sort=sort)</span>

    <span class="s0">if </span><span class="s1">op == </span><span class="s2">&quot;skew&quot;</span><span class="s1">:</span>
        <span class="s5"># skew has skipna</span>
        <span class="s1">result = getattr(grouped</span><span class="s0">, </span><span class="s1">op)(skipna=skipna)</span>
        <span class="s1">expected = frame.groupby(level=</span><span class="s4">0</span><span class="s1">).apply(</span>
            <span class="s0">lambda </span><span class="s1">h: getattr(h</span><span class="s0">, </span><span class="s1">op)(axis=axis</span><span class="s0">, </span><span class="s1">skipna=skipna)</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">sort:</span>
            <span class="s1">expected = expected.sort_index(axis=axis)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">result = getattr(grouped</span><span class="s0">, </span><span class="s1">op)()</span>
        <span class="s1">expected = frame.groupby(level=</span><span class="s4">0</span><span class="s1">).apply(</span><span class="s0">lambda </span><span class="s1">h: getattr(h</span><span class="s0">, </span><span class="s1">op)(axis=axis))</span>
        <span class="s0">if </span><span class="s1">sort:</span>
            <span class="s1">expected = expected.sort_index(axis=axis)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
</pre>
</body>
</html>