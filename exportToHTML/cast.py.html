<html>
<head>
<title>cast.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
cast.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Routines for casting. 
&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">import </span><span class="s1">datetime </span><span class="s2">as </span><span class="s1">dt</span>
<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s2">,</span>
    <span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">Literal</span><span class="s2">,</span>
    <span class="s1">TypeVar</span><span class="s2">,</span>
    <span class="s1">cast</span><span class="s2">,</span>
    <span class="s1">overload</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">pandas._config </span><span class="s2">import </span><span class="s1">using_pyarrow_string_dtype</span>

<span class="s2">from </span><span class="s1">pandas._libs </span><span class="s2">import </span><span class="s1">lib</span>
<span class="s2">from </span><span class="s1">pandas._libs.missing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">NA</span><span class="s2">,</span>
    <span class="s1">NAType</span><span class="s2">,</span>
    <span class="s1">checknull</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas._libs.tslibs </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">NaT</span><span class="s2">,</span>
    <span class="s1">OutOfBoundsDatetime</span><span class="s2">,</span>
    <span class="s1">OutOfBoundsTimedelta</span><span class="s2">,</span>
    <span class="s1">Timedelta</span><span class="s2">,</span>
    <span class="s1">Timestamp</span><span class="s2">,</span>
    <span class="s1">get_unit_from_dtype</span><span class="s2">,</span>
    <span class="s1">is_supported_unit</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas._libs.tslibs.timedeltas </span><span class="s2">import </span><span class="s1">array_to_timedelta64</span>
<span class="s2">from </span><span class="s1">pandas.errors </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">IntCastingNaNError</span><span class="s2">,</span>
    <span class="s1">LossySetitemError</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ensure_int8</span><span class="s2">,</span>
    <span class="s1">ensure_int16</span><span class="s2">,</span>
    <span class="s1">ensure_int32</span><span class="s2">,</span>
    <span class="s1">ensure_int64</span><span class="s2">,</span>
    <span class="s1">ensure_object</span><span class="s2">,</span>
    <span class="s1">ensure_str</span><span class="s2">,</span>
    <span class="s1">is_bool</span><span class="s2">,</span>
    <span class="s1">is_complex</span><span class="s2">,</span>
    <span class="s1">is_float</span><span class="s2">,</span>
    <span class="s1">is_integer</span><span class="s2">,</span>
    <span class="s1">is_object_dtype</span><span class="s2">,</span>
    <span class="s1">is_scalar</span><span class="s2">,</span>
    <span class="s1">is_string_dtype</span><span class="s2">,</span>
    <span class="s1">pandas_dtype </span><span class="s2">as </span><span class="s1">pandas_dtype_func</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.dtypes </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ArrowDtype</span><span class="s2">,</span>
    <span class="s1">BaseMaskedDtype</span><span class="s2">,</span>
    <span class="s1">CategoricalDtype</span><span class="s2">,</span>
    <span class="s1">DatetimeTZDtype</span><span class="s2">,</span>
    <span class="s1">ExtensionDtype</span><span class="s2">,</span>
    <span class="s1">IntervalDtype</span><span class="s2">,</span>
    <span class="s1">PandasExtensionDtype</span><span class="s2">,</span>
    <span class="s1">PeriodDtype</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.generic </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ABCIndex</span><span class="s2">,</span>
    <span class="s1">ABCSeries</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.inference </span><span class="s2">import </span><span class="s1">is_list_like</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.missing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">is_valid_na_for_dtype</span><span class="s2">,</span>
    <span class="s1">isna</span><span class="s2">,</span>
    <span class="s1">na_value_for_dtype</span><span class="s2">,</span>
    <span class="s1">notna</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">from </span><span class="s1">pandas.io._util </span><span class="s2">import </span><span class="s1">_arrow_dtype_mapping</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s2">from </span><span class="s1">collections.abc </span><span class="s2">import </span><span class="s1">(</span>
        <span class="s1">Sequence</span><span class="s2">,</span>
        <span class="s1">Sized</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s2">from </span><span class="s1">pandas._typing </span><span class="s2">import </span><span class="s1">(</span>
        <span class="s1">ArrayLike</span><span class="s2">,</span>
        <span class="s1">Dtype</span><span class="s2">,</span>
        <span class="s1">DtypeObj</span><span class="s2">,</span>
        <span class="s1">NumpyIndexT</span><span class="s2">,</span>
        <span class="s1">Scalar</span><span class="s2">,</span>
        <span class="s1">npt</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">Index</span>
    <span class="s2">from </span><span class="s1">pandas.core.arrays </span><span class="s2">import </span><span class="s1">(</span>
        <span class="s1">Categorical</span><span class="s2">,</span>
        <span class="s1">DatetimeArray</span><span class="s2">,</span>
        <span class="s1">ExtensionArray</span><span class="s2">,</span>
        <span class="s1">IntervalArray</span><span class="s2">,</span>
        <span class="s1">PeriodArray</span><span class="s2">,</span>
        <span class="s1">TimedeltaArray</span><span class="s2">,</span>
    <span class="s1">)</span>


<span class="s1">_int8_max = np.iinfo(np.int8).max</span>
<span class="s1">_int16_max = np.iinfo(np.int16).max</span>
<span class="s1">_int32_max = np.iinfo(np.int32).max</span>

<span class="s1">_dtype_obj = np.dtype(object)</span>

<span class="s1">NumpyArrayT = TypeVar(</span><span class="s3">&quot;NumpyArrayT&quot;</span><span class="s2">, </span><span class="s1">bound=np.ndarray)</span>


<span class="s2">def </span><span class="s1">maybe_convert_platform(</span>
    <span class="s1">values: list | tuple | range | np.ndarray | ExtensionArray</span><span class="s2">,</span>
<span class="s1">) -&gt; ArrayLike:</span>
    <span class="s0">&quot;&quot;&quot;try to do platform conversion, allow ndarray or list here&quot;&quot;&quot;</span>
    <span class="s1">arr: ArrayLike</span>

    <span class="s2">if </span><span class="s1">isinstance(values</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">, </span><span class="s1">range)):</span>
        <span class="s1">arr = construct_1d_object_array_from_listlike(values)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s4"># The caller is responsible for ensuring that we have np.ndarray</span>
        <span class="s4">#  or ExtensionArray here.</span>
        <span class="s1">arr = values</span>

    <span class="s2">if </span><span class="s1">arr.dtype == _dtype_obj:</span>
        <span class="s1">arr = cast(np.ndarray</span><span class="s2">, </span><span class="s1">arr)</span>
        <span class="s1">arr = lib.maybe_convert_objects(arr)</span>

    <span class="s2">return </span><span class="s1">arr</span>


<span class="s2">def </span><span class="s1">is_nested_object(obj) -&gt; bool:</span>
    <span class="s0">&quot;&quot;&quot; 
    return a boolean if we have a nested object, e.g. a Series with 1 or 
    more Series elements 
 
    This may not be necessarily be performant. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">bool(</span>
        <span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">ABCSeries)</span>
        <span class="s2">and </span><span class="s1">is_object_dtype(obj.dtype)</span>
        <span class="s2">and </span><span class="s1">any(isinstance(v</span><span class="s2">, </span><span class="s1">ABCSeries) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">obj._values)</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">maybe_box_datetimelike(value: Scalar</span><span class="s2">, </span><span class="s1">dtype: Dtype | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None</span><span class="s1">) -&gt; Scalar:</span>
    <span class="s0">&quot;&quot;&quot; 
    Cast scalar to Timestamp or Timedelta if scalar is datetime-like 
    and dtype is not object. 
 
    Parameters 
    ---------- 
    value : scalar 
    dtype : Dtype, optional 
 
    Returns 
    ------- 
    scalar 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">dtype == _dtype_obj:</span>
        <span class="s2">pass</span>
    <span class="s2">elif </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">(np.datetime64</span><span class="s2">, </span><span class="s1">dt.datetime)):</span>
        <span class="s1">value = Timestamp(value)</span>
    <span class="s2">elif </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">(np.timedelta64</span><span class="s2">, </span><span class="s1">dt.timedelta)):</span>
        <span class="s1">value = Timedelta(value)</span>

    <span class="s2">return </span><span class="s1">value</span>


<span class="s2">def </span><span class="s1">maybe_box_native(value: Scalar | </span><span class="s2">None </span><span class="s1">| NAType) -&gt; Scalar | </span><span class="s2">None </span><span class="s1">| NAType:</span>
    <span class="s0">&quot;&quot;&quot; 
    If passed a scalar cast the scalar to a python native type. 
 
    Parameters 
    ---------- 
    value : scalar or Series 
 
    Returns 
    ------- 
    scalar or Series 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">is_float(value):</span>
        <span class="s1">value = float(value)</span>
    <span class="s2">elif </span><span class="s1">is_integer(value):</span>
        <span class="s1">value = int(value)</span>
    <span class="s2">elif </span><span class="s1">is_bool(value):</span>
        <span class="s1">value = bool(value)</span>
    <span class="s2">elif </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">(np.datetime64</span><span class="s2">, </span><span class="s1">np.timedelta64)):</span>
        <span class="s1">value = maybe_box_datetimelike(value)</span>
    <span class="s2">elif </span><span class="s1">value </span><span class="s2">is </span><span class="s1">NA:</span>
        <span class="s1">value = </span><span class="s2">None</span>
    <span class="s2">return </span><span class="s1">value</span>


<span class="s2">def </span><span class="s1">_maybe_unbox_datetimelike(value: Scalar</span><span class="s2">, </span><span class="s1">dtype: DtypeObj) -&gt; Scalar:</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert a Timedelta or Timestamp to timedelta64 or datetime64 for setting 
    into a numpy array.  Failing to unbox would risk dropping nanoseconds. 
 
    Notes 
    ----- 
    Caller is responsible for checking dtype.kind in &quot;mM&quot; 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">is_valid_na_for_dtype(value</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s4"># GH#36541: can't fill array directly with pd.NaT</span>
        <span class="s4"># &gt; np.empty(10, dtype=&quot;datetime64[ns]&quot;).fill(pd.NaT)</span>
        <span class="s4"># ValueError: cannot convert float NaN to integer</span>
        <span class="s1">value = dtype.type(</span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">Timestamp):</span>
        <span class="s2">if </span><span class="s1">value.tz </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">value = value.to_datetime64()</span>
        <span class="s2">elif not </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">DatetimeTZDtype):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Cannot unbox tzaware Timestamp to tznaive dtype&quot;</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">Timedelta):</span>
        <span class="s1">value = value.to_timedelta64()</span>

    <span class="s1">_disallow_mismatched_datetimelike(value</span><span class="s2">, </span><span class="s1">dtype)</span>
    <span class="s2">return </span><span class="s1">value</span>


<span class="s2">def </span><span class="s1">_disallow_mismatched_datetimelike(value</span><span class="s2">, </span><span class="s1">dtype: DtypeObj):</span>
    <span class="s0">&quot;&quot;&quot; 
    numpy allows np.array(dt64values, dtype=&quot;timedelta64[ns]&quot;) and 
    vice-versa, but we do not want to allow this, so we need to 
    check explicitly 
    &quot;&quot;&quot;</span>
    <span class="s1">vdtype = getattr(value</span><span class="s2">, </span><span class="s3">&quot;dtype&quot;</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">vdtype </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return</span>
    <span class="s2">elif </span><span class="s1">(vdtype.kind == </span><span class="s3">&quot;m&quot; </span><span class="s2">and </span><span class="s1">dtype.kind == </span><span class="s3">&quot;M&quot;</span><span class="s1">) </span><span class="s2">or </span><span class="s1">(</span>
        <span class="s1">vdtype.kind == </span><span class="s3">&quot;M&quot; </span><span class="s2">and </span><span class="s1">dtype.kind == </span><span class="s3">&quot;m&quot;</span>
    <span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;Cannot cast </span><span class="s2">{</span><span class="s1">repr(value)</span><span class="s2">} </span><span class="s3">to </span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>


<span class="s1">@overload</span>
<span class="s2">def </span><span class="s1">maybe_downcast_to_dtype(result: np.ndarray</span><span class="s2">, </span><span class="s1">dtype: str | np.dtype) -&gt; np.ndarray:</span>
    <span class="s1">...</span>


<span class="s1">@overload</span>
<span class="s2">def </span><span class="s1">maybe_downcast_to_dtype(result: ExtensionArray</span><span class="s2">, </span><span class="s1">dtype: str | np.dtype) -&gt; ArrayLike:</span>
    <span class="s1">...</span>


<span class="s2">def </span><span class="s1">maybe_downcast_to_dtype(result: ArrayLike</span><span class="s2">, </span><span class="s1">dtype: str | np.dtype) -&gt; ArrayLike:</span>
    <span class="s0">&quot;&quot;&quot; 
    try to cast to the specified dtype (e.g. convert back to bool/int 
    or could be an astype of float64-&gt;float32 
    &quot;&quot;&quot;</span>
    <span class="s1">do_round = </span><span class="s2">False</span>

    <span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s2">if </span><span class="s1">dtype == </span><span class="s3">&quot;infer&quot;</span><span class="s1">:</span>
            <span class="s1">inferred_type = lib.infer_dtype(result</span><span class="s2">, </span><span class="s1">skipna=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">inferred_type == </span><span class="s3">&quot;boolean&quot;</span><span class="s1">:</span>
                <span class="s1">dtype = </span><span class="s3">&quot;bool&quot;</span>
            <span class="s2">elif </span><span class="s1">inferred_type == </span><span class="s3">&quot;integer&quot;</span><span class="s1">:</span>
                <span class="s1">dtype = </span><span class="s3">&quot;int64&quot;</span>
            <span class="s2">elif </span><span class="s1">inferred_type == </span><span class="s3">&quot;datetime64&quot;</span><span class="s1">:</span>
                <span class="s1">dtype = </span><span class="s3">&quot;datetime64[ns]&quot;</span>
            <span class="s2">elif </span><span class="s1">inferred_type </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;timedelta&quot;</span><span class="s2">, </span><span class="s3">&quot;timedelta64&quot;</span><span class="s1">]:</span>
                <span class="s1">dtype = </span><span class="s3">&quot;timedelta64[ns]&quot;</span>

            <span class="s4"># try to upcast here</span>
            <span class="s2">elif </span><span class="s1">inferred_type == </span><span class="s3">&quot;floating&quot;</span><span class="s1">:</span>
                <span class="s1">dtype = </span><span class="s3">&quot;int64&quot;</span>
                <span class="s2">if </span><span class="s1">issubclass(result.dtype.type</span><span class="s2">, </span><span class="s1">np.number):</span>
                    <span class="s1">do_round = </span><span class="s2">True</span>

            <span class="s2">else</span><span class="s1">:</span>
                <span class="s4"># TODO: complex?  what if result is already non-object?</span>
                <span class="s1">dtype = </span><span class="s3">&quot;object&quot;</span>

        <span class="s1">dtype = np.dtype(dtype)</span>

    <span class="s2">if not </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">np.dtype):</span>
        <span class="s4"># enforce our signature annotation</span>
        <span class="s2">raise </span><span class="s1">TypeError(dtype)  </span><span class="s4"># pragma: no cover</span>

    <span class="s1">converted = maybe_downcast_numeric(result</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">do_round)</span>
    <span class="s2">if </span><span class="s1">converted </span><span class="s2">is not </span><span class="s1">result:</span>
        <span class="s2">return </span><span class="s1">converted</span>

    <span class="s4"># a datetimelike</span>
    <span class="s4"># GH12821, iNaT is cast to float</span>
    <span class="s2">if </span><span class="s1">dtype.kind </span><span class="s2">in </span><span class="s3">&quot;mM&quot; </span><span class="s2">and </span><span class="s1">result.dtype.kind </span><span class="s2">in </span><span class="s3">&quot;if&quot;</span><span class="s1">:</span>
        <span class="s1">result = result.astype(dtype)</span>

    <span class="s2">elif </span><span class="s1">dtype.kind == </span><span class="s3">&quot;m&quot; </span><span class="s2">and </span><span class="s1">result.dtype == _dtype_obj:</span>
        <span class="s4"># test_where_downcast_to_td64</span>
        <span class="s1">result = cast(np.ndarray</span><span class="s2">, </span><span class="s1">result)</span>
        <span class="s1">result = array_to_timedelta64(result)</span>

    <span class="s2">elif </span><span class="s1">dtype == np.dtype(</span><span class="s3">&quot;M8[ns]&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">result.dtype == _dtype_obj:</span>
        <span class="s1">result = cast(np.ndarray</span><span class="s2">, </span><span class="s1">result)</span>
        <span class="s2">return </span><span class="s1">np.asarray(maybe_cast_to_datetime(result</span><span class="s2">, </span><span class="s1">dtype=dtype))</span>

    <span class="s2">return </span><span class="s1">result</span>


<span class="s1">@overload</span>
<span class="s2">def </span><span class="s1">maybe_downcast_numeric(</span>
    <span class="s1">result: np.ndarray</span><span class="s2">, </span><span class="s1">dtype: np.dtype</span><span class="s2">, </span><span class="s1">do_round: bool = </span><span class="s2">False</span>
<span class="s1">) -&gt; np.ndarray:</span>
    <span class="s1">...</span>


<span class="s1">@overload</span>
<span class="s2">def </span><span class="s1">maybe_downcast_numeric(</span>
    <span class="s1">result: ExtensionArray</span><span class="s2">, </span><span class="s1">dtype: DtypeObj</span><span class="s2">, </span><span class="s1">do_round: bool = </span><span class="s2">False</span>
<span class="s1">) -&gt; ArrayLike:</span>
    <span class="s1">...</span>


<span class="s2">def </span><span class="s1">maybe_downcast_numeric(</span>
    <span class="s1">result: ArrayLike</span><span class="s2">, </span><span class="s1">dtype: DtypeObj</span><span class="s2">, </span><span class="s1">do_round: bool = </span><span class="s2">False</span>
<span class="s1">) -&gt; ArrayLike:</span>
    <span class="s0">&quot;&quot;&quot; 
    Subset of maybe_downcast_to_dtype restricted to numeric dtypes. 
 
    Parameters 
    ---------- 
    result : ndarray or ExtensionArray 
    dtype : np.dtype or ExtensionDtype 
    do_round : bool 
 
    Returns 
    ------- 
    ndarray or ExtensionArray 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">np.dtype) </span><span class="s2">or not </span><span class="s1">isinstance(result.dtype</span><span class="s2">, </span><span class="s1">np.dtype):</span>
        <span class="s4"># e.g. SparseDtype has no itemsize attr</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">trans(x):</span>
        <span class="s2">if </span><span class="s1">do_round:</span>
            <span class="s2">return </span><span class="s1">x.round()</span>
        <span class="s2">return </span><span class="s1">x</span>

    <span class="s2">if </span><span class="s1">dtype.kind == result.dtype.kind:</span>
        <span class="s4"># don't allow upcasts here (except if empty)</span>
        <span class="s2">if </span><span class="s1">result.dtype.itemsize &lt;= dtype.itemsize </span><span class="s2">and </span><span class="s1">result.size:</span>
            <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">if </span><span class="s1">dtype.kind </span><span class="s2">in </span><span class="s3">&quot;biu&quot;</span><span class="s1">:</span>
        <span class="s2">if not </span><span class="s1">result.size:</span>
            <span class="s4"># if we don't have any elements, just astype it</span>
            <span class="s2">return </span><span class="s1">trans(result).astype(dtype)</span>

        <span class="s4"># do a test on the first element, if it fails then we are done</span>
        <span class="s1">r = result.ravel()</span>
        <span class="s1">arr = np.array([r[</span><span class="s5">0</span><span class="s1">]])</span>

        <span class="s2">if </span><span class="s1">isna(arr).any():</span>
            <span class="s4"># if we have any nulls, then we are done</span>
            <span class="s2">return </span><span class="s1">result</span>

        <span class="s2">elif not </span><span class="s1">isinstance(r[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">(np.integer</span><span class="s2">, </span><span class="s1">np.floating</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">bool)):</span>
            <span class="s4"># a comparable, e.g. a Decimal may slip in here</span>
            <span class="s2">return </span><span class="s1">result</span>

        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">issubclass(result.dtype.type</span><span class="s2">, </span><span class="s1">(np.object_</span><span class="s2">, </span><span class="s1">np.number))</span>
            <span class="s2">and </span><span class="s1">notna(result).all()</span>
        <span class="s1">):</span>
            <span class="s1">new_result = trans(result).astype(dtype)</span>
            <span class="s2">if </span><span class="s1">new_result.dtype.kind == </span><span class="s3">&quot;O&quot; </span><span class="s2">or </span><span class="s1">result.dtype.kind == </span><span class="s3">&quot;O&quot;</span><span class="s1">:</span>
                <span class="s4"># np.allclose may raise TypeError on object-dtype</span>
                <span class="s2">if </span><span class="s1">(new_result == result).all():</span>
                    <span class="s2">return </span><span class="s1">new_result</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">np.allclose(new_result</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">0</span><span class="s1">):</span>
                    <span class="s2">return </span><span class="s1">new_result</span>

    <span class="s2">elif </span><span class="s1">(</span>
        <span class="s1">issubclass(dtype.type</span><span class="s2">, </span><span class="s1">np.floating)</span>
        <span class="s2">and </span><span class="s1">result.dtype.kind != </span><span class="s3">&quot;b&quot;</span>
        <span class="s2">and not </span><span class="s1">is_string_dtype(result.dtype)</span>
    <span class="s1">):</span>
        <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s1">warnings.filterwarnings(</span>
                <span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s3">&quot;overflow encountered in cast&quot;</span><span class="s2">, </span><span class="s1">RuntimeWarning</span>
            <span class="s1">)</span>
            <span class="s1">new_result = result.astype(dtype)</span>

        <span class="s4"># Adjust tolerances based on floating point size</span>
        <span class="s1">size_tols = {</span><span class="s5">4</span><span class="s1">: </span><span class="s5">5e-4</span><span class="s2">, </span><span class="s5">8</span><span class="s1">: </span><span class="s5">5e-8</span><span class="s2">, </span><span class="s5">16</span><span class="s1">: </span><span class="s5">5e-16</span><span class="s1">}</span>

        <span class="s1">atol = size_tols.get(new_result.dtype.itemsize</span><span class="s2">, </span><span class="s5">0.0</span><span class="s1">)</span>

        <span class="s4"># Check downcast float values are still equal within 7 digits when</span>
        <span class="s4"># converting from float64 to float32</span>
        <span class="s2">if </span><span class="s1">np.allclose(new_result</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, </span><span class="s1">equal_nan=</span><span class="s2">True, </span><span class="s1">rtol=</span><span class="s5">0.0</span><span class="s2">, </span><span class="s1">atol=atol):</span>
            <span class="s2">return </span><span class="s1">new_result</span>

    <span class="s2">elif </span><span class="s1">dtype.kind == result.dtype.kind == </span><span class="s3">&quot;c&quot;</span><span class="s1">:</span>
        <span class="s1">new_result = result.astype(dtype)</span>

        <span class="s2">if </span><span class="s1">np.array_equal(new_result</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, </span><span class="s1">equal_nan=</span><span class="s2">True</span><span class="s1">):</span>
            <span class="s4"># TODO: use tolerance like we do for float?</span>
            <span class="s2">return </span><span class="s1">new_result</span>

    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">maybe_upcast_numeric_to_64bit(arr: NumpyIndexT) -&gt; NumpyIndexT:</span>
    <span class="s0">&quot;&quot;&quot; 
    If array is a int/uint/float bit size lower than 64 bit, upcast it to 64 bit. 
 
    Parameters 
    ---------- 
    arr : ndarray or ExtensionArray 
 
    Returns 
    ------- 
    ndarray or ExtensionArray 
    &quot;&quot;&quot;</span>
    <span class="s1">dtype = arr.dtype</span>
    <span class="s2">if </span><span class="s1">dtype.kind == </span><span class="s3">&quot;i&quot; </span><span class="s2">and </span><span class="s1">dtype != np.int64:</span>
        <span class="s2">return </span><span class="s1">arr.astype(np.int64)</span>
    <span class="s2">elif </span><span class="s1">dtype.kind == </span><span class="s3">&quot;u&quot; </span><span class="s2">and </span><span class="s1">dtype != np.uint64:</span>
        <span class="s2">return </span><span class="s1">arr.astype(np.uint64)</span>
    <span class="s2">elif </span><span class="s1">dtype.kind == </span><span class="s3">&quot;f&quot; </span><span class="s2">and </span><span class="s1">dtype != np.float64:</span>
        <span class="s2">return </span><span class="s1">arr.astype(np.float64)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">arr</span>


<span class="s2">def </span><span class="s1">maybe_cast_pointwise_result(</span>
    <span class="s1">result: ArrayLike</span><span class="s2">,</span>
    <span class="s1">dtype: DtypeObj</span><span class="s2">,</span>
    <span class="s1">numeric_only: bool = </span><span class="s2">False,</span>
    <span class="s1">same_dtype: bool = </span><span class="s2">True,</span>
<span class="s1">) -&gt; ArrayLike:</span>
    <span class="s0">&quot;&quot;&quot; 
    Try casting result of a pointwise operation back to the original dtype if 
    appropriate. 
 
    Parameters 
    ---------- 
    result : array-like 
        Result to cast. 
    dtype : np.dtype or ExtensionDtype 
        Input Series from which result was calculated. 
    numeric_only : bool, default False 
        Whether to cast only numerics or datetimes as well. 
    same_dtype : bool, default True 
        Specify dtype when calling _from_sequence 
 
    Returns 
    ------- 
    result : array-like 
        result maybe casted to the dtype. 
    &quot;&quot;&quot;</span>

    <span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">ExtensionDtype):</span>
        <span class="s2">if not </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">(CategoricalDtype</span><span class="s2">, </span><span class="s1">DatetimeTZDtype)):</span>
            <span class="s4"># TODO: avoid this special-casing</span>
            <span class="s4"># We have to special case categorical so as not to upcast</span>
            <span class="s4"># things like counts back to categorical</span>

            <span class="s1">cls = dtype.construct_array_type()</span>
            <span class="s2">if </span><span class="s1">same_dtype:</span>
                <span class="s1">result = _maybe_cast_to_extension_array(cls</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">result = _maybe_cast_to_extension_array(cls</span><span class="s2">, </span><span class="s1">result)</span>

    <span class="s2">elif </span><span class="s1">(numeric_only </span><span class="s2">and </span><span class="s1">dtype.kind </span><span class="s2">in </span><span class="s3">&quot;iufcb&quot;</span><span class="s1">) </span><span class="s2">or not </span><span class="s1">numeric_only:</span>
        <span class="s1">result = maybe_downcast_to_dtype(result</span><span class="s2">, </span><span class="s1">dtype)</span>

    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">_maybe_cast_to_extension_array(</span>
    <span class="s1">cls: type[ExtensionArray]</span><span class="s2">, </span><span class="s1">obj: ArrayLike</span><span class="s2">, </span><span class="s1">dtype: ExtensionDtype | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None</span>
<span class="s1">) -&gt; ArrayLike:</span>
    <span class="s0">&quot;&quot;&quot; 
    Call to `_from_sequence` that returns the object unchanged on Exception. 
 
    Parameters 
    ---------- 
    cls : class, subclass of ExtensionArray 
    obj : arraylike 
        Values to pass to cls._from_sequence 
    dtype : ExtensionDtype, optional 
 
    Returns 
    ------- 
    ExtensionArray or obj 
    &quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">pandas.core.arrays.string_ </span><span class="s2">import </span><span class="s1">BaseStringArray</span>

    <span class="s4"># Everything can be converted to StringArrays, but we may not want to convert</span>
    <span class="s2">if </span><span class="s1">issubclass(cls</span><span class="s2">, </span><span class="s1">BaseStringArray) </span><span class="s2">and </span><span class="s1">lib.infer_dtype(obj) != </span><span class="s3">&quot;string&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">obj</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">result = cls._from_sequence(obj</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s2">except </span><span class="s1">Exception:</span>
        <span class="s4"># We can't predict what downstream EA constructors may raise</span>
        <span class="s1">result = obj</span>
    <span class="s2">return </span><span class="s1">result</span>


<span class="s1">@overload</span>
<span class="s2">def </span><span class="s1">ensure_dtype_can_hold_na(dtype: np.dtype) -&gt; np.dtype:</span>
    <span class="s1">...</span>


<span class="s1">@overload</span>
<span class="s2">def </span><span class="s1">ensure_dtype_can_hold_na(dtype: ExtensionDtype) -&gt; ExtensionDtype:</span>
    <span class="s1">...</span>


<span class="s2">def </span><span class="s1">ensure_dtype_can_hold_na(dtype: DtypeObj) -&gt; DtypeObj:</span>
    <span class="s0">&quot;&quot;&quot; 
    If we have a dtype that cannot hold NA values, find the best match that can. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">ExtensionDtype):</span>
        <span class="s2">if </span><span class="s1">dtype._can_hold_na:</span>
            <span class="s2">return </span><span class="s1">dtype</span>
        <span class="s2">elif </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">IntervalDtype):</span>
            <span class="s4"># TODO(GH#45349): don't special-case IntervalDtype, allow</span>
            <span class="s4">#  overriding instead of returning object below.</span>
            <span class="s2">return </span><span class="s1">IntervalDtype(np.float64</span><span class="s2">, </span><span class="s1">closed=dtype.closed)</span>
        <span class="s2">return </span><span class="s1">_dtype_obj</span>
    <span class="s2">elif </span><span class="s1">dtype.kind == </span><span class="s3">&quot;b&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">_dtype_obj</span>
    <span class="s2">elif </span><span class="s1">dtype.kind </span><span class="s2">in </span><span class="s3">&quot;iu&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">np.dtype(np.float64)</span>
    <span class="s2">return </span><span class="s1">dtype</span>


<span class="s1">_canonical_nans = {</span>
    <span class="s1">np.datetime64: np.datetime64(</span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">np.timedelta64: np.timedelta64(</span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">type(np.nan): np.nan</span><span class="s2">,</span>
<span class="s1">}</span>


<span class="s2">def </span><span class="s1">maybe_promote(dtype: np.dtype</span><span class="s2">, </span><span class="s1">fill_value=np.nan):</span>
    <span class="s0">&quot;&quot;&quot; 
    Find the minimal dtype that can hold both the given dtype and fill_value. 
 
    Parameters 
    ---------- 
    dtype : np.dtype 
    fill_value : scalar, default np.nan 
 
    Returns 
    ------- 
    dtype 
        Upcasted from dtype argument if necessary. 
    fill_value 
        Upcasted from fill_value argument if necessary. 
 
    Raises 
    ------ 
    ValueError 
        If fill_value is a non-scalar and dtype is not object. 
    &quot;&quot;&quot;</span>
    <span class="s1">orig = fill_value</span>
    <span class="s1">orig_is_nat = </span><span class="s2">False</span>
    <span class="s2">if </span><span class="s1">checknull(fill_value):</span>
        <span class="s4"># https://github.com/pandas-dev/pandas/pull/39692#issuecomment-1441051740</span>
        <span class="s4">#  avoid cache misses with NaN/NaT values that are not singletons</span>
        <span class="s2">if </span><span class="s1">fill_value </span><span class="s2">is not </span><span class="s1">NA:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">orig_is_nat = np.isnat(fill_value)</span>
            <span class="s2">except </span><span class="s1">TypeError:</span>
                <span class="s2">pass</span>

        <span class="s1">fill_value = _canonical_nans.get(type(fill_value)</span><span class="s2">, </span><span class="s1">fill_value)</span>

    <span class="s4"># for performance, we are using a cached version of the actual implementation</span>
    <span class="s4"># of the function in _maybe_promote. However, this doesn't always work (in case</span>
    <span class="s4"># of non-hashable arguments), so we fallback to the actual implementation if needed</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s4"># error: Argument 3 to &quot;__call__&quot; of &quot;_lru_cache_wrapper&quot; has incompatible type</span>
        <span class="s4"># &quot;Type[Any]&quot;; expected &quot;Hashable&quot;  [arg-type]</span>
        <span class="s1">dtype</span><span class="s2">, </span><span class="s1">fill_value = _maybe_promote_cached(</span>
            <span class="s1">dtype</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">, </span><span class="s1">type(fill_value)  </span><span class="s4"># type: ignore[arg-type]</span>
        <span class="s1">)</span>
    <span class="s2">except </span><span class="s1">TypeError:</span>
        <span class="s4"># if fill_value is not hashable (required for caching)</span>
        <span class="s1">dtype</span><span class="s2">, </span><span class="s1">fill_value = _maybe_promote(dtype</span><span class="s2">, </span><span class="s1">fill_value)</span>

    <span class="s2">if </span><span class="s1">(dtype == _dtype_obj </span><span class="s2">and </span><span class="s1">orig </span><span class="s2">is not None</span><span class="s1">) </span><span class="s2">or </span><span class="s1">(</span>
        <span class="s1">orig_is_nat </span><span class="s2">and </span><span class="s1">np.datetime_data(orig)[</span><span class="s5">0</span><span class="s1">] != </span><span class="s3">&quot;ns&quot;</span>
    <span class="s1">):</span>
        <span class="s4"># GH#51592,53497 restore our potentially non-canonical fill_value</span>
        <span class="s1">fill_value = orig</span>
    <span class="s2">return </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">fill_value</span>


<span class="s1">@functools.lru_cache</span>
<span class="s2">def </span><span class="s1">_maybe_promote_cached(dtype</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">, </span><span class="s1">fill_value_type):</span>
    <span class="s4"># The cached version of _maybe_promote below</span>
    <span class="s4"># This also use fill_value_type as (unused) argument to use this in the</span>
    <span class="s4"># cache lookup -&gt; to differentiate 1 and True</span>
    <span class="s2">return </span><span class="s1">_maybe_promote(dtype</span><span class="s2">, </span><span class="s1">fill_value)</span>


<span class="s2">def </span><span class="s1">_maybe_promote(dtype: np.dtype</span><span class="s2">, </span><span class="s1">fill_value=np.nan):</span>
    <span class="s4"># The actual implementation of the function, use `maybe_promote` above for</span>
    <span class="s4"># a cached version.</span>
    <span class="s2">if not </span><span class="s1">is_scalar(fill_value):</span>
        <span class="s4"># with object dtype there is nothing to promote, and the user can</span>
        <span class="s4">#  pass pretty much any weird fill_value they like</span>
        <span class="s2">if </span><span class="s1">dtype != object:</span>
            <span class="s4"># with object dtype there is nothing to promote, and the user can</span>
            <span class="s4">#  pass pretty much any weird fill_value they like</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;fill_value must be a scalar&quot;</span><span class="s1">)</span>
        <span class="s1">dtype = _dtype_obj</span>
        <span class="s2">return </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">fill_value</span>

    <span class="s2">if </span><span class="s1">is_valid_na_for_dtype(fill_value</span><span class="s2">, </span><span class="s1">dtype) </span><span class="s2">and </span><span class="s1">dtype.kind </span><span class="s2">in </span><span class="s3">&quot;iufcmM&quot;</span><span class="s1">:</span>
        <span class="s1">dtype = ensure_dtype_can_hold_na(dtype)</span>
        <span class="s1">fv = na_value_for_dtype(dtype)</span>
        <span class="s2">return </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">fv</span>

    <span class="s2">elif </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">CategoricalDtype):</span>
        <span class="s2">if </span><span class="s1">fill_value </span><span class="s2">in </span><span class="s1">dtype.categories </span><span class="s2">or </span><span class="s1">isna(fill_value):</span>
            <span class="s2">return </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">fill_value</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">object</span><span class="s2">, </span><span class="s1">ensure_object(fill_value)</span>

    <span class="s2">elif </span><span class="s1">isna(fill_value):</span>
        <span class="s1">dtype = _dtype_obj</span>
        <span class="s2">if </span><span class="s1">fill_value </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s4"># but we retain e.g. pd.NA</span>
            <span class="s1">fill_value = np.nan</span>
        <span class="s2">return </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">fill_value</span>

    <span class="s4"># returns tuple of (dtype, fill_value)</span>
    <span class="s2">if </span><span class="s1">issubclass(dtype.type</span><span class="s2">, </span><span class="s1">np.datetime64):</span>
        <span class="s1">inferred</span><span class="s2">, </span><span class="s1">fv = infer_dtype_from_scalar(fill_value)</span>
        <span class="s2">if </span><span class="s1">inferred == dtype:</span>
            <span class="s2">return </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">fv</span>

        <span class="s2">from </span><span class="s1">pandas.core.arrays </span><span class="s2">import </span><span class="s1">DatetimeArray</span>

        <span class="s1">dta = DatetimeArray._from_sequence([]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;M8[ns]&quot;</span><span class="s1">)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">fv = dta._validate_setitem_value(fill_value)</span>
            <span class="s2">return </span><span class="s1">dta.dtype</span><span class="s2">, </span><span class="s1">fv</span>
        <span class="s2">except </span><span class="s1">(ValueError</span><span class="s2">, </span><span class="s1">TypeError):</span>
            <span class="s2">return </span><span class="s1">_dtype_obj</span><span class="s2">, </span><span class="s1">fill_value</span>

    <span class="s2">elif </span><span class="s1">issubclass(dtype.type</span><span class="s2">, </span><span class="s1">np.timedelta64):</span>
        <span class="s1">inferred</span><span class="s2">, </span><span class="s1">fv = infer_dtype_from_scalar(fill_value)</span>
        <span class="s2">if </span><span class="s1">inferred == dtype:</span>
            <span class="s2">return </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">fv</span>

        <span class="s2">elif </span><span class="s1">inferred.kind == </span><span class="s3">&quot;m&quot;</span><span class="s1">:</span>
            <span class="s4"># different unit, e.g. passed np.timedelta64(24, &quot;h&quot;) with dtype=m8[ns]</span>
            <span class="s4"># see if we can losslessly cast it to our dtype</span>
            <span class="s1">unit = np.datetime_data(dtype)[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">td = Timedelta(fill_value).as_unit(unit</span><span class="s2">, </span><span class="s1">round_ok=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s2">except </span><span class="s1">OutOfBoundsTimedelta:</span>
                <span class="s2">return </span><span class="s1">_dtype_obj</span><span class="s2">, </span><span class="s1">fill_value</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">td.asm8</span>

        <span class="s2">return </span><span class="s1">_dtype_obj</span><span class="s2">, </span><span class="s1">fill_value</span>

    <span class="s2">elif </span><span class="s1">is_float(fill_value):</span>
        <span class="s2">if </span><span class="s1">issubclass(dtype.type</span><span class="s2">, </span><span class="s1">np.bool_):</span>
            <span class="s1">dtype = np.dtype(np.object_)</span>

        <span class="s2">elif </span><span class="s1">issubclass(dtype.type</span><span class="s2">, </span><span class="s1">np.integer):</span>
            <span class="s1">dtype = np.dtype(np.float64)</span>

        <span class="s2">elif </span><span class="s1">dtype.kind == </span><span class="s3">&quot;f&quot;</span><span class="s1">:</span>
            <span class="s1">mst = np.min_scalar_type(fill_value)</span>
            <span class="s2">if </span><span class="s1">mst &gt; dtype:</span>
                <span class="s4"># e.g. mst is np.float64 and dtype is np.float32</span>
                <span class="s1">dtype = mst</span>

        <span class="s2">elif </span><span class="s1">dtype.kind == </span><span class="s3">&quot;c&quot;</span><span class="s1">:</span>
            <span class="s1">mst = np.min_scalar_type(fill_value)</span>
            <span class="s1">dtype = np.promote_types(dtype</span><span class="s2">, </span><span class="s1">mst)</span>

    <span class="s2">elif </span><span class="s1">is_bool(fill_value):</span>
        <span class="s2">if not </span><span class="s1">issubclass(dtype.type</span><span class="s2">, </span><span class="s1">np.bool_):</span>
            <span class="s1">dtype = np.dtype(np.object_)</span>

    <span class="s2">elif </span><span class="s1">is_integer(fill_value):</span>
        <span class="s2">if </span><span class="s1">issubclass(dtype.type</span><span class="s2">, </span><span class="s1">np.bool_):</span>
            <span class="s1">dtype = np.dtype(np.object_)</span>

        <span class="s2">elif </span><span class="s1">issubclass(dtype.type</span><span class="s2">, </span><span class="s1">np.integer):</span>
            <span class="s2">if not </span><span class="s1">np.can_cast(fill_value</span><span class="s2">, </span><span class="s1">dtype):</span>
                <span class="s4"># upcast to prevent overflow</span>
                <span class="s1">mst = np.min_scalar_type(fill_value)</span>
                <span class="s1">dtype = np.promote_types(dtype</span><span class="s2">, </span><span class="s1">mst)</span>
                <span class="s2">if </span><span class="s1">dtype.kind == </span><span class="s3">&quot;f&quot;</span><span class="s1">:</span>
                    <span class="s4"># Case where we disagree with numpy</span>
                    <span class="s1">dtype = np.dtype(np.object_)</span>

    <span class="s2">elif </span><span class="s1">is_complex(fill_value):</span>
        <span class="s2">if </span><span class="s1">issubclass(dtype.type</span><span class="s2">, </span><span class="s1">np.bool_):</span>
            <span class="s1">dtype = np.dtype(np.object_)</span>

        <span class="s2">elif </span><span class="s1">issubclass(dtype.type</span><span class="s2">, </span><span class="s1">(np.integer</span><span class="s2">, </span><span class="s1">np.floating)):</span>
            <span class="s1">mst = np.min_scalar_type(fill_value)</span>
            <span class="s1">dtype = np.promote_types(dtype</span><span class="s2">, </span><span class="s1">mst)</span>

        <span class="s2">elif </span><span class="s1">dtype.kind == </span><span class="s3">&quot;c&quot;</span><span class="s1">:</span>
            <span class="s1">mst = np.min_scalar_type(fill_value)</span>
            <span class="s2">if </span><span class="s1">mst &gt; dtype:</span>
                <span class="s4"># e.g. mst is np.complex128 and dtype is np.complex64</span>
                <span class="s1">dtype = mst</span>

    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">dtype = np.dtype(np.object_)</span>

    <span class="s4"># in case we have a string that looked like a number</span>
    <span class="s2">if </span><span class="s1">issubclass(dtype.type</span><span class="s2">, </span><span class="s1">(bytes</span><span class="s2">, </span><span class="s1">str)):</span>
        <span class="s1">dtype = np.dtype(np.object_)</span>

    <span class="s1">fill_value = _ensure_dtype_type(fill_value</span><span class="s2">, </span><span class="s1">dtype)</span>
    <span class="s2">return </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">fill_value</span>


<span class="s2">def </span><span class="s1">_ensure_dtype_type(value</span><span class="s2">, </span><span class="s1">dtype: np.dtype):</span>
    <span class="s0">&quot;&quot;&quot; 
    Ensure that the given value is an instance of the given dtype. 
 
    e.g. if out dtype is np.complex64_, we should have an instance of that 
    as opposed to a python complex object. 
 
    Parameters 
    ---------- 
    value : object 
    dtype : np.dtype 
 
    Returns 
    ------- 
    object 
    &quot;&quot;&quot;</span>
    <span class="s4"># Start with exceptions in which we do _not_ cast to numpy types</span>

    <span class="s2">if </span><span class="s1">dtype == _dtype_obj:</span>
        <span class="s2">return </span><span class="s1">value</span>

    <span class="s4"># Note: before we get here we have already excluded isna(value)</span>
    <span class="s2">return </span><span class="s1">dtype.type(value)</span>


<span class="s2">def </span><span class="s1">infer_dtype_from(val) -&gt; tuple[DtypeObj</span><span class="s2">, </span><span class="s1">Any]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Interpret the dtype from a scalar or array. 
 
    Parameters 
    ---------- 
    val : object 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">is_list_like(val):</span>
        <span class="s2">return </span><span class="s1">infer_dtype_from_scalar(val)</span>
    <span class="s2">return </span><span class="s1">infer_dtype_from_array(val)</span>


<span class="s2">def </span><span class="s1">infer_dtype_from_scalar(val) -&gt; tuple[DtypeObj</span><span class="s2">, </span><span class="s1">Any]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Interpret the dtype from a scalar. 
 
    Parameters 
    ---------- 
    val : object 
    &quot;&quot;&quot;</span>
    <span class="s1">dtype: DtypeObj = _dtype_obj</span>

    <span class="s4"># a 1-element ndarray</span>
    <span class="s2">if </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
        <span class="s2">if </span><span class="s1">val.ndim != </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s3">&quot;invalid ndarray passed to infer_dtype_from_scalar&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

        <span class="s1">dtype = val.dtype</span>
        <span class="s1">val = lib.item_from_zerodim(val)</span>

    <span class="s2">elif </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s4"># If we create an empty array using a string to infer</span>
        <span class="s4"># the dtype, NumPy will only allocate one character per entry</span>
        <span class="s4"># so this is kind of bad. Alternately we could use np.repeat</span>
        <span class="s4"># instead of np.empty (but then you still don't want things</span>
        <span class="s4"># coming out as np.str_!</span>

        <span class="s1">dtype = _dtype_obj</span>
        <span class="s2">if </span><span class="s1">using_pyarrow_string_dtype():</span>
            <span class="s2">from </span><span class="s1">pandas.core.arrays.string_ </span><span class="s2">import </span><span class="s1">StringDtype</span>

            <span class="s1">dtype = StringDtype(storage=</span><span class="s3">&quot;pyarrow_numpy&quot;</span><span class="s1">)</span>

    <span class="s2">elif </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">(np.datetime64</span><span class="s2">, </span><span class="s1">dt.datetime)):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">val = Timestamp(val)</span>
        <span class="s2">except </span><span class="s1">OutOfBoundsDatetime:</span>
            <span class="s2">return </span><span class="s1">_dtype_obj</span><span class="s2">, </span><span class="s1">val</span>

        <span class="s2">if </span><span class="s1">val </span><span class="s2">is </span><span class="s1">NaT </span><span class="s2">or </span><span class="s1">val.tz </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">val = val.to_datetime64()</span>
            <span class="s1">dtype = val.dtype</span>
            <span class="s4"># TODO: test with datetime(2920, 10, 1) based on test_replace_dtypes</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">dtype = DatetimeTZDtype(unit=val.unit</span><span class="s2">, </span><span class="s1">tz=val.tz)</span>

    <span class="s2">elif </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">(np.timedelta64</span><span class="s2">, </span><span class="s1">dt.timedelta)):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">val = Timedelta(val)</span>
        <span class="s2">except </span><span class="s1">(OutOfBoundsTimedelta</span><span class="s2">, </span><span class="s1">OverflowError):</span>
            <span class="s1">dtype = _dtype_obj</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">val </span><span class="s2">is </span><span class="s1">NaT:</span>
                <span class="s1">val = np.timedelta64(</span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">val = val.asm8</span>
            <span class="s1">dtype = val.dtype</span>

    <span class="s2">elif </span><span class="s1">is_bool(val):</span>
        <span class="s1">dtype = np.dtype(np.bool_)</span>

    <span class="s2">elif </span><span class="s1">is_integer(val):</span>
        <span class="s2">if </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">np.integer):</span>
            <span class="s1">dtype = np.dtype(type(val))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">dtype = np.dtype(np.int64)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">np.array(val</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s2">except </span><span class="s1">OverflowError:</span>
            <span class="s1">dtype = np.array(val).dtype</span>

    <span class="s2">elif </span><span class="s1">is_float(val):</span>
        <span class="s2">if </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">np.floating):</span>
            <span class="s1">dtype = np.dtype(type(val))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">dtype = np.dtype(np.float64)</span>

    <span class="s2">elif </span><span class="s1">is_complex(val):</span>
        <span class="s1">dtype = np.dtype(np.complex128)</span>

    <span class="s2">if </span><span class="s1">lib.is_period(val):</span>
        <span class="s1">dtype = PeriodDtype(freq=val.freq)</span>
    <span class="s2">elif </span><span class="s1">lib.is_interval(val):</span>
        <span class="s1">subtype = infer_dtype_from_scalar(val.left)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">dtype = IntervalDtype(subtype=subtype</span><span class="s2">, </span><span class="s1">closed=val.closed)</span>

    <span class="s2">return </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">val</span>


<span class="s2">def </span><span class="s1">dict_compat(d: dict[Scalar</span><span class="s2">, </span><span class="s1">Scalar]) -&gt; dict[Scalar</span><span class="s2">, </span><span class="s1">Scalar]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert datetimelike-keyed dicts to a Timestamp-keyed dict. 
 
    Parameters 
    ---------- 
    d: dict-like object 
 
    Returns 
    ------- 
    dict 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">{maybe_box_datetimelike(key): value </span><span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">d.items()}</span>


<span class="s2">def </span><span class="s1">infer_dtype_from_array(arr) -&gt; tuple[DtypeObj</span><span class="s2">, </span><span class="s1">ArrayLike]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Infer the dtype from an array. 
 
    Parameters 
    ---------- 
    arr : array 
 
    Returns 
    ------- 
    tuple (pandas-compat dtype, array) 
 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.asarray([1, '1']) 
    array(['1', '1'], dtype='&lt;U21') 
 
    &gt;&gt;&gt; infer_dtype_from_array([1, '1']) 
    (dtype('O'), [1, '1']) 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(arr</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
        <span class="s2">return </span><span class="s1">arr.dtype</span><span class="s2">, </span><span class="s1">arr</span>

    <span class="s2">if not </span><span class="s1">is_list_like(arr):</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;'arr' must be list-like&quot;</span><span class="s1">)</span>

    <span class="s1">arr_dtype = getattr(arr</span><span class="s2">, </span><span class="s3">&quot;dtype&quot;</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">isinstance(arr_dtype</span><span class="s2">, </span><span class="s1">ExtensionDtype):</span>
        <span class="s2">return </span><span class="s1">arr.dtype</span><span class="s2">, </span><span class="s1">arr</span>

    <span class="s2">elif </span><span class="s1">isinstance(arr</span><span class="s2">, </span><span class="s1">ABCSeries):</span>
        <span class="s2">return </span><span class="s1">arr.dtype</span><span class="s2">, </span><span class="s1">np.asarray(arr)</span>

    <span class="s4"># don't force numpy coerce with nan's</span>
    <span class="s1">inferred = lib.infer_dtype(arr</span><span class="s2">, </span><span class="s1">skipna=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">inferred </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;string&quot;</span><span class="s2">, </span><span class="s3">&quot;bytes&quot;</span><span class="s2">, </span><span class="s3">&quot;mixed&quot;</span><span class="s2">, </span><span class="s3">&quot;mixed-integer&quot;</span><span class="s1">]:</span>
        <span class="s2">return </span><span class="s1">(np.dtype(np.object_)</span><span class="s2">, </span><span class="s1">arr)</span>

    <span class="s1">arr = np.asarray(arr)</span>
    <span class="s2">return </span><span class="s1">arr.dtype</span><span class="s2">, </span><span class="s1">arr</span>


<span class="s2">def </span><span class="s1">_maybe_infer_dtype_type(element):</span>
    <span class="s0">&quot;&quot;&quot; 
    Try to infer an object's dtype, for use in arithmetic ops. 
 
    Uses `element.dtype` if that's available. 
    Objects implementing the iterator protocol are cast to a NumPy array, 
    and from there the array's type is used. 
 
    Parameters 
    ---------- 
    element : object 
        Possibly has a `.dtype` attribute, and possibly the iterator 
        protocol. 
 
    Returns 
    ------- 
    tipo : type 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from collections import namedtuple 
    &gt;&gt;&gt; Foo = namedtuple(&quot;Foo&quot;, &quot;dtype&quot;) 
    &gt;&gt;&gt; _maybe_infer_dtype_type(Foo(np.dtype(&quot;i8&quot;))) 
    dtype('int64') 
    &quot;&quot;&quot;</span>
    <span class="s1">tipo = </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">hasattr(element</span><span class="s2">, </span><span class="s3">&quot;dtype&quot;</span><span class="s1">):</span>
        <span class="s1">tipo = element.dtype</span>
    <span class="s2">elif </span><span class="s1">is_list_like(element):</span>
        <span class="s1">element = np.asarray(element)</span>
        <span class="s1">tipo = element.dtype</span>
    <span class="s2">return </span><span class="s1">tipo</span>


<span class="s2">def </span><span class="s1">invalidate_string_dtypes(dtype_set: set[DtypeObj]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Change string like dtypes to object for 
    ``DataFrame.select_dtypes()``. 
    &quot;&quot;&quot;</span>
    <span class="s4"># error: Argument 1 to &lt;set&gt; has incompatible type &quot;Type[generic]&quot;; expected</span>
    <span class="s4"># &quot;Union[dtype[Any], ExtensionDtype, None]&quot;</span>
    <span class="s4"># error: Argument 2 to &lt;set&gt; has incompatible type &quot;Type[generic]&quot;; expected</span>
    <span class="s4"># &quot;Union[dtype[Any], ExtensionDtype, None]&quot;</span>
    <span class="s1">non_string_dtypes = dtype_set - {</span>
        <span class="s1">np.dtype(</span><span class="s3">&quot;S&quot;</span><span class="s1">).type</span><span class="s2">,  </span><span class="s4"># type: ignore[arg-type]</span>
        <span class="s1">np.dtype(</span><span class="s3">&quot;&lt;U&quot;</span><span class="s1">).type</span><span class="s2">,  </span><span class="s4"># type: ignore[arg-type]</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">non_string_dtypes != dtype_set:</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;string dtypes are not allowed, use 'object' instead&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">coerce_indexer_dtype(indexer</span><span class="s2">, </span><span class="s1">categories) -&gt; np.ndarray:</span>
    <span class="s0">&quot;&quot;&quot;coerce the indexer input array to the smallest dtype possible&quot;&quot;&quot;</span>
    <span class="s1">length = len(categories)</span>
    <span class="s2">if </span><span class="s1">length &lt; _int8_max:</span>
        <span class="s2">return </span><span class="s1">ensure_int8(indexer)</span>
    <span class="s2">elif </span><span class="s1">length &lt; _int16_max:</span>
        <span class="s2">return </span><span class="s1">ensure_int16(indexer)</span>
    <span class="s2">elif </span><span class="s1">length &lt; _int32_max:</span>
        <span class="s2">return </span><span class="s1">ensure_int32(indexer)</span>
    <span class="s2">return </span><span class="s1">ensure_int64(indexer)</span>


<span class="s2">def </span><span class="s1">convert_dtypes(</span>
    <span class="s1">input_array: ArrayLike</span><span class="s2">,</span>
    <span class="s1">convert_string: bool = </span><span class="s2">True,</span>
    <span class="s1">convert_integer: bool = </span><span class="s2">True,</span>
    <span class="s1">convert_boolean: bool = </span><span class="s2">True,</span>
    <span class="s1">convert_floating: bool = </span><span class="s2">True,</span>
    <span class="s1">infer_objects: bool = </span><span class="s2">False,</span>
    <span class="s1">dtype_backend: Literal[</span><span class="s3">&quot;numpy_nullable&quot;</span><span class="s2">, </span><span class="s3">&quot;pyarrow&quot;</span><span class="s1">] = </span><span class="s3">&quot;numpy_nullable&quot;</span><span class="s2">,</span>
<span class="s1">) -&gt; DtypeObj:</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert objects to best possible type, and optionally, 
    to types supporting ``pd.NA``. 
 
    Parameters 
    ---------- 
    input_array : ExtensionArray or np.ndarray 
    convert_string : bool, default True 
        Whether object dtypes should be converted to ``StringDtype()``. 
    convert_integer : bool, default True 
        Whether, if possible, conversion can be done to integer extension types. 
    convert_boolean : bool, defaults True 
        Whether object dtypes should be converted to ``BooleanDtypes()``. 
    convert_floating : bool, defaults True 
        Whether, if possible, conversion can be done to floating extension types. 
        If `convert_integer` is also True, preference will be give to integer 
        dtypes if the floats can be faithfully casted to integers. 
    infer_objects : bool, defaults False 
        Whether to also infer objects to float/int if possible. Is only hit if the 
        object array contains pd.NA. 
    dtype_backend : {'numpy_nullable', 'pyarrow'}, default 'numpy_nullable' 
        Back-end data type applied to the resultant :class:`DataFrame` 
        (still experimental). Behaviour is as follows: 
 
        * ``&quot;numpy_nullable&quot;``: returns nullable-dtype-backed :class:`DataFrame` 
          (default). 
        * ``&quot;pyarrow&quot;``: returns pyarrow-backed nullable :class:`ArrowDtype` 
          DataFrame. 
 
        .. versionadded:: 2.0 
 
    Returns 
    ------- 
    np.dtype, or ExtensionDtype 
    &quot;&quot;&quot;</span>
    <span class="s1">inferred_dtype: str | DtypeObj</span>

    <span class="s2">if </span><span class="s1">(</span>
        <span class="s1">convert_string </span><span class="s2">or </span><span class="s1">convert_integer </span><span class="s2">or </span><span class="s1">convert_boolean </span><span class="s2">or </span><span class="s1">convert_floating</span>
    <span class="s1">) </span><span class="s2">and </span><span class="s1">isinstance(input_array</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
        <span class="s2">if </span><span class="s1">input_array.dtype == object:</span>
            <span class="s1">inferred_dtype = lib.infer_dtype(input_array)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">inferred_dtype = input_array.dtype</span>

        <span class="s2">if </span><span class="s1">is_string_dtype(inferred_dtype):</span>
            <span class="s2">if not </span><span class="s1">convert_string </span><span class="s2">or </span><span class="s1">inferred_dtype == </span><span class="s3">&quot;bytes&quot;</span><span class="s1">:</span>
                <span class="s1">inferred_dtype = input_array.dtype</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">inferred_dtype = pandas_dtype_func(</span><span class="s3">&quot;string&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">convert_integer:</span>
            <span class="s1">target_int_dtype = pandas_dtype_func(</span><span class="s3">&quot;Int64&quot;</span><span class="s1">)</span>

            <span class="s2">if </span><span class="s1">input_array.dtype.kind </span><span class="s2">in </span><span class="s3">&quot;iu&quot;</span><span class="s1">:</span>
                <span class="s2">from </span><span class="s1">pandas.core.arrays.integer </span><span class="s2">import </span><span class="s1">NUMPY_INT_TO_DTYPE</span>

                <span class="s1">inferred_dtype = NUMPY_INT_TO_DTYPE.get(</span>
                    <span class="s1">input_array.dtype</span><span class="s2">, </span><span class="s1">target_int_dtype</span>
                <span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">input_array.dtype.kind </span><span class="s2">in </span><span class="s3">&quot;fcb&quot;</span><span class="s1">:</span>
                <span class="s4"># TODO: de-dup with maybe_cast_to_integer_array?</span>
                <span class="s1">arr = input_array[notna(input_array)]</span>
                <span class="s2">if </span><span class="s1">(arr.astype(int) == arr).all():</span>
                    <span class="s1">inferred_dtype = target_int_dtype</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">inferred_dtype = input_array.dtype</span>
            <span class="s2">elif </span><span class="s1">(</span>
                <span class="s1">infer_objects</span>
                <span class="s2">and </span><span class="s1">input_array.dtype == object</span>
                <span class="s2">and </span><span class="s1">(isinstance(inferred_dtype</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">inferred_dtype == </span><span class="s3">&quot;integer&quot;</span><span class="s1">)</span>
            <span class="s1">):</span>
                <span class="s1">inferred_dtype = target_int_dtype</span>

        <span class="s2">if </span><span class="s1">convert_floating:</span>
            <span class="s2">if </span><span class="s1">input_array.dtype.kind </span><span class="s2">in </span><span class="s3">&quot;fcb&quot;</span><span class="s1">:</span>
                <span class="s4"># i.e. numeric but not integer</span>
                <span class="s2">from </span><span class="s1">pandas.core.arrays.floating </span><span class="s2">import </span><span class="s1">NUMPY_FLOAT_TO_DTYPE</span>

                <span class="s1">inferred_float_dtype: DtypeObj = NUMPY_FLOAT_TO_DTYPE.get(</span>
                    <span class="s1">input_array.dtype</span><span class="s2">, </span><span class="s1">pandas_dtype_func(</span><span class="s3">&quot;Float64&quot;</span><span class="s1">)</span>
                <span class="s1">)</span>
                <span class="s4"># if we could also convert to integer, check if all floats</span>
                <span class="s4"># are actually integers</span>
                <span class="s2">if </span><span class="s1">convert_integer:</span>
                    <span class="s4"># TODO: de-dup with maybe_cast_to_integer_array?</span>
                    <span class="s1">arr = input_array[notna(input_array)]</span>
                    <span class="s2">if </span><span class="s1">(arr.astype(int) == arr).all():</span>
                        <span class="s1">inferred_dtype = pandas_dtype_func(</span><span class="s3">&quot;Int64&quot;</span><span class="s1">)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">inferred_dtype = inferred_float_dtype</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">inferred_dtype = inferred_float_dtype</span>
            <span class="s2">elif </span><span class="s1">(</span>
                <span class="s1">infer_objects</span>
                <span class="s2">and </span><span class="s1">input_array.dtype == object</span>
                <span class="s2">and </span><span class="s1">(</span>
                    <span class="s1">isinstance(inferred_dtype</span><span class="s2">, </span><span class="s1">str)</span>
                    <span class="s2">and </span><span class="s1">inferred_dtype == </span><span class="s3">&quot;mixed-integer-float&quot;</span>
                <span class="s1">)</span>
            <span class="s1">):</span>
                <span class="s1">inferred_dtype = pandas_dtype_func(</span><span class="s3">&quot;Float64&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">convert_boolean:</span>
            <span class="s2">if </span><span class="s1">input_array.dtype.kind == </span><span class="s3">&quot;b&quot;</span><span class="s1">:</span>
                <span class="s1">inferred_dtype = pandas_dtype_func(</span><span class="s3">&quot;boolean&quot;</span><span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">isinstance(inferred_dtype</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">inferred_dtype == </span><span class="s3">&quot;boolean&quot;</span><span class="s1">:</span>
                <span class="s1">inferred_dtype = pandas_dtype_func(</span><span class="s3">&quot;boolean&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">isinstance(inferred_dtype</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s4"># If we couldn't do anything else, then we retain the dtype</span>
            <span class="s1">inferred_dtype = input_array.dtype</span>

    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">inferred_dtype = input_array.dtype</span>

    <span class="s2">if </span><span class="s1">dtype_backend == </span><span class="s3">&quot;pyarrow&quot;</span><span class="s1">:</span>
        <span class="s2">from </span><span class="s1">pandas.core.arrays.arrow.array </span><span class="s2">import </span><span class="s1">to_pyarrow_type</span>
        <span class="s2">from </span><span class="s1">pandas.core.arrays.string_ </span><span class="s2">import </span><span class="s1">StringDtype</span>

        <span class="s2">assert not </span><span class="s1">isinstance(inferred_dtype</span><span class="s2">, </span><span class="s1">str)</span>

        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">(convert_integer </span><span class="s2">and </span><span class="s1">inferred_dtype.kind </span><span class="s2">in </span><span class="s3">&quot;iu&quot;</span><span class="s1">)</span>
            <span class="s2">or </span><span class="s1">(convert_floating </span><span class="s2">and </span><span class="s1">inferred_dtype.kind </span><span class="s2">in </span><span class="s3">&quot;fc&quot;</span><span class="s1">)</span>
            <span class="s2">or </span><span class="s1">(convert_boolean </span><span class="s2">and </span><span class="s1">inferred_dtype.kind == </span><span class="s3">&quot;b&quot;</span><span class="s1">)</span>
            <span class="s2">or </span><span class="s1">(convert_string </span><span class="s2">and </span><span class="s1">isinstance(inferred_dtype</span><span class="s2">, </span><span class="s1">StringDtype))</span>
            <span class="s2">or </span><span class="s1">(</span>
                <span class="s1">inferred_dtype.kind </span><span class="s2">not in </span><span class="s3">&quot;iufcb&quot;</span>
                <span class="s2">and not </span><span class="s1">isinstance(inferred_dtype</span><span class="s2">, </span><span class="s1">StringDtype)</span>
            <span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s2">if </span><span class="s1">isinstance(inferred_dtype</span><span class="s2">, </span><span class="s1">PandasExtensionDtype) </span><span class="s2">and not </span><span class="s1">isinstance(</span>
                <span class="s1">inferred_dtype</span><span class="s2">, </span><span class="s1">DatetimeTZDtype</span>
            <span class="s1">):</span>
                <span class="s1">base_dtype = inferred_dtype.base</span>
            <span class="s2">elif </span><span class="s1">isinstance(inferred_dtype</span><span class="s2">, </span><span class="s1">(BaseMaskedDtype</span><span class="s2">, </span><span class="s1">ArrowDtype)):</span>
                <span class="s1">base_dtype = inferred_dtype.numpy_dtype</span>
            <span class="s2">elif </span><span class="s1">isinstance(inferred_dtype</span><span class="s2">, </span><span class="s1">StringDtype):</span>
                <span class="s1">base_dtype = np.dtype(str)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">base_dtype = inferred_dtype</span>
            <span class="s1">pa_type = to_pyarrow_type(base_dtype)</span>
            <span class="s2">if </span><span class="s1">pa_type </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">inferred_dtype = ArrowDtype(pa_type)</span>
    <span class="s2">elif </span><span class="s1">dtype_backend == </span><span class="s3">&quot;numpy_nullable&quot; </span><span class="s2">and </span><span class="s1">isinstance(inferred_dtype</span><span class="s2">, </span><span class="s1">ArrowDtype):</span>
        <span class="s4"># GH 53648</span>
        <span class="s1">inferred_dtype = _arrow_dtype_mapping()[inferred_dtype.pyarrow_dtype]</span>

    <span class="s4"># error: Incompatible return value type (got &quot;Union[str, Union[dtype[Any],</span>
    <span class="s4"># ExtensionDtype]]&quot;, expected &quot;Union[dtype[Any], ExtensionDtype]&quot;)</span>
    <span class="s2">return </span><span class="s1">inferred_dtype  </span><span class="s4"># type: ignore[return-value]</span>


<span class="s2">def </span><span class="s1">maybe_infer_to_datetimelike(</span>
    <span class="s1">value: npt.NDArray[np.object_]</span><span class="s2">,</span>
<span class="s1">) -&gt; np.ndarray | DatetimeArray | TimedeltaArray | PeriodArray | IntervalArray:</span>
    <span class="s0">&quot;&quot;&quot; 
    we might have a array (or single object) that is datetime like, 
    and no dtype is passed don't change the value unless we find a 
    datetime/timedelta set 
 
    this is pretty strict in that a datetime/timedelta is REQUIRED 
    in addition to possible nulls/string likes 
 
    Parameters 
    ---------- 
    value : np.ndarray[object] 
 
    Returns 
    ------- 
    np.ndarray, DatetimeArray, TimedeltaArray, PeriodArray, or IntervalArray 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">np.ndarray) </span><span class="s2">or </span><span class="s1">value.dtype != object:</span>
        <span class="s4"># Caller is responsible for passing only ndarray[object]</span>
        <span class="s2">raise </span><span class="s1">TypeError(type(value))  </span><span class="s4"># pragma: no cover</span>
    <span class="s2">if </span><span class="s1">value.ndim != </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s4"># Caller is responsible</span>
        <span class="s2">raise </span><span class="s1">ValueError(value.ndim)  </span><span class="s4"># pragma: no cover</span>

    <span class="s2">if not </span><span class="s1">len(value):</span>
        <span class="s2">return </span><span class="s1">value</span>

    <span class="s4"># error: Incompatible return value type (got &quot;Union[ExtensionArray,</span>
    <span class="s4"># ndarray[Any, Any]]&quot;, expected &quot;Union[ndarray[Any, Any], DatetimeArray,</span>
    <span class="s4"># TimedeltaArray, PeriodArray, IntervalArray]&quot;)</span>
    <span class="s2">return </span><span class="s1">lib.maybe_convert_objects(  </span><span class="s4"># type: ignore[return-value]</span>
        <span class="s1">value</span><span class="s2">,</span>
        <span class="s4"># Here we do not convert numeric dtypes, as if we wanted that,</span>
        <span class="s4">#  numpy would have done it for us.</span>
        <span class="s1">convert_numeric=</span><span class="s2">False,</span>
        <span class="s1">convert_non_numeric=</span><span class="s2">True,</span>
        <span class="s1">dtype_if_all_nat=np.dtype(</span><span class="s3">&quot;M8[ns]&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">maybe_cast_to_datetime(</span>
    <span class="s1">value: np.ndarray | list</span><span class="s2">, </span><span class="s1">dtype: np.dtype</span>
<span class="s1">) -&gt; ExtensionArray | np.ndarray:</span>
    <span class="s0">&quot;&quot;&quot; 
    try to cast the array/value to a datetimelike dtype, converting float 
    nan to iNaT 
 
    Caller is responsible for handling ExtensionDtype cases and non dt64/td64 
    cases. 
    &quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">pandas.core.arrays.datetimes </span><span class="s2">import </span><span class="s1">DatetimeArray</span>
    <span class="s2">from </span><span class="s1">pandas.core.arrays.timedeltas </span><span class="s2">import </span><span class="s1">TimedeltaArray</span>

    <span class="s2">assert </span><span class="s1">dtype.kind </span><span class="s2">in </span><span class="s3">&quot;mM&quot;</span>
    <span class="s2">if not </span><span class="s1">is_list_like(value):</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;value must be listlike&quot;</span><span class="s1">)</span>

    <span class="s4"># TODO: _from_sequence would raise ValueError in cases where</span>
    <span class="s4">#  _ensure_nanosecond_dtype raises TypeError</span>
    <span class="s1">_ensure_nanosecond_dtype(dtype)</span>

    <span class="s2">if </span><span class="s1">lib.is_np_dtype(dtype</span><span class="s2">, </span><span class="s3">&quot;m&quot;</span><span class="s1">):</span>
        <span class="s1">res = TimedeltaArray._from_sequence(value</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s2">return </span><span class="s1">res</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">dta = DatetimeArray._from_sequence(value</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">err:</span>
            <span class="s4"># We can give a Series-specific exception message.</span>
            <span class="s2">if </span><span class="s3">&quot;cannot supply both a tz and a timezone-naive dtype&quot; </span><span class="s2">in </span><span class="s1">str(err):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;Cannot convert timezone-aware data to &quot;</span>
                    <span class="s3">&quot;timezone-naive dtype. Use &quot;</span>
                    <span class="s3">&quot;pd.Series(values).dt.tz_localize(None) instead.&quot;</span>
                <span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>
            <span class="s2">raise</span>

        <span class="s2">return </span><span class="s1">dta</span>


<span class="s2">def </span><span class="s1">_ensure_nanosecond_dtype(dtype: DtypeObj) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s3">&quot;&quot;&quot; 
    Convert dtypes with granularity less than nanosecond to nanosecond 
 
    &gt;&gt;&gt; _ensure_nanosecond_dtype(np.dtype(&quot;M8[us]&quot;)) 
 
    &gt;&gt;&gt; _ensure_nanosecond_dtype(np.dtype(&quot;M8[D]&quot;)) 
    Traceback (most recent call last): 
        ... 
    TypeError: dtype=datetime64[D] is not supported. Supported resolutions are 's', 'ms', 'us', and 'ns' 
 
    &gt;&gt;&gt; _ensure_nanosecond_dtype(np.dtype(&quot;m8[ps]&quot;)) 
    Traceback (most recent call last): 
        ... 
    TypeError: dtype=timedelta64[ps] is not supported. Supported resolutions are 's', 'ms', 'us', and 'ns' 
    &quot;&quot;&quot;  </span><span class="s4"># noqa: E501</span>
    <span class="s1">msg = (</span>
        <span class="s3">f&quot;The '</span><span class="s2">{</span><span class="s1">dtype.name</span><span class="s2">}</span><span class="s3">' dtype has no unit. &quot;</span>
        <span class="s3">f&quot;Please pass in '</span><span class="s2">{</span><span class="s1">dtype.name</span><span class="s2">}</span><span class="s3">[ns]' instead.&quot;</span>
    <span class="s1">)</span>

    <span class="s4"># unpack e.g. SparseDtype</span>
    <span class="s1">dtype = getattr(dtype</span><span class="s2">, </span><span class="s3">&quot;subtype&quot;</span><span class="s2">, </span><span class="s1">dtype)</span>

    <span class="s2">if not </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">np.dtype):</span>
        <span class="s4"># i.e. datetime64tz</span>
        <span class="s2">pass</span>

    <span class="s2">elif </span><span class="s1">dtype.kind </span><span class="s2">in </span><span class="s3">&quot;mM&quot;</span><span class="s1">:</span>
        <span class="s1">reso = get_unit_from_dtype(dtype)</span>
        <span class="s2">if not </span><span class="s1">is_supported_unit(reso):</span>
            <span class="s4"># pre-2.0 we would silently swap in nanos for lower-resolutions,</span>
            <span class="s4">#  raise for above-nano resolutions</span>
            <span class="s2">if </span><span class="s1">dtype.name </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;datetime64&quot;</span><span class="s2">, </span><span class="s3">&quot;timedelta64&quot;</span><span class="s1">]:</span>
                <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
            <span class="s4"># TODO: ValueError or TypeError? existing test</span>
            <span class="s4">#  test_constructor_generic_timestamp_bad_frequency expects TypeError</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s3">f&quot;dtype=</span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">} </span><span class="s3">is not supported. Supported resolutions are 's', &quot;</span>
                <span class="s3">&quot;'ms', 'us', and 'ns'&quot;</span>
            <span class="s1">)</span>


<span class="s4"># TODO: other value-dependent functions to standardize here include</span>
<span class="s4">#  Index._find_common_type_compat</span>
<span class="s2">def </span><span class="s1">find_result_type(left_dtype: DtypeObj</span><span class="s2">, </span><span class="s1">right: Any) -&gt; DtypeObj:</span>
    <span class="s0">&quot;&quot;&quot; 
    Find the type/dtype for the result of an operation between objects. 
 
    This is similar to find_common_type, but looks at the right object instead 
    of just its dtype. This can be useful in particular when the right 
    object does not have a `dtype`. 
 
    Parameters 
    ---------- 
    left_dtype : np.dtype or ExtensionDtype 
    right : Any 
 
    Returns 
    ------- 
    np.dtype or ExtensionDtype 
 
    See also 
    -------- 
    find_common_type 
    numpy.result_type 
    &quot;&quot;&quot;</span>
    <span class="s1">new_dtype: DtypeObj</span>

    <span class="s2">if </span><span class="s1">(</span>
        <span class="s1">isinstance(left_dtype</span><span class="s2">, </span><span class="s1">np.dtype)</span>
        <span class="s2">and </span><span class="s1">left_dtype.kind </span><span class="s2">in </span><span class="s3">&quot;iuc&quot;</span>
        <span class="s2">and </span><span class="s1">(lib.is_integer(right) </span><span class="s2">or </span><span class="s1">lib.is_float(right))</span>
    <span class="s1">):</span>
        <span class="s4"># e.g. with int8 dtype and right=512, we want to end up with</span>
        <span class="s4"># np.int16, whereas infer_dtype_from(512) gives np.int64,</span>
        <span class="s4">#  which will make us upcast too far.</span>
        <span class="s2">if </span><span class="s1">lib.is_float(right) </span><span class="s2">and </span><span class="s1">right.is_integer() </span><span class="s2">and </span><span class="s1">left_dtype.kind != </span><span class="s3">&quot;f&quot;</span><span class="s1">:</span>
            <span class="s1">right = int(right)</span>
        <span class="s1">new_dtype = np.result_type(left_dtype</span><span class="s2">, </span><span class="s1">right)</span>

    <span class="s2">elif </span><span class="s1">is_valid_na_for_dtype(right</span><span class="s2">, </span><span class="s1">left_dtype):</span>
        <span class="s4"># e.g. IntervalDtype[int] and None/np.nan</span>
        <span class="s1">new_dtype = ensure_dtype_can_hold_na(left_dtype)</span>

    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">dtype</span><span class="s2">, </span><span class="s1">_ = infer_dtype_from(right)</span>
        <span class="s1">new_dtype = find_common_type([left_dtype</span><span class="s2">, </span><span class="s1">dtype])</span>

    <span class="s2">return </span><span class="s1">new_dtype</span>


<span class="s2">def </span><span class="s1">common_dtype_categorical_compat(</span>
    <span class="s1">objs: Sequence[Index | ArrayLike]</span><span class="s2">, </span><span class="s1">dtype: DtypeObj</span>
<span class="s1">) -&gt; DtypeObj:</span>
    <span class="s0">&quot;&quot;&quot; 
    Update the result of find_common_type to account for NAs in a Categorical. 
 
    Parameters 
    ---------- 
    objs : list[np.ndarray | ExtensionArray | Index] 
    dtype : np.dtype or ExtensionDtype 
 
    Returns 
    ------- 
    np.dtype or ExtensionDtype 
    &quot;&quot;&quot;</span>
    <span class="s4"># GH#38240</span>

    <span class="s4"># TODO: more generally, could do `not can_hold_na(dtype)`</span>
    <span class="s2">if </span><span class="s1">lib.is_np_dtype(dtype</span><span class="s2">, </span><span class="s3">&quot;iu&quot;</span><span class="s1">):</span>
        <span class="s2">for </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">objs:</span>
            <span class="s4"># We don't want to accientally allow e.g. &quot;categorical&quot; str here</span>
            <span class="s1">obj_dtype = getattr(obj</span><span class="s2">, </span><span class="s3">&quot;dtype&quot;</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">isinstance(obj_dtype</span><span class="s2">, </span><span class="s1">CategoricalDtype):</span>
                <span class="s2">if </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">ABCIndex):</span>
                    <span class="s4"># This check may already be cached</span>
                    <span class="s1">hasnas = obj.hasnans</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s4"># Categorical</span>
                    <span class="s1">hasnas = cast(</span><span class="s3">&quot;Categorical&quot;</span><span class="s2">, </span><span class="s1">obj)._hasna</span>

                <span class="s2">if </span><span class="s1">hasnas:</span>
                    <span class="s4"># see test_union_int_categorical_with_nan</span>
                    <span class="s1">dtype = np.dtype(np.float64)</span>
                    <span class="s2">break</span>
    <span class="s2">return </span><span class="s1">dtype</span>


<span class="s2">def </span><span class="s1">np_find_common_type(*dtypes: np.dtype) -&gt; np.dtype:</span>
    <span class="s0">&quot;&quot;&quot; 
    np.find_common_type implementation pre-1.25 deprecation using np.result_type 
    https://github.com/pandas-dev/pandas/pull/49569#issuecomment-1308300065 
 
    Parameters 
    ---------- 
    dtypes : np.dtypes 
 
    Returns 
    ------- 
    np.dtype 
    &quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">common_dtype = np.result_type(*dtypes)</span>
        <span class="s2">if </span><span class="s1">common_dtype.kind </span><span class="s2">in </span><span class="s3">&quot;mMSU&quot;</span><span class="s1">:</span>
            <span class="s4"># NumPy promotion currently (1.25) misbehaves for for times and strings,</span>
            <span class="s4"># so fall back to object (find_common_dtype did unless there</span>
            <span class="s4"># was only one dtype)</span>
            <span class="s1">common_dtype = np.dtype(</span><span class="s3">&quot;O&quot;</span><span class="s1">)</span>

    <span class="s2">except </span><span class="s1">TypeError:</span>
        <span class="s1">common_dtype = np.dtype(</span><span class="s3">&quot;O&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">common_dtype</span>


<span class="s1">@overload</span>
<span class="s2">def </span><span class="s1">find_common_type(types: list[np.dtype]) -&gt; np.dtype:</span>
    <span class="s1">...</span>


<span class="s1">@overload</span>
<span class="s2">def </span><span class="s1">find_common_type(types: list[ExtensionDtype]) -&gt; DtypeObj:</span>
    <span class="s1">...</span>


<span class="s1">@overload</span>
<span class="s2">def </span><span class="s1">find_common_type(types: list[DtypeObj]) -&gt; DtypeObj:</span>
    <span class="s1">...</span>


<span class="s2">def </span><span class="s1">find_common_type(types):</span>
    <span class="s0">&quot;&quot;&quot; 
    Find a common data type among the given dtypes. 
 
    Parameters 
    ---------- 
    types : list of dtypes 
 
    Returns 
    ------- 
    pandas extension or numpy dtype 
 
    See Also 
    -------- 
    numpy.find_common_type 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">types:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;no types given&quot;</span><span class="s1">)</span>

    <span class="s1">first = types[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s4"># workaround for find_common_type([np.dtype('datetime64[ns]')] * 2)</span>
    <span class="s4"># =&gt; object</span>
    <span class="s2">if </span><span class="s1">lib.dtypes_all_equal(list(types)):</span>
        <span class="s2">return </span><span class="s1">first</span>

    <span class="s4"># get unique types (dict.fromkeys is used as order-preserving set())</span>
    <span class="s1">types = list(dict.fromkeys(types).keys())</span>

    <span class="s2">if </span><span class="s1">any(isinstance(t</span><span class="s2">, </span><span class="s1">ExtensionDtype) </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">types):</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">types:</span>
            <span class="s2">if </span><span class="s1">isinstance(t</span><span class="s2">, </span><span class="s1">ExtensionDtype):</span>
                <span class="s1">res = t._get_common_dtype(types)</span>
                <span class="s2">if </span><span class="s1">res </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">res</span>
        <span class="s2">return </span><span class="s1">np.dtype(</span><span class="s3">&quot;object&quot;</span><span class="s1">)</span>

    <span class="s4"># take lowest unit</span>
    <span class="s2">if </span><span class="s1">all(lib.is_np_dtype(t</span><span class="s2">, </span><span class="s3">&quot;M&quot;</span><span class="s1">) </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">types):</span>
        <span class="s2">return </span><span class="s1">np.dtype(max(types))</span>
    <span class="s2">if </span><span class="s1">all(lib.is_np_dtype(t</span><span class="s2">, </span><span class="s3">&quot;m&quot;</span><span class="s1">) </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">types):</span>
        <span class="s2">return </span><span class="s1">np.dtype(max(types))</span>

    <span class="s4"># don't mix bool / int or float or complex</span>
    <span class="s4"># this is different from numpy, which casts bool with float/int as int</span>
    <span class="s1">has_bools = any(t.kind == </span><span class="s3">&quot;b&quot; </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">types)</span>
    <span class="s2">if </span><span class="s1">has_bools:</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">types:</span>
            <span class="s2">if </span><span class="s1">t.kind </span><span class="s2">in </span><span class="s3">&quot;iufc&quot;</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">np.dtype(</span><span class="s3">&quot;object&quot;</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">np_find_common_type(*types)</span>


<span class="s2">def </span><span class="s1">construct_2d_arraylike_from_scalar(</span>
    <span class="s1">value: Scalar</span><span class="s2">, </span><span class="s1">length: int</span><span class="s2">, </span><span class="s1">width: int</span><span class="s2">, </span><span class="s1">dtype: np.dtype</span><span class="s2">, </span><span class="s1">copy: bool</span>
<span class="s1">) -&gt; np.ndarray:</span>
    <span class="s1">shape = (length</span><span class="s2">, </span><span class="s1">width)</span>

    <span class="s2">if </span><span class="s1">dtype.kind </span><span class="s2">in </span><span class="s3">&quot;mM&quot;</span><span class="s1">:</span>
        <span class="s1">value = _maybe_box_and_unbox_datetimelike(value</span><span class="s2">, </span><span class="s1">dtype)</span>
    <span class="s2">elif </span><span class="s1">dtype == _dtype_obj:</span>
        <span class="s2">if </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">(np.timedelta64</span><span class="s2">, </span><span class="s1">np.datetime64)):</span>
            <span class="s4"># calling np.array below would cast to pytimedelta/pydatetime</span>
            <span class="s1">out = np.empty(shape</span><span class="s2">, </span><span class="s1">dtype=object)</span>
            <span class="s1">out.fill(value)</span>
            <span class="s2">return </span><span class="s1">out</span>

    <span class="s4"># Attempt to coerce to a numpy array</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">arr = np.array(value</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">copy=copy)</span>
    <span class="s2">except </span><span class="s1">(ValueError</span><span class="s2">, </span><span class="s1">TypeError) </span><span class="s2">as </span><span class="s1">err:</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span>
            <span class="s3">f&quot;DataFrame constructor called with incompatible data and dtype: </span><span class="s2">{</span><span class="s1">err</span><span class="s2">}</span><span class="s3">&quot;</span>
        <span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>

    <span class="s2">if </span><span class="s1">arr.ndim != </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;DataFrame constructor not properly called!&quot;</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">np.full(shape</span><span class="s2">, </span><span class="s1">arr)</span>


<span class="s2">def </span><span class="s1">construct_1d_arraylike_from_scalar(</span>
    <span class="s1">value: Scalar</span><span class="s2">, </span><span class="s1">length: int</span><span class="s2">, </span><span class="s1">dtype: DtypeObj | </span><span class="s2">None</span>
<span class="s1">) -&gt; ArrayLike:</span>
    <span class="s0">&quot;&quot;&quot; 
    create a np.ndarray / pandas type of specified shape and dtype 
    filled with values 
 
    Parameters 
    ---------- 
    value : scalar value 
    length : int 
    dtype : pandas_dtype or np.dtype 
 
    Returns 
    ------- 
    np.ndarray / pandas type of length, filled with value 
 
    &quot;&quot;&quot;</span>

    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">dtype</span><span class="s2">, </span><span class="s1">value = infer_dtype_from_scalar(value)</span>
        <span class="s2">except </span><span class="s1">OutOfBoundsDatetime:</span>
            <span class="s1">dtype = _dtype_obj</span>

    <span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">ExtensionDtype):</span>
        <span class="s1">cls = dtype.construct_array_type()</span>
        <span class="s1">seq = [] </span><span class="s2">if </span><span class="s1">length == </span><span class="s5">0 </span><span class="s2">else </span><span class="s1">[value]</span>
        <span class="s1">subarr = cls._from_sequence(seq</span><span class="s2">, </span><span class="s1">dtype=dtype).repeat(length)</span>

    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">length </span><span class="s2">and </span><span class="s1">dtype.kind </span><span class="s2">in </span><span class="s3">&quot;iu&quot; </span><span class="s2">and </span><span class="s1">isna(value):</span>
            <span class="s4"># coerce if we have nan for an integer dtype</span>
            <span class="s1">dtype = np.dtype(</span><span class="s3">&quot;float64&quot;</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">lib.is_np_dtype(dtype</span><span class="s2">, </span><span class="s3">&quot;US&quot;</span><span class="s1">):</span>
            <span class="s4"># we need to coerce to object dtype to avoid</span>
            <span class="s4"># to allow numpy to take our string as a scalar value</span>
            <span class="s1">dtype = np.dtype(</span><span class="s3">&quot;object&quot;</span><span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">isna(value):</span>
                <span class="s1">value = ensure_str(value)</span>
        <span class="s2">elif </span><span class="s1">dtype.kind </span><span class="s2">in </span><span class="s3">&quot;mM&quot;</span><span class="s1">:</span>
            <span class="s1">value = _maybe_box_and_unbox_datetimelike(value</span><span class="s2">, </span><span class="s1">dtype)</span>

        <span class="s1">subarr = np.empty(length</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s2">if </span><span class="s1">length:</span>
            <span class="s4"># GH 47391: numpy &gt; 1.24 will raise filling np.nan into int dtypes</span>
            <span class="s1">subarr.fill(value)</span>

    <span class="s2">return </span><span class="s1">subarr</span>


<span class="s2">def </span><span class="s1">_maybe_box_and_unbox_datetimelike(value: Scalar</span><span class="s2">, </span><span class="s1">dtype: DtypeObj):</span>
    <span class="s4"># Caller is responsible for checking dtype.kind in &quot;mM&quot;</span>

    <span class="s2">if </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">dt.datetime):</span>
        <span class="s4"># we dont want to box dt64, in particular datetime64(&quot;NaT&quot;)</span>
        <span class="s1">value = maybe_box_datetimelike(value</span><span class="s2">, </span><span class="s1">dtype)</span>

    <span class="s2">return </span><span class="s1">_maybe_unbox_datetimelike(value</span><span class="s2">, </span><span class="s1">dtype)</span>


<span class="s2">def </span><span class="s1">construct_1d_object_array_from_listlike(values: Sized) -&gt; np.ndarray:</span>
    <span class="s0">&quot;&quot;&quot; 
    Transform any list-like object in a 1-dimensional numpy array of object 
    dtype. 
 
    Parameters 
    ---------- 
    values : any iterable which has a len() 
 
    Raises 
    ------ 
    TypeError 
        * If `values` does not have a len() 
 
    Returns 
    ------- 
    1-dimensional numpy array of dtype object 
    &quot;&quot;&quot;</span>
    <span class="s4"># numpy will try to interpret nested lists as further dimensions, hence</span>
    <span class="s4"># making a 1D array that contains list-likes is a bit tricky:</span>
    <span class="s1">result = np.empty(len(values)</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;object&quot;</span><span class="s1">)</span>
    <span class="s1">result[:] = values</span>
    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">maybe_cast_to_integer_array(arr: list | np.ndarray</span><span class="s2">, </span><span class="s1">dtype: np.dtype) -&gt; np.ndarray:</span>
    <span class="s0">&quot;&quot;&quot; 
    Takes any dtype and returns the casted version, raising for when data is 
    incompatible with integer/unsigned integer dtypes. 
 
    Parameters 
    ---------- 
    arr : np.ndarray or list 
        The array to cast. 
    dtype : np.dtype 
        The integer dtype to cast the array to. 
 
    Returns 
    ------- 
    ndarray 
        Array of integer or unsigned integer dtype. 
 
    Raises 
    ------ 
    OverflowError : the dtype is incompatible with the data 
    ValueError : loss of precision has occurred during casting 
 
    Examples 
    -------- 
    If you try to coerce negative values to unsigned integers, it raises: 
 
    &gt;&gt;&gt; pd.Series([-1], dtype=&quot;uint64&quot;) 
    Traceback (most recent call last): 
        ... 
    OverflowError: Trying to coerce negative values to unsigned integers 
 
    Also, if you try to coerce float values to integers, it raises: 
 
    &gt;&gt;&gt; maybe_cast_to_integer_array([1, 2, 3.5], dtype=np.dtype(&quot;int64&quot;)) 
    Traceback (most recent call last): 
        ... 
    ValueError: Trying to coerce float values to integers 
    &quot;&quot;&quot;</span>
    <span class="s2">assert </span><span class="s1">dtype.kind </span><span class="s2">in </span><span class="s3">&quot;iu&quot;</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">if not </span><span class="s1">isinstance(arr</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
            <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
                <span class="s4"># We already disallow dtype=uint w/ negative numbers</span>
                <span class="s4"># (test_constructor_coercion_signed_to_unsigned) so safe to ignore.</span>
                <span class="s1">warnings.filterwarnings(</span>
                    <span class="s3">&quot;ignore&quot;</span><span class="s2">,</span>
                    <span class="s3">&quot;NumPy will stop allowing conversion of out-of-bound Python int&quot;</span><span class="s2">,</span>
                    <span class="s1">DeprecationWarning</span><span class="s2">,</span>
                <span class="s1">)</span>
                <span class="s1">casted = np.array(arr</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
                <span class="s1">warnings.filterwarnings(</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">category=RuntimeWarning)</span>
                <span class="s1">casted = arr.astype(dtype</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s2">except </span><span class="s1">OverflowError </span><span class="s2">as </span><span class="s1">err:</span>
        <span class="s2">raise </span><span class="s1">OverflowError(</span>
            <span class="s3">&quot;The elements provided in the data cannot all be &quot;</span>
            <span class="s3">f&quot;casted to the dtype </span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">}</span><span class="s3">&quot;</span>
        <span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>

    <span class="s2">if </span><span class="s1">isinstance(arr</span><span class="s2">, </span><span class="s1">np.ndarray) </span><span class="s2">and </span><span class="s1">arr.dtype == dtype:</span>
        <span class="s4"># avoid expensive array_equal check</span>
        <span class="s2">return </span><span class="s1">casted</span>

    <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
        <span class="s1">warnings.filterwarnings(</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">category=RuntimeWarning)</span>
        <span class="s1">warnings.filterwarnings(</span>
            <span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s3">&quot;elementwise comparison failed&quot;</span><span class="s2">, </span><span class="s1">FutureWarning</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">np.array_equal(arr</span><span class="s2">, </span><span class="s1">casted):</span>
            <span class="s2">return </span><span class="s1">casted</span>

    <span class="s4"># We do this casting to allow for proper</span>
    <span class="s4"># data and dtype checking.</span>
    <span class="s4">#</span>
    <span class="s4"># We didn't do this earlier because NumPy</span>
    <span class="s4"># doesn't handle `uint64` correctly.</span>
    <span class="s1">arr = np.asarray(arr)</span>

    <span class="s2">if </span><span class="s1">np.issubdtype(arr.dtype</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s2">if </span><span class="s1">(casted.astype(str) == arr).all():</span>
            <span class="s2">return </span><span class="s1">casted</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;string values cannot be losslessly cast to </span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">dtype.kind == </span><span class="s3">&quot;u&quot; </span><span class="s2">and </span><span class="s1">(arr &lt; </span><span class="s5">0</span><span class="s1">).any():</span>
        <span class="s2">raise </span><span class="s1">OverflowError(</span><span class="s3">&quot;Trying to coerce negative values to unsigned integers&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">arr.dtype.kind == </span><span class="s3">&quot;f&quot;</span><span class="s1">:</span>
        <span class="s2">if not </span><span class="s1">np.isfinite(arr).all():</span>
            <span class="s2">raise </span><span class="s1">IntCastingNaNError(</span>
                <span class="s3">&quot;Cannot convert non-finite values (NA or inf) to integer&quot;</span>
            <span class="s1">)</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Trying to coerce float values to integers&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">arr.dtype == object:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Trying to coerce float values to integers&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">casted.dtype &lt; arr.dtype:</span>
        <span class="s4"># GH#41734 e.g. [1, 200, 923442] and dtype=&quot;int8&quot; -&gt; overflows</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s3">f&quot;Values are too large to be losslessly converted to </span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">}</span><span class="s3">. &quot;</span>
            <span class="s3">f&quot;To cast anyway, use pd.Series(values).astype(</span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">}</span><span class="s3">)&quot;</span>
        <span class="s1">)</span>

    <span class="s2">if </span><span class="s1">arr.dtype.kind </span><span class="s2">in </span><span class="s3">&quot;mM&quot;</span><span class="s1">:</span>
        <span class="s4"># test_constructor_maskedarray_nonfloat</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span>
            <span class="s3">f&quot;Constructing a Series or DataFrame from </span><span class="s2">{</span><span class="s1">arr.dtype</span><span class="s2">} </span><span class="s3">values and &quot;</span>
            <span class="s3">f&quot;dtype=</span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">} </span><span class="s3">is not supported. Use values.view(</span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">}</span><span class="s3">) instead.&quot;</span>
        <span class="s1">)</span>

    <span class="s4"># No known cases that get here, but raising explicitly to cover our bases.</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;values cannot be losslessly cast to </span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">can_hold_element(arr: ArrayLike</span><span class="s2">, </span><span class="s1">element: Any) -&gt; bool:</span>
    <span class="s0">&quot;&quot;&quot; 
    Can we do an inplace setitem with this element in an array with this dtype? 
 
    Parameters 
    ---------- 
    arr : np.ndarray or ExtensionArray 
    element : Any 
 
    Returns 
    ------- 
    bool 
    &quot;&quot;&quot;</span>
    <span class="s1">dtype = arr.dtype</span>
    <span class="s2">if not </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">np.dtype) </span><span class="s2">or </span><span class="s1">dtype.kind </span><span class="s2">in </span><span class="s3">&quot;mM&quot;</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">(PeriodDtype</span><span class="s2">, </span><span class="s1">IntervalDtype</span><span class="s2">, </span><span class="s1">DatetimeTZDtype</span><span class="s2">, </span><span class="s1">np.dtype)):</span>
            <span class="s4"># np.dtype here catches datetime64ns and timedelta64ns; we assume</span>
            <span class="s4">#  in this case that we have DatetimeArray/TimedeltaArray</span>
            <span class="s1">arr = cast(</span>
                <span class="s3">&quot;PeriodArray | DatetimeArray | TimedeltaArray | IntervalArray&quot;</span><span class="s2">, </span><span class="s1">arr</span>
            <span class="s1">)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">arr._validate_setitem_value(element)</span>
                <span class="s2">return True</span>
            <span class="s2">except </span><span class="s1">(ValueError</span><span class="s2">, </span><span class="s1">TypeError):</span>
                <span class="s4"># TODO: re-use _catch_deprecated_value_error to ensure we are</span>
                <span class="s4">#  strict about what exceptions we allow through here.</span>
                <span class="s2">return False</span>

        <span class="s4"># This is technically incorrect, but maintains the behavior of</span>
        <span class="s4"># ExtensionBlock._can_hold_element</span>
        <span class="s2">return True</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">np_can_hold_element(dtype</span><span class="s2">, </span><span class="s1">element)</span>
        <span class="s2">return True</span>
    <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">LossySetitemError):</span>
        <span class="s2">return False</span>


<span class="s2">def </span><span class="s1">np_can_hold_element(dtype: np.dtype</span><span class="s2">, </span><span class="s1">element: Any) -&gt; Any:</span>
    <span class="s0">&quot;&quot;&quot; 
    Raise if we cannot losslessly set this element into an ndarray with this dtype. 
 
    Specifically about places where we disagree with numpy.  i.e. there are 
    cases where numpy will raise in doing the setitem that we do not check 
    for here, e.g. setting str &quot;X&quot; into a numeric ndarray. 
 
    Returns 
    ------- 
    Any 
        The element, potentially cast to the dtype. 
 
    Raises 
    ------ 
    ValueError : If we cannot losslessly store this element with this dtype. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">dtype == _dtype_obj:</span>
        <span class="s2">return </span><span class="s1">element</span>

    <span class="s1">tipo = _maybe_infer_dtype_type(element)</span>

    <span class="s2">if </span><span class="s1">dtype.kind </span><span class="s2">in </span><span class="s3">&quot;iu&quot;</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">isinstance(element</span><span class="s2">, </span><span class="s1">range):</span>
            <span class="s2">if </span><span class="s1">_dtype_can_hold_range(element</span><span class="s2">, </span><span class="s1">dtype):</span>
                <span class="s2">return </span><span class="s1">element</span>
            <span class="s2">raise </span><span class="s1">LossySetitemError</span>

        <span class="s2">if </span><span class="s1">is_integer(element) </span><span class="s2">or </span><span class="s1">(is_float(element) </span><span class="s2">and </span><span class="s1">element.is_integer()):</span>
            <span class="s4"># e.g. test_setitem_series_int8 if we have a python int 1</span>
            <span class="s4">#  tipo may be np.int32, despite the fact that it will fit</span>
            <span class="s4">#  in smaller int dtypes.</span>
            <span class="s1">info = np.iinfo(dtype)</span>
            <span class="s2">if </span><span class="s1">info.min &lt;= element &lt;= info.max:</span>
                <span class="s2">return </span><span class="s1">dtype.type(element)</span>
            <span class="s2">raise </span><span class="s1">LossySetitemError</span>

        <span class="s2">if </span><span class="s1">tipo </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">tipo.kind </span><span class="s2">not in </span><span class="s3">&quot;iu&quot;</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">isinstance(element</span><span class="s2">, </span><span class="s1">np.ndarray) </span><span class="s2">and </span><span class="s1">element.dtype.kind == </span><span class="s3">&quot;f&quot;</span><span class="s1">:</span>
                    <span class="s4"># If all can be losslessly cast to integers, then we can hold them</span>
                    <span class="s2">with </span><span class="s1">np.errstate(invalid=</span><span class="s3">&quot;ignore&quot;</span><span class="s1">):</span>
                        <span class="s4"># We check afterwards if cast was losslessly, so no need to show</span>
                        <span class="s4"># the warning</span>
                        <span class="s1">casted = element.astype(dtype)</span>
                    <span class="s1">comp = casted == element</span>
                    <span class="s2">if </span><span class="s1">comp.all():</span>
                        <span class="s4"># Return the casted values bc they can be passed to</span>
                        <span class="s4">#  np.putmask, whereas the raw values cannot.</span>
                        <span class="s4">#  see TestSetitemFloatNDarrayIntoIntegerSeries</span>
                        <span class="s2">return </span><span class="s1">casted</span>
                    <span class="s2">raise </span><span class="s1">LossySetitemError</span>

                <span class="s4"># Anything other than integer we cannot hold</span>
                <span class="s2">raise </span><span class="s1">LossySetitemError</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">dtype.kind == </span><span class="s3">&quot;u&quot;</span>
                <span class="s2">and </span><span class="s1">isinstance(element</span><span class="s2">, </span><span class="s1">np.ndarray)</span>
                <span class="s2">and </span><span class="s1">element.dtype.kind == </span><span class="s3">&quot;i&quot;</span>
            <span class="s1">):</span>
                <span class="s4"># see test_where_uint64</span>
                <span class="s1">casted = element.astype(dtype)</span>
                <span class="s2">if </span><span class="s1">(casted == element).all():</span>
                    <span class="s4"># TODO: faster to check (element &gt;=0).all()?  potential</span>
                    <span class="s4">#  itemsize issues there?</span>
                    <span class="s2">return </span><span class="s1">casted</span>
                <span class="s2">raise </span><span class="s1">LossySetitemError</span>
            <span class="s2">if </span><span class="s1">dtype.itemsize &lt; tipo.itemsize:</span>
                <span class="s2">raise </span><span class="s1">LossySetitemError</span>
            <span class="s2">if not </span><span class="s1">isinstance(tipo</span><span class="s2">, </span><span class="s1">np.dtype):</span>
                <span class="s4"># i.e. nullable IntegerDtype; we can put this into an ndarray</span>
                <span class="s4">#  losslessly iff it has no NAs</span>
                <span class="s2">if </span><span class="s1">element._hasna:</span>
                    <span class="s2">raise </span><span class="s1">LossySetitemError</span>
                <span class="s2">return </span><span class="s1">element</span>

            <span class="s2">return </span><span class="s1">element</span>

        <span class="s2">raise </span><span class="s1">LossySetitemError</span>

    <span class="s2">if </span><span class="s1">dtype.kind == </span><span class="s3">&quot;f&quot;</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">lib.is_integer(element) </span><span class="s2">or </span><span class="s1">lib.is_float(element):</span>
            <span class="s1">casted = dtype.type(element)</span>
            <span class="s2">if </span><span class="s1">np.isnan(casted) </span><span class="s2">or </span><span class="s1">casted == element:</span>
                <span class="s2">return </span><span class="s1">casted</span>
            <span class="s4"># otherwise e.g. overflow see TestCoercionFloat32</span>
            <span class="s2">raise </span><span class="s1">LossySetitemError</span>

        <span class="s2">if </span><span class="s1">tipo </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s4"># TODO: itemsize check?</span>
            <span class="s2">if </span><span class="s1">tipo.kind </span><span class="s2">not in </span><span class="s3">&quot;iuf&quot;</span><span class="s1">:</span>
                <span class="s4"># Anything other than float/integer we cannot hold</span>
                <span class="s2">raise </span><span class="s1">LossySetitemError</span>
            <span class="s2">if not </span><span class="s1">isinstance(tipo</span><span class="s2">, </span><span class="s1">np.dtype):</span>
                <span class="s4"># i.e. nullable IntegerDtype or FloatingDtype;</span>
                <span class="s4">#  we can put this into an ndarray losslessly iff it has no NAs</span>
                <span class="s2">if </span><span class="s1">element._hasna:</span>
                    <span class="s2">raise </span><span class="s1">LossySetitemError</span>
                <span class="s2">return </span><span class="s1">element</span>
            <span class="s2">elif </span><span class="s1">tipo.itemsize &gt; dtype.itemsize </span><span class="s2">or </span><span class="s1">tipo.kind != dtype.kind:</span>
                <span class="s2">if </span><span class="s1">isinstance(element</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
                    <span class="s4"># e.g. TestDataFrameIndexingWhere::test_where_alignment</span>
                    <span class="s1">casted = element.astype(dtype)</span>
                    <span class="s2">if </span><span class="s1">np.array_equal(casted</span><span class="s2">, </span><span class="s1">element</span><span class="s2">, </span><span class="s1">equal_nan=</span><span class="s2">True</span><span class="s1">):</span>
                        <span class="s2">return </span><span class="s1">casted</span>
                    <span class="s2">raise </span><span class="s1">LossySetitemError</span>

            <span class="s2">return </span><span class="s1">element</span>

        <span class="s2">raise </span><span class="s1">LossySetitemError</span>

    <span class="s2">if </span><span class="s1">dtype.kind == </span><span class="s3">&quot;c&quot;</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">lib.is_integer(element) </span><span class="s2">or </span><span class="s1">lib.is_complex(element) </span><span class="s2">or </span><span class="s1">lib.is_float(element):</span>
            <span class="s2">if </span><span class="s1">np.isnan(element):</span>
                <span class="s4"># see test_where_complex GH#6345</span>
                <span class="s2">return </span><span class="s1">dtype.type(element)</span>

            <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
                <span class="s1">warnings.filterwarnings(</span><span class="s3">&quot;ignore&quot;</span><span class="s1">)</span>
                <span class="s1">casted = dtype.type(element)</span>
            <span class="s2">if </span><span class="s1">casted == element:</span>
                <span class="s2">return </span><span class="s1">casted</span>
            <span class="s4"># otherwise e.g. overflow see test_32878_complex_itemsize</span>
            <span class="s2">raise </span><span class="s1">LossySetitemError</span>

        <span class="s2">if </span><span class="s1">tipo </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">tipo.kind </span><span class="s2">in </span><span class="s3">&quot;iufc&quot;</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">element</span>
            <span class="s2">raise </span><span class="s1">LossySetitemError</span>
        <span class="s2">raise </span><span class="s1">LossySetitemError</span>

    <span class="s2">if </span><span class="s1">dtype.kind == </span><span class="s3">&quot;b&quot;</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">tipo </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">tipo.kind == </span><span class="s3">&quot;b&quot;</span><span class="s1">:</span>
                <span class="s2">if not </span><span class="s1">isinstance(tipo</span><span class="s2">, </span><span class="s1">np.dtype):</span>
                    <span class="s4"># i.e. we have a BooleanArray</span>
                    <span class="s2">if </span><span class="s1">element._hasna:</span>
                        <span class="s4"># i.e. there are pd.NA elements</span>
                        <span class="s2">raise </span><span class="s1">LossySetitemError</span>
                <span class="s2">return </span><span class="s1">element</span>
            <span class="s2">raise </span><span class="s1">LossySetitemError</span>
        <span class="s2">if </span><span class="s1">lib.is_bool(element):</span>
            <span class="s2">return </span><span class="s1">element</span>
        <span class="s2">raise </span><span class="s1">LossySetitemError</span>

    <span class="s2">if </span><span class="s1">dtype.kind == </span><span class="s3">&quot;S&quot;</span><span class="s1">:</span>
        <span class="s4"># TODO: test tests.frame.methods.test_replace tests get here,</span>
        <span class="s4">#  need more targeted tests.  xref phofl has a PR about this</span>
        <span class="s2">if </span><span class="s1">tipo </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">tipo.kind == </span><span class="s3">&quot;S&quot; </span><span class="s2">and </span><span class="s1">tipo.itemsize &lt;= dtype.itemsize:</span>
                <span class="s2">return </span><span class="s1">element</span>
            <span class="s2">raise </span><span class="s1">LossySetitemError</span>
        <span class="s2">if </span><span class="s1">isinstance(element</span><span class="s2">, </span><span class="s1">bytes) </span><span class="s2">and </span><span class="s1">len(element) &lt;= dtype.itemsize:</span>
            <span class="s2">return </span><span class="s1">element</span>
        <span class="s2">raise </span><span class="s1">LossySetitemError</span>

    <span class="s2">if </span><span class="s1">dtype.kind == </span><span class="s3">&quot;V&quot;</span><span class="s1">:</span>
        <span class="s4"># i.e. np.void, which cannot hold _anything_</span>
        <span class="s2">raise </span><span class="s1">LossySetitemError</span>

    <span class="s2">raise </span><span class="s1">NotImplementedError(dtype)</span>


<span class="s2">def </span><span class="s1">_dtype_can_hold_range(rng: range</span><span class="s2">, </span><span class="s1">dtype: np.dtype) -&gt; bool:</span>
    <span class="s0">&quot;&quot;&quot; 
    _maybe_infer_dtype_type infers to int64 (and float64 for very large endpoints), 
    but in many cases a range can be held by a smaller integer dtype. 
    Check if this is one of those cases. 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">len(rng):</span>
        <span class="s2">return True</span>
    <span class="s2">return </span><span class="s1">np.can_cast(rng[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype) </span><span class="s2">and </span><span class="s1">np.can_cast(rng[-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype)</span>
</pre>
</body>
</html>