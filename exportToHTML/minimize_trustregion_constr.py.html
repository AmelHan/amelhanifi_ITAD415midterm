<html>
<head>
<title>minimize_trustregion_constr.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #6a8759;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
minimize_trustregion_constr.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">time</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">scipy.sparse.linalg </span><span class="s0">import </span><span class="s1">LinearOperator</span>
<span class="s0">from </span><span class="s1">.._differentiable_functions </span><span class="s0">import </span><span class="s1">VectorFunction</span>
<span class="s0">from </span><span class="s1">.._constraints </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">NonlinearConstraint</span><span class="s0">, </span><span class="s1">LinearConstraint</span><span class="s0">, </span><span class="s1">PreparedConstraint</span><span class="s0">, </span><span class="s1">Bounds</span><span class="s0">, </span><span class="s1">strict_bounds)</span>
<span class="s0">from </span><span class="s1">.._hessian_update_strategy </span><span class="s0">import </span><span class="s1">BFGS</span>
<span class="s0">from </span><span class="s1">.._optimize </span><span class="s0">import </span><span class="s1">OptimizeResult</span>
<span class="s0">from </span><span class="s1">.._differentiable_functions </span><span class="s0">import </span><span class="s1">ScalarFunction</span>
<span class="s0">from </span><span class="s1">.equality_constrained_sqp </span><span class="s0">import </span><span class="s1">equality_constrained_sqp</span>
<span class="s0">from </span><span class="s1">.canonical_constraint </span><span class="s0">import </span><span class="s1">(CanonicalConstraint</span><span class="s0">,</span>
                                   <span class="s1">initial_constraints_as_canonical)</span>
<span class="s0">from </span><span class="s1">.tr_interior_point </span><span class="s0">import </span><span class="s1">tr_interior_point</span>
<span class="s0">from </span><span class="s1">.report </span><span class="s0">import </span><span class="s1">BasicReport</span><span class="s0">, </span><span class="s1">SQPReport</span><span class="s0">, </span><span class="s1">IPReport</span>


<span class="s1">TERMINATION_MESSAGES = {</span>
    <span class="s2">0</span><span class="s1">: </span><span class="s3">&quot;The maximum number of function evaluations is exceeded.&quot;</span><span class="s0">,</span>
    <span class="s2">1</span><span class="s1">: </span><span class="s3">&quot;`gtol` termination condition is satisfied.&quot;</span><span class="s0">,</span>
    <span class="s2">2</span><span class="s1">: </span><span class="s3">&quot;`xtol` termination condition is satisfied.&quot;</span><span class="s0">,</span>
    <span class="s2">3</span><span class="s1">: </span><span class="s3">&quot;`callback` function requested termination.&quot;</span>
<span class="s1">}</span>


<span class="s0">class </span><span class="s1">HessianLinearOperator:</span>
    <span class="s4">&quot;&quot;&quot;Build LinearOperator from hessp&quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">hessp</span><span class="s0">, </span><span class="s1">n):</span>
        <span class="s1">self.hessp = hessp</span>
        <span class="s1">self.n = n</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">*args):</span>
        <span class="s0">def </span><span class="s1">matvec(p):</span>
            <span class="s0">return </span><span class="s1">self.hessp(x</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">*args)</span>

        <span class="s0">return </span><span class="s1">LinearOperator((self.n</span><span class="s0">, </span><span class="s1">self.n)</span><span class="s0">, </span><span class="s1">matvec=matvec)</span>


<span class="s0">class </span><span class="s1">LagrangianHessian:</span>
    <span class="s4">&quot;&quot;&quot;The Hessian of the Lagrangian as LinearOperator. 
 
    The Lagrangian is computed as the objective function plus all the 
    constraints multiplied with some numbers (Lagrange multipliers). 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">objective_hess</span><span class="s0">, </span><span class="s1">constraints_hess):</span>
        <span class="s1">self.n = n</span>
        <span class="s1">self.objective_hess = objective_hess</span>
        <span class="s1">self.constraints_hess = constraints_hess</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">v_eq=np.empty(</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">v_ineq=np.empty(</span><span class="s2">0</span><span class="s1">)):</span>
        <span class="s1">H_objective = self.objective_hess(x)</span>
        <span class="s1">H_constraints = self.constraints_hess(x</span><span class="s0">, </span><span class="s1">v_eq</span><span class="s0">, </span><span class="s1">v_ineq)</span>

        <span class="s0">def </span><span class="s1">matvec(p):</span>
            <span class="s0">return </span><span class="s1">H_objective.dot(p) + H_constraints.dot(p)</span>

        <span class="s0">return </span><span class="s1">LinearOperator((self.n</span><span class="s0">, </span><span class="s1">self.n)</span><span class="s0">, </span><span class="s1">matvec)</span>


<span class="s0">def </span><span class="s1">update_state_sqp(state</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">last_iteration_failed</span><span class="s0">, </span><span class="s1">objective</span><span class="s0">, </span><span class="s1">prepared_constraints</span><span class="s0">,</span>
                     <span class="s1">start_time</span><span class="s0">, </span><span class="s1">tr_radius</span><span class="s0">, </span><span class="s1">constr_penalty</span><span class="s0">, </span><span class="s1">cg_info):</span>
    <span class="s1">state.nit += </span><span class="s2">1</span>
    <span class="s1">state.nfev = objective.nfev</span>
    <span class="s1">state.njev = objective.ngev</span>
    <span class="s1">state.nhev = objective.nhev</span>
    <span class="s1">state.constr_nfev = [c.fun.nfev </span><span class="s0">if </span><span class="s1">isinstance(c.fun</span><span class="s0">, </span><span class="s1">VectorFunction) </span><span class="s0">else </span><span class="s2">0</span>
                         <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">prepared_constraints]</span>
    <span class="s1">state.constr_njev = [c.fun.njev </span><span class="s0">if </span><span class="s1">isinstance(c.fun</span><span class="s0">, </span><span class="s1">VectorFunction) </span><span class="s0">else </span><span class="s2">0</span>
                         <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">prepared_constraints]</span>
    <span class="s1">state.constr_nhev = [c.fun.nhev </span><span class="s0">if </span><span class="s1">isinstance(c.fun</span><span class="s0">, </span><span class="s1">VectorFunction) </span><span class="s0">else </span><span class="s2">0</span>
                         <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">prepared_constraints]</span>

    <span class="s0">if not </span><span class="s1">last_iteration_failed:</span>
        <span class="s1">state.x = x</span>
        <span class="s1">state.fun = objective.f</span>
        <span class="s1">state.grad = objective.g</span>
        <span class="s1">state.v = [c.fun.v </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">prepared_constraints]</span>
        <span class="s1">state.constr = [c.fun.f </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">prepared_constraints]</span>
        <span class="s1">state.jac = [c.fun.J </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">prepared_constraints]</span>
        <span class="s5"># Compute Lagrangian Gradient</span>
        <span class="s1">state.lagrangian_grad = np.copy(state.grad)</span>
        <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">prepared_constraints:</span>
            <span class="s1">state.lagrangian_grad += c.fun.J.T.dot(c.fun.v)</span>
        <span class="s1">state.optimality = np.linalg.norm(state.lagrangian_grad</span><span class="s0">, </span><span class="s1">np.inf)</span>
        <span class="s5"># Compute maximum constraint violation</span>
        <span class="s1">state.constr_violation = </span><span class="s2">0</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(prepared_constraints)):</span>
            <span class="s1">lb</span><span class="s0">, </span><span class="s1">ub = prepared_constraints[i].bounds</span>
            <span class="s1">c = state.constr[i]</span>
            <span class="s1">state.constr_violation = np.max([state.constr_violation</span><span class="s0">,</span>
                                             <span class="s1">np.max(lb - c)</span><span class="s0">,</span>
                                             <span class="s1">np.max(c - ub)])</span>

    <span class="s1">state.execution_time = time.time() - start_time</span>
    <span class="s1">state.tr_radius = tr_radius</span>
    <span class="s1">state.constr_penalty = constr_penalty</span>
    <span class="s1">state.cg_niter += cg_info[</span><span class="s3">&quot;niter&quot;</span><span class="s1">]</span>
    <span class="s1">state.cg_stop_cond = cg_info[</span><span class="s3">&quot;stop_cond&quot;</span><span class="s1">]</span>

    <span class="s0">return </span><span class="s1">state</span>


<span class="s0">def </span><span class="s1">update_state_ip(state</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">last_iteration_failed</span><span class="s0">, </span><span class="s1">objective</span><span class="s0">,</span>
                    <span class="s1">prepared_constraints</span><span class="s0">, </span><span class="s1">start_time</span><span class="s0">,</span>
                    <span class="s1">tr_radius</span><span class="s0">, </span><span class="s1">constr_penalty</span><span class="s0">, </span><span class="s1">cg_info</span><span class="s0">,</span>
                    <span class="s1">barrier_parameter</span><span class="s0">, </span><span class="s1">barrier_tolerance):</span>
    <span class="s1">state = update_state_sqp(state</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">last_iteration_failed</span><span class="s0">, </span><span class="s1">objective</span><span class="s0">,</span>
                             <span class="s1">prepared_constraints</span><span class="s0">, </span><span class="s1">start_time</span><span class="s0">, </span><span class="s1">tr_radius</span><span class="s0">,</span>
                             <span class="s1">constr_penalty</span><span class="s0">, </span><span class="s1">cg_info)</span>
    <span class="s1">state.barrier_parameter = barrier_parameter</span>
    <span class="s1">state.barrier_tolerance = barrier_tolerance</span>
    <span class="s0">return </span><span class="s1">state</span>


<span class="s0">def </span><span class="s1">_minimize_trustregion_constr(fun</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">grad</span><span class="s0">,</span>
                                 <span class="s1">hess</span><span class="s0">, </span><span class="s1">hessp</span><span class="s0">, </span><span class="s1">bounds</span><span class="s0">, </span><span class="s1">constraints</span><span class="s0">,</span>
                                 <span class="s1">xtol=</span><span class="s2">1e-8</span><span class="s0">, </span><span class="s1">gtol=</span><span class="s2">1e-8</span><span class="s0">,</span>
                                 <span class="s1">barrier_tol=</span><span class="s2">1e-8</span><span class="s0">,</span>
                                 <span class="s1">sparse_jacobian=</span><span class="s0">None,</span>
                                 <span class="s1">callback=</span><span class="s0">None, </span><span class="s1">maxiter=</span><span class="s2">1000</span><span class="s0">,</span>
                                 <span class="s1">verbose=</span><span class="s2">0</span><span class="s0">, </span><span class="s1">finite_diff_rel_step=</span><span class="s0">None,</span>
                                 <span class="s1">initial_constr_penalty=</span><span class="s2">1.0</span><span class="s0">, </span><span class="s1">initial_tr_radius=</span><span class="s2">1.0</span><span class="s0">,</span>
                                 <span class="s1">initial_barrier_parameter=</span><span class="s2">0.1</span><span class="s0">,</span>
                                 <span class="s1">initial_barrier_tolerance=</span><span class="s2">0.1</span><span class="s0">,</span>
                                 <span class="s1">factorization_method=</span><span class="s0">None,</span>
                                 <span class="s1">disp=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Minimize a scalar function subject to constraints. 
 
    Parameters 
    ---------- 
    gtol : float, optional 
        Tolerance for termination by the norm of the Lagrangian gradient. 
        The algorithm will terminate when both the infinity norm (i.e., max 
        abs value) of the Lagrangian gradient and the constraint violation 
        are smaller than ``gtol``. Default is 1e-8. 
    xtol : float, optional 
        Tolerance for termination by the change of the independent variable. 
        The algorithm will terminate when ``tr_radius &lt; xtol``, where 
        ``tr_radius`` is the radius of the trust region used in the algorithm. 
        Default is 1e-8. 
    barrier_tol : float, optional 
        Threshold on the barrier parameter for the algorithm termination. 
        When inequality constraints are present, the algorithm will terminate 
        only when the barrier parameter is less than `barrier_tol`. 
        Default is 1e-8. 
    sparse_jacobian : {bool, None}, optional 
        Determines how to represent Jacobians of the constraints. If bool, 
        then Jacobians of all the constraints will be converted to the 
        corresponding format. If None (default), then Jacobians won't be 
        converted, but the algorithm can proceed only if they all have the 
        same format. 
    initial_tr_radius: float, optional 
        Initial trust radius. The trust radius gives the maximum distance 
        between solution points in consecutive iterations. It reflects the 
        trust the algorithm puts in the local approximation of the optimization 
        problem. For an accurate local approximation the trust-region should be 
        large and for an  approximation valid only close to the current point it 
        should be a small one. The trust radius is automatically updated throughout 
        the optimization process, with ``initial_tr_radius`` being its initial value. 
        Default is 1 (recommended in [1]_, p. 19). 
    initial_constr_penalty : float, optional 
        Initial constraints penalty parameter. The penalty parameter is used for 
        balancing the requirements of decreasing the objective function 
        and satisfying the constraints. It is used for defining the merit function: 
        ``merit_function(x) = fun(x) + constr_penalty * constr_norm_l2(x)``, 
        where ``constr_norm_l2(x)`` is the l2 norm of a vector containing all 
        the constraints. The merit function is used for accepting or rejecting 
        trial points and ``constr_penalty`` weights the two conflicting goals 
        of reducing objective function and constraints. The penalty is automatically 
        updated throughout the optimization  process, with 
        ``initial_constr_penalty`` being its  initial value. Default is 1 
        (recommended in [1]_, p 19). 
    initial_barrier_parameter, initial_barrier_tolerance: float, optional 
        Initial barrier parameter and initial tolerance for the barrier subproblem. 
        Both are used only when inequality constraints are present. For dealing with 
        optimization problems ``min_x f(x)`` subject to inequality constraints 
        ``c(x) &lt;= 0`` the algorithm introduces slack variables, solving the problem 
        ``min_(x,s) f(x) + barrier_parameter*sum(ln(s))`` subject to the equality 
        constraints  ``c(x) + s = 0`` instead of the original problem. This subproblem 
        is solved for decreasing values of ``barrier_parameter`` and with decreasing 
        tolerances for the termination, starting with ``initial_barrier_parameter`` 
        for the barrier parameter and ``initial_barrier_tolerance`` for the 
        barrier tolerance. Default is 0.1 for both values (recommended in [1]_ p. 19). 
        Also note that ``barrier_parameter`` and ``barrier_tolerance`` are updated 
        with the same prefactor. 
    factorization_method : string or None, optional 
        Method to factorize the Jacobian of the constraints. Use None (default) 
        for the auto selection or one of: 
 
            - 'NormalEquation' (requires scikit-sparse) 
            - 'AugmentedSystem' 
            - 'QRFactorization' 
            - 'SVDFactorization' 
 
        The methods 'NormalEquation' and 'AugmentedSystem' can be used only 
        with sparse constraints. The projections required by the algorithm 
        will be computed using, respectively, the normal equation  and the 
        augmented system approaches explained in [1]_. 'NormalEquation' 
        computes the Cholesky factorization of ``A A.T`` and 'AugmentedSystem' 
        performs the LU factorization of an augmented system. They usually 
        provide similar results. 'AugmentedSystem' is used by default for 
        sparse matrices. 
 
        The methods 'QRFactorization' and 'SVDFactorization' can be used 
        only with dense constraints. They compute the required projections 
        using, respectively, QR and SVD factorizations. The 'SVDFactorization' 
        method can cope with Jacobian matrices with deficient row rank and will 
        be used whenever other factorization methods fail (which may imply the 
        conversion of sparse matrices to a dense format when required). 
        By default, 'QRFactorization' is used for dense matrices. 
    finite_diff_rel_step : None or array_like, optional 
        Relative step size for the finite difference approximation. 
    maxiter : int, optional 
        Maximum number of algorithm iterations. Default is 1000. 
    verbose : {0, 1, 2}, optional 
        Level of algorithm's verbosity: 
 
            * 0 (default) : work silently. 
            * 1 : display a termination report. 
            * 2 : display progress during iterations. 
            * 3 : display progress during iterations (more complete report). 
 
    disp : bool, optional 
        If True (default), then `verbose` will be set to 1 if it was 0. 
 
    Returns 
    ------- 
    `OptimizeResult` with the fields documented below. Note the following: 
 
        1. All values corresponding to the constraints are ordered as they 
           were passed to the solver. And values corresponding to `bounds` 
           constraints are put *after* other constraints. 
        2. All numbers of function, Jacobian or Hessian evaluations correspond 
           to numbers of actual Python function calls. It means, for example, 
           that if a Jacobian is estimated by finite differences, then the 
           number of Jacobian evaluations will be zero and the number of 
           function evaluations will be incremented by all calls during the 
           finite difference estimation. 
 
    x : ndarray, shape (n,) 
        Solution found. 
    optimality : float 
        Infinity norm of the Lagrangian gradient at the solution. 
    constr_violation : float 
        Maximum constraint violation at the solution. 
    fun : float 
        Objective function at the solution. 
    grad : ndarray, shape (n,) 
        Gradient of the objective function at the solution. 
    lagrangian_grad : ndarray, shape (n,) 
        Gradient of the Lagrangian function at the solution. 
    nit : int 
        Total number of iterations. 
    nfev : integer 
        Number of the objective function evaluations. 
    njev : integer 
        Number of the objective function gradient evaluations. 
    nhev : integer 
        Number of the objective function Hessian evaluations. 
    cg_niter : int 
        Total number of the conjugate gradient method iterations. 
    method : {'equality_constrained_sqp', 'tr_interior_point'} 
        Optimization method used. 
    constr : list of ndarray 
        List of constraint values at the solution. 
    jac : list of {ndarray, sparse matrix} 
        List of the Jacobian matrices of the constraints at the solution. 
    v : list of ndarray 
        List of the Lagrange multipliers for the constraints at the solution. 
        For an inequality constraint a positive multiplier means that the upper 
        bound is active, a negative multiplier means that the lower bound is 
        active and if a multiplier is zero it means the constraint is not 
        active. 
    constr_nfev : list of int 
        Number of constraint evaluations for each of the constraints. 
    constr_njev : list of int 
        Number of Jacobian matrix evaluations for each of the constraints. 
    constr_nhev : list of int 
        Number of Hessian evaluations for each of the constraints. 
    tr_radius : float 
        Radius of the trust region at the last iteration. 
    constr_penalty : float 
        Penalty parameter at the last iteration, see `initial_constr_penalty`. 
    barrier_tolerance : float 
        Tolerance for the barrier subproblem at the last iteration. 
        Only for problems with inequality constraints. 
    barrier_parameter : float 
        Barrier parameter at the last iteration. Only for problems 
        with inequality constraints. 
    execution_time : float 
        Total execution time. 
    message : str 
        Termination message. 
    status : {0, 1, 2, 3} 
        Termination status: 
 
            * 0 : The maximum number of function evaluations is exceeded. 
            * 1 : `gtol` termination condition is satisfied. 
            * 2 : `xtol` termination condition is satisfied. 
            * 3 : `callback` function requested termination. 
 
    cg_stop_cond : int 
        Reason for CG subproblem termination at the last iteration: 
 
            * 0 : CG subproblem not evaluated. 
            * 1 : Iteration limit was reached. 
            * 2 : Reached the trust-region boundary. 
            * 3 : Negative curvature detected. 
            * 4 : Tolerance was satisfied. 
 
    References 
    ---------- 
    .. [1] Conn, A. R., Gould, N. I., &amp; Toint, P. L. 
           Trust region methods. 2000. Siam. pp. 19. 
    &quot;&quot;&quot;</span>
    <span class="s1">x0 = np.atleast_1d(x0).astype(float)</span>
    <span class="s1">n_vars = np.size(x0)</span>
    <span class="s0">if </span><span class="s1">hess </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">callable(hessp):</span>
            <span class="s1">hess = HessianLinearOperator(hessp</span><span class="s0">, </span><span class="s1">n_vars)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">hess = BFGS()</span>
    <span class="s0">if </span><span class="s1">disp </span><span class="s0">and </span><span class="s1">verbose == </span><span class="s2">0</span><span class="s1">:</span>
        <span class="s1">verbose = </span><span class="s2">1</span>

    <span class="s0">if </span><span class="s1">bounds </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">modified_lb = np.nextafter(bounds.lb</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s1">where=bounds.lb &gt; -np.inf)</span>
        <span class="s1">modified_ub = np.nextafter(bounds.ub</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">where=bounds.ub &lt; np.inf)</span>
        <span class="s1">modified_lb = np.where(np.isfinite(bounds.lb)</span><span class="s0">, </span><span class="s1">modified_lb</span><span class="s0">, </span><span class="s1">bounds.lb)</span>
        <span class="s1">modified_ub = np.where(np.isfinite(bounds.ub)</span><span class="s0">, </span><span class="s1">modified_ub</span><span class="s0">, </span><span class="s1">bounds.ub)</span>
        <span class="s1">bounds = Bounds(modified_lb</span><span class="s0">, </span><span class="s1">modified_ub</span><span class="s0">, </span><span class="s1">keep_feasible=bounds.keep_feasible)</span>
        <span class="s1">finite_diff_bounds = strict_bounds(bounds.lb</span><span class="s0">, </span><span class="s1">bounds.ub</span><span class="s0">,</span>
                                           <span class="s1">bounds.keep_feasible</span><span class="s0">, </span><span class="s1">n_vars)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">finite_diff_bounds = (-np.inf</span><span class="s0">, </span><span class="s1">np.inf)</span>

    <span class="s5"># Define Objective Function</span>
    <span class="s1">objective = ScalarFunction(fun</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">grad</span><span class="s0">, </span><span class="s1">hess</span><span class="s0">,</span>
                               <span class="s1">finite_diff_rel_step</span><span class="s0">, </span><span class="s1">finite_diff_bounds)</span>

    <span class="s5"># Put constraints in list format when needed.</span>
    <span class="s0">if </span><span class="s1">isinstance(constraints</span><span class="s0">, </span><span class="s1">(NonlinearConstraint</span><span class="s0">, </span><span class="s1">LinearConstraint)):</span>
        <span class="s1">constraints = [constraints]</span>

    <span class="s5"># Prepare constraints.</span>
    <span class="s1">prepared_constraints = [</span>
        <span class="s1">PreparedConstraint(c</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">sparse_jacobian</span><span class="s0">, </span><span class="s1">finite_diff_bounds)</span>
        <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">constraints]</span>

    <span class="s5"># Check that all constraints are either sparse or dense.</span>
    <span class="s1">n_sparse = sum(c.fun.sparse_jacobian </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">prepared_constraints)</span>
    <span class="s0">if </span><span class="s2">0 </span><span class="s1">&lt; n_sparse &lt; len(prepared_constraints):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;All constraints must have the same kind of the &quot;</span>
                         <span class="s3">&quot;Jacobian --- either all sparse or all dense. &quot;</span>
                         <span class="s3">&quot;You can set the sparsity globally by setting &quot;</span>
                         <span class="s3">&quot;`sparse_jacobian` to either True of False.&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">prepared_constraints:</span>
        <span class="s1">sparse_jacobian = n_sparse &gt; </span><span class="s2">0</span>

    <span class="s0">if </span><span class="s1">bounds </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">sparse_jacobian </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">sparse_jacobian = </span><span class="s0">True</span>
        <span class="s1">prepared_constraints.append(PreparedConstraint(bounds</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                                                       <span class="s1">sparse_jacobian))</span>

    <span class="s5"># Concatenate initial constraints to the canonical form.</span>
    <span class="s1">c_eq0</span><span class="s0">, </span><span class="s1">c_ineq0</span><span class="s0">, </span><span class="s1">J_eq0</span><span class="s0">, </span><span class="s1">J_ineq0 = initial_constraints_as_canonical(</span>
        <span class="s1">n_vars</span><span class="s0">, </span><span class="s1">prepared_constraints</span><span class="s0">, </span><span class="s1">sparse_jacobian)</span>

    <span class="s5"># Prepare all canonical constraints and concatenate it into one.</span>
    <span class="s1">canonical_all = [CanonicalConstraint.from_PreparedConstraint(c)</span>
                     <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">prepared_constraints]</span>

    <span class="s0">if </span><span class="s1">len(canonical_all) == </span><span class="s2">0</span><span class="s1">:</span>
        <span class="s1">canonical = CanonicalConstraint.empty(n_vars)</span>
    <span class="s0">elif </span><span class="s1">len(canonical_all) == </span><span class="s2">1</span><span class="s1">:</span>
        <span class="s1">canonical = canonical_all[</span><span class="s2">0</span><span class="s1">]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">canonical = CanonicalConstraint.concatenate(canonical_all</span><span class="s0">,</span>
                                                    <span class="s1">sparse_jacobian)</span>

    <span class="s5"># Generate the Hessian of the Lagrangian.</span>
    <span class="s1">lagrangian_hess = LagrangianHessian(n_vars</span><span class="s0">, </span><span class="s1">objective.hess</span><span class="s0">, </span><span class="s1">canonical.hess)</span>

    <span class="s5"># Choose appropriate method</span>
    <span class="s0">if </span><span class="s1">canonical.n_ineq == </span><span class="s2">0</span><span class="s1">:</span>
        <span class="s1">method = </span><span class="s3">'equality_constrained_sqp'</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">method = </span><span class="s3">'tr_interior_point'</span>

    <span class="s5"># Construct OptimizeResult</span>
    <span class="s1">state = OptimizeResult(</span>
        <span class="s1">nit=</span><span class="s2">0</span><span class="s0">, </span><span class="s1">nfev=</span><span class="s2">0</span><span class="s0">, </span><span class="s1">njev=</span><span class="s2">0</span><span class="s0">, </span><span class="s1">nhev=</span><span class="s2">0</span><span class="s0">,</span>
        <span class="s1">cg_niter=</span><span class="s2">0</span><span class="s0">, </span><span class="s1">cg_stop_cond=</span><span class="s2">0</span><span class="s0">,</span>
        <span class="s1">fun=objective.f</span><span class="s0">, </span><span class="s1">grad=objective.g</span><span class="s0">,</span>
        <span class="s1">lagrangian_grad=np.copy(objective.g)</span><span class="s0">,</span>
        <span class="s1">constr=[c.fun.f </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">prepared_constraints]</span><span class="s0">,</span>
        <span class="s1">jac=[c.fun.J </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">prepared_constraints]</span><span class="s0">,</span>
        <span class="s1">constr_nfev=[</span><span class="s2">0 </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">prepared_constraints]</span><span class="s0">,</span>
        <span class="s1">constr_njev=[</span><span class="s2">0 </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">prepared_constraints]</span><span class="s0">,</span>
        <span class="s1">constr_nhev=[</span><span class="s2">0 </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">prepared_constraints]</span><span class="s0">,</span>
        <span class="s1">v=[c.fun.v </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">prepared_constraints]</span><span class="s0">,</span>
        <span class="s1">method=method)</span>

    <span class="s5"># Start counting</span>
    <span class="s1">start_time = time.time()</span>

    <span class="s5"># Define stop criteria</span>
    <span class="s0">if </span><span class="s1">method == </span><span class="s3">'equality_constrained_sqp'</span><span class="s1">:</span>
        <span class="s0">def </span><span class="s1">stop_criteria(state</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">last_iteration_failed</span><span class="s0">,</span>
                          <span class="s1">optimality</span><span class="s0">, </span><span class="s1">constr_violation</span><span class="s0">,</span>
                          <span class="s1">tr_radius</span><span class="s0">, </span><span class="s1">constr_penalty</span><span class="s0">, </span><span class="s1">cg_info):</span>
            <span class="s1">state = update_state_sqp(state</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">last_iteration_failed</span><span class="s0">,</span>
                                     <span class="s1">objective</span><span class="s0">, </span><span class="s1">prepared_constraints</span><span class="s0">,</span>
                                     <span class="s1">start_time</span><span class="s0">, </span><span class="s1">tr_radius</span><span class="s0">, </span><span class="s1">constr_penalty</span><span class="s0">,</span>
                                     <span class="s1">cg_info)</span>
            <span class="s0">if </span><span class="s1">verbose == </span><span class="s2">2</span><span class="s1">:</span>
                <span class="s1">BasicReport.print_iteration(state.nit</span><span class="s0">,</span>
                                            <span class="s1">state.nfev</span><span class="s0">,</span>
                                            <span class="s1">state.cg_niter</span><span class="s0">,</span>
                                            <span class="s1">state.fun</span><span class="s0">,</span>
                                            <span class="s1">state.tr_radius</span><span class="s0">,</span>
                                            <span class="s1">state.optimality</span><span class="s0">,</span>
                                            <span class="s1">state.constr_violation)</span>
            <span class="s0">elif </span><span class="s1">verbose &gt; </span><span class="s2">2</span><span class="s1">:</span>
                <span class="s1">SQPReport.print_iteration(state.nit</span><span class="s0">,</span>
                                          <span class="s1">state.nfev</span><span class="s0">,</span>
                                          <span class="s1">state.cg_niter</span><span class="s0">,</span>
                                          <span class="s1">state.fun</span><span class="s0">,</span>
                                          <span class="s1">state.tr_radius</span><span class="s0">,</span>
                                          <span class="s1">state.optimality</span><span class="s0">,</span>
                                          <span class="s1">state.constr_violation</span><span class="s0">,</span>
                                          <span class="s1">state.constr_penalty</span><span class="s0">,</span>
                                          <span class="s1">state.cg_stop_cond)</span>
            <span class="s1">state.status = </span><span class="s0">None</span>
            <span class="s1">state.niter = state.nit  </span><span class="s5"># Alias for callback (backward-compatibility)</span>
            <span class="s0">if </span><span class="s1">callback </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">callback_stop = </span><span class="s0">False</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">callback_stop = callback(state)</span>
                <span class="s0">except </span><span class="s1">StopIteration:</span>
                    <span class="s1">callback_stop = </span><span class="s0">True</span>
                <span class="s0">if </span><span class="s1">callback_stop:</span>
                    <span class="s1">state.status = </span><span class="s2">3</span>
                    <span class="s0">return True</span>
            <span class="s0">if </span><span class="s1">state.optimality &lt; gtol </span><span class="s0">and </span><span class="s1">state.constr_violation &lt; gtol:</span>
                <span class="s1">state.status = </span><span class="s2">1</span>
            <span class="s0">elif </span><span class="s1">state.tr_radius &lt; xtol:</span>
                <span class="s1">state.status = </span><span class="s2">2</span>
            <span class="s0">elif </span><span class="s1">state.nit &gt;= maxiter:</span>
                <span class="s1">state.status = </span><span class="s2">0</span>
            <span class="s0">return </span><span class="s1">state.status </span><span class="s0">in </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">method == </span><span class="s3">'tr_interior_point'</span><span class="s1">:</span>
        <span class="s0">def </span><span class="s1">stop_criteria(state</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">last_iteration_failed</span><span class="s0">, </span><span class="s1">tr_radius</span><span class="s0">,</span>
                          <span class="s1">constr_penalty</span><span class="s0">, </span><span class="s1">cg_info</span><span class="s0">, </span><span class="s1">barrier_parameter</span><span class="s0">,</span>
                          <span class="s1">barrier_tolerance):</span>
            <span class="s1">state = update_state_ip(state</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">last_iteration_failed</span><span class="s0">,</span>
                                    <span class="s1">objective</span><span class="s0">, </span><span class="s1">prepared_constraints</span><span class="s0">,</span>
                                    <span class="s1">start_time</span><span class="s0">, </span><span class="s1">tr_radius</span><span class="s0">, </span><span class="s1">constr_penalty</span><span class="s0">,</span>
                                    <span class="s1">cg_info</span><span class="s0">, </span><span class="s1">barrier_parameter</span><span class="s0">, </span><span class="s1">barrier_tolerance)</span>
            <span class="s0">if </span><span class="s1">verbose == </span><span class="s2">2</span><span class="s1">:</span>
                <span class="s1">BasicReport.print_iteration(state.nit</span><span class="s0">,</span>
                                            <span class="s1">state.nfev</span><span class="s0">,</span>
                                            <span class="s1">state.cg_niter</span><span class="s0">,</span>
                                            <span class="s1">state.fun</span><span class="s0">,</span>
                                            <span class="s1">state.tr_radius</span><span class="s0">,</span>
                                            <span class="s1">state.optimality</span><span class="s0">,</span>
                                            <span class="s1">state.constr_violation)</span>
            <span class="s0">elif </span><span class="s1">verbose &gt; </span><span class="s2">2</span><span class="s1">:</span>
                <span class="s1">IPReport.print_iteration(state.nit</span><span class="s0">,</span>
                                         <span class="s1">state.nfev</span><span class="s0">,</span>
                                         <span class="s1">state.cg_niter</span><span class="s0">,</span>
                                         <span class="s1">state.fun</span><span class="s0">,</span>
                                         <span class="s1">state.tr_radius</span><span class="s0">,</span>
                                         <span class="s1">state.optimality</span><span class="s0">,</span>
                                         <span class="s1">state.constr_violation</span><span class="s0">,</span>
                                         <span class="s1">state.constr_penalty</span><span class="s0">,</span>
                                         <span class="s1">state.barrier_parameter</span><span class="s0">,</span>
                                         <span class="s1">state.cg_stop_cond)</span>
            <span class="s1">state.status = </span><span class="s0">None</span>
            <span class="s1">state.niter = state.nit  </span><span class="s5"># Alias for callback (backward compatibility)</span>
            <span class="s0">if </span><span class="s1">callback </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">callback_stop = </span><span class="s0">False</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">callback_stop = callback(state)</span>
                <span class="s0">except </span><span class="s1">StopIteration:</span>
                    <span class="s1">callback_stop = </span><span class="s0">True</span>
                <span class="s0">if </span><span class="s1">callback_stop:</span>
                    <span class="s1">state.status = </span><span class="s2">3</span>
                    <span class="s0">return True</span>
            <span class="s0">if </span><span class="s1">state.optimality &lt; gtol </span><span class="s0">and </span><span class="s1">state.constr_violation &lt; gtol:</span>
                <span class="s1">state.status = </span><span class="s2">1</span>
            <span class="s0">elif </span><span class="s1">(state.tr_radius &lt; xtol</span>
                  <span class="s0">and </span><span class="s1">state.barrier_parameter &lt; barrier_tol):</span>
                <span class="s1">state.status = </span><span class="s2">2</span>
            <span class="s0">elif </span><span class="s1">state.nit &gt;= maxiter:</span>
                <span class="s1">state.status = </span><span class="s2">0</span>
            <span class="s0">return </span><span class="s1">state.status </span><span class="s0">in </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">verbose == </span><span class="s2">2</span><span class="s1">:</span>
        <span class="s1">BasicReport.print_header()</span>
    <span class="s0">elif </span><span class="s1">verbose &gt; </span><span class="s2">2</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">method == </span><span class="s3">'equality_constrained_sqp'</span><span class="s1">:</span>
            <span class="s1">SQPReport.print_header()</span>
        <span class="s0">elif </span><span class="s1">method == </span><span class="s3">'tr_interior_point'</span><span class="s1">:</span>
            <span class="s1">IPReport.print_header()</span>

    <span class="s5"># Call inferior function to do the optimization</span>
    <span class="s0">if </span><span class="s1">method == </span><span class="s3">'equality_constrained_sqp'</span><span class="s1">:</span>
        <span class="s0">def </span><span class="s1">fun_and_constr(x):</span>
            <span class="s1">f = objective.fun(x)</span>
            <span class="s1">c_eq</span><span class="s0">, </span><span class="s1">_ = canonical.fun(x)</span>
            <span class="s0">return </span><span class="s1">f</span><span class="s0">, </span><span class="s1">c_eq</span>

        <span class="s0">def </span><span class="s1">grad_and_jac(x):</span>
            <span class="s1">g = objective.grad(x)</span>
            <span class="s1">J_eq</span><span class="s0">, </span><span class="s1">_ = canonical.jac(x)</span>
            <span class="s0">return </span><span class="s1">g</span><span class="s0">, </span><span class="s1">J_eq</span>

        <span class="s1">_</span><span class="s0">, </span><span class="s1">result = equality_constrained_sqp(</span>
            <span class="s1">fun_and_constr</span><span class="s0">, </span><span class="s1">grad_and_jac</span><span class="s0">, </span><span class="s1">lagrangian_hess</span><span class="s0">,</span>
            <span class="s1">x0</span><span class="s0">, </span><span class="s1">objective.f</span><span class="s0">, </span><span class="s1">objective.g</span><span class="s0">,</span>
            <span class="s1">c_eq0</span><span class="s0">, </span><span class="s1">J_eq0</span><span class="s0">,</span>
            <span class="s1">stop_criteria</span><span class="s0">, </span><span class="s1">state</span><span class="s0">,</span>
            <span class="s1">initial_constr_penalty</span><span class="s0">, </span><span class="s1">initial_tr_radius</span><span class="s0">,</span>
            <span class="s1">factorization_method)</span>

    <span class="s0">elif </span><span class="s1">method == </span><span class="s3">'tr_interior_point'</span><span class="s1">:</span>
        <span class="s1">_</span><span class="s0">, </span><span class="s1">result = tr_interior_point(</span>
            <span class="s1">objective.fun</span><span class="s0">, </span><span class="s1">objective.grad</span><span class="s0">, </span><span class="s1">lagrangian_hess</span><span class="s0">,</span>
            <span class="s1">n_vars</span><span class="s0">, </span><span class="s1">canonical.n_ineq</span><span class="s0">, </span><span class="s1">canonical.n_eq</span><span class="s0">,</span>
            <span class="s1">canonical.fun</span><span class="s0">, </span><span class="s1">canonical.jac</span><span class="s0">,</span>
            <span class="s1">x0</span><span class="s0">, </span><span class="s1">objective.f</span><span class="s0">, </span><span class="s1">objective.g</span><span class="s0">,</span>
            <span class="s1">c_ineq0</span><span class="s0">, </span><span class="s1">J_ineq0</span><span class="s0">, </span><span class="s1">c_eq0</span><span class="s0">, </span><span class="s1">J_eq0</span><span class="s0">,</span>
            <span class="s1">stop_criteria</span><span class="s0">,</span>
            <span class="s1">canonical.keep_feasible</span><span class="s0">,</span>
            <span class="s1">xtol</span><span class="s0">, </span><span class="s1">state</span><span class="s0">, </span><span class="s1">initial_barrier_parameter</span><span class="s0">,</span>
            <span class="s1">initial_barrier_tolerance</span><span class="s0">,</span>
            <span class="s1">initial_constr_penalty</span><span class="s0">, </span><span class="s1">initial_tr_radius</span><span class="s0">,</span>
            <span class="s1">factorization_method)</span>

    <span class="s5"># Status 3 occurs when the callback function requests termination,</span>
    <span class="s5"># this is assumed to not be a success.</span>
    <span class="s1">result.success = </span><span class="s0">True if </span><span class="s1">result.status </span><span class="s0">in </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">) </span><span class="s0">else False</span>
    <span class="s1">result.message = TERMINATION_MESSAGES[result.status]</span>

    <span class="s5"># Alias (for backward compatibility with 1.1.0)</span>
    <span class="s1">result.niter = result.nit</span>

    <span class="s0">if </span><span class="s1">verbose == </span><span class="s2">2</span><span class="s1">:</span>
        <span class="s1">BasicReport.print_footer()</span>
    <span class="s0">elif </span><span class="s1">verbose &gt; </span><span class="s2">2</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">method == </span><span class="s3">'equality_constrained_sqp'</span><span class="s1">:</span>
            <span class="s1">SQPReport.print_footer()</span>
        <span class="s0">elif </span><span class="s1">method == </span><span class="s3">'tr_interior_point'</span><span class="s1">:</span>
            <span class="s1">IPReport.print_footer()</span>
    <span class="s0">if </span><span class="s1">verbose &gt;= </span><span class="s2">1</span><span class="s1">:</span>
        <span class="s1">print(result.message)</span>
        <span class="s1">print(</span><span class="s3">&quot;Number of iterations: {}, function evaluations: {}, &quot;</span>
              <span class="s3">&quot;CG iterations: {}, optimality: {:.2e}, &quot;</span>
              <span class="s3">&quot;constraint violation: {:.2e}, execution time: {:4.2} s.&quot;</span>
              <span class="s1">.format(result.nit</span><span class="s0">, </span><span class="s1">result.nfev</span><span class="s0">, </span><span class="s1">result.cg_niter</span><span class="s0">,</span>
                      <span class="s1">result.optimality</span><span class="s0">, </span><span class="s1">result.constr_violation</span><span class="s0">,</span>
                      <span class="s1">result.execution_time))</span>
    <span class="s0">return </span><span class="s1">result</span>
</pre>
</body>
</html>