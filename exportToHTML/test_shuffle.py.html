<html>
<head>
<title>test_shuffle.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #629755; font-style: italic;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_shuffle.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">itertools</span>
<span class="s0">import </span><span class="s1">multiprocessing </span><span class="s0">as </span><span class="s1">mp</span>
<span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">pickle</span>
<span class="s0">import </span><span class="s1">random</span>
<span class="s0">import </span><span class="s1">string</span>
<span class="s0">import </span><span class="s1">tempfile</span>
<span class="s0">from </span><span class="s1">concurrent.futures </span><span class="s0">import </span><span class="s1">ProcessPoolExecutor</span>
<span class="s0">from </span><span class="s1">copy </span><span class="s0">import </span><span class="s1">copy</span>
<span class="s0">from </span><span class="s1">datetime </span><span class="s0">import </span><span class="s1">date</span><span class="s0">, </span><span class="s1">time</span>
<span class="s0">from </span><span class="s1">decimal </span><span class="s0">import </span><span class="s1">Decimal</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">partial</span>
<span class="s0">from </span><span class="s1">unittest </span><span class="s0">import </span><span class="s1">mock</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">import </span><span class="s1">dask</span>
<span class="s0">import </span><span class="s1">dask.dataframe </span><span class="s0">as </span><span class="s1">dd</span>
<span class="s0">from </span><span class="s1">dask.base </span><span class="s0">import </span><span class="s1">compute_as_if_collection</span>
<span class="s0">from </span><span class="s1">dask.dataframe._compat </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">PANDAS_GE_140</span><span class="s0">,</span>
    <span class="s1">PANDAS_GE_150</span><span class="s0">,</span>
    <span class="s1">PANDAS_GE_200</span><span class="s0">,</span>
    <span class="s1">PANDAS_GE_220</span><span class="s0">,</span>
    <span class="s1">assert_categorical_equal</span><span class="s0">,</span>
    <span class="s1">tm</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">dask.dataframe.shuffle </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">_calculate_divisions</span><span class="s0">,</span>
    <span class="s1">_noop</span><span class="s0">,</span>
    <span class="s1">maybe_buffered_partd</span><span class="s0">,</span>
    <span class="s1">partitioning_index</span><span class="s0">,</span>
    <span class="s1">rearrange_by_column</span><span class="s0">,</span>
    <span class="s1">rearrange_by_divisions</span><span class="s0">,</span>
    <span class="s1">shuffle</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">dask.dataframe.utils </span><span class="s0">import </span><span class="s1">assert_eq</span><span class="s0">, </span><span class="s1">make_meta</span>
<span class="s0">from </span><span class="s1">dask.optimization </span><span class="s0">import </span><span class="s1">cull</span>

<span class="s0">try</span><span class="s1">:</span>
    <span class="s0">import </span><span class="s1">pyarrow </span><span class="s0">as </span><span class="s1">pa</span>
<span class="s0">except </span><span class="s1">ImportError:</span>
    <span class="s1">pa = </span><span class="s0">None</span>

<span class="s1">dsk = {</span>
    <span class="s1">(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s3">0</span><span class="s1">): pd.DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">7</span><span class="s1">]}</span><span class="s0">, </span><span class="s1">index=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">): pd.DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s3">2</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">8</span><span class="s1">]}</span><span class="s0">, </span><span class="s1">index=[</span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">8</span><span class="s1">])</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s1">): pd.DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">7</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">9</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s3">3</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">9</span><span class="s1">]}</span><span class="s0">, </span><span class="s1">index=[</span><span class="s3">9</span><span class="s0">, </span><span class="s3">9</span><span class="s0">, </span><span class="s3">9</span><span class="s1">])</span><span class="s0">,</span>
<span class="s1">}</span>
<span class="s1">meta = make_meta(</span>
    <span class="s1">{</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s2">&quot;i8&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s2">&quot;i8&quot;</span><span class="s1">}</span><span class="s0">, </span><span class="s1">index=pd.Index([]</span><span class="s0">, </span><span class="s2">&quot;i8&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">parent_meta=pd.DataFrame()</span>
<span class="s1">)</span>
<span class="s1">d = dd.DataFrame(dsk</span><span class="s0">, </span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">meta</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">9</span><span class="s0">, </span><span class="s3">9</span><span class="s1">])</span>
<span class="s1">full = d.compute()</span>

<span class="s1">shuffle_func = shuffle  </span><span class="s4"># conflicts with keyword argument</span>


<span class="s0">def </span><span class="s1">test_shuffle(shuffle_method):</span>
    <span class="s1">s = shuffle_func(d</span><span class="s0">, </span><span class="s1">d.b</span><span class="s0">, </span><span class="s1">shuffle=shuffle_method)</span>
    <span class="s0">assert </span><span class="s1">isinstance(s</span><span class="s0">, </span><span class="s1">dd.DataFrame)</span>
    <span class="s0">assert </span><span class="s1">s.npartitions == d.npartitions</span>

    <span class="s1">x = dask.get(s.dask</span><span class="s0">, </span><span class="s1">(s._name</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
    <span class="s1">y = dask.get(s.dask</span><span class="s0">, </span><span class="s1">(s._name</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>

    <span class="s0">assert not </span><span class="s1">(set(x.b) &amp; set(y.b))  </span><span class="s4"># disjoint</span>
    <span class="s0">assert </span><span class="s1">set(s.dask).issuperset(d.dask)</span>

    <span class="s0">assert </span><span class="s1">shuffle_func(d</span><span class="s0">, </span><span class="s1">d.b)._name == shuffle_func(d</span><span class="s0">, </span><span class="s1">d.b)._name</span>


<span class="s0">def </span><span class="s1">test_default_partitions():</span>
    <span class="s0">assert </span><span class="s1">shuffle(d</span><span class="s0">, </span><span class="s1">d.b).npartitions == d.npartitions</span>


<span class="s0">def </span><span class="s1">test_shuffle_npartitions(shuffle_method):</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: np.random.random(</span><span class="s3">100</span><span class="s1">)})</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">s = shuffle(ddf</span><span class="s0">, </span><span class="s1">ddf.x</span><span class="s0">, </span><span class="s1">shuffle=shuffle_method</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">17</span><span class="s0">, </span><span class="s1">max_branch=</span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">sc = s.compute()</span>
    <span class="s0">assert </span><span class="s1">s.npartitions == </span><span class="s3">17</span>
    <span class="s0">assert </span><span class="s1">set(s.dask).issuperset(set(ddf.dask))</span>

    <span class="s0">assert </span><span class="s1">len(sc) == len(df)</span>
    <span class="s0">assert </span><span class="s1">list(s.columns) == list(df.columns)</span>
    <span class="s0">assert </span><span class="s1">set(map(tuple</span><span class="s0">, </span><span class="s1">sc.values.tolist())) == set(map(tuple</span><span class="s0">, </span><span class="s1">df.values.tolist()))</span>


<span class="s0">def </span><span class="s1">test_shuffle_npartitions_lt_input_partitions(shuffle_method):</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: np.random.random(</span><span class="s3">100</span><span class="s1">)})</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">20</span><span class="s1">)</span>
    <span class="s1">s = shuffle(ddf</span><span class="s0">, </span><span class="s1">ddf.x</span><span class="s0">, </span><span class="s1">shuffle=shuffle_method</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">5</span><span class="s0">, </span><span class="s1">max_branch=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">sc = s.compute()</span>
    <span class="s0">assert </span><span class="s1">s.npartitions == </span><span class="s3">5</span>
    <span class="s0">assert </span><span class="s1">set(s.dask).issuperset(set(ddf.dask))</span>

    <span class="s0">assert </span><span class="s1">len(sc) == len(df)</span>
    <span class="s0">assert </span><span class="s1">list(s.columns) == list(df.columns)</span>
    <span class="s0">assert </span><span class="s1">set(map(tuple</span><span class="s0">, </span><span class="s1">sc.values.tolist())) == set(map(tuple</span><span class="s0">, </span><span class="s1">df.values.tolist()))</span>


<span class="s0">def </span><span class="s1">test_index_with_non_series(shuffle_method):</span>
    <span class="s0">from </span><span class="s1">dask.dataframe.tests.test_multi </span><span class="s0">import </span><span class="s1">list_eq</span>

    <span class="s1">list_eq(</span>
        <span class="s1">shuffle(d</span><span class="s0">, </span><span class="s1">d.b</span><span class="s0">, </span><span class="s1">shuffle=shuffle_method)</span><span class="s0">, </span><span class="s1">shuffle(d</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s1">shuffle=shuffle_method)</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_index_with_dataframe(shuffle_method):</span>
    <span class="s1">res1 = shuffle(d</span><span class="s0">, </span><span class="s1">d[[</span><span class="s2">&quot;b&quot;</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">shuffle=shuffle_method).compute()</span>
    <span class="s1">res2 = shuffle(d</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">shuffle=shuffle_method).compute()</span>
    <span class="s1">res3 = shuffle(d</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s1">shuffle=shuffle_method).compute()</span>

    <span class="s0">assert </span><span class="s1">sorted(res1.values.tolist()) == sorted(res2.values.tolist())</span>
    <span class="s0">assert </span><span class="s1">sorted(res1.values.tolist()) == sorted(res3.values.tolist())</span>


<span class="s0">def </span><span class="s1">test_shuffle_from_one_partition_to_one_other(shuffle_method):</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]})</span>
    <span class="s1">a = dd.from_pandas(df</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>

    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]:</span>
        <span class="s1">b = shuffle(a</span><span class="s0">, </span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">npartitions=i</span><span class="s0">, </span><span class="s1">shuffle=shuffle_method)</span>
        <span class="s0">assert </span><span class="s1">len(a.compute(scheduler=</span><span class="s2">&quot;sync&quot;</span><span class="s1">)) == len(b.compute(scheduler=</span><span class="s2">&quot;sync&quot;</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">test_shuffle_empty_partitions(shuffle_method):</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">] * </span><span class="s3">10</span><span class="s1">})</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">s = shuffle(ddf</span><span class="s0">, </span><span class="s1">ddf.x</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">6</span><span class="s0">, </span><span class="s1">shuffle=shuffle_method)</span>
    <span class="s1">parts = compute_as_if_collection(dd.DataFrame</span><span class="s0">, </span><span class="s1">s.dask</span><span class="s0">, </span><span class="s1">s.__dask_keys__())</span>
    <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">parts:</span>
        <span class="s0">assert </span><span class="s1">s.columns == p.columns</span>


<span class="s1">df2 = pd.DataFrame(</span>
    <span class="s1">{</span>
        <span class="s2">&quot;i32&quot;</span><span class="s1">: np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">] * </span><span class="s3">3</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;int32&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s2">&quot;f32&quot;</span><span class="s1">: np.array([</span><span class="s0">None, </span><span class="s3">2.5</span><span class="s0">, </span><span class="s3">3.5</span><span class="s1">] * </span><span class="s3">3</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;float32&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s2">&quot;cat&quot;</span><span class="s1">: pd.Series([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">] * </span><span class="s3">3</span><span class="s1">).astype(</span><span class="s2">&quot;category&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s2">&quot;obj&quot;</span><span class="s1">: pd.Series([</span><span class="s2">&quot;d&quot;</span><span class="s0">, </span><span class="s2">&quot;e&quot;</span><span class="s0">, </span><span class="s2">&quot;f&quot;</span><span class="s1">] * </span><span class="s3">3</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s2">&quot;bool&quot;</span><span class="s1">: np.array([</span><span class="s0">True, False, True</span><span class="s1">] * </span><span class="s3">3</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s2">&quot;dt&quot;</span><span class="s1">: pd.Series(pd.date_range(</span><span class="s2">&quot;20130101&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">9</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s2">&quot;dt_tz&quot;</span><span class="s1">: pd.Series(pd.date_range(</span><span class="s2">&quot;20130101&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">9</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;US/Eastern&quot;</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s2">&quot;td&quot;</span><span class="s1">: pd.Series(pd.timedelta_range(</span><span class="s2">&quot;2000&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">9</span><span class="s1">))</span><span class="s0">,</span>
    <span class="s1">}</span>
<span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_partitioning_index():</span>
    <span class="s1">res = partitioning_index(df2.i32</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">((res &lt; </span><span class="s3">3</span><span class="s1">) &amp; (res &gt;= </span><span class="s3">0</span><span class="s1">)).all()</span>
    <span class="s0">assert </span><span class="s1">len(np.unique(res)) &gt; </span><span class="s3">1</span>

    <span class="s0">assert </span><span class="s1">(partitioning_index(df2.i32</span><span class="s0">, </span><span class="s3">3</span><span class="s1">) == partitioning_index(df2.i32</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)).all()</span>

    <span class="s1">res = partitioning_index(df2[[</span><span class="s2">&quot;i32&quot;</span><span class="s1">]]</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">((res &lt; </span><span class="s3">3</span><span class="s1">) &amp; (res &gt;= </span><span class="s3">0</span><span class="s1">)).all()</span>
    <span class="s0">assert </span><span class="s1">len(np.unique(res)) &gt; </span><span class="s3">1</span>

    <span class="s1">res = partitioning_index(df2[[</span><span class="s2">&quot;cat&quot;</span><span class="s0">, </span><span class="s2">&quot;bool&quot;</span><span class="s0">, </span><span class="s2">&quot;f32&quot;</span><span class="s1">]]</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">((</span><span class="s3">0 </span><span class="s1">&lt;= res) &amp; (res &lt; </span><span class="s3">2</span><span class="s1">)).all()</span>

    <span class="s1">res = partitioning_index(df2.index</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">((res &lt; </span><span class="s3">4</span><span class="s1">) &amp; (res &gt;= </span><span class="s3">0</span><span class="s1">)).all()</span>
    <span class="s0">assert </span><span class="s1">len(np.unique(res)) &gt; </span><span class="s3">1</span>


<span class="s0">def </span><span class="s1">test_partitioning_index_categorical_on_values():</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: list(string.ascii_letters)</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">] * </span><span class="s3">13</span><span class="s1">})</span>
    <span class="s1">df.a = df.a.astype(</span><span class="s2">&quot;category&quot;</span><span class="s1">)</span>
    <span class="s1">df2 = df.copy()</span>
    <span class="s1">df2.a = df2.a.cat.set_categories(list(reversed(df2.a.cat.categories)))</span>

    <span class="s1">res = partitioning_index(df.a</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span>
    <span class="s1">res2 = partitioning_index(df2.a</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">(res == res2).all()</span>

    <span class="s1">res = partitioning_index(df</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span>
    <span class="s1">res2 = partitioning_index(df2</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">(res == res2).all()</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;npartitions&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s1">pytest.param(</span><span class="s3">23</span><span class="s0">, </span><span class="s1">marks=pytest.mark.slow)]</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_set_index_general(npartitions</span><span class="s0">, </span><span class="s1">shuffle_method):</span>
    <span class="s1">names = [</span><span class="s2">&quot;alice&quot;</span><span class="s0">, </span><span class="s2">&quot;bob&quot;</span><span class="s0">, </span><span class="s2">&quot;ricky&quot;</span><span class="s1">]</span>
    <span class="s1">df = pd.DataFrame(</span>
        <span class="s1">{</span>
            <span class="s2">&quot;x&quot;</span><span class="s1">: np.random.random(</span><span class="s3">100</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;y&quot;</span><span class="s1">: np.random.random(</span><span class="s3">100</span><span class="s1">) // </span><span class="s3">0.2</span><span class="s0">,</span>
            <span class="s2">&quot;z&quot;</span><span class="s1">: np.random.choice(names</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">index=np.random.random(</span><span class="s3">100</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s4"># Ensure extension dtypes work</span>
    <span class="s4"># NOTE: Older version of pandas have known issues with extension dtypes.</span>
    <span class="s4"># We generally expect extension dtypes to work well when using `pandas&gt;=1.4.0`.</span>
    <span class="s0">if </span><span class="s1">PANDAS_GE_140:</span>
        <span class="s1">df = df.astype({</span><span class="s2">&quot;x&quot;</span><span class="s1">: </span><span class="s2">&quot;Float64&quot;</span><span class="s0">, </span><span class="s2">&quot;z&quot;</span><span class="s1">: </span><span class="s2">&quot;string&quot;</span><span class="s1">})</span>

    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=npartitions)</span>

    <span class="s1">assert_eq(df.set_index(</span><span class="s2">&quot;x&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">ddf.set_index(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">shuffle=shuffle_method))</span>
    <span class="s1">assert_eq(df.set_index(</span><span class="s2">&quot;y&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">ddf.set_index(</span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s1">shuffle=shuffle_method))</span>
    <span class="s1">assert_eq(df.set_index(</span><span class="s2">&quot;z&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">ddf.set_index(</span><span class="s2">&quot;z&quot;</span><span class="s0">, </span><span class="s1">shuffle=shuffle_method))</span>
    <span class="s1">assert_eq(df.set_index(df.x)</span><span class="s0">, </span><span class="s1">ddf.set_index(ddf.x</span><span class="s0">, </span><span class="s1">shuffle=shuffle_method))</span>
    <span class="s1">assert_eq(</span>
        <span class="s1">df.set_index(df.x + df.y)</span><span class="s0">, </span><span class="s1">ddf.set_index(ddf.x + ddf.y</span><span class="s0">, </span><span class="s1">shuffle=shuffle_method)</span>
    <span class="s1">)</span>
    <span class="s1">assert_eq(df.set_index(df.x + </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">ddf.set_index(ddf.x + </span><span class="s3">1</span><span class="s0">, </span><span class="s1">shuffle=shuffle_method))</span>


<span class="s1">@pytest.mark.skipif(</span>
    <span class="s0">not </span><span class="s1">PANDAS_GE_150</span><span class="s0">, </span><span class="s1">reason=</span><span class="s2">&quot;Only test `string[pyarrow]` on recent versions of pandas&quot;</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;string_dtype&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;string[python]&quot;</span><span class="s0">, </span><span class="s2">&quot;string[pyarrow]&quot;</span><span class="s0">, </span><span class="s2">&quot;object&quot;</span><span class="s1">]</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_set_index_string(shuffle_method</span><span class="s0">, </span><span class="s1">string_dtype):</span>
    <span class="s0">if </span><span class="s1">string_dtype == </span><span class="s2">&quot;string[pyarrow]&quot;</span><span class="s1">:</span>
        <span class="s1">pytest.importorskip(</span><span class="s2">&quot;pyarrow&quot;</span><span class="s1">)</span>
    <span class="s1">names = [</span><span class="s2">&quot;alice&quot;</span><span class="s0">, </span><span class="s2">&quot;bob&quot;</span><span class="s0">, </span><span class="s2">&quot;ricky&quot;</span><span class="s1">]</span>
    <span class="s1">df = pd.DataFrame(</span>
        <span class="s1">{</span>
            <span class="s2">&quot;x&quot;</span><span class="s1">: np.random.random(</span><span class="s3">100</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;y&quot;</span><span class="s1">: np.random.choice(names</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">index=np.random.random(</span><span class="s3">100</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">df = df.astype({</span><span class="s2">&quot;y&quot;</span><span class="s1">: string_dtype})</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">assert_eq(df.set_index(</span><span class="s2">&quot;y&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">ddf.set_index(</span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s1">shuffle=shuffle_method))</span>


<span class="s0">def </span><span class="s1">test_set_index_self_index(shuffle_method):</span>
    <span class="s1">df = pd.DataFrame(</span>
        <span class="s1">{</span><span class="s2">&quot;x&quot;</span><span class="s1">: np.random.random(</span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: np.random.random(</span><span class="s3">100</span><span class="s1">) // </span><span class="s3">0.2</span><span class="s1">}</span><span class="s0">,</span>
        <span class="s1">index=np.random.random(</span><span class="s3">100</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">a = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">4</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;this is a no-op&quot;</span><span class="s1">):</span>
        <span class="s1">b = a.set_index(a.index</span><span class="s0">, </span><span class="s1">shuffle=shuffle_method)</span>
    <span class="s0">assert </span><span class="s1">a </span><span class="s0">is </span><span class="s1">b</span>

    <span class="s1">assert_eq(b</span><span class="s0">, </span><span class="s1">df.set_index(df.index))</span>


<span class="s0">def </span><span class="s1">test_set_index_names(shuffle_method):</span>
    <span class="s0">if </span><span class="s1">shuffle_method == </span><span class="s2">&quot;disk&quot;</span><span class="s1">:</span>
        <span class="s1">pytest.xfail(</span><span class="s2">&quot;dsk names in disk shuffle are not deterministic&quot;</span><span class="s1">)</span>

    <span class="s1">df = pd.DataFrame(</span>
        <span class="s1">{</span><span class="s2">&quot;x&quot;</span><span class="s1">: np.random.random(</span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: np.random.random(</span><span class="s3">100</span><span class="s1">) // </span><span class="s3">0.2</span><span class="s1">}</span><span class="s0">,</span>
        <span class="s1">index=np.random.random(</span><span class="s3">100</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">4</span><span class="s1">)</span>

    <span class="s0">assert </span><span class="s1">set(ddf.set_index(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">shuffle=shuffle_method).dask) == set(</span>
        <span class="s1">ddf.set_index(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">shuffle=shuffle_method).dask</span>
    <span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">set(ddf.set_index(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">shuffle=shuffle_method).dask) != set(</span>
        <span class="s1">ddf.set_index(</span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s1">shuffle=shuffle_method).dask</span>
    <span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">set(ddf.set_index(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">max_branch=</span><span class="s3">4</span><span class="s0">, </span><span class="s1">shuffle=shuffle_method).dask) != set(</span>
        <span class="s1">ddf.set_index(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">max_branch=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">shuffle=shuffle_method).dask</span>
    <span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">set(ddf.set_index(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">drop=</span><span class="s0">True, </span><span class="s1">shuffle=shuffle_method).dask) != set(</span>
        <span class="s1">ddf.set_index(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">drop=</span><span class="s0">False, </span><span class="s1">shuffle=shuffle_method).dask</span>
    <span class="s1">)</span>


<span class="s1">ME = </span><span class="s2">&quot;ME&quot; </span><span class="s0">if </span><span class="s1">PANDAS_GE_220 </span><span class="s0">else </span><span class="s2">&quot;M&quot;</span>


<span class="s0">def </span><span class="s1">test_set_index_2(shuffle_method):</span>
    <span class="s1">df = dd.demo.make_timeseries(</span>
        <span class="s2">&quot;2000&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;2004&quot;</span><span class="s0">,</span>
        <span class="s1">{</span><span class="s2">&quot;value&quot;</span><span class="s1">: float</span><span class="s0">, </span><span class="s2">&quot;name&quot;</span><span class="s1">: str</span><span class="s0">, </span><span class="s2">&quot;id&quot;</span><span class="s1">: int}</span><span class="s0">,</span>
        <span class="s1">freq=</span><span class="s2">&quot;2h&quot;</span><span class="s0">,</span>
        <span class="s1">partition_freq=</span><span class="s2">f&quot;1</span><span class="s0">{</span><span class="s1">ME</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s0">,</span>
        <span class="s1">seed=</span><span class="s3">1</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">df2 = df.set_index(</span><span class="s2">&quot;name&quot;</span><span class="s0">, </span><span class="s1">shuffle=shuffle_method)</span>
    <span class="s1">df2.value.sum().compute(scheduler=</span><span class="s2">&quot;sync&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_set_index_3(shuffle_method):</span>
    <span class="s1">df = pd.DataFrame(np.random.random((</span><span class="s3">10</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">])</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">5</span><span class="s1">)</span>

    <span class="s1">ddf2 = ddf.set_index(</span>
        <span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">shuffle=shuffle_method</span><span class="s0">, </span><span class="s1">max_branch=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">npartitions=ddf.npartitions</span>
    <span class="s1">)</span>
    <span class="s1">df2 = df.set_index(</span><span class="s2">&quot;x&quot;</span><span class="s1">)</span>
    <span class="s1">assert_eq(df2</span><span class="s0">, </span><span class="s1">ddf2)</span>
    <span class="s0">assert </span><span class="s1">ddf2.npartitions == ddf.npartitions</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;drop&quot;</span><span class="s0">, </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">))</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;append&quot;</span><span class="s0">, </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">))</span>
<span class="s0">def </span><span class="s1">test_set_index_no_sort(drop</span><span class="s0">, </span><span class="s1">append):</span>
    <span class="s5">&quot;&quot;&quot; 
    GH10333 - Allow setting index on existing partitions without 
    computing new divisions and repartitioning. 
    &quot;&quot;&quot;</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;col1&quot;</span><span class="s1">: [</span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;col2&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]})</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">2</span><span class="s1">)</span>

    <span class="s0">assert </span><span class="s1">ddf.npartitions &gt; </span><span class="s3">1</span>

    <span class="s4"># Default is sort=True</span>
    <span class="s4"># Index in ddf will be same values, but sorted</span>
    <span class="s1">df_result = df.set_index(</span><span class="s2">&quot;col1&quot;</span><span class="s1">)</span>
    <span class="s1">ddf_result = ddf.set_index(</span><span class="s2">&quot;col1&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">ddf_result.known_divisions</span>
    <span class="s1">assert_eq(ddf_result</span><span class="s0">, </span><span class="s1">df_result.sort_index()</span><span class="s0">, </span><span class="s1">sort_results=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s4"># Unknown divisions and index remains unsorted when sort is False</span>
    <span class="s4"># and thus equal to pandas set_index, adding extra kwargs also supported by</span>
    <span class="s4"># pandas set_index to ensure they're forwarded.</span>
    <span class="s1">df_result = df.set_index(</span><span class="s2">&quot;col1&quot;</span><span class="s0">, </span><span class="s1">drop=drop</span><span class="s0">, </span><span class="s1">append=append)</span>
    <span class="s1">ddf_result = ddf.set_index(</span><span class="s2">&quot;col1&quot;</span><span class="s0">, </span><span class="s1">sort=</span><span class="s0">False, </span><span class="s1">drop=drop</span><span class="s0">, </span><span class="s1">append=append)</span>
    <span class="s0">assert not </span><span class="s1">ddf_result.known_divisions</span>
    <span class="s1">assert_eq(ddf_result</span><span class="s0">, </span><span class="s1">df_result</span><span class="s0">, </span><span class="s1">sort_results=</span><span class="s0">False</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_shuffle_sort(shuffle_method):</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: [</span><span class="s3">9</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]})</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">3</span><span class="s1">)</span>

    <span class="s1">df2 = df.set_index(</span><span class="s2">&quot;x&quot;</span><span class="s1">).sort_index()</span>
    <span class="s1">ddf2 = ddf.set_index(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">shuffle=shuffle_method)</span>

    <span class="s1">assert_eq(ddf2.loc[</span><span class="s3">2</span><span class="s1">:</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">df2.loc[</span><span class="s3">2</span><span class="s1">:</span><span class="s3">3</span><span class="s1">])</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;scheduler&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;threads&quot;</span><span class="s0">, </span><span class="s2">&quot;processes&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_rearrange(shuffle_method</span><span class="s0">, </span><span class="s1">scheduler):</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: np.random.random(</span><span class="s3">10</span><span class="s1">)})</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">ddf2 = ddf.assign(_partitions=ddf.x % </span><span class="s3">4</span><span class="s1">)</span>

    <span class="s1">result = rearrange_by_column(</span>
        <span class="s1">ddf2</span><span class="s0">, </span><span class="s2">&quot;_partitions&quot;</span><span class="s0">, </span><span class="s1">max_branch=</span><span class="s3">32</span><span class="s0">, </span><span class="s1">shuffle=shuffle_method</span>
    <span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">result.npartitions == ddf.npartitions</span>
    <span class="s0">assert </span><span class="s1">set(ddf.dask).issubset(result.dask)</span>

    <span class="s4"># Every value in exactly one partition</span>
    <span class="s1">a = result.compute(scheduler=scheduler)</span>
    <span class="s1">get = dask.base.get_scheduler(scheduler=scheduler)</span>
    <span class="s1">parts = get(result.dask</span><span class="s0">, </span><span class="s1">result.__dask_keys__())</span>

    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">a._partitions.drop_duplicates():</span>
        <span class="s0">assert </span><span class="s1">sum(i </span><span class="s0">in </span><span class="s1">set(part._partitions) </span><span class="s0">for </span><span class="s1">part </span><span class="s0">in </span><span class="s1">parts) == </span><span class="s3">1</span>


<span class="s0">def </span><span class="s1">test_rearrange_cleanup():</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: np.random.random(</span><span class="s3">10</span><span class="s1">)})</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">ddf2 = ddf.assign(_partitions=ddf.x % </span><span class="s3">4</span><span class="s1">)</span>

    <span class="s1">tmpdir = tempfile.mkdtemp()</span>

    <span class="s0">with </span><span class="s1">dask.config.set(temporay_directory=str(tmpdir)):</span>
        <span class="s1">result = rearrange_by_column(ddf2</span><span class="s0">, </span><span class="s2">&quot;_partitions&quot;</span><span class="s0">, </span><span class="s1">max_branch=</span><span class="s3">32</span><span class="s0">, </span><span class="s1">shuffle=</span><span class="s2">&quot;disk&quot;</span><span class="s1">)</span>
        <span class="s1">result.compute(scheduler=</span><span class="s2">&quot;processes&quot;</span><span class="s1">)</span>

    <span class="s0">assert </span><span class="s1">len(os.listdir(tmpdir)) == </span><span class="s3">0</span>


<span class="s0">def </span><span class="s1">mock_shuffle_group_3(df</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">npartitions</span><span class="s0">, </span><span class="s1">p):</span>
    <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Mock exception!&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_rearrange_disk_cleanup_with_exception():</span>
    <span class="s4"># ensure temporary files are cleaned up when there's an internal exception.</span>

    <span class="s0">with </span><span class="s1">mock.patch(</span><span class="s2">&quot;dask.dataframe.shuffle.shuffle_group_3&quot;</span><span class="s0">, </span><span class="s1">new=mock_shuffle_group_3):</span>
        <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: np.random.random(</span><span class="s3">10</span><span class="s1">)})</span>
        <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">ddf2 = ddf.assign(_partitions=ddf.x % </span><span class="s3">4</span><span class="s1">)</span>

        <span class="s1">tmpdir = tempfile.mkdtemp()</span>

        <span class="s0">with </span><span class="s1">dask.config.set(temporay_directory=str(tmpdir)):</span>
            <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;Mock exception!&quot;</span><span class="s1">):</span>
                <span class="s1">result = rearrange_by_column(</span>
                    <span class="s1">ddf2</span><span class="s0">, </span><span class="s2">&quot;_partitions&quot;</span><span class="s0">, </span><span class="s1">max_branch=</span><span class="s3">32</span><span class="s0">, </span><span class="s1">shuffle=</span><span class="s2">&quot;disk&quot;</span>
                <span class="s1">)</span>
                <span class="s1">result.compute(scheduler=</span><span class="s2">&quot;processes&quot;</span><span class="s1">)</span>

    <span class="s0">assert </span><span class="s1">len(os.listdir(tmpdir)) == </span><span class="s3">0</span>


<span class="s0">def </span><span class="s1">test_rearrange_by_column_with_narrow_divisions():</span>
    <span class="s0">from </span><span class="s1">dask.dataframe.tests.test_multi </span><span class="s0">import </span><span class="s1">list_eq</span>

    <span class="s1">A = pd.DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]})</span>
    <span class="s1">a = dd.repartition(A</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">])</span>

    <span class="s1">df = rearrange_by_divisions(a</span><span class="s0">, </span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">5</span><span class="s1">))</span>
    <span class="s1">list_eq(df</span><span class="s0">, </span><span class="s1">a)</span>


<span class="s0">def </span><span class="s1">test_maybe_buffered_partd(tmp_path):</span>
    <span class="s0">import </span><span class="s1">partd</span>

    <span class="s1">f = maybe_buffered_partd()</span>
    <span class="s1">p1 = f()</span>
    <span class="s0">assert </span><span class="s1">isinstance(p1.partd</span><span class="s0">, </span><span class="s1">partd.Buffer)</span>
    <span class="s1">f2 = pickle.loads(pickle.dumps(f))</span>
    <span class="s0">assert not </span><span class="s1">f2.buffer</span>
    <span class="s1">p2 = f2()</span>
    <span class="s0">assert </span><span class="s1">isinstance(p2.partd</span><span class="s0">, </span><span class="s1">partd.File)</span>

    <span class="s1">f3 = maybe_buffered_partd(tempdir=tmp_path)</span>
    <span class="s1">p3 = f3()</span>
    <span class="s0">assert </span><span class="s1">isinstance(p3.partd</span><span class="s0">, </span><span class="s1">partd.Buffer)</span>
    <span class="s1">contents = list(tmp_path.iterdir())</span>
    <span class="s0">assert </span><span class="s1">len(contents) == </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">contents[</span><span class="s3">0</span><span class="s1">].suffix == </span><span class="s2">&quot;.partd&quot;</span>
    <span class="s0">assert </span><span class="s1">contents[</span><span class="s3">0</span><span class="s1">].parent == tmp_path</span>
    <span class="s1">f4 = pickle.loads(pickle.dumps(f3))</span>
    <span class="s0">assert not </span><span class="s1">f4.buffer</span>
    <span class="s0">assert </span><span class="s1">f4.tempdir == tmp_path</span>


<span class="s0">def </span><span class="s1">test_set_index_with_explicit_divisions():</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: [</span><span class="s3">4</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]}</span><span class="s0">, </span><span class="s1">index=[</span><span class="s3">10</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">30</span><span class="s0">, </span><span class="s3">40</span><span class="s1">])</span>

    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">2</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">throw(*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">raise </span><span class="s1">Exception()</span>

    <span class="s0">with </span><span class="s1">dask.config.set(scheduler=throw):</span>
        <span class="s1">ddf2 = ddf.set_index(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">divisions=[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s1">])</span>
    <span class="s0">assert </span><span class="s1">ddf2.divisions == (</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span>

    <span class="s1">df2 = df.set_index(</span><span class="s2">&quot;x&quot;</span><span class="s1">)</span>
    <span class="s1">assert_eq(ddf2</span><span class="s0">, </span><span class="s1">df2)</span>

    <span class="s4"># Divisions must be sorted</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">ddf.set_index(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">divisions=[</span><span class="s3">3</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">5</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">test_set_index_with_empty_divisions():</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]})</span>

    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">2</span><span class="s1">)</span>

    <span class="s4"># Divisions must not be empty</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">ddf.set_index(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">divisions=[])</span>


<span class="s0">def </span><span class="s1">test_set_index_divisions_2():</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: list(</span><span class="s2">&quot;abdabd&quot;</span><span class="s1">)})</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>

    <span class="s1">result = ddf.set_index(</span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s1">divisions=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">])</span>
    <span class="s0">assert </span><span class="s1">result.divisions == (</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">)</span>

    <span class="s0">assert </span><span class="s1">list(result.compute(scheduler=</span><span class="s2">&quot;sync&quot;</span><span class="s1">).index[-</span><span class="s3">2</span><span class="s1">:]) == [</span><span class="s2">&quot;d&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">test_set_index_divisions_compute():</span>
    <span class="s1">d2 = d.set_index(</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s1">divisions=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">9</span><span class="s1">]</span><span class="s0">, </span><span class="s1">compute=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">d3 = d.set_index(</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s1">divisions=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">9</span><span class="s1">]</span><span class="s0">, </span><span class="s1">compute=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s1">assert_eq(d2</span><span class="s0">, </span><span class="s1">d3)</span>
    <span class="s1">assert_eq(d2</span><span class="s0">, </span><span class="s1">full.set_index(</span><span class="s2">&quot;b&quot;</span><span class="s1">))</span>
    <span class="s1">assert_eq(d3</span><span class="s0">, </span><span class="s1">full.set_index(</span><span class="s2">&quot;b&quot;</span><span class="s1">))</span>
    <span class="s0">assert </span><span class="s1">len(d2.dask) &gt; len(d3.dask)</span>

    <span class="s1">d4 = d.set_index(d.b</span><span class="s0">, </span><span class="s1">divisions=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">9</span><span class="s1">]</span><span class="s0">, </span><span class="s1">compute=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">d5 = d.set_index(d.b</span><span class="s0">, </span><span class="s1">divisions=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">9</span><span class="s1">]</span><span class="s0">, </span><span class="s1">compute=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">exp = full.copy()</span>
    <span class="s1">exp.index = exp.b</span>
    <span class="s1">assert_eq(d4</span><span class="s0">, </span><span class="s1">d5)</span>
    <span class="s1">assert_eq(d4</span><span class="s0">, </span><span class="s1">exp)</span>
    <span class="s1">assert_eq(d5</span><span class="s0">, </span><span class="s1">exp)</span>
    <span class="s0">assert </span><span class="s1">len(d4.dask) &gt; len(d5.dask)</span>


<span class="s0">def </span><span class="s1">test_set_index_divisions_sorted():</span>
    <span class="s1">p1 = pd.DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: [</span><span class="s3">10</span><span class="s0">, </span><span class="s3">11</span><span class="s0">, </span><span class="s3">12</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: [</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s1">]})</span>
    <span class="s1">p2 = pd.DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: [</span><span class="s3">13</span><span class="s0">, </span><span class="s3">14</span><span class="s0">, </span><span class="s3">15</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: [</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">]})</span>
    <span class="s1">p3 = pd.DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: [</span><span class="s3">16</span><span class="s0">, </span><span class="s3">17</span><span class="s0">, </span><span class="s3">18</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: [</span><span class="s2">&quot;d&quot;</span><span class="s0">, </span><span class="s2">&quot;e&quot;</span><span class="s0">, </span><span class="s2">&quot;e&quot;</span><span class="s1">]})</span>

    <span class="s1">ddf = dd.DataFrame(</span>
        <span class="s1">{(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s3">0</span><span class="s1">): p1</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">): p2</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s1">): p3}</span><span class="s0">, </span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">p1</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, None, None, None</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">df = ddf.compute()</span>

    <span class="s0">def </span><span class="s1">throw(*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">raise </span><span class="s1">Exception(</span><span class="s2">&quot;Shouldn't have computed&quot;</span><span class="s1">)</span>

    <span class="s0">with </span><span class="s1">dask.config.set(scheduler=throw):</span>
        <span class="s1">res = ddf.set_index(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">divisions=[</span><span class="s3">10</span><span class="s0">, </span><span class="s3">13</span><span class="s0">, </span><span class="s3">16</span><span class="s0">, </span><span class="s3">18</span><span class="s1">]</span><span class="s0">, </span><span class="s1">sorted=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">assert_eq(res</span><span class="s0">, </span><span class="s1">df.set_index(</span><span class="s2">&quot;x&quot;</span><span class="s1">))</span>

    <span class="s0">with </span><span class="s1">dask.config.set(scheduler=throw):</span>
        <span class="s1">res = ddf.set_index(</span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s1">divisions=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s0">, </span><span class="s2">&quot;e&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">sorted=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">assert_eq(res</span><span class="s0">, </span><span class="s1">df.set_index(</span><span class="s2">&quot;y&quot;</span><span class="s1">))</span>

    <span class="s4"># with sorted=True, divisions must be same length as df.divisions</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">ddf.set_index(</span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s1">divisions=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s0">, </span><span class="s2">&quot;e&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">sorted=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s4"># Divisions must be sorted</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">ddf.set_index(</span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s1">divisions=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">sorted=</span><span class="s0">True</span><span class="s1">)</span>


<span class="s1">@pytest.mark.slow</span>
<span class="s0">def </span><span class="s1">test_set_index_consistent_divisions():</span>
    <span class="s4"># See https://github.com/dask/dask/issues/3867</span>
    <span class="s1">df = pd.DataFrame(</span>
        <span class="s1">{</span><span class="s2">&quot;x&quot;</span><span class="s1">: np.random.random(</span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: np.random.random(</span><span class="s3">100</span><span class="s1">) // </span><span class="s3">0.2</span><span class="s1">}</span><span class="s0">,</span>
        <span class="s1">index=np.random.random(</span><span class="s3">100</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">ddf = ddf.clear_divisions()</span>

    <span class="s1">ctx = mp.get_context(</span><span class="s2">&quot;spawn&quot;</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">ProcessPoolExecutor(</span><span class="s3">8</span><span class="s0">, </span><span class="s1">ctx) </span><span class="s0">as </span><span class="s1">pool:</span>
        <span class="s1">func = partial(_set_index</span><span class="s0">, </span><span class="s1">df=ddf</span><span class="s0">, </span><span class="s1">idx=</span><span class="s2">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s1">divisions_set = set(pool.map(func</span><span class="s0">, </span><span class="s1">range(</span><span class="s3">100</span><span class="s1">)))</span>
    <span class="s0">assert </span><span class="s1">len(divisions_set) == </span><span class="s3">1</span>


<span class="s0">def </span><span class="s1">_set_index(i</span><span class="s0">, </span><span class="s1">df</span><span class="s0">, </span><span class="s1">idx):</span>
    <span class="s0">return </span><span class="s1">df.set_index(idx).divisions</span>


<span class="s0">def </span><span class="s1">test_set_index_reduces_partitions_small(shuffle_method):</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: np.random.random(</span><span class="s3">100</span><span class="s1">)})</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">50</span><span class="s1">)</span>

    <span class="s1">ddf2 = ddf.set_index(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">shuffle=shuffle_method</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s2">&quot;auto&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">ddf2.npartitions &lt; </span><span class="s3">10</span>


<span class="s0">def </span><span class="s1">make_part(n):</span>
    <span class="s0">return </span><span class="s1">pd.DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: np.random.random(n)</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: np.random.random(n)})</span>


<span class="s0">def </span><span class="s1">test_set_index_reduces_partitions_large(shuffle_method):</span>
    <span class="s1">nbytes = </span><span class="s3">1e6</span>
    <span class="s1">nparts = </span><span class="s3">50</span>
    <span class="s1">n = int(nbytes / (nparts * </span><span class="s3">8</span><span class="s1">))</span>
    <span class="s1">ddf = dd.DataFrame(</span>
        <span class="s1">{(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">i): (make_part</span><span class="s0">, </span><span class="s1">n) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(nparts)}</span><span class="s0">,</span>
        <span class="s2">&quot;x&quot;</span><span class="s0">,</span>
        <span class="s1">make_part(</span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s0">None</span><span class="s1">] * (nparts + </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">ddf2 = ddf.set_index(</span>
        <span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">shuffle=shuffle_method</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s2">&quot;auto&quot;</span><span class="s0">, </span><span class="s1">partition_size=nbytes</span>
    <span class="s1">)</span>
    <span class="s0">assert </span><span class="s3">1 </span><span class="s1">&lt; ddf2.npartitions &lt; </span><span class="s3">20</span>


<span class="s0">def </span><span class="s1">test_set_index_doesnt_increase_partitions(shuffle_method):</span>
    <span class="s1">nparts = </span><span class="s3">2</span>
    <span class="s1">nbytes = </span><span class="s3">1e6</span>
    <span class="s1">n = int(nbytes / (nparts * </span><span class="s3">8</span><span class="s1">))</span>
    <span class="s1">ddf = dd.DataFrame(</span>
        <span class="s1">{(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">i): (make_part</span><span class="s0">, </span><span class="s1">n) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(nparts)}</span><span class="s0">,</span>
        <span class="s2">&quot;x&quot;</span><span class="s0">,</span>
        <span class="s1">make_part(</span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s0">None</span><span class="s1">] * (nparts + </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">ddf2 = ddf.set_index(</span>
        <span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">shuffle=shuffle_method</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s2">&quot;auto&quot;</span><span class="s0">, </span><span class="s1">partition_size=nbytes</span>
    <span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">ddf2.npartitions &lt;= ddf.npartitions</span>


<span class="s0">def </span><span class="s1">test_set_index_detects_sorted_data(shuffle_method):</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: range(</span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: range(</span><span class="s3">100</span><span class="s1">)})</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">sort=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">ddf2 = ddf.set_index(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">shuffle=shuffle_method)</span>
    <span class="s0">assert </span><span class="s1">len(ddf2.dask) &lt; ddf.npartitions * </span><span class="s3">4</span>


<span class="s0">def </span><span class="s1">test_set_index_sorts():</span>
    <span class="s4"># https://github.com/dask/dask/issues/2288</span>
    <span class="s1">vals = np.array(</span>
        <span class="s1">[</span>
            <span class="s3">1348550149000000000</span><span class="s0">,</span>
            <span class="s3">1348550149000000000</span><span class="s0">,</span>
            <span class="s3">1348558142000000000</span><span class="s0">,</span>
            <span class="s3">1348558142000000000</span><span class="s0">,</span>
            <span class="s3">1348585928000000000</span><span class="s0">,</span>
            <span class="s3">1348585928000000000</span><span class="s0">,</span>
            <span class="s3">1348600739000000000</span><span class="s0">,</span>
            <span class="s3">1348601706000000000</span><span class="s0">,</span>
            <span class="s3">1348600739000000000</span><span class="s0">,</span>
            <span class="s3">1348601706000000000</span><span class="s0">,</span>
            <span class="s3">1348614789000000000</span><span class="s0">,</span>
            <span class="s3">1348614789000000000</span><span class="s0">,</span>
            <span class="s3">1348621037000000000</span><span class="s0">,</span>
            <span class="s3">1348621038000000000</span><span class="s0">,</span>
            <span class="s3">1348621040000000000</span><span class="s0">,</span>
            <span class="s3">1348621037000000000</span><span class="s0">,</span>
            <span class="s3">1348621038000000000</span><span class="s0">,</span>
            <span class="s3">1348621040000000000</span><span class="s0">,</span>
            <span class="s3">1348637628000000000</span><span class="s0">,</span>
            <span class="s3">1348638159000000000</span><span class="s0">,</span>
            <span class="s3">1348638160000000000</span><span class="s0">,</span>
            <span class="s3">1348638159000000000</span><span class="s0">,</span>
            <span class="s3">1348638160000000000</span><span class="s0">,</span>
            <span class="s3">1348637628000000000</span><span class="s0">,</span>
            <span class="s3">1348646354000000000</span><span class="s0">,</span>
            <span class="s3">1348646354000000000</span><span class="s0">,</span>
            <span class="s3">1348659107000000000</span><span class="s0">,</span>
            <span class="s3">1348657111000000000</span><span class="s0">,</span>
            <span class="s3">1348659107000000000</span><span class="s0">,</span>
            <span class="s3">1348657111000000000</span><span class="s0">,</span>
            <span class="s3">1348672876000000000</span><span class="s0">,</span>
            <span class="s3">1348672876000000000</span><span class="s0">,</span>
            <span class="s3">1348682787000000000</span><span class="s0">,</span>
            <span class="s3">1348681985000000000</span><span class="s0">,</span>
            <span class="s3">1348682787000000000</span><span class="s0">,</span>
            <span class="s3">1348681985000000000</span><span class="s0">,</span>
            <span class="s3">1348728167000000000</span><span class="s0">,</span>
            <span class="s3">1348728167000000000</span><span class="s0">,</span>
            <span class="s3">1348730745000000000</span><span class="s0">,</span>
            <span class="s3">1348730745000000000</span><span class="s0">,</span>
            <span class="s3">1348750198000000000</span><span class="s0">,</span>
            <span class="s3">1348750198000000000</span><span class="s0">,</span>
            <span class="s3">1348750198000000000</span><span class="s0">,</span>
            <span class="s3">1348753539000000000</span><span class="s0">,</span>
            <span class="s3">1348753539000000000</span><span class="s0">,</span>
            <span class="s3">1348753539000000000</span><span class="s0">,</span>
            <span class="s3">1348754449000000000</span><span class="s0">,</span>
            <span class="s3">1348754449000000000</span><span class="s0">,</span>
            <span class="s3">1348761333000000000</span><span class="s0">,</span>
            <span class="s3">1348761554000000000</span><span class="s0">,</span>
            <span class="s3">1348761610000000000</span><span class="s0">,</span>
            <span class="s3">1348761333000000000</span><span class="s0">,</span>
            <span class="s3">1348761554000000000</span><span class="s0">,</span>
            <span class="s3">1348761610000000000</span><span class="s0">,</span>
            <span class="s3">1348782624000000000</span><span class="s0">,</span>
            <span class="s3">1348782624000000000</span><span class="s0">,</span>
            <span class="s3">1348782624000000000</span><span class="s0">,</span>
            <span class="s3">1348782624000000000</span><span class="s0">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">vals = pd.to_datetime(vals</span><span class="s0">, </span><span class="s1">unit=</span><span class="s2">&quot;ns&quot;</span><span class="s1">)</span>
    <span class="s1">breaks = [</span><span class="s3">10</span><span class="s0">, </span><span class="s3">36</span><span class="s0">, </span><span class="s3">58</span><span class="s1">]</span>
    <span class="s1">dfs = []</span>

    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(breaks)):</span>
        <span class="s1">lo = sum(breaks[:i])</span>
        <span class="s1">hi = sum(breaks[i : i + </span><span class="s3">1</span><span class="s1">])</span>

        <span class="s1">dfs.append(pd.DataFrame({</span><span class="s2">&quot;timestamp&quot;</span><span class="s1">: vals[lo:hi]}</span><span class="s0">, </span><span class="s1">index=range(lo</span><span class="s0">, </span><span class="s1">hi)))</span>

    <span class="s1">ddf = dd.concat(dfs).clear_divisions()</span>
    <span class="s0">assert </span><span class="s1">ddf.set_index(</span><span class="s2">&quot;timestamp&quot;</span><span class="s1">).index.compute().is_monotonic_increasing </span><span class="s0">is True</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;engine&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;pandas&quot;</span><span class="s0">, </span><span class="s1">pytest.param(</span><span class="s2">&quot;cudf&quot;</span><span class="s0">, </span><span class="s1">marks=pytest.mark.gpu)]</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_set_index(engine):</span>
    <span class="s0">if </span><span class="s1">engine == </span><span class="s2">&quot;cudf&quot;</span><span class="s1">:</span>
        <span class="s4"># NOTE: engine == &quot;cudf&quot; requires cudf/dask_cudf,</span>
        <span class="s4"># will be skipped by non-GPU CI.</span>

        <span class="s1">dask_cudf = pytest.importorskip(</span><span class="s2">&quot;dask_cudf&quot;</span><span class="s1">)</span>

    <span class="s1">dsk = {</span>
        <span class="s1">(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s3">0</span><span class="s1">): pd.DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s3">4</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]}</span><span class="s0">, </span><span class="s1">index=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">): pd.DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">8</span><span class="s1">]}</span><span class="s0">, </span><span class="s1">index=[</span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">8</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s1">): pd.DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">7</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">9</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s3">9</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">8</span><span class="s1">]}</span><span class="s0">, </span><span class="s1">index=[</span><span class="s3">9</span><span class="s0">, </span><span class="s3">9</span><span class="s0">, </span><span class="s3">9</span><span class="s1">])</span><span class="s0">,</span>
    <span class="s1">}</span>
    <span class="s1">d = dd.DataFrame(dsk</span><span class="s0">, </span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">meta</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">9</span><span class="s0">, </span><span class="s3">9</span><span class="s1">])</span>

    <span class="s0">if </span><span class="s1">engine == </span><span class="s2">&quot;cudf&quot;</span><span class="s1">:</span>
        <span class="s1">d = dask_cudf.from_dask_dataframe(d)</span>

    <span class="s1">full = d.compute()</span>

    <span class="s1">d2 = d.set_index(</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">d2.npartitions == </span><span class="s3">3</span>
    <span class="s0">assert </span><span class="s1">d2.index.name == </span><span class="s2">&quot;b&quot;</span>
    <span class="s1">assert_eq(d2</span><span class="s0">, </span><span class="s1">full.set_index(</span><span class="s2">&quot;b&quot;</span><span class="s1">))</span>

    <span class="s1">d3 = d.set_index(d.b</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">d3.npartitions == </span><span class="s3">3</span>
    <span class="s0">assert </span><span class="s1">d3.index.name == </span><span class="s2">&quot;b&quot;</span>
    <span class="s1">assert_eq(d3</span><span class="s0">, </span><span class="s1">full.set_index(full.b))</span>

    <span class="s1">d4 = d.set_index(</span><span class="s2">&quot;b&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">d4.index.name == </span><span class="s2">&quot;b&quot;</span>
    <span class="s1">assert_eq(d4</span><span class="s0">, </span><span class="s1">full.set_index(</span><span class="s2">&quot;b&quot;</span><span class="s1">))</span>

    <span class="s1">d5 = d.set_index([</span><span class="s2">&quot;b&quot;</span><span class="s1">])</span>
    <span class="s0">assert </span><span class="s1">d5.index.name == </span><span class="s2">&quot;b&quot;</span>
    <span class="s1">assert_eq(d5</span><span class="s0">, </span><span class="s1">full.set_index([</span><span class="s2">&quot;b&quot;</span><span class="s1">]))</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;engine&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;pandas&quot;</span><span class="s0">, </span><span class="s1">pytest.param(</span><span class="s2">&quot;cudf&quot;</span><span class="s0">, </span><span class="s1">marks=pytest.mark.gpu)]</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_set_index_interpolate(engine):</span>
    <span class="s0">if </span><span class="s1">engine == </span><span class="s2">&quot;cudf&quot;</span><span class="s1">:</span>
        <span class="s4"># NOTE: engine == &quot;cudf&quot; requires cudf/dask_cudf,</span>
        <span class="s4"># will be skipped by non-GPU CI.</span>

        <span class="s1">cudf = pytest.importorskip(</span><span class="s2">&quot;cudf&quot;</span><span class="s1">)</span>
        <span class="s1">dask_cudf = pytest.importorskip(</span><span class="s2">&quot;dask_cudf&quot;</span><span class="s1">)</span>

    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: [</span><span class="s3">4</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: [</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]})</span>

    <span class="s0">if </span><span class="s1">engine == </span><span class="s2">&quot;cudf&quot;</span><span class="s1">:</span>
        <span class="s1">gdf = cudf.from_pandas(df)</span>
        <span class="s1">d = dask_cudf.from_cudf(gdf</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">d = dd.from_pandas(df</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>

    <span class="s1">d1 = d.set_index(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">d1.npartitions &lt;= </span><span class="s3">3</span>
    <span class="s0">assert </span><span class="s1">set(d1.divisions) == {</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s1">}</span>

    <span class="s1">d2 = d.set_index(</span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">d2.divisions[</span><span class="s3">0</span><span class="s1">] == </span><span class="s3">1.0</span>
    <span class="s0">assert </span><span class="s3">1.0 </span><span class="s1">&lt; d2.divisions[</span><span class="s3">1</span><span class="s1">] &lt; d2.divisions[</span><span class="s3">2</span><span class="s1">] &lt; </span><span class="s3">2.0</span>
    <span class="s0">assert </span><span class="s1">d2.divisions[</span><span class="s3">3</span><span class="s1">] == </span><span class="s3">2.0</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;engine&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;pandas&quot;</span><span class="s0">, </span><span class="s1">pytest.param(</span><span class="s2">&quot;cudf&quot;</span><span class="s0">, </span><span class="s1">marks=pytest.mark.gpu)]</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_set_index_interpolate_int(engine):</span>
    <span class="s0">if </span><span class="s1">engine == </span><span class="s2">&quot;cudf&quot;</span><span class="s1">:</span>
        <span class="s4"># NOTE: engine == &quot;cudf&quot; requires cudf/dask_cudf,</span>
        <span class="s4"># will be skipped by non-GPU CI.</span>

        <span class="s1">cudf = pytest.importorskip(</span><span class="s2">&quot;cudf&quot;</span><span class="s1">)</span>
        <span class="s1">dask_cudf = pytest.importorskip(</span><span class="s2">&quot;dask_cudf&quot;</span><span class="s1">)</span>

    <span class="s1">L = sorted(list(range(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">200</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)) * </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: </span><span class="s3">2 </span><span class="s1">* L})</span>

    <span class="s0">if </span><span class="s1">engine == </span><span class="s2">&quot;cudf&quot;</span><span class="s1">:</span>
        <span class="s1">gdf = cudf.from_pandas(df)</span>
        <span class="s1">d = dask_cudf.from_cudf(gdf</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">d = dd.from_pandas(df</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>

    <span class="s1">d1 = d.set_index(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">all(np.issubdtype(type(x)</span><span class="s0">, </span><span class="s1">np.integer) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">d1.divisions)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;engine&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;pandas&quot;</span><span class="s0">, </span><span class="s1">pytest.param(</span><span class="s2">&quot;cudf&quot;</span><span class="s0">, </span><span class="s1">marks=pytest.mark.gpu)]</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_set_index_interpolate_large_uint(engine):</span>
    <span class="s0">if </span><span class="s1">engine == </span><span class="s2">&quot;cudf&quot;</span><span class="s1">:</span>
        <span class="s4"># NOTE: engine == &quot;cudf&quot; requires cudf/dask_cudf,</span>
        <span class="s4"># will be skipped by non-GPU CI.</span>

        <span class="s1">cudf = pytest.importorskip(</span><span class="s2">&quot;cudf&quot;</span><span class="s1">)</span>
        <span class="s1">dask_cudf = pytest.importorskip(</span><span class="s2">&quot;dask_cudf&quot;</span><span class="s1">)</span>

    <span class="s2">&quot;&quot;&quot;This test is for #7304&quot;&quot;&quot;</span>
    <span class="s1">df = pd.DataFrame(</span>
        <span class="s1">{</span><span class="s2">&quot;x&quot;</span><span class="s1">: np.array([</span><span class="s3">612509347682975743</span><span class="s0">, </span><span class="s3">616762138058293247</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.uint64)}</span>
    <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">engine == </span><span class="s2">&quot;cudf&quot;</span><span class="s1">:</span>
        <span class="s1">gdf = cudf.from_pandas(df)</span>
        <span class="s1">d = dask_cudf.from_cudf(gdf</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">d = dd.from_pandas(df</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>

    <span class="s1">d1 = d.set_index(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">d1.npartitions == </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">set(d1.divisions) == {</span><span class="s3">612509347682975743</span><span class="s0">, </span><span class="s3">616762138058293247</span><span class="s1">}</span>


<span class="s0">def </span><span class="s1">test_set_index_timezone():</span>
    <span class="s1">s_naive = pd.Series(pd.date_range(</span><span class="s2">&quot;20130101&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">3</span><span class="s1">))</span>
    <span class="s1">s_aware = pd.Series(pd.date_range(</span><span class="s2">&quot;20130101&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;US/Eastern&quot;</span><span class="s1">))</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;tz&quot;</span><span class="s1">: s_aware</span><span class="s0">, </span><span class="s2">&quot;notz&quot;</span><span class="s1">: s_naive})</span>
    <span class="s1">d = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">1</span><span class="s1">)  </span><span class="s4"># TODO: Use npartitions=2</span>

    <span class="s1">d1 = d.set_index(</span><span class="s2">&quot;notz&quot;</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">s1 = pd.DatetimeIndex(s_naive.values</span><span class="s0">, </span><span class="s1">dtype=s_naive.dtype)</span>
    <span class="s0">assert </span><span class="s1">d1.divisions[</span><span class="s3">0</span><span class="s1">] == s_naive[</span><span class="s3">0</span><span class="s1">] == s1[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">d1.divisions[-</span><span class="s3">1</span><span class="s1">] == s_naive[</span><span class="s3">2</span><span class="s1">] == s1[</span><span class="s3">2</span><span class="s1">]</span>

    <span class="s4"># We currently lose &quot;freq&quot;.  Converting data with pandas-defined dtypes</span>
    <span class="s4"># to numpy or pure Python can be lossy like this.</span>
    <span class="s1">d2 = d.set_index(</span><span class="s2">&quot;tz&quot;</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">s2 = pd.DatetimeIndex(s_aware</span><span class="s0">, </span><span class="s1">dtype=s_aware.dtype)</span>
    <span class="s0">assert </span><span class="s1">d2.divisions[</span><span class="s3">0</span><span class="s1">] == s2[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">d2.divisions[-</span><span class="s3">1</span><span class="s1">] == s2[</span><span class="s3">2</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">d2.divisions[</span><span class="s3">0</span><span class="s1">].tz == s2[</span><span class="s3">0</span><span class="s1">].tz</span>
    <span class="s0">assert </span><span class="s1">d2.divisions[</span><span class="s3">0</span><span class="s1">].tz </span><span class="s0">is not None</span>
    <span class="s1">s2badtype = pd.DatetimeIndex(s_aware.values</span><span class="s0">, </span><span class="s1">dtype=s_naive.dtype)</span>
    <span class="s0">assert not </span><span class="s1">d2.divisions[</span><span class="s3">0</span><span class="s1">] == s2badtype[</span><span class="s3">0</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">test_set_index_npartitions():</span>
    <span class="s4"># https://github.com/dask/dask/issues/6974</span>
    <span class="s1">data = pd.DataFrame(</span>
        <span class="s1">index=pd.Index(</span>
            <span class="s1">[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;C&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">data = dd.from_pandas(data</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">output = data.reset_index().set_index(</span><span class="s2">&quot;index&quot;</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">output.npartitions == </span><span class="s3">1</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;unit&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;ns&quot;</span><span class="s0">, </span><span class="s2">&quot;us&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_set_index_datetime_precision(unit):</span>
    <span class="s4"># https://github.com/dask/dask/issues/6864</span>

    <span class="s1">df = pd.DataFrame(</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s3">1567703791155681</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s3">1567703792155681</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s3">1567703790155681</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s3">1567703793155681</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">columns=[</span><span class="s2">&quot;ts&quot;</span><span class="s0">, </span><span class="s2">&quot;rank&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">df.ts = pd.to_datetime(df.ts</span><span class="s0">, </span><span class="s1">unit=unit)</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">ddf = ddf.set_index(</span><span class="s2">&quot;ts&quot;</span><span class="s1">)</span>

    <span class="s1">assert_eq(ddf</span><span class="s0">, </span><span class="s1">df.set_index(</span><span class="s2">&quot;ts&quot;</span><span class="s1">))</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;drop&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_set_index_drop(drop):</span>
    <span class="s1">pdf = pd.DataFrame(</span>
        <span class="s1">{</span>
            <span class="s2">&quot;A&quot;</span><span class="s1">: list(</span><span class="s2">&quot;ABAABBABAA&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;B&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">9</span><span class="s0">, </span><span class="s3">10</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;C&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">ddf = dd.from_pandas(pdf</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>

    <span class="s1">assert_eq(ddf.set_index(</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s1">drop=drop)</span><span class="s0">, </span><span class="s1">pdf.set_index(</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s1">drop=drop))</span>
    <span class="s1">assert_eq(ddf.set_index(</span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s1">drop=drop)</span><span class="s0">, </span><span class="s1">pdf.set_index(</span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s1">drop=drop))</span>
    <span class="s1">assert_eq(ddf.set_index(</span><span class="s2">&quot;C&quot;</span><span class="s0">, </span><span class="s1">drop=drop)</span><span class="s0">, </span><span class="s1">pdf.set_index(</span><span class="s2">&quot;C&quot;</span><span class="s0">, </span><span class="s1">drop=drop))</span>
    <span class="s1">assert_eq(ddf.set_index(ddf.A</span><span class="s0">, </span><span class="s1">drop=drop)</span><span class="s0">, </span><span class="s1">pdf.set_index(pdf.A</span><span class="s0">, </span><span class="s1">drop=drop))</span>
    <span class="s1">assert_eq(ddf.set_index(ddf.B</span><span class="s0">, </span><span class="s1">drop=drop)</span><span class="s0">, </span><span class="s1">pdf.set_index(pdf.B</span><span class="s0">, </span><span class="s1">drop=drop))</span>
    <span class="s1">assert_eq(ddf.set_index(ddf.C</span><span class="s0">, </span><span class="s1">drop=drop)</span><span class="s0">, </span><span class="s1">pdf.set_index(pdf.C</span><span class="s0">, </span><span class="s1">drop=drop))</span>

    <span class="s4"># numeric columns</span>
    <span class="s1">pdf = pd.DataFrame(</span>
        <span class="s1">{</span>
            <span class="s3">0</span><span class="s1">: list(</span><span class="s2">&quot;ABAABBABAA&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s3">1</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">9</span><span class="s0">, </span><span class="s3">10</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s3">2</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">ddf = dd.from_pandas(pdf</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">assert_eq(ddf.set_index(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">drop=drop)</span><span class="s0">, </span><span class="s1">pdf.set_index(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">drop=drop))</span>
    <span class="s1">assert_eq(ddf.set_index(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">drop=drop)</span><span class="s0">, </span><span class="s1">pdf.set_index(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">drop=drop))</span>


<span class="s0">def </span><span class="s1">test_set_index_raises_error_on_bad_input():</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s3">7</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]})</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>

    <span class="s1">msg = </span><span class="s2">r&quot;Dask dataframe does not yet support multi-indexes&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError) </span><span class="s0">as </span><span class="s1">err:</span>
        <span class="s1">ddf.set_index([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">])</span>
    <span class="s0">assert </span><span class="s1">msg </span><span class="s0">in </span><span class="s1">str(err.value)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError) </span><span class="s0">as </span><span class="s1">err:</span>
        <span class="s1">ddf.set_index([[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]])</span>
    <span class="s0">assert </span><span class="s1">msg </span><span class="s0">in </span><span class="s1">str(err.value)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError) </span><span class="s0">as </span><span class="s1">err:</span>
        <span class="s1">ddf.set_index([[</span><span class="s2">&quot;a&quot;</span><span class="s1">]])</span>
    <span class="s0">assert </span><span class="s1">msg </span><span class="s0">in </span><span class="s1">str(err.value)</span>


<span class="s0">def </span><span class="s1">test_set_index_sorted_true():</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: [</span><span class="s3">10</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">40</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;z&quot;</span><span class="s1">: [</span><span class="s3">4</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]})</span>
    <span class="s1">a = dd.from_pandas(df</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">sort=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">assert not </span><span class="s1">a.known_divisions</span>

    <span class="s1">b = a.set_index(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">sorted=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">b.known_divisions</span>
    <span class="s0">assert </span><span class="s1">set(a.dask).issubset(set(b.dask))</span>

    <span class="s0">for </span><span class="s1">drop </span><span class="s0">in </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">]:</span>
        <span class="s1">assert_eq(a.set_index(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">drop=drop)</span><span class="s0">, </span><span class="s1">df.set_index(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">drop=drop))</span>
        <span class="s1">assert_eq(</span>
            <span class="s1">a.set_index(a.x</span><span class="s0">, </span><span class="s1">sorted=</span><span class="s0">True, </span><span class="s1">drop=drop)</span><span class="s0">, </span><span class="s1">df.set_index(df.x</span><span class="s0">, </span><span class="s1">drop=drop)</span>
        <span class="s1">)</span>
        <span class="s1">assert_eq(</span>
            <span class="s1">a.set_index(a.x + </span><span class="s3">1</span><span class="s0">, </span><span class="s1">sorted=</span><span class="s0">True, </span><span class="s1">drop=drop)</span><span class="s0">,</span>
            <span class="s1">df.set_index(df.x + </span><span class="s3">1</span><span class="s0">, </span><span class="s1">drop=drop)</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">a.set_index(a.z</span><span class="s0">, </span><span class="s1">sorted=</span><span class="s0">True</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_set_index_sorted_single_partition():</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]})</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_eq(ddf.set_index(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">sorted=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">df.set_index(</span><span class="s2">&quot;x&quot;</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">test_set_index_sorted_min_max_same():</span>
    <span class="s1">a = pd.DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]})</span>
    <span class="s1">b = pd.DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]})</span>

    <span class="s1">aa = dask.delayed(a)</span>
    <span class="s1">bb = dask.delayed(b)</span>

    <span class="s1">df = dd.from_delayed([aa</span><span class="s0">, </span><span class="s1">bb]</span><span class="s0">, </span><span class="s1">meta=a)</span>
    <span class="s0">assert not </span><span class="s1">df.known_divisions</span>

    <span class="s1">df2 = df.set_index(</span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s1">sorted=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">df2.divisions == (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_set_index_empty_partition():</span>
    <span class="s1">test_vals = [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span>
    <span class="s1">converters = [int</span><span class="s0">, </span><span class="s1">float</span><span class="s0">, </span><span class="s1">str</span><span class="s0">, lambda </span><span class="s1">x: pd.to_datetime(x</span><span class="s0">, </span><span class="s1">unit=</span><span class="s2">&quot;ns&quot;</span><span class="s1">)]</span>

    <span class="s0">for </span><span class="s1">conv </span><span class="s0">in </span><span class="s1">converters:</span>
        <span class="s1">df = pd.DataFrame(</span>
            <span class="s1">[{</span><span class="s2">&quot;x&quot;</span><span class="s1">: conv(i)</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: i} </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">test_vals]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">ddf = dd.concat(</span>
            <span class="s1">[</span>
                <span class="s1">dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">dd.from_pandas(df[df.y &gt; df.y.max()]</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>

        <span class="s0">assert </span><span class="s1">any(ddf.get_partition(p).compute().empty </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">range(ddf.npartitions))</span>
        <span class="s0">assert </span><span class="s1">assert_eq(ddf.set_index(</span><span class="s2">&quot;x&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">df.set_index(</span><span class="s2">&quot;x&quot;</span><span class="s1">))</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;converter&quot;</span><span class="s0">, </span><span class="s1">[int</span><span class="s0">, </span><span class="s1">float</span><span class="s0">, </span><span class="s1">str</span><span class="s0">, lambda </span><span class="s1">x: pd.to_datetime(x</span><span class="s0">, </span><span class="s1">unit=</span><span class="s2">&quot;ns&quot;</span><span class="s1">)]</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_set_index_on_empty(converter):</span>
    <span class="s1">test_vals = [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]</span>

    <span class="s1">df = pd.DataFrame([{</span><span class="s2">&quot;x&quot;</span><span class="s1">: converter(x)</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: x} </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">test_vals])</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">4</span><span class="s1">)</span>

    <span class="s0">assert </span><span class="s1">ddf.npartitions &gt; </span><span class="s3">1</span>

    <span class="s1">actual = ddf[ddf.y &gt; df.y.max()].set_index(</span><span class="s2">&quot;x&quot;</span><span class="s1">)</span>
    <span class="s1">expected = df[df.y &gt; df.y.max()].set_index(</span><span class="s2">&quot;x&quot;</span><span class="s1">)</span>

    <span class="s0">assert </span><span class="s1">assert_eq(actual</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_freq=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">actual.npartitions == </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">all(pd.isnull(d) </span><span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">actual.divisions)</span>

    <span class="s1">actual = ddf[ddf.y &gt; df.y.max()].set_index(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">sorted=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">assert_eq(actual</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_freq=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">actual.npartitions == </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">all(pd.isnull(d) </span><span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">actual.divisions)</span>


<span class="s0">def </span><span class="s1">test_set_index_categorical():</span>
    <span class="s4"># https://github.com/dask/dask/issues/5671</span>
    <span class="s1">order = list(reversed(string.ascii_letters))</span>
    <span class="s1">values = list(string.ascii_letters)</span>
    <span class="s1">random.shuffle(values)</span>
    <span class="s1">dtype = pd.api.types.CategoricalDtype(order</span><span class="s0">, </span><span class="s1">ordered=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;A&quot;</span><span class="s1">: pd.Categorical(values</span><span class="s0">, </span><span class="s1">dtype=dtype)</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">: </span><span class="s3">1</span><span class="s1">})</span>

    <span class="s1">result = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">2</span><span class="s1">).set_index(</span><span class="s2">&quot;A&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">len(result) == len(df)</span>

    <span class="s4"># sorted with the metric defined by the Categorical</span>
    <span class="s1">divisions = pd.Categorical(result.divisions</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">assert_categorical_equal(divisions</span><span class="s0">, </span><span class="s1">divisions.sort_values())</span>


<span class="s0">def </span><span class="s1">test_set_index_with_empty_and_overlap():</span>
    <span class="s4"># https://github.com/dask/dask/issues/8735</span>
    <span class="s1">df = pd.DataFrame(</span>
        <span class="s1">index=list(range(</span><span class="s3">8</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">data={</span>
            <span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">}</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">result = ddf[ddf.b == </span><span class="s3">1</span><span class="s1">].set_index(</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s1">sorted=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">expected = df[df.b == </span><span class="s3">1</span><span class="s1">].set_index(</span><span class="s2">&quot;a&quot;</span><span class="s1">)</span>

    <span class="s0">assert </span><span class="s1">result.divisions == (</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">3.0</span><span class="s0">, </span><span class="s3">3.0</span><span class="s1">)</span>
    <span class="s1">assert_eq(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_compute_divisions():</span>
    <span class="s0">from </span><span class="s1">dask.dataframe.shuffle </span><span class="s0">import </span><span class="s1">compute_and_set_divisions</span>

    <span class="s1">df = pd.DataFrame(</span>
        <span class="s1">{</span><span class="s2">&quot;x&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: [</span><span class="s3">10</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">40</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;z&quot;</span><span class="s1">: [</span><span class="s3">4</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]}</span><span class="s0">,</span>
        <span class="s1">index=[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">20</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">a = dd.from_pandas(df</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">sort=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">assert not </span><span class="s1">a.known_divisions</span>

    <span class="s1">b = compute_and_set_divisions(copy(a))</span>

    <span class="s1">assert_eq(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">check_divisions=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">b.known_divisions</span>


<span class="s0">def </span><span class="s1">test_empty_partitions():</span>
    <span class="s4"># See https://github.com/dask/dask/issues/2408</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: list(range(</span><span class="s3">10</span><span class="s1">))})</span>
    <span class="s1">df[</span><span class="s2">&quot;b&quot;</span><span class="s1">] = df[</span><span class="s2">&quot;a&quot;</span><span class="s1">] % </span><span class="s3">3</span>
    <span class="s1">df[</span><span class="s2">&quot;c&quot;</span><span class="s1">] = df[</span><span class="s2">&quot;b&quot;</span><span class="s1">].astype(str)</span>

    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">ddf = ddf.set_index(</span><span class="s2">&quot;b&quot;</span><span class="s1">)</span>
    <span class="s1">ddf = ddf.repartition(npartitions=</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">ddf.get_partition(</span><span class="s3">0</span><span class="s1">).compute()</span>
    <span class="s1">assert_eq(ddf</span><span class="s0">, </span><span class="s1">df.set_index(</span><span class="s2">&quot;b&quot;</span><span class="s1">))</span>

    <span class="s1">ddf = ddf.set_index(</span><span class="s2">&quot;c&quot;</span><span class="s1">)</span>
    <span class="s1">assert_eq(ddf</span><span class="s0">, </span><span class="s1">df.set_index(</span><span class="s2">&quot;b&quot;</span><span class="s1">).set_index(</span><span class="s2">&quot;c&quot;</span><span class="s1">))</span>


<span class="s1">@pytest.mark.slow</span>
<span class="s0">def </span><span class="s1">test_gh_2730():</span>
    <span class="s1">large = pd.DataFrame({</span><span class="s2">&quot;KEY&quot;</span><span class="s1">: np.arange(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">50000</span><span class="s1">)})</span>
    <span class="s1">small = pd.DataFrame({</span><span class="s2">&quot;KEY&quot;</span><span class="s1">: np.arange(</span><span class="s3">25</span><span class="s0">, </span><span class="s3">500</span><span class="s1">)})</span>

    <span class="s1">dd_left = dd.from_pandas(small</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">dd_right = dd.from_pandas(large</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">257</span><span class="s1">)</span>

    <span class="s0">with </span><span class="s1">dask.config.set({</span><span class="s2">&quot;dataframe.shuffle.method&quot;</span><span class="s1">: </span><span class="s2">&quot;tasks&quot;</span><span class="s0">, </span><span class="s2">&quot;scheduler&quot;</span><span class="s1">: </span><span class="s2">&quot;sync&quot;</span><span class="s1">}):</span>
        <span class="s1">dd_merged = dd_left.merge(dd_right</span><span class="s0">, </span><span class="s1">how=</span><span class="s2">&quot;inner&quot;</span><span class="s0">, </span><span class="s1">on=</span><span class="s2">&quot;KEY&quot;</span><span class="s1">)</span>
        <span class="s1">result = dd_merged.compute()</span>

    <span class="s1">expected = large.merge(small</span><span class="s0">, </span><span class="s1">how=</span><span class="s2">&quot;inner&quot;</span><span class="s0">, </span><span class="s1">on=</span><span class="s2">&quot;KEY&quot;</span><span class="s1">)</span>

    <span class="s1">tm.assert_frame_equal(result.sort_values(</span><span class="s2">&quot;KEY&quot;</span><span class="s1">).reset_index(drop=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;npartitions&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, </span><span class="s2">&quot;auto&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_set_index_does_not_repeat_work_due_to_optimizations(npartitions):</span>
    <span class="s4"># Atomic counter</span>
    <span class="s1">count = itertools.count()</span>

    <span class="s0">def </span><span class="s1">increment():</span>
        <span class="s1">next(count)</span>

    <span class="s0">def </span><span class="s1">make_part(dummy</span><span class="s0">, </span><span class="s1">n):</span>
        <span class="s0">return </span><span class="s1">pd.DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: np.random.random(n)</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: np.random.random(n)})</span>

    <span class="s1">nbytes = </span><span class="s3">1e6</span>
    <span class="s1">nparts = </span><span class="s3">50</span>
    <span class="s1">n = int(nbytes / (nparts * </span><span class="s3">8</span><span class="s1">))</span>

    <span class="s1">dsk = {(</span><span class="s2">&quot;inc&quot;</span><span class="s0">, </span><span class="s1">i): (increment</span><span class="s0">,</span><span class="s1">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(nparts)}</span>
    <span class="s1">dsk.update({(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">i): (make_part</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;inc&quot;</span><span class="s0">, </span><span class="s1">i)</span><span class="s0">, </span><span class="s1">n) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(nparts)})</span>
    <span class="s1">ddf = dd.DataFrame(dsk</span><span class="s0">, </span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">make_part(</span><span class="s0">None, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None</span><span class="s1">] * (nparts + </span><span class="s3">1</span><span class="s1">))</span>

    <span class="s1">ddf.set_index(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">npartitions=npartitions)</span>
    <span class="s1">ntimes = next(count)</span>
    <span class="s0">assert </span><span class="s1">ntimes == nparts</span>


<span class="s0">def </span><span class="s1">test_set_index_errors_with_inplace_kwarg():</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">9</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">7</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s3">6</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">: [</span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]})</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">1</span><span class="s1">)</span>

    <span class="s1">ddf.set_index(</span><span class="s2">&quot;a&quot;</span><span class="s1">)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError):</span>
        <span class="s1">ddf.set_index(</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_set_index_timestamp():</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;A&quot;</span><span class="s1">: pd.date_range(</span><span class="s2">&quot;2000&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">12</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;US/Central&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">: </span><span class="s3">1</span><span class="s1">})</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">divisions = (</span>
        <span class="s1">pd.Timestamp(</span><span class="s2">&quot;2000-01-01 00:00:00-0600&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;US/Central&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">pd.Timestamp(</span><span class="s2">&quot;2000-01-12 00:00:00-0600&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;US/Central&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s4"># Note: `freq` is lost during round trip</span>
    <span class="s1">df2 = df.set_index(</span><span class="s2">&quot;A&quot;</span><span class="s1">)</span>
    <span class="s1">ddf_new_div = ddf.set_index(</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s1">divisions=divisions)</span>
    <span class="s0">for </span><span class="s1">ts1</span><span class="s0">, </span><span class="s1">ts2 </span><span class="s0">in </span><span class="s1">zip(divisions</span><span class="s0">, </span><span class="s1">ddf_new_div.divisions):</span>
        <span class="s0">assert </span><span class="s1">ts1.timetuple() == ts2.timetuple()</span>
        <span class="s0">assert </span><span class="s1">ts1.tz == ts2.tz</span>

    <span class="s1">assert_eq(df2</span><span class="s0">, </span><span class="s1">ddf_new_div</span><span class="s0">, </span><span class="s1">check_freq=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">assert_eq(df2</span><span class="s0">, </span><span class="s1">ddf.set_index(</span><span class="s2">&quot;A&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">check_freq=</span><span class="s0">False</span><span class="s1">)</span>


<span class="s1">@pytest.mark.skipif(</span><span class="s0">not </span><span class="s1">PANDAS_GE_140</span><span class="s0">, </span><span class="s1">reason=</span><span class="s2">&quot;EA Indexes not supported before&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_set_index_ea_dtype():</span>
    <span class="s1">pdf = pd.DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: pd.Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;Int64&quot;</span><span class="s1">)})</span>
    <span class="s1">ddf = dd.from_pandas(pdf</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">pdf_result = pdf.set_index(</span><span class="s2">&quot;b&quot;</span><span class="s1">)</span>
    <span class="s1">ddf_result = ddf.set_index(</span><span class="s2">&quot;b&quot;</span><span class="s1">)</span>
    <span class="s1">assert_eq(ddf_result</span><span class="s0">, </span><span class="s1">pdf_result)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;compression&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, </span><span class="s2">&quot;ZLib&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_disk_shuffle_with_compression_option(compression):</span>
    <span class="s4"># test if dataframe shuffle works both with and without compression</span>
    <span class="s0">with </span><span class="s1">dask.config.set({</span><span class="s2">&quot;dataframe.shuffle.compression&quot;</span><span class="s1">: compression}):</span>
        <span class="s1">test_shuffle(</span><span class="s2">&quot;disk&quot;</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;compression&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;UNKOWN_COMPRESSION_ALGO&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_disk_shuffle_with_unknown_compression(compression):</span>
    <span class="s4"># test if dask raises an error in case of fault config string</span>
    <span class="s0">with </span><span class="s1">dask.config.set({</span><span class="s2">&quot;dataframe.shuffle.compression&quot;</span><span class="s1">: compression}):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">ImportError</span><span class="s0">,</span>
            <span class="s1">match=(</span>
                <span class="s2">&quot;Not able to import and load {} as compression algorithm.&quot;</span>
                <span class="s2">&quot;Please check if the library is installed and supported by Partd.&quot;</span><span class="s1">.format(</span>
                    <span class="s1">compression</span>
                <span class="s1">)</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">):</span>
            <span class="s1">test_shuffle(</span><span class="s2">&quot;disk&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_disk_shuffle_check_actual_compression():</span>
    <span class="s4"># test if the compression switch is really respected by testing the size of the actual partd-data on disk</span>
    <span class="s0">def </span><span class="s1">generate_raw_partd_file(compression):</span>
        <span class="s4"># generate and write a dummy dataframe to disk and return the raw data bytes</span>
        <span class="s1">df1 = pd.DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: list(range(</span><span class="s3">10000</span><span class="s1">))})</span>
        <span class="s1">df1[</span><span class="s2">&quot;b&quot;</span><span class="s1">] = (df1[</span><span class="s2">&quot;a&quot;</span><span class="s1">] * </span><span class="s3">123</span><span class="s1">).astype(str)</span>
        <span class="s0">with </span><span class="s1">dask.config.set({</span><span class="s2">&quot;dataframe.shuffle.compression&quot;</span><span class="s1">: compression}):</span>
            <span class="s1">p1 = maybe_buffered_partd(buffer=</span><span class="s0">False, </span><span class="s1">tempdir=</span><span class="s0">None</span><span class="s1">)()</span>
            <span class="s1">p1.append({</span><span class="s2">&quot;x&quot;</span><span class="s1">: df1})</span>
            <span class="s4"># get underlying filename from partd - depending on nested structure of partd object</span>
            <span class="s1">filename = (</span>
                <span class="s1">p1.partd.partd.filename(</span><span class="s2">&quot;x&quot;</span><span class="s1">) </span><span class="s0">if </span><span class="s1">compression </span><span class="s0">else </span><span class="s1">p1.partd.filename(</span><span class="s2">&quot;x&quot;</span><span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s0">with </span><span class="s1">open(filename</span><span class="s0">, </span><span class="s2">&quot;rb&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">f:</span>
                <span class="s0">return </span><span class="s1">f.read()</span>

    <span class="s4"># get compressed and uncompressed raw data</span>
    <span class="s1">uncompressed_data = generate_raw_partd_file(compression=</span><span class="s0">None</span><span class="s1">)</span>
    <span class="s1">compressed_data = generate_raw_partd_file(compression=</span><span class="s2">&quot;BZ2&quot;</span><span class="s1">)</span>

    <span class="s0">assert </span><span class="s1">len(uncompressed_data) &gt; len(compressed_data)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;ignore_index&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, True, False</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;on&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;id&quot;</span><span class="s0">, </span><span class="s2">&quot;name&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;id&quot;</span><span class="s0">, </span><span class="s2">&quot;name&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">pd.Series([</span><span class="s2">&quot;id&quot;</span><span class="s0">, </span><span class="s2">&quot;name&quot;</span><span class="s1">])]</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;max_branch&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, </span><span class="s3">4</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_dataframe_shuffle_on_arg(on</span><span class="s0">, </span><span class="s1">ignore_index</span><span class="s0">, </span><span class="s1">max_branch</span><span class="s0">, </span><span class="s1">shuffle_method):</span>
    <span class="s4"># Make sure DataFrame.shuffle API returns the same result</span>
    <span class="s4"># whether the ``on`` argument is a list of column names,</span>
    <span class="s4"># or a separate DataFrame with equivalent values...</span>
    <span class="s1">df_in = dask.datasets.timeseries(</span>
        <span class="s2">&quot;2000&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;2001&quot;</span><span class="s0">,</span>
        <span class="s1">types={</span><span class="s2">&quot;value&quot;</span><span class="s1">: float</span><span class="s0">, </span><span class="s2">&quot;name&quot;</span><span class="s1">: str</span><span class="s0">, </span><span class="s2">&quot;id&quot;</span><span class="s1">: int}</span><span class="s0">,</span>
        <span class="s1">freq=</span><span class="s2">&quot;2h&quot;</span><span class="s0">,</span>
        <span class="s1">partition_freq=</span><span class="s2">f&quot;1</span><span class="s0">{</span><span class="s1">ME</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s0">,</span>
        <span class="s1">seed=</span><span class="s3">1</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">if </span><span class="s1">isinstance(on</span><span class="s0">, </span><span class="s1">str):</span>
        <span class="s1">ext_on = df_in[[on]].copy()</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">ext_on = df_in[on].copy()</span>
    <span class="s1">df_out_1 = df_in.shuffle(</span>
        <span class="s1">on</span><span class="s0">, </span><span class="s1">shuffle=shuffle_method</span><span class="s0">, </span><span class="s1">ignore_index=ignore_index</span><span class="s0">, </span><span class="s1">max_branch=max_branch</span>
    <span class="s1">)</span>
    <span class="s1">df_out_2 = df_in.shuffle(ext_on</span><span class="s0">, </span><span class="s1">shuffle=shuffle_method</span><span class="s0">, </span><span class="s1">ignore_index=ignore_index)</span>

    <span class="s1">assert_eq(df_out_1</span><span class="s0">, </span><span class="s1">df_out_2</span><span class="s0">, </span><span class="s1">check_index=(</span><span class="s0">not </span><span class="s1">ignore_index))</span>

    <span class="s4"># disk shuffling doesn't support ignore_index</span>
    <span class="s0">if </span><span class="s1">ignore_index </span><span class="s0">and </span><span class="s1">shuffle_method == </span><span class="s2">&quot;tasks&quot;</span><span class="s1">:</span>
        <span class="s0">assert </span><span class="s1">df_out_1.index.dtype != df_in.index.dtype</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">assert </span><span class="s1">df_out_1.index.dtype == df_in.index.dtype</span>


<span class="s0">def </span><span class="s1">test_set_index_overlap():</span>
    <span class="s1">A = pd.DataFrame({</span><span class="s2">&quot;key&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;value&quot;</span><span class="s1">: list(</span><span class="s2">&quot;abcd&quot; </span><span class="s1">* </span><span class="s3">2</span><span class="s1">)})</span>
    <span class="s1">a = dd.from_pandas(A</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">a = a.set_index(</span><span class="s2">&quot;key&quot;</span><span class="s0">, </span><span class="s1">sorted=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">b = a.repartition(divisions=a.divisions)</span>
    <span class="s1">assert_eq(a</span><span class="s0">, </span><span class="s1">b)</span>


<span class="s0">def </span><span class="s1">test_set_index_overlap_2():</span>
    <span class="s1">df = pd.DataFrame(</span>
        <span class="s1">index=pd.Index(</span>
            <span class="s1">[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;C&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">name=</span><span class="s2">&quot;index&quot;</span><span class="s0">,</span>
        <span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">result = ddf.reset_index().repartition(</span><span class="s3">8</span><span class="s1">).set_index(</span><span class="s2">&quot;index&quot;</span><span class="s0">, </span><span class="s1">sorted=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">expected = df.reset_index().set_index(</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span>
    <span class="s1">assert_eq(result</span><span class="s0">, </span><span class="s1">expected)</span>
    <span class="s0">assert </span><span class="s1">result.npartitions == </span><span class="s3">8</span>


<span class="s0">def </span><span class="s1">test_set_index_overlap_does_not_drop_rows_when_divisions_overlap():</span>
    <span class="s4"># https://github.com/dask/dask/issues/9339</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;ts&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;value&quot;</span><span class="s1">: </span><span class="s2">&quot;abc&quot;</span><span class="s1">})</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">3</span><span class="s1">)</span>

    <span class="s1">expected = df.set_index(</span><span class="s2">&quot;ts&quot;</span><span class="s1">)</span>
    <span class="s1">actual = ddf.set_index(</span><span class="s2">&quot;ts&quot;</span><span class="s0">, </span><span class="s1">sorted=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s1">assert_eq(expected</span><span class="s0">, </span><span class="s1">actual)</span>


<span class="s0">def </span><span class="s1">test_compute_current_divisions_nan_partition():</span>
    <span class="s4"># Compute divisions 1 null partition</span>
    <span class="s1">a = d[d.a &gt; </span><span class="s3">3</span><span class="s1">].sort_values(</span><span class="s2">&quot;a&quot;</span><span class="s1">)</span>
    <span class="s1">divisions = a.compute_current_divisions(</span><span class="s2">&quot;a&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">divisions == (</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">9</span><span class="s1">)</span>
    <span class="s1">a.divisions = divisions</span>
    <span class="s1">assert_eq(a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">check_divisions=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s4"># Compute divisions with 0 null partitions</span>
    <span class="s1">a = d[d.a &gt; </span><span class="s3">1</span><span class="s1">].sort_values(</span><span class="s2">&quot;a&quot;</span><span class="s1">)</span>
    <span class="s1">divisions = a.compute_current_divisions(</span><span class="s2">&quot;a&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">divisions == (</span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">9</span><span class="s1">)</span>
    <span class="s1">a.divisions = divisions</span>
    <span class="s1">assert_eq(a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">check_divisions=</span><span class="s0">False</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_compute_current_divisions_overlap():</span>
    <span class="s1">A = pd.DataFrame({</span><span class="s2">&quot;key&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;value&quot;</span><span class="s1">: list(</span><span class="s2">&quot;abcd&quot; </span><span class="s1">* </span><span class="s3">2</span><span class="s1">)})</span>
    <span class="s1">a = dd.from_pandas(A</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;Partitions have overlapping values&quot;</span><span class="s1">):</span>
        <span class="s1">divisions = a.compute_current_divisions(</span><span class="s2">&quot;key&quot;</span><span class="s1">)</span>
        <span class="s1">b = a.set_index(</span><span class="s2">&quot;key&quot;</span><span class="s0">, </span><span class="s1">divisions=divisions)</span>
        <span class="s0">assert </span><span class="s1">b.divisions == (</span><span class="s3">1</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">[len(p) </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">b.partitions] == [</span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">test_compute_current_divisions_overlap_2():</span>
    <span class="s1">data = pd.DataFrame(</span>
        <span class="s1">index=pd.Index(</span>
            <span class="s1">[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;C&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">name=</span><span class="s2">&quot;index&quot;</span><span class="s0">,</span>
        <span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">ddf1 = dd.from_pandas(data</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">ddf2 = ddf1.clear_divisions().repartition(</span><span class="s3">8</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;Partitions have overlapping values&quot;</span><span class="s1">):</span>
        <span class="s1">ddf2.compute_current_divisions()</span>


<span class="s0">def </span><span class="s1">test_shuffle_hlg_layer():</span>
    <span class="s4"># This test checks that the `ShuffleLayer` HLG Layer</span>
    <span class="s4"># is used (as expected) for a multi-stage shuffle.</span>
    <span class="s1">ddf = dd.from_pandas(</span>
        <span class="s1">pd.DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: np.random.randint(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)})</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">10</span>
    <span class="s1">)</span>
    <span class="s4"># Disk-based shuffle doesn't use HLG layers at the moment, so we only test tasks</span>
    <span class="s1">ddf_shuffled = ddf.shuffle(</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s1">max_branch=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">shuffle=</span><span class="s2">&quot;tasks&quot;</span><span class="s1">)</span>
    <span class="s1">keys = [(ddf_shuffled._name</span><span class="s0">, </span><span class="s1">i) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(ddf_shuffled.npartitions)]</span>

    <span class="s4"># Cull the HLG</span>
    <span class="s1">dsk = ddf_shuffled.__dask_graph__()</span>
    <span class="s1">dsk_culled = dsk.cull(set(keys))</span>
    <span class="s0">assert </span><span class="s1">isinstance(dsk_culled</span><span class="s0">, </span><span class="s1">dask.highlevelgraph.HighLevelGraph)</span>

    <span class="s4"># Ensure we have ShuffleLayers</span>
    <span class="s0">assert </span><span class="s1">any(</span>
        <span class="s1">isinstance(layer</span><span class="s0">, </span><span class="s1">dd.shuffle.ShuffleLayer) </span><span class="s0">for </span><span class="s1">layer </span><span class="s0">in </span><span class="s1">dsk.layers.values()</span>
    <span class="s1">)</span>

    <span class="s4"># Check that the ShuffleLayers are non-materialized</span>
    <span class="s0">for </span><span class="s1">layer </span><span class="s0">in </span><span class="s1">dsk.layers.values():</span>
        <span class="s0">if </span><span class="s1">isinstance(layer</span><span class="s0">, </span><span class="s1">dd.shuffle.ShuffleLayer):</span>
            <span class="s0">assert not </span><span class="s1">hasattr(layer</span><span class="s0">, </span><span class="s2">&quot;_cached_dict&quot;</span><span class="s1">)</span>

    <span class="s4"># Make sure HLG culling reduces the graph size</span>
    <span class="s0">assert </span><span class="s1">len(dsk_culled) &lt; len(dsk)</span>

    <span class="s4"># Check ShuffleLayer names</span>
    <span class="s0">for </span><span class="s1">name</span><span class="s0">, </span><span class="s1">layer </span><span class="s0">in </span><span class="s1">dsk.layers.items():</span>
        <span class="s0">if </span><span class="s1">isinstance(layer</span><span class="s0">, </span><span class="s1">dd.shuffle.ShuffleLayer):</span>
            <span class="s0">assert </span><span class="s1">name.startswith(</span><span class="s2">&quot;shuffle-&quot;</span><span class="s1">)</span>

    <span class="s4"># Since we already culled the HLG,</span>
    <span class="s4"># culling the dictionary should not change the graph</span>
    <span class="s1">dsk_dict = dict(dsk_culled)</span>
    <span class="s1">dsk_dict_culled</span><span class="s0">, </span><span class="s1">_ = cull(dsk_dict</span><span class="s0">, </span><span class="s1">keys)</span>
    <span class="s0">assert </span><span class="s1">dsk_dict_culled == dsk_dict</span>


<span class="s0">def </span><span class="s1">test_shuffle_partitions_meta_dtype():</span>
    <span class="s1">ddf = dd.from_pandas(</span>
        <span class="s1">pd.DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: np.random.randint(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)}</span><span class="s0">, </span><span class="s1">index=np.random.random(</span><span class="s3">100</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">npartitions=</span><span class="s3">10</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s4"># Disk-based shuffle doesn't use HLG layers at the moment, so we only test tasks</span>
    <span class="s1">ddf_shuffled = ddf.shuffle(ddf[</span><span class="s2">&quot;a&quot;</span><span class="s1">] % </span><span class="s3">10</span><span class="s0">, </span><span class="s1">max_branch=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">shuffle=</span><span class="s2">&quot;tasks&quot;</span><span class="s1">)</span>
    <span class="s4"># Cull the HLG</span>
    <span class="s1">dsk = ddf_shuffled.__dask_graph__()</span>

    <span class="s0">for </span><span class="s1">layer </span><span class="s0">in </span><span class="s1">dsk.layers.values():</span>
        <span class="s0">if </span><span class="s1">isinstance(layer</span><span class="s0">, </span><span class="s1">dd.shuffle.ShuffleLayer):</span>
            <span class="s0">assert </span><span class="s1">layer.meta_input[</span><span class="s2">&quot;_partitions&quot;</span><span class="s1">].dtype == np.int64</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;npartitions&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s3">10</span><span class="s0">,  </span><span class="s4"># ShuffleLayer</span>
        <span class="s3">1</span><span class="s0">,  </span><span class="s4"># SimpleShuffleLayer</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_shuffle_hlg_layer_serialize(npartitions):</span>
    <span class="s1">ddf = dd.from_pandas(</span>
        <span class="s1">pd.DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: np.random.randint(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)})</span><span class="s0">, </span><span class="s1">npartitions=npartitions</span>
    <span class="s1">)</span>
    <span class="s4"># Disk-based shuffle doesn't use HLG layers at the moment, so we only test tasks</span>
    <span class="s1">ddf_shuffled = ddf.shuffle(</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s1">max_branch=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">shuffle=</span><span class="s2">&quot;tasks&quot;</span><span class="s1">)</span>

    <span class="s4"># Ensure shuffle layers can be serialized and don't result in</span>
    <span class="s4"># the underlying low-level graph being materialized</span>
    <span class="s1">dsk = ddf_shuffled.__dask_graph__()</span>
    <span class="s0">for </span><span class="s1">layer </span><span class="s0">in </span><span class="s1">dsk.layers.values():</span>
        <span class="s0">if not </span><span class="s1">isinstance(layer</span><span class="s0">, </span><span class="s1">dd.shuffle.SimpleShuffleLayer):</span>
            <span class="s0">continue</span>
        <span class="s0">assert not </span><span class="s1">hasattr(layer</span><span class="s0">, </span><span class="s2">&quot;_cached_dict&quot;</span><span class="s1">)</span>
        <span class="s1">layer_roundtrip = pickle.loads(pickle.dumps(layer))</span>
        <span class="s0">assert </span><span class="s1">type(layer_roundtrip) == type(layer)</span>
        <span class="s0">assert not </span><span class="s1">hasattr(layer_roundtrip</span><span class="s0">, </span><span class="s2">&quot;_cached_dict&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">layer_roundtrip.keys() == layer.keys()</span>


<span class="s0">def </span><span class="s1">test_set_index_nan_partition():</span>
    <span class="s1">d[d.a &gt; </span><span class="s3">3</span><span class="s1">].set_index(</span><span class="s2">&quot;a&quot;</span><span class="s1">)  </span><span class="s4"># Set index with 1 null partition</span>
    <span class="s1">d[d.a &gt; </span><span class="s3">1</span><span class="s1">].set_index(</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s1">sorted=</span><span class="s0">True</span><span class="s1">)  </span><span class="s4"># Set sorted index with 0 null partitions</span>
    <span class="s1">a = d[d.a &gt; </span><span class="s3">3</span><span class="s1">].set_index(</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s1">sorted=</span><span class="s0">True</span><span class="s1">)  </span><span class="s4"># Set sorted index with 1 null partition</span>
    <span class="s1">assert_eq(a</span><span class="s0">, </span><span class="s1">a)</span>


<span class="s0">def </span><span class="s1">test_set_index_with_dask_dt_index():</span>
    <span class="s1">values = {</span>
        <span class="s2">&quot;x&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">] * </span><span class="s3">3</span><span class="s0">,</span>
        <span class="s2">&quot;y&quot;</span><span class="s1">: [</span><span class="s3">10</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">30</span><span class="s1">] * </span><span class="s3">4</span><span class="s0">,</span>
        <span class="s2">&quot;name&quot;</span><span class="s1">: [</span><span class="s2">&quot;Alice&quot;</span><span class="s0">, </span><span class="s2">&quot;Bob&quot;</span><span class="s1">] * </span><span class="s3">6</span><span class="s0">,</span>
    <span class="s1">}</span>
    <span class="s1">date_index = pd.date_range(</span>
        <span class="s1">start=</span><span class="s2">&quot;2022-02-22&quot;</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;16h&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">12</span>
    <span class="s1">) - pd.Timedelta(seconds=</span><span class="s3">30</span><span class="s1">)</span>
    <span class="s1">df = pd.DataFrame(values</span><span class="s0">, </span><span class="s1">index=date_index)</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">3</span><span class="s1">)</span>

    <span class="s4"># specify a different date index entirely</span>
    <span class="s1">day_index = ddf.index.dt.floor(</span><span class="s2">&quot;D&quot;</span><span class="s1">)</span>
    <span class="s1">day_df = ddf.set_index(day_index)</span>
    <span class="s1">expected = dd.from_pandas(</span>
        <span class="s1">pd.DataFrame(values</span><span class="s0">, </span><span class="s1">index=date_index.floor(</span><span class="s2">&quot;D&quot;</span><span class="s1">))</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">3</span>
    <span class="s1">)</span>
    <span class="s1">assert_eq(day_df</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s4"># specify an index with shifted dates</span>
    <span class="s1">one_day = pd.Timedelta(days=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">next_day_df = ddf.set_index(ddf.index + one_day)</span>
    <span class="s1">expected = dd.from_pandas(</span>
        <span class="s1">pd.DataFrame(values</span><span class="s0">, </span><span class="s1">index=date_index + one_day)</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">3</span>
    <span class="s1">)</span>
    <span class="s1">assert_eq(next_day_df</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s4"># try a different index type</span>
    <span class="s1">no_dates = dd.from_pandas(pd.DataFrame(values)</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">range_df = ddf.set_index(no_dates.index)</span>
    <span class="s1">expected = dd.from_pandas(pd.DataFrame(values)</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">assert_eq(range_df</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_set_index_with_series_uses_fastpath():</span>
    <span class="s1">dates = pd.date_range(start=</span><span class="s2">&quot;2022-02-22&quot;</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;16h&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">12</span><span class="s1">) - pd.Timedelta(</span>
        <span class="s1">seconds=</span><span class="s3">30</span>
    <span class="s1">)</span>
    <span class="s1">one_day = pd.Timedelta(days=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">df = pd.DataFrame(</span>
        <span class="s1">{</span>
            <span class="s2">&quot;x&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">] * </span><span class="s3">3</span><span class="s0">,</span>
            <span class="s2">&quot;y&quot;</span><span class="s1">: [</span><span class="s3">10</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">30</span><span class="s1">] * </span><span class="s3">4</span><span class="s0">,</span>
            <span class="s2">&quot;name&quot;</span><span class="s1">: [</span><span class="s2">&quot;Alice&quot;</span><span class="s0">, </span><span class="s2">&quot;Bob&quot;</span><span class="s1">] * </span><span class="s3">6</span><span class="s0">,</span>
            <span class="s2">&quot;d1&quot;</span><span class="s1">: dates + one_day</span><span class="s0">,</span>
            <span class="s2">&quot;d2&quot;</span><span class="s1">: dates + one_day * </span><span class="s3">5</span><span class="s0">,</span>
        <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">index=dates</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">3</span><span class="s1">)</span>

    <span class="s1">res = ddf.set_index(ddf.d2 + one_day)</span>
    <span class="s1">expected = df.set_index(df.d2 + one_day)</span>
    <span class="s1">assert_eq(res</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_set_index_partitions_meta_dtype():</span>
    <span class="s1">ddf = dd.from_pandas(</span>
        <span class="s1">pd.DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: np.random.randint(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)}</span><span class="s0">, </span><span class="s1">index=np.random.random(</span><span class="s3">100</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">npartitions=</span><span class="s3">10</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s4"># Disk-based shuffle doesn't use HLG layers at the moment, so we only test tasks</span>
    <span class="s1">ddf = ddf.set_index(</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s1">shuffle=</span><span class="s2">&quot;tasks&quot;</span><span class="s1">)</span>
    <span class="s4"># Cull the HLG</span>
    <span class="s1">dsk = ddf.__dask_graph__()</span>

    <span class="s0">for </span><span class="s1">layer </span><span class="s0">in </span><span class="s1">dsk.layers.values():</span>
        <span class="s0">if </span><span class="s1">isinstance(layer</span><span class="s0">, </span><span class="s1">dd.shuffle.SimpleShuffleLayer):</span>
            <span class="s0">assert </span><span class="s1">layer.meta_input[</span><span class="s2">&quot;_partitions&quot;</span><span class="s1">].dtype == np.int64</span>


<span class="s0">def </span><span class="s1">test_sort_values_partitions_meta_dtype_with_divisions():</span>
    <span class="s0">with </span><span class="s1">dask.config.set({</span><span class="s2">&quot;dataframe.shuffle.method&quot;</span><span class="s1">: </span><span class="s2">&quot;tasks&quot;</span><span class="s1">}):</span>
        <span class="s1">ddf = dd.from_pandas(</span>
            <span class="s1">pd.DataFrame(</span>
                <span class="s1">{</span>
                    <span class="s2">&quot;a&quot;</span><span class="s1">: np.random.randint(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s2">&quot;b&quot;</span><span class="s1">: np.random.randint(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">}</span><span class="s0">,</span>
                <span class="s1">index=np.random.random(</span><span class="s3">100</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">npartitions=</span><span class="s3">10</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s4"># Disk-based shuffle doesn't use HLG layers at the moment, so we only test tasks</span>
        <span class="s1">ddf = ddf.set_index(</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s1">shuffle=</span><span class="s2">&quot;tasks&quot;</span><span class="s1">).sort_values(</span><span class="s2">&quot;b&quot;</span><span class="s1">)</span>
        <span class="s4"># Cull the HLG</span>
        <span class="s1">dsk = ddf.__dask_graph__()</span>

        <span class="s0">for </span><span class="s1">layer </span><span class="s0">in </span><span class="s1">dsk.layers.values():</span>
            <span class="s0">if </span><span class="s1">isinstance(layer</span><span class="s0">, </span><span class="s1">dd.shuffle.SimpleShuffleLayer):</span>
                <span class="s0">assert </span><span class="s1">layer.meta_input[</span><span class="s2">&quot;_partitions&quot;</span><span class="s1">].dtype == np.int64</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;ascending&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;by&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;nelem&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">10</span><span class="s0">, </span><span class="s3">500</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_sort_values(nelem</span><span class="s0">, </span><span class="s1">by</span><span class="s0">, </span><span class="s1">ascending):</span>
    <span class="s1">np.random.seed(</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">df = pd.DataFrame()</span>
    <span class="s1">df[</span><span class="s2">&quot;a&quot;</span><span class="s1">] = np.ascontiguousarray(np.arange(nelem)[::-</span><span class="s3">1</span><span class="s1">])</span>
    <span class="s1">df[</span><span class="s2">&quot;b&quot;</span><span class="s1">] = np.arange(</span><span class="s3">100</span><span class="s0">, </span><span class="s1">nelem + </span><span class="s3">100</span><span class="s1">)</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">10</span><span class="s1">)</span>

    <span class="s4"># run on single-threaded scheduler for debugging purposes</span>
    <span class="s0">with </span><span class="s1">dask.config.set(scheduler=</span><span class="s2">&quot;single-threaded&quot;</span><span class="s1">):</span>
        <span class="s1">got = ddf.sort_values(by=by</span><span class="s0">, </span><span class="s1">ascending=ascending)</span>
    <span class="s1">expect = df.sort_values(by=by</span><span class="s0">, </span><span class="s1">ascending=ascending)</span>
    <span class="s1">dd.assert_eq(got</span><span class="s0">, </span><span class="s1">expect</span><span class="s0">, </span><span class="s1">check_index=</span><span class="s0">False, </span><span class="s1">sort_results=</span><span class="s0">False</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;backend&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;pandas&quot;</span><span class="s0">, </span><span class="s1">pytest.param(</span><span class="s2">&quot;cudf&quot;</span><span class="s0">, </span><span class="s1">marks=pytest.mark.gpu)]</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;by&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;z&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;z&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;z&quot;</span><span class="s0">, </span><span class="s2">&quot;x&quot;</span><span class="s1">]])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;ascending&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_sort_values_tasks_backend(backend</span><span class="s0">, </span><span class="s1">by</span><span class="s0">, </span><span class="s1">ascending):</span>
    <span class="s0">if </span><span class="s1">backend == </span><span class="s2">&quot;cudf&quot;</span><span class="s1">:</span>
        <span class="s1">pytest.importorskip(</span><span class="s2">&quot;dask_cudf&quot;</span><span class="s1">)</span>
    <span class="s1">pdf = pd.DataFrame(</span>
        <span class="s1">{</span><span class="s2">&quot;x&quot;</span><span class="s1">: range(</span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">] * </span><span class="s3">2</span><span class="s0">, </span><span class="s2">&quot;z&quot;</span><span class="s1">: [</span><span class="s2">&quot;cat&quot;</span><span class="s0">, </span><span class="s2">&quot;dog&quot;</span><span class="s1">] * </span><span class="s3">5</span><span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">ddf = dd.from_pandas(pdf</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">10</span><span class="s1">).to_backend(backend)</span>

    <span class="s1">expect = pdf.sort_values(by=by</span><span class="s0">, </span><span class="s1">ascending=ascending)</span>
    <span class="s1">got = dd.DataFrame.sort_values(ddf</span><span class="s0">, </span><span class="s1">by=by</span><span class="s0">, </span><span class="s1">ascending=ascending</span><span class="s0">, </span><span class="s1">shuffle=</span><span class="s2">&quot;tasks&quot;</span><span class="s1">)</span>
    <span class="s1">dd.assert_eq(got</span><span class="s0">, </span><span class="s1">expect</span><span class="s0">, </span><span class="s1">sort_results=</span><span class="s0">False</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;ascending&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False, </span><span class="s1">[</span><span class="s0">False, True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">]])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;by&quot;</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s1">]])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;nelem&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">10</span><span class="s0">, </span><span class="s3">500</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_sort_values_single_partition(nelem</span><span class="s0">, </span><span class="s1">by</span><span class="s0">, </span><span class="s1">ascending):</span>
    <span class="s1">np.random.seed(</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">df = pd.DataFrame()</span>
    <span class="s1">df[</span><span class="s2">&quot;a&quot;</span><span class="s1">] = np.ascontiguousarray(np.arange(nelem)[::-</span><span class="s3">1</span><span class="s1">])</span>
    <span class="s1">df[</span><span class="s2">&quot;b&quot;</span><span class="s1">] = np.arange(</span><span class="s3">100</span><span class="s0">, </span><span class="s1">nelem + </span><span class="s3">100</span><span class="s1">)</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">1</span><span class="s1">)</span>

    <span class="s4"># run on single-threaded scheduler for debugging purposes</span>
    <span class="s0">with </span><span class="s1">dask.config.set(scheduler=</span><span class="s2">&quot;single-threaded&quot;</span><span class="s1">):</span>
        <span class="s1">got = ddf.sort_values(by=by</span><span class="s0">, </span><span class="s1">ascending=ascending)</span>
    <span class="s1">expect = df.sort_values(by=by</span><span class="s0">, </span><span class="s1">ascending=ascending)</span>
    <span class="s1">dd.assert_eq(got</span><span class="s0">, </span><span class="s1">expect</span><span class="s0">, </span><span class="s1">check_index=</span><span class="s0">False</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;na_position&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;first&quot;</span><span class="s0">, </span><span class="s2">&quot;last&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;ascending&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;by&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;nparts&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">5</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;data&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">{</span>
            <span class="s2">&quot;a&quot;</span><span class="s1">: list(range(</span><span class="s3">50</span><span class="s1">)) + [</span><span class="s0">None</span><span class="s1">] * </span><span class="s3">50 </span><span class="s1">+ list(range(</span><span class="s3">50</span><span class="s0">, </span><span class="s3">100</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s0">None</span><span class="s1">] * </span><span class="s3">100 </span><span class="s1">+ list(range(</span><span class="s3">100</span><span class="s0">, </span><span class="s3">150</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">{</span>
            <span class="s2">&quot;a&quot;</span><span class="s1">: list(range(</span><span class="s3">15</span><span class="s1">)) + [</span><span class="s0">None</span><span class="s1">] * </span><span class="s3">5</span><span class="s0">,</span>
            <span class="s2">&quot;b&quot;</span><span class="s1">: list(reversed(range(</span><span class="s3">20</span><span class="s1">)))</span><span class="s0">,</span>
        <span class="s1">}</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_sort_values_with_nulls(data</span><span class="s0">, </span><span class="s1">nparts</span><span class="s0">, </span><span class="s1">by</span><span class="s0">, </span><span class="s1">ascending</span><span class="s0">, </span><span class="s1">na_position):</span>
    <span class="s1">df = pd.DataFrame(data)</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=nparts)</span>

    <span class="s4"># run on single-threaded scheduler for debugging purposes</span>
    <span class="s0">with </span><span class="s1">dask.config.set(scheduler=</span><span class="s2">&quot;single-threaded&quot;</span><span class="s1">):</span>
        <span class="s1">got = ddf.sort_values(by=by</span><span class="s0">, </span><span class="s1">ascending=ascending</span><span class="s0">, </span><span class="s1">na_position=na_position)</span>
    <span class="s1">expect = df.sort_values(by=by</span><span class="s0">, </span><span class="s1">ascending=ascending</span><span class="s0">, </span><span class="s1">na_position=na_position)</span>
    <span class="s1">dd.assert_eq(got</span><span class="s0">, </span><span class="s1">expect</span><span class="s0">, </span><span class="s1">check_index=</span><span class="s0">False</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_shuffle_values_raises():</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]})</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(</span>
        <span class="s1">ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;na_position must be either 'first' or 'last'&quot;</span>
    <span class="s1">):</span>
        <span class="s1">ddf.sort_values(by=</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s1">na_position=</span><span class="s2">&quot;invalid&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_shuffle_by_as_list():</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]})</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">dask.config.set(scheduler=</span><span class="s2">&quot;single-threaded&quot;</span><span class="s1">):</span>
        <span class="s1">got = ddf.sort_values(by=[</span><span class="s2">&quot;a&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s2">&quot;auto&quot;</span><span class="s0">, </span><span class="s1">ascending=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">expect = pd.DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]})</span>
    <span class="s1">dd.assert_eq(got</span><span class="s0">, </span><span class="s1">expect</span><span class="s0">, </span><span class="s1">check_index=</span><span class="s0">False</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_noop():</span>
    <span class="s0">assert </span><span class="s1">_noop(</span><span class="s3">1</span><span class="s0">, None</span><span class="s1">) == </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">_noop(</span><span class="s2">&quot;test&quot;</span><span class="s0">, None</span><span class="s1">) == </span><span class="s2">&quot;test&quot;</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;by&quot;</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s1">]])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;nparts&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">10</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_sort_values_custom_function(by</span><span class="s0">, </span><span class="s1">nparts):</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">] * </span><span class="s3">20</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s1">] * </span><span class="s3">15</span><span class="s1">})</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=nparts)</span>

    <span class="s0">def </span><span class="s1">f(partition</span><span class="s0">, </span><span class="s1">by_columns</span><span class="s0">, </span><span class="s1">ascending</span><span class="s0">, </span><span class="s1">na_position</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">return </span><span class="s1">partition.sort_values(</span>
            <span class="s1">by_columns</span><span class="s0">, </span><span class="s1">ascending=ascending</span><span class="s0">, </span><span class="s1">na_position=na_position</span>
        <span class="s1">)</span>

    <span class="s4"># run on single-threaded scheduler for debugging purposes</span>
    <span class="s0">with </span><span class="s1">dask.config.set(scheduler=</span><span class="s2">&quot;single-threaded&quot;</span><span class="s1">):</span>
        <span class="s1">got = ddf.sort_values(</span>
            <span class="s1">by=by[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">sort_function=f</span><span class="s0">, </span><span class="s1">sort_function_kwargs={</span><span class="s2">&quot;by_columns&quot;</span><span class="s1">: by}</span>
        <span class="s1">)</span>
    <span class="s1">expect = df.sort_values(by=by)</span>
    <span class="s1">dd.assert_eq(got</span><span class="s0">, </span><span class="s1">expect</span><span class="s0">, </span><span class="s1">check_index=</span><span class="s0">False</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_sort_values_bool_ascending():</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">] * </span><span class="s3">20</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s1">] * </span><span class="s3">15</span><span class="s1">})</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">10</span><span class="s1">)</span>

    <span class="s4"># attempt to sort with list of ascending booleans</span>
    <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError):</span>
        <span class="s1">ddf.sort_values(by=</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s1">ascending=[</span><span class="s0">True, False</span><span class="s1">])</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;npartitions&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_sort_values_timestamp(npartitions):</span>
    <span class="s4"># Regression test for https://github.com/dask/dask/issues/9641</span>
    <span class="s1">df = pd.DataFrame.from_records(</span>
        <span class="s1">[</span>
            <span class="s1">[pd.Timestamp(</span><span class="s2">&quot;2002-01-11 21:00:01+0000&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;UTC&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s3">4223</span><span class="s0">, </span><span class="s3">54719.0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[pd.Timestamp(</span><span class="s2">&quot;2002-01-14 21:00:01+0000&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;UTC&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s3">6942</span><span class="s0">, </span><span class="s3">19223.0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[pd.Timestamp(</span><span class="s2">&quot;2002-01-15 21:00:01+0000&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;UTC&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s3">12551</span><span class="s0">, </span><span class="s3">72865.0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[pd.Timestamp(</span><span class="s2">&quot;2002-01-23 21:00:01+0000&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;UTC&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s3">6005</span><span class="s0">, </span><span class="s3">57670.0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[pd.Timestamp(</span><span class="s2">&quot;2002-01-29 21:00:01+0000&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;UTC&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s3">2043</span><span class="s0">, </span><span class="s3">58600.0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[pd.Timestamp(</span><span class="s2">&quot;2002-02-01 21:00:01+0000&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;UTC&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s3">6909</span><span class="s0">, </span><span class="s3">8459.0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[pd.Timestamp(</span><span class="s2">&quot;2002-01-14 21:00:01+0000&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;UTC&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s3">5326</span><span class="s0">, </span><span class="s3">77339.0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[pd.Timestamp(</span><span class="s2">&quot;2002-01-14 21:00:01+0000&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;UTC&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s3">4711</span><span class="s0">, </span><span class="s3">54135.0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[pd.Timestamp(</span><span class="s2">&quot;2002-01-22 21:00:01+0000&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;UTC&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s3">103</span><span class="s0">, </span><span class="s3">57627.0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[pd.Timestamp(</span><span class="s2">&quot;2002-01-30 21:00:01+0000&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;UTC&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s3">16862</span><span class="s0">, </span><span class="s3">54458.0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[pd.Timestamp(</span><span class="s2">&quot;2002-01-31 21:00:01+0000&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;UTC&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s3">4143</span><span class="s0">, </span><span class="s3">56280.0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">columns=[</span><span class="s2">&quot;time&quot;</span><span class="s0">, </span><span class="s2">&quot;id1&quot;</span><span class="s0">, </span><span class="s2">&quot;id2&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=npartitions)</span>
    <span class="s1">result = ddf.sort_values(</span><span class="s2">&quot;time&quot;</span><span class="s1">)</span>
    <span class="s1">expected = df.sort_values(</span><span class="s2">&quot;time&quot;</span><span class="s1">)</span>
    <span class="s1">assert_eq(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;pdf,expected&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span>
            <span class="s1">pd.DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: list(</span><span class="s2">&quot;aabbcc&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: list(</span><span class="s2">&quot;xyyyzz&quot;</span><span class="s1">)})</span><span class="s0">,</span>
            <span class="s1">([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">]</span><span class="s0">, False</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s1">pd.DataFrame(</span>
                <span class="s1">{</span>
                    <span class="s2">&quot;x&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">,</span>
                    <span class="s2">&quot;y&quot;</span><span class="s1">: [</span><span class="s3">21</span><span class="s0">, </span><span class="s3">9</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">10</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">}</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">8</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, False</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s1">pd.DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: [</span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, None, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, None, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, None</span><span class="s1">]})</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s1">[</span><span class="s3">2.0</span><span class="s0">, </span><span class="s3">4.0</span><span class="s0">, </span><span class="s3">5.666666666666667</span><span class="s0">, </span><span class="s3">8.0</span><span class="s0">, </span><span class="s3">10.0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s3">5.0</span><span class="s0">, </span><span class="s3">10.0</span><span class="s0">, </span><span class="s3">2.0</span><span class="s0">, </span><span class="s3">4.0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s3">7.0</span><span class="s0">, </span><span class="s3">10.0</span><span class="s0">, </span><span class="s3">8.0</span><span class="s0">, </span><span class="s3">4.0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s0">False,</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_calculate_divisions(pdf</span><span class="s0">, </span><span class="s1">expected):</span>
    <span class="s1">ddf = dd.from_pandas(pdf</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">divisions</span><span class="s0">, </span><span class="s1">mins</span><span class="s0">, </span><span class="s1">maxes</span><span class="s0">, </span><span class="s1">presorted = _calculate_divisions(ddf</span><span class="s0">, </span><span class="s1">ddf[</span><span class="s2">&quot;x&quot;</span><span class="s1">]</span><span class="s0">, False, </span><span class="s3">4</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">divisions == expected[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">mins == expected[</span><span class="s3">1</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">maxes == expected[</span><span class="s3">2</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">presorted == expected[</span><span class="s3">3</span><span class="s1">]</span>


<span class="s1">@pytest.mark.skipif(pa </span><span class="s0">is None, </span><span class="s1">reason=</span><span class="s2">&quot;Need pyarrow&quot;</span><span class="s1">)</span>
<span class="s1">@pytest.mark.skipif(</span><span class="s0">not </span><span class="s1">PANDAS_GE_200</span><span class="s0">, </span><span class="s1">reason=</span><span class="s2">&quot;dtype support not good before 2.0&quot;</span><span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;data, dtype&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;string[pyarrow]&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s6">b&quot;a&quot;</span><span class="s0">, </span><span class="s6">b&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;binary[pyarrow]&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s4"># Should probably fix upstream, https://github.com/pandas-dev/pandas/issues/52590</span>
        <span class="s4"># ([&quot;a&quot;, &quot;b&quot;], pa.large_string()),</span>
        <span class="s4"># ([b&quot;a&quot;, b&quot;b&quot;], pa.large_binary()),</span>
        <span class="s1">([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;int64[pyarrow]&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;float64[pyarrow]&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;uint64[pyarrow]&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([date(</span><span class="s3">2022</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">date(</span><span class="s3">1999</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">31</span><span class="s1">)]</span><span class="s0">, </span><span class="s2">&quot;date32[pyarrow]&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s1">[pd.Timestamp(</span><span class="s2">&quot;2022-01-01&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pd.Timestamp(</span><span class="s2">&quot;2023-01-02&quot;</span><span class="s1">)]</span><span class="s0">,</span>
            <span class="s2">&quot;timestamp[ns][pyarrow]&quot;</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([Decimal(</span><span class="s2">&quot;5&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">Decimal(</span><span class="s2">&quot;6.24&quot;</span><span class="s1">)]</span><span class="s0">, </span><span class="s2">&quot;decimal128&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([pd.Timedelta(</span><span class="s2">&quot;1 day&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pd.Timedelta(</span><span class="s2">&quot;20 days&quot;</span><span class="s1">)]</span><span class="s0">, </span><span class="s2">&quot;duration[ns][pyarrow]&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([time(</span><span class="s3">12</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">time(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">12</span><span class="s1">)]</span><span class="s0">, </span><span class="s2">&quot;time64[ns][pyarrow]&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_set_index_pyarrow_dtype(data</span><span class="s0">, </span><span class="s1">dtype):</span>
    <span class="s0">if </span><span class="s1">dtype == </span><span class="s2">&quot;decimal128&quot;</span><span class="s1">:</span>
        <span class="s1">dtype = pd.ArrowDtype(pa.decimal128(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
    <span class="s1">pdf = pd.DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;arrow_col&quot;</span><span class="s1">: pd.Series(data</span><span class="s0">, </span><span class="s1">dtype=dtype)})</span>
    <span class="s1">ddf = dd.from_pandas(pdf</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">pdf_result = pdf.set_index(</span><span class="s2">&quot;arrow_col&quot;</span><span class="s1">)</span>
    <span class="s1">ddf_result = ddf.set_index(</span><span class="s2">&quot;arrow_col&quot;</span><span class="s1">)</span>
    <span class="s1">assert_eq(ddf_result</span><span class="s0">, </span><span class="s1">pdf_result)</span>
</pre>
</body>
</html>