<html>
<head>
<title>_dia.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_dia.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Sparse DIAgonal format&quot;&quot;&quot;</span>

<span class="s1">__docformat__ = </span><span class="s2">&quot;restructuredtext en&quot;</span>

<span class="s1">__all__ = [</span><span class="s2">'dia_array'</span><span class="s3">, </span><span class="s2">'dia_matrix'</span><span class="s3">, </span><span class="s2">'isspmatrix_dia'</span><span class="s1">]</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>

<span class="s3">from </span><span class="s1">._matrix </span><span class="s3">import </span><span class="s1">spmatrix</span><span class="s3">, </span><span class="s1">_array_doc_to_matrix</span>
<span class="s3">from </span><span class="s1">._base </span><span class="s3">import </span><span class="s1">issparse</span><span class="s3">, </span><span class="s1">_formats</span><span class="s3">, </span><span class="s1">_spbase</span><span class="s3">, </span><span class="s1">sparray</span>
<span class="s3">from </span><span class="s1">._data </span><span class="s3">import </span><span class="s1">_data_matrix</span>
<span class="s3">from </span><span class="s1">._sputils </span><span class="s3">import </span><span class="s1">(isshape</span><span class="s3">, </span><span class="s1">upcast_char</span><span class="s3">, </span><span class="s1">getdtype</span><span class="s3">, </span><span class="s1">get_sum_dtype</span><span class="s3">, </span><span class="s1">validateaxis</span><span class="s3">, </span><span class="s1">check_shape)</span>
<span class="s3">from </span><span class="s1">._sparsetools </span><span class="s3">import </span><span class="s1">dia_matvec</span>


<span class="s3">class </span><span class="s1">_dia_base(_data_matrix):</span>
    <span class="s0">&quot;&quot;&quot;Sparse matrix with DIAgonal storage 
 
    This can be instantiated in several ways: 
        dia_array(D) 
            with a dense matrix 
 
        dia_array(S) 
            with another sparse matrix S (equivalent to S.todia()) 
 
        dia_array((M, N), [dtype]) 
            to construct an empty matrix with shape (M, N), 
            dtype is optional, defaulting to dtype='d'. 
 
        dia_array((data, offsets), shape=(M, N)) 
            where the ``data[k,:]`` stores the diagonal entries for 
            diagonal ``offsets[k]`` (See example below) 
 
    Attributes 
    ---------- 
    dtype : dtype 
        Data type of the matrix 
    shape : 2-tuple 
        Shape of the matrix 
    ndim : int 
        Number of dimensions (this is always 2) 
    nnz 
        Number of stored values, including explicit zeros 
    data 
        DIA format data array of the matrix 
    offsets 
        DIA format offset array of the matrix 
 
    Notes 
    ----- 
 
    Sparse matrices can be used in arithmetic operations: they support 
    addition, subtraction, multiplication, division, and matrix power. 
 
    Examples 
    -------- 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.sparse import dia_array 
    &gt;&gt;&gt; dia_array((3, 4), dtype=np.int8).toarray() 
    array([[0, 0, 0, 0], 
           [0, 0, 0, 0], 
           [0, 0, 0, 0]], dtype=int8) 
 
    &gt;&gt;&gt; data = np.array([[1, 2, 3, 4]]).repeat(3, axis=0) 
    &gt;&gt;&gt; offsets = np.array([0, -1, 2]) 
    &gt;&gt;&gt; dia_array((data, offsets), shape=(4, 4)).toarray() 
    array([[1, 0, 3, 0], 
           [1, 2, 0, 4], 
           [0, 2, 3, 0], 
           [0, 0, 3, 4]]) 
 
    &gt;&gt;&gt; from scipy.sparse import dia_array 
    &gt;&gt;&gt; n = 10 
    &gt;&gt;&gt; ex = np.ones(n) 
    &gt;&gt;&gt; data = np.array([ex, 2 * ex, ex]) 
    &gt;&gt;&gt; offsets = np.array([-1, 0, 1]) 
    &gt;&gt;&gt; dia_array((data, offsets), shape=(n, n)).toarray() 
    array([[2., 1., 0., ..., 0., 0., 0.], 
           [1., 2., 1., ..., 0., 0., 0.], 
           [0., 1., 2., ..., 0., 0., 0.], 
           ..., 
           [0., 0., 0., ..., 2., 1., 0.], 
           [0., 0., 0., ..., 1., 2., 1.], 
           [0., 0., 0., ..., 0., 1., 2.]]) 
    &quot;&quot;&quot;</span>
    <span class="s1">_format = </span><span class="s2">'dia'</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">arg1</span><span class="s3">, </span><span class="s1">shape=</span><span class="s3">None, </span><span class="s1">dtype=</span><span class="s3">None, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s1">_data_matrix.__init__(self)</span>

        <span class="s3">if </span><span class="s1">issparse(arg1):</span>
            <span class="s3">if </span><span class="s1">arg1.format == </span><span class="s2">&quot;dia&quot;</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">copy:</span>
                    <span class="s1">arg1 = arg1.copy()</span>
                <span class="s1">self.data = arg1.data</span>
                <span class="s1">self.offsets = arg1.offsets</span>
                <span class="s1">self._shape = check_shape(arg1.shape)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">arg1.format == self.format </span><span class="s3">and </span><span class="s1">copy:</span>
                    <span class="s1">A = arg1.copy()</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">A = arg1.todia()</span>
                <span class="s1">self.data = A.data</span>
                <span class="s1">self.offsets = A.offsets</span>
                <span class="s1">self._shape = check_shape(A.shape)</span>
        <span class="s3">elif </span><span class="s1">isinstance(arg1</span><span class="s3">, </span><span class="s1">tuple):</span>
            <span class="s3">if </span><span class="s1">isshape(arg1):</span>
                <span class="s4"># It's a tuple of matrix dimensions (M, N)</span>
                <span class="s4"># create empty matrix</span>
                <span class="s1">self._shape = check_shape(arg1)</span>
                <span class="s1">self.data = np.zeros((</span><span class="s5">0</span><span class="s3">,</span><span class="s5">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">getdtype(dtype</span><span class="s3">, </span><span class="s1">default=float))</span>
                <span class="s1">idx_dtype = self._get_index_dtype(maxval=max(self.shape))</span>
                <span class="s1">self.offsets = np.zeros((</span><span class="s5">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s4"># Try interpreting it as (data, offsets)</span>
                    <span class="s1">data</span><span class="s3">, </span><span class="s1">offsets = arg1</span>
                <span class="s3">except </span><span class="s1">Exception </span><span class="s3">as </span><span class="s1">e:</span>
                    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">'unrecognized form for dia_array constructor'</span><span class="s1">) </span><span class="s3">from </span><span class="s1">e</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">if </span><span class="s1">shape </span><span class="s3">is None</span><span class="s1">:</span>
                        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">'expected a shape argument'</span><span class="s1">)</span>
                    <span class="s1">self.data = np.atleast_2d(np.array(arg1[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=dtype</span><span class="s3">, </span><span class="s1">copy=copy))</span>
                    <span class="s1">self.offsets = np.atleast_1d(np.array(arg1[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">,</span>
                                                          <span class="s1">dtype=self._get_index_dtype(maxval=max(shape))</span><span class="s3">,</span>
                                                          <span class="s1">copy=copy))</span>
                    <span class="s1">self._shape = check_shape(shape)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s4">#must be dense, convert to COO first, then to DIA</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">arg1 = np.asarray(arg1)</span>
            <span class="s3">except </span><span class="s1">Exception </span><span class="s3">as </span><span class="s1">e:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;unrecognized form for&quot;</span>
                        <span class="s2">&quot; %s_matrix constructor&quot; </span><span class="s1">% self.format) </span><span class="s3">from </span><span class="s1">e</span>
            <span class="s1">A = self._coo_container(arg1</span><span class="s3">, </span><span class="s1">dtype=dtype</span><span class="s3">, </span><span class="s1">shape=shape).todia()</span>
            <span class="s1">self.data = A.data</span>
            <span class="s1">self.offsets = A.offsets</span>
            <span class="s1">self._shape = check_shape(A.shape)</span>

        <span class="s3">if </span><span class="s1">dtype </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.data = self.data.astype(dtype)</span>

        <span class="s4">#check format</span>
        <span class="s3">if </span><span class="s1">self.offsets.ndim != </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">'offsets array must have rank 1'</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">self.data.ndim != </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">'data array must have rank 2'</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">self.data.shape[</span><span class="s5">0</span><span class="s1">] != len(self.offsets):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">'number of diagonals (%d) '</span>
                    <span class="s2">'does not match the number of offsets (%d)'</span>
                    <span class="s1">% (self.data.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">len(self.offsets)))</span>

        <span class="s3">if </span><span class="s1">len(np.unique(self.offsets)) != len(self.offsets):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">'offset array contains duplicate values'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s1">format = _formats[self.getformat()][</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s3">return </span><span class="s2">&quot;&lt;%dx%d sparse matrix of type '%s'</span><span class="s3">\n</span><span class="s2">&quot; </span><span class="s1">\</span>
               <span class="s2">&quot;</span><span class="s3">\t</span><span class="s2">with %d stored elements (%d diagonals) in %s format&gt;&quot; </span><span class="s1">% \</span>
               <span class="s1">(self.shape + (self.dtype.type</span><span class="s3">, </span><span class="s1">self.nnz</span><span class="s3">, </span><span class="s1">self.data.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">,</span>
                              <span class="s1">format))</span>

    <span class="s3">def </span><span class="s1">_data_mask(self):</span>
        <span class="s0">&quot;&quot;&quot;Returns a mask of the same shape as self.data, where 
        mask[i,j] is True when data[i,j] corresponds to a stored element.&quot;&quot;&quot;</span>
        <span class="s1">num_rows</span><span class="s3">, </span><span class="s1">num_cols = self.shape</span>
        <span class="s1">offset_inds = np.arange(self.data.shape[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">row = offset_inds - self.offsets[:</span><span class="s3">,None</span><span class="s1">]</span>
        <span class="s1">mask = (row &gt;= </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">mask &amp;= (row &lt; num_rows)</span>
        <span class="s1">mask &amp;= (offset_inds &lt; num_cols)</span>
        <span class="s3">return </span><span class="s1">mask</span>

    <span class="s3">def </span><span class="s1">count_nonzero(self):</span>
        <span class="s1">mask = self._data_mask()</span>
        <span class="s3">return </span><span class="s1">np.count_nonzero(self.data[mask])</span>

    <span class="s3">def </span><span class="s1">_getnnz(self</span><span class="s3">, </span><span class="s1">axis=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">axis </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s2">&quot;_getnnz over an axis is not implemented &quot;</span>
                                      <span class="s2">&quot;for DIA format&quot;</span><span class="s1">)</span>
        <span class="s1">M</span><span class="s3">,</span><span class="s1">N = self.shape</span>
        <span class="s1">nnz = </span><span class="s5">0</span>
        <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">self.offsets:</span>
            <span class="s3">if </span><span class="s1">k &gt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">nnz += min(M</span><span class="s3">,</span><span class="s1">N-k)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">nnz += min(M+k</span><span class="s3">,</span><span class="s1">N)</span>
        <span class="s3">return </span><span class="s1">int(nnz)</span>

    <span class="s1">_getnnz.__doc__ = _spbase._getnnz.__doc__</span>
    <span class="s1">count_nonzero.__doc__ = _spbase.count_nonzero.__doc__</span>

    <span class="s3">def </span><span class="s1">sum(self</span><span class="s3">, </span><span class="s1">axis=</span><span class="s3">None, </span><span class="s1">dtype=</span><span class="s3">None, </span><span class="s1">out=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">validateaxis(axis)</span>

        <span class="s3">if </span><span class="s1">axis </span><span class="s3">is not None and </span><span class="s1">axis &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">axis += </span><span class="s5">2</span>

        <span class="s1">res_dtype = get_sum_dtype(self.dtype)</span>
        <span class="s1">num_rows</span><span class="s3">, </span><span class="s1">num_cols = self.shape</span>
        <span class="s1">ret = </span><span class="s3">None</span>

        <span class="s3">if </span><span class="s1">axis == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">mask = self._data_mask()</span>
            <span class="s1">x = (self.data * mask).sum(axis=</span><span class="s5">0</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">x.shape[</span><span class="s5">0</span><span class="s1">] == num_cols:</span>
                <span class="s1">res = x</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">res = np.zeros(num_cols</span><span class="s3">, </span><span class="s1">dtype=x.dtype)</span>
                <span class="s1">res[:x.shape[</span><span class="s5">0</span><span class="s1">]] = x</span>
            <span class="s1">ret = self._ascontainer(res</span><span class="s3">, </span><span class="s1">dtype=res_dtype)</span>

        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">row_sums = np.zeros((num_rows</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">dtype=res_dtype)</span>
            <span class="s1">one = np.ones(num_cols</span><span class="s3">, </span><span class="s1">dtype=res_dtype)</span>
            <span class="s1">dia_matvec(num_rows</span><span class="s3">, </span><span class="s1">num_cols</span><span class="s3">, </span><span class="s1">len(self.offsets)</span><span class="s3">,</span>
                       <span class="s1">self.data.shape[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">self.offsets</span><span class="s3">, </span><span class="s1">self.data</span><span class="s3">, </span><span class="s1">one</span><span class="s3">, </span><span class="s1">row_sums)</span>

            <span class="s1">row_sums = self._ascontainer(row_sums)</span>

            <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">row_sums.sum(dtype=dtype</span><span class="s3">, </span><span class="s1">out=out)</span>

            <span class="s1">ret = self._ascontainer(row_sums.sum(axis=axis))</span>

        <span class="s3">if </span><span class="s1">out </span><span class="s3">is not None and </span><span class="s1">out.shape != ret.shape:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;dimensions do not match&quot;</span><span class="s1">)</span>

        <span class="s3">return </span><span class="s1">ret.sum(axis=()</span><span class="s3">, </span><span class="s1">dtype=dtype</span><span class="s3">, </span><span class="s1">out=out)</span>

    <span class="s1">sum.__doc__ = _spbase.sum.__doc__</span>

    <span class="s3">def </span><span class="s1">_add_sparse(self</span><span class="s3">, </span><span class="s1">other):</span>

        <span class="s4"># Check if other is also of type dia_array</span>
        <span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">type(self)):</span>
            <span class="s4"># If other is not of type dia_array, default to</span>
            <span class="s4"># converting to csr_matrix, as is done in the _add_sparse</span>
            <span class="s4"># method of parent class _spbase</span>
            <span class="s3">return </span><span class="s1">self.tocsr()._add_sparse(other)</span>

        <span class="s4"># The task is to compute m = self + other</span>
        <span class="s4"># Start by making a copy of self, of the datatype</span>
        <span class="s4"># that should result from adding self and other</span>
        <span class="s1">dtype = np.promote_types(self.dtype</span><span class="s3">, </span><span class="s1">other.dtype)</span>
        <span class="s1">m = self.astype(dtype</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">True</span><span class="s1">)</span>

        <span class="s4"># Then, add all the stored diagonals of other.</span>
        <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">other.offsets:</span>
            <span class="s4"># Check if the diagonal has already been added.</span>
            <span class="s3">if </span><span class="s1">d </span><span class="s3">in </span><span class="s1">m.offsets:</span>
                <span class="s4"># If the diagonal is already there, we need to take</span>
                <span class="s4"># the sum of the existing and the new</span>
                <span class="s1">m.setdiag(m.diagonal(d) + other.diagonal(d)</span><span class="s3">, </span><span class="s1">d)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">m.setdiag(other.diagonal(d)</span><span class="s3">, </span><span class="s1">d)</span>
        <span class="s3">return </span><span class="s1">m</span>

    <span class="s3">def </span><span class="s1">_mul_vector(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s1">x = other</span>

        <span class="s1">y = np.zeros(self.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=upcast_char(self.dtype.char</span><span class="s3">,</span>
                                                       <span class="s1">x.dtype.char))</span>

        <span class="s1">L = self.data.shape[</span><span class="s5">1</span><span class="s1">]</span>

        <span class="s1">M</span><span class="s3">,</span><span class="s1">N = self.shape</span>

        <span class="s1">dia_matvec(M</span><span class="s3">,</span><span class="s1">N</span><span class="s3">, </span><span class="s1">len(self.offsets)</span><span class="s3">, </span><span class="s1">L</span><span class="s3">, </span><span class="s1">self.offsets</span><span class="s3">, </span><span class="s1">self.data</span><span class="s3">, </span><span class="s1">x.ravel()</span><span class="s3">, </span><span class="s1">y.ravel())</span>

        <span class="s3">return </span><span class="s1">y</span>

    <span class="s3">def </span><span class="s1">_mul_multimatrix(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">return </span><span class="s1">np.hstack([self._mul_vector(col).reshape(-</span><span class="s5">1</span><span class="s3">,</span><span class="s5">1</span><span class="s1">) </span><span class="s3">for </span><span class="s1">col </span><span class="s3">in </span><span class="s1">other.T])</span>

    <span class="s3">def </span><span class="s1">_setdiag(self</span><span class="s3">, </span><span class="s1">values</span><span class="s3">, </span><span class="s1">k=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s1">M</span><span class="s3">, </span><span class="s1">N = self.shape</span>

        <span class="s3">if </span><span class="s1">values.ndim == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s4"># broadcast</span>
            <span class="s1">values_n = np.inf</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">values_n = len(values)</span>

        <span class="s3">if </span><span class="s1">k &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">n = min(M + k</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">values_n)</span>
            <span class="s1">min_index = </span><span class="s5">0</span>
            <span class="s1">max_index = n</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">n = min(M</span><span class="s3">, </span><span class="s1">N - k</span><span class="s3">, </span><span class="s1">values_n)</span>
            <span class="s1">min_index = k</span>
            <span class="s1">max_index = k + n</span>

        <span class="s3">if </span><span class="s1">values.ndim != </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s4"># allow also longer sequences</span>
            <span class="s1">values = values[:n]</span>

        <span class="s1">data_rows</span><span class="s3">, </span><span class="s1">data_cols = self.data.shape</span>
        <span class="s3">if </span><span class="s1">k </span><span class="s3">in </span><span class="s1">self.offsets:</span>
            <span class="s3">if </span><span class="s1">max_index &gt; data_cols:</span>
                <span class="s1">data = np.zeros((data_rows</span><span class="s3">, </span><span class="s1">max_index)</span><span class="s3">, </span><span class="s1">dtype=self.data.dtype)</span>
                <span class="s1">data[:</span><span class="s3">, </span><span class="s1">:data_cols] = self.data</span>
                <span class="s1">self.data = data</span>
            <span class="s1">self.data[self.offsets == k</span><span class="s3">, </span><span class="s1">min_index:max_index] = values</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.offsets = np.append(self.offsets</span><span class="s3">, </span><span class="s1">self.offsets.dtype.type(k))</span>
            <span class="s1">m = max(max_index</span><span class="s3">, </span><span class="s1">data_cols)</span>
            <span class="s1">data = np.zeros((data_rows + </span><span class="s5">1</span><span class="s3">, </span><span class="s1">m)</span><span class="s3">, </span><span class="s1">dtype=self.data.dtype)</span>
            <span class="s1">data[:-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">:data_cols] = self.data</span>
            <span class="s1">data[-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">min_index:max_index] = values</span>
            <span class="s1">self.data = data</span>

    <span class="s3">def </span><span class="s1">todia(self</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">copy:</span>
            <span class="s3">return </span><span class="s1">self.copy()</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self</span>

    <span class="s1">todia.__doc__ = _spbase.todia.__doc__</span>

    <span class="s3">def </span><span class="s1">transpose(self</span><span class="s3">, </span><span class="s1">axes=</span><span class="s3">None, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">axes </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Sparse matrices do not support &quot;</span>
                              <span class="s2">&quot;an 'axes' parameter because swapping &quot;</span>
                              <span class="s2">&quot;dimensions is the only logical permutation.&quot;</span><span class="s1">)</span>

        <span class="s1">num_rows</span><span class="s3">, </span><span class="s1">num_cols = self.shape</span>
        <span class="s1">max_dim = max(self.shape)</span>

        <span class="s4"># flip diagonal offsets</span>
        <span class="s1">offsets = -self.offsets</span>

        <span class="s4"># re-align the data matrix</span>
        <span class="s1">r = np.arange(len(offsets)</span><span class="s3">, </span><span class="s1">dtype=np.intc)[:</span><span class="s3">, None</span><span class="s1">]</span>
        <span class="s1">c = np.arange(num_rows</span><span class="s3">, </span><span class="s1">dtype=np.intc) - (offsets % max_dim)[:</span><span class="s3">, None</span><span class="s1">]</span>
        <span class="s1">pad_amount = max(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">max_dim-self.data.shape[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">data = np.hstack((self.data</span><span class="s3">, </span><span class="s1">np.zeros((self.data.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">pad_amount)</span><span class="s3">,</span>
                                              <span class="s1">dtype=self.data.dtype)))</span>
        <span class="s1">data = data[r</span><span class="s3">, </span><span class="s1">c]</span>
        <span class="s3">return </span><span class="s1">self._dia_container((data</span><span class="s3">, </span><span class="s1">offsets)</span><span class="s3">, </span><span class="s1">shape=(</span>
            <span class="s1">num_cols</span><span class="s3">, </span><span class="s1">num_rows)</span><span class="s3">, </span><span class="s1">copy=copy)</span>

    <span class="s1">transpose.__doc__ = _spbase.transpose.__doc__</span>

    <span class="s3">def </span><span class="s1">diagonal(self</span><span class="s3">, </span><span class="s1">k=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s1">rows</span><span class="s3">, </span><span class="s1">cols = self.shape</span>
        <span class="s3">if </span><span class="s1">k &lt;= -rows </span><span class="s3">or </span><span class="s1">k &gt;= cols:</span>
            <span class="s3">return </span><span class="s1">np.empty(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">dtype=self.data.dtype)</span>
        <span class="s1">idx</span><span class="s3">, </span><span class="s1">= np.nonzero(self.offsets == k)</span>
        <span class="s1">first_col = max(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">k)</span>
        <span class="s1">last_col = min(rows + k</span><span class="s3">, </span><span class="s1">cols)</span>
        <span class="s1">result_size = last_col - first_col</span>
        <span class="s3">if </span><span class="s1">idx.size == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">np.zeros(result_size</span><span class="s3">, </span><span class="s1">dtype=self.data.dtype)</span>
        <span class="s1">result = self.data[idx[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">first_col:last_col]</span>
        <span class="s1">padding = result_size - len(result)</span>
        <span class="s3">if </span><span class="s1">padding &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">result = np.pad(result</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">padding)</span><span class="s3">, </span><span class="s1">mode=</span><span class="s2">'constant'</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">result</span>

    <span class="s1">diagonal.__doc__ = _spbase.diagonal.__doc__</span>

    <span class="s3">def </span><span class="s1">tocsc(self</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">self.nnz == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self._csc_container(self.shape</span><span class="s3">, </span><span class="s1">dtype=self.dtype)</span>

        <span class="s1">num_rows</span><span class="s3">, </span><span class="s1">num_cols = self.shape</span>
        <span class="s1">num_offsets</span><span class="s3">, </span><span class="s1">offset_len = self.data.shape</span>
        <span class="s1">offset_inds = np.arange(offset_len)</span>

        <span class="s1">row = offset_inds - self.offsets[:</span><span class="s3">,None</span><span class="s1">]</span>
        <span class="s1">mask = (row &gt;= </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">mask &amp;= (row &lt; num_rows)</span>
        <span class="s1">mask &amp;= (offset_inds &lt; num_cols)</span>
        <span class="s1">mask &amp;= (self.data != </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s1">idx_dtype = self._get_index_dtype(maxval=max(self.shape))</span>
        <span class="s1">indptr = np.zeros(num_cols + </span><span class="s5">1</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
        <span class="s1">indptr[</span><span class="s5">1</span><span class="s1">:offset_len+</span><span class="s5">1</span><span class="s1">] = np.cumsum(mask.sum(axis=</span><span class="s5">0</span><span class="s1">)[:num_cols])</span>
        <span class="s3">if </span><span class="s1">offset_len &lt; num_cols:</span>
            <span class="s1">indptr[offset_len+</span><span class="s5">1</span><span class="s1">:] = indptr[offset_len]</span>
        <span class="s1">indices = row.T[mask.T].astype(idx_dtype</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s1">data = self.data.T[mask.T]</span>
        <span class="s3">return </span><span class="s1">self._csc_container((data</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">indptr)</span><span class="s3">, </span><span class="s1">shape=self.shape</span><span class="s3">,</span>
                                   <span class="s1">dtype=self.dtype)</span>

    <span class="s1">tocsc.__doc__ = _spbase.tocsc.__doc__</span>

    <span class="s3">def </span><span class="s1">tocoo(self</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s1">num_rows</span><span class="s3">, </span><span class="s1">num_cols = self.shape</span>
        <span class="s1">num_offsets</span><span class="s3">, </span><span class="s1">offset_len = self.data.shape</span>
        <span class="s1">offset_inds = np.arange(offset_len)</span>

        <span class="s1">row = offset_inds - self.offsets[:</span><span class="s3">,None</span><span class="s1">]</span>
        <span class="s1">mask = (row &gt;= </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">mask &amp;= (row &lt; num_rows)</span>
        <span class="s1">mask &amp;= (offset_inds &lt; num_cols)</span>
        <span class="s1">mask &amp;= (self.data != </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">row = row[mask]</span>
        <span class="s1">col = np.tile(offset_inds</span><span class="s3">, </span><span class="s1">num_offsets)[mask.ravel()]</span>
        <span class="s1">data = self.data[mask]</span>
        <span class="s4"># Note: this cannot set has_canonical_format=True, because despite the</span>
        <span class="s4"># lack of duplicates, we do not generate sorted indices.</span>
        <span class="s3">return </span><span class="s1">self._coo_container(</span>
            <span class="s1">(data</span><span class="s3">, </span><span class="s1">(row</span><span class="s3">, </span><span class="s1">col))</span><span class="s3">, </span><span class="s1">shape=self.shape</span><span class="s3">, </span><span class="s1">dtype=self.dtype</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span>
        <span class="s1">)</span>

    <span class="s1">tocoo.__doc__ = _spbase.tocoo.__doc__</span>

    <span class="s4"># needed by _data_matrix</span>
    <span class="s3">def </span><span class="s1">_with_data(self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Returns a matrix with the same sparsity structure as self, 
        but with different data.  By default the structure arrays are copied. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">copy:</span>
            <span class="s3">return </span><span class="s1">self._dia_container(</span>
                <span class="s1">(data</span><span class="s3">, </span><span class="s1">self.offsets.copy())</span><span class="s3">, </span><span class="s1">shape=self.shape</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self._dia_container(</span>
                <span class="s1">(data</span><span class="s3">, </span><span class="s1">self.offsets)</span><span class="s3">, </span><span class="s1">shape=self.shape</span>
            <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">resize(self</span><span class="s3">, </span><span class="s1">*shape):</span>
        <span class="s1">shape = check_shape(shape)</span>
        <span class="s1">M</span><span class="s3">, </span><span class="s1">N = shape</span>
        <span class="s4"># we do not need to handle the case of expanding N</span>
        <span class="s1">self.data = self.data[:</span><span class="s3">, </span><span class="s1">:N]</span>

        <span class="s3">if </span><span class="s1">(M &gt; self.shape[</span><span class="s5">0</span><span class="s1">] </span><span class="s3">and</span>
                <span class="s1">np.any(self.offsets + self.shape[</span><span class="s5">0</span><span class="s1">] &lt; self.data.shape[</span><span class="s5">1</span><span class="s1">])):</span>
            <span class="s4"># explicitly clear values that were previously hidden</span>
            <span class="s1">mask = (self.offsets[:</span><span class="s3">, None</span><span class="s1">] + self.shape[</span><span class="s5">0</span><span class="s1">] &lt;=</span>
                    <span class="s1">np.arange(self.data.shape[</span><span class="s5">1</span><span class="s1">]))</span>
            <span class="s1">self.data[mask] = </span><span class="s5">0</span>

        <span class="s1">self._shape = shape</span>

    <span class="s1">resize.__doc__ = _spbase.resize.__doc__</span>


<span class="s3">def </span><span class="s1">isspmatrix_dia(x):</span>
    <span class="s0">&quot;&quot;&quot;Is `x` of dia_matrix type? 
 
    Parameters 
    ---------- 
    x 
        object to check for being a dia matrix 
 
    Returns 
    ------- 
    bool 
        True if `x` is a dia matrix, False otherwise 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.sparse import dia_array, dia_matrix, coo_matrix, isspmatrix_dia 
    &gt;&gt;&gt; isspmatrix_dia(dia_matrix([[5]])) 
    True 
    &gt;&gt;&gt; isspmatrix_dia(dia_array([[5]])) 
    False 
    &gt;&gt;&gt; isspmatrix_dia(coo_matrix([[5]])) 
    False 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">isinstance(x</span><span class="s3">, </span><span class="s1">dia_matrix)</span>


<span class="s4"># This namespace class separates array from matrix with isinstance</span>
<span class="s3">class </span><span class="s1">dia_array(_dia_base</span><span class="s3">, </span><span class="s1">sparray):</span>
    <span class="s3">pass</span>

<span class="s1">dia_array.__doc__ = _dia_base.__doc__</span>

<span class="s3">class </span><span class="s1">dia_matrix(spmatrix</span><span class="s3">, </span><span class="s1">_dia_base):</span>
    <span class="s3">pass</span>

<span class="s1">dia_matrix.__doc__ = _array_doc_to_matrix(_dia_base.__doc__)</span>
</pre>
</body>
</html>