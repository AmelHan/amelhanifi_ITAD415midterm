<html>
<head>
<title>summary2.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
summary2.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">statsmodels.compat.python </span><span class="s0">import </span><span class="s1">lzip</span>

<span class="s0">import </span><span class="s1">datetime</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">reduce</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">import </span><span class="s1">textwrap</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>

<span class="s0">from </span><span class="s1">.table </span><span class="s0">import </span><span class="s1">SimpleTable</span>
<span class="s0">from </span><span class="s1">.tableformatting </span><span class="s0">import </span><span class="s1">fmt_latex</span><span class="s0">, </span><span class="s1">fmt_txt</span>


<span class="s0">class </span><span class="s1">Summary:</span>
    <span class="s0">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self.tables = []</span>
        <span class="s1">self.settings = []</span>
        <span class="s1">self.extra_txt = []</span>
        <span class="s1">self.title = </span><span class="s0">None</span>
        <span class="s1">self._merge_latex = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">__str__(self):</span>
        <span class="s0">return </span><span class="s1">self.as_text()</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s1">str(type(self)) + </span><span class="s2">'</span><span class="s0">\n</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\n</span><span class="s2">' </span><span class="s1">+ self.__str__() + </span><span class="s2">'</span><span class="s0">\n</span><span class="s2">&quot;&quot;&quot;'</span>

    <span class="s0">def </span><span class="s1">_repr_html_(self):</span>
        <span class="s3">&quot;&quot;&quot;Display as HTML in IPython notebook.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.as_html()</span>

    <span class="s0">def </span><span class="s1">_repr_latex_(self):</span>
        <span class="s3">'''Display as LaTeX when converting IPython notebook to PDF.'''</span>
        <span class="s0">return </span><span class="s1">self.as_latex()</span>

    <span class="s0">def </span><span class="s1">add_df(self</span><span class="s0">, </span><span class="s1">df</span><span class="s0">, </span><span class="s1">index=</span><span class="s0">True, </span><span class="s1">header=</span><span class="s0">True, </span><span class="s1">float_format=</span><span class="s2">'%.4f'</span><span class="s0">,</span>
               <span class="s1">align=</span><span class="s2">'r'</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Add the contents of a DataFrame to summary table 
 
        Parameters 
        ---------- 
        df : DataFrame 
        header : bool 
            Reproduce the DataFrame column labels in summary table 
        index : bool 
            Reproduce the DataFrame row labels in summary table 
        float_format : str 
            Formatting to float data columns 
        align : str 
            Data alignment (l/c/r) 
        &quot;&quot;&quot;</span>

        <span class="s1">settings = {</span><span class="s2">'index'</span><span class="s1">: index</span><span class="s0">, </span><span class="s2">'header'</span><span class="s1">: header</span><span class="s0">,</span>
                    <span class="s2">'float_format'</span><span class="s1">: float_format</span><span class="s0">, </span><span class="s2">'align'</span><span class="s1">: align}</span>
        <span class="s1">self.tables.append(df)</span>
        <span class="s1">self.settings.append(settings)</span>

    <span class="s0">def </span><span class="s1">add_array(self</span><span class="s0">, </span><span class="s1">array</span><span class="s0">, </span><span class="s1">align=</span><span class="s2">'r'</span><span class="s0">, </span><span class="s1">float_format=</span><span class="s2">&quot;%.4f&quot;</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Add the contents of a Numpy array to summary table 
 
        Parameters 
        ---------- 
        array : numpy array (2D) 
        float_format : str 
            Formatting to array if type is float 
        align : str 
            Data alignment (l/c/r) 
        &quot;&quot;&quot;</span>

        <span class="s1">table = pd.DataFrame(array)</span>
        <span class="s1">self.add_df(table</span><span class="s0">, </span><span class="s1">index=</span><span class="s0">False, </span><span class="s1">header=</span><span class="s0">False,</span>
                    <span class="s1">float_format=float_format</span><span class="s0">, </span><span class="s1">align=align)</span>

    <span class="s0">def </span><span class="s1">add_dict(self</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">ncols=</span><span class="s4">2</span><span class="s0">, </span><span class="s1">align=</span><span class="s2">'l'</span><span class="s0">, </span><span class="s1">float_format=</span><span class="s2">&quot;%.4f&quot;</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Add the contents of a Dict to summary table 
 
        Parameters 
        ---------- 
        d : dict 
            Keys and values are automatically coerced to strings with str(). 
            Users are encouraged to format them before using add_dict. 
        ncols : int 
            Number of columns of the output table 
        align : str 
            Data alignment (l/c/r) 
        float_format : str 
            Formatting to float data columns 
        &quot;&quot;&quot;</span>

        <span class="s1">keys = [_formatter(x</span><span class="s0">, </span><span class="s1">float_format) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">d.keys()]</span>
        <span class="s1">vals = [_formatter(x</span><span class="s0">, </span><span class="s1">float_format) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">d.values()]</span>
        <span class="s1">data = np.array(lzip(keys</span><span class="s0">, </span><span class="s1">vals))</span>

        <span class="s0">if </span><span class="s1">data.shape[</span><span class="s4">0</span><span class="s1">] % ncols != </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">pad = ncols - (data.shape[</span><span class="s4">0</span><span class="s1">] % ncols)</span>
            <span class="s1">data = np.vstack([data</span><span class="s0">, </span><span class="s1">np.array(pad * [[</span><span class="s2">''</span><span class="s0">, </span><span class="s2">''</span><span class="s1">]])])</span>

        <span class="s1">data = np.split(data</span><span class="s0">, </span><span class="s1">ncols)</span>
        <span class="s1">data = reduce(</span><span class="s0">lambda </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y: np.hstack([x</span><span class="s0">, </span><span class="s1">y])</span><span class="s0">, </span><span class="s1">data)</span>
        <span class="s1">self.add_array(data</span><span class="s0">, </span><span class="s1">align=align)</span>

    <span class="s0">def </span><span class="s1">add_text(self</span><span class="s0">, </span><span class="s1">string):</span>
        <span class="s3">&quot;&quot;&quot;Append a note to the bottom of the summary table. In ASCII tables, 
        the note will be wrapped to table width. Notes are not indented. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.extra_txt.append(string)</span>

    <span class="s0">def </span><span class="s1">add_title(self</span><span class="s0">, </span><span class="s1">title=</span><span class="s0">None, </span><span class="s1">results=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Insert a title on top of the summary table. If a string is provided 
        in the title argument, that string is printed. If no title string is 
        provided but a results instance is provided, statsmodels attempts 
        to construct a useful title automatically. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(title</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s1">self.title = title</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">results </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">model = results.model.__class__.__name__</span>
                <span class="s0">if </span><span class="s1">model </span><span class="s0">in </span><span class="s1">_model_types:</span>
                    <span class="s1">model = _model_types[model]</span>
                <span class="s1">self.title = </span><span class="s2">'Results: ' </span><span class="s1">+ model</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.title = </span><span class="s2">''</span>

    <span class="s0">def </span><span class="s1">add_base(self</span><span class="s0">, </span><span class="s1">results</span><span class="s0">, </span><span class="s1">alpha=</span><span class="s4">0.05</span><span class="s0">, </span><span class="s1">float_format=</span><span class="s2">&quot;%.4f&quot;</span><span class="s0">, </span><span class="s1">title=</span><span class="s0">None,</span>
                 <span class="s1">xname=</span><span class="s0">None, </span><span class="s1">yname=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Try to construct a basic summary instance. 
 
        Parameters 
        ---------- 
        results : Model results instance 
        alpha : float 
            significance level for the confidence intervals (optional) 
        float_format: str 
            Float formatting for summary of parameters (optional) 
        title : str 
            Title of the summary table (optional) 
        xname : list[str] of length equal to the number of parameters 
            Names of the independent variables (optional) 
        yname : str 
            Name of the dependent variable (optional) 
        &quot;&quot;&quot;</span>

        <span class="s1">param = summary_params(results</span><span class="s0">, </span><span class="s1">alpha=alpha</span><span class="s0">, </span><span class="s1">use_t=results.use_t)</span>
        <span class="s1">info = summary_model(results)</span>
        <span class="s0">if </span><span class="s1">xname </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">param.index = xname</span>
        <span class="s0">if </span><span class="s1">yname </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">info[</span><span class="s2">'Dependent Variable:'</span><span class="s1">] = yname</span>
        <span class="s1">self.add_dict(info</span><span class="s0">, </span><span class="s1">align=</span><span class="s2">'l'</span><span class="s1">)</span>
        <span class="s1">self.add_df(param</span><span class="s0">, </span><span class="s1">float_format=float_format)</span>
        <span class="s1">self.add_title(title=title</span><span class="s0">, </span><span class="s1">results=results)</span>

    <span class="s0">def </span><span class="s1">as_text(self):</span>
        <span class="s3">&quot;&quot;&quot;Generate ASCII Summary Table 
        &quot;&quot;&quot;</span>

        <span class="s1">tables = self.tables</span>
        <span class="s1">settings = self.settings</span>
        <span class="s1">title = self.title</span>
        <span class="s1">extra_txt = self.extra_txt</span>

        <span class="s1">pad_col</span><span class="s0">, </span><span class="s1">pad_index</span><span class="s0">, </span><span class="s1">widest = _measure_tables(tables</span><span class="s0">, </span><span class="s1">settings)</span>

        <span class="s1">rule_equal = widest * </span><span class="s2">'='</span>

        <span class="s1">simple_tables = _simple_tables(tables</span><span class="s0">, </span><span class="s1">settings</span><span class="s0">, </span><span class="s1">pad_col</span><span class="s0">, </span><span class="s1">pad_index)</span>
        <span class="s1">tab = [x.as_text() </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">simple_tables]</span>

        <span class="s1">tab = </span><span class="s2">'</span><span class="s0">\n</span><span class="s2">'</span><span class="s1">.join(tab)</span>
        <span class="s1">tab = tab.split(</span><span class="s2">'</span><span class="s0">\n</span><span class="s2">'</span><span class="s1">)</span>
        <span class="s1">tab[</span><span class="s4">0</span><span class="s1">] = rule_equal</span>
        <span class="s1">tab.append(rule_equal)</span>
        <span class="s1">tab = </span><span class="s2">'</span><span class="s0">\n</span><span class="s2">'</span><span class="s1">.join(tab)</span>

        <span class="s0">if </span><span class="s1">title </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">title = title</span>
            <span class="s0">if </span><span class="s1">len(title) &lt; widest:</span>
                <span class="s1">title = </span><span class="s2">' ' </span><span class="s1">* int(widest / </span><span class="s4">2 </span><span class="s1">- len(title) / </span><span class="s4">2</span><span class="s1">) + title</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">title = </span><span class="s2">''</span>

        <span class="s1">txt = [textwrap.wrap(x</span><span class="s0">, </span><span class="s1">widest) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">extra_txt]</span>
        <span class="s1">txt = [</span><span class="s2">'</span><span class="s0">\n</span><span class="s2">'</span><span class="s1">.join(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">txt]</span>
        <span class="s1">txt = </span><span class="s2">'</span><span class="s0">\n</span><span class="s2">'</span><span class="s1">.join(txt)</span>

        <span class="s1">out = </span><span class="s2">'</span><span class="s0">\n</span><span class="s2">'</span><span class="s1">.join([title</span><span class="s0">, </span><span class="s1">tab</span><span class="s0">, </span><span class="s1">txt])</span>

        <span class="s0">return </span><span class="s1">out</span>

    <span class="s0">def </span><span class="s1">as_html(self):</span>
        <span class="s3">&quot;&quot;&quot;Generate HTML Summary Table 
        &quot;&quot;&quot;</span>

        <span class="s1">tables = self.tables</span>
        <span class="s1">settings = self.settings</span>

        <span class="s1">simple_tables = _simple_tables(tables</span><span class="s0">, </span><span class="s1">settings)</span>
        <span class="s1">tab = [x.as_html() </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">simple_tables]</span>
        <span class="s1">tab = </span><span class="s2">'</span><span class="s0">\n</span><span class="s2">'</span><span class="s1">.join(tab)</span>

        <span class="s1">temp_txt = [st.replace(</span><span class="s2">'</span><span class="s0">\n</span><span class="s2">'</span><span class="s0">, </span><span class="s2">'&lt;br/&gt;</span><span class="s0">\n</span><span class="s2">'</span><span class="s1">)</span><span class="s0">for </span><span class="s1">st </span><span class="s0">in </span><span class="s1">self.extra_txt]</span>
        <span class="s1">txt = </span><span class="s2">'&lt;br/&gt;</span><span class="s0">\n</span><span class="s2">'</span><span class="s1">.join(temp_txt)</span>

        <span class="s1">out = </span><span class="s2">'&lt;br/&gt;</span><span class="s0">\n</span><span class="s2">'</span><span class="s1">.join([tab</span><span class="s0">, </span><span class="s1">txt])</span>

        <span class="s0">return </span><span class="s1">out</span>

    <span class="s0">def </span><span class="s1">as_latex(self</span><span class="s0">, </span><span class="s1">label=</span><span class="s2">''</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Generate LaTeX Summary Table 
 
        Parameters 
        ---------- 
        label : str 
            Label of the summary table that can be referenced 
            in a latex document (optional) 
        &quot;&quot;&quot;</span>
        <span class="s1">tables = self.tables</span>
        <span class="s1">settings = self.settings</span>
        <span class="s1">title = self.title</span>

        <span class="s0">if </span><span class="s1">title </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">title = </span><span class="s2">'</span><span class="s0">\\</span><span class="s2">caption{' </span><span class="s1">+ title + </span><span class="s2">'}'</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">title = </span><span class="s2">'</span><span class="s0">\\</span><span class="s2">caption{}'</span>

        <span class="s1">label = </span><span class="s2">'</span><span class="s0">\\</span><span class="s2">label{' </span><span class="s1">+ label + </span><span class="s2">'}'</span>

        <span class="s1">simple_tables = _simple_tables(tables</span><span class="s0">, </span><span class="s1">settings)</span>
        <span class="s1">tab = [x.as_latex_tabular() </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">simple_tables]</span>
        <span class="s1">tab = </span><span class="s2">'</span><span class="s0">\n\n</span><span class="s2">'</span><span class="s1">.join(tab)</span>

        <span class="s1">to_replace = (</span><span class="s2">'</span><span class="s0">\\\\</span><span class="s2">hline</span><span class="s0">\\</span><span class="s2">n</span><span class="s0">\\\\</span><span class="s2">hline</span><span class="s0">\\</span><span class="s2">n</span><span class="s0">\\\\</span><span class="s2">'</span>
                      <span class="s2">'end{tabular}</span><span class="s0">\\</span><span class="s2">n</span><span class="s0">\\\\</span><span class="s2">begin{tabular}{.*}</span><span class="s0">\\</span><span class="s2">n'</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">self._merge_latex:</span>
            <span class="s5"># create single tabular object for summary_col</span>
            <span class="s1">tab = re.sub(to_replace</span><span class="s0">, </span><span class="s2">r'\\midrule\n'</span><span class="s0">, </span><span class="s1">tab)</span>

        <span class="s1">non_captioned = </span><span class="s2">'</span><span class="s0">\\</span><span class="s2">begin{table}'</span><span class="s0">, </span><span class="s1">title</span><span class="s0">, </span><span class="s1">label</span><span class="s0">, </span><span class="s1">tab</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\\</span><span class="s2">end{table}'</span>
        <span class="s1">non_captioned = </span><span class="s2">'</span><span class="s0">\n</span><span class="s2">'</span><span class="s1">.join(non_captioned)</span>

        <span class="s1">txt = </span><span class="s2">' </span><span class="s0">\\</span><span class="s2">newline </span><span class="s0">\n</span><span class="s2">'</span><span class="s1">.join(self.extra_txt)</span>
        <span class="s1">out = non_captioned + </span><span class="s2">'</span><span class="s0">\n\\</span><span class="s2">bigskip</span><span class="s0">\n</span><span class="s2">' </span><span class="s1">+ txt</span>

        <span class="s0">return </span><span class="s1">out</span>


<span class="s0">def </span><span class="s1">_measure_tables(tables</span><span class="s0">, </span><span class="s1">settings):</span>
    <span class="s3">&quot;&quot;&quot;Compare width of ascii tables in a list and calculate padding values. 
    We add space to each col_sep to get us as close as possible to the 
    width of the largest table. Then, we add a few spaces to the first 
    column to pad the rest. 
    &quot;&quot;&quot;</span>

    <span class="s1">simple_tables = _simple_tables(tables</span><span class="s0">, </span><span class="s1">settings)</span>
    <span class="s1">tab = [x.as_text() </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">simple_tables]</span>

    <span class="s1">length = [len(x.splitlines()[</span><span class="s4">0</span><span class="s1">]) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">tab]</span>
    <span class="s1">len_max = max(length)</span>
    <span class="s1">pad_sep = []</span>
    <span class="s1">pad_index = []</span>

    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(tab)):</span>
        <span class="s1">nsep = max(tables[i].shape[</span><span class="s4">1</span><span class="s1">] - </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">pad = int((len_max - length[i]) / nsep)</span>
        <span class="s1">pad_sep.append(pad)</span>
        <span class="s1">len_new = length[i] + nsep * pad</span>
        <span class="s1">pad_index.append(len_max - len_new)</span>

    <span class="s0">return </span><span class="s1">pad_sep</span><span class="s0">, </span><span class="s1">pad_index</span><span class="s0">, </span><span class="s1">max(length)</span>


<span class="s5"># Useful stuff  # TODO: be more specific</span>
<span class="s1">_model_types = {</span><span class="s2">'OLS'</span><span class="s1">: </span><span class="s2">'Ordinary least squares'</span><span class="s0">,</span>
                <span class="s2">'GLS'</span><span class="s1">: </span><span class="s2">'Generalized least squares'</span><span class="s0">,</span>
                <span class="s2">'GLSAR'</span><span class="s1">: </span><span class="s2">'Generalized least squares with AR(p)'</span><span class="s0">,</span>
                <span class="s2">'WLS'</span><span class="s1">: </span><span class="s2">'Weighted least squares'</span><span class="s0">,</span>
                <span class="s2">'RLM'</span><span class="s1">: </span><span class="s2">'Robust linear model'</span><span class="s0">,</span>
                <span class="s2">'NBin'</span><span class="s1">: </span><span class="s2">'Negative binomial model'</span><span class="s0">,</span>
                <span class="s2">'GLM'</span><span class="s1">: </span><span class="s2">'Generalized linear model'</span>
                <span class="s1">}</span>


<span class="s0">def </span><span class="s1">summary_model(results):</span>
    <span class="s3">&quot;&quot;&quot; 
    Create a dict with information about the model 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">time_now(*args</span><span class="s0">, </span><span class="s1">**kwds):</span>
        <span class="s1">now = datetime.datetime.now()</span>
        <span class="s0">return </span><span class="s1">now.strftime(</span><span class="s2">'%Y-%m-%d %H:%M'</span><span class="s1">)</span>

    <span class="s1">info = {}</span>
    <span class="s1">info[</span><span class="s2">'Model:'</span><span class="s1">] = </span><span class="s0">lambda </span><span class="s1">x: x.model.__class__.__name__</span>
    <span class="s1">info[</span><span class="s2">'Model Family:'</span><span class="s1">] = </span><span class="s0">lambda </span><span class="s1">x: x.family.__class.__name__</span>
    <span class="s1">info[</span><span class="s2">'Link Function:'</span><span class="s1">] = </span><span class="s0">lambda </span><span class="s1">x: x.family.link.__class__.__name__</span>
    <span class="s1">info[</span><span class="s2">'Dependent Variable:'</span><span class="s1">] = </span><span class="s0">lambda </span><span class="s1">x: x.model.endog_names</span>
    <span class="s1">info[</span><span class="s2">'Date:'</span><span class="s1">] = time_now</span>
    <span class="s1">info[</span><span class="s2">'No. Observations:'</span><span class="s1">] = </span><span class="s0">lambda </span><span class="s1">x: </span><span class="s2">&quot;%#6d&quot; </span><span class="s1">% x.nobs</span>
    <span class="s1">info[</span><span class="s2">'Df Model:'</span><span class="s1">] = </span><span class="s0">lambda </span><span class="s1">x: </span><span class="s2">&quot;%#6d&quot; </span><span class="s1">% x.df_model</span>
    <span class="s1">info[</span><span class="s2">'Df Residuals:'</span><span class="s1">] = </span><span class="s0">lambda </span><span class="s1">x: </span><span class="s2">&quot;%#6d&quot; </span><span class="s1">% x.df_resid</span>
    <span class="s1">info[</span><span class="s2">'Converged:'</span><span class="s1">] = </span><span class="s0">lambda </span><span class="s1">x: x.mle_retvals[</span><span class="s2">'converged'</span><span class="s1">]</span>
    <span class="s1">info[</span><span class="s2">'No. Iterations:'</span><span class="s1">] = </span><span class="s0">lambda </span><span class="s1">x: x.mle_retvals[</span><span class="s2">'iterations'</span><span class="s1">]</span>
    <span class="s1">info[</span><span class="s2">'Method:'</span><span class="s1">] = </span><span class="s0">lambda </span><span class="s1">x: x.method</span>
    <span class="s1">info[</span><span class="s2">'Norm:'</span><span class="s1">] = </span><span class="s0">lambda </span><span class="s1">x: x.fit_options[</span><span class="s2">'norm'</span><span class="s1">]</span>
    <span class="s1">info[</span><span class="s2">'Scale Est.:'</span><span class="s1">] = </span><span class="s0">lambda </span><span class="s1">x: x.fit_options[</span><span class="s2">'scale_est'</span><span class="s1">]</span>
    <span class="s1">info[</span><span class="s2">'Cov. Type:'</span><span class="s1">] = </span><span class="s0">lambda </span><span class="s1">x: x.fit_options[</span><span class="s2">'cov'</span><span class="s1">]</span>

    <span class="s1">rsquared_type = </span><span class="s2">'' </span><span class="s0">if </span><span class="s1">results.k_constant </span><span class="s0">else </span><span class="s2">' (uncentered)'</span>
    <span class="s1">info[</span><span class="s2">'R-squared' </span><span class="s1">+ rsquared_type + </span><span class="s2">':'</span><span class="s1">] = </span><span class="s0">lambda </span><span class="s1">x: </span><span class="s2">&quot;%#8.3f&quot; </span><span class="s1">% x.rsquared</span>
    <span class="s1">info[</span><span class="s2">'Adj. R-squared' </span><span class="s1">+ rsquared_type + </span><span class="s2">':'</span><span class="s1">] = </span><span class="s0">lambda </span><span class="s1">x: </span><span class="s2">&quot;%#8.3f&quot; </span><span class="s1">% x.rsquared_adj  </span><span class="s5"># noqa:E501</span>
    <span class="s1">info[</span><span class="s2">'Pseudo R-squared:'</span><span class="s1">] = </span><span class="s0">lambda </span><span class="s1">x: </span><span class="s2">&quot;%#8.3f&quot; </span><span class="s1">% x.prsquared</span>
    <span class="s1">info[</span><span class="s2">'AIC:'</span><span class="s1">] = </span><span class="s0">lambda </span><span class="s1">x: </span><span class="s2">&quot;%8.4f&quot; </span><span class="s1">% x.aic</span>
    <span class="s1">info[</span><span class="s2">'BIC:'</span><span class="s1">] = </span><span class="s0">lambda </span><span class="s1">x: </span><span class="s2">&quot;%8.4f&quot; </span><span class="s1">% x.bic</span>
    <span class="s1">info[</span><span class="s2">'Log-Likelihood:'</span><span class="s1">] = </span><span class="s0">lambda </span><span class="s1">x: </span><span class="s2">&quot;%#8.5g&quot; </span><span class="s1">% x.llf</span>
    <span class="s1">info[</span><span class="s2">'LL-Null:'</span><span class="s1">] = </span><span class="s0">lambda </span><span class="s1">x: </span><span class="s2">&quot;%#8.5g&quot; </span><span class="s1">% x.llnull</span>
    <span class="s1">info[</span><span class="s2">'LLR p-value:'</span><span class="s1">] = </span><span class="s0">lambda </span><span class="s1">x: </span><span class="s2">&quot;%#8.5g&quot; </span><span class="s1">% x.llr_pvalue</span>
    <span class="s1">info[</span><span class="s2">'Deviance:'</span><span class="s1">] = </span><span class="s0">lambda </span><span class="s1">x: </span><span class="s2">&quot;%#8.5g&quot; </span><span class="s1">% x.deviance</span>
    <span class="s1">info[</span><span class="s2">'Pearson chi2:'</span><span class="s1">] = </span><span class="s0">lambda </span><span class="s1">x: </span><span class="s2">&quot;%#6.3g&quot; </span><span class="s1">% x.pearson_chi2</span>
    <span class="s1">info[</span><span class="s2">'F-statistic:'</span><span class="s1">] = </span><span class="s0">lambda </span><span class="s1">x: </span><span class="s2">&quot;%#8.4g&quot; </span><span class="s1">% x.fvalue</span>
    <span class="s1">info[</span><span class="s2">'Prob (F-statistic):'</span><span class="s1">] = </span><span class="s0">lambda </span><span class="s1">x: </span><span class="s2">&quot;%#6.3g&quot; </span><span class="s1">% x.f_pvalue</span>
    <span class="s1">info[</span><span class="s2">'Scale:'</span><span class="s1">] = </span><span class="s0">lambda </span><span class="s1">x: </span><span class="s2">&quot;%#8.5g&quot; </span><span class="s1">% x.scale</span>
    <span class="s1">out = {}</span>
    <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">func </span><span class="s0">in </span><span class="s1">info.items():</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">out[key] = func(results)</span>
        <span class="s0">except </span><span class="s1">(AttributeError</span><span class="s0">, </span><span class="s1">KeyError</span><span class="s0">, </span><span class="s1">NotImplementedError):</span>
            <span class="s5"># NOTE: some models do not have loglike defined (RLM),</span>
            <span class="s5">#   so raise NotImplementedError</span>
            <span class="s0">pass</span>
    <span class="s0">return </span><span class="s1">out</span>


<span class="s0">def </span><span class="s1">summary_params(results</span><span class="s0">, </span><span class="s1">yname=</span><span class="s0">None, </span><span class="s1">xname=</span><span class="s0">None, </span><span class="s1">alpha=</span><span class="s4">.05</span><span class="s0">, </span><span class="s1">use_t=</span><span class="s0">True,</span>
                   <span class="s1">skip_header=</span><span class="s0">False, </span><span class="s1">float_format=</span><span class="s2">&quot;%.4f&quot;</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;create a summary table of parameters from results instance 
 
    Parameters 
    ---------- 
    res : results instance 
        some required information is directly taken from the result 
        instance 
    yname : {str, None} 
        optional name for the endogenous variable, default is &quot;y&quot; 
    xname : {list[str], None} 
        optional names for the exogenous variables, default is &quot;var_xx&quot; 
    alpha : float 
        significance level for the confidence intervals 
    use_t : bool 
        indicator whether the p-values are based on the Student-t 
        distribution (if True) or on the normal distribution (if False) 
    skip_header : bool 
        If false (default), then the header row is added. If true, then no 
        header row is added. 
    float_format : str 
        float formatting options (e.g. &quot;.3g&quot;) 
 
    Returns 
    ------- 
    params_table : SimpleTable instance 
    &quot;&quot;&quot;</span>

    <span class="s0">if </span><span class="s1">isinstance(results</span><span class="s0">, </span><span class="s1">tuple):</span>
        <span class="s1">results</span><span class="s0">, </span><span class="s1">params</span><span class="s0">, </span><span class="s1">bse</span><span class="s0">, </span><span class="s1">tvalues</span><span class="s0">, </span><span class="s1">pvalues</span><span class="s0">, </span><span class="s1">conf_int = results</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">params = results.params</span>
        <span class="s1">bse = results.bse</span>
        <span class="s1">tvalues = results.tvalues</span>
        <span class="s1">pvalues = results.pvalues</span>
        <span class="s1">conf_int = results.conf_int(alpha)</span>

    <span class="s1">data = np.array([params</span><span class="s0">, </span><span class="s1">bse</span><span class="s0">, </span><span class="s1">tvalues</span><span class="s0">, </span><span class="s1">pvalues]).T</span>
    <span class="s1">data = np.hstack([data</span><span class="s0">, </span><span class="s1">conf_int])</span>
    <span class="s1">data = pd.DataFrame(data)</span>

    <span class="s0">if </span><span class="s1">use_t:</span>
        <span class="s1">data.columns = [</span><span class="s2">'Coef.'</span><span class="s0">, </span><span class="s2">'Std.Err.'</span><span class="s0">, </span><span class="s2">'t'</span><span class="s0">, </span><span class="s2">'P&gt;|t|'</span><span class="s0">,</span>
                        <span class="s2">'[' </span><span class="s1">+ str(alpha / </span><span class="s4">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">str(</span><span class="s4">1 </span><span class="s1">- alpha / </span><span class="s4">2</span><span class="s1">) + </span><span class="s2">']'</span><span class="s1">]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">data.columns = [</span><span class="s2">'Coef.'</span><span class="s0">, </span><span class="s2">'Std.Err.'</span><span class="s0">, </span><span class="s2">'z'</span><span class="s0">, </span><span class="s2">'P&gt;|z|'</span><span class="s0">,</span>
                        <span class="s2">'[' </span><span class="s1">+ str(alpha / </span><span class="s4">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">str(</span><span class="s4">1 </span><span class="s1">- alpha / </span><span class="s4">2</span><span class="s1">) + </span><span class="s2">']'</span><span class="s1">]</span>

    <span class="s0">if not </span><span class="s1">xname:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">data.index = results.model.data.param_names</span>
        <span class="s0">except </span><span class="s1">AttributeError:</span>
            <span class="s1">data.index = results.model.exog_names</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">data.index = xname</span>

    <span class="s0">return </span><span class="s1">data</span>


<span class="s5"># Vertical summary instance for multiple models</span>
<span class="s0">def </span><span class="s1">_col_params(result</span><span class="s0">, </span><span class="s1">float_format=</span><span class="s2">'%.4f'</span><span class="s0">, </span><span class="s1">stars=</span><span class="s0">True, </span><span class="s1">include_r2=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Stack coefficients and standard errors in single column 
    &quot;&quot;&quot;</span>

    <span class="s5"># Extract parameters</span>
    <span class="s1">res = summary_params(result)</span>
    <span class="s5"># Format float</span>
    <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">res.columns[:</span><span class="s4">2</span><span class="s1">]:</span>
        <span class="s1">res[col] = res[col].apply(</span><span class="s0">lambda </span><span class="s1">x: float_format % x)</span>
    <span class="s5"># Std.Errors in parentheses</span>
    <span class="s1">res.iloc[:</span><span class="s0">, </span><span class="s4">1</span><span class="s1">] = </span><span class="s2">'(' </span><span class="s1">+ res.iloc[:</span><span class="s0">, </span><span class="s4">1</span><span class="s1">] + </span><span class="s2">')'</span>
    <span class="s5"># Significance stars</span>
    <span class="s0">if </span><span class="s1">stars:</span>
        <span class="s1">idx = res.iloc[:</span><span class="s0">, </span><span class="s4">3</span><span class="s1">] &lt; </span><span class="s4">.1</span>
        <span class="s1">res.loc[idx</span><span class="s0">, </span><span class="s1">res.columns[</span><span class="s4">0</span><span class="s1">]] = res.loc[idx</span><span class="s0">, </span><span class="s1">res.columns[</span><span class="s4">0</span><span class="s1">]] + </span><span class="s2">'*'</span>
        <span class="s1">idx = res.iloc[:</span><span class="s0">, </span><span class="s4">3</span><span class="s1">] &lt; </span><span class="s4">.05</span>
        <span class="s1">res.loc[idx</span><span class="s0">, </span><span class="s1">res.columns[</span><span class="s4">0</span><span class="s1">]] = res.loc[idx</span><span class="s0">, </span><span class="s1">res.columns[</span><span class="s4">0</span><span class="s1">]] + </span><span class="s2">'*'</span>
        <span class="s1">idx = res.iloc[:</span><span class="s0">, </span><span class="s4">3</span><span class="s1">] &lt; </span><span class="s4">.01</span>
        <span class="s1">res.loc[idx</span><span class="s0">, </span><span class="s1">res.columns[</span><span class="s4">0</span><span class="s1">]] = res.loc[idx</span><span class="s0">, </span><span class="s1">res.columns[</span><span class="s4">0</span><span class="s1">]] + </span><span class="s2">'*'</span>
    <span class="s5"># Stack Coefs and Std.Errors</span>
    <span class="s1">res = res.iloc[:</span><span class="s0">, </span><span class="s1">:</span><span class="s4">2</span><span class="s1">]</span>
    <span class="s1">res = res.stack()</span>

    <span class="s5"># Add R-squared</span>
    <span class="s0">if </span><span class="s1">include_r2:</span>
        <span class="s1">rsquared = getattr(result</span><span class="s0">, </span><span class="s2">'rsquared'</span><span class="s0">, </span><span class="s1">np.nan)</span>
        <span class="s1">rsquared_adj = getattr(result</span><span class="s0">, </span><span class="s2">'rsquared_adj'</span><span class="s0">, </span><span class="s1">np.nan)</span>
        <span class="s1">r2 = pd.Series({(</span><span class="s2">'R-squared'</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">): rsquared</span><span class="s0">,</span>
                        <span class="s1">(</span><span class="s2">'R-squared Adj.'</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">): rsquared_adj})</span>

        <span class="s0">if </span><span class="s1">r2.notnull().any():</span>
            <span class="s1">r2 = r2.apply(</span><span class="s0">lambda </span><span class="s1">x: float_format % x)</span>
            <span class="s1">res = pd.concat([res</span><span class="s0">, </span><span class="s1">r2]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s1">res = pd.DataFrame(res)</span>
    <span class="s1">res.columns = [str(result.model.endog_names)]</span>
    <span class="s0">return </span><span class="s1">res</span>


<span class="s0">def </span><span class="s1">_col_info(result</span><span class="s0">, </span><span class="s1">info_dict=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Stack model info in a column 
    &quot;&quot;&quot;</span>

    <span class="s0">if </span><span class="s1">info_dict </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">info_dict = {}</span>
    <span class="s1">out = []</span>
    <span class="s1">index = []</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">info_dict:</span>
        <span class="s0">if </span><span class="s1">isinstance(info_dict[i]</span><span class="s0">, </span><span class="s1">dict):</span>
            <span class="s5"># this is a specific model info_dict, but not for this result...</span>
            <span class="s0">continue</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">out.append(info_dict[i](result))</span>
        <span class="s0">except </span><span class="s1">AttributeError:</span>
            <span class="s1">out.append(</span><span class="s2">''</span><span class="s1">)</span>
        <span class="s1">index.append(i)</span>
    <span class="s1">out = pd.DataFrame({str(result.model.endog_names): out}</span><span class="s0">, </span><span class="s1">index=index)</span>
    <span class="s0">return </span><span class="s1">out</span>


<span class="s0">def </span><span class="s1">_make_unique(list_of_names):</span>
    <span class="s0">if </span><span class="s1">len(set(list_of_names)) == len(list_of_names):</span>
        <span class="s0">return </span><span class="s1">list_of_names</span>
    <span class="s5"># pandas does not like it if multiple columns have the same names</span>
    <span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">defaultdict</span>
    <span class="s1">name_counter = defaultdict(str)</span>
    <span class="s1">header = []</span>
    <span class="s0">for </span><span class="s1">_name </span><span class="s0">in </span><span class="s1">list_of_names:</span>
        <span class="s1">name_counter[_name] += </span><span class="s2">&quot;I&quot;</span>
        <span class="s1">header.append(_name + </span><span class="s2">&quot; &quot; </span><span class="s1">+ name_counter[_name])</span>
    <span class="s0">return </span><span class="s1">header</span>


<span class="s0">def </span><span class="s1">summary_col(results</span><span class="s0">, </span><span class="s1">float_format=</span><span class="s2">'%.4f'</span><span class="s0">, </span><span class="s1">model_names=()</span><span class="s0">, </span><span class="s1">stars=</span><span class="s0">False,</span>
                <span class="s1">info_dict=</span><span class="s0">None, </span><span class="s1">regressor_order=()</span><span class="s0">, </span><span class="s1">drop_omitted=</span><span class="s0">False,</span>
                <span class="s1">include_r2=</span><span class="s0">True</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Summarize multiple results instances side-by-side (coefs and SEs) 
 
    Parameters 
    ---------- 
    results : statsmodels results instance or list of result instances 
    float_format : str, optional 
        float format for coefficients and standard errors 
        Default : '%.4f' 
    model_names : list[str], optional 
        Must have same length as the number of results. If the names are not 
        unique, a roman number will be appended to all model names 
    stars : bool 
        print significance stars 
    info_dict : dict, default None 
        dict of functions to be applied to results instances to retrieve 
        model info. To use specific information for different models, add a 
        (nested) info_dict with model name as the key. 
        Example: `info_dict = {&quot;N&quot;:lambda x:(x.nobs), &quot;R2&quot;: ..., &quot;OLS&quot;:{ 
        &quot;R2&quot;:...}}` would only show `R2` for OLS regression models, but 
        additionally `N` for all other results. 
        Default : None (use the info_dict specified in 
        result.default_model_infos, if this property exists) 
    regressor_order : list[str], optional 
        list of names of the regressors in the desired order. All regressors 
        not specified will be appended to the end of the list. 
    drop_omitted : bool, optional 
        Includes regressors that are not specified in regressor_order. If 
        False, regressors not specified will be appended to end of the list. 
        If True, only regressors in regressor_order will be included. 
    include_r2 : bool, optional 
        Includes R2 and adjusted R2 in the summary table. 
    &quot;&quot;&quot;</span>

    <span class="s0">if not </span><span class="s1">isinstance(results</span><span class="s0">, </span><span class="s1">list):</span>
        <span class="s1">results = [results]</span>

    <span class="s1">cols = [_col_params(x</span><span class="s0">, </span><span class="s1">stars=stars</span><span class="s0">, </span><span class="s1">float_format=float_format</span><span class="s0">,</span>
                        <span class="s1">include_r2=include_r2) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">results]</span>

    <span class="s5"># Unique column names (pandas has problems merging otherwise)</span>
    <span class="s0">if </span><span class="s1">model_names:</span>
        <span class="s1">colnames = _make_unique(model_names)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">colnames = _make_unique([x.columns[</span><span class="s4">0</span><span class="s1">] </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">cols])</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(cols)):</span>
        <span class="s1">cols[i].columns = [colnames[i]]</span>

    <span class="s0">def </span><span class="s1">merg(x</span><span class="s0">, </span><span class="s1">y):</span>
        <span class="s0">return </span><span class="s1">x.merge(y</span><span class="s0">, </span><span class="s1">how=</span><span class="s2">'outer'</span><span class="s0">, </span><span class="s1">right_index=</span><span class="s0">True,</span>
                       <span class="s1">left_index=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s1">summ = reduce(merg</span><span class="s0">, </span><span class="s1">cols)</span>

    <span class="s0">if </span><span class="s1">regressor_order:</span>
        <span class="s1">varnames = summ.index.get_level_values(</span><span class="s4">0</span><span class="s1">).tolist()</span>
        <span class="s1">vc = pd.Series(varnames).value_counts()</span>
        <span class="s1">varnames = vc.loc[vc == </span><span class="s4">2</span><span class="s1">].index.tolist()</span>
        <span class="s1">ordered = [x </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">regressor_order </span><span class="s0">if </span><span class="s1">x </span><span class="s0">in </span><span class="s1">varnames]</span>
        <span class="s1">unordered = [x </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">varnames </span><span class="s0">if </span><span class="s1">x </span><span class="s0">not in </span><span class="s1">regressor_order]</span>
        <span class="s1">new_order = ordered + unordered</span>
        <span class="s1">other = [x </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">summ.index.get_level_values(</span><span class="s4">0</span><span class="s1">)</span>
                 <span class="s0">if </span><span class="s1">x </span><span class="s0">not in </span><span class="s1">new_order]</span>
        <span class="s1">new_order += other</span>
        <span class="s0">if </span><span class="s1">drop_omitted:</span>
            <span class="s0">for </span><span class="s1">uo </span><span class="s0">in </span><span class="s1">unordered:</span>
                <span class="s1">new_order.remove(uo)</span>
        <span class="s1">summ = summ.loc[new_order]</span>

    <span class="s1">idx = []</span>
    <span class="s1">index = summ.index.get_level_values(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">index.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s4">2</span><span class="s1">):</span>
        <span class="s1">idx.append(index[i])</span>
        <span class="s0">if </span><span class="s1">(i + </span><span class="s4">1</span><span class="s1">) &lt; index.shape[</span><span class="s4">0</span><span class="s1">] </span><span class="s0">and </span><span class="s1">(index[i] == index[i + </span><span class="s4">1</span><span class="s1">]):</span>
            <span class="s1">idx.append(</span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">idx.append(index[i + </span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">summ.index = idx</span>

    <span class="s5"># add infos about the models.</span>
    <span class="s0">if </span><span class="s1">info_dict:</span>
        <span class="s1">cols = [_col_info(x</span><span class="s0">, </span><span class="s1">info_dict.get(x.model.__class__.__name__</span><span class="s0">,</span>
                                           <span class="s1">info_dict)) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">results]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">cols = [_col_info(x</span><span class="s0">, </span><span class="s1">getattr(x</span><span class="s0">, </span><span class="s2">&quot;default_model_infos&quot;</span><span class="s0">, None</span><span class="s1">)) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in</span>
                <span class="s1">results]</span>
    <span class="s5"># use unique column names, otherwise the merge will not succeed</span>
    <span class="s0">for </span><span class="s1">df</span><span class="s0">, </span><span class="s1">name </span><span class="s0">in </span><span class="s1">zip(cols</span><span class="s0">, </span><span class="s1">_make_unique([df.columns[</span><span class="s4">0</span><span class="s1">] </span><span class="s0">for </span><span class="s1">df </span><span class="s0">in </span><span class="s1">cols])):</span>
        <span class="s1">df.columns = [name]</span>

    <span class="s0">def </span><span class="s1">merg(x</span><span class="s0">, </span><span class="s1">y):</span>
        <span class="s0">return </span><span class="s1">x.merge(y</span><span class="s0">, </span><span class="s1">how=</span><span class="s2">'outer'</span><span class="s0">, </span><span class="s1">right_index=</span><span class="s0">True,</span>
                       <span class="s1">left_index=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s1">info = reduce(merg</span><span class="s0">, </span><span class="s1">cols)</span>
    <span class="s1">dat = pd.DataFrame(np.vstack([summ</span><span class="s0">, </span><span class="s1">info]))  </span><span class="s5"># pd.concat better, but error</span>
    <span class="s1">dat.columns = summ.columns</span>
    <span class="s1">dat.index = pd.Index(summ.index.tolist() + info.index.tolist())</span>
    <span class="s1">summ = dat</span>

    <span class="s1">summ = summ.fillna(</span><span class="s2">''</span><span class="s1">)</span>

    <span class="s1">smry = Summary()</span>
    <span class="s1">smry._merge_latex = </span><span class="s0">True</span>
    <span class="s1">smry.add_df(summ</span><span class="s0">, </span><span class="s1">header=</span><span class="s0">True, </span><span class="s1">align=</span><span class="s2">'l'</span><span class="s1">)</span>
    <span class="s1">smry.add_text(</span><span class="s2">'Standard errors in parentheses.'</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">stars:</span>
        <span class="s1">smry.add_text(</span><span class="s2">'* p&lt;.1, ** p&lt;.05, ***p&lt;.01'</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">smry</span>


<span class="s0">def </span><span class="s1">_formatter(element</span><span class="s0">, </span><span class="s1">float_format=</span><span class="s2">'%.4f'</span><span class="s1">):</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">out = float_format % element</span>
    <span class="s0">except </span><span class="s1">(ValueError</span><span class="s0">, </span><span class="s1">TypeError):</span>
        <span class="s1">out = str(element)</span>
    <span class="s0">return </span><span class="s1">out.strip()</span>


<span class="s0">def </span><span class="s1">_df_to_simpletable(df</span><span class="s0">, </span><span class="s1">align=</span><span class="s2">'r'</span><span class="s0">, </span><span class="s1">float_format=</span><span class="s2">&quot;%.4f&quot;</span><span class="s0">, </span><span class="s1">header=</span><span class="s0">True,</span>
                       <span class="s1">index=</span><span class="s0">True, </span><span class="s1">table_dec_above=</span><span class="s2">'-'</span><span class="s0">, </span><span class="s1">table_dec_below=</span><span class="s0">None,</span>
                       <span class="s1">header_dec_below=</span><span class="s2">'-'</span><span class="s0">, </span><span class="s1">pad_col=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">pad_index=</span><span class="s4">0</span><span class="s1">):</span>
    <span class="s1">dat = df.copy()</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">dat = dat.map(</span><span class="s0">lambda </span><span class="s1">x: _formatter(x</span><span class="s0">, </span><span class="s1">float_format))</span>
    <span class="s0">except </span><span class="s1">AttributeError:</span>
        <span class="s1">dat = dat.applymap(</span><span class="s0">lambda </span><span class="s1">x: _formatter(x</span><span class="s0">, </span><span class="s1">float_format))</span>
    <span class="s0">if </span><span class="s1">header:</span>
        <span class="s1">headers = [str(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">dat.columns.tolist()]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">headers = </span><span class="s0">None</span>
    <span class="s0">if </span><span class="s1">index:</span>
        <span class="s1">stubs = [str(x) + int(pad_index) * </span><span class="s2">' ' </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">dat.index.tolist()]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">dat.iloc[:</span><span class="s0">, </span><span class="s4">0</span><span class="s1">] = [str(x) + int(pad_index) * </span><span class="s2">' '</span>
                          <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">dat.iloc[:</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]]</span>
        <span class="s1">stubs = </span><span class="s0">None</span>
    <span class="s1">st = SimpleTable(np.array(dat)</span><span class="s0">, </span><span class="s1">headers=headers</span><span class="s0">, </span><span class="s1">stubs=stubs</span><span class="s0">,</span>
                     <span class="s1">ltx_fmt=fmt_latex</span><span class="s0">, </span><span class="s1">txt_fmt=fmt_txt)</span>
    <span class="s1">st.output_formats[</span><span class="s2">'latex'</span><span class="s1">][</span><span class="s2">'data_aligns'</span><span class="s1">] = align</span>
    <span class="s1">st.output_formats[</span><span class="s2">'latex'</span><span class="s1">][</span><span class="s2">'header_align'</span><span class="s1">] = align</span>
    <span class="s1">st.output_formats[</span><span class="s2">'txt'</span><span class="s1">][</span><span class="s2">'data_aligns'</span><span class="s1">] = align</span>
    <span class="s1">st.output_formats[</span><span class="s2">'txt'</span><span class="s1">][</span><span class="s2">'table_dec_above'</span><span class="s1">] = table_dec_above</span>
    <span class="s1">st.output_formats[</span><span class="s2">'txt'</span><span class="s1">][</span><span class="s2">'table_dec_below'</span><span class="s1">] = table_dec_below</span>
    <span class="s1">st.output_formats[</span><span class="s2">'txt'</span><span class="s1">][</span><span class="s2">'header_dec_below'</span><span class="s1">] = header_dec_below</span>
    <span class="s1">st.output_formats[</span><span class="s2">'txt'</span><span class="s1">][</span><span class="s2">'colsep'</span><span class="s1">] = </span><span class="s2">' ' </span><span class="s1">* int(pad_col + </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">st</span>


<span class="s0">def </span><span class="s1">_simple_tables(tables</span><span class="s0">, </span><span class="s1">settings</span><span class="s0">, </span><span class="s1">pad_col=</span><span class="s0">None, </span><span class="s1">pad_index=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s1">simple_tables = []</span>
    <span class="s1">float_format = settings[</span><span class="s4">0</span><span class="s1">][</span><span class="s2">'float_format'</span><span class="s1">] </span><span class="s0">if </span><span class="s1">settings </span><span class="s0">else </span><span class="s2">'%.4f'</span>
    <span class="s0">if </span><span class="s1">pad_col </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">pad_col = [</span><span class="s4">0</span><span class="s1">] * len(tables)</span>
    <span class="s0">if </span><span class="s1">pad_index </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">pad_index = [</span><span class="s4">0</span><span class="s1">] * len(tables)</span>
    <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">enumerate(tables):</span>
        <span class="s1">index = settings[i][</span><span class="s2">'index'</span><span class="s1">]</span>
        <span class="s1">header = settings[i][</span><span class="s2">'header'</span><span class="s1">]</span>
        <span class="s1">align = settings[i][</span><span class="s2">'align'</span><span class="s1">]</span>
        <span class="s1">simple_tables.append(_df_to_simpletable(v</span><span class="s0">, </span><span class="s1">align=align</span><span class="s0">,</span>
                                                <span class="s1">float_format=float_format</span><span class="s0">,</span>
                                                <span class="s1">header=header</span><span class="s0">, </span><span class="s1">index=index</span><span class="s0">,</span>
                                                <span class="s1">pad_col=pad_col[i]</span><span class="s0">,</span>
                                                <span class="s1">pad_index=pad_index[i]))</span>
    <span class="s0">return </span><span class="s1">simple_tables</span>
</pre>
</body>
</html>