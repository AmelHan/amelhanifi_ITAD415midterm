<html>
<head>
<title>test_ltisys.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_ltisys.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">abc </span><span class="s0">import </span><span class="s1">abstractmethod</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">(assert_almost_equal</span><span class="s0">, </span><span class="s1">assert_equal</span><span class="s0">, </span><span class="s1">assert_allclose</span><span class="s0">,</span>
                           <span class="s1">assert_</span><span class="s0">, </span><span class="s1">suppress_warnings)</span>
<span class="s0">from </span><span class="s1">pytest </span><span class="s0">import </span><span class="s1">raises </span><span class="s0">as </span><span class="s1">assert_raises</span>
<span class="s0">from </span><span class="s1">pytest </span><span class="s0">import </span><span class="s1">warns</span>

<span class="s0">from </span><span class="s1">scipy.signal </span><span class="s0">import </span><span class="s1">(ss2tf</span><span class="s0">, </span><span class="s1">tf2ss</span><span class="s0">, </span><span class="s1">lsim2</span><span class="s0">, </span><span class="s1">impulse2</span><span class="s0">, </span><span class="s1">step2</span><span class="s0">, </span><span class="s1">lti</span><span class="s0">,</span>
                          <span class="s1">dlti</span><span class="s0">, </span><span class="s1">bode</span><span class="s0">, </span><span class="s1">freqresp</span><span class="s0">, </span><span class="s1">lsim</span><span class="s0">, </span><span class="s1">impulse</span><span class="s0">, </span><span class="s1">step</span><span class="s0">,</span>
                          <span class="s1">abcd_normalize</span><span class="s0">, </span><span class="s1">place_poles</span><span class="s0">,</span>
                          <span class="s1">TransferFunction</span><span class="s0">, </span><span class="s1">StateSpace</span><span class="s0">, </span><span class="s1">ZerosPolesGain)</span>
<span class="s0">from </span><span class="s1">scipy.signal._filter_design </span><span class="s0">import </span><span class="s1">BadCoefficients</span>
<span class="s0">import </span><span class="s1">scipy.linalg </span><span class="s0">as </span><span class="s1">linalg</span>


<span class="s0">def </span><span class="s1">_assert_poles_close(P1</span><span class="s0">,</span><span class="s1">P2</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-8</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-8</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Check each pole in P1 is close to a pole in P2 with a 1e-8 
    relative tolerance or 1e-8 absolute tolerance (useful for zero poles). 
    These tolerances are very strict but the systems tested are known to 
    accept these poles so we should not be far from what is requested. 
    &quot;&quot;&quot;</span>
    <span class="s1">P2 = P2.copy()</span>
    <span class="s0">for </span><span class="s1">p1 </span><span class="s0">in </span><span class="s1">P1:</span>
        <span class="s1">found = </span><span class="s0">False</span>
        <span class="s0">for </span><span class="s1">p2_idx </span><span class="s0">in </span><span class="s1">range(P2.shape[</span><span class="s2">0</span><span class="s1">]):</span>
            <span class="s0">if </span><span class="s1">np.allclose([np.real(p1)</span><span class="s0">, </span><span class="s1">np.imag(p1)]</span><span class="s0">,</span>
                           <span class="s1">[np.real(P2[p2_idx])</span><span class="s0">, </span><span class="s1">np.imag(P2[p2_idx])]</span><span class="s0">,</span>
                           <span class="s1">rtol</span><span class="s0">, </span><span class="s1">atol):</span>
                <span class="s1">found = </span><span class="s0">True</span>
                <span class="s1">np.delete(P2</span><span class="s0">, </span><span class="s1">p2_idx)</span>
                <span class="s0">break</span>
        <span class="s0">if not </span><span class="s1">found:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Can't find pole &quot; </span><span class="s1">+ str(p1) + </span><span class="s4">&quot; in &quot; </span><span class="s1">+ str(P2))</span>


<span class="s0">class </span><span class="s1">TestPlacePoles:</span>

    <span class="s0">def </span><span class="s1">_check(self</span><span class="s0">, </span><span class="s1">A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">P</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot; 
        Perform the most common tests on the poles computed by place_poles 
        and return the Bunch object for further specific tests 
        &quot;&quot;&quot;</span>
        <span class="s1">fsf = place_poles(A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">P</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">expected</span><span class="s0">, </span><span class="s1">_ = np.linalg.eig(A - np.dot(B</span><span class="s0">, </span><span class="s1">fsf.gain_matrix))</span>
        <span class="s1">_assert_poles_close(expected</span><span class="s0">, </span><span class="s1">fsf.requested_poles)</span>
        <span class="s1">_assert_poles_close(expected</span><span class="s0">, </span><span class="s1">fsf.computed_poles)</span>
        <span class="s1">_assert_poles_close(P</span><span class="s0">,</span><span class="s1">fsf.requested_poles)</span>
        <span class="s0">return </span><span class="s1">fsf</span>

    <span class="s0">def </span><span class="s1">test_real(self):</span>
        <span class="s5"># Test real pole placement using KNV and YT0 algorithm and example 1 in</span>
        <span class="s5"># section 4 of the reference publication (see place_poles docstring)</span>
        <span class="s1">A = np.array([</span><span class="s2">1.380</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.2077</span><span class="s0">, </span><span class="s2">6.715</span><span class="s0">, </span><span class="s1">-</span><span class="s2">5.676</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.5814</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4.290</span><span class="s0">, </span><span class="s2">0</span><span class="s0">,</span>
                      <span class="s2">0.6750</span><span class="s0">, </span><span class="s2">1.067</span><span class="s0">, </span><span class="s2">4.273</span><span class="s0">, </span><span class="s1">-</span><span class="s2">6.654</span><span class="s0">, </span><span class="s2">5.893</span><span class="s0">, </span><span class="s2">0.0480</span><span class="s0">, </span><span class="s2">4.273</span><span class="s0">,</span>
                      <span class="s2">1.343</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2.104</span><span class="s1">]).reshape(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span>
        <span class="s1">B = np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">5.679</span><span class="s0">, </span><span class="s2">1.136</span><span class="s0">, </span><span class="s2">1.136</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3.146</span><span class="s0">,</span><span class="s2">0</span><span class="s1">]).reshape(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">P = np.array([-</span><span class="s2">0.2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">5.0566</span><span class="s0">, </span><span class="s1">-</span><span class="s2">8.6659</span><span class="s1">])</span>

        <span class="s5"># Check that both KNV and YT compute correct K matrix</span>
        <span class="s1">self._check(A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">P</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'KNV0'</span><span class="s1">)</span>
        <span class="s1">self._check(A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">P</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'YT'</span><span class="s1">)</span>

        <span class="s5"># Try to reach the specific case in _YT_real where two singular</span>
        <span class="s5"># values are almost equal. This is to improve code coverage but I</span>
        <span class="s5"># have no way to be sure this code is really reached</span>

        <span class="s5"># on some architectures this can lead to a RuntimeWarning invalid</span>
        <span class="s5"># value in divide (see gh-7590), so suppress it for now</span>
        <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s4">'ignore'</span><span class="s1">):</span>
            <span class="s1">self._check(A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">3</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_complex(self):</span>
        <span class="s5"># Test complex pole placement on a linearized car model, taken from L.</span>
        <span class="s5"># Jaulin, Automatique pour la robotique, Cours et Exercices, iSTE</span>
        <span class="s5"># editions p 184/185</span>
        <span class="s1">A = np.array([[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">7</span><span class="s1">/</span><span class="s2">3.</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]])</span>
        <span class="s1">B = np.array([[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]])</span>
        <span class="s5"># Test complex poles on YT</span>
        <span class="s1">P = np.array([-</span><span class="s2">3</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s1">-</span><span class="s2">1j</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s1">+</span><span class="s2">1j</span><span class="s1">])</span>
        <span class="s5"># on macOS arm64 this can lead to a RuntimeWarning invalid</span>
        <span class="s5"># value in divide, so suppress it for now</span>
        <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s4">'ignore'</span><span class="s0">, </span><span class="s1">invalid=</span><span class="s4">'ignore'</span><span class="s1">):</span>
            <span class="s1">self._check(A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">P)</span>

        <span class="s5"># Try to reach the specific case in _YT_complex where two singular</span>
        <span class="s5"># values are almost equal. This is to improve code coverage but I</span>
        <span class="s5"># have no way to be sure this code is really reached</span>

        <span class="s1">P = [</span><span class="s2">0</span><span class="s1">-</span><span class="s2">1e-6j</span><span class="s0">,</span><span class="s2">0</span><span class="s1">+</span><span class="s2">1e-6j</span><span class="s0">,</span><span class="s1">-</span><span class="s2">10</span><span class="s0">,</span><span class="s2">10</span><span class="s1">]</span>
        <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s4">'ignore'</span><span class="s0">, </span><span class="s1">invalid=</span><span class="s4">'ignore'</span><span class="s1">):</span>
            <span class="s1">self._check(A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">P</span><span class="s0">, </span><span class="s1">maxiter=</span><span class="s2">1000</span><span class="s1">)</span>

        <span class="s5"># Try to reach the specific case in _YT_complex where the rank two</span>
        <span class="s5"># update yields two null vectors. This test was found via Monte Carlo.</span>

        <span class="s1">A = np.array(</span>
                    <span class="s1">[-</span><span class="s2">2148</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2902</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2267</span><span class="s0">, </span><span class="s1">-</span><span class="s2">598</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1722</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1829</span><span class="s0">, </span><span class="s1">-</span><span class="s2">165</span><span class="s0">, </span><span class="s1">-</span><span class="s2">283</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2546</span><span class="s0">,</span>
                   <span class="s1">-</span><span class="s2">167</span><span class="s0">, </span><span class="s1">-</span><span class="s2">754</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2285</span><span class="s0">, </span><span class="s1">-</span><span class="s2">543</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1700</span><span class="s0">, </span><span class="s1">-</span><span class="s2">584</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2978</span><span class="s0">, </span><span class="s1">-</span><span class="s2">925</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1300</span><span class="s0">,</span>
                   <span class="s1">-</span><span class="s2">1583</span><span class="s0">, </span><span class="s1">-</span><span class="s2">984</span><span class="s0">, </span><span class="s1">-</span><span class="s2">386</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2650</span><span class="s0">, </span><span class="s1">-</span><span class="s2">764</span><span class="s0">, </span><span class="s1">-</span><span class="s2">897</span><span class="s0">, </span><span class="s1">-</span><span class="s2">517</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1598</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1709</span><span class="s0">,</span>
                   <span class="s1">-</span><span class="s2">291</span><span class="s0">, </span><span class="s1">-</span><span class="s2">338</span><span class="s0">, </span><span class="s1">-</span><span class="s2">153</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1804</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1106</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1168</span><span class="s0">, </span><span class="s1">-</span><span class="s2">867</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2297</span><span class="s1">]</span>
                   <span class="s1">).reshape(</span><span class="s2">6</span><span class="s0">,</span><span class="s2">6</span><span class="s1">)</span>

        <span class="s1">B = np.array(</span>
                    <span class="s1">[-</span><span class="s2">108</span><span class="s0">, </span><span class="s1">-</span><span class="s2">374</span><span class="s0">, </span><span class="s1">-</span><span class="s2">524</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1285</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1232</span><span class="s0">, </span><span class="s1">-</span><span class="s2">161</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1204</span><span class="s0">, </span><span class="s1">-</span><span class="s2">672</span><span class="s0">, </span><span class="s1">-</span><span class="s2">637</span><span class="s0">,</span>
                     <span class="s1">-</span><span class="s2">15</span><span class="s0">, </span><span class="s1">-</span><span class="s2">483</span><span class="s0">, </span><span class="s1">-</span><span class="s2">23</span><span class="s0">, </span><span class="s1">-</span><span class="s2">931</span><span class="s0">, </span><span class="s1">-</span><span class="s2">780</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1245</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1129</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1290</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1502</span><span class="s0">,</span>
                     <span class="s1">-</span><span class="s2">952</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1374</span><span class="s0">, </span><span class="s1">-</span><span class="s2">62</span><span class="s0">, </span><span class="s1">-</span><span class="s2">964</span><span class="s0">, </span><span class="s1">-</span><span class="s2">930</span><span class="s0">, </span><span class="s1">-</span><span class="s2">939</span><span class="s0">, </span><span class="s1">-</span><span class="s2">792</span><span class="s0">, </span><span class="s1">-</span><span class="s2">756</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1437</span><span class="s0">,</span>
                     <span class="s1">-</span><span class="s2">491</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1543</span><span class="s0">, </span><span class="s1">-</span><span class="s2">686</span><span class="s1">]</span>
                     <span class="s1">).reshape(</span><span class="s2">6</span><span class="s0">,</span><span class="s2">5</span><span class="s1">)</span>
        <span class="s1">P = [-</span><span class="s2">25.</span><span class="s1">-</span><span class="s2">29.j</span><span class="s0">, </span><span class="s1">-</span><span class="s2">25.</span><span class="s1">+</span><span class="s2">29.j</span><span class="s0">, </span><span class="s2">31.</span><span class="s1">-</span><span class="s2">42.j</span><span class="s0">, </span><span class="s2">31.</span><span class="s1">+</span><span class="s2">42.j</span><span class="s0">, </span><span class="s2">33.</span><span class="s1">-</span><span class="s2">41.j</span><span class="s0">, </span><span class="s2">33.</span><span class="s1">+</span><span class="s2">41.j</span><span class="s1">]</span>
        <span class="s1">self._check(A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">P)</span>

        <span class="s5"># Use a lot of poles to go through all cases for update_order</span>
        <span class="s5"># in _YT_loop</span>

        <span class="s1">big_A = np.ones((</span><span class="s2">11</span><span class="s0">,</span><span class="s2">11</span><span class="s1">))-np.eye(</span><span class="s2">11</span><span class="s1">)</span>
        <span class="s1">big_B = np.ones((</span><span class="s2">11</span><span class="s0">,</span><span class="s2">10</span><span class="s1">))-np.diag([</span><span class="s2">1</span><span class="s1">]*</span><span class="s2">10</span><span class="s0">,</span><span class="s2">1</span><span class="s1">)[:</span><span class="s0">,</span><span class="s2">1</span><span class="s1">:]</span>
        <span class="s1">big_A[:</span><span class="s2">6</span><span class="s0">,</span><span class="s1">:</span><span class="s2">6</span><span class="s1">] = A</span>
        <span class="s1">big_B[:</span><span class="s2">6</span><span class="s0">,</span><span class="s1">:</span><span class="s2">5</span><span class="s1">] = B</span>

        <span class="s1">P = [-</span><span class="s2">10</span><span class="s0">,</span><span class="s1">-</span><span class="s2">20</span><span class="s0">,</span><span class="s1">-</span><span class="s2">30</span><span class="s0">,</span><span class="s2">40</span><span class="s0">,</span><span class="s2">50</span><span class="s0">,</span><span class="s2">60</span><span class="s0">,</span><span class="s2">70</span><span class="s0">,</span><span class="s1">-</span><span class="s2">20</span><span class="s1">-</span><span class="s2">5j</span><span class="s0">,</span><span class="s1">-</span><span class="s2">20</span><span class="s1">+</span><span class="s2">5j</span><span class="s0">,</span><span class="s2">5</span><span class="s1">+</span><span class="s2">3j</span><span class="s0">,</span><span class="s2">5</span><span class="s1">-</span><span class="s2">3j</span><span class="s1">]</span>
        <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s4">'ignore'</span><span class="s0">, </span><span class="s1">invalid=</span><span class="s4">'ignore'</span><span class="s1">):</span>
            <span class="s1">self._check(big_A</span><span class="s0">, </span><span class="s1">big_B</span><span class="s0">, </span><span class="s1">P)</span>

        <span class="s5">#check with only complex poles and only real poles</span>
        <span class="s1">P = [-</span><span class="s2">10</span><span class="s0">,</span><span class="s1">-</span><span class="s2">20</span><span class="s0">,</span><span class="s1">-</span><span class="s2">30</span><span class="s0">,</span><span class="s1">-</span><span class="s2">40</span><span class="s0">,</span><span class="s1">-</span><span class="s2">50</span><span class="s0">,</span><span class="s1">-</span><span class="s2">60</span><span class="s0">,</span><span class="s1">-</span><span class="s2">70</span><span class="s0">,</span><span class="s1">-</span><span class="s2">80</span><span class="s0">,</span><span class="s1">-</span><span class="s2">90</span><span class="s0">,</span><span class="s1">-</span><span class="s2">100</span><span class="s1">]</span>
        <span class="s1">self._check(big_A[:-</span><span class="s2">1</span><span class="s0">,</span><span class="s1">:-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">big_B[:-</span><span class="s2">1</span><span class="s0">,</span><span class="s1">:-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">P)</span>
        <span class="s1">P = [-</span><span class="s2">10</span><span class="s1">+</span><span class="s2">10j</span><span class="s0">,</span><span class="s1">-</span><span class="s2">20</span><span class="s1">+</span><span class="s2">20j</span><span class="s0">,</span><span class="s1">-</span><span class="s2">30</span><span class="s1">+</span><span class="s2">30j</span><span class="s0">,</span><span class="s1">-</span><span class="s2">40</span><span class="s1">+</span><span class="s2">40j</span><span class="s0">,</span><span class="s1">-</span><span class="s2">50</span><span class="s1">+</span><span class="s2">50j</span><span class="s0">,</span>
             <span class="s1">-</span><span class="s2">10</span><span class="s1">-</span><span class="s2">10j</span><span class="s0">,</span><span class="s1">-</span><span class="s2">20</span><span class="s1">-</span><span class="s2">20j</span><span class="s0">,</span><span class="s1">-</span><span class="s2">30</span><span class="s1">-</span><span class="s2">30j</span><span class="s0">,</span><span class="s1">-</span><span class="s2">40</span><span class="s1">-</span><span class="s2">40j</span><span class="s0">,</span><span class="s1">-</span><span class="s2">50</span><span class="s1">-</span><span class="s2">50j</span><span class="s1">]</span>
        <span class="s1">self._check(big_A[:-</span><span class="s2">1</span><span class="s0">,</span><span class="s1">:-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">big_B[:-</span><span class="s2">1</span><span class="s0">,</span><span class="s1">:-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">P)</span>

        <span class="s5"># need a 5x5 array to ensure YT handles properly when there</span>
        <span class="s5"># is only one real pole and several complex</span>
        <span class="s1">A = np.array([</span><span class="s2">0</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">7</span><span class="s1">/</span><span class="s2">3.</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span>
                      <span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">9</span><span class="s1">]).reshape(</span><span class="s2">5</span><span class="s0">,</span><span class="s2">5</span><span class="s1">)</span>
        <span class="s1">B = np.array([</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s1">]).reshape(</span><span class="s2">5</span><span class="s0">,</span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">P = np.array([-</span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3</span><span class="s1">+</span><span class="s2">1j</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3</span><span class="s1">-</span><span class="s2">1j</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">+</span><span class="s2">1j</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">-</span><span class="s2">1j</span><span class="s1">])</span>
        <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s4">'ignore'</span><span class="s0">, </span><span class="s1">invalid=</span><span class="s4">'ignore'</span><span class="s1">):</span>
            <span class="s1">place_poles(A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">P)</span>

        <span class="s5"># same test with an odd number of real poles &gt; 1</span>
        <span class="s5"># this is another specific case of YT</span>
        <span class="s1">P = np.array([-</span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">+</span><span class="s2">1j</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">-</span><span class="s2">1j</span><span class="s1">])</span>
        <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s4">'ignore'</span><span class="s0">, </span><span class="s1">invalid=</span><span class="s4">'ignore'</span><span class="s1">):</span>
            <span class="s1">self._check(A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">P)</span>

    <span class="s0">def </span><span class="s1">test_tricky_B(self):</span>
        <span class="s5"># check we handle as we should the 1 column B matrices and</span>
        <span class="s5"># n column B matrices (with n such as shape(A)=(n, n))</span>
        <span class="s1">A = np.array([</span><span class="s2">1.380</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.2077</span><span class="s0">, </span><span class="s2">6.715</span><span class="s0">, </span><span class="s1">-</span><span class="s2">5.676</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.5814</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4.290</span><span class="s0">, </span><span class="s2">0</span><span class="s0">,</span>
                      <span class="s2">0.6750</span><span class="s0">, </span><span class="s2">1.067</span><span class="s0">, </span><span class="s2">4.273</span><span class="s0">, </span><span class="s1">-</span><span class="s2">6.654</span><span class="s0">, </span><span class="s2">5.893</span><span class="s0">, </span><span class="s2">0.0480</span><span class="s0">, </span><span class="s2">4.273</span><span class="s0">,</span>
                      <span class="s2">1.343</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2.104</span><span class="s1">]).reshape(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span>
        <span class="s1">B = np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">5.679</span><span class="s0">, </span><span class="s2">1.136</span><span class="s0">, </span><span class="s2">1.136</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3.146</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">,</span>
                      <span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">8</span><span class="s1">]).reshape(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span>

        <span class="s5"># KNV or YT are not called here, it's a specific case with only</span>
        <span class="s5"># one unique solution</span>
        <span class="s1">P = np.array([-</span><span class="s2">0.2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">5.0566</span><span class="s0">, </span><span class="s1">-</span><span class="s2">8.6659</span><span class="s1">])</span>
        <span class="s1">fsf = self._check(A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">P)</span>
        <span class="s5"># rtol and nb_iter should be set to np.nan as the identity can be</span>
        <span class="s5"># used as transfer matrix</span>
        <span class="s1">assert_equal(fsf.rtol</span><span class="s0">, </span><span class="s1">np.nan)</span>
        <span class="s1">assert_equal(fsf.nb_iter</span><span class="s0">, </span><span class="s1">np.nan)</span>

        <span class="s5"># check with complex poles too as they trigger a specific case in</span>
        <span class="s5"># the specific case :-)</span>
        <span class="s1">P = np.array((-</span><span class="s2">2</span><span class="s1">+</span><span class="s2">1j</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2</span><span class="s1">-</span><span class="s2">1j</span><span class="s0">,</span><span class="s1">-</span><span class="s2">3</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2</span><span class="s1">))</span>
        <span class="s1">fsf = self._check(A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">P)</span>
        <span class="s1">assert_equal(fsf.rtol</span><span class="s0">, </span><span class="s1">np.nan)</span>
        <span class="s1">assert_equal(fsf.nb_iter</span><span class="s0">, </span><span class="s1">np.nan)</span>

        <span class="s5">#now test with a B matrix with only one column (no optimisation)</span>
        <span class="s1">B = B[:</span><span class="s0">,</span><span class="s2">0</span><span class="s1">].reshape(</span><span class="s2">4</span><span class="s0">,</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">P = np.array((-</span><span class="s2">2</span><span class="s1">+</span><span class="s2">1j</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2</span><span class="s1">-</span><span class="s2">1j</span><span class="s0">,</span><span class="s1">-</span><span class="s2">3</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2</span><span class="s1">))</span>
        <span class="s1">fsf = self._check(A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">P)</span>

        <span class="s5">#  we can't optimize anything, check they are set to 0 as expected</span>
        <span class="s1">assert_equal(fsf.rtol</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(fsf.nb_iter</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_errors(self):</span>
        <span class="s5"># Test input mistakes from user</span>
        <span class="s1">A = np.array([</span><span class="s2">0</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">7</span><span class="s1">/</span><span class="s2">3.</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s1">]).reshape(</span><span class="s2">4</span><span class="s0">,</span><span class="s2">4</span><span class="s1">)</span>
        <span class="s1">B = np.array([</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s1">]).reshape(</span><span class="s2">4</span><span class="s0">,</span><span class="s2">2</span><span class="s1">)</span>

        <span class="s5">#should fail as the method keyword is invalid</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">place_poles</span><span class="s0">, </span><span class="s1">A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">(-</span><span class="s2">2.1</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2.2</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2.3</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2.4</span><span class="s1">)</span><span class="s0">,</span>
                      <span class="s1">method=</span><span class="s4">&quot;foo&quot;</span><span class="s1">)</span>

        <span class="s5">#should fail as poles are not 1D array</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">place_poles</span><span class="s0">, </span><span class="s1">A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">,</span>
                      <span class="s1">np.array((-</span><span class="s2">2.1</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2.2</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2.3</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2.4</span><span class="s1">)).reshape(</span><span class="s2">4</span><span class="s0">,</span><span class="s2">1</span><span class="s1">))</span>

        <span class="s5">#should fail as A is not a 2D array</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">place_poles</span><span class="s0">, </span><span class="s1">A[:</span><span class="s0">,</span><span class="s1">:</span><span class="s0">,</span><span class="s1">np.newaxis]</span><span class="s0">, </span><span class="s1">B</span><span class="s0">,</span>
                      <span class="s1">(-</span><span class="s2">2.1</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2.2</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2.3</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2.4</span><span class="s1">))</span>

        <span class="s5">#should fail as B is not a 2D array</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">place_poles</span><span class="s0">, </span><span class="s1">A</span><span class="s0">, </span><span class="s1">B[:</span><span class="s0">,</span><span class="s1">:</span><span class="s0">,</span><span class="s1">np.newaxis]</span><span class="s0">,</span>
                      <span class="s1">(-</span><span class="s2">2.1</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2.2</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2.3</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2.4</span><span class="s1">))</span>

        <span class="s5">#should fail as there are too many poles</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">place_poles</span><span class="s0">, </span><span class="s1">A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">(-</span><span class="s2">2.1</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2.2</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2.3</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2.4</span><span class="s0">,</span><span class="s1">-</span><span class="s2">3</span><span class="s1">))</span>

        <span class="s5">#should fail as there are not enough poles</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">place_poles</span><span class="s0">, </span><span class="s1">A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">(-</span><span class="s2">2.1</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2.2</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2.3</span><span class="s1">))</span>

        <span class="s5">#should fail as the rtol is greater than 1</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">place_poles</span><span class="s0">, </span><span class="s1">A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">(-</span><span class="s2">2.1</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2.2</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2.3</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2.4</span><span class="s1">)</span><span class="s0">,</span>
                      <span class="s1">rtol=</span><span class="s2">42</span><span class="s1">)</span>

        <span class="s5">#should fail as maxiter is smaller than 1</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">place_poles</span><span class="s0">, </span><span class="s1">A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">(-</span><span class="s2">2.1</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2.2</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2.3</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2.4</span><span class="s1">)</span><span class="s0">,</span>
                      <span class="s1">maxiter=-</span><span class="s2">42</span><span class="s1">)</span>

        <span class="s5"># should fail as ndim(B) is two</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">place_poles</span><span class="s0">, </span><span class="s1">A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">(-</span><span class="s2">2</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2</span><span class="s1">))</span>

        <span class="s5">#unctrollable system</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">place_poles</span><span class="s0">, </span><span class="s1">np.ones((</span><span class="s2">4</span><span class="s0">,</span><span class="s2">4</span><span class="s1">))</span><span class="s0">,</span>
                      <span class="s1">np.ones((</span><span class="s2">4</span><span class="s0">,</span><span class="s2">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">4</span><span class="s1">))</span>

        <span class="s5"># Should not raise ValueError as the poles can be placed but should</span>
        <span class="s5"># raise a warning as the convergence is not reached</span>
        <span class="s0">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s0">True</span><span class="s1">) </span><span class="s0">as </span><span class="s1">w:</span>
            <span class="s1">warnings.simplefilter(</span><span class="s4">&quot;always&quot;</span><span class="s1">)</span>
            <span class="s1">fsf = place_poles(A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">(-</span><span class="s2">1</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2</span><span class="s0">,</span><span class="s1">-</span><span class="s2">3</span><span class="s0">,</span><span class="s1">-</span><span class="s2">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-16</span><span class="s0">, </span><span class="s1">maxiter=</span><span class="s2">42</span><span class="s1">)</span>
            <span class="s1">assert_(len(w) == </span><span class="s2">1</span><span class="s1">)</span>
            <span class="s1">assert_(issubclass(w[-</span><span class="s2">1</span><span class="s1">].category</span><span class="s0">, </span><span class="s1">UserWarning))</span>
            <span class="s1">assert_(</span><span class="s4">&quot;Convergence was not reached after maxiter iterations&quot;</span>
                    <span class="s0">in </span><span class="s1">str(w[-</span><span class="s2">1</span><span class="s1">].message))</span>
            <span class="s1">assert_equal(fsf.nb_iter</span><span class="s0">, </span><span class="s2">42</span><span class="s1">)</span>

        <span class="s5"># should fail as a complex misses its conjugate</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">place_poles</span><span class="s0">, </span><span class="s1">A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">(-</span><span class="s2">2</span><span class="s1">+</span><span class="s2">1j</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2</span><span class="s1">-</span><span class="s2">1j</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2</span><span class="s1">+</span><span class="s2">3j</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2</span><span class="s1">))</span>

        <span class="s5"># should fail as A is not square</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">place_poles</span><span class="s0">, </span><span class="s1">A[:</span><span class="s0">,</span><span class="s1">:</span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">(-</span><span class="s2">2</span><span class="s0">,</span><span class="s1">-</span><span class="s2">3</span><span class="s0">,</span><span class="s1">-</span><span class="s2">4</span><span class="s0">,</span><span class="s1">-</span><span class="s2">5</span><span class="s1">))</span>

        <span class="s5"># should fail as B has not the same number of lines as A</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">place_poles</span><span class="s0">, </span><span class="s1">A</span><span class="s0">, </span><span class="s1">B[:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">(-</span><span class="s2">2</span><span class="s0">,</span><span class="s1">-</span><span class="s2">3</span><span class="s0">,</span><span class="s1">-</span><span class="s2">4</span><span class="s0">,</span><span class="s1">-</span><span class="s2">5</span><span class="s1">))</span>

        <span class="s5"># should fail as KNV0 does not support complex poles</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">place_poles</span><span class="s0">, </span><span class="s1">A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">,</span>
                      <span class="s1">(-</span><span class="s2">2</span><span class="s1">+</span><span class="s2">1j</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2</span><span class="s1">-</span><span class="s2">1j</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2</span><span class="s1">+</span><span class="s2">3j</span><span class="s0">,</span><span class="s1">-</span><span class="s2">2</span><span class="s1">-</span><span class="s2">3j</span><span class="s1">)</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">&quot;KNV0&quot;</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestSS2TF:</span>

    <span class="s0">def </span><span class="s1">check_matrix_shapes(self</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">q</span><span class="s0">, </span><span class="s1">r):</span>
        <span class="s1">ss2tf(np.zeros((p</span><span class="s0">, </span><span class="s1">p))</span><span class="s0">,</span>
              <span class="s1">np.zeros((p</span><span class="s0">, </span><span class="s1">q))</span><span class="s0">,</span>
              <span class="s1">np.zeros((r</span><span class="s0">, </span><span class="s1">p))</span><span class="s0">,</span>
              <span class="s1">np.zeros((r</span><span class="s0">, </span><span class="s1">q))</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_shapes(self):</span>
        <span class="s5"># Each tuple holds:</span>
        <span class="s5">#   number of states, number of inputs, number of outputs</span>
        <span class="s0">for </span><span class="s1">p</span><span class="s0">, </span><span class="s1">q</span><span class="s0">, </span><span class="s1">r </span><span class="s0">in </span><span class="s1">[(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)]:</span>
            <span class="s1">self.check_matrix_shapes(p</span><span class="s0">, </span><span class="s1">q</span><span class="s0">, </span><span class="s1">r)</span>

    <span class="s0">def </span><span class="s1">test_basic(self):</span>
        <span class="s5"># Test a round trip through tf2ss and ss2tf.</span>
        <span class="s1">b = np.array([</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">3.0</span><span class="s0">, </span><span class="s2">5.0</span><span class="s1">])</span>
        <span class="s1">a = np.array([</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">3.0</span><span class="s1">])</span>

        <span class="s1">A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">D = tf2ss(b</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_allclose(A</span><span class="s0">, </span><span class="s1">[[-</span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>
        <span class="s1">assert_allclose(B</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>
        <span class="s1">assert_allclose(C</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>
        <span class="s1">assert_allclose(D</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-14</span><span class="s1">)</span>

        <span class="s1">bb</span><span class="s0">, </span><span class="s1">aa = ss2tf(A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">D)</span>
        <span class="s1">assert_allclose(bb[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>
        <span class="s1">assert_allclose(aa</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_zero_order_round_trip(self):</span>
        <span class="s5"># See gh-5760</span>
        <span class="s1">tf = (</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">D = tf2ss(*tf)</span>
        <span class="s1">assert_allclose(A</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>
        <span class="s1">assert_allclose(B</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>
        <span class="s1">assert_allclose(C</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>
        <span class="s1">assert_allclose(D</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">2</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>

        <span class="s1">num</span><span class="s0">, </span><span class="s1">den = ss2tf(A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">D)</span>
        <span class="s1">assert_allclose(num</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>
        <span class="s1">assert_allclose(den</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>

        <span class="s1">tf = ([[</span><span class="s2">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s1">]]</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">D = tf2ss(*tf)</span>
        <span class="s1">assert_allclose(A</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>
        <span class="s1">assert_allclose(B</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>
        <span class="s1">assert_allclose(C</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>
        <span class="s1">assert_allclose(D</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>

        <span class="s1">num</span><span class="s0">, </span><span class="s1">den = ss2tf(A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">D)</span>
        <span class="s1">assert_allclose(num</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">5</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>
        <span class="s1">assert_allclose(den</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_simo_round_trip(self):</span>
        <span class="s5"># See gh-5753</span>
        <span class="s1">tf = ([[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">D = tf2ss(*tf)</span>
        <span class="s1">assert_allclose(A</span><span class="s0">, </span><span class="s1">[[-</span><span class="s2">2</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>
        <span class="s1">assert_allclose(B</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>
        <span class="s1">assert_allclose(C</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>
        <span class="s1">assert_allclose(D</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>

        <span class="s1">num</span><span class="s0">, </span><span class="s1">den = ss2tf(A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">D)</span>
        <span class="s1">assert_allclose(num</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>
        <span class="s1">assert_allclose(den</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>

        <span class="s1">tf = ([[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">D = tf2ss(*tf)</span>
        <span class="s1">assert_allclose(A</span><span class="s0">, </span><span class="s1">[[-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>
        <span class="s1">assert_allclose(B</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>
        <span class="s1">assert_allclose(C</span><span class="s0">, </span><span class="s1">[[-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>
        <span class="s1">assert_allclose(D</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>

        <span class="s1">num</span><span class="s0">, </span><span class="s1">den = ss2tf(A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">D)</span>
        <span class="s1">assert_allclose(num</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>
        <span class="s1">assert_allclose(den</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>

        <span class="s1">tf = ([[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">])</span>
        <span class="s1">A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">D = tf2ss(*tf)</span>
        <span class="s1">assert_allclose(A</span><span class="s0">, </span><span class="s1">[[-</span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>
        <span class="s1">assert_allclose(B</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>
        <span class="s1">assert_allclose(C</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>
        <span class="s1">assert_allclose(D</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>

        <span class="s1">num</span><span class="s0">, </span><span class="s1">den = ss2tf(A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">D)</span>
        <span class="s1">assert_allclose(num</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>
        <span class="s1">assert_allclose(den</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>

        <span class="s1">tf = (np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=object)</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">6</span><span class="s1">])</span>
        <span class="s1">A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">D = tf2ss(*tf)</span>
        <span class="s1">assert_allclose(A</span><span class="s0">, </span><span class="s1">[[-</span><span class="s2">6</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-31</span><span class="s1">)</span>
        <span class="s1">assert_allclose(B</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-31</span><span class="s1">)</span>
        <span class="s1">assert_allclose(C</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">9</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-31</span><span class="s1">)</span>
        <span class="s1">assert_allclose(D</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-31</span><span class="s1">)</span>

        <span class="s1">num</span><span class="s0">, </span><span class="s1">den = ss2tf(A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">D)</span>
        <span class="s1">assert_allclose(num</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>
        <span class="s1">assert_allclose(den</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>

        <span class="s1">tf = (np.array([[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=object)</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">5</span><span class="s1">])</span>
        <span class="s1">A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">D = tf2ss(*tf)</span>
        <span class="s1">assert_allclose(A</span><span class="s0">, </span><span class="s1">[[-</span><span class="s2">6</span><span class="s0">, </span><span class="s1">-</span><span class="s2">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>
        <span class="s1">assert_allclose(B</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>
        <span class="s1">assert_allclose(C</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">4</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>
        <span class="s1">assert_allclose(D</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>

        <span class="s1">num</span><span class="s0">, </span><span class="s1">den = ss2tf(A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">D)</span>
        <span class="s1">assert_allclose(num</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>
        <span class="s1">assert_allclose(den</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_all_int_arrays(self):</span>
        <span class="s1">A = [[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">3</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s1">]]</span>
        <span class="s1">B = [[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]]</span>
        <span class="s1">C = [[</span><span class="s2">5</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]]</span>
        <span class="s1">D = [[</span><span class="s2">0</span><span class="s1">]]</span>
        <span class="s1">num</span><span class="s0">, </span><span class="s1">den = ss2tf(A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">D)</span>
        <span class="s1">assert_allclose(num</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">5.0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-14</span><span class="s1">)</span>
        <span class="s1">assert_allclose(den</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">4.0</span><span class="s0">, </span><span class="s2">3.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_multioutput(self):</span>
        <span class="s5"># Regression test for gh-2669.</span>

        <span class="s5"># 4 states</span>
        <span class="s1">A = np.array([[-</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[-</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[-</span><span class="s2">4.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">3.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[-</span><span class="s2">8.0</span><span class="s0">, </span><span class="s2">8.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">4.0</span><span class="s1">]])</span>

        <span class="s5"># 1 input</span>
        <span class="s1">B = np.array([[</span><span class="s2">0.3</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">7.0</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">0.0</span><span class="s1">]])</span>

        <span class="s5"># 3 outputs</span>
        <span class="s1">C = np.array([[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">8.0</span><span class="s0">, </span><span class="s2">8.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]])</span>

        <span class="s1">D = np.array([[</span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">1.0</span><span class="s1">]])</span>

        <span class="s5"># Get the transfer functions for all the outputs in one call.</span>
        <span class="s1">b_all</span><span class="s0">, </span><span class="s1">a = ss2tf(A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">D)</span>

        <span class="s5"># Get the transfer functions for each output separately.</span>
        <span class="s1">b0</span><span class="s0">, </span><span class="s1">a0 = ss2tf(A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">D[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">b1</span><span class="s0">, </span><span class="s1">a1 = ss2tf(A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">D[</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">b2</span><span class="s0">, </span><span class="s1">a2 = ss2tf(A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">D[</span><span class="s2">2</span><span class="s1">])</span>

        <span class="s5"># Check that we got the same results.</span>
        <span class="s1">assert_allclose(a0</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>
        <span class="s1">assert_allclose(a1</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>
        <span class="s1">assert_allclose(a2</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b_all</span><span class="s0">, </span><span class="s1">np.vstack((b0</span><span class="s0">, </span><span class="s1">b1</span><span class="s0">, </span><span class="s1">b2))</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-14</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">_TestLsimFuncs:</span>
    <span class="s1">digits_accuracy = </span><span class="s2">7</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">func(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">lti_nowarn(self</span><span class="s0">, </span><span class="s1">*args):</span>
        <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(BadCoefficients)</span>
            <span class="s1">system = lti(*args)</span>
        <span class="s0">return </span><span class="s1">system</span>

    <span class="s0">def </span><span class="s1">test_first_order(self):</span>
        <span class="s5"># y' = -y</span>
        <span class="s5"># exact solution is y(t) = exp(-t)</span>
        <span class="s1">system = self.lti_nowarn(-</span><span class="s2">1.</span><span class="s0">,</span><span class="s2">1.</span><span class="s0">,</span><span class="s2">1.</span><span class="s0">,</span><span class="s2">0.</span><span class="s1">)</span>
        <span class="s1">t = np.linspace(</span><span class="s2">0</span><span class="s0">,</span><span class="s2">5</span><span class="s1">)</span>
        <span class="s1">u = np.zeros_like(t)</span>
        <span class="s1">tout</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">x = self.func(system</span><span class="s0">, </span><span class="s1">u</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">X0=[</span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">expected_x = np.exp(-tout)</span>
        <span class="s1">assert_almost_equal(x</span><span class="s0">, </span><span class="s1">expected_x)</span>
        <span class="s1">assert_almost_equal(y</span><span class="s0">, </span><span class="s1">expected_x)</span>

    <span class="s0">def </span><span class="s1">test_second_order(self):</span>
        <span class="s1">t = np.linspace(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">1001</span><span class="s1">)</span>
        <span class="s1">u = np.zeros_like(t)</span>
        <span class="s5"># Second order system with a repeated root: x''(t) + 2*x(t) + x(t) = 0.</span>
        <span class="s5"># With initial conditions x(0)=1.0 and x'(t)=0.0, the exact solution</span>
        <span class="s5"># is (1-t)*exp(-t).</span>
        <span class="s1">system = self.lti_nowarn([</span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">tout</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">x = self.func(system</span><span class="s0">, </span><span class="s1">u</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">X0=[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">])</span>
        <span class="s1">expected_x = (</span><span class="s2">1.0 </span><span class="s1">- tout) * np.exp(-tout)</span>
        <span class="s1">assert_almost_equal(x[:</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">expected_x)</span>

    <span class="s0">def </span><span class="s1">test_integrator(self):</span>
        <span class="s5"># integrator: y' = u</span>
        <span class="s1">system = self.lti_nowarn(</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s2">0.</span><span class="s1">)</span>
        <span class="s1">t = np.linspace(</span><span class="s2">0</span><span class="s0">,</span><span class="s2">5</span><span class="s1">)</span>
        <span class="s1">u = t</span>
        <span class="s1">tout</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">x = self.func(system</span><span class="s0">, </span><span class="s1">u</span><span class="s0">, </span><span class="s1">t)</span>
        <span class="s1">expected_x = </span><span class="s2">0.5 </span><span class="s1">* tout**</span><span class="s2">2</span>
        <span class="s1">assert_almost_equal(x</span><span class="s0">, </span><span class="s1">expected_x</span><span class="s0">, </span><span class="s1">decimal=self.digits_accuracy)</span>
        <span class="s1">assert_almost_equal(y</span><span class="s0">, </span><span class="s1">expected_x</span><span class="s0">, </span><span class="s1">decimal=self.digits_accuracy)</span>

    <span class="s0">def </span><span class="s1">test_two_states(self):</span>
        <span class="s5"># A system with two state variables, two inputs, and one output.</span>
        <span class="s1">A = np.array([[-</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2.0</span><span class="s1">]])</span>
        <span class="s1">B = np.array([[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]])</span>
        <span class="s1">C = np.array([</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">])</span>
        <span class="s1">D = np.zeros((</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">))</span>

        <span class="s1">system = self.lti_nowarn(A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">D)</span>

        <span class="s1">t = np.linspace(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">10.0</span><span class="s0">, </span><span class="s2">21</span><span class="s1">)</span>
        <span class="s1">u = np.zeros((len(t)</span><span class="s0">, </span><span class="s2">2</span><span class="s1">))</span>
        <span class="s1">tout</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">x = self.func(system</span><span class="s0">, </span><span class="s1">U=u</span><span class="s0">, </span><span class="s1">T=t</span><span class="s0">, </span><span class="s1">X0=[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">expected_y = np.exp(-tout)</span>
        <span class="s1">expected_x0 = np.exp(-tout)</span>
        <span class="s1">expected_x1 = np.exp(-</span><span class="s2">2.0 </span><span class="s1">* tout)</span>
        <span class="s1">assert_almost_equal(y</span><span class="s0">, </span><span class="s1">expected_y)</span>
        <span class="s1">assert_almost_equal(x[:</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">expected_x0)</span>
        <span class="s1">assert_almost_equal(x[:</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">expected_x1)</span>

    <span class="s0">def </span><span class="s1">test_double_integrator(self):</span>
        <span class="s5"># double integrator: y'' = 2u</span>
        <span class="s1">A = np.array([[</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">1.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">0.</span><span class="s1">]])</span>
        <span class="s1">B = np.array([[</span><span class="s2">0.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.</span><span class="s1">]])</span>
        <span class="s1">C = np.array([[</span><span class="s2">2.</span><span class="s0">, </span><span class="s2">0.</span><span class="s1">]])</span>
        <span class="s1">system = self.lti_nowarn(A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s2">0.</span><span class="s1">)</span>
        <span class="s1">t = np.linspace(</span><span class="s2">0</span><span class="s0">,</span><span class="s2">5</span><span class="s1">)</span>
        <span class="s1">u = np.ones_like(t)</span>
        <span class="s1">tout</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">x = self.func(system</span><span class="s0">, </span><span class="s1">u</span><span class="s0">, </span><span class="s1">t)</span>
        <span class="s1">expected_x = np.transpose(np.array([</span><span class="s2">0.5 </span><span class="s1">* tout**</span><span class="s2">2</span><span class="s0">, </span><span class="s1">tout]))</span>
        <span class="s1">expected_y = tout**</span><span class="s2">2</span>
        <span class="s1">assert_almost_equal(x</span><span class="s0">, </span><span class="s1">expected_x</span><span class="s0">, </span><span class="s1">decimal=self.digits_accuracy)</span>
        <span class="s1">assert_almost_equal(y</span><span class="s0">, </span><span class="s1">expected_y</span><span class="s0">, </span><span class="s1">decimal=self.digits_accuracy)</span>

    <span class="s0">def </span><span class="s1">test_jordan_block(self):</span>
        <span class="s5"># Non-diagonalizable A matrix</span>
        <span class="s5">#   x1' + x1 = x2</span>
        <span class="s5">#   x2' + x2 = u</span>
        <span class="s5">#   y = x1</span>
        <span class="s5"># Exact solution with u = 0 is y(t) = t exp(-t)</span>
        <span class="s1">A = np.array([[-</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">1.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.</span><span class="s1">]])</span>
        <span class="s1">B = np.array([[</span><span class="s2">0.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.</span><span class="s1">]])</span>
        <span class="s1">C = np.array([[</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">0.</span><span class="s1">]])</span>
        <span class="s1">system = self.lti_nowarn(A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s2">0.</span><span class="s1">)</span>
        <span class="s1">t = np.linspace(</span><span class="s2">0</span><span class="s0">,</span><span class="s2">5</span><span class="s1">)</span>
        <span class="s1">u = np.zeros_like(t)</span>
        <span class="s1">tout</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">x = self.func(system</span><span class="s0">, </span><span class="s1">u</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">X0=[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">expected_y = tout * np.exp(-tout)</span>
        <span class="s1">assert_almost_equal(y</span><span class="s0">, </span><span class="s1">expected_y)</span>

    <span class="s0">def </span><span class="s1">test_miso(self):</span>
        <span class="s5"># A system with two state variables, two inputs, and one output.</span>
        <span class="s1">A = np.array([[-</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2.0</span><span class="s1">]])</span>
        <span class="s1">B = np.array([[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]])</span>
        <span class="s1">C = np.array([</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">])</span>
        <span class="s1">D = np.zeros((</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s1">))</span>
        <span class="s1">system = self.lti_nowarn(A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">D)</span>

        <span class="s1">t = np.linspace(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">5.0</span><span class="s0">, </span><span class="s2">101</span><span class="s1">)</span>
        <span class="s1">u = np.zeros((len(t)</span><span class="s0">, </span><span class="s2">2</span><span class="s1">))</span>
        <span class="s1">tout</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">x = self.func(system</span><span class="s0">, </span><span class="s1">u</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">X0=[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">expected_y = np.exp(-tout)</span>
        <span class="s1">expected_x0 = np.exp(-tout)</span>
        <span class="s1">expected_x1 = np.exp(-</span><span class="s2">2.0</span><span class="s1">*tout)</span>
        <span class="s1">assert_almost_equal(y</span><span class="s0">, </span><span class="s1">expected_y)</span>
        <span class="s1">assert_almost_equal(x[:</span><span class="s0">,</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">expected_x0)</span>
        <span class="s1">assert_almost_equal(x[:</span><span class="s0">,</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">expected_x1)</span>


<span class="s0">class </span><span class="s1">TestLsim(_TestLsimFuncs):</span>

    <span class="s0">def </span><span class="s1">func(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">return </span><span class="s1">lsim(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_nonzero_initial_time(self):</span>
        <span class="s1">system = self.lti_nowarn(-</span><span class="s2">1.</span><span class="s0">,</span><span class="s2">1.</span><span class="s0">,</span><span class="s2">1.</span><span class="s0">,</span><span class="s2">0.</span><span class="s1">)</span>
        <span class="s1">t = np.linspace(</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">u = np.zeros_like(t)</span>
        <span class="s1">tout</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">x = self.func(system</span><span class="s0">, </span><span class="s1">u</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">X0=[</span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">expected_y = np.exp(-tout)</span>
        <span class="s1">assert_almost_equal(y</span><span class="s0">, </span><span class="s1">expected_y)</span>

    <span class="s0">def </span><span class="s1">test_nonequal_timesteps(self):</span>
        <span class="s1">t = np.array([</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">3.0</span><span class="s1">])</span>
        <span class="s1">u = np.array([</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s5"># Simple integrator: x'(t) = u(t)</span>
        <span class="s1">system = ([</span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">])</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">,</span>
                           <span class="s1">match=</span><span class="s4">&quot;Time steps are not equally spaced.&quot;</span><span class="s1">):</span>
            <span class="s1">tout</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">x = self.func(system</span><span class="s0">, </span><span class="s1">u</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">X0=[</span><span class="s2">1.0</span><span class="s1">])</span>


<span class="s0">class </span><span class="s1">TestLsim2(_TestLsimFuncs):</span>
    <span class="s1">digits_accuracy = </span><span class="s2">6</span>

    <span class="s0">def </span><span class="s1">func(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">with </span><span class="s1">warns(DeprecationWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;lsim2 is deprecated&quot;</span><span class="s1">):</span>
            <span class="s1">t</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">x = lsim2(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">return </span><span class="s1">t</span><span class="s0">, </span><span class="s1">np.squeeze(y)</span><span class="s0">, </span><span class="s1">np.squeeze(x)</span>

    <span class="s0">def </span><span class="s1">test_integrator_nonequal_timestamp(self):</span>
        <span class="s1">t = np.array([</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">3.0</span><span class="s1">])</span>
        <span class="s1">u = np.array([</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s5"># Simple integrator: x'(t) = u(t)</span>
        <span class="s1">system = ([</span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">,</span><span class="s2">0.0</span><span class="s1">])</span>
        <span class="s1">tout</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">x = self.func(system</span><span class="s0">, </span><span class="s1">u</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">X0=[</span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">expected_x = np.maximum(</span><span class="s2">1.0</span><span class="s0">, </span><span class="s1">tout)</span>
        <span class="s1">assert_almost_equal(x</span><span class="s0">, </span><span class="s1">expected_x)</span>

    <span class="s0">def </span><span class="s1">test_integrator_nonequal_timestamp_kwarg(self):</span>
        <span class="s1">t = np.array([</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.1</span><span class="s0">, </span><span class="s2">1.1</span><span class="s0">, </span><span class="s2">2.0</span><span class="s1">])</span>
        <span class="s1">u = np.array([</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">])</span>
        <span class="s5"># Simple integrator:  x'(t) = u(t)</span>
        <span class="s1">system = ([</span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">])</span>
        <span class="s1">tout</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">x = self.func(system</span><span class="s0">, </span><span class="s1">u</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">hmax=</span><span class="s2">0.01</span><span class="s1">)</span>
        <span class="s1">expected_x = np.array([</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">0.1</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(x</span><span class="s0">, </span><span class="s1">expected_x)</span>

    <span class="s0">def </span><span class="s1">test_default_arguments(self):</span>
        <span class="s5"># Test use of the default values of the arguments `T` and `U`.</span>
        <span class="s5"># Second order system with a repeated root: x''(t) + 2*x(t) + x(t) = 0.</span>
        <span class="s5"># With initial conditions x(0)=1.0 and x'(t)=0.0, the exact solution</span>
        <span class="s5"># is (1-t)*exp(-t).</span>
        <span class="s1">system = ([</span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">tout</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">x = self.func(system</span><span class="s0">, </span><span class="s1">X0=[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">])</span>
        <span class="s1">expected_x = (</span><span class="s2">1.0 </span><span class="s1">- tout) * np.exp(-tout)</span>
        <span class="s1">assert_almost_equal(x[:</span><span class="s0">,</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">expected_x)</span>


<span class="s0">class </span><span class="s1">_TestImpulseFuncs:</span>
    <span class="s5"># Common tests for impulse/impulse2 (= self.func)</span>

    <span class="s0">def </span><span class="s1">test_first_order(self):</span>
        <span class="s5"># First order system: x'(t) + x(t) = u(t)</span>
        <span class="s5"># Exact impulse response is x(t) = exp(-t).</span>
        <span class="s1">system = ([</span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">,</span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">tout</span><span class="s0">, </span><span class="s1">y = self.func(system)</span>
        <span class="s1">expected_y = np.exp(-tout)</span>
        <span class="s1">assert_almost_equal(y</span><span class="s0">, </span><span class="s1">expected_y)</span>

    <span class="s0">def </span><span class="s1">test_first_order_fixed_time(self):</span>
        <span class="s5"># Specify the desired time values for the output.</span>

        <span class="s5"># First order system: x'(t) + x(t) = u(t)</span>
        <span class="s5"># Exact impulse response is x(t) = exp(-t).</span>
        <span class="s1">system = ([</span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">,</span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">n = </span><span class="s2">21</span>
        <span class="s1">t = np.linspace(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s0">, </span><span class="s1">n)</span>
        <span class="s1">tout</span><span class="s0">, </span><span class="s1">y = self.func(system</span><span class="s0">, </span><span class="s1">T=t)</span>
        <span class="s1">assert_equal(tout.shape</span><span class="s0">, </span><span class="s1">(n</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">assert_almost_equal(tout</span><span class="s0">, </span><span class="s1">t)</span>
        <span class="s1">expected_y = np.exp(-t)</span>
        <span class="s1">assert_almost_equal(y</span><span class="s0">, </span><span class="s1">expected_y)</span>

    <span class="s0">def </span><span class="s1">test_first_order_initial(self):</span>
        <span class="s5"># Specify an initial condition as a scalar.</span>

        <span class="s5"># First order system: x'(t) + x(t) = u(t), x(0)=3.0</span>
        <span class="s5"># Exact impulse response is x(t) = 4*exp(-t).</span>
        <span class="s1">system = ([</span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">,</span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">tout</span><span class="s0">, </span><span class="s1">y = self.func(system</span><span class="s0">, </span><span class="s1">X0=</span><span class="s2">3.0</span><span class="s1">)</span>
        <span class="s1">expected_y = </span><span class="s2">4.0 </span><span class="s1">* np.exp(-tout)</span>
        <span class="s1">assert_almost_equal(y</span><span class="s0">, </span><span class="s1">expected_y)</span>

    <span class="s0">def </span><span class="s1">test_first_order_initial_list(self):</span>
        <span class="s5"># Specify an initial condition as a list.</span>

        <span class="s5"># First order system: x'(t) + x(t) = u(t), x(0)=3.0</span>
        <span class="s5"># Exact impulse response is x(t) = 4*exp(-t).</span>
        <span class="s1">system = ([</span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">,</span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">tout</span><span class="s0">, </span><span class="s1">y = self.func(system</span><span class="s0">, </span><span class="s1">X0=[</span><span class="s2">3.0</span><span class="s1">])</span>
        <span class="s1">expected_y = </span><span class="s2">4.0 </span><span class="s1">* np.exp(-tout)</span>
        <span class="s1">assert_almost_equal(y</span><span class="s0">, </span><span class="s1">expected_y)</span>

    <span class="s0">def </span><span class="s1">test_integrator(self):</span>
        <span class="s5"># Simple integrator: x'(t) = u(t)</span>
        <span class="s1">system = ([</span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">,</span><span class="s2">0.0</span><span class="s1">])</span>
        <span class="s1">tout</span><span class="s0">, </span><span class="s1">y = self.func(system)</span>
        <span class="s1">expected_y = np.ones_like(tout)</span>
        <span class="s1">assert_almost_equal(y</span><span class="s0">, </span><span class="s1">expected_y)</span>

    <span class="s0">def </span><span class="s1">test_second_order(self):</span>
        <span class="s5"># Second order system with a repeated root:</span>
        <span class="s5">#     x''(t) + 2*x(t) + x(t) = u(t)</span>
        <span class="s5"># The exact impulse response is t*exp(-t).</span>
        <span class="s1">system = ([</span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">tout</span><span class="s0">, </span><span class="s1">y = self.func(system)</span>
        <span class="s1">expected_y = tout * np.exp(-tout)</span>
        <span class="s1">assert_almost_equal(y</span><span class="s0">, </span><span class="s1">expected_y)</span>

    <span class="s0">def </span><span class="s1">test_array_like(self):</span>
        <span class="s5"># Test that function can accept sequences, scalars.</span>
        <span class="s1">system = ([</span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s5"># TODO: add meaningful test where X0 is a list</span>
        <span class="s1">tout</span><span class="s0">, </span><span class="s1">y = self.func(system</span><span class="s0">, </span><span class="s1">X0=[</span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">T=[</span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">])</span>
        <span class="s1">tout</span><span class="s0">, </span><span class="s1">y = self.func(system</span><span class="s0">, </span><span class="s1">X0=[</span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">T=[</span><span class="s2">5</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_array_like2(self):</span>
        <span class="s1">system = ([</span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">tout</span><span class="s0">, </span><span class="s1">y = self.func(system</span><span class="s0">, </span><span class="s1">X0=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">T=</span><span class="s2">5</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestImpulse2(_TestImpulseFuncs):</span>

    <span class="s0">def </span><span class="s1">func(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">with </span><span class="s1">warns(DeprecationWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;impulse2 is deprecated&quot;</span><span class="s1">):</span>
            <span class="s0">return </span><span class="s1">impulse2(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>


<span class="s0">class </span><span class="s1">TestImpulse(_TestImpulseFuncs):</span>

    <span class="s0">def </span><span class="s1">func(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">return </span><span class="s1">impulse(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>


<span class="s0">class </span><span class="s1">_TestStepFuncs:</span>
    <span class="s0">def </span><span class="s1">test_first_order(self):</span>
        <span class="s5"># First order system: x'(t) + x(t) = u(t)</span>
        <span class="s5"># Exact step response is x(t) = 1 - exp(-t).</span>
        <span class="s1">system = ([</span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">,</span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">tout</span><span class="s0">, </span><span class="s1">y = self.func(system)</span>
        <span class="s1">expected_y = </span><span class="s2">1.0 </span><span class="s1">- np.exp(-tout)</span>
        <span class="s1">assert_almost_equal(y</span><span class="s0">, </span><span class="s1">expected_y)</span>

    <span class="s0">def </span><span class="s1">test_first_order_fixed_time(self):</span>
        <span class="s5"># Specify the desired time values for the output.</span>

        <span class="s5"># First order system: x'(t) + x(t) = u(t)</span>
        <span class="s5"># Exact step response is x(t) = 1 - exp(-t).</span>
        <span class="s1">system = ([</span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">,</span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">n = </span><span class="s2">21</span>
        <span class="s1">t = np.linspace(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s0">, </span><span class="s1">n)</span>
        <span class="s1">tout</span><span class="s0">, </span><span class="s1">y = self.func(system</span><span class="s0">, </span><span class="s1">T=t)</span>
        <span class="s1">assert_equal(tout.shape</span><span class="s0">, </span><span class="s1">(n</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">assert_almost_equal(tout</span><span class="s0">, </span><span class="s1">t)</span>
        <span class="s1">expected_y = </span><span class="s2">1 </span><span class="s1">- np.exp(-t)</span>
        <span class="s1">assert_almost_equal(y</span><span class="s0">, </span><span class="s1">expected_y)</span>

    <span class="s0">def </span><span class="s1">test_first_order_initial(self):</span>
        <span class="s5"># Specify an initial condition as a scalar.</span>

        <span class="s5"># First order system: x'(t) + x(t) = u(t), x(0)=3.0</span>
        <span class="s5"># Exact step response is x(t) = 1 + 2*exp(-t).</span>
        <span class="s1">system = ([</span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">,</span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">tout</span><span class="s0">, </span><span class="s1">y = self.func(system</span><span class="s0">, </span><span class="s1">X0=</span><span class="s2">3.0</span><span class="s1">)</span>
        <span class="s1">expected_y = </span><span class="s2">1 </span><span class="s1">+ </span><span class="s2">2.0</span><span class="s1">*np.exp(-tout)</span>
        <span class="s1">assert_almost_equal(y</span><span class="s0">, </span><span class="s1">expected_y)</span>

    <span class="s0">def </span><span class="s1">test_first_order_initial_list(self):</span>
        <span class="s5"># Specify an initial condition as a list.</span>

        <span class="s5"># First order system: x'(t) + x(t) = u(t), x(0)=3.0</span>
        <span class="s5"># Exact step response is x(t) = 1 + 2*exp(-t).</span>
        <span class="s1">system = ([</span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">,</span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">tout</span><span class="s0">, </span><span class="s1">y = self.func(system</span><span class="s0">, </span><span class="s1">X0=[</span><span class="s2">3.0</span><span class="s1">])</span>
        <span class="s1">expected_y = </span><span class="s2">1 </span><span class="s1">+ </span><span class="s2">2.0</span><span class="s1">*np.exp(-tout)</span>
        <span class="s1">assert_almost_equal(y</span><span class="s0">, </span><span class="s1">expected_y)</span>

    <span class="s0">def </span><span class="s1">test_integrator(self):</span>
        <span class="s5"># Simple integrator: x'(t) = u(t)</span>
        <span class="s5"># Exact step response is x(t) = t.</span>
        <span class="s1">system = ([</span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">,</span><span class="s2">0.0</span><span class="s1">])</span>
        <span class="s1">tout</span><span class="s0">, </span><span class="s1">y = self.func(system)</span>
        <span class="s1">expected_y = tout</span>
        <span class="s1">assert_almost_equal(y</span><span class="s0">, </span><span class="s1">expected_y)</span>

    <span class="s0">def </span><span class="s1">test_second_order(self):</span>
        <span class="s5"># Second order system with a repeated root:</span>
        <span class="s5">#     x''(t) + 2*x(t) + x(t) = u(t)</span>
        <span class="s5"># The exact step response is 1 - (1 + t)*exp(-t).</span>
        <span class="s1">system = ([</span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">tout</span><span class="s0">, </span><span class="s1">y = self.func(system)</span>
        <span class="s1">expected_y = </span><span class="s2">1 </span><span class="s1">- (</span><span class="s2">1 </span><span class="s1">+ tout) * np.exp(-tout)</span>
        <span class="s1">assert_almost_equal(y</span><span class="s0">, </span><span class="s1">expected_y)</span>

    <span class="s0">def </span><span class="s1">test_array_like(self):</span>
        <span class="s5"># Test that function can accept sequences, scalars.</span>
        <span class="s1">system = ([</span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s5"># TODO: add meaningful test where X0 is a list</span>
        <span class="s1">tout</span><span class="s0">, </span><span class="s1">y = self.func(system</span><span class="s0">, </span><span class="s1">T=[</span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">])</span>


<span class="s0">class </span><span class="s1">TestStep2(_TestStepFuncs):</span>
    <span class="s0">def </span><span class="s1">func(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">with </span><span class="s1">warns(DeprecationWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;step2 is deprecated&quot;</span><span class="s1">):</span>
            <span class="s0">return </span><span class="s1">step2(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_integrator(self):</span>
        <span class="s5"># This test is almost the same as the one it overwrites in the base</span>
        <span class="s5"># class.  The only difference is the tolerances passed to step2:</span>
        <span class="s5"># the default tolerances are not accurate enough for this test</span>

        <span class="s5"># Simple integrator: x'(t) = u(t)</span>
        <span class="s5"># Exact step response is x(t) = t.</span>
        <span class="s1">system = ([</span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">,</span><span class="s2">0.0</span><span class="s1">])</span>
        <span class="s1">tout</span><span class="s0">, </span><span class="s1">y = self.func(system</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-10</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-8</span><span class="s1">)</span>
        <span class="s1">expected_y = tout</span>
        <span class="s1">assert_almost_equal(y</span><span class="s0">, </span><span class="s1">expected_y)</span>


<span class="s0">class </span><span class="s1">TestStep(_TestStepFuncs):</span>
    <span class="s0">def </span><span class="s1">func(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">return </span><span class="s1">step(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_complex_input(self):</span>
        <span class="s5"># Test that complex input doesn't raise an error.</span>
        <span class="s5"># `step` doesn't seem to have been designed for complex input, but this</span>
        <span class="s5"># works and may be used, so add regression test.  See gh-2654.</span>
        <span class="s1">step(([]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">1</span><span class="s1">+</span><span class="s2">0j</span><span class="s1">))</span>


<span class="s0">class </span><span class="s1">TestLti:</span>
    <span class="s0">def </span><span class="s1">test_lti_instantiation(self):</span>
        <span class="s5"># Test that lti can be instantiated with sequences, scalars.</span>
        <span class="s5"># See PR-225.</span>

        <span class="s5"># TransferFunction</span>
        <span class="s1">s = lti([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_(isinstance(s</span><span class="s0">, </span><span class="s1">TransferFunction))</span>
        <span class="s1">assert_(isinstance(s</span><span class="s0">, </span><span class="s1">lti))</span>
        <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">isinstance(s</span><span class="s0">, </span><span class="s1">dlti))</span>
        <span class="s1">assert_(s.dt </span><span class="s0">is None</span><span class="s1">)</span>

        <span class="s5"># ZerosPolesGain</span>
        <span class="s1">s = lti(np.array([])</span><span class="s0">, </span><span class="s1">np.array([-</span><span class="s2">1</span><span class="s1">])</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(s</span><span class="s0">, </span><span class="s1">ZerosPolesGain))</span>
        <span class="s1">assert_(isinstance(s</span><span class="s0">, </span><span class="s1">lti))</span>
        <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">isinstance(s</span><span class="s0">, </span><span class="s1">dlti))</span>
        <span class="s1">assert_(s.dt </span><span class="s0">is None</span><span class="s1">)</span>

        <span class="s5"># StateSpace</span>
        <span class="s1">s = lti([]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">s = lti([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(s</span><span class="s0">, </span><span class="s1">StateSpace))</span>
        <span class="s1">assert_(isinstance(s</span><span class="s0">, </span><span class="s1">lti))</span>
        <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">isinstance(s</span><span class="s0">, </span><span class="s1">dlti))</span>
        <span class="s1">assert_(s.dt </span><span class="s0">is None</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestStateSpace:</span>
    <span class="s0">def </span><span class="s1">test_initialization(self):</span>
        <span class="s5"># Check that all initializations work</span>
        <span class="s1">StateSpace(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">StateSpace([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s1">])</span>
        <span class="s1">StateSpace(np.array([[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]])</span><span class="s0">, </span><span class="s1">np.array([[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s1">]])</span><span class="s0">,</span>
                   <span class="s1">np.array([[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]])</span><span class="s0">, </span><span class="s1">np.array([[</span><span class="s2">0</span><span class="s1">]]))</span>

    <span class="s0">def </span><span class="s1">test_conversion(self):</span>
        <span class="s5"># Check the conversion functions</span>
        <span class="s1">s = StateSpace(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(s.to_ss()</span><span class="s0">, </span><span class="s1">StateSpace))</span>
        <span class="s1">assert_(isinstance(s.to_tf()</span><span class="s0">, </span><span class="s1">TransferFunction))</span>
        <span class="s1">assert_(isinstance(s.to_zpk()</span><span class="s0">, </span><span class="s1">ZerosPolesGain))</span>

        <span class="s5"># Make sure copies work</span>
        <span class="s1">assert_(StateSpace(s) </span><span class="s0">is not </span><span class="s1">s)</span>
        <span class="s1">assert_(s.to_ss() </span><span class="s0">is not </span><span class="s1">s)</span>

    <span class="s0">def </span><span class="s1">test_properties(self):</span>
        <span class="s5"># Test setters/getters for cross class properties.</span>
        <span class="s5"># This implicitly tests to_tf() and to_zpk()</span>

        <span class="s5"># Getters</span>
        <span class="s1">s = StateSpace(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(s.poles</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(s.zeros</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_(s.dt </span><span class="s0">is None</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_operators(self):</span>
        <span class="s5"># Test +/-/* operators on systems</span>

        <span class="s0">class </span><span class="s1">BadType:</span>
            <span class="s0">pass</span>

        <span class="s1">s1 = StateSpace(np.array([[-</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.7</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.3</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.8</span><span class="s1">]])</span><span class="s0">,</span>
                        <span class="s1">np.array([[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">]])</span><span class="s0">,</span>
                        <span class="s1">np.array([[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]])</span><span class="s0">,</span>
                        <span class="s1">np.array([[</span><span class="s2">0</span><span class="s1">]])</span><span class="s0">,</span>
                        <span class="s1">)</span>

        <span class="s1">s2 = StateSpace(np.array([[-</span><span class="s2">0.2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.4</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.1</span><span class="s1">]])</span><span class="s0">,</span>
                        <span class="s1">np.array([[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">]])</span><span class="s0">,</span>
                        <span class="s1">np.array([[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]])</span><span class="s0">,</span>
                        <span class="s1">np.array([[</span><span class="s2">0</span><span class="s1">]])</span>
                        <span class="s1">)</span>

        <span class="s1">s_discrete = s1.to_discrete(</span><span class="s2">0.1</span><span class="s1">)</span>
        <span class="s1">s2_discrete = s2.to_discrete(</span><span class="s2">0.2</span><span class="s1">)</span>
        <span class="s1">s3_discrete = s2.to_discrete(</span><span class="s2">0.1</span><span class="s1">)</span>

        <span class="s5"># Impulse response</span>
        <span class="s1">t = np.linspace(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">100</span><span class="s1">)</span>
        <span class="s1">u = np.zeros_like(t)</span>
        <span class="s1">u[</span><span class="s2">0</span><span class="s1">] = </span><span class="s2">1</span>

        <span class="s5"># Test multiplication</span>
        <span class="s0">for </span><span class="s1">typ </span><span class="s0">in </span><span class="s1">(int</span><span class="s0">, </span><span class="s1">float</span><span class="s0">, </span><span class="s1">complex</span><span class="s0">, </span><span class="s1">np.float32</span><span class="s0">, </span><span class="s1">np.complex128</span><span class="s0">, </span><span class="s1">np.array):</span>
            <span class="s1">assert_allclose(lsim(typ(</span><span class="s2">2</span><span class="s1">) * s1</span><span class="s0">, </span><span class="s1">U=u</span><span class="s0">, </span><span class="s1">T=t)[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                            <span class="s1">typ(</span><span class="s2">2</span><span class="s1">) * lsim(s1</span><span class="s0">, </span><span class="s1">U=u</span><span class="s0">, </span><span class="s1">T=t)[</span><span class="s2">1</span><span class="s1">])</span>

            <span class="s1">assert_allclose(lsim(s1 * typ(</span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">U=u</span><span class="s0">, </span><span class="s1">T=t)[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                            <span class="s1">lsim(s1</span><span class="s0">, </span><span class="s1">U=u</span><span class="s0">, </span><span class="s1">T=t)[</span><span class="s2">1</span><span class="s1">] * typ(</span><span class="s2">2</span><span class="s1">))</span>

            <span class="s1">assert_allclose(lsim(s1 / typ(</span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">U=u</span><span class="s0">, </span><span class="s1">T=t)[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                            <span class="s1">lsim(s1</span><span class="s0">, </span><span class="s1">U=u</span><span class="s0">, </span><span class="s1">T=t)[</span><span class="s2">1</span><span class="s1">] / typ(</span><span class="s2">2</span><span class="s1">))</span>

            <span class="s0">with </span><span class="s1">assert_raises(TypeError):</span>
                <span class="s1">typ(</span><span class="s2">2</span><span class="s1">) / s1</span>

        <span class="s1">assert_allclose(lsim(s1 * </span><span class="s2">2</span><span class="s0">, </span><span class="s1">U=u</span><span class="s0">, </span><span class="s1">T=t)[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                        <span class="s1">lsim(s1</span><span class="s0">, </span><span class="s1">U=</span><span class="s2">2 </span><span class="s1">* u</span><span class="s0">, </span><span class="s1">T=t)[</span><span class="s2">1</span><span class="s1">])</span>

        <span class="s1">assert_allclose(lsim(s1 * s2</span><span class="s0">, </span><span class="s1">U=u</span><span class="s0">, </span><span class="s1">T=t)[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                        <span class="s1">lsim(s1</span><span class="s0">, </span><span class="s1">U=lsim(s2</span><span class="s0">, </span><span class="s1">U=u</span><span class="s0">, </span><span class="s1">T=t)[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">T=t)[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                        <span class="s1">atol=</span><span class="s2">1e-5</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">assert_raises(TypeError):</span>
            <span class="s1">s1 / s1</span>

        <span class="s0">with </span><span class="s1">assert_raises(TypeError):</span>
            <span class="s1">s1 * s_discrete</span>

        <span class="s0">with </span><span class="s1">assert_raises(TypeError):</span>
            <span class="s5"># Check different discretization constants</span>
            <span class="s1">s_discrete * s2_discrete</span>

        <span class="s0">with </span><span class="s1">assert_raises(TypeError):</span>
            <span class="s1">s1 * BadType()</span>

        <span class="s0">with </span><span class="s1">assert_raises(TypeError):</span>
            <span class="s1">BadType() * s1</span>

        <span class="s0">with </span><span class="s1">assert_raises(TypeError):</span>
            <span class="s1">s1 / BadType()</span>

        <span class="s0">with </span><span class="s1">assert_raises(TypeError):</span>
            <span class="s1">BadType() / s1</span>

        <span class="s5"># Test addition</span>
        <span class="s1">assert_allclose(lsim(s1 + </span><span class="s2">2</span><span class="s0">, </span><span class="s1">U=u</span><span class="s0">, </span><span class="s1">T=t)[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                        <span class="s2">2 </span><span class="s1">* u + lsim(s1</span><span class="s0">, </span><span class="s1">U=u</span><span class="s0">, </span><span class="s1">T=t)[</span><span class="s2">1</span><span class="s1">])</span>

        <span class="s5"># Check for dimension mismatch</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError):</span>
            <span class="s1">s1 + np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>

        <span class="s0">with </span><span class="s1">assert_raises(ValueError):</span>
            <span class="s1">np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]) + s1</span>

        <span class="s0">with </span><span class="s1">assert_raises(TypeError):</span>
            <span class="s1">s1 + s_discrete</span>

        <span class="s0">with </span><span class="s1">assert_raises(ValueError):</span>
            <span class="s1">s1 / np.array([[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]])</span>

        <span class="s0">with </span><span class="s1">assert_raises(TypeError):</span>
            <span class="s5"># Check different discretization constants</span>
            <span class="s1">s_discrete + s2_discrete</span>

        <span class="s0">with </span><span class="s1">assert_raises(TypeError):</span>
            <span class="s1">s1 + BadType()</span>

        <span class="s0">with </span><span class="s1">assert_raises(TypeError):</span>
            <span class="s1">BadType() + s1</span>

        <span class="s1">assert_allclose(lsim(s1 + s2</span><span class="s0">, </span><span class="s1">U=u</span><span class="s0">, </span><span class="s1">T=t)[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                        <span class="s1">lsim(s1</span><span class="s0">, </span><span class="s1">U=u</span><span class="s0">, </span><span class="s1">T=t)[</span><span class="s2">1</span><span class="s1">] + lsim(s2</span><span class="s0">, </span><span class="s1">U=u</span><span class="s0">, </span><span class="s1">T=t)[</span><span class="s2">1</span><span class="s1">])</span>

        <span class="s5"># Test subtraction</span>
        <span class="s1">assert_allclose(lsim(s1 - </span><span class="s2">2</span><span class="s0">, </span><span class="s1">U=u</span><span class="s0">, </span><span class="s1">T=t)[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                        <span class="s1">-</span><span class="s2">2 </span><span class="s1">* u + lsim(s1</span><span class="s0">, </span><span class="s1">U=u</span><span class="s0">, </span><span class="s1">T=t)[</span><span class="s2">1</span><span class="s1">])</span>

        <span class="s1">assert_allclose(lsim(</span><span class="s2">2 </span><span class="s1">- s1</span><span class="s0">, </span><span class="s1">U=u</span><span class="s0">, </span><span class="s1">T=t)[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                        <span class="s2">2 </span><span class="s1">* u + lsim(-s1</span><span class="s0">, </span><span class="s1">U=u</span><span class="s0">, </span><span class="s1">T=t)[</span><span class="s2">1</span><span class="s1">])</span>

        <span class="s1">assert_allclose(lsim(s1 - s2</span><span class="s0">, </span><span class="s1">U=u</span><span class="s0">, </span><span class="s1">T=t)[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                        <span class="s1">lsim(s1</span><span class="s0">, </span><span class="s1">U=u</span><span class="s0">, </span><span class="s1">T=t)[</span><span class="s2">1</span><span class="s1">] - lsim(s2</span><span class="s0">, </span><span class="s1">U=u</span><span class="s0">, </span><span class="s1">T=t)[</span><span class="s2">1</span><span class="s1">])</span>

        <span class="s0">with </span><span class="s1">assert_raises(TypeError):</span>
            <span class="s1">s1 - BadType()</span>

        <span class="s0">with </span><span class="s1">assert_raises(TypeError):</span>
            <span class="s1">BadType() - s1</span>

        <span class="s1">s = s_discrete + s3_discrete</span>
        <span class="s1">assert_(s.dt == </span><span class="s2">0.1</span><span class="s1">)</span>

        <span class="s1">s = s_discrete * s3_discrete</span>
        <span class="s1">assert_(s.dt == </span><span class="s2">0.1</span><span class="s1">)</span>

        <span class="s1">s = </span><span class="s2">3 </span><span class="s1">* s_discrete</span>
        <span class="s1">assert_(s.dt == </span><span class="s2">0.1</span><span class="s1">)</span>

        <span class="s1">s = -s_discrete</span>
        <span class="s1">assert_(s.dt == </span><span class="s2">0.1</span><span class="s1">)</span>

<span class="s0">class </span><span class="s1">TestTransferFunction:</span>
    <span class="s0">def </span><span class="s1">test_initialization(self):</span>
        <span class="s5"># Check that all initializations work</span>
        <span class="s1">TransferFunction(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">TransferFunction([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">TransferFunction(np.array([</span><span class="s2">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">2</span><span class="s1">]))</span>

    <span class="s0">def </span><span class="s1">test_conversion(self):</span>
        <span class="s5"># Check the conversion functions</span>
        <span class="s1">s = TransferFunction([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_(isinstance(s.to_ss()</span><span class="s0">, </span><span class="s1">StateSpace))</span>
        <span class="s1">assert_(isinstance(s.to_tf()</span><span class="s0">, </span><span class="s1">TransferFunction))</span>
        <span class="s1">assert_(isinstance(s.to_zpk()</span><span class="s0">, </span><span class="s1">ZerosPolesGain))</span>

        <span class="s5"># Make sure copies work</span>
        <span class="s1">assert_(TransferFunction(s) </span><span class="s0">is not </span><span class="s1">s)</span>
        <span class="s1">assert_(s.to_tf() </span><span class="s0">is not </span><span class="s1">s)</span>

    <span class="s0">def </span><span class="s1">test_properties(self):</span>
        <span class="s5"># Test setters/getters for cross class properties.</span>
        <span class="s5"># This implicitly tests to_ss() and to_zpk()</span>

        <span class="s5"># Getters</span>
        <span class="s1">s = TransferFunction([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(s.poles</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(s.zeros</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">])</span>


<span class="s0">class </span><span class="s1">TestZerosPolesGain:</span>
    <span class="s0">def </span><span class="s1">test_initialization(self):</span>
        <span class="s5"># Check that all initializations work</span>
        <span class="s1">ZerosPolesGain(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">ZerosPolesGain([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">ZerosPolesGain(np.array([</span><span class="s2">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">2</span><span class="s1">])</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_conversion(self):</span>
        <span class="s5">#Check the conversion functions</span>
        <span class="s1">s = ZerosPolesGain(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(s.to_ss()</span><span class="s0">, </span><span class="s1">StateSpace))</span>
        <span class="s1">assert_(isinstance(s.to_tf()</span><span class="s0">, </span><span class="s1">TransferFunction))</span>
        <span class="s1">assert_(isinstance(s.to_zpk()</span><span class="s0">, </span><span class="s1">ZerosPolesGain))</span>

        <span class="s5"># Make sure copies work</span>
        <span class="s1">assert_(ZerosPolesGain(s) </span><span class="s0">is not </span><span class="s1">s)</span>
        <span class="s1">assert_(s.to_zpk() </span><span class="s0">is not </span><span class="s1">s)</span>


<span class="s0">class </span><span class="s1">Test_abcd_normalize:</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.A = np.array([[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3.0</span><span class="s0">, </span><span class="s2">4.0</span><span class="s1">]])</span>
        <span class="s1">self.B = np.array([[-</span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">5.0</span><span class="s1">]])</span>
        <span class="s1">self.C = np.array([[</span><span class="s2">4.0</span><span class="s0">, </span><span class="s2">5.0</span><span class="s1">]])</span>
        <span class="s1">self.D = np.array([[</span><span class="s2">2.5</span><span class="s1">]])</span>

    <span class="s0">def </span><span class="s1">test_no_matrix_fails(self):</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">abcd_normalize)</span>

    <span class="s0">def </span><span class="s1">test_A_nosquare_fails(self):</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">abcd_normalize</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">self.B</span><span class="s0">, </span><span class="s1">self.C</span><span class="s0">, </span><span class="s1">self.D)</span>

    <span class="s0">def </span><span class="s1">test_AB_mismatch_fails(self):</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">abcd_normalize</span><span class="s0">, </span><span class="s1">self.A</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">self.C</span><span class="s0">, </span><span class="s1">self.D)</span>

    <span class="s0">def </span><span class="s1">test_AC_mismatch_fails(self):</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">abcd_normalize</span><span class="s0">, </span><span class="s1">self.A</span><span class="s0">, </span><span class="s1">self.B</span><span class="s0">,</span>
                      <span class="s1">[[</span><span class="s2">4.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">5.0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">self.D)</span>

    <span class="s0">def </span><span class="s1">test_CD_mismatch_fails(self):</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">abcd_normalize</span><span class="s0">, </span><span class="s1">self.A</span><span class="s0">, </span><span class="s1">self.B</span><span class="s0">,</span>
                      <span class="s1">self.C</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2.5</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_BD_mismatch_fails(self):</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">abcd_normalize</span><span class="s0">, </span><span class="s1">self.A</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">self.C</span><span class="s0">, </span><span class="s1">self.D)</span>

    <span class="s0">def </span><span class="s1">test_normalized_matrices_unchanged(self):</span>
        <span class="s1">A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">D = abcd_normalize(self.A</span><span class="s0">, </span><span class="s1">self.B</span><span class="s0">, </span><span class="s1">self.C</span><span class="s0">, </span><span class="s1">self.D)</span>
        <span class="s1">assert_equal(A</span><span class="s0">, </span><span class="s1">self.A)</span>
        <span class="s1">assert_equal(B</span><span class="s0">, </span><span class="s1">self.B)</span>
        <span class="s1">assert_equal(C</span><span class="s0">, </span><span class="s1">self.C)</span>
        <span class="s1">assert_equal(D</span><span class="s0">, </span><span class="s1">self.D)</span>

    <span class="s0">def </span><span class="s1">test_shapes(self):</span>
        <span class="s1">A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">D = abcd_normalize(self.A</span><span class="s0">, </span><span class="s1">self.B</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(A.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">A.shape[</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(A.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">B.shape[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_equal(A.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">C.shape[</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(C.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">D.shape[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_equal(B.shape[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">D.shape[</span><span class="s2">1</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_zero_dimension_is_not_none1(self):</span>
        <span class="s1">B_ = np.zeros((</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s1">))</span>
        <span class="s1">D_ = np.zeros((</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">))</span>
        <span class="s1">A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">D = abcd_normalize(A=self.A</span><span class="s0">, </span><span class="s1">B=B_</span><span class="s0">, </span><span class="s1">D=D_)</span>
        <span class="s1">assert_equal(A</span><span class="s0">, </span><span class="s1">self.A)</span>
        <span class="s1">assert_equal(B</span><span class="s0">, </span><span class="s1">B_)</span>
        <span class="s1">assert_equal(D</span><span class="s0">, </span><span class="s1">D_)</span>
        <span class="s1">assert_equal(C.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">D_.shape[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_equal(C.shape[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.A.shape[</span><span class="s2">0</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_zero_dimension_is_not_none2(self):</span>
        <span class="s1">B_ = np.zeros((</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s1">))</span>
        <span class="s1">C_ = np.zeros((</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s1">))</span>
        <span class="s1">A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">D = abcd_normalize(A=self.A</span><span class="s0">, </span><span class="s1">B=B_</span><span class="s0">, </span><span class="s1">C=C_)</span>
        <span class="s1">assert_equal(A</span><span class="s0">, </span><span class="s1">self.A)</span>
        <span class="s1">assert_equal(B</span><span class="s0">, </span><span class="s1">B_)</span>
        <span class="s1">assert_equal(C</span><span class="s0">, </span><span class="s1">C_)</span>
        <span class="s1">assert_equal(D.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">C_.shape[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_equal(D.shape[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">B_.shape[</span><span class="s2">1</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_missing_A(self):</span>
        <span class="s1">A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">D = abcd_normalize(B=self.B</span><span class="s0">, </span><span class="s1">C=self.C</span><span class="s0">, </span><span class="s1">D=self.D)</span>
        <span class="s1">assert_equal(A.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">A.shape[</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(A.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">B.shape[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_equal(A.shape</span><span class="s0">, </span><span class="s1">(self.B.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.B.shape[</span><span class="s2">0</span><span class="s1">]))</span>

    <span class="s0">def </span><span class="s1">test_missing_B(self):</span>
        <span class="s1">A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">D = abcd_normalize(A=self.A</span><span class="s0">, </span><span class="s1">C=self.C</span><span class="s0">, </span><span class="s1">D=self.D)</span>
        <span class="s1">assert_equal(B.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">A.shape[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_equal(B.shape[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">D.shape[</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(B.shape</span><span class="s0">, </span><span class="s1">(self.A.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.D.shape[</span><span class="s2">1</span><span class="s1">]))</span>

    <span class="s0">def </span><span class="s1">test_missing_C(self):</span>
        <span class="s1">A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">D = abcd_normalize(A=self.A</span><span class="s0">, </span><span class="s1">B=self.B</span><span class="s0">, </span><span class="s1">D=self.D)</span>
        <span class="s1">assert_equal(C.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">D.shape[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_equal(C.shape[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">A.shape[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_equal(C.shape</span><span class="s0">, </span><span class="s1">(self.D.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.A.shape[</span><span class="s2">0</span><span class="s1">]))</span>

    <span class="s0">def </span><span class="s1">test_missing_D(self):</span>
        <span class="s1">A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">D = abcd_normalize(A=self.A</span><span class="s0">, </span><span class="s1">B=self.B</span><span class="s0">, </span><span class="s1">C=self.C)</span>
        <span class="s1">assert_equal(D.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">C.shape[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_equal(D.shape[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">B.shape[</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(D.shape</span><span class="s0">, </span><span class="s1">(self.C.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.B.shape[</span><span class="s2">1</span><span class="s1">]))</span>

    <span class="s0">def </span><span class="s1">test_missing_AB(self):</span>
        <span class="s1">A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">D = abcd_normalize(C=self.C</span><span class="s0">, </span><span class="s1">D=self.D)</span>
        <span class="s1">assert_equal(A.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">A.shape[</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(A.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">B.shape[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_equal(B.shape[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">D.shape[</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(A.shape</span><span class="s0">, </span><span class="s1">(self.C.shape[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.C.shape[</span><span class="s2">1</span><span class="s1">]))</span>
        <span class="s1">assert_equal(B.shape</span><span class="s0">, </span><span class="s1">(self.C.shape[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.D.shape[</span><span class="s2">1</span><span class="s1">]))</span>

    <span class="s0">def </span><span class="s1">test_missing_AC(self):</span>
        <span class="s1">A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">D = abcd_normalize(B=self.B</span><span class="s0">, </span><span class="s1">D=self.D)</span>
        <span class="s1">assert_equal(A.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">A.shape[</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(A.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">B.shape[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_equal(C.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">D.shape[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_equal(C.shape[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">A.shape[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_equal(A.shape</span><span class="s0">, </span><span class="s1">(self.B.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.B.shape[</span><span class="s2">0</span><span class="s1">]))</span>
        <span class="s1">assert_equal(C.shape</span><span class="s0">, </span><span class="s1">(self.D.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.B.shape[</span><span class="s2">0</span><span class="s1">]))</span>

    <span class="s0">def </span><span class="s1">test_missing_AD(self):</span>
        <span class="s1">A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">D = abcd_normalize(B=self.B</span><span class="s0">, </span><span class="s1">C=self.C)</span>
        <span class="s1">assert_equal(A.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">A.shape[</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(A.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">B.shape[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_equal(D.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">C.shape[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_equal(D.shape[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">B.shape[</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(A.shape</span><span class="s0">, </span><span class="s1">(self.B.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.B.shape[</span><span class="s2">0</span><span class="s1">]))</span>
        <span class="s1">assert_equal(D.shape</span><span class="s0">, </span><span class="s1">(self.C.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.B.shape[</span><span class="s2">1</span><span class="s1">]))</span>

    <span class="s0">def </span><span class="s1">test_missing_BC(self):</span>
        <span class="s1">A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">D = abcd_normalize(A=self.A</span><span class="s0">, </span><span class="s1">D=self.D)</span>
        <span class="s1">assert_equal(B.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">A.shape[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_equal(B.shape[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">D.shape[</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(C.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">D.shape[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_equal(C.shape[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">A.shape[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_equal(B.shape</span><span class="s0">, </span><span class="s1">(self.A.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.D.shape[</span><span class="s2">1</span><span class="s1">]))</span>
        <span class="s1">assert_equal(C.shape</span><span class="s0">, </span><span class="s1">(self.D.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.A.shape[</span><span class="s2">0</span><span class="s1">]))</span>

    <span class="s0">def </span><span class="s1">test_missing_ABC_fails(self):</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">abcd_normalize</span><span class="s0">, </span><span class="s1">D=self.D)</span>

    <span class="s0">def </span><span class="s1">test_missing_BD_fails(self):</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">abcd_normalize</span><span class="s0">, </span><span class="s1">A=self.A</span><span class="s0">, </span><span class="s1">C=self.C)</span>

    <span class="s0">def </span><span class="s1">test_missing_CD_fails(self):</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">abcd_normalize</span><span class="s0">, </span><span class="s1">A=self.A</span><span class="s0">, </span><span class="s1">B=self.B)</span>


<span class="s0">class </span><span class="s1">Test_bode:</span>

    <span class="s0">def </span><span class="s1">test_01(self):</span>
        <span class="s5"># Test bode() magnitude calculation (manual sanity check).</span>
        <span class="s5"># 1st order low-pass filter: H(s) = 1 / (s + 1),</span>
        <span class="s5"># cutoff: 1 rad/s, slope: -20 dB/decade</span>
        <span class="s5">#   H(s=0.1) ~= 0 dB</span>
        <span class="s5">#   H(s=1) ~= -3 dB</span>
        <span class="s5">#   H(s=10) ~= -20 dB</span>
        <span class="s5">#   H(s=100) ~= -40 dB</span>
        <span class="s1">system = lti([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">w = [</span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">100</span><span class="s1">]</span>
        <span class="s1">w</span><span class="s0">, </span><span class="s1">mag</span><span class="s0">, </span><span class="s1">phase = bode(system</span><span class="s0">, </span><span class="s1">w=w)</span>
        <span class="s1">expected_mag = [</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3</span><span class="s0">, </span><span class="s1">-</span><span class="s2">20</span><span class="s0">, </span><span class="s1">-</span><span class="s2">40</span><span class="s1">]</span>
        <span class="s1">assert_almost_equal(mag</span><span class="s0">, </span><span class="s1">expected_mag</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_02(self):</span>
        <span class="s5"># Test bode() phase calculation (manual sanity check).</span>
        <span class="s5"># 1st order low-pass filter: H(s) = 1 / (s + 1),</span>
        <span class="s5">#   angle(H(s=0.1)) ~= -5.7 deg</span>
        <span class="s5">#   angle(H(s=1)) ~= -45 deg</span>
        <span class="s5">#   angle(H(s=10)) ~= -84.3 deg</span>
        <span class="s1">system = lti([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">w = [</span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">10</span><span class="s1">]</span>
        <span class="s1">w</span><span class="s0">, </span><span class="s1">mag</span><span class="s0">, </span><span class="s1">phase = bode(system</span><span class="s0">, </span><span class="s1">w=w)</span>
        <span class="s1">expected_phase = [-</span><span class="s2">5.7</span><span class="s0">, </span><span class="s1">-</span><span class="s2">45</span><span class="s0">, </span><span class="s1">-</span><span class="s2">84.3</span><span class="s1">]</span>
        <span class="s1">assert_almost_equal(phase</span><span class="s0">, </span><span class="s1">expected_phase</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_03(self):</span>
        <span class="s5"># Test bode() magnitude calculation.</span>
        <span class="s5"># 1st order low-pass filter: H(s) = 1 / (s + 1)</span>
        <span class="s1">system = lti([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">w = [</span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">100</span><span class="s1">]</span>
        <span class="s1">w</span><span class="s0">, </span><span class="s1">mag</span><span class="s0">, </span><span class="s1">phase = bode(system</span><span class="s0">, </span><span class="s1">w=w)</span>
        <span class="s1">jw = w * </span><span class="s2">1j</span>
        <span class="s1">y = np.polyval(system.num</span><span class="s0">, </span><span class="s1">jw) / np.polyval(system.den</span><span class="s0">, </span><span class="s1">jw)</span>
        <span class="s1">expected_mag = </span><span class="s2">20.0 </span><span class="s1">* np.log10(abs(y))</span>
        <span class="s1">assert_almost_equal(mag</span><span class="s0">, </span><span class="s1">expected_mag)</span>

    <span class="s0">def </span><span class="s1">test_04(self):</span>
        <span class="s5"># Test bode() phase calculation.</span>
        <span class="s5"># 1st order low-pass filter: H(s) = 1 / (s + 1)</span>
        <span class="s1">system = lti([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">w = [</span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">100</span><span class="s1">]</span>
        <span class="s1">w</span><span class="s0">, </span><span class="s1">mag</span><span class="s0">, </span><span class="s1">phase = bode(system</span><span class="s0">, </span><span class="s1">w=w)</span>
        <span class="s1">jw = w * </span><span class="s2">1j</span>
        <span class="s1">y = np.polyval(system.num</span><span class="s0">, </span><span class="s1">jw) / np.polyval(system.den</span><span class="s0">, </span><span class="s1">jw)</span>
        <span class="s1">expected_phase = np.arctan2(y.imag</span><span class="s0">, </span><span class="s1">y.real) * </span><span class="s2">180.0 </span><span class="s1">/ np.pi</span>
        <span class="s1">assert_almost_equal(phase</span><span class="s0">, </span><span class="s1">expected_phase)</span>

    <span class="s0">def </span><span class="s1">test_05(self):</span>
        <span class="s5"># Test that bode() finds a reasonable frequency range.</span>
        <span class="s5"># 1st order low-pass filter: H(s) = 1 / (s + 1)</span>
        <span class="s1">system = lti([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">n = </span><span class="s2">10</span>
        <span class="s5"># Expected range is from 0.01 to 10.</span>
        <span class="s1">expected_w = np.logspace(-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">n)</span>
        <span class="s1">w</span><span class="s0">, </span><span class="s1">mag</span><span class="s0">, </span><span class="s1">phase = bode(system</span><span class="s0">, </span><span class="s1">n=n)</span>
        <span class="s1">assert_almost_equal(w</span><span class="s0">, </span><span class="s1">expected_w)</span>

    <span class="s0">def </span><span class="s1">test_06(self):</span>
        <span class="s5"># Test that bode() doesn't fail on a system with a pole at 0.</span>
        <span class="s5"># integrator, pole at zero: H(s) = 1 / s</span>
        <span class="s1">system = lti([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">w</span><span class="s0">, </span><span class="s1">mag</span><span class="s0">, </span><span class="s1">phase = bode(system</span><span class="s0">, </span><span class="s1">n=</span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">assert_equal(w[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">0.01</span><span class="s1">)  </span><span class="s5"># a fail would give not-a-number</span>

    <span class="s0">def </span><span class="s1">test_07(self):</span>
        <span class="s5"># bode() should not fail on a system with pure imaginary poles.</span>
        <span class="s5"># The test passes if bode doesn't raise an exception.</span>
        <span class="s1">system = lti([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">100</span><span class="s1">])</span>
        <span class="s1">w</span><span class="s0">, </span><span class="s1">mag</span><span class="s0">, </span><span class="s1">phase = bode(system</span><span class="s0">, </span><span class="s1">n=</span><span class="s2">2</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_08(self):</span>
        <span class="s5"># Test that bode() return continuous phase, issues/2331.</span>
        <span class="s1">system = lti([]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">10</span><span class="s0">, </span><span class="s1">-</span><span class="s2">30</span><span class="s0">, </span><span class="s1">-</span><span class="s2">40</span><span class="s0">, </span><span class="s1">-</span><span class="s2">60</span><span class="s0">, </span><span class="s1">-</span><span class="s2">70</span><span class="s1">]</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">w</span><span class="s0">, </span><span class="s1">mag</span><span class="s0">, </span><span class="s1">phase = system.bode(w=np.logspace(-</span><span class="s2">3</span><span class="s0">, </span><span class="s2">40</span><span class="s0">, </span><span class="s2">100</span><span class="s1">))</span>
        <span class="s1">assert_almost_equal(min(phase)</span><span class="s0">, </span><span class="s1">-</span><span class="s2">450</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">15</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_from_state_space(self):</span>
        <span class="s5"># Ensure that bode works with a system that was created from the</span>
        <span class="s5"># state space representation matrices A, B, C, D.  In this case,</span>
        <span class="s5"># system.num will be a 2-D array with shape (1, n+1), where (n,n)</span>
        <span class="s5"># is the shape of A.</span>
        <span class="s5"># A Butterworth lowpass filter is used, so we know the exact</span>
        <span class="s5"># frequency response.</span>
        <span class="s1">a = np.array([</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">A = linalg.companion(a).T</span>
        <span class="s1">B = np.array([[</span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s1">]])</span>
        <span class="s1">C = np.array([[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]])</span>
        <span class="s1">D = np.array([[</span><span class="s2">0.0</span><span class="s1">]])</span>
        <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(BadCoefficients)</span>
            <span class="s1">system = lti(A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">D)</span>
            <span class="s1">w</span><span class="s0">, </span><span class="s1">mag</span><span class="s0">, </span><span class="s1">phase = bode(system</span><span class="s0">, </span><span class="s1">n=</span><span class="s2">100</span><span class="s1">)</span>

        <span class="s1">expected_magnitude = </span><span class="s2">20 </span><span class="s1">* np.log10(np.sqrt(</span><span class="s2">1.0 </span><span class="s1">/ (</span><span class="s2">1.0 </span><span class="s1">+ w**</span><span class="s2">6</span><span class="s1">)))</span>
        <span class="s1">assert_almost_equal(mag</span><span class="s0">, </span><span class="s1">expected_magnitude)</span>


<span class="s0">class </span><span class="s1">Test_freqresp:</span>

    <span class="s0">def </span><span class="s1">test_output_manual(self):</span>
        <span class="s5"># Test freqresp() output calculation (manual sanity check).</span>
        <span class="s5"># 1st order low-pass filter: H(s) = 1 / (s + 1),</span>
        <span class="s5">#   re(H(s=0.1)) ~= 0.99</span>
        <span class="s5">#   re(H(s=1)) ~= 0.5</span>
        <span class="s5">#   re(H(s=10)) ~= 0.0099</span>
        <span class="s1">system = lti([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">w = [</span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">10</span><span class="s1">]</span>
        <span class="s1">w</span><span class="s0">, </span><span class="s1">H = freqresp(system</span><span class="s0">, </span><span class="s1">w=w)</span>
        <span class="s1">expected_re = [</span><span class="s2">0.99</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.0099</span><span class="s1">]</span>
        <span class="s1">expected_im = [-</span><span class="s2">0.099</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.099</span><span class="s1">]</span>
        <span class="s1">assert_almost_equal(H.real</span><span class="s0">, </span><span class="s1">expected_re</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(H.imag</span><span class="s0">, </span><span class="s1">expected_im</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_output(self):</span>
        <span class="s5"># Test freqresp() output calculation.</span>
        <span class="s5"># 1st order low-pass filter: H(s) = 1 / (s + 1)</span>
        <span class="s1">system = lti([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">w = [</span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">100</span><span class="s1">]</span>
        <span class="s1">w</span><span class="s0">, </span><span class="s1">H = freqresp(system</span><span class="s0">, </span><span class="s1">w=w)</span>
        <span class="s1">s = w * </span><span class="s2">1j</span>
        <span class="s1">expected = np.polyval(system.num</span><span class="s0">, </span><span class="s1">s) / np.polyval(system.den</span><span class="s0">, </span><span class="s1">s)</span>
        <span class="s1">assert_almost_equal(H.real</span><span class="s0">, </span><span class="s1">expected.real)</span>
        <span class="s1">assert_almost_equal(H.imag</span><span class="s0">, </span><span class="s1">expected.imag)</span>

    <span class="s0">def </span><span class="s1">test_freq_range(self):</span>
        <span class="s5"># Test that freqresp() finds a reasonable frequency range.</span>
        <span class="s5"># 1st order low-pass filter: H(s) = 1 / (s + 1)</span>
        <span class="s5"># Expected range is from 0.01 to 10.</span>
        <span class="s1">system = lti([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">n = </span><span class="s2">10</span>
        <span class="s1">expected_w = np.logspace(-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">n)</span>
        <span class="s1">w</span><span class="s0">, </span><span class="s1">H = freqresp(system</span><span class="s0">, </span><span class="s1">n=n)</span>
        <span class="s1">assert_almost_equal(w</span><span class="s0">, </span><span class="s1">expected_w)</span>

    <span class="s0">def </span><span class="s1">test_pole_zero(self):</span>
        <span class="s5"># Test that freqresp() doesn't fail on a system with a pole at 0.</span>
        <span class="s5"># integrator, pole at zero: H(s) = 1 / s</span>
        <span class="s1">system = lti([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">w</span><span class="s0">, </span><span class="s1">H = freqresp(system</span><span class="s0">, </span><span class="s1">n=</span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">assert_equal(w[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">0.01</span><span class="s1">)  </span><span class="s5"># a fail would give not-a-number</span>

    <span class="s0">def </span><span class="s1">test_from_state_space(self):</span>
        <span class="s5"># Ensure that freqresp works with a system that was created from the</span>
        <span class="s5"># state space representation matrices A, B, C, D.  In this case,</span>
        <span class="s5"># system.num will be a 2-D array with shape (1, n+1), where (n,n) is</span>
        <span class="s5"># the shape of A.</span>
        <span class="s5"># A Butterworth lowpass filter is used, so we know the exact</span>
        <span class="s5"># frequency response.</span>
        <span class="s1">a = np.array([</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">A = linalg.companion(a).T</span>
        <span class="s1">B = np.array([[</span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">1.0</span><span class="s1">]])</span>
        <span class="s1">C = np.array([[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]])</span>
        <span class="s1">D = np.array([[</span><span class="s2">0.0</span><span class="s1">]])</span>
        <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(BadCoefficients)</span>
            <span class="s1">system = lti(A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">D)</span>
            <span class="s1">w</span><span class="s0">, </span><span class="s1">H = freqresp(system</span><span class="s0">, </span><span class="s1">n=</span><span class="s2">100</span><span class="s1">)</span>
        <span class="s1">s = w * </span><span class="s2">1j</span>
        <span class="s1">expected = (</span><span class="s2">1.0 </span><span class="s1">/ (</span><span class="s2">1.0 </span><span class="s1">+ </span><span class="s2">2</span><span class="s1">*s + </span><span class="s2">2</span><span class="s1">*s**</span><span class="s2">2 </span><span class="s1">+ s**</span><span class="s2">3</span><span class="s1">))</span>
        <span class="s1">assert_almost_equal(H.real</span><span class="s0">, </span><span class="s1">expected.real)</span>
        <span class="s1">assert_almost_equal(H.imag</span><span class="s0">, </span><span class="s1">expected.imag)</span>

    <span class="s0">def </span><span class="s1">test_from_zpk(self):</span>
        <span class="s5"># 4th order low-pass filter: H(s) = 1 / (s + 1)</span>
        <span class="s1">system = lti([]</span><span class="s0">,</span><span class="s1">[-</span><span class="s2">1</span><span class="s1">]*</span><span class="s2">4</span><span class="s0">,</span><span class="s1">[</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">w = [</span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">100</span><span class="s1">]</span>
        <span class="s1">w</span><span class="s0">, </span><span class="s1">H = freqresp(system</span><span class="s0">, </span><span class="s1">w=w)</span>
        <span class="s1">s = w * </span><span class="s2">1j</span>
        <span class="s1">expected = </span><span class="s2">1 </span><span class="s1">/ (s + </span><span class="s2">1</span><span class="s1">)**</span><span class="s2">4</span>
        <span class="s1">assert_almost_equal(H.real</span><span class="s0">, </span><span class="s1">expected.real)</span>
        <span class="s1">assert_almost_equal(H.imag</span><span class="s0">, </span><span class="s1">expected.imag)</span>
</pre>
</body>
</html>