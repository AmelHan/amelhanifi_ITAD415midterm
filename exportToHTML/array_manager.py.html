<html>
<head>
<title>array_manager.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
array_manager.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Experimental manager based on storing a collection of 1D arrays 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s2">,</span>
    <span class="s1">Callable</span><span class="s2">,</span>
    <span class="s1">Literal</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">pandas._libs </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">NaT</span><span class="s2">,</span>
    <span class="s1">lib</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">from </span><span class="s1">pandas.core.dtypes.astype </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">astype_array</span><span class="s2">,</span>
    <span class="s1">astype_array_safe</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.cast </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ensure_dtype_can_hold_na</span><span class="s2">,</span>
    <span class="s1">find_common_type</span><span class="s2">,</span>
    <span class="s1">infer_dtype_from_scalar</span><span class="s2">,</span>
    <span class="s1">np_find_common_type</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ensure_platform_int</span><span class="s2">,</span>
    <span class="s1">is_datetime64_ns_dtype</span><span class="s2">,</span>
    <span class="s1">is_integer</span><span class="s2">,</span>
    <span class="s1">is_numeric_dtype</span><span class="s2">,</span>
    <span class="s1">is_object_dtype</span><span class="s2">,</span>
    <span class="s1">is_timedelta64_ns_dtype</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.dtypes </span><span class="s2">import </span><span class="s1">ExtensionDtype</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.generic </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ABCDataFrame</span><span class="s2">,</span>
    <span class="s1">ABCSeries</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.missing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">array_equals</span><span class="s2">,</span>
    <span class="s1">isna</span><span class="s2">,</span>
    <span class="s1">na_value_for_dtype</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">import </span><span class="s1">pandas.core.algorithms </span><span class="s2">as </span><span class="s1">algos</span>
<span class="s2">from </span><span class="s1">pandas.core.array_algos.quantile </span><span class="s2">import </span><span class="s1">quantile_compat</span>
<span class="s2">from </span><span class="s1">pandas.core.array_algos.take </span><span class="s2">import </span><span class="s1">take_1d</span>
<span class="s2">from </span><span class="s1">pandas.core.arrays </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">DatetimeArray</span><span class="s2">,</span>
    <span class="s1">ExtensionArray</span><span class="s2">,</span>
    <span class="s1">NumpyExtensionArray</span><span class="s2">,</span>
    <span class="s1">TimedeltaArray</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.construction </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ensure_wrapped_if_datetimelike</span><span class="s2">,</span>
    <span class="s1">extract_array</span><span class="s2">,</span>
    <span class="s1">sanitize_array</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.indexers </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">maybe_convert_indices</span><span class="s2">,</span>
    <span class="s1">validate_indices</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.indexes.api </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Index</span><span class="s2">,</span>
    <span class="s1">ensure_index</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.internals.base </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">DataManager</span><span class="s2">,</span>
    <span class="s1">SingleDataManager</span><span class="s2">,</span>
    <span class="s1">ensure_np_dtype</span><span class="s2">,</span>
    <span class="s1">interleaved_dtype</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.internals.blocks </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">BlockPlacement</span><span class="s2">,</span>
    <span class="s1">ensure_block_shape</span><span class="s2">,</span>
    <span class="s1">external_values</span><span class="s2">,</span>
    <span class="s1">extract_pandas_array</span><span class="s2">,</span>
    <span class="s1">maybe_coerce_values</span><span class="s2">,</span>
    <span class="s1">new_block</span><span class="s2">,</span>
    <span class="s1">to_native_types</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.internals.managers </span><span class="s2">import </span><span class="s1">make_na_array</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s2">from </span><span class="s1">collections.abc </span><span class="s2">import </span><span class="s1">Hashable</span>

    <span class="s2">from </span><span class="s1">pandas._typing </span><span class="s2">import </span><span class="s1">(</span>
        <span class="s1">ArrayLike</span><span class="s2">,</span>
        <span class="s1">AxisInt</span><span class="s2">,</span>
        <span class="s1">DtypeObj</span><span class="s2">,</span>
        <span class="s1">QuantileInterpolation</span><span class="s2">,</span>
        <span class="s1">Self</span><span class="s2">,</span>
        <span class="s1">npt</span><span class="s2">,</span>
    <span class="s1">)</span>


<span class="s2">class </span><span class="s1">BaseArrayManager(DataManager):</span>
    <span class="s0">&quot;&quot;&quot; 
    Core internal data structure to implement DataFrame and Series. 
 
    Alternative to the BlockManager, storing a list of 1D arrays instead of 
    Blocks. 
 
    This is *not* a public API class 
 
    Parameters 
    ---------- 
    arrays : Sequence of arrays 
    axes : Sequence of Index 
    verify_integrity : bool, default True 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = [</span>
        <span class="s3">&quot;_axes&quot;</span><span class="s2">,  </span><span class="s4"># private attribute, because 'axes' has different order, see below</span>
        <span class="s3">&quot;arrays&quot;</span><span class="s2">,</span>
    <span class="s1">]</span>

    <span class="s1">arrays: list[np.ndarray | ExtensionArray]</span>
    <span class="s1">_axes: list[Index]</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">arrays: list[np.ndarray | ExtensionArray]</span><span class="s2">,</span>
        <span class="s1">axes: list[Index]</span><span class="s2">,</span>
        <span class="s1">verify_integrity: bool = </span><span class="s2">True,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">make_empty(self</span><span class="s2">, </span><span class="s1">axes=</span><span class="s2">None</span><span class="s1">) -&gt; Self:</span>
        <span class="s0">&quot;&quot;&quot;Return an empty ArrayManager with the items axis of len 0 (no columns)&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">axes </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">axes = [self.axes[</span><span class="s5">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">Index([])]</span>

        <span class="s1">arrays: list[np.ndarray | ExtensionArray] = []</span>
        <span class="s2">return </span><span class="s1">type(self)(arrays</span><span class="s2">, </span><span class="s1">axes)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">items(self) -&gt; Index:</span>
        <span class="s2">return </span><span class="s1">self._axes[-</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s4"># error: Signature of &quot;axes&quot; incompatible with supertype &quot;DataManager&quot;</span>
    <span class="s2">def </span><span class="s1">axes(self) -&gt; list[Index]:  </span><span class="s4"># type: ignore[override]</span>
        <span class="s4"># mypy doesn't work to override attribute with property</span>
        <span class="s4"># see https://github.com/python/mypy/issues/4125</span>
        <span class="s0">&quot;&quot;&quot;Axes is BlockManager-compatible order (columns, rows)&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">[self._axes[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self._axes[</span><span class="s5">0</span><span class="s1">]]</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">shape_proper(self) -&gt; tuple[int</span><span class="s2">, </span><span class="s1">...]:</span>
        <span class="s4"># this returns (n_rows, n_columns)</span>
        <span class="s2">return </span><span class="s1">tuple(len(ax) </span><span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">self._axes)</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_normalize_axis(axis: AxisInt) -&gt; int:</span>
        <span class="s4"># switch axis</span>
        <span class="s1">axis = </span><span class="s5">1 </span><span class="s2">if </span><span class="s1">axis == </span><span class="s5">0 </span><span class="s2">else </span><span class="s5">0</span>
        <span class="s2">return </span><span class="s1">axis</span>

    <span class="s2">def </span><span class="s1">set_axis(self</span><span class="s2">, </span><span class="s1">axis: AxisInt</span><span class="s2">, </span><span class="s1">new_labels: Index) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s4"># Caller is responsible for ensuring we have an Index object.</span>
        <span class="s1">self._validate_set_axis(axis</span><span class="s2">, </span><span class="s1">new_labels)</span>
        <span class="s1">axis = self._normalize_axis(axis)</span>
        <span class="s1">self._axes[axis] = new_labels</span>

    <span class="s2">def </span><span class="s1">get_dtypes(self) -&gt; npt.NDArray[np.object_]:</span>
        <span class="s2">return </span><span class="s1">np.array([arr.dtype </span><span class="s2">for </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">self.arrays]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;object&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">add_references(self</span><span class="s2">, </span><span class="s1">mgr: BaseArrayManager) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Only implemented on the BlockManager level 
        &quot;&quot;&quot;</span>
        <span class="s2">return</span>

    <span class="s2">def </span><span class="s1">__getstate__(self):</span>
        <span class="s2">return </span><span class="s1">self.arrays</span><span class="s2">, </span><span class="s1">self._axes</span>

    <span class="s2">def </span><span class="s1">__setstate__(self</span><span class="s2">, </span><span class="s1">state) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.arrays = state[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">self._axes = state[</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s1">output = type(self).__name__</span>
        <span class="s1">output += </span><span class="s3">f&quot;</span><span class="s2">\n</span><span class="s3">Index: </span><span class="s2">{</span><span class="s1">self._axes[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">}</span><span class="s3">&quot;</span>
        <span class="s2">if </span><span class="s1">self.ndim == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">output += </span><span class="s3">f&quot;</span><span class="s2">\n</span><span class="s3">Columns: </span><span class="s2">{</span><span class="s1">self._axes[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">}</span><span class="s3">&quot;</span>
        <span class="s1">output += </span><span class="s3">f&quot;</span><span class="s2">\n{</span><span class="s1">len(self.arrays)</span><span class="s2">} </span><span class="s3">arrays:&quot;</span>
        <span class="s2">for </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">self.arrays:</span>
            <span class="s1">output += </span><span class="s3">f&quot;</span><span class="s2">\n{</span><span class="s1">arr.dtype</span><span class="s2">}</span><span class="s3">&quot;</span>
        <span class="s2">return </span><span class="s1">output</span>

    <span class="s2">def </span><span class="s1">apply(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">f</span><span class="s2">,</span>
        <span class="s1">align_keys: list[str] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">**kwargs</span><span class="s2">,</span>
    <span class="s1">) -&gt; Self:</span>
        <span class="s0">&quot;&quot;&quot; 
        Iterate over the arrays, collect and create a new ArrayManager. 
 
        Parameters 
        ---------- 
        f : str or callable 
            Name of the Array method to apply. 
        align_keys: List[str] or None, default None 
        **kwargs 
            Keywords to pass to `f` 
 
        Returns 
        ------- 
        ArrayManager 
        &quot;&quot;&quot;</span>
        <span class="s2">assert </span><span class="s3">&quot;filter&quot; </span><span class="s2">not in </span><span class="s1">kwargs</span>

        <span class="s1">align_keys = align_keys </span><span class="s2">or </span><span class="s1">[]</span>
        <span class="s1">result_arrays: list[ArrayLike] = []</span>
        <span class="s4"># fillna: Series/DataFrame is responsible for making sure value is aligned</span>

        <span class="s1">aligned_args = {k: kwargs[k] </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">align_keys}</span>

        <span class="s2">if </span><span class="s1">f == </span><span class="s3">&quot;apply&quot;</span><span class="s1">:</span>
            <span class="s1">f = kwargs.pop(</span><span class="s3">&quot;func&quot;</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">enumerate(self.arrays):</span>
            <span class="s2">if </span><span class="s1">aligned_args:</span>
                <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">aligned_args.items():</span>
                    <span class="s2">if </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">(ABCSeries</span><span class="s2">, </span><span class="s1">ABCDataFrame)):</span>
                        <span class="s4"># The caller is responsible for ensuring that</span>
                        <span class="s4">#  obj.axes[-1].equals(self.items)</span>
                        <span class="s2">if </span><span class="s1">obj.ndim == </span><span class="s5">1</span><span class="s1">:</span>
                            <span class="s1">kwargs[k] = obj.iloc[i]</span>
                        <span class="s2">else</span><span class="s1">:</span>
                            <span class="s1">kwargs[k] = obj.iloc[:</span><span class="s2">, </span><span class="s1">i]._values</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s4"># otherwise we have an array-like</span>
                        <span class="s1">kwargs[k] = obj[i]</span>

            <span class="s2">if </span><span class="s1">callable(f):</span>
                <span class="s1">applied = f(arr</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">applied = getattr(arr</span><span class="s2">, </span><span class="s1">f)(**kwargs)</span>

            <span class="s1">result_arrays.append(applied)</span>

        <span class="s1">new_axes = self._axes</span>
        <span class="s2">return </span><span class="s1">type(self)(result_arrays</span><span class="s2">, </span><span class="s1">new_axes)</span>

    <span class="s2">def </span><span class="s1">apply_with_block(self</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">align_keys=</span><span class="s2">None, </span><span class="s1">**kwargs) -&gt; Self:</span>
        <span class="s4"># switch axis to follow BlockManager logic</span>
        <span class="s1">swap_axis = </span><span class="s2">True</span>
        <span class="s2">if </span><span class="s1">f == </span><span class="s3">&quot;interpolate&quot;</span><span class="s1">:</span>
            <span class="s1">swap_axis = </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s1">swap_axis </span><span class="s2">and </span><span class="s3">&quot;axis&quot; </span><span class="s2">in </span><span class="s1">kwargs </span><span class="s2">and </span><span class="s1">self.ndim == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">kwargs[</span><span class="s3">&quot;axis&quot;</span><span class="s1">] = </span><span class="s5">1 </span><span class="s2">if </span><span class="s1">kwargs[</span><span class="s3">&quot;axis&quot;</span><span class="s1">] == </span><span class="s5">0 </span><span class="s2">else </span><span class="s5">0</span>

        <span class="s1">align_keys = align_keys </span><span class="s2">or </span><span class="s1">[]</span>
        <span class="s1">aligned_args = {k: kwargs[k] </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">align_keys}</span>

        <span class="s1">result_arrays = []</span>

        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">enumerate(self.arrays):</span>
            <span class="s2">if </span><span class="s1">aligned_args:</span>
                <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">aligned_args.items():</span>
                    <span class="s2">if </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">(ABCSeries</span><span class="s2">, </span><span class="s1">ABCDataFrame)):</span>
                        <span class="s4"># The caller is responsible for ensuring that</span>
                        <span class="s4">#  obj.axes[-1].equals(self.items)</span>
                        <span class="s2">if </span><span class="s1">obj.ndim == </span><span class="s5">1</span><span class="s1">:</span>
                            <span class="s2">if </span><span class="s1">self.ndim == </span><span class="s5">2</span><span class="s1">:</span>
                                <span class="s1">kwargs[k] = obj.iloc[slice(i</span><span class="s2">, </span><span class="s1">i + </span><span class="s5">1</span><span class="s1">)]._values</span>
                            <span class="s2">else</span><span class="s1">:</span>
                                <span class="s1">kwargs[k] = obj.iloc[:]._values</span>
                        <span class="s2">else</span><span class="s1">:</span>
                            <span class="s1">kwargs[k] = obj.iloc[:</span><span class="s2">, </span><span class="s1">[i]]._values</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s4"># otherwise we have an ndarray</span>
                        <span class="s2">if </span><span class="s1">obj.ndim == </span><span class="s5">2</span><span class="s1">:</span>
                            <span class="s1">kwargs[k] = obj[[i]]</span>

            <span class="s2">if </span><span class="s1">isinstance(arr.dtype</span><span class="s2">, </span><span class="s1">np.dtype) </span><span class="s2">and not </span><span class="s1">isinstance(arr</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
                <span class="s4"># i.e. TimedeltaArray, DatetimeArray with tz=None. Need to</span>
                <span class="s4">#  convert for the Block constructors.</span>
                <span class="s1">arr = np.asarray(arr)</span>

            <span class="s1">arr = maybe_coerce_values(arr)</span>
            <span class="s2">if </span><span class="s1">self.ndim == </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s1">arr = ensure_block_shape(arr</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
                <span class="s1">bp = BlockPlacement(slice(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>
                <span class="s1">block = new_block(arr</span><span class="s2">, </span><span class="s1">placement=bp</span><span class="s2">, </span><span class="s1">ndim=</span><span class="s5">2</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">bp = BlockPlacement(slice(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">len(self)</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>
                <span class="s1">block = new_block(arr</span><span class="s2">, </span><span class="s1">placement=bp</span><span class="s2">, </span><span class="s1">ndim=</span><span class="s5">1</span><span class="s1">)</span>

            <span class="s1">applied = getattr(block</span><span class="s2">, </span><span class="s1">f)(**kwargs)</span>
            <span class="s2">if </span><span class="s1">isinstance(applied</span><span class="s2">, </span><span class="s1">list):</span>
                <span class="s1">applied = applied[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">arr = applied.values</span>
            <span class="s2">if </span><span class="s1">self.ndim == </span><span class="s5">2 </span><span class="s2">and </span><span class="s1">arr.ndim == </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s4"># 2D for np.ndarray or DatetimeArray/TimedeltaArray</span>
                <span class="s2">assert </span><span class="s1">len(arr) == </span><span class="s5">1</span>
                <span class="s4"># error: No overload variant of &quot;__getitem__&quot; of &quot;ExtensionArray&quot;</span>
                <span class="s4"># matches argument type &quot;Tuple[int, slice]&quot;</span>
                <span class="s1">arr = arr[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]  </span><span class="s4"># type: ignore[call-overload]</span>
            <span class="s1">result_arrays.append(arr)</span>

        <span class="s2">return </span><span class="s1">type(self)(result_arrays</span><span class="s2">, </span><span class="s1">self._axes)</span>

    <span class="s2">def </span><span class="s1">setitem(self</span><span class="s2">, </span><span class="s1">indexer</span><span class="s2">, </span><span class="s1">value) -&gt; Self:</span>
        <span class="s2">return </span><span class="s1">self.apply_with_block(</span><span class="s3">&quot;setitem&quot;</span><span class="s2">, </span><span class="s1">indexer=indexer</span><span class="s2">, </span><span class="s1">value=value)</span>

    <span class="s2">def </span><span class="s1">diff(self</span><span class="s2">, </span><span class="s1">n: int) -&gt; Self:</span>
        <span class="s2">assert </span><span class="s1">self.ndim == </span><span class="s5">2  </span><span class="s4"># caller ensures</span>
        <span class="s2">return </span><span class="s1">self.apply(algos.diff</span><span class="s2">, </span><span class="s1">n=n)</span>

    <span class="s2">def </span><span class="s1">astype(self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">copy: bool | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">False, </span><span class="s1">errors: str = </span><span class="s3">&quot;raise&quot;</span><span class="s1">) -&gt; Self:</span>
        <span class="s2">if </span><span class="s1">copy </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">copy = </span><span class="s2">True</span>

        <span class="s2">return </span><span class="s1">self.apply(astype_array_safe</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">copy=copy</span><span class="s2">, </span><span class="s1">errors=errors)</span>

    <span class="s2">def </span><span class="s1">convert(self</span><span class="s2">, </span><span class="s1">copy: bool | </span><span class="s2">None</span><span class="s1">) -&gt; Self:</span>
        <span class="s2">if </span><span class="s1">copy </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">copy = </span><span class="s2">True</span>

        <span class="s2">def </span><span class="s1">_convert(arr):</span>
            <span class="s2">if </span><span class="s1">is_object_dtype(arr.dtype):</span>
                <span class="s4"># extract NumpyExtensionArray for tests that patch</span>
                <span class="s4">#  NumpyExtensionArray._typ</span>
                <span class="s1">arr = np.asarray(arr)</span>
                <span class="s1">result = lib.maybe_convert_objects(</span>
                    <span class="s1">arr</span><span class="s2">,</span>
                    <span class="s1">convert_non_numeric=</span><span class="s2">True,</span>
                <span class="s1">)</span>
                <span class="s2">if </span><span class="s1">result </span><span class="s2">is </span><span class="s1">arr </span><span class="s2">and </span><span class="s1">copy:</span>
                    <span class="s2">return </span><span class="s1">arr.copy()</span>
                <span class="s2">return </span><span class="s1">result</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">arr.copy() </span><span class="s2">if </span><span class="s1">copy </span><span class="s2">else </span><span class="s1">arr</span>

        <span class="s2">return </span><span class="s1">self.apply(_convert)</span>

    <span class="s2">def </span><span class="s1">to_native_types(self</span><span class="s2">, </span><span class="s1">**kwargs) -&gt; Self:</span>
        <span class="s2">return </span><span class="s1">self.apply(to_native_types</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">any_extension_types(self) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;Whether any of the blocks in this manager are extension blocks&quot;&quot;&quot;</span>
        <span class="s2">return False  </span><span class="s4"># any(block.is_extension for block in self.blocks)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">is_view(self) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;return a boolean if we are a single block and are a view&quot;&quot;&quot;</span>
        <span class="s4"># TODO what is this used for?</span>
        <span class="s2">return False</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">is_single_block(self) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">len(self.arrays) == </span><span class="s5">1</span>

    <span class="s2">def </span><span class="s1">_get_data_subset(self</span><span class="s2">, </span><span class="s1">predicate: Callable) -&gt; Self:</span>
        <span class="s1">indices = [i </span><span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">enumerate(self.arrays) </span><span class="s2">if </span><span class="s1">predicate(arr)]</span>
        <span class="s1">arrays = [self.arrays[i] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">indices]</span>
        <span class="s4"># TODO copy?</span>
        <span class="s4"># Note: using Index.take ensures we can retain e.g. DatetimeIndex.freq,</span>
        <span class="s4">#  see test_describe_datetime_columns</span>
        <span class="s1">taker = np.array(indices</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;intp&quot;</span><span class="s1">)</span>
        <span class="s1">new_cols = self._axes[</span><span class="s5">1</span><span class="s1">].take(taker)</span>
        <span class="s1">new_axes = [self._axes[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">new_cols]</span>
        <span class="s2">return </span><span class="s1">type(self)(arrays</span><span class="s2">, </span><span class="s1">new_axes</span><span class="s2">, </span><span class="s1">verify_integrity=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_bool_data(self</span><span class="s2">, </span><span class="s1">copy: bool = </span><span class="s2">False</span><span class="s1">) -&gt; Self:</span>
        <span class="s0">&quot;&quot;&quot; 
        Select columns that are bool-dtype and object-dtype columns that are all-bool. 
 
        Parameters 
        ---------- 
        copy : bool, default False 
            Whether to copy the blocks 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._get_data_subset(</span><span class="s2">lambda </span><span class="s1">x: x.dtype == np.dtype(bool))</span>

    <span class="s2">def </span><span class="s1">get_numeric_data(self</span><span class="s2">, </span><span class="s1">copy: bool = </span><span class="s2">False</span><span class="s1">) -&gt; Self:</span>
        <span class="s0">&quot;&quot;&quot; 
        Select columns that have a numeric dtype. 
 
        Parameters 
        ---------- 
        copy : bool, default False 
            Whether to copy the blocks 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._get_data_subset(</span>
            <span class="s2">lambda </span><span class="s1">arr: is_numeric_dtype(arr.dtype)</span>
            <span class="s2">or </span><span class="s1">getattr(arr.dtype</span><span class="s2">, </span><span class="s3">&quot;_is_numeric&quot;</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">copy(self</span><span class="s2">, </span><span class="s1">deep: bool | Literal[</span><span class="s3">&quot;all&quot;</span><span class="s1">] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">True</span><span class="s1">) -&gt; Self:</span>
        <span class="s0">&quot;&quot;&quot; 
        Make deep or shallow copy of ArrayManager 
 
        Parameters 
        ---------- 
        deep : bool or string, default True 
            If False, return shallow copy (do not copy data) 
            If 'all', copy data and a deep copy of the index 
 
        Returns 
        ------- 
        BlockManager 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">deep </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s4"># ArrayManager does not yet support CoW, so deep=None always means</span>
            <span class="s4"># deep=True for now</span>
            <span class="s1">deep = </span><span class="s2">True</span>

        <span class="s4"># this preserves the notion of view copying of axes</span>
        <span class="s2">if </span><span class="s1">deep:</span>
            <span class="s4"># hit in e.g. tests.io.json.test_pandas</span>

            <span class="s2">def </span><span class="s1">copy_func(ax):</span>
                <span class="s2">return </span><span class="s1">ax.copy(deep=</span><span class="s2">True</span><span class="s1">) </span><span class="s2">if </span><span class="s1">deep == </span><span class="s3">&quot;all&quot; </span><span class="s2">else </span><span class="s1">ax.view()</span>

            <span class="s1">new_axes = [copy_func(ax) </span><span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">self._axes]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">new_axes = list(self._axes)</span>

        <span class="s2">if </span><span class="s1">deep:</span>
            <span class="s1">new_arrays = [arr.copy() </span><span class="s2">for </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">self.arrays]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">new_arrays = list(self.arrays)</span>
        <span class="s2">return </span><span class="s1">type(self)(new_arrays</span><span class="s2">, </span><span class="s1">new_axes</span><span class="s2">, </span><span class="s1">verify_integrity=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">reindex_indexer(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">new_axis</span><span class="s2">,</span>
        <span class="s1">indexer</span><span class="s2">,</span>
        <span class="s1">axis: AxisInt</span><span class="s2">,</span>
        <span class="s1">fill_value=</span><span class="s2">None,</span>
        <span class="s1">allow_dups: bool = </span><span class="s2">False,</span>
        <span class="s1">copy: bool | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">True,</span>
        <span class="s4"># ignored keywords</span>
        <span class="s1">only_slice: bool = </span><span class="s2">False,</span>
        <span class="s4"># ArrayManager specific keywords</span>
        <span class="s1">use_na_proxy: bool = </span><span class="s2">False,</span>
    <span class="s1">) -&gt; Self:</span>
        <span class="s1">axis = self._normalize_axis(axis)</span>
        <span class="s2">return </span><span class="s1">self._reindex_indexer(</span>
            <span class="s1">new_axis</span><span class="s2">,</span>
            <span class="s1">indexer</span><span class="s2">,</span>
            <span class="s1">axis</span><span class="s2">,</span>
            <span class="s1">fill_value</span><span class="s2">,</span>
            <span class="s1">allow_dups</span><span class="s2">,</span>
            <span class="s1">copy</span><span class="s2">,</span>
            <span class="s1">use_na_proxy</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_reindex_indexer(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">new_axis</span><span class="s2">,</span>
        <span class="s1">indexer: npt.NDArray[np.intp] | </span><span class="s2">None,</span>
        <span class="s1">axis: AxisInt</span><span class="s2">,</span>
        <span class="s1">fill_value=</span><span class="s2">None,</span>
        <span class="s1">allow_dups: bool = </span><span class="s2">False,</span>
        <span class="s1">copy: bool | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">True,</span>
        <span class="s1">use_na_proxy: bool = </span><span class="s2">False,</span>
    <span class="s1">) -&gt; Self:</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        new_axis : Index 
        indexer : ndarray[intp] or None 
        axis : int 
        fill_value : object, default None 
        allow_dups : bool, default False 
        copy : bool, default True 
 
 
        pandas-indexer with -1's only. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">copy </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s4"># ArrayManager does not yet support CoW, so deep=None always means</span>
            <span class="s4"># deep=True for now</span>
            <span class="s1">copy = </span><span class="s2">True</span>

        <span class="s2">if </span><span class="s1">indexer </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">new_axis </span><span class="s2">is </span><span class="s1">self._axes[axis] </span><span class="s2">and not </span><span class="s1">copy:</span>
                <span class="s2">return </span><span class="s1">self</span>

            <span class="s1">result = self.copy(deep=copy)</span>
            <span class="s1">result._axes = list(self._axes)</span>
            <span class="s1">result._axes[axis] = new_axis</span>
            <span class="s2">return </span><span class="s1">result</span>

        <span class="s4"># some axes don't allow reindexing with dups</span>
        <span class="s2">if not </span><span class="s1">allow_dups:</span>
            <span class="s1">self._axes[axis]._validate_can_reindex(indexer)</span>

        <span class="s2">if </span><span class="s1">axis &gt;= self.ndim:</span>
            <span class="s2">raise </span><span class="s1">IndexError(</span><span class="s3">&quot;Requested axis not found in manager&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">axis == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">new_arrays = []</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">indexer:</span>
                <span class="s2">if </span><span class="s1">i == -</span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">arr = self._make_na_array(</span>
                        <span class="s1">fill_value=fill_value</span><span class="s2">, </span><span class="s1">use_na_proxy=use_na_proxy</span>
                    <span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">arr = self.arrays[i]</span>
                    <span class="s2">if </span><span class="s1">copy:</span>
                        <span class="s1">arr = arr.copy()</span>
                <span class="s1">new_arrays.append(arr)</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">validate_indices(indexer</span><span class="s2">, </span><span class="s1">len(self._axes[</span><span class="s5">0</span><span class="s1">]))</span>
            <span class="s1">indexer = ensure_platform_int(indexer)</span>
            <span class="s1">mask = indexer == -</span><span class="s5">1</span>
            <span class="s1">needs_masking = mask.any()</span>
            <span class="s1">new_arrays = [</span>
                <span class="s1">take_1d(</span>
                    <span class="s1">arr</span><span class="s2">,</span>
                    <span class="s1">indexer</span><span class="s2">,</span>
                    <span class="s1">allow_fill=needs_masking</span><span class="s2">,</span>
                    <span class="s1">fill_value=fill_value</span><span class="s2">,</span>
                    <span class="s1">mask=mask</span><span class="s2">,</span>
                    <span class="s4"># if fill_value is not None else blk.fill_value</span>
                <span class="s1">)</span>
                <span class="s2">for </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">self.arrays</span>
            <span class="s1">]</span>

        <span class="s1">new_axes = list(self._axes)</span>
        <span class="s1">new_axes[axis] = new_axis</span>

        <span class="s2">return </span><span class="s1">type(self)(new_arrays</span><span class="s2">, </span><span class="s1">new_axes</span><span class="s2">, </span><span class="s1">verify_integrity=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">take(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">indexer: npt.NDArray[np.intp]</span><span class="s2">,</span>
        <span class="s1">axis: AxisInt = </span><span class="s5">1</span><span class="s2">,</span>
        <span class="s1">verify: bool = </span><span class="s2">True,</span>
    <span class="s1">) -&gt; Self:</span>
        <span class="s0">&quot;&quot;&quot; 
        Take items along any axis. 
        &quot;&quot;&quot;</span>
        <span class="s2">assert </span><span class="s1">isinstance(indexer</span><span class="s2">, </span><span class="s1">np.ndarray)</span><span class="s2">, </span><span class="s1">type(indexer)</span>
        <span class="s2">assert </span><span class="s1">indexer.dtype == np.intp</span><span class="s2">, </span><span class="s1">indexer.dtype</span>

        <span class="s1">axis = self._normalize_axis(axis)</span>

        <span class="s2">if not </span><span class="s1">indexer.ndim == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;indexer should be 1-dimensional&quot;</span><span class="s1">)</span>

        <span class="s1">n = self.shape_proper[axis]</span>
        <span class="s1">indexer = maybe_convert_indices(indexer</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">verify=verify)</span>

        <span class="s1">new_labels = self._axes[axis].take(indexer)</span>
        <span class="s2">return </span><span class="s1">self._reindex_indexer(</span>
            <span class="s1">new_axis=new_labels</span><span class="s2">, </span><span class="s1">indexer=indexer</span><span class="s2">, </span><span class="s1">axis=axis</span><span class="s2">, </span><span class="s1">allow_dups=</span><span class="s2">True</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_make_na_array(self</span><span class="s2">, </span><span class="s1">fill_value=</span><span class="s2">None, </span><span class="s1">use_na_proxy: bool = </span><span class="s2">False</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">use_na_proxy:</span>
            <span class="s2">assert </span><span class="s1">fill_value </span><span class="s2">is None</span>
            <span class="s2">return </span><span class="s1">NullArrayProxy(self.shape_proper[</span><span class="s5">0</span><span class="s1">])</span>

        <span class="s2">if </span><span class="s1">fill_value </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">fill_value = np.nan</span>

        <span class="s1">dtype</span><span class="s2">, </span><span class="s1">fill_value = infer_dtype_from_scalar(fill_value)</span>
        <span class="s1">array_values = make_na_array(dtype</span><span class="s2">, </span><span class="s1">self.shape_proper[:</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">fill_value)</span>
        <span class="s2">return </span><span class="s1">array_values</span>

    <span class="s2">def </span><span class="s1">_equal_values(self</span><span class="s2">, </span><span class="s1">other) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot; 
        Used in .equals defined in base class. Only check the column values 
        assuming shape and indexes have already been checked. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right </span><span class="s2">in </span><span class="s1">zip(self.arrays</span><span class="s2">, </span><span class="s1">other.arrays):</span>
            <span class="s2">if not </span><span class="s1">array_equals(left</span><span class="s2">, </span><span class="s1">right):</span>
                <span class="s2">return False</span>
        <span class="s2">return True</span>

    <span class="s4"># TODO</span>
    <span class="s4"># to_dict</span>


<span class="s2">class </span><span class="s1">ArrayManager(BaseArrayManager):</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">ndim(self) -&gt; Literal[</span><span class="s5">2</span><span class="s1">]:</span>
        <span class="s2">return </span><span class="s5">2</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">arrays: list[np.ndarray | ExtensionArray]</span><span class="s2">,</span>
        <span class="s1">axes: list[Index]</span><span class="s2">,</span>
        <span class="s1">verify_integrity: bool = </span><span class="s2">True,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s4"># Note: we are storing the axes in &quot;_axes&quot; in the (row, columns) order</span>
        <span class="s4"># which contrasts the order how it is stored in BlockManager</span>
        <span class="s1">self._axes = axes</span>
        <span class="s1">self.arrays = arrays</span>

        <span class="s2">if </span><span class="s1">verify_integrity:</span>
            <span class="s1">self._axes = [ensure_index(ax) </span><span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">axes]</span>
            <span class="s1">arrays = [extract_pandas_array(x</span><span class="s2">, None, </span><span class="s5">1</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">arrays]</span>
            <span class="s1">self.arrays = [maybe_coerce_values(arr) </span><span class="s2">for </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">arrays]</span>
            <span class="s1">self._verify_integrity()</span>

    <span class="s2">def </span><span class="s1">_verify_integrity(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">n_rows</span><span class="s2">, </span><span class="s1">n_columns = self.shape_proper</span>
        <span class="s2">if not </span><span class="s1">len(self.arrays) == n_columns:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;Number of passed arrays must equal the size of the column Index: &quot;</span>
                <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">len(self.arrays)</span><span class="s2">} </span><span class="s3">arrays vs </span><span class="s2">{</span><span class="s1">n_columns</span><span class="s2">} </span><span class="s3">columns.&quot;</span>
            <span class="s1">)</span>
        <span class="s2">for </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">self.arrays:</span>
            <span class="s2">if not </span><span class="s1">len(arr) == n_rows:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;Passed arrays should have the same length as the rows Index: &quot;</span>
                    <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">len(arr)</span><span class="s2">} </span><span class="s3">vs </span><span class="s2">{</span><span class="s1">n_rows</span><span class="s2">} </span><span class="s3">rows&quot;</span>
                <span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">isinstance(arr</span><span class="s2">, </span><span class="s1">(np.ndarray</span><span class="s2">, </span><span class="s1">ExtensionArray)):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;Passed arrays should be np.ndarray or ExtensionArray instances, &quot;</span>
                    <span class="s3">f&quot;got </span><span class="s2">{</span><span class="s1">type(arr)</span><span class="s2">} </span><span class="s3">instead&quot;</span>
                <span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">arr.ndim == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;Passed arrays should be 1-dimensional, got array with &quot;</span>
                    <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">arr.ndim</span><span class="s2">} </span><span class="s3">dimensions instead.&quot;</span>
                <span class="s1">)</span>

    <span class="s4"># --------------------------------------------------------------------</span>
    <span class="s4"># Indexing</span>

    <span class="s2">def </span><span class="s1">fast_xs(self</span><span class="s2">, </span><span class="s1">loc: int) -&gt; SingleArrayManager:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the array corresponding to `frame.iloc[loc]`. 
 
        Parameters 
        ---------- 
        loc : int 
 
        Returns 
        ------- 
        np.ndarray or ExtensionArray 
        &quot;&quot;&quot;</span>
        <span class="s1">dtype = interleaved_dtype([arr.dtype </span><span class="s2">for </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">self.arrays])</span>

        <span class="s1">values = [arr[loc] </span><span class="s2">for </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">self.arrays]</span>
        <span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">ExtensionDtype):</span>
            <span class="s1">result = dtype.construct_array_type()._from_sequence(values</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s4"># for datetime64/timedelta64, the np.ndarray constructor cannot handle pd.NaT</span>
        <span class="s2">elif </span><span class="s1">is_datetime64_ns_dtype(dtype):</span>
            <span class="s1">result = DatetimeArray._from_sequence(values</span><span class="s2">, </span><span class="s1">dtype=dtype)._ndarray</span>
        <span class="s2">elif </span><span class="s1">is_timedelta64_ns_dtype(dtype):</span>
            <span class="s1">result = TimedeltaArray._from_sequence(values</span><span class="s2">, </span><span class="s1">dtype=dtype)._ndarray</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">result = np.array(values</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s2">return </span><span class="s1">SingleArrayManager([result]</span><span class="s2">, </span><span class="s1">[self._axes[</span><span class="s5">1</span><span class="s1">]])</span>

    <span class="s2">def </span><span class="s1">get_slice(self</span><span class="s2">, </span><span class="s1">slobj: slice</span><span class="s2">, </span><span class="s1">axis: AxisInt = </span><span class="s5">0</span><span class="s1">) -&gt; ArrayManager:</span>
        <span class="s1">axis = self._normalize_axis(axis)</span>

        <span class="s2">if </span><span class="s1">axis == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">arrays = [arr[slobj] </span><span class="s2">for </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">self.arrays]</span>
        <span class="s2">elif </span><span class="s1">axis == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">arrays = self.arrays[slobj]</span>

        <span class="s1">new_axes = list(self._axes)</span>
        <span class="s1">new_axes[axis] = new_axes[axis]._getitem_slice(slobj)</span>

        <span class="s2">return </span><span class="s1">type(self)(arrays</span><span class="s2">, </span><span class="s1">new_axes</span><span class="s2">, </span><span class="s1">verify_integrity=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">iget(self</span><span class="s2">, </span><span class="s1">i: int) -&gt; SingleArrayManager:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the data as a SingleArrayManager. 
        &quot;&quot;&quot;</span>
        <span class="s1">values = self.arrays[i]</span>
        <span class="s2">return </span><span class="s1">SingleArrayManager([values]</span><span class="s2">, </span><span class="s1">[self._axes[</span><span class="s5">0</span><span class="s1">]])</span>

    <span class="s2">def </span><span class="s1">iget_values(self</span><span class="s2">, </span><span class="s1">i: int) -&gt; ArrayLike:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the data for column i as the values (ndarray or ExtensionArray). 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.arrays[i]</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">column_arrays(self) -&gt; list[ArrayLike]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Used in the JSON C code to access column arrays. 
        &quot;&quot;&quot;</span>

        <span class="s2">return </span><span class="s1">[np.asarray(arr) </span><span class="s2">for </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">self.arrays]</span>

    <span class="s2">def </span><span class="s1">iset(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">loc: int | slice | np.ndarray</span><span class="s2">,</span>
        <span class="s1">value: ArrayLike</span><span class="s2">,</span>
        <span class="s1">inplace: bool = </span><span class="s2">False,</span>
        <span class="s1">refs=</span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Set new column(s). 
 
        This changes the ArrayManager in-place, but replaces (an) existing 
        column(s), not changing column values in-place). 
 
        Parameters 
        ---------- 
        loc : integer, slice or boolean mask 
            Positional location (already bounds checked) 
        value : np.ndarray or ExtensionArray 
        inplace : bool, default False 
            Whether overwrite existing array as opposed to replacing it. 
        &quot;&quot;&quot;</span>
        <span class="s4"># single column -&gt; single integer index</span>
        <span class="s2">if </span><span class="s1">lib.is_integer(loc):</span>
            <span class="s4"># TODO can we avoid needing to unpack this here? That means converting</span>
            <span class="s4"># DataFrame into 1D array when loc is an integer</span>
            <span class="s2">if </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">np.ndarray) </span><span class="s2">and </span><span class="s1">value.ndim == </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s2">assert </span><span class="s1">value.shape[</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">1</span>
                <span class="s1">value = value[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span>

            <span class="s4"># TODO we receive a datetime/timedelta64 ndarray from DataFrame._iset_item</span>
            <span class="s4"># but we should avoid that and pass directly the proper array</span>
            <span class="s1">value = maybe_coerce_values(value)</span>

            <span class="s2">assert </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">(np.ndarray</span><span class="s2">, </span><span class="s1">ExtensionArray))</span>
            <span class="s2">assert </span><span class="s1">value.ndim == </span><span class="s5">1</span>
            <span class="s2">assert </span><span class="s1">len(value) == len(self._axes[</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s1">self.arrays[loc] = value</span>
            <span class="s2">return</span>

        <span class="s4"># multiple columns -&gt; convert slice or array to integer indices</span>
        <span class="s2">elif </span><span class="s1">isinstance(loc</span><span class="s2">, </span><span class="s1">slice):</span>
            <span class="s1">indices: range | np.ndarray = range(</span>
                <span class="s1">loc.start </span><span class="s2">if </span><span class="s1">loc.start </span><span class="s2">is not None else </span><span class="s5">0</span><span class="s2">,</span>
                <span class="s1">loc.stop </span><span class="s2">if </span><span class="s1">loc.stop </span><span class="s2">is not None else </span><span class="s1">self.shape_proper[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">loc.step </span><span class="s2">if </span><span class="s1">loc.step </span><span class="s2">is not None else </span><span class="s5">1</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">isinstance(loc</span><span class="s2">, </span><span class="s1">np.ndarray)</span>
            <span class="s2">assert </span><span class="s1">loc.dtype == </span><span class="s3">&quot;bool&quot;</span>
            <span class="s1">indices = np.nonzero(loc)[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s2">assert </span><span class="s1">value.ndim == </span><span class="s5">2</span>
        <span class="s2">assert </span><span class="s1">value.shape[</span><span class="s5">0</span><span class="s1">] == len(self._axes[</span><span class="s5">0</span><span class="s1">])</span>

        <span class="s2">for </span><span class="s1">value_idx</span><span class="s2">, </span><span class="s1">mgr_idx </span><span class="s2">in </span><span class="s1">enumerate(indices):</span>
            <span class="s4"># error: No overload variant of &quot;__getitem__&quot; of &quot;ExtensionArray&quot; matches</span>
            <span class="s4"># argument type &quot;Tuple[slice, int]&quot;</span>
            <span class="s1">value_arr = value[:</span><span class="s2">, </span><span class="s1">value_idx]  </span><span class="s4"># type: ignore[call-overload]</span>
            <span class="s1">self.arrays[mgr_idx] = value_arr</span>
        <span class="s2">return</span>

    <span class="s2">def </span><span class="s1">column_setitem(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">loc: int</span><span class="s2">, </span><span class="s1">idx: int | slice | np.ndarray</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">inplace_only: bool = </span><span class="s2">False</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Set values (&quot;setitem&quot;) into a single column (not setting the full column). 
 
        This is a method on the ArrayManager level, to avoid creating an 
        intermediate Series at the DataFrame level (`s = df[loc]; s[idx] = value`) 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">is_integer(loc):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;The column index should be an integer&quot;</span><span class="s1">)</span>
        <span class="s1">arr = self.arrays[loc]</span>
        <span class="s1">mgr = SingleArrayManager([arr]</span><span class="s2">, </span><span class="s1">[self._axes[</span><span class="s5">0</span><span class="s1">]])</span>
        <span class="s2">if </span><span class="s1">inplace_only:</span>
            <span class="s1">mgr.setitem_inplace(idx</span><span class="s2">, </span><span class="s1">value)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">new_mgr = mgr.setitem((idx</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">value)</span>
            <span class="s4"># update existing ArrayManager in-place</span>
            <span class="s1">self.arrays[loc] = new_mgr.arrays[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">insert(self</span><span class="s2">, </span><span class="s1">loc: int</span><span class="s2">, </span><span class="s1">item: Hashable</span><span class="s2">, </span><span class="s1">value: ArrayLike</span><span class="s2">, </span><span class="s1">refs=</span><span class="s2">None</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Insert item at selected position. 
 
        Parameters 
        ---------- 
        loc : int 
        item : hashable 
        value : np.ndarray or ExtensionArray 
        &quot;&quot;&quot;</span>
        <span class="s4"># insert to the axis; this could possibly raise a TypeError</span>
        <span class="s1">new_axis = self.items.insert(loc</span><span class="s2">, </span><span class="s1">item)</span>

        <span class="s1">value = extract_array(value</span><span class="s2">, </span><span class="s1">extract_numpy=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">value.ndim == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">value.shape[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s4"># error: No overload variant of &quot;__getitem__&quot; of &quot;ExtensionArray&quot;</span>
                <span class="s4"># matches argument type &quot;Tuple[int, slice]&quot;</span>
                <span class="s1">value = value[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]  </span><span class="s4"># type: ignore[call-overload]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">f&quot;Expected a 1D array, got an array with shape </span><span class="s2">{</span><span class="s1">value.shape</span><span class="s2">}</span><span class="s3">&quot;</span>
                <span class="s1">)</span>
        <span class="s1">value = maybe_coerce_values(value)</span>

        <span class="s4"># TODO self.arrays can be empty</span>
        <span class="s4"># assert len(value) == len(self.arrays[0])</span>

        <span class="s4"># TODO is this copy needed?</span>
        <span class="s1">arrays = self.arrays.copy()</span>
        <span class="s1">arrays.insert(loc</span><span class="s2">, </span><span class="s1">value)</span>

        <span class="s1">self.arrays = arrays</span>
        <span class="s1">self._axes[</span><span class="s5">1</span><span class="s1">] = new_axis</span>

    <span class="s2">def </span><span class="s1">idelete(self</span><span class="s2">, </span><span class="s1">indexer) -&gt; ArrayManager:</span>
        <span class="s0">&quot;&quot;&quot; 
        Delete selected locations in-place (new block and array, same BlockManager) 
        &quot;&quot;&quot;</span>
        <span class="s1">to_keep = np.ones(self.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=np.bool_)</span>
        <span class="s1">to_keep[indexer] = </span><span class="s2">False</span>

        <span class="s1">self.arrays = [self.arrays[i] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">np.nonzero(to_keep)[</span><span class="s5">0</span><span class="s1">]]</span>
        <span class="s1">self._axes = [self._axes[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self._axes[</span><span class="s5">1</span><span class="s1">][to_keep]]</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s4"># --------------------------------------------------------------------</span>
    <span class="s4"># Array-wise Operation</span>

    <span class="s2">def </span><span class="s1">grouped_reduce(self</span><span class="s2">, </span><span class="s1">func: Callable) -&gt; Self:</span>
        <span class="s0">&quot;&quot;&quot; 
        Apply grouped reduction function columnwise, returning a new ArrayManager. 
 
        Parameters 
        ---------- 
        func : grouped reduction function 
 
        Returns 
        ------- 
        ArrayManager 
        &quot;&quot;&quot;</span>
        <span class="s1">result_arrays: list[np.ndarray] = []</span>
        <span class="s1">result_indices: list[int] = []</span>

        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">enumerate(self.arrays):</span>
            <span class="s4"># grouped_reduce functions all expect 2D arrays</span>
            <span class="s1">arr = ensure_block_shape(arr</span><span class="s2">, </span><span class="s1">ndim=</span><span class="s5">2</span><span class="s1">)</span>
            <span class="s1">res = func(arr)</span>
            <span class="s2">if </span><span class="s1">res.ndim == </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s4"># reverse of ensure_block_shape</span>
                <span class="s2">assert </span><span class="s1">res.shape[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">1</span>
                <span class="s1">res = res[</span><span class="s5">0</span><span class="s1">]</span>

            <span class="s1">result_arrays.append(res)</span>
            <span class="s1">result_indices.append(i)</span>

        <span class="s2">if </span><span class="s1">len(result_arrays) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">nrows = </span><span class="s5">0</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">nrows = result_arrays[</span><span class="s5">0</span><span class="s1">].shape[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">index = Index(range(nrows))</span>

        <span class="s1">columns = self.items</span>

        <span class="s4"># error: Argument 1 to &quot;ArrayManager&quot; has incompatible type &quot;List[ndarray]&quot;;</span>
        <span class="s4"># expected &quot;List[Union[ndarray, ExtensionArray]]&quot;</span>
        <span class="s2">return </span><span class="s1">type(self)(result_arrays</span><span class="s2">, </span><span class="s1">[index</span><span class="s2">, </span><span class="s1">columns])  </span><span class="s4"># type: ignore[arg-type]</span>

    <span class="s2">def </span><span class="s1">reduce(self</span><span class="s2">, </span><span class="s1">func: Callable) -&gt; Self:</span>
        <span class="s0">&quot;&quot;&quot; 
        Apply reduction function column-wise, returning a single-row ArrayManager. 
 
        Parameters 
        ---------- 
        func : reduction function 
 
        Returns 
        ------- 
        ArrayManager 
        &quot;&quot;&quot;</span>
        <span class="s1">result_arrays: list[np.ndarray] = []</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">enumerate(self.arrays):</span>
            <span class="s1">res = func(arr</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>

            <span class="s4"># TODO NaT doesn't preserve dtype, so we need to ensure to create</span>
            <span class="s4"># a timedelta result array if original was timedelta</span>
            <span class="s4"># what if datetime results in timedelta? (eg std)</span>
            <span class="s1">dtype = arr.dtype </span><span class="s2">if </span><span class="s1">res </span><span class="s2">is </span><span class="s1">NaT </span><span class="s2">else None</span>
            <span class="s1">result_arrays.append(</span>
                <span class="s1">sanitize_array([res]</span><span class="s2">, None, </span><span class="s1">dtype=dtype)  </span><span class="s4"># type: ignore[arg-type]</span>
            <span class="s1">)</span>

        <span class="s1">index = Index._simple_new(np.array([</span><span class="s2">None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=object))  </span><span class="s4"># placeholder</span>
        <span class="s1">columns = self.items</span>

        <span class="s4"># error: Argument 1 to &quot;ArrayManager&quot; has incompatible type &quot;List[ndarray]&quot;;</span>
        <span class="s4"># expected &quot;List[Union[ndarray, ExtensionArray]]&quot;</span>
        <span class="s1">new_mgr = type(self)(result_arrays</span><span class="s2">, </span><span class="s1">[index</span><span class="s2">, </span><span class="s1">columns])  </span><span class="s4"># type: ignore[arg-type]</span>
        <span class="s2">return </span><span class="s1">new_mgr</span>

    <span class="s2">def </span><span class="s1">operate_blockwise(self</span><span class="s2">, </span><span class="s1">other: ArrayManager</span><span class="s2">, </span><span class="s1">array_op) -&gt; ArrayManager:</span>
        <span class="s0">&quot;&quot;&quot; 
        Apply array_op blockwise with another (aligned) BlockManager. 
        &quot;&quot;&quot;</span>
        <span class="s4"># TODO what if `other` is BlockManager ?</span>
        <span class="s1">left_arrays = self.arrays</span>
        <span class="s1">right_arrays = other.arrays</span>
        <span class="s1">result_arrays = [</span>
            <span class="s1">array_op(left</span><span class="s2">, </span><span class="s1">right) </span><span class="s2">for </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right </span><span class="s2">in </span><span class="s1">zip(left_arrays</span><span class="s2">, </span><span class="s1">right_arrays)</span>
        <span class="s1">]</span>
        <span class="s2">return </span><span class="s1">type(self)(result_arrays</span><span class="s2">, </span><span class="s1">self._axes)</span>

    <span class="s2">def </span><span class="s1">quantile(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">qs: Index</span><span class="s2">,  </span><span class="s4"># with dtype float64</span>
        <span class="s1">transposed: bool = </span><span class="s2">False,</span>
        <span class="s1">interpolation: QuantileInterpolation = </span><span class="s3">&quot;linear&quot;</span><span class="s2">,</span>
    <span class="s1">) -&gt; ArrayManager:</span>
        <span class="s1">arrs = [ensure_block_shape(x</span><span class="s2">, </span><span class="s5">2</span><span class="s1">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self.arrays]</span>
        <span class="s1">new_arrs = [</span>
            <span class="s1">quantile_compat(x</span><span class="s2">, </span><span class="s1">np.asarray(qs._values)</span><span class="s2">, </span><span class="s1">interpolation) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">arrs</span>
        <span class="s1">]</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">enumerate(new_arrs):</span>
            <span class="s2">if </span><span class="s1">arr.ndim == </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s2">assert </span><span class="s1">arr.shape[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">1</span><span class="s2">, </span><span class="s1">arr.shape</span>
                <span class="s1">new_arrs[i] = arr[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s1">axes = [qs</span><span class="s2">, </span><span class="s1">self._axes[</span><span class="s5">1</span><span class="s1">]]</span>
        <span class="s2">return </span><span class="s1">type(self)(new_arrs</span><span class="s2">, </span><span class="s1">axes)</span>

    <span class="s4"># ----------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">unstack(self</span><span class="s2">, </span><span class="s1">unstacker</span><span class="s2">, </span><span class="s1">fill_value) -&gt; ArrayManager:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a BlockManager with all blocks unstacked. 
 
        Parameters 
        ---------- 
        unstacker : reshape._Unstacker 
        fill_value : Any 
            fill_value for newly introduced missing values. 
 
        Returns 
        ------- 
        unstacked : BlockManager 
        &quot;&quot;&quot;</span>
        <span class="s1">indexer</span><span class="s2">, </span><span class="s1">_ = unstacker._indexer_and_to_sort</span>
        <span class="s2">if </span><span class="s1">unstacker.mask.all():</span>
            <span class="s1">new_indexer = indexer</span>
            <span class="s1">allow_fill = </span><span class="s2">False</span>
            <span class="s1">new_mask2D = </span><span class="s2">None</span>
            <span class="s1">needs_masking = </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">new_indexer = np.full(unstacker.mask.shape</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">new_indexer[unstacker.mask] = indexer</span>
            <span class="s1">allow_fill = </span><span class="s2">True</span>
            <span class="s4"># calculating the full mask once and passing it to take_1d is faster</span>
            <span class="s4"># than letting take_1d calculate it in each repeated call</span>
            <span class="s1">new_mask2D = (~unstacker.mask).reshape(*unstacker.full_shape)</span>
            <span class="s1">needs_masking = new_mask2D.any(axis=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">new_indexer2D = new_indexer.reshape(*unstacker.full_shape)</span>
        <span class="s1">new_indexer2D = ensure_platform_int(new_indexer2D)</span>

        <span class="s1">new_arrays = []</span>
        <span class="s2">for </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">self.arrays:</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(unstacker.full_shape[</span><span class="s5">1</span><span class="s1">]):</span>
                <span class="s2">if </span><span class="s1">allow_fill:</span>
                    <span class="s4"># error: Value of type &quot;Optional[Any]&quot; is not indexable  [index]</span>
                    <span class="s1">new_arr = take_1d(</span>
                        <span class="s1">arr</span><span class="s2">,</span>
                        <span class="s1">new_indexer2D[:</span><span class="s2">, </span><span class="s1">i]</span><span class="s2">,</span>
                        <span class="s1">allow_fill=needs_masking[i]</span><span class="s2">,  </span><span class="s4"># type: ignore[index]</span>
                        <span class="s1">fill_value=fill_value</span><span class="s2">,</span>
                        <span class="s1">mask=new_mask2D[:</span><span class="s2">, </span><span class="s1">i]</span><span class="s2">,  </span><span class="s4"># type: ignore[index]</span>
                    <span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">new_arr = take_1d(arr</span><span class="s2">, </span><span class="s1">new_indexer2D[:</span><span class="s2">, </span><span class="s1">i]</span><span class="s2">, </span><span class="s1">allow_fill=</span><span class="s2">False</span><span class="s1">)</span>
                <span class="s1">new_arrays.append(new_arr)</span>

        <span class="s1">new_index = unstacker.new_index</span>
        <span class="s1">new_columns = unstacker.get_new_columns(self._axes[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">new_axes = [new_index</span><span class="s2">, </span><span class="s1">new_columns]</span>

        <span class="s2">return </span><span class="s1">type(self)(new_arrays</span><span class="s2">, </span><span class="s1">new_axes</span><span class="s2">, </span><span class="s1">verify_integrity=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">as_array(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">dtype=</span><span class="s2">None,</span>
        <span class="s1">copy: bool = </span><span class="s2">False,</span>
        <span class="s1">na_value: object = lib.no_default</span><span class="s2">,</span>
    <span class="s1">) -&gt; np.ndarray:</span>
        <span class="s0">&quot;&quot;&quot; 
        Convert the blockmanager data into an numpy array. 
 
        Parameters 
        ---------- 
        dtype : object, default None 
            Data type of the return array. 
        copy : bool, default False 
            If True then guarantee that a copy is returned. A value of 
            False does not guarantee that the underlying data is not 
            copied. 
        na_value : object, default lib.no_default 
            Value to be used as the missing value sentinel. 
 
        Returns 
        ------- 
        arr : ndarray 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len(self.arrays) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">empty_arr = np.empty(self.shape</span><span class="s2">, </span><span class="s1">dtype=float)</span>
            <span class="s2">return </span><span class="s1">empty_arr.transpose()</span>

        <span class="s4"># We want to copy when na_value is provided to avoid</span>
        <span class="s4"># mutating the original object</span>
        <span class="s1">copy = copy </span><span class="s2">or </span><span class="s1">na_value </span><span class="s2">is not </span><span class="s1">lib.no_default</span>

        <span class="s2">if not </span><span class="s1">dtype:</span>
            <span class="s1">dtype = interleaved_dtype([arr.dtype </span><span class="s2">for </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">self.arrays])</span>

        <span class="s1">dtype = ensure_np_dtype(dtype)</span>

        <span class="s1">result = np.empty(self.shape_proper</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">enumerate(self.arrays):</span>
            <span class="s1">arr = arr.astype(dtype</span><span class="s2">, </span><span class="s1">copy=copy)</span>
            <span class="s1">result[:</span><span class="s2">, </span><span class="s1">i] = arr</span>

        <span class="s2">if </span><span class="s1">na_value </span><span class="s2">is not </span><span class="s1">lib.no_default:</span>
            <span class="s1">result[isna(result)] = na_value</span>

        <span class="s2">return </span><span class="s1">result</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">concat_horizontal(cls</span><span class="s2">, </span><span class="s1">mgrs: list[Self]</span><span class="s2">, </span><span class="s1">axes: list[Index]) -&gt; Self:</span>
        <span class="s0">&quot;&quot;&quot; 
        Concatenate uniformly-indexed ArrayManagers horizontally. 
        &quot;&quot;&quot;</span>
        <span class="s4"># concatting along the columns -&gt; combine reindexed arrays in a single manager</span>
        <span class="s1">arrays = list(itertools.chain.from_iterable([mgr.arrays </span><span class="s2">for </span><span class="s1">mgr </span><span class="s2">in </span><span class="s1">mgrs]))</span>
        <span class="s1">new_mgr = cls(arrays</span><span class="s2">, </span><span class="s1">[axes[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">axes[</span><span class="s5">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">verify_integrity=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">new_mgr</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">concat_vertical(cls</span><span class="s2">, </span><span class="s1">mgrs: list[Self]</span><span class="s2">, </span><span class="s1">axes: list[Index]) -&gt; Self:</span>
        <span class="s0">&quot;&quot;&quot; 
        Concatenate uniformly-indexed ArrayManagers vertically. 
        &quot;&quot;&quot;</span>
        <span class="s4"># concatting along the rows -&gt; concat the reindexed arrays</span>
        <span class="s4"># TODO(ArrayManager) doesn't yet preserve the correct dtype</span>
        <span class="s1">arrays = [</span>
            <span class="s1">concat_arrays([mgrs[i].arrays[j] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(mgrs))])</span>
            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(len(mgrs[</span><span class="s5">0</span><span class="s1">].arrays))</span>
        <span class="s1">]</span>
        <span class="s1">new_mgr = cls(arrays</span><span class="s2">, </span><span class="s1">[axes[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">axes[</span><span class="s5">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">verify_integrity=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">new_mgr</span>


<span class="s2">class </span><span class="s1">SingleArrayManager(BaseArrayManager</span><span class="s2">, </span><span class="s1">SingleDataManager):</span>
    <span class="s1">__slots__ = [</span>
        <span class="s3">&quot;_axes&quot;</span><span class="s2">,  </span><span class="s4"># private attribute, because 'axes' has different order, see below</span>
        <span class="s3">&quot;arrays&quot;</span><span class="s2">,</span>
    <span class="s1">]</span>

    <span class="s1">arrays: list[np.ndarray | ExtensionArray]</span>
    <span class="s1">_axes: list[Index]</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">ndim(self) -&gt; Literal[</span><span class="s5">1</span><span class="s1">]:</span>
        <span class="s2">return </span><span class="s5">1</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">arrays: list[np.ndarray | ExtensionArray]</span><span class="s2">,</span>
        <span class="s1">axes: list[Index]</span><span class="s2">,</span>
        <span class="s1">verify_integrity: bool = </span><span class="s2">True,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._axes = axes</span>
        <span class="s1">self.arrays = arrays</span>

        <span class="s2">if </span><span class="s1">verify_integrity:</span>
            <span class="s2">assert </span><span class="s1">len(axes) == </span><span class="s5">1</span>
            <span class="s2">assert </span><span class="s1">len(arrays) == </span><span class="s5">1</span>
            <span class="s1">self._axes = [ensure_index(ax) </span><span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">self._axes]</span>
            <span class="s1">arr = arrays[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">arr = maybe_coerce_values(arr)</span>
            <span class="s1">arr = extract_pandas_array(arr</span><span class="s2">, None, </span><span class="s5">1</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">self.arrays = [arr]</span>
            <span class="s1">self._verify_integrity()</span>

    <span class="s2">def </span><span class="s1">_verify_integrity(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">(n_rows</span><span class="s2">,</span><span class="s1">) = self.shape</span>
        <span class="s2">assert </span><span class="s1">len(self.arrays) == </span><span class="s5">1</span>
        <span class="s1">arr = self.arrays[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">assert </span><span class="s1">len(arr) == n_rows</span>
        <span class="s2">if not </span><span class="s1">arr.ndim == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;Passed array should be 1-dimensional, got array with &quot;</span>
                <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">arr.ndim</span><span class="s2">} </span><span class="s3">dimensions instead.&quot;</span>
            <span class="s1">)</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_normalize_axis(axis):</span>
        <span class="s2">return </span><span class="s1">axis</span>

    <span class="s2">def </span><span class="s1">make_empty(self</span><span class="s2">, </span><span class="s1">axes=</span><span class="s2">None</span><span class="s1">) -&gt; SingleArrayManager:</span>
        <span class="s0">&quot;&quot;&quot;Return an empty ArrayManager with index/array of length 0&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">axes </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">axes = [Index([]</span><span class="s2">, </span><span class="s1">dtype=object)]</span>
        <span class="s1">array: np.ndarray = np.array([]</span><span class="s2">, </span><span class="s1">dtype=self.dtype)</span>
        <span class="s2">return </span><span class="s1">type(self)([array]</span><span class="s2">, </span><span class="s1">axes)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_array(cls</span><span class="s2">, </span><span class="s1">array</span><span class="s2">, </span><span class="s1">index) -&gt; SingleArrayManager:</span>
        <span class="s2">return </span><span class="s1">cls([array]</span><span class="s2">, </span><span class="s1">[index])</span>

    <span class="s4"># error: Cannot override writeable attribute with read-only property</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">axes(self) -&gt; list[Index]:  </span><span class="s4"># type: ignore[override]</span>
        <span class="s2">return </span><span class="s1">self._axes</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">index(self) -&gt; Index:</span>
        <span class="s2">return </span><span class="s1">self._axes[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">dtype(self):</span>
        <span class="s2">return </span><span class="s1">self.array.dtype</span>

    <span class="s2">def </span><span class="s1">external_values(self):</span>
        <span class="s0">&quot;&quot;&quot;The array that Series.values returns&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">external_values(self.array)</span>

    <span class="s2">def </span><span class="s1">internal_values(self):</span>
        <span class="s0">&quot;&quot;&quot;The array that Series._values returns&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.array</span>

    <span class="s2">def </span><span class="s1">array_values(self):</span>
        <span class="s0">&quot;&quot;&quot;The array that Series.array returns&quot;&quot;&quot;</span>
        <span class="s1">arr = self.array</span>
        <span class="s2">if </span><span class="s1">isinstance(arr</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
            <span class="s1">arr = NumpyExtensionArray(arr)</span>
        <span class="s2">return </span><span class="s1">arr</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_can_hold_na(self) -&gt; bool:</span>
        <span class="s2">if </span><span class="s1">isinstance(self.array</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
            <span class="s2">return </span><span class="s1">self.array.dtype.kind </span><span class="s2">not in </span><span class="s3">&quot;iub&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># ExtensionArray</span>
            <span class="s2">return </span><span class="s1">self.array._can_hold_na</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">is_single_block(self) -&gt; bool:</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">fast_xs(self</span><span class="s2">, </span><span class="s1">loc: int) -&gt; SingleArrayManager:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">&quot;Use series._values[loc] instead&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_slice(self</span><span class="s2">, </span><span class="s1">slobj: slice</span><span class="s2">, </span><span class="s1">axis: AxisInt = </span><span class="s5">0</span><span class="s1">) -&gt; SingleArrayManager:</span>
        <span class="s2">if </span><span class="s1">axis &gt;= self.ndim:</span>
            <span class="s2">raise </span><span class="s1">IndexError(</span><span class="s3">&quot;Requested axis not found in manager&quot;</span><span class="s1">)</span>

        <span class="s1">new_array = self.array[slobj]</span>
        <span class="s1">new_index = self.index._getitem_slice(slobj)</span>
        <span class="s2">return </span><span class="s1">type(self)([new_array]</span><span class="s2">, </span><span class="s1">[new_index]</span><span class="s2">, </span><span class="s1">verify_integrity=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_rows_with_mask(self</span><span class="s2">, </span><span class="s1">indexer: npt.NDArray[np.bool_]) -&gt; SingleArrayManager:</span>
        <span class="s1">new_array = self.array[indexer]</span>
        <span class="s1">new_index = self.index[indexer]</span>
        <span class="s2">return </span><span class="s1">type(self)([new_array]</span><span class="s2">, </span><span class="s1">[new_index])</span>

    <span class="s4"># error: Signature of &quot;apply&quot; incompatible with supertype &quot;BaseArrayManager&quot;</span>
    <span class="s2">def </span><span class="s1">apply(self</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">**kwargs) -&gt; Self:  </span><span class="s4"># type: ignore[override]</span>
        <span class="s2">if </span><span class="s1">callable(func):</span>
            <span class="s1">new_array = func(self.array</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">new_array = getattr(self.array</span><span class="s2">, </span><span class="s1">func)(**kwargs)</span>
        <span class="s2">return </span><span class="s1">type(self)([new_array]</span><span class="s2">, </span><span class="s1">self._axes)</span>

    <span class="s2">def </span><span class="s1">setitem(self</span><span class="s2">, </span><span class="s1">indexer</span><span class="s2">, </span><span class="s1">value) -&gt; SingleArrayManager:</span>
        <span class="s0">&quot;&quot;&quot; 
        Set values with indexer. 
 
        For SingleArrayManager, this backs s[indexer] = value 
 
        See `setitem_inplace` for a version that works inplace and doesn't 
        return a new Manager. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(indexer</span><span class="s2">, </span><span class="s1">np.ndarray) </span><span class="s2">and </span><span class="s1">indexer.ndim &gt; self.ndim:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;Cannot set values with ndim &gt; </span><span class="s2">{</span><span class="s1">self.ndim</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self.apply_with_block(</span><span class="s3">&quot;setitem&quot;</span><span class="s2">, </span><span class="s1">indexer=indexer</span><span class="s2">, </span><span class="s1">value=value)</span>

    <span class="s2">def </span><span class="s1">idelete(self</span><span class="s2">, </span><span class="s1">indexer) -&gt; SingleArrayManager:</span>
        <span class="s0">&quot;&quot;&quot; 
        Delete selected locations in-place (new array, same ArrayManager) 
        &quot;&quot;&quot;</span>
        <span class="s1">to_keep = np.ones(self.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=np.bool_)</span>
        <span class="s1">to_keep[indexer] = </span><span class="s2">False</span>

        <span class="s1">self.arrays = [self.arrays[</span><span class="s5">0</span><span class="s1">][to_keep]]</span>
        <span class="s1">self._axes = [self._axes[</span><span class="s5">0</span><span class="s1">][to_keep]]</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">_get_data_subset(self</span><span class="s2">, </span><span class="s1">predicate: Callable) -&gt; SingleArrayManager:</span>
        <span class="s4"># used in get_numeric_data / get_bool_data</span>
        <span class="s2">if </span><span class="s1">predicate(self.array):</span>
            <span class="s2">return </span><span class="s1">type(self)(self.arrays</span><span class="s2">, </span><span class="s1">self._axes</span><span class="s2">, </span><span class="s1">verify_integrity=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.make_empty()</span>

    <span class="s2">def </span><span class="s1">set_values(self</span><span class="s2">, </span><span class="s1">values: ArrayLike) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Set (replace) the values of the SingleArrayManager in place. 
 
        Use at your own risk! This does not check if the passed values are 
        valid for the current SingleArrayManager (length, dtype, etc). 
        &quot;&quot;&quot;</span>
        <span class="s1">self.arrays[</span><span class="s5">0</span><span class="s1">] = values</span>

    <span class="s2">def </span><span class="s1">to_2d_mgr(self</span><span class="s2">, </span><span class="s1">columns: Index) -&gt; ArrayManager:</span>
        <span class="s0">&quot;&quot;&quot; 
        Manager analogue of Series.to_frame 
        &quot;&quot;&quot;</span>
        <span class="s1">arrays = [self.arrays[</span><span class="s5">0</span><span class="s1">]]</span>
        <span class="s1">axes = [self.axes[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">columns]</span>

        <span class="s2">return </span><span class="s1">ArrayManager(arrays</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">, </span><span class="s1">verify_integrity=</span><span class="s2">False</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">NullArrayProxy:</span>
    <span class="s0">&quot;&quot;&quot; 
    Proxy object for an all-NA array. 
 
    Only stores the length of the array, and not the dtype. The dtype 
    will only be known when actually concatenating (after determining the 
    common dtype, for which this proxy is ignored). 
    Using this object avoids that the internals/concat.py needs to determine 
    the proper dtype and array type. 
    &quot;&quot;&quot;</span>

    <span class="s1">ndim = </span><span class="s5">1</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">n: int) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.n = n</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">shape(self) -&gt; tuple[int]:</span>
        <span class="s2">return </span><span class="s1">(self.n</span><span class="s2">,</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">to_array(self</span><span class="s2">, </span><span class="s1">dtype: DtypeObj) -&gt; ArrayLike:</span>
        <span class="s0">&quot;&quot;&quot; 
        Helper function to create the actual all-NA array from the NullArrayProxy 
        object. 
 
        Parameters 
        ---------- 
        arr : NullArrayProxy 
        dtype : the dtype for the resulting array 
 
        Returns 
        ------- 
        np.ndarray or ExtensionArray 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">ExtensionDtype):</span>
            <span class="s1">empty = dtype.construct_array_type()._from_sequence([]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">indexer = -np.ones(self.n</span><span class="s2">, </span><span class="s1">dtype=np.intp)</span>
            <span class="s2">return </span><span class="s1">empty.take(indexer</span><span class="s2">, </span><span class="s1">allow_fill=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># when introducing missing values, int becomes float, bool becomes object</span>
            <span class="s1">dtype = ensure_dtype_can_hold_na(dtype)</span>
            <span class="s1">fill_value = na_value_for_dtype(dtype)</span>
            <span class="s1">arr = np.empty(self.n</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">arr.fill(fill_value)</span>
            <span class="s2">return </span><span class="s1">ensure_wrapped_if_datetimelike(arr)</span>


<span class="s2">def </span><span class="s1">concat_arrays(to_concat: list) -&gt; ArrayLike:</span>
    <span class="s0">&quot;&quot;&quot; 
    Alternative for concat_compat but specialized for use in the ArrayManager. 
 
    Differences: only deals with 1D arrays (no axis keyword), assumes 
    ensure_wrapped_if_datetimelike and does not skip empty arrays to determine 
    the dtype. 
    In addition ensures that all NullArrayProxies get replaced with actual 
    arrays. 
 
    Parameters 
    ---------- 
    to_concat : list of arrays 
 
    Returns 
    ------- 
    np.ndarray or ExtensionArray 
    &quot;&quot;&quot;</span>
    <span class="s4"># ignore the all-NA proxies to determine the resulting dtype</span>
    <span class="s1">to_concat_no_proxy = [x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">to_concat </span><span class="s2">if not </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">NullArrayProxy)]</span>

    <span class="s1">dtypes = {x.dtype </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">to_concat_no_proxy}</span>
    <span class="s1">single_dtype = len(dtypes) == </span><span class="s5">1</span>

    <span class="s2">if </span><span class="s1">single_dtype:</span>
        <span class="s1">target_dtype = to_concat_no_proxy[</span><span class="s5">0</span><span class="s1">].dtype</span>
    <span class="s2">elif </span><span class="s1">all(lib.is_np_dtype(x</span><span class="s2">, </span><span class="s3">&quot;iub&quot;</span><span class="s1">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">dtypes):</span>
        <span class="s4"># GH#42092</span>
        <span class="s1">target_dtype = np_find_common_type(*dtypes)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">target_dtype = find_common_type([arr.dtype </span><span class="s2">for </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">to_concat_no_proxy])</span>

    <span class="s1">to_concat = [</span>
        <span class="s1">arr.to_array(target_dtype)</span>
        <span class="s2">if </span><span class="s1">isinstance(arr</span><span class="s2">, </span><span class="s1">NullArrayProxy)</span>
        <span class="s2">else </span><span class="s1">astype_array(arr</span><span class="s2">, </span><span class="s1">target_dtype</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">to_concat</span>
    <span class="s1">]</span>

    <span class="s2">if </span><span class="s1">isinstance(to_concat[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ExtensionArray):</span>
        <span class="s1">cls = type(to_concat[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s2">return </span><span class="s1">cls._concat_same_type(to_concat)</span>

    <span class="s1">result = np.concatenate(to_concat)</span>

    <span class="s4"># TODO decide on exact behaviour (we shouldn't do this only for empty result)</span>
    <span class="s4"># see https://github.com/pandas-dev/pandas/issues/39817</span>
    <span class="s2">if </span><span class="s1">len(result) == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s4"># all empties -&gt; check for bool to not coerce to float</span>
        <span class="s1">kinds = {obj.dtype.kind </span><span class="s2">for </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">to_concat_no_proxy}</span>
        <span class="s2">if </span><span class="s1">len(kinds) != </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s3">&quot;b&quot; </span><span class="s2">in </span><span class="s1">kinds:</span>
                <span class="s1">result = result.astype(object)</span>
    <span class="s2">return </span><span class="s1">result</span>
</pre>
</body>
</html>