<html>
<head>
<title>test_gee.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_gee.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Test functions for GEE 
 
External comparisons are to R and Stata.  The statsmodels GEE 
implementation should generally agree with the R GEE implementation 
for the independence and exchangeable correlation structures.  For 
other correlation structures, the details of the correlation 
estimation differ among implementations and the results will not agree 
exactly. 
&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">statsmodels.compat </span><span class="s2">import </span><span class="s1">lrange</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pytest</span>
<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">(assert_almost_equal</span><span class="s2">, </span><span class="s1">assert_equal</span><span class="s2">, </span><span class="s1">assert_allclose</span><span class="s2">,</span>
                           <span class="s1">assert_array_less</span><span class="s2">, </span><span class="s1">assert_raises</span><span class="s2">, </span><span class="s1">assert_warns</span><span class="s2">,</span>
                           <span class="s1">assert_)</span>
<span class="s2">import </span><span class="s1">statsmodels.genmod.generalized_estimating_equations </span><span class="s2">as </span><span class="s1">gee</span>
<span class="s2">import </span><span class="s1">statsmodels.tools </span><span class="s2">as </span><span class="s1">tools</span>
<span class="s2">import </span><span class="s1">statsmodels.regression.linear_model </span><span class="s2">as </span><span class="s1">lm</span>
<span class="s2">from </span><span class="s1">statsmodels.genmod </span><span class="s2">import </span><span class="s1">families</span>
<span class="s2">from </span><span class="s1">statsmodels.genmod </span><span class="s2">import </span><span class="s1">cov_struct</span>
<span class="s2">import </span><span class="s1">statsmodels.discrete.discrete_model </span><span class="s2">as </span><span class="s1">discrete</span>

<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">from </span><span class="s1">scipy.stats.distributions </span><span class="s2">import </span><span class="s1">norm</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">import </span><span class="s1">matplotlib.pyplot </span><span class="s2">as </span><span class="s1">plt</span>
<span class="s2">except </span><span class="s1">ImportError:</span>
    <span class="s2">pass</span>

<span class="s1">pdf_output = </span><span class="s2">False</span>

<span class="s2">if </span><span class="s1">pdf_output:</span>
    <span class="s2">from </span><span class="s1">matplotlib.backends.backend_pdf </span><span class="s2">import </span><span class="s1">PdfPages</span>
    <span class="s1">pdf = PdfPages(</span><span class="s3">&quot;test_glm.pdf&quot;</span><span class="s1">)</span>
<span class="s2">else</span><span class="s1">:</span>
    <span class="s1">pdf = </span><span class="s2">None</span>


<span class="s2">def </span><span class="s1">close_or_save(pdf</span><span class="s2">, </span><span class="s1">fig):</span>
    <span class="s2">if </span><span class="s1">pdf_output:</span>
        <span class="s1">pdf.savefig(fig)</span>


<span class="s2">def </span><span class="s1">load_data(fname</span><span class="s2">, </span><span class="s1">icept=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Load a data set from the results directory.  The data set should 
    be a CSV file with the following format: 
 
    Column 0: Group indicator 
    Column 1: endog variable 
    Columns 2-end: exog variables 
 
    If `icept` is True, an intercept is prepended to the exog 
    variables. 
    &quot;&quot;&quot;</span>

    <span class="s1">cur_dir = os.path.dirname(os.path.abspath(__file__))</span>
    <span class="s1">Z = np.genfromtxt(os.path.join(cur_dir</span><span class="s2">, </span><span class="s3">'results'</span><span class="s2">, </span><span class="s1">fname)</span><span class="s2">,</span>
                      <span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s1">)</span>

    <span class="s1">group = Z[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">endog = Z[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">exog = Z[:</span><span class="s2">, </span><span class="s4">2</span><span class="s1">:]</span>

    <span class="s2">if </span><span class="s1">icept:</span>
        <span class="s1">exog = np.concatenate((np.ones((exog.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span><span class="s2">, </span><span class="s1">exog)</span><span class="s2">,</span>
                              <span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group</span>


<span class="s2">def </span><span class="s1">check_wrapper(results):</span>
    <span class="s5"># check wrapper</span>
    <span class="s1">assert_(isinstance(results.params</span><span class="s2">, </span><span class="s1">pd.Series))</span>
    <span class="s1">assert_(isinstance(results.fittedvalues</span><span class="s2">, </span><span class="s1">pd.Series))</span>
    <span class="s1">assert_(isinstance(results.resid</span><span class="s2">, </span><span class="s1">pd.Series))</span>
    <span class="s1">assert_(isinstance(results.centered_resid</span><span class="s2">, </span><span class="s1">pd.Series))</span>

    <span class="s1">assert_(isinstance(results._results.params</span><span class="s2">, </span><span class="s1">np.ndarray))</span>
    <span class="s1">assert_(isinstance(results._results.fittedvalues</span><span class="s2">, </span><span class="s1">np.ndarray))</span>
    <span class="s1">assert_(isinstance(results._results.resid</span><span class="s2">, </span><span class="s1">np.ndarray))</span>
    <span class="s1">assert_(isinstance(results._results.centered_resid</span><span class="s2">, </span><span class="s1">np.ndarray))</span>


<span class="s2">class </span><span class="s1">TestGEE:</span>

    <span class="s2">def </span><span class="s1">test_margins_gaussian(self):</span>
        <span class="s5"># Check marginal effects for a Gaussian GEE fit.  Marginal</span>
        <span class="s5"># effects and ordinary effects should be equal.</span>

        <span class="s1">n = </span><span class="s4">40</span>
        <span class="s1">np.random.seed(</span><span class="s4">34234</span><span class="s1">)</span>
        <span class="s1">exog = np.random.normal(size=(n</span><span class="s2">, </span><span class="s4">3</span><span class="s1">))</span>
        <span class="s1">exog[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] = </span><span class="s4">1</span>

        <span class="s1">groups = np.kron(np.arange(n / </span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.r_[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">endog = exog[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">] + np.random.normal(size=n)</span>

        <span class="s1">model = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">groups)</span>
        <span class="s1">result = model.fit(</span>
            <span class="s1">start_params=[-</span><span class="s4">4.88085602e-04</span><span class="s2">, </span><span class="s4">1.18501903</span><span class="s2">, </span><span class="s4">4.78820100e-02</span><span class="s1">])</span>

        <span class="s1">marg = result.get_margeff()</span>

        <span class="s1">assert_allclose(marg.margeff</span><span class="s2">, </span><span class="s1">result.params[</span><span class="s4">1</span><span class="s1">:])</span>
        <span class="s1">assert_allclose(marg.margeff_se</span><span class="s2">, </span><span class="s1">result.bse[</span><span class="s4">1</span><span class="s1">:])</span>

        <span class="s5"># smoke test</span>
        <span class="s1">marg.summary()</span>

    <span class="s2">def </span><span class="s1">test_margins_gaussian_lists_tuples(self):</span>
        <span class="s5"># Check marginal effects for a Gaussian GEE fit using lists and</span>
        <span class="s5"># tuples. Marginal effects and ordinary effects should be equal.</span>

        <span class="s1">n = </span><span class="s4">40</span>
        <span class="s1">np.random.seed(</span><span class="s4">34234</span><span class="s1">)</span>
        <span class="s1">exog_arr = np.random.normal(size=(n</span><span class="s2">, </span><span class="s4">3</span><span class="s1">))</span>
        <span class="s1">exog_arr[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] = </span><span class="s4">1</span>

        <span class="s1">groups_arr = np.kron(np.arange(n / </span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.r_[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">endog_arr = exog_arr[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">] + np.random.normal(size=n)</span>

        <span class="s5"># check that GEE accepts lists</span>
        <span class="s1">exog_list = [list(row) </span><span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">exog_arr]</span>
        <span class="s1">groups_list = list(groups_arr)</span>
        <span class="s1">endog_list = list(endog_arr)</span>

        <span class="s1">model = gee.GEE(endog_list</span><span class="s2">, </span><span class="s1">exog_list</span><span class="s2">, </span><span class="s1">groups_list)</span>
        <span class="s1">result = model.fit(</span>
            <span class="s1">start_params=[-</span><span class="s4">4.88085602e-04</span><span class="s2">, </span><span class="s4">1.18501903</span><span class="s2">, </span><span class="s4">4.78820100e-02</span><span class="s1">])</span>

        <span class="s1">marg = result.get_margeff()</span>

        <span class="s1">assert_allclose(marg.margeff</span><span class="s2">, </span><span class="s1">result.params[</span><span class="s4">1</span><span class="s1">:])</span>
        <span class="s1">assert_allclose(marg.margeff_se</span><span class="s2">, </span><span class="s1">result.bse[</span><span class="s4">1</span><span class="s1">:])</span>

        <span class="s5"># check that GEE accepts tuples</span>
        <span class="s1">exog_tuple = tuple(tuple(row) </span><span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">exog_arr)</span>
        <span class="s1">groups_tuple = tuple(groups_arr)</span>
        <span class="s1">endog_tuple = tuple(endog_arr)</span>

        <span class="s1">model = gee.GEE(endog_tuple</span><span class="s2">, </span><span class="s1">exog_tuple</span><span class="s2">, </span><span class="s1">groups_tuple)</span>
        <span class="s1">result = model.fit(</span>
            <span class="s1">start_params=[-</span><span class="s4">4.88085602e-04</span><span class="s2">, </span><span class="s4">1.18501903</span><span class="s2">, </span><span class="s4">4.78820100e-02</span><span class="s1">])</span>

        <span class="s1">marg = result.get_margeff()</span>

        <span class="s1">assert_allclose(marg.margeff</span><span class="s2">, </span><span class="s1">result.params[</span><span class="s4">1</span><span class="s1">:])</span>
        <span class="s1">assert_allclose(marg.margeff_se</span><span class="s2">, </span><span class="s1">result.bse[</span><span class="s4">1</span><span class="s1">:])</span>

    <span class="s2">def </span><span class="s1">test_margins_logistic(self):</span>
        <span class="s5"># Check marginal effects for a binomial GEE fit.  Comparison</span>
        <span class="s5"># comes from Stata.</span>

        <span class="s1">np.random.seed(</span><span class="s4">34234</span><span class="s1">)</span>
        <span class="s1">endog = np.r_[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">exog = np.ones((</span><span class="s4">8</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">exog[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">] = np.r_[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span>

        <span class="s1">groups = np.arange(</span><span class="s4">8</span><span class="s1">)</span>

        <span class="s1">model = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">family=families.Binomial())</span>
        <span class="s1">result = model.fit(</span>
            <span class="s1">cov_type=</span><span class="s3">'naive'</span><span class="s2">, </span><span class="s1">start_params=[-</span><span class="s4">3.29583687</span><span class="s2">,  </span><span class="s4">2.19722458</span><span class="s1">])</span>

        <span class="s1">marg = result.get_margeff()</span>

        <span class="s1">assert_allclose(marg.margeff</span><span class="s2">, </span><span class="s1">np.r_[</span><span class="s4">0.4119796</span><span class="s1">])</span>
        <span class="s1">assert_allclose(marg.margeff_se</span><span class="s2">, </span><span class="s1">np.r_[</span><span class="s4">0.1379962</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_margins_multinomial(self):</span>
        <span class="s5"># Check marginal effects for a 2-class multinomial GEE fit,</span>
        <span class="s5"># which should be equivalent to logistic regression.  Comparison</span>
        <span class="s5"># comes from Stata.</span>

        <span class="s1">np.random.seed(</span><span class="s4">34234</span><span class="s1">)</span>
        <span class="s1">endog = np.r_[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">exog = np.ones((</span><span class="s4">8</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">exog[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">] = np.r_[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span>

        <span class="s1">groups = np.arange(</span><span class="s4">8</span><span class="s1">)</span>

        <span class="s1">model = gee.NominalGEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">groups)</span>
        <span class="s1">result = model.fit(cov_type=</span><span class="s3">'naive'</span><span class="s2">, </span><span class="s1">start_params=[</span>
                           <span class="s4">3.295837</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2.197225</span><span class="s1">])</span>

        <span class="s1">marg = result.get_margeff()</span>

        <span class="s1">assert_allclose(marg.margeff</span><span class="s2">, </span><span class="s1">np.r_[-</span><span class="s4">0.41197961</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-5</span><span class="s1">)</span>
        <span class="s1">assert_allclose(marg.margeff_se</span><span class="s2">, </span><span class="s1">np.r_[</span><span class="s4">0.1379962</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.smoke</span>
    <span class="s1">@pytest.mark.matplotlib</span>
    <span class="s2">def </span><span class="s1">test_nominal_plot(self</span><span class="s2">, </span><span class="s1">close_figures):</span>
        <span class="s1">np.random.seed(</span><span class="s4">34234</span><span class="s1">)</span>
        <span class="s1">endog = np.r_[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">exog = np.ones((</span><span class="s4">8</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">exog[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">] = np.r_[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span>

        <span class="s1">groups = np.arange(</span><span class="s4">8</span><span class="s1">)</span>

        <span class="s1">model = gee.NominalGEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">groups)</span>
        <span class="s1">result = model.fit(cov_type=</span><span class="s3">'naive'</span><span class="s2">,</span>
                           <span class="s1">start_params=[</span><span class="s4">3.295837</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2.197225</span><span class="s1">])</span>

        <span class="s1">fig = result.plot_distribution()</span>
        <span class="s1">assert_equal(isinstance(fig</span><span class="s2">, </span><span class="s1">plt.Figure)</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_margins_poisson(self):</span>
        <span class="s5"># Check marginal effects for a Poisson GEE fit.</span>

        <span class="s1">np.random.seed(</span><span class="s4">34234</span><span class="s1">)</span>
        <span class="s1">endog = np.r_[</span><span class="s4">10</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s4">13</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s4">18</span><span class="s2">, </span><span class="s4">26</span><span class="s2">, </span><span class="s4">29</span><span class="s1">]</span>
        <span class="s1">exog = np.ones((</span><span class="s4">8</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">exog[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">] = np.r_[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span>

        <span class="s1">groups = np.arange(</span><span class="s4">8</span><span class="s1">)</span>

        <span class="s1">model = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">family=families.Poisson())</span>
        <span class="s1">result = model.fit(cov_type=</span><span class="s3">'naive'</span><span class="s2">, </span><span class="s1">start_params=[</span>
                           <span class="s4">2.52572864</span><span class="s2">, </span><span class="s4">0.62057649</span><span class="s1">])</span>

        <span class="s1">marg = result.get_margeff()</span>

        <span class="s1">assert_allclose(marg.margeff</span><span class="s2">, </span><span class="s1">np.r_[</span><span class="s4">11.0928</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(marg.margeff_se</span><span class="s2">, </span><span class="s1">np.r_[</span><span class="s4">3.269015</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_multinomial(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Check the 2-class multinomial (nominal) GEE fit against 
        logistic regression. 
        &quot;&quot;&quot;</span>

        <span class="s1">np.random.seed(</span><span class="s4">34234</span><span class="s1">)</span>
        <span class="s1">endog = np.r_[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">exog = np.ones((</span><span class="s4">8</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">exog[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">] = np.r_[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span>

        <span class="s1">groups = np.arange(</span><span class="s4">8</span><span class="s1">)</span>

        <span class="s1">model = gee.NominalGEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">groups)</span>
        <span class="s1">results = model.fit(cov_type=</span><span class="s3">'naive'</span><span class="s2">, </span><span class="s1">start_params=[</span>
                            <span class="s4">3.295837</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2.197225</span><span class="s1">])</span>

        <span class="s1">logit_model = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">,</span>
                              <span class="s1">family=families.Binomial())</span>
        <span class="s1">logit_results = logit_model.fit(cov_type=</span><span class="s3">'naive'</span><span class="s1">)</span>

        <span class="s1">assert_allclose(results.params</span><span class="s2">, </span><span class="s1">-logit_results.params</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-5</span><span class="s1">)</span>
        <span class="s1">assert_allclose(results.bse</span><span class="s2">, </span><span class="s1">logit_results.bse</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_weighted(self):</span>

        <span class="s5"># Simple check where the answer can be computed by hand.</span>
        <span class="s1">exog = np.ones(</span><span class="s4">20</span><span class="s1">)</span>
        <span class="s1">weights = np.ones(</span><span class="s4">20</span><span class="s1">)</span>
        <span class="s1">weights[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">10</span><span class="s1">] = </span><span class="s4">2</span>
        <span class="s1">endog = np.zeros(</span><span class="s4">20</span><span class="s1">)</span>
        <span class="s1">endog[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">10</span><span class="s1">] += </span><span class="s4">1</span>
        <span class="s1">groups = np.kron(np.arange(</span><span class="s4">10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.r_[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">model = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">weights=weights)</span>
        <span class="s1">result = model.fit()</span>
        <span class="s1">assert_allclose(result.params</span><span class="s2">, </span><span class="s1">np.r_[</span><span class="s4">2 </span><span class="s1">/ </span><span class="s4">3.</span><span class="s1">])</span>

        <span class="s5"># Comparison against stata using groups with different sizes.</span>
        <span class="s1">weights = np.ones(</span><span class="s4">20</span><span class="s1">)</span>
        <span class="s1">weights[</span><span class="s4">10</span><span class="s1">:] = </span><span class="s4">2</span>
        <span class="s1">endog = np.r_[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">6</span><span class="s2">,</span>
                      <span class="s4">7</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">8</span><span class="s1">]</span>
        <span class="s1">exog1 = np.r_[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s2">,</span>
                      <span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span>
        <span class="s1">groups = np.r_[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">6</span><span class="s2">,</span>
                       <span class="s4">8</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s1">]</span>
        <span class="s1">exog = np.column_stack((np.ones(</span><span class="s4">20</span><span class="s1">)</span><span class="s2">, </span><span class="s1">exog1))</span>

        <span class="s5"># Comparison using independence model</span>
        <span class="s1">model = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">weights=weights</span><span class="s2">,</span>
                        <span class="s1">cov_struct=cov_struct.Independence())</span>
        <span class="s1">g = np.mean([</span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])</span>
        <span class="s1">fac = </span><span class="s4">20 </span><span class="s1">/ float(</span><span class="s4">20 </span><span class="s1">- g)</span>
        <span class="s1">result = model.fit(ddof_scale=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">scaling_factor=fac)</span>

        <span class="s1">assert_allclose(result.params</span><span class="s2">, </span><span class="s1">np.r_[</span><span class="s4">1.247573</span><span class="s2">, </span><span class="s4">1.436893</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(result.scale</span><span class="s2">, </span><span class="s4">1.808576</span><span class="s1">)</span>

        <span class="s5"># Stata multiples robust SE by sqrt(N / (N - g)), where N is</span>
        <span class="s5"># the total sample size and g is the average group size.</span>
        <span class="s1">assert_allclose(result.bse</span><span class="s2">, </span><span class="s1">np.r_[</span><span class="s4">0.895366</span><span class="s2">, </span><span class="s4">0.3425498</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-5</span><span class="s1">)</span>

        <span class="s5"># Comparison using exchangeable model</span>
        <span class="s5"># Smoke test for now</span>
        <span class="s1">model = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">weights=weights</span><span class="s2">,</span>
                        <span class="s1">cov_struct=cov_struct.Exchangeable())</span>
        <span class="s1">model.fit(ddof_scale=</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s5"># This is in the release announcement for version 0.6.</span>
    <span class="s2">def </span><span class="s1">test_poisson_epil(self):</span>

        <span class="s1">cur_dir = os.path.dirname(os.path.abspath(__file__))</span>
        <span class="s1">fname = os.path.join(cur_dir</span><span class="s2">, </span><span class="s3">&quot;results&quot;</span><span class="s2">, </span><span class="s3">&quot;epil.csv&quot;</span><span class="s1">)</span>
        <span class="s1">data = pd.read_csv(fname)</span>

        <span class="s1">fam = families.Poisson()</span>
        <span class="s1">ind = cov_struct.Independence()</span>
        <span class="s1">mod1 = gee.GEE.from_formula(</span><span class="s3">&quot;y ~ age + trt + base&quot;</span><span class="s2">, </span><span class="s1">data[</span><span class="s3">&quot;subject&quot;</span><span class="s1">]</span><span class="s2">,</span>
                                    <span class="s1">data</span><span class="s2">, </span><span class="s1">cov_struct=ind</span><span class="s2">, </span><span class="s1">family=fam)</span>
        <span class="s1">rslt1 = mod1.fit(cov_type=</span><span class="s3">'naive'</span><span class="s1">)</span>

        <span class="s5"># Coefficients should agree with GLM</span>
        <span class="s2">from </span><span class="s1">statsmodels.genmod.generalized_linear_model </span><span class="s2">import </span><span class="s1">GLM</span>

        <span class="s1">mod2 = GLM.from_formula(</span><span class="s3">&quot;y ~ age + trt + base&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">,</span>
                                <span class="s1">family=families.Poisson())</span>
        <span class="s1">rslt2 = mod2.fit()</span>

        <span class="s5"># do not use wrapper, asserts_xxx do not work</span>
        <span class="s1">rslt1 = rslt1._results</span>
        <span class="s1">rslt2 = rslt2._results</span>

        <span class="s1">assert_allclose(rslt1.params</span><span class="s2">, </span><span class="s1">rslt2.params</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(rslt1.bse</span><span class="s2">, </span><span class="s1">rslt2.bse</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-6</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_missing(self):</span>
        <span class="s5"># Test missing data handling for calling from the api.  Missing</span>
        <span class="s5"># data handling does not currently work for formulas.</span>

        <span class="s1">np.random.seed(</span><span class="s4">34234</span><span class="s1">)</span>
        <span class="s1">endog = np.random.normal(size=</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">exog = np.random.normal(size=(</span><span class="s4">100</span><span class="s2">, </span><span class="s4">3</span><span class="s1">))</span>
        <span class="s1">exog[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] = </span><span class="s4">1</span>
        <span class="s1">groups = np.kron(lrange(</span><span class="s4">20</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.ones(</span><span class="s4">5</span><span class="s1">))</span>

        <span class="s1">endog[</span><span class="s4">0</span><span class="s1">] = np.nan</span>
        <span class="s1">endog[</span><span class="s4">5</span><span class="s1">:</span><span class="s4">7</span><span class="s1">] = np.nan</span>
        <span class="s1">exog[</span><span class="s4">10</span><span class="s1">:</span><span class="s4">12</span><span class="s2">, </span><span class="s4">1</span><span class="s1">] = np.nan</span>

        <span class="s1">mod1 = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">missing=</span><span class="s3">'drop'</span><span class="s1">)</span>
        <span class="s1">rslt1 = mod1.fit()</span>

        <span class="s1">assert_almost_equal(len(mod1.endog)</span><span class="s2">, </span><span class="s4">95</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(np.asarray(mod1.exog.shape)</span><span class="s2">, </span><span class="s1">np.r_[</span><span class="s4">95</span><span class="s2">, </span><span class="s4">3</span><span class="s1">])</span>

        <span class="s1">ii = np.isfinite(endog) &amp; np.isfinite(exog).all(</span><span class="s4">1</span><span class="s1">)</span>

        <span class="s1">mod2 = gee.GEE(endog[ii]</span><span class="s2">, </span><span class="s1">exog[ii</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">groups[ii]</span><span class="s2">, </span><span class="s1">missing=</span><span class="s3">'none'</span><span class="s1">)</span>
        <span class="s1">rslt2 = mod2.fit()</span>

        <span class="s1">assert_almost_equal(rslt1.params</span><span class="s2">, </span><span class="s1">rslt2.params)</span>
        <span class="s1">assert_almost_equal(rslt1.bse</span><span class="s2">, </span><span class="s1">rslt2.bse)</span>

    <span class="s2">def </span><span class="s1">test_missing_formula(self):</span>
        <span class="s5"># Test missing data handling for formulas.</span>

        <span class="s1">np.random.seed(</span><span class="s4">34234</span><span class="s1">)</span>
        <span class="s1">endog = np.random.normal(size=</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">exog1 = np.random.normal(size=</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">exog2 = np.random.normal(size=</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">exog3 = np.random.normal(size=</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">groups = np.kron(lrange(</span><span class="s4">20</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.ones(</span><span class="s4">5</span><span class="s1">))</span>

        <span class="s1">endog[</span><span class="s4">0</span><span class="s1">] = np.nan</span>
        <span class="s1">endog[</span><span class="s4">5</span><span class="s1">:</span><span class="s4">7</span><span class="s1">] = np.nan</span>
        <span class="s1">exog2[</span><span class="s4">10</span><span class="s1">:</span><span class="s4">12</span><span class="s1">] = np.nan</span>

        <span class="s1">data0 = pd.DataFrame({</span><span class="s3">&quot;endog&quot;</span><span class="s1">: endog</span><span class="s2">, </span><span class="s3">&quot;exog1&quot;</span><span class="s1">: exog1</span><span class="s2">, </span><span class="s3">&quot;exog2&quot;</span><span class="s1">: exog2</span><span class="s2">,</span>
                              <span class="s3">&quot;exog3&quot;</span><span class="s1">: exog3</span><span class="s2">, </span><span class="s3">&quot;groups&quot;</span><span class="s1">: groups})</span>

        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">data = data0.copy()</span>
            <span class="s1">kwargs = {}</span>
            <span class="s2">if </span><span class="s1">k == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">data[</span><span class="s3">&quot;offset&quot;</span><span class="s1">] = </span><span class="s4">0</span>
                <span class="s1">data[</span><span class="s3">&quot;time&quot;</span><span class="s1">] = </span><span class="s4">0</span>
                <span class="s1">kwargs[</span><span class="s3">&quot;offset&quot;</span><span class="s1">] = </span><span class="s3">&quot;offset&quot;</span>
                <span class="s1">kwargs[</span><span class="s3">&quot;time&quot;</span><span class="s1">] = </span><span class="s3">&quot;time&quot;</span>

            <span class="s1">mod1 = gee.GEE.from_formula(</span><span class="s3">&quot;endog ~ exog1 + exog2 + exog3&quot;</span><span class="s2">,</span>
                                        <span class="s1">groups=</span><span class="s3">&quot;groups&quot;</span><span class="s2">, </span><span class="s1">data=data</span><span class="s2">,</span>
                                        <span class="s1">missing=</span><span class="s3">'drop'</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s1">rslt1 = mod1.fit()</span>

            <span class="s1">assert_almost_equal(len(mod1.endog)</span><span class="s2">, </span><span class="s4">95</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(np.asarray(mod1.exog.shape)</span><span class="s2">, </span><span class="s1">np.r_[</span><span class="s4">95</span><span class="s2">, </span><span class="s4">4</span><span class="s1">])</span>

            <span class="s1">data = data.dropna()</span>

            <span class="s1">kwargs = {}</span>
            <span class="s2">if </span><span class="s1">k == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">kwargs[</span><span class="s3">&quot;offset&quot;</span><span class="s1">] = data[</span><span class="s3">&quot;offset&quot;</span><span class="s1">]</span>
                <span class="s1">kwargs[</span><span class="s3">&quot;time&quot;</span><span class="s1">] = data[</span><span class="s3">&quot;time&quot;</span><span class="s1">]</span>

            <span class="s1">mod2 = gee.GEE.from_formula(</span><span class="s3">&quot;endog ~ exog1 + exog2 + exog3&quot;</span><span class="s2">,</span>
                                        <span class="s1">groups=data[</span><span class="s3">&quot;groups&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">data=data</span><span class="s2">,</span>
                                        <span class="s1">missing=</span><span class="s3">'none'</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s1">rslt2 = mod2.fit()</span>

            <span class="s1">assert_almost_equal(rslt1.params.values</span><span class="s2">, </span><span class="s1">rslt2.params.values)</span>
            <span class="s1">assert_almost_equal(rslt1.bse.values</span><span class="s2">, </span><span class="s1">rslt2.bse.values)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;k1&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">False, True</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;k2&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">False, True</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_invalid_args(self</span><span class="s2">, </span><span class="s1">k1</span><span class="s2">, </span><span class="s1">k2):</span>

        <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">3</span><span class="s1">):</span>

            <span class="s1">p = [</span><span class="s4">20</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s4">20</span><span class="s1">]</span>
            <span class="s1">p[j] = </span><span class="s4">18</span>

            <span class="s1">endog = np.zeros(p[</span><span class="s4">0</span><span class="s1">])</span>
            <span class="s1">exog = np.zeros((p[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>

            <span class="s1">kwargs = {}</span>
            <span class="s1">kwargs[</span><span class="s3">&quot;groups&quot;</span><span class="s1">] = np.zeros(p[</span><span class="s4">2</span><span class="s1">])</span>
            <span class="s2">if </span><span class="s1">k1:</span>
                <span class="s1">kwargs[</span><span class="s3">&quot;exposure&quot;</span><span class="s1">] = np.zeros(</span><span class="s4">18</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">k2:</span>
                <span class="s1">kwargs[</span><span class="s3">&quot;time&quot;</span><span class="s1">] = np.zeros(</span><span class="s4">18</span><span class="s1">)</span>
            <span class="s2">with </span><span class="s1">assert_raises(ValueError):</span>
                <span class="s1">gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">test_default_time(self):</span>
        <span class="s5"># Check that the time defaults work correctly.</span>

        <span class="s1">endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group = load_data(</span><span class="s3">&quot;gee_logistic_1.csv&quot;</span><span class="s1">)</span>

        <span class="s5"># Time values for the autoregressive model</span>
        <span class="s1">T = np.zeros(len(endog))</span>
        <span class="s1">idx = set(group)</span>
        <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">idx:</span>
            <span class="s1">jj = np.flatnonzero(group == ii)</span>
            <span class="s1">T[jj] = lrange(len(jj))</span>

        <span class="s1">family = families.Binomial()</span>
        <span class="s1">va = cov_struct.Autoregressive(grid=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">md1 = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group</span><span class="s2">, </span><span class="s1">family=family</span><span class="s2">, </span><span class="s1">cov_struct=va)</span>
        <span class="s1">mdf1 = md1.fit()</span>

        <span class="s1">md2 = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group</span><span class="s2">, </span><span class="s1">time=T</span><span class="s2">, </span><span class="s1">family=family</span><span class="s2">,</span>
                      <span class="s1">cov_struct=va)</span>
        <span class="s1">mdf2 = md2.fit()</span>

        <span class="s1">assert_almost_equal(mdf1.params</span><span class="s2">, </span><span class="s1">mdf2.params</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(mdf1.standard_errors()</span><span class="s2">,</span>
                            <span class="s1">mdf2.standard_errors()</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_logistic(self):</span>
        <span class="s5"># R code for comparing results:</span>

        <span class="s5"># library(gee)</span>
        <span class="s5"># Z = read.csv(&quot;results/gee_logistic_1.csv&quot;, header=FALSE)</span>
        <span class="s5"># Y = Z[,2]</span>
        <span class="s5"># Id = Z[,1]</span>
        <span class="s5"># X1 = Z[,3]</span>
        <span class="s5"># X2 = Z[,4]</span>
        <span class="s5"># X3 = Z[,5]</span>

        <span class="s5"># mi = gee(Y ~ X1 + X2 + X3, id=Id, family=binomial,</span>
        <span class="s5">#         corstr=&quot;independence&quot;)</span>
        <span class="s5"># smi = summary(mi)</span>
        <span class="s5"># u = coefficients(smi)</span>
        <span class="s5"># cfi = paste(u[,1], collapse=&quot;,&quot;)</span>
        <span class="s5"># sei = paste(u[,4], collapse=&quot;,&quot;)</span>

        <span class="s5"># me = gee(Y ~ X1 + X2 + X3, id=Id, family=binomial,</span>
        <span class="s5">#         corstr=&quot;exchangeable&quot;)</span>
        <span class="s5"># sme = summary(me)</span>
        <span class="s5"># u = coefficients(sme)</span>
        <span class="s5"># cfe = paste(u[,1], collapse=&quot;,&quot;)</span>
        <span class="s5"># see = paste(u[,4], collapse=&quot;,&quot;)</span>

        <span class="s5"># ma = gee(Y ~ X1 + X2 + X3, id=Id, family=binomial,</span>
        <span class="s5">#         corstr=&quot;AR-M&quot;)</span>
        <span class="s5"># sma = summary(ma)</span>
        <span class="s5"># u = coefficients(sma)</span>
        <span class="s5"># cfa = paste(u[,1], collapse=&quot;,&quot;)</span>
        <span class="s5"># sea = paste(u[,4], collapse=&quot;,&quot;)</span>

        <span class="s5"># sprintf(&quot;cf = [[%s],[%s],[%s]]&quot;, cfi, cfe, cfa)</span>
        <span class="s5"># sprintf(&quot;se = [[%s],[%s],[%s]]&quot;, sei, see, sea)</span>

        <span class="s1">endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group = load_data(</span><span class="s3">&quot;gee_logistic_1.csv&quot;</span><span class="s1">)</span>

        <span class="s5"># Time values for the autoregressive model</span>
        <span class="s1">T = np.zeros(len(endog))</span>
        <span class="s1">idx = set(group)</span>
        <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">idx:</span>
            <span class="s1">jj = np.flatnonzero(group == ii)</span>
            <span class="s1">T[jj] = lrange(len(jj))</span>

        <span class="s1">family = families.Binomial()</span>
        <span class="s1">ve = cov_struct.Exchangeable()</span>
        <span class="s1">vi = cov_struct.Independence()</span>
        <span class="s1">va = cov_struct.Autoregressive(grid=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s5"># From R gee</span>
        <span class="s1">cf = [[</span><span class="s4">0.0167272965285882</span><span class="s2">, </span><span class="s4">1.13038654425893</span><span class="s2">,</span>
               <span class="s1">-</span><span class="s4">1.86896345082962</span><span class="s2">, </span><span class="s4">1.09397608331333</span><span class="s1">]</span><span class="s2">,</span>
              <span class="s1">[</span><span class="s4">0.0178982283915449</span><span class="s2">, </span><span class="s4">1.13118798191788</span><span class="s2">,</span>
               <span class="s1">-</span><span class="s4">1.86133518416017</span><span class="s2">, </span><span class="s4">1.08944256230299</span><span class="s1">]</span><span class="s2">,</span>
              <span class="s1">[</span><span class="s4">0.0109621937947958</span><span class="s2">, </span><span class="s4">1.13226505028438</span><span class="s2">,</span>
               <span class="s1">-</span><span class="s4">1.88278757333046</span><span class="s2">, </span><span class="s4">1.09954623769449</span><span class="s1">]]</span>
        <span class="s1">se = [[</span><span class="s4">0.127291720283049</span><span class="s2">, </span><span class="s4">0.166725808326067</span><span class="s2">,</span>
               <span class="s4">0.192430061340865</span><span class="s2">, </span><span class="s4">0.173141068839597</span><span class="s1">]</span><span class="s2">,</span>
              <span class="s1">[</span><span class="s4">0.127045031730155</span><span class="s2">, </span><span class="s4">0.165470678232842</span><span class="s2">,</span>
               <span class="s4">0.192052750030501</span><span class="s2">, </span><span class="s4">0.173174779369249</span><span class="s1">]</span><span class="s2">,</span>
              <span class="s1">[</span><span class="s4">0.127240302296444</span><span class="s2">, </span><span class="s4">0.170554083928117</span><span class="s2">,</span>
               <span class="s4">0.191045527104503</span><span class="s2">, </span><span class="s4">0.169776150974586</span><span class="s1">]]</span>

        <span class="s2">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">enumerate((vi</span><span class="s2">, </span><span class="s1">ve</span><span class="s2">, </span><span class="s1">va)):</span>
            <span class="s1">md = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group</span><span class="s2">, </span><span class="s1">T</span><span class="s2">, </span><span class="s1">family</span><span class="s2">, </span><span class="s1">v)</span>
            <span class="s1">mdf = md.fit()</span>
            <span class="s2">if </span><span class="s1">id(v) != id(va):</span>
                <span class="s1">assert_almost_equal(mdf.params</span><span class="s2">, </span><span class="s1">cf[j]</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>
                <span class="s1">assert_almost_equal(mdf.standard_errors()</span><span class="s2">, </span><span class="s1">se[j]</span><span class="s2">,</span>
                                    <span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>

        <span class="s5"># Test with formulas</span>
        <span class="s1">D = np.concatenate((endog[:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">group[:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">exog[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">:])</span><span class="s2">,</span>
                           <span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">D = pd.DataFrame(D)</span>
        <span class="s1">D.columns = [</span><span class="s3">&quot;Y&quot;</span><span class="s2">, </span><span class="s3">&quot;Id&quot;</span><span class="s2">, </span><span class="s1">] + [</span><span class="s3">&quot;X%d&quot; </span><span class="s1">% (k + </span><span class="s4">1</span><span class="s1">)</span>
                                     <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range(exog.shape[</span><span class="s4">1</span><span class="s1">] - </span><span class="s4">1</span><span class="s1">)]</span>
        <span class="s2">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">enumerate((vi</span><span class="s2">, </span><span class="s1">ve)):</span>
            <span class="s1">md = gee.GEE.from_formula(</span><span class="s3">&quot;Y ~ X1 + X2 + X3&quot;</span><span class="s2">, </span><span class="s3">&quot;Id&quot;</span><span class="s2">, </span><span class="s1">D</span><span class="s2">,</span>
                                      <span class="s1">family=family</span><span class="s2">, </span><span class="s1">cov_struct=v)</span>
            <span class="s1">mdf = md.fit()</span>
            <span class="s1">assert_almost_equal(mdf.params</span><span class="s2">, </span><span class="s1">cf[j]</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(mdf.standard_errors()</span><span class="s2">, </span><span class="s1">se[j]</span><span class="s2">,</span>
                                <span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>

        <span class="s5"># FIXME: do not leave commented-out</span>
        <span class="s5"># Check for run-time exceptions in summary</span>
        <span class="s5"># print(mdf.summary())</span>

    <span class="s2">def </span><span class="s1">test_autoregressive(self):</span>

        <span class="s1">dep_params_true = [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.589208623896</span><span class="s2">, </span><span class="s4">0.559823804948</span><span class="s1">]</span>

        <span class="s1">params_true = [[</span><span class="s4">1.08043787</span><span class="s2">, </span><span class="s4">1.12709319</span><span class="s2">, </span><span class="s4">0.90133927</span><span class="s1">]</span><span class="s2">,</span>
                       <span class="s1">[</span><span class="s4">0.9613677</span><span class="s2">, </span><span class="s4">1.05826987</span><span class="s2">, </span><span class="s4">0.90832055</span><span class="s1">]</span><span class="s2">,</span>
                       <span class="s1">[</span><span class="s4">1.05370439</span><span class="s2">, </span><span class="s4">0.96084864</span><span class="s2">, </span><span class="s4">0.93923374</span><span class="s1">]]</span>

        <span class="s1">np.random.seed(</span><span class="s4">342837482</span><span class="s1">)</span>

        <span class="s1">num_group = </span><span class="s4">100</span>
        <span class="s1">ar_param = </span><span class="s4">0.5</span>
        <span class="s1">k = </span><span class="s4">3</span>

        <span class="s1">ga = families.Gaussian()</span>

        <span class="s2">for </span><span class="s1">gsize </span><span class="s2">in </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">:</span>

            <span class="s1">ix = np.arange(gsize)[:</span><span class="s2">, None</span><span class="s1">] - np.arange(gsize)[</span><span class="s2">None, </span><span class="s1">:]</span>
            <span class="s1">ix = np.abs(ix)</span>
            <span class="s1">cmat = ar_param ** ix</span>
            <span class="s1">cmat_r = np.linalg.cholesky(cmat)</span>

            <span class="s1">endog = []</span>
            <span class="s1">exog = []</span>
            <span class="s1">groups = []</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(num_group):</span>
                <span class="s1">x = np.random.normal(size=(gsize</span><span class="s2">, </span><span class="s1">k))</span>
                <span class="s1">exog.append(x)</span>
                <span class="s1">expval = x.sum(</span><span class="s4">1</span><span class="s1">)</span>
                <span class="s1">errors = np.dot(cmat_r</span><span class="s2">, </span><span class="s1">np.random.normal(size=gsize))</span>
                <span class="s1">endog.append(expval + errors)</span>
                <span class="s1">groups.append(i * np.ones(gsize))</span>

            <span class="s1">endog = np.concatenate(endog)</span>
            <span class="s1">groups = np.concatenate(groups)</span>
            <span class="s1">exog = np.concatenate(exog</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>

            <span class="s1">ar = cov_struct.Autoregressive(grid=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s1">md = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">family=ga</span><span class="s2">, </span><span class="s1">cov_struct=ar)</span>
            <span class="s1">mdf = md.fit()</span>
            <span class="s1">assert_almost_equal(ar.dep_params</span><span class="s2">, </span><span class="s1">dep_params_true[gsize - </span><span class="s4">1</span><span class="s1">])</span>
            <span class="s1">assert_almost_equal(mdf.params</span><span class="s2">, </span><span class="s1">params_true[gsize - </span><span class="s4">1</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_post_estimation(self):</span>

        <span class="s1">family = families.Gaussian()</span>
        <span class="s1">endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group = load_data(</span><span class="s3">&quot;gee_linear_1.csv&quot;</span><span class="s1">)</span>

        <span class="s1">ve = cov_struct.Exchangeable()</span>

        <span class="s1">md = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group</span><span class="s2">, None, </span><span class="s1">family</span><span class="s2">, </span><span class="s1">ve)</span>
        <span class="s1">mdf = md.fit()</span>

        <span class="s1">assert_almost_equal(np.dot(exog</span><span class="s2">, </span><span class="s1">mdf.params)</span><span class="s2">,</span>
                            <span class="s1">mdf.fittedvalues)</span>
        <span class="s1">assert_almost_equal(endog - np.dot(exog</span><span class="s2">, </span><span class="s1">mdf.params)</span><span class="s2">,</span>
                            <span class="s1">mdf.resid)</span>

    <span class="s2">def </span><span class="s1">test_scoretest(self):</span>
        <span class="s5"># Regression tests</span>

        <span class="s1">np.random.seed(</span><span class="s4">6432</span><span class="s1">)</span>
        <span class="s1">n = </span><span class="s4">200  </span><span class="s5"># Must be divisible by 4</span>
        <span class="s1">exog = np.random.normal(size=(n</span><span class="s2">, </span><span class="s4">4</span><span class="s1">))</span>
        <span class="s1">endog = exog[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] + exog[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">] + exog[:</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">endog += </span><span class="s4">3 </span><span class="s1">* np.random.normal(size=n)</span>
        <span class="s1">group = np.kron(np.arange(n / </span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.ones(</span><span class="s4">4</span><span class="s1">))</span>

        <span class="s5"># Test under the null.</span>
        <span class="s1">L = np.array([[</span><span class="s4">1.</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]])</span>
        <span class="s1">R = np.array([</span><span class="s4">0.</span><span class="s2">, </span><span class="s1">])</span>
        <span class="s1">family = families.Gaussian()</span>
        <span class="s1">va = cov_struct.Independence()</span>
        <span class="s1">mod1 = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group</span><span class="s2">, </span><span class="s1">family=family</span><span class="s2">,</span>
                       <span class="s1">cov_struct=va</span><span class="s2">, </span><span class="s1">constraint=(L</span><span class="s2">, </span><span class="s1">R))</span>
        <span class="s1">res1 = mod1.fit()</span>
        <span class="s1">assert_almost_equal(res1.score_test()[</span><span class="s3">&quot;statistic&quot;</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s4">1.08126334</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(res1.score_test()[</span><span class="s3">&quot;p-value&quot;</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s4">0.2984151086</span><span class="s1">)</span>

        <span class="s5"># Test under the alternative.</span>
        <span class="s1">L = np.array([[</span><span class="s4">1.</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]])</span>
        <span class="s1">R = np.array([</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">])</span>
        <span class="s1">family = families.Gaussian()</span>
        <span class="s1">va = cov_struct.Independence()</span>
        <span class="s1">mod2 = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group</span><span class="s2">, </span><span class="s1">family=family</span><span class="s2">,</span>
                       <span class="s1">cov_struct=va</span><span class="s2">, </span><span class="s1">constraint=(L</span><span class="s2">, </span><span class="s1">R))</span>
        <span class="s1">res2 = mod2.fit()</span>
        <span class="s1">assert_almost_equal(res2.score_test()[</span><span class="s3">&quot;statistic&quot;</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s4">3.491110965</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(res2.score_test()[</span><span class="s3">&quot;p-value&quot;</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s4">0.0616991659</span><span class="s1">)</span>

        <span class="s5"># Compare to Wald tests</span>
        <span class="s1">exog = np.random.normal(size=(n</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">L = np.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]])</span>
        <span class="s1">R = np.array([</span><span class="s4">0.</span><span class="s1">])</span>
        <span class="s1">f = np.r_[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">10</span><span class="s1">):</span>
            <span class="s1">endog = exog[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] + (</span><span class="s4">0.5 </span><span class="s1">+ i / </span><span class="s4">10.</span><span class="s1">) * exog[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">] +\</span>
                <span class="s1">np.random.normal(size=n)</span>
            <span class="s1">family = families.Gaussian()</span>
            <span class="s1">va = cov_struct.Independence()</span>
            <span class="s1">mod0 = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group</span><span class="s2">, </span><span class="s1">family=family</span><span class="s2">,</span>
                           <span class="s1">cov_struct=va)</span>
            <span class="s1">rslt0 = mod0.fit()</span>
            <span class="s1">family = families.Gaussian()</span>
            <span class="s1">va = cov_struct.Independence()</span>
            <span class="s1">mod1 = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group</span><span class="s2">, </span><span class="s1">family=family</span><span class="s2">,</span>
                           <span class="s1">cov_struct=va</span><span class="s2">, </span><span class="s1">constraint=(L</span><span class="s2">, </span><span class="s1">R))</span>
            <span class="s1">res1 = mod1.fit()</span>
            <span class="s1">se = np.sqrt(np.dot(f</span><span class="s2">, </span><span class="s1">np.dot(rslt0.cov_params()</span><span class="s2">, </span><span class="s1">f)))</span>
            <span class="s1">wald_z = np.dot(f</span><span class="s2">, </span><span class="s1">rslt0.params) / se</span>
            <span class="s1">wald_p = </span><span class="s4">2 </span><span class="s1">* norm.cdf(-np.abs(wald_z))</span>
            <span class="s1">score_p = res1.score_test()[</span><span class="s3">&quot;p-value&quot;</span><span class="s1">]</span>
            <span class="s1">assert_array_less(np.abs(wald_p - score_p)</span><span class="s2">, </span><span class="s4">0.02</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;cov_struct&quot;</span><span class="s2">, </span><span class="s1">[cov_struct.Independence</span><span class="s2">,</span>
                                            <span class="s1">cov_struct.Exchangeable])</span>
    <span class="s2">def </span><span class="s1">test_compare_score_test(self</span><span class="s2">, </span><span class="s1">cov_struct):</span>

        <span class="s1">np.random.seed(</span><span class="s4">6432</span><span class="s1">)</span>
        <span class="s1">n = </span><span class="s4">200  </span><span class="s5"># Must be divisible by 4</span>
        <span class="s1">exog = np.random.normal(size=(n</span><span class="s2">, </span><span class="s4">4</span><span class="s1">))</span>
        <span class="s1">group = np.kron(np.arange(n / </span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.ones(</span><span class="s4">4</span><span class="s1">))</span>

        <span class="s1">exog_sub = exog[:</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]]</span>
        <span class="s1">endog = exog_sub.sum(</span><span class="s4">1</span><span class="s1">) + </span><span class="s4">3 </span><span class="s1">* np.random.normal(size=n)</span>

        <span class="s1">L = np.asarray([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]])</span>
        <span class="s1">R = np.zeros(</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">mod_lr = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group</span><span class="s2">, </span><span class="s1">constraint=(L</span><span class="s2">, </span><span class="s1">R)</span><span class="s2">,</span>
                         <span class="s1">cov_struct=cov_struct())</span>
        <span class="s1">mod_lr.fit()</span>

        <span class="s1">mod_sub = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog_sub</span><span class="s2">, </span><span class="s1">group</span><span class="s2">, </span><span class="s1">cov_struct=cov_struct())</span>
        <span class="s1">res_sub = mod_sub.fit()</span>

        <span class="s2">for </span><span class="s1">call_fit </span><span class="s2">in </span><span class="s1">[</span><span class="s2">False, True</span><span class="s1">]:</span>
            <span class="s1">mod = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group</span><span class="s2">, </span><span class="s1">cov_struct=cov_struct())</span>
            <span class="s2">if </span><span class="s1">call_fit:</span>
                <span class="s5"># Should work with or without fitting the parent model</span>
                <span class="s1">mod.fit()</span>
            <span class="s1">score_results = mod.compare_score_test(res_sub)</span>
            <span class="s1">assert_almost_equal(</span>
                <span class="s1">score_results[</span><span class="s3">&quot;statistic&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">mod_lr.score_test_results[</span><span class="s3">&quot;statistic&quot;</span><span class="s1">])</span>
            <span class="s1">assert_almost_equal(</span>
                <span class="s1">score_results[</span><span class="s3">&quot;p-value&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">mod_lr.score_test_results[</span><span class="s3">&quot;p-value&quot;</span><span class="s1">])</span>
            <span class="s1">assert_almost_equal(</span>
                <span class="s1">score_results[</span><span class="s3">&quot;df&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">mod_lr.score_test_results[</span><span class="s3">&quot;df&quot;</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_compare_score_test_warnings(self):</span>

        <span class="s1">np.random.seed(</span><span class="s4">6432</span><span class="s1">)</span>
        <span class="s1">n = </span><span class="s4">200  </span><span class="s5"># Must be divisible by 4</span>
        <span class="s1">exog = np.random.normal(size=(n</span><span class="s2">, </span><span class="s4">4</span><span class="s1">))</span>
        <span class="s1">group = np.kron(np.arange(n / </span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.ones(</span><span class="s4">4</span><span class="s1">))</span>
        <span class="s1">exog_sub = exog[:</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]]</span>
        <span class="s1">endog = exog_sub.sum(</span><span class="s4">1</span><span class="s1">) + </span><span class="s4">3 </span><span class="s1">* np.random.normal(size=n)</span>

        <span class="s5"># Mismatched cov_struct</span>
        <span class="s2">with </span><span class="s1">assert_warns(UserWarning):</span>
            <span class="s1">mod_sub = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog_sub</span><span class="s2">, </span><span class="s1">group</span><span class="s2">,</span>
                              <span class="s1">cov_struct=cov_struct.Exchangeable())</span>
            <span class="s1">res_sub = mod_sub.fit()</span>
            <span class="s1">mod = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group</span><span class="s2">,</span>
                          <span class="s1">cov_struct=cov_struct.Independence())</span>
            <span class="s1">mod.compare_score_test(res_sub)  </span><span class="s5"># smoketest</span>

        <span class="s5"># Mismatched family</span>
        <span class="s2">with </span><span class="s1">assert_warns(UserWarning):</span>
            <span class="s1">mod_sub = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog_sub</span><span class="s2">, </span><span class="s1">group</span><span class="s2">,</span>
                              <span class="s1">family=families.Gaussian())</span>
            <span class="s1">res_sub = mod_sub.fit()</span>
            <span class="s1">mod = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group</span><span class="s2">, </span><span class="s1">family=families.Poisson())</span>
            <span class="s1">mod.compare_score_test(res_sub)  </span><span class="s5"># smoketest</span>

        <span class="s5"># Mismatched size</span>
        <span class="s2">with </span><span class="s1">assert_raises(Exception):</span>
            <span class="s1">mod_sub = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog_sub</span><span class="s2">, </span><span class="s1">group)</span>
            <span class="s1">res_sub = mod_sub.fit()</span>
            <span class="s1">mod = gee.GEE(endog[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">100</span><span class="s1">]</span><span class="s2">, </span><span class="s1">exog[:</span><span class="s4">100</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">group[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">100</span><span class="s1">])</span>
            <span class="s1">mod.compare_score_test(res_sub)  </span><span class="s5"># smoketest</span>

        <span class="s5"># Mismatched weights</span>
        <span class="s2">with </span><span class="s1">assert_warns(UserWarning):</span>
            <span class="s1">w = np.random.uniform(size=n)</span>
            <span class="s1">mod_sub = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog_sub</span><span class="s2">, </span><span class="s1">group</span><span class="s2">, </span><span class="s1">weights=w)</span>
            <span class="s1">res_sub = mod_sub.fit()</span>
            <span class="s1">mod = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group)</span>
            <span class="s1">mod.compare_score_test(res_sub)  </span><span class="s5"># smoketest</span>

        <span class="s5"># Parent and submodel are the same dimension</span>
        <span class="s2">with </span><span class="s1">pytest.warns(UserWarning):</span>
            <span class="s1">w = np.random.uniform(size=n)</span>
            <span class="s1">mod_sub = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group)</span>
            <span class="s1">res_sub = mod_sub.fit()</span>
            <span class="s1">mod = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group)</span>
            <span class="s1">mod.compare_score_test(res_sub)  </span><span class="s5"># smoketest</span>

    <span class="s2">def </span><span class="s1">test_constraint_covtype(self):</span>
        <span class="s5"># Test constraints with different cov types</span>
        <span class="s1">np.random.seed(</span><span class="s4">6432</span><span class="s1">)</span>
        <span class="s1">n = </span><span class="s4">200</span>
        <span class="s1">exog = np.random.normal(size=(n</span><span class="s2">, </span><span class="s4">4</span><span class="s1">))</span>
        <span class="s1">endog = exog[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] + exog[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">] + exog[:</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">endog += </span><span class="s4">3 </span><span class="s1">* np.random.normal(size=n)</span>
        <span class="s1">group = np.kron(np.arange(n / </span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.ones(</span><span class="s4">4</span><span class="s1">))</span>
        <span class="s1">L = np.array([[</span><span class="s4">1.</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]])</span>
        <span class="s1">R = np.array([</span><span class="s4">0.</span><span class="s2">, </span><span class="s1">])</span>
        <span class="s1">family = families.Gaussian()</span>
        <span class="s1">va = cov_struct.Independence()</span>
        <span class="s2">for </span><span class="s1">cov_type </span><span class="s2">in </span><span class="s3">&quot;robust&quot;</span><span class="s2">, </span><span class="s3">&quot;naive&quot;</span><span class="s2">, </span><span class="s3">&quot;bias_reduced&quot;</span><span class="s1">:</span>
            <span class="s1">model = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group</span><span class="s2">, </span><span class="s1">family=family</span><span class="s2">,</span>
                            <span class="s1">cov_struct=va</span><span class="s2">, </span><span class="s1">constraint=(L</span><span class="s2">, </span><span class="s1">R))</span>
            <span class="s1">result = model.fit(cov_type=cov_type)</span>
            <span class="s1">result.standard_errors(cov_type=cov_type)</span>
            <span class="s1">assert_allclose(result.cov_robust.shape</span><span class="s2">, </span><span class="s1">np.r_[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s1">])</span>
            <span class="s1">assert_allclose(result.cov_naive.shape</span><span class="s2">, </span><span class="s1">np.r_[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s1">])</span>
            <span class="s2">if </span><span class="s1">cov_type == </span><span class="s3">&quot;bias_reduced&quot;</span><span class="s1">:</span>
                <span class="s1">assert_allclose(result.cov_robust_bc.shape</span><span class="s2">, </span><span class="s1">np.r_[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_linear(self):</span>
        <span class="s5"># library(gee)</span>

        <span class="s5"># Z = read.csv(&quot;results/gee_linear_1.csv&quot;, header=FALSE)</span>
        <span class="s5"># Y = Z[,2]</span>
        <span class="s5"># Id = Z[,1]</span>
        <span class="s5"># X1 = Z[,3]</span>
        <span class="s5"># X2 = Z[,4]</span>
        <span class="s5"># X3 = Z[,5]</span>
        <span class="s5"># mi = gee(Y ~ X1 + X2 + X3, id=Id, family=gaussian,</span>
        <span class="s5">#         corstr=&quot;independence&quot;, tol=1e-8, maxit=100)</span>
        <span class="s5"># smi = summary(mi)</span>
        <span class="s5"># u = coefficients(smi)</span>

        <span class="s5"># cfi = paste(u[,1], collapse=&quot;,&quot;)</span>
        <span class="s5"># sei = paste(u[,4], collapse=&quot;,&quot;)</span>

        <span class="s5"># me = gee(Y ~ X1 + X2 + X3, id=Id, family=gaussian,</span>
        <span class="s5">#         corstr=&quot;exchangeable&quot;, tol=1e-8, maxit=100)</span>
        <span class="s5"># sme = summary(me)</span>
        <span class="s5"># u = coefficients(sme)</span>

        <span class="s5"># cfe = paste(u[,1], collapse=&quot;,&quot;)</span>
        <span class="s5"># see = paste(u[,4], collapse=&quot;,&quot;)</span>

        <span class="s5"># sprintf(&quot;cf = [[%s],[%s]]&quot;, cfi, cfe)</span>
        <span class="s5"># sprintf(&quot;se = [[%s],[%s]]&quot;, sei, see)</span>

        <span class="s1">family = families.Gaussian()</span>

        <span class="s1">endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group = load_data(</span><span class="s3">&quot;gee_linear_1.csv&quot;</span><span class="s1">)</span>

        <span class="s1">vi = cov_struct.Independence()</span>
        <span class="s1">ve = cov_struct.Exchangeable()</span>

        <span class="s5"># From R gee</span>
        <span class="s1">cf = [[-</span><span class="s4">0.01850226507491</span><span class="s2">, </span><span class="s4">0.81436304278962</span><span class="s2">,</span>
               <span class="s1">-</span><span class="s4">1.56167635393184</span><span class="s2">, </span><span class="s4">0.794239361055003</span><span class="s1">]</span><span class="s2">,</span>
              <span class="s1">[-</span><span class="s4">0.0182920577154767</span><span class="s2">, </span><span class="s4">0.814898414022467</span><span class="s2">,</span>
               <span class="s1">-</span><span class="s4">1.56194040106201</span><span class="s2">, </span><span class="s4">0.793499517527478</span><span class="s1">]]</span>
        <span class="s1">se = [[</span><span class="s4">0.0440733554189401</span><span class="s2">, </span><span class="s4">0.0479993639119261</span><span class="s2">,</span>
               <span class="s4">0.0496045952071308</span><span class="s2">, </span><span class="s4">0.0479467597161284</span><span class="s1">]</span><span class="s2">,</span>
              <span class="s1">[</span><span class="s4">0.0440369906460754</span><span class="s2">, </span><span class="s4">0.0480069787567662</span><span class="s2">,</span>
               <span class="s4">0.049519758758187</span><span class="s2">, </span><span class="s4">0.0479760443027526</span><span class="s1">]]</span>

        <span class="s2">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">enumerate((vi</span><span class="s2">, </span><span class="s1">ve)):</span>
            <span class="s1">md = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group</span><span class="s2">, None, </span><span class="s1">family</span><span class="s2">, </span><span class="s1">v)</span>
            <span class="s1">mdf = md.fit()</span>
            <span class="s1">assert_almost_equal(mdf.params</span><span class="s2">, </span><span class="s1">cf[j]</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">10</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(mdf.standard_errors()</span><span class="s2">, </span><span class="s1">se[j]</span><span class="s2">,</span>
                                <span class="s1">decimal=</span><span class="s4">10</span><span class="s1">)</span>

        <span class="s5"># Test with formulas</span>
        <span class="s1">D = np.concatenate((endog[:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">group[:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">exog[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">:])</span><span class="s2">,</span>
                           <span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">D = pd.DataFrame(D)</span>
        <span class="s1">D.columns = [</span><span class="s3">&quot;Y&quot;</span><span class="s2">, </span><span class="s3">&quot;Id&quot;</span><span class="s2">, </span><span class="s1">] + [</span><span class="s3">&quot;X%d&quot; </span><span class="s1">% (k + </span><span class="s4">1</span><span class="s1">)</span>
                                     <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range(exog.shape[</span><span class="s4">1</span><span class="s1">] - </span><span class="s4">1</span><span class="s1">)]</span>
        <span class="s2">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">enumerate((vi</span><span class="s2">, </span><span class="s1">ve)):</span>
            <span class="s1">md = gee.GEE.from_formula(</span><span class="s3">&quot;Y ~ X1 + X2 + X3&quot;</span><span class="s2">, </span><span class="s3">&quot;Id&quot;</span><span class="s2">, </span><span class="s1">D</span><span class="s2">,</span>
                                      <span class="s1">family=family</span><span class="s2">, </span><span class="s1">cov_struct=v)</span>
            <span class="s1">mdf = md.fit()</span>
            <span class="s1">assert_almost_equal(mdf.params</span><span class="s2">, </span><span class="s1">cf[j]</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">10</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(mdf.standard_errors()</span><span class="s2">, </span><span class="s1">se[j]</span><span class="s2">,</span>
                                <span class="s1">decimal=</span><span class="s4">10</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_linear_constrained(self):</span>

        <span class="s1">family = families.Gaussian()</span>

        <span class="s1">np.random.seed(</span><span class="s4">34234</span><span class="s1">)</span>
        <span class="s1">exog = np.random.normal(size=(</span><span class="s4">300</span><span class="s2">, </span><span class="s4">4</span><span class="s1">))</span>
        <span class="s1">exog[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] = </span><span class="s4">1</span>
        <span class="s1">endog = np.dot(exog</span><span class="s2">, </span><span class="s1">np.r_[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">]) +\</span>
            <span class="s1">np.random.normal(size=</span><span class="s4">300</span><span class="s1">)</span>
        <span class="s1">group = np.kron(np.arange(</span><span class="s4">100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.r_[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>

        <span class="s1">vi = cov_struct.Independence()</span>
        <span class="s1">ve = cov_struct.Exchangeable()</span>

        <span class="s1">L = np.r_[[[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]]]</span>
        <span class="s1">R = np.r_[</span><span class="s4">0</span><span class="s2">, </span><span class="s1">]</span>

        <span class="s2">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">enumerate((vi</span><span class="s2">, </span><span class="s1">ve)):</span>
            <span class="s1">md = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group</span><span class="s2">, None, </span><span class="s1">family</span><span class="s2">, </span><span class="s1">v</span><span class="s2">,</span>
                         <span class="s1">constraint=(L</span><span class="s2">, </span><span class="s1">R))</span>
            <span class="s1">mdf = md.fit()</span>
            <span class="s1">assert_almost_equal(mdf.params[</span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">10</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_nested_linear(self):</span>

        <span class="s1">family = families.Gaussian()</span>

        <span class="s1">endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group = load_data(</span><span class="s3">&quot;gee_nested_linear_1.csv&quot;</span><span class="s1">)</span>

        <span class="s1">group_n = []</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(endog.shape[</span><span class="s4">0</span><span class="s1">] // </span><span class="s4">10</span><span class="s1">):</span>
            <span class="s1">group_n.extend([</span><span class="s4">0</span><span class="s2">, </span><span class="s1">] * </span><span class="s4">5</span><span class="s1">)</span>
            <span class="s1">group_n.extend([</span><span class="s4">1</span><span class="s2">, </span><span class="s1">] * </span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">group_n = np.array(group_n)[:</span><span class="s2">, None</span><span class="s1">]</span>

        <span class="s1">dp = cov_struct.Independence()</span>
        <span class="s1">md = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group</span><span class="s2">, None, </span><span class="s1">family</span><span class="s2">, </span><span class="s1">dp)</span>
        <span class="s1">mdf1 = md.fit()</span>

        <span class="s5"># From statsmodels.GEE (not an independent test)</span>
        <span class="s1">cf = np.r_[-</span><span class="s4">0.1671073</span><span class="s2">,  </span><span class="s4">1.00467426</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2.01723004</span><span class="s2">,  </span><span class="s4">0.97297106</span><span class="s1">]</span>
        <span class="s1">se = np.r_[</span><span class="s4">0.08629606</span><span class="s2">,  </span><span class="s4">0.04058653</span><span class="s2">,  </span><span class="s4">0.04067038</span><span class="s2">,  </span><span class="s4">0.03777989</span><span class="s1">]</span>
        <span class="s1">assert_almost_equal(mdf1.params</span><span class="s2">, </span><span class="s1">cf</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(mdf1.standard_errors()</span><span class="s2">, </span><span class="s1">se</span><span class="s2">,</span>
                            <span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>

        <span class="s1">ne = cov_struct.Nested()</span>
        <span class="s1">md = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group</span><span class="s2">, None, </span><span class="s1">family</span><span class="s2">, </span><span class="s1">ne</span><span class="s2">,</span>
                     <span class="s1">dep_data=group_n)</span>
        <span class="s1">mdf2 = md.fit(start_params=mdf1.params)</span>

        <span class="s5"># From statsmodels.GEE (not an independent test)</span>
        <span class="s1">cf = np.r_[-</span><span class="s4">0.16655319</span><span class="s2">,  </span><span class="s4">1.02183688</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2.00858719</span><span class="s2">,  </span><span class="s4">1.00101969</span><span class="s1">]</span>
        <span class="s1">se = np.r_[</span><span class="s4">0.08632616</span><span class="s2">,  </span><span class="s4">0.02913582</span><span class="s2">,  </span><span class="s4">0.03114428</span><span class="s2">,  </span><span class="s4">0.02893991</span><span class="s1">]</span>
        <span class="s1">assert_almost_equal(mdf2.params</span><span class="s2">, </span><span class="s1">cf</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(mdf2.standard_errors()</span><span class="s2">, </span><span class="s1">se</span><span class="s2">,</span>
                            <span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>

        <span class="s1">smry = mdf2.cov_struct.summary()</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">smry.Variance</span><span class="s2">,</span>
            <span class="s1">np.r_[</span><span class="s4">1.043878</span><span class="s2">, </span><span class="s4">0.611656</span><span class="s2">, </span><span class="s4">1.421205</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">atol=</span><span class="s4">1e-5</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_nested_pandas(self):</span>

        <span class="s1">np.random.seed(</span><span class="s4">4234</span><span class="s1">)</span>
        <span class="s1">n = </span><span class="s4">10000</span>

        <span class="s5"># Outer groups</span>
        <span class="s1">groups = np.kron(np.arange(n // </span><span class="s4">100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.ones(</span><span class="s4">100</span><span class="s1">)).astype(int)</span>

        <span class="s5"># Inner groups</span>
        <span class="s1">groups1 = np.kron(np.arange(n // </span><span class="s4">50</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.ones(</span><span class="s4">50</span><span class="s1">)).astype(int)</span>
        <span class="s1">groups2 = np.kron(np.arange(n // </span><span class="s4">10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.ones(</span><span class="s4">10</span><span class="s1">)).astype(int)</span>

        <span class="s5"># Group effects</span>
        <span class="s1">groups_e = np.random.normal(size=n // </span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">groups1_e = </span><span class="s4">2 </span><span class="s1">* np.random.normal(size=n // </span><span class="s4">50</span><span class="s1">)</span>
        <span class="s1">groups2_e = </span><span class="s4">3 </span><span class="s1">* np.random.normal(size=n // </span><span class="s4">10</span><span class="s1">)</span>

        <span class="s1">y = groups_e[groups] + groups1_e[groups1] + groups2_e[groups2]</span>
        <span class="s1">y += </span><span class="s4">0.5 </span><span class="s1">* np.random.normal(size=n)</span>

        <span class="s1">df = pd.DataFrame({</span><span class="s3">&quot;y&quot;</span><span class="s1">: y</span><span class="s2">, </span><span class="s3">&quot;TheGroups&quot;</span><span class="s1">: groups</span><span class="s2">,</span>
                           <span class="s3">&quot;groups1&quot;</span><span class="s1">: groups1</span><span class="s2">, </span><span class="s3">&quot;groups2&quot;</span><span class="s1">: groups2})</span>

        <span class="s1">model = gee.GEE.from_formula(</span><span class="s3">&quot;y ~ 1&quot;</span><span class="s2">, </span><span class="s1">groups=</span><span class="s3">&quot;TheGroups&quot;</span><span class="s2">,</span>
                                     <span class="s1">dep_data=</span><span class="s3">&quot;0 + groups1 + groups2&quot;</span><span class="s2">,</span>
                                     <span class="s1">cov_struct=cov_struct.Nested()</span><span class="s2">,</span>
                                     <span class="s1">data=df)</span>
        <span class="s1">result = model.fit()</span>

        <span class="s5"># The true variances are 1, 4, 9, 0.25</span>
        <span class="s1">smry = result.cov_struct.summary()</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">smry.Variance</span><span class="s2">,</span>
            <span class="s1">np.r_[</span><span class="s4">1.437299</span><span class="s2">, </span><span class="s4">4.421543</span><span class="s2">, </span><span class="s4">8.905295</span><span class="s2">, </span><span class="s4">0.258480</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">atol=</span><span class="s4">1e-5</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_ordinal(self):</span>

        <span class="s1">family = families.Binomial()</span>

        <span class="s1">endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">groups = load_data(</span><span class="s3">&quot;gee_ordinal_1.csv&quot;</span><span class="s2">,</span>
                                        <span class="s1">icept=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">va = cov_struct.GlobalOddsRatio(</span><span class="s3">&quot;ordinal&quot;</span><span class="s1">)</span>

        <span class="s1">mod = gee.OrdinalGEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, None, </span><span class="s1">family</span><span class="s2">, </span><span class="s1">va)</span>
        <span class="s1">rslt = mod.fit()</span>

        <span class="s5"># Regression test</span>
        <span class="s1">cf = np.r_[</span><span class="s4">1.09250002</span><span class="s2">, </span><span class="s4">0.0217443</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.39851092</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.01812116</span><span class="s2">,</span>
                   <span class="s4">0.03023969</span><span class="s2">, </span><span class="s4">1.18258516</span><span class="s2">, </span><span class="s4">0.01803453</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.10203381</span><span class="s1">]</span>
        <span class="s1">assert_almost_equal(rslt.params</span><span class="s2">, </span><span class="s1">cf</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">5</span><span class="s1">)</span>

        <span class="s5"># Regression test</span>
        <span class="s1">se = np.r_[</span><span class="s4">0.10883461</span><span class="s2">, </span><span class="s4">0.10330197</span><span class="s2">, </span><span class="s4">0.11177088</span><span class="s2">, </span><span class="s4">0.05486569</span><span class="s2">,</span>
                   <span class="s4">0.05997153</span><span class="s2">, </span><span class="s4">0.09168148</span><span class="s2">, </span><span class="s4">0.05953324</span><span class="s2">, </span><span class="s4">0.0853862</span><span class="s1">]</span>
        <span class="s1">assert_almost_equal(rslt.bse</span><span class="s2">, </span><span class="s1">se</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">5</span><span class="s1">)</span>

        <span class="s5"># Check that we get the correct results type</span>
        <span class="s1">assert_equal(type(rslt)</span><span class="s2">, </span><span class="s1">gee.OrdinalGEEResultsWrapper)</span>
        <span class="s1">assert_equal(type(rslt._results)</span><span class="s2">, </span><span class="s1">gee.OrdinalGEEResults)</span>

    <span class="s1">@pytest.mark.smoke</span>
    <span class="s2">def </span><span class="s1">test_ordinal_formula(self):</span>

        <span class="s1">np.random.seed(</span><span class="s4">434</span><span class="s1">)</span>
        <span class="s1">n = </span><span class="s4">40</span>
        <span class="s1">y = np.random.randint(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">n)</span>
        <span class="s1">groups = np.arange(n)</span>
        <span class="s1">x1 = np.random.normal(size=n)</span>
        <span class="s1">x2 = np.random.normal(size=n)</span>

        <span class="s1">df = pd.DataFrame({</span><span class="s3">&quot;y&quot;</span><span class="s1">: y</span><span class="s2">, </span><span class="s3">&quot;groups&quot;</span><span class="s1">: groups</span><span class="s2">, </span><span class="s3">&quot;x1&quot;</span><span class="s1">: x1</span><span class="s2">, </span><span class="s3">&quot;x2&quot;</span><span class="s1">: x2})</span>

        <span class="s1">model = gee.OrdinalGEE.from_formula(</span><span class="s3">&quot;y ~ 0 + x1 + x2&quot;</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">data=df)</span>
        <span class="s1">model.fit()</span>

        <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s1">warnings.simplefilter(</span><span class="s3">&quot;ignore&quot;</span><span class="s1">)</span>
            <span class="s1">model = gee.NominalGEE.from_formula(</span><span class="s3">&quot;y ~ 0 + x1 + x2&quot;</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">,</span>
                                                <span class="s1">data=df)</span>
            <span class="s1">model.fit()</span>

    <span class="s1">@pytest.mark.smoke</span>
    <span class="s2">def </span><span class="s1">test_ordinal_independence(self):</span>

        <span class="s1">np.random.seed(</span><span class="s4">434</span><span class="s1">)</span>
        <span class="s1">n = </span><span class="s4">40</span>
        <span class="s1">y = np.random.randint(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">n)</span>
        <span class="s1">groups = np.kron(np.arange(n / </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.r_[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">x = np.random.normal(size=(n</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>

        <span class="s1">odi = cov_struct.OrdinalIndependence()</span>
        <span class="s1">model1 = gee.OrdinalGEE(y</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">cov_struct=odi)</span>
        <span class="s1">model1.fit()</span>

    <span class="s1">@pytest.mark.smoke</span>
    <span class="s2">def </span><span class="s1">test_nominal_independence(self):</span>

        <span class="s1">np.random.seed(</span><span class="s4">434</span><span class="s1">)</span>
        <span class="s1">n = </span><span class="s4">40</span>
        <span class="s1">y = np.random.randint(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">n)</span>
        <span class="s1">groups = np.kron(np.arange(n / </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.r_[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">x = np.random.normal(size=(n</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>

        <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s1">warnings.simplefilter(</span><span class="s3">&quot;ignore&quot;</span><span class="s1">)</span>
            <span class="s1">nmi = cov_struct.NominalIndependence()</span>
            <span class="s1">model1 = gee.NominalGEE(y</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">cov_struct=nmi)</span>
            <span class="s1">model1.fit()</span>

    <span class="s1">@pytest.mark.smoke</span>
    <span class="s1">@pytest.mark.matplotlib</span>
    <span class="s2">def </span><span class="s1">test_ordinal_plot(self</span><span class="s2">, </span><span class="s1">close_figures):</span>
        <span class="s1">family = families.Binomial()</span>

        <span class="s1">endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">groups = load_data(</span><span class="s3">&quot;gee_ordinal_1.csv&quot;</span><span class="s2">,</span>
                                        <span class="s1">icept=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">va = cov_struct.GlobalOddsRatio(</span><span class="s3">&quot;ordinal&quot;</span><span class="s1">)</span>

        <span class="s1">mod = gee.OrdinalGEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, None, </span><span class="s1">family</span><span class="s2">, </span><span class="s1">va)</span>
        <span class="s1">rslt = mod.fit()</span>

        <span class="s1">fig = rslt.plot_distribution()</span>
        <span class="s1">assert_equal(isinstance(fig</span><span class="s2">, </span><span class="s1">plt.Figure)</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_nominal(self):</span>

        <span class="s1">endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">groups = load_data(</span><span class="s3">&quot;gee_nominal_1.csv&quot;</span><span class="s2">,</span>
                                        <span class="s1">icept=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s5"># Test with independence correlation</span>
        <span class="s1">va = cov_struct.Independence()</span>
        <span class="s1">mod1 = gee.NominalGEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">cov_struct=va)</span>
        <span class="s1">rslt1 = mod1.fit()</span>

        <span class="s5"># Regression test</span>
        <span class="s1">cf1 = np.r_[</span><span class="s4">0.450009</span><span class="s2">, </span><span class="s4">0.451959</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.918825</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.468266</span><span class="s1">]</span>
        <span class="s1">se1 = np.r_[</span><span class="s4">0.08915936</span><span class="s2">, </span><span class="s4">0.07005046</span><span class="s2">, </span><span class="s4">0.12198139</span><span class="s2">, </span><span class="s4">0.08281258</span><span class="s1">]</span>
        <span class="s1">assert_allclose(rslt1.params</span><span class="s2">, </span><span class="s1">cf1</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-5</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-5</span><span class="s1">)</span>
        <span class="s1">assert_allclose(rslt1.standard_errors()</span><span class="s2">, </span><span class="s1">se1</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-5</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-5</span><span class="s1">)</span>

        <span class="s5"># Test with global odds ratio dependence</span>
        <span class="s1">va = cov_struct.GlobalOddsRatio(</span><span class="s3">&quot;nominal&quot;</span><span class="s1">)</span>
        <span class="s1">mod2 = gee.NominalGEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">cov_struct=va)</span>
        <span class="s1">rslt2 = mod2.fit(start_params=rslt1.params)</span>

        <span class="s5"># Regression test</span>
        <span class="s1">cf2 = np.r_[</span><span class="s4">0.455365</span><span class="s2">, </span><span class="s4">0.415334</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.916589</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.502116</span><span class="s1">]</span>
        <span class="s1">se2 = np.r_[</span><span class="s4">0.08803614</span><span class="s2">, </span><span class="s4">0.06628179</span><span class="s2">, </span><span class="s4">0.12259726</span><span class="s2">, </span><span class="s4">0.08411064</span><span class="s1">]</span>
        <span class="s1">assert_allclose(rslt2.params</span><span class="s2">, </span><span class="s1">cf2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-5</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-5</span><span class="s1">)</span>
        <span class="s1">assert_allclose(rslt2.standard_errors()</span><span class="s2">, </span><span class="s1">se2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-5</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-5</span><span class="s1">)</span>

        <span class="s5"># Make sure we get the correct results type</span>
        <span class="s1">assert_equal(type(rslt1)</span><span class="s2">, </span><span class="s1">gee.NominalGEEResultsWrapper)</span>
        <span class="s1">assert_equal(type(rslt1._results)</span><span class="s2">, </span><span class="s1">gee.NominalGEEResults)</span>

    <span class="s2">def </span><span class="s1">test_poisson(self):</span>
        <span class="s5"># library(gee)</span>
        <span class="s5"># Z = read.csv(&quot;results/gee_poisson_1.csv&quot;, header=FALSE)</span>
        <span class="s5"># Y = Z[,2]</span>
        <span class="s5"># Id = Z[,1]</span>
        <span class="s5"># X1 = Z[,3]</span>
        <span class="s5"># X2 = Z[,4]</span>
        <span class="s5"># X3 = Z[,5]</span>
        <span class="s5"># X4 = Z[,6]</span>
        <span class="s5"># X5 = Z[,7]</span>

        <span class="s5"># mi = gee(Y ~ X1 + X2 + X3 + X4 + X5, id=Id, family=poisson,</span>
        <span class="s5">#        corstr=&quot;independence&quot;, scale.fix=TRUE)</span>
        <span class="s5"># smi = summary(mi)</span>
        <span class="s5"># u = coefficients(smi)</span>
        <span class="s5"># cfi = paste(u[,1], collapse=&quot;,&quot;)</span>
        <span class="s5"># sei = paste(u[,4], collapse=&quot;,&quot;)</span>

        <span class="s5"># me = gee(Y ~ X1 + X2 + X3 + X4 + X5, id=Id, family=poisson,</span>
        <span class="s5">#        corstr=&quot;exchangeable&quot;, scale.fix=TRUE)</span>
        <span class="s5"># sme = summary(me)</span>

        <span class="s5"># u = coefficients(sme)</span>
        <span class="s5"># cfe = paste(u[,1], collapse=&quot;,&quot;)</span>
        <span class="s5"># see = paste(u[,4], collapse=&quot;,&quot;)</span>

        <span class="s5"># sprintf(&quot;cf = [[%s],[%s]]&quot;, cfi, cfe)</span>
        <span class="s5"># sprintf(&quot;se = [[%s],[%s]]&quot;, sei, see)</span>

        <span class="s1">family = families.Poisson()</span>

        <span class="s1">endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group_n = load_data(</span><span class="s3">&quot;gee_poisson_1.csv&quot;</span><span class="s1">)</span>

        <span class="s1">vi = cov_struct.Independence()</span>
        <span class="s1">ve = cov_struct.Exchangeable()</span>

        <span class="s5"># From R gee</span>
        <span class="s1">cf = [[-</span><span class="s4">0.0364450410793481</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.0543209391301178</span><span class="s2">,</span>
               <span class="s4">0.0156642711741052</span><span class="s2">, </span><span class="s4">0.57628591338724</span><span class="s2">,</span>
               <span class="s1">-</span><span class="s4">0.00465659951186211</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.477093153099256</span><span class="s1">]</span><span class="s2">,</span>
              <span class="s1">[-</span><span class="s4">0.0315615554826533</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.0562589480840004</span><span class="s2">,</span>
               <span class="s4">0.0178419412298561</span><span class="s2">, </span><span class="s4">0.571512795340481</span><span class="s2">,</span>
               <span class="s1">-</span><span class="s4">0.00363255566297332</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.475971696727736</span><span class="s1">]]</span>
        <span class="s1">se = [[</span><span class="s4">0.0611309237214186</span><span class="s2">, </span><span class="s4">0.0390680524493108</span><span class="s2">,</span>
               <span class="s4">0.0334234174505518</span><span class="s2">, </span><span class="s4">0.0366860768962715</span><span class="s2">,</span>
               <span class="s4">0.0304758505008105</span><span class="s2">, </span><span class="s4">0.0316348058881079</span><span class="s1">]</span><span class="s2">,</span>
              <span class="s1">[</span><span class="s4">0.0610840153582275</span><span class="s2">, </span><span class="s4">0.0376887268649102</span><span class="s2">,</span>
               <span class="s4">0.0325168379415177</span><span class="s2">, </span><span class="s4">0.0369786751362213</span><span class="s2">,</span>
               <span class="s4">0.0296141014225009</span><span class="s2">, </span><span class="s4">0.0306115470200955</span><span class="s1">]]</span>

        <span class="s2">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">enumerate((vi</span><span class="s2">, </span><span class="s1">ve)):</span>
            <span class="s1">md = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group_n</span><span class="s2">, None, </span><span class="s1">family</span><span class="s2">, </span><span class="s1">v)</span>
            <span class="s1">mdf = md.fit()</span>
            <span class="s1">assert_almost_equal(mdf.params</span><span class="s2">, </span><span class="s1">cf[j]</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">5</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(mdf.standard_errors()</span><span class="s2">, </span><span class="s1">se[j]</span><span class="s2">,</span>
                                <span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>

        <span class="s5"># Test with formulas</span>
        <span class="s1">D = np.concatenate((endog[:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">group_n[:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">exog[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">:])</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">D = pd.DataFrame(D)</span>
        <span class="s1">D.columns = [</span><span class="s3">&quot;Y&quot;</span><span class="s2">, </span><span class="s3">&quot;Id&quot;</span><span class="s2">, </span><span class="s1">] + [</span><span class="s3">&quot;X%d&quot; </span><span class="s1">% (k + </span><span class="s4">1</span><span class="s1">)</span>
                                     <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range(exog.shape[</span><span class="s4">1</span><span class="s1">] - </span><span class="s4">1</span><span class="s1">)]</span>
        <span class="s2">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">enumerate((vi</span><span class="s2">, </span><span class="s1">ve)):</span>
            <span class="s1">md = gee.GEE.from_formula(</span><span class="s3">&quot;Y ~ X1 + X2 + X3 + X4 + X5&quot;</span><span class="s2">, </span><span class="s3">&quot;Id&quot;</span><span class="s2">,</span>
                                      <span class="s1">D</span><span class="s2">, </span><span class="s1">family=family</span><span class="s2">, </span><span class="s1">cov_struct=v)</span>
            <span class="s1">mdf = md.fit()</span>
            <span class="s1">assert_almost_equal(mdf.params</span><span class="s2">, </span><span class="s1">cf[j]</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">5</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(mdf.standard_errors()</span><span class="s2">, </span><span class="s1">se[j]</span><span class="s2">,</span>
                                <span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>
            <span class="s5"># print(mdf.params)</span>

    <span class="s2">def </span><span class="s1">test_groups(self):</span>
        <span class="s5"># Test various group structures (nonconsecutive, different</span>
        <span class="s5"># group sizes, not ordered, string labels)</span>

        <span class="s1">np.random.seed(</span><span class="s4">234</span><span class="s1">)</span>
        <span class="s1">n = </span><span class="s4">40</span>
        <span class="s1">x = np.random.normal(size=(n</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">y = np.random.normal(size=n)</span>

        <span class="s5"># groups with unequal group sizes</span>
        <span class="s1">groups = np.kron(np.arange(n / </span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.ones(</span><span class="s4">4</span><span class="s1">))</span>
        <span class="s1">groups[</span><span class="s4">8</span><span class="s1">:</span><span class="s4">12</span><span class="s1">] = </span><span class="s4">3</span>
        <span class="s1">groups[</span><span class="s4">34</span><span class="s1">:</span><span class="s4">36</span><span class="s1">] = </span><span class="s4">9</span>

        <span class="s1">model1 = gee.GEE(y</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">groups=groups)</span>
        <span class="s1">result1 = model1.fit()</span>

        <span class="s5"># Unordered groups</span>
        <span class="s1">ix = np.random.permutation(n)</span>
        <span class="s1">y1 = y[ix]</span>
        <span class="s1">x1 = x[ix</span><span class="s2">, </span><span class="s1">:]</span>
        <span class="s1">groups1 = groups[ix]</span>

        <span class="s1">model2 = gee.GEE(y1</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">groups=groups1)</span>
        <span class="s1">result2 = model2.fit()</span>

        <span class="s1">assert_allclose(result1.params</span><span class="s2">, </span><span class="s1">result2.params)</span>
        <span class="s1">assert_allclose(result1.tvalues</span><span class="s2">, </span><span class="s1">result2.tvalues)</span>

        <span class="s5"># group labels are strings</span>
        <span class="s1">mp = {}</span>
        <span class="s2">import </span><span class="s1">string</span>
        <span class="s2">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">g </span><span class="s2">in </span><span class="s1">enumerate(set(groups)):</span>
            <span class="s1">mp[g] = string.ascii_letters[j:j + </span><span class="s4">4</span><span class="s1">]</span>
        <span class="s1">groups2 = [mp[g] </span><span class="s2">for </span><span class="s1">g </span><span class="s2">in </span><span class="s1">groups]</span>

        <span class="s1">model3 = gee.GEE(y</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">groups=groups2)</span>
        <span class="s1">result3 = model3.fit()</span>

        <span class="s1">assert_allclose(result1.params</span><span class="s2">, </span><span class="s1">result3.params)</span>
        <span class="s1">assert_allclose(result1.tvalues</span><span class="s2">, </span><span class="s1">result3.tvalues)</span>

    <span class="s2">def </span><span class="s1">test_compare_OLS(self):</span>
        <span class="s5"># Gaussian GEE with independence correlation should agree</span>
        <span class="s5"># exactly with OLS for parameter estimates and standard errors</span>
        <span class="s5"># derived from the naive covariance estimate.</span>

        <span class="s1">vs = cov_struct.Independence()</span>
        <span class="s1">family = families.Gaussian()</span>

        <span class="s1">np.random.seed(</span><span class="s4">34234</span><span class="s1">)</span>
        <span class="s1">Y = np.random.normal(size=</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">X1 = np.random.normal(size=</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">X2 = np.random.normal(size=</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">X3 = np.random.normal(size=</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">groups = np.kron(lrange(</span><span class="s4">20</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.ones(</span><span class="s4">5</span><span class="s1">))</span>

        <span class="s1">D = pd.DataFrame({</span><span class="s3">&quot;Y&quot;</span><span class="s1">: Y</span><span class="s2">, </span><span class="s3">&quot;X1&quot;</span><span class="s1">: X1</span><span class="s2">, </span><span class="s3">&quot;X2&quot;</span><span class="s1">: X2</span><span class="s2">, </span><span class="s3">&quot;X3&quot;</span><span class="s1">: X3})</span>

        <span class="s1">md = gee.GEE.from_formula(</span><span class="s3">&quot;Y ~ X1 + X2 + X3&quot;</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">D</span><span class="s2">,</span>
                                  <span class="s1">family=family</span><span class="s2">, </span><span class="s1">cov_struct=vs)</span>
        <span class="s1">mdf = md.fit()</span>

        <span class="s1">ols = lm.OLS.from_formula(</span><span class="s3">&quot;Y ~ X1 + X2 + X3&quot;</span><span class="s2">, </span><span class="s1">data=D).fit()</span>

        <span class="s5"># do not use wrapper, asserts_xxx do not work</span>
        <span class="s1">ols = ols._results</span>

        <span class="s1">assert_almost_equal(ols.params</span><span class="s2">, </span><span class="s1">mdf.params</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">10</span><span class="s1">)</span>

        <span class="s1">se = mdf.standard_errors(cov_type=</span><span class="s3">&quot;naive&quot;</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(ols.bse</span><span class="s2">, </span><span class="s1">se</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">10</span><span class="s1">)</span>

        <span class="s1">naive_tvalues = mdf.params / np.sqrt(np.diag(mdf.cov_naive))</span>
        <span class="s1">assert_almost_equal(naive_tvalues</span><span class="s2">, </span><span class="s1">ols.tvalues</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">10</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_formulas(self):</span>
        <span class="s5"># Check formulas, especially passing groups and time as either</span>
        <span class="s5"># variable names or arrays.</span>

        <span class="s1">n = </span><span class="s4">100</span>
        <span class="s1">np.random.seed(</span><span class="s4">34234</span><span class="s1">)</span>
        <span class="s1">Y = np.random.normal(size=n)</span>
        <span class="s1">X1 = np.random.normal(size=n)</span>
        <span class="s1">mat = np.concatenate((np.ones((n</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span><span class="s2">, </span><span class="s1">X1[:</span><span class="s2">, None</span><span class="s1">])</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">Time = np.random.uniform(size=n)</span>
        <span class="s1">groups = np.kron(lrange(</span><span class="s4">20</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.ones(</span><span class="s4">5</span><span class="s1">))</span>

        <span class="s1">data = pd.DataFrame({</span><span class="s3">&quot;Y&quot;</span><span class="s1">: Y</span><span class="s2">, </span><span class="s3">&quot;X1&quot;</span><span class="s1">: X1</span><span class="s2">, </span><span class="s3">&quot;Time&quot;</span><span class="s1">: Time</span><span class="s2">, </span><span class="s3">&quot;groups&quot;</span><span class="s1">: groups})</span>

        <span class="s1">va = cov_struct.Autoregressive(grid=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">family = families.Gaussian()</span>

        <span class="s1">mod1 = gee.GEE(Y</span><span class="s2">, </span><span class="s1">mat</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">time=Time</span><span class="s2">, </span><span class="s1">family=family</span><span class="s2">,</span>
                       <span class="s1">cov_struct=va)</span>
        <span class="s1">rslt1 = mod1.fit()</span>

        <span class="s1">mod2 = gee.GEE.from_formula(</span><span class="s3">&quot;Y ~ X1&quot;</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">time=Time</span><span class="s2">,</span>
                                    <span class="s1">family=family</span><span class="s2">, </span><span class="s1">cov_struct=va)</span>
        <span class="s1">rslt2 = mod2.fit()</span>

        <span class="s1">mod3 = gee.GEE.from_formula(</span><span class="s3">&quot;Y ~ X1&quot;</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">time=</span><span class="s3">&quot;Time&quot;</span><span class="s2">,</span>
                                    <span class="s1">family=family</span><span class="s2">, </span><span class="s1">cov_struct=va)</span>
        <span class="s1">rslt3 = mod3.fit()</span>

        <span class="s1">mod4 = gee.GEE.from_formula(</span><span class="s3">&quot;Y ~ X1&quot;</span><span class="s2">, </span><span class="s3">&quot;groups&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">time=Time</span><span class="s2">,</span>
                                    <span class="s1">family=family</span><span class="s2">, </span><span class="s1">cov_struct=va)</span>
        <span class="s1">rslt4 = mod4.fit()</span>

        <span class="s1">mod5 = gee.GEE.from_formula(</span><span class="s3">&quot;Y ~ X1&quot;</span><span class="s2">, </span><span class="s3">&quot;groups&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">time=</span><span class="s3">&quot;Time&quot;</span><span class="s2">,</span>
                                    <span class="s1">family=family</span><span class="s2">, </span><span class="s1">cov_struct=va)</span>
        <span class="s1">rslt5 = mod5.fit()</span>

        <span class="s1">assert_almost_equal(rslt1.params</span><span class="s2">, </span><span class="s1">rslt2.params</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">8</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(rslt1.params</span><span class="s2">, </span><span class="s1">rslt3.params</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">8</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(rslt1.params</span><span class="s2">, </span><span class="s1">rslt4.params</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">8</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(rslt1.params</span><span class="s2">, </span><span class="s1">rslt5.params</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">8</span><span class="s1">)</span>

        <span class="s1">check_wrapper(rslt2)</span>

    <span class="s2">def </span><span class="s1">test_compare_logit(self):</span>

        <span class="s1">vs = cov_struct.Independence()</span>
        <span class="s1">family = families.Binomial()</span>

        <span class="s1">np.random.seed(</span><span class="s4">34234</span><span class="s1">)</span>
        <span class="s1">Y = </span><span class="s4">1 </span><span class="s1">* (np.random.normal(size=</span><span class="s4">100</span><span class="s1">) &lt; </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">X1 = np.random.normal(size=</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">X2 = np.random.normal(size=</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">X3 = np.random.normal(size=</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">groups = np.random.randint(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">100</span><span class="s1">)</span>

        <span class="s1">D = pd.DataFrame({</span><span class="s3">&quot;Y&quot;</span><span class="s1">: Y</span><span class="s2">, </span><span class="s3">&quot;X1&quot;</span><span class="s1">: X1</span><span class="s2">, </span><span class="s3">&quot;X2&quot;</span><span class="s1">: X2</span><span class="s2">, </span><span class="s3">&quot;X3&quot;</span><span class="s1">: X3})</span>

        <span class="s1">mod1 = gee.GEE.from_formula(</span><span class="s3">&quot;Y ~ X1 + X2 + X3&quot;</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">D</span><span class="s2">,</span>
                                    <span class="s1">family=family</span><span class="s2">, </span><span class="s1">cov_struct=vs)</span>
        <span class="s1">rslt1 = mod1.fit()</span>

        <span class="s1">mod2 = discrete.Logit.from_formula(</span><span class="s3">&quot;Y ~ X1 + X2 + X3&quot;</span><span class="s2">, </span><span class="s1">data=D)</span>
        <span class="s1">rslt2 = mod2.fit(disp=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">assert_almost_equal(rslt1.params.values</span><span class="s2">, </span><span class="s1">rslt2.params.values</span><span class="s2">,</span>
                            <span class="s1">decimal=</span><span class="s4">10</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_compare_poisson(self):</span>

        <span class="s1">vs = cov_struct.Independence()</span>
        <span class="s1">family = families.Poisson()</span>

        <span class="s1">np.random.seed(</span><span class="s4">34234</span><span class="s1">)</span>
        <span class="s1">Y = np.ceil(-np.log(np.random.uniform(size=</span><span class="s4">100</span><span class="s1">)))</span>
        <span class="s1">X1 = np.random.normal(size=</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">X2 = np.random.normal(size=</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">X3 = np.random.normal(size=</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">groups = np.random.randint(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">100</span><span class="s1">)</span>

        <span class="s1">D = pd.DataFrame({</span><span class="s3">&quot;Y&quot;</span><span class="s1">: Y</span><span class="s2">, </span><span class="s3">&quot;X1&quot;</span><span class="s1">: X1</span><span class="s2">, </span><span class="s3">&quot;X2&quot;</span><span class="s1">: X2</span><span class="s2">, </span><span class="s3">&quot;X3&quot;</span><span class="s1">: X3})</span>

        <span class="s1">mod1 = gee.GEE.from_formula(</span><span class="s3">&quot;Y ~ X1 + X2 + X3&quot;</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">D</span><span class="s2">,</span>
                                    <span class="s1">family=family</span><span class="s2">, </span><span class="s1">cov_struct=vs)</span>
        <span class="s1">rslt1 = mod1.fit()</span>

        <span class="s1">mod2 = discrete.Poisson.from_formula(</span><span class="s3">&quot;Y ~ X1 + X2 + X3&quot;</span><span class="s2">, </span><span class="s1">data=D)</span>
        <span class="s1">rslt2 = mod2.fit(disp=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">assert_almost_equal(rslt1.params.values</span><span class="s2">, </span><span class="s1">rslt2.params.values</span><span class="s2">,</span>
                            <span class="s1">decimal=</span><span class="s4">10</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_predict(self):</span>

        <span class="s1">n = </span><span class="s4">50</span>
        <span class="s1">np.random.seed(</span><span class="s4">4324</span><span class="s1">)</span>
        <span class="s1">X1 = np.random.normal(size=n)</span>
        <span class="s1">X2 = np.random.normal(size=n)</span>
        <span class="s1">groups = np.kron(np.arange(n / </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.r_[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">offset = np.random.uniform(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">size=n)</span>
        <span class="s1">Y = np.random.normal(</span><span class="s4">0.1 </span><span class="s1">* (X1 + X2) + offset</span><span class="s2">, </span><span class="s1">size=n)</span>
        <span class="s1">data = pd.DataFrame({</span><span class="s3">&quot;Y&quot;</span><span class="s1">: Y</span><span class="s2">, </span><span class="s3">&quot;X1&quot;</span><span class="s1">: X1</span><span class="s2">, </span><span class="s3">&quot;X2&quot;</span><span class="s1">: X2</span><span class="s2">, </span><span class="s3">&quot;groups&quot;</span><span class="s1">: groups</span><span class="s2">,</span>
                             <span class="s3">&quot;offset&quot;</span><span class="s1">: offset})</span>

        <span class="s1">fml = </span><span class="s3">&quot;Y ~ X1 + X2&quot;</span>
        <span class="s1">model = gee.GEE.from_formula(fml</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">data</span><span class="s2">,</span>
                                     <span class="s1">family=families.Gaussian()</span><span class="s2">,</span>
                                     <span class="s1">offset=</span><span class="s3">&quot;offset&quot;</span><span class="s1">)</span>
        <span class="s1">result = model.fit(start_params=[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.1</span><span class="s1">])</span>
        <span class="s1">assert_equal(result.converged</span><span class="s2">, True</span><span class="s1">)</span>

        <span class="s1">pred1 = result.predict()</span>
        <span class="s1">pred2 = result.predict(offset=data.offset)</span>
        <span class="s1">pred3 = result.predict(exog=data[[</span><span class="s3">&quot;X1&quot;</span><span class="s2">, </span><span class="s3">&quot;X2&quot;</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">offset=data.offset)</span>
        <span class="s1">pred4 = result.predict(exog=data[[</span><span class="s3">&quot;X1&quot;</span><span class="s2">, </span><span class="s3">&quot;X2&quot;</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">offset=</span><span class="s4">0 </span><span class="s1">* data.offset)</span>
        <span class="s1">pred5 = result.predict(offset=</span><span class="s4">0 </span><span class="s1">* data.offset)</span>

        <span class="s1">assert_allclose(pred1</span><span class="s2">, </span><span class="s1">pred2)</span>
        <span class="s1">assert_allclose(pred1</span><span class="s2">, </span><span class="s1">pred3)</span>
        <span class="s1">assert_allclose(pred1</span><span class="s2">, </span><span class="s1">pred4 + data.offset)</span>
        <span class="s1">assert_allclose(pred1</span><span class="s2">, </span><span class="s1">pred5 + data.offset)</span>

        <span class="s1">x1_new = np.random.normal(size=</span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">x2_new = np.random.normal(size=</span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">new_exog = pd.DataFrame({</span><span class="s3">&quot;X1&quot;</span><span class="s1">: x1_new</span><span class="s2">, </span><span class="s3">&quot;X2&quot;</span><span class="s1">: x2_new})</span>
        <span class="s1">pred6 = result.predict(exog=new_exog)</span>
        <span class="s1">params = result.params</span>
        <span class="s1">pred6_correct = params[</span><span class="s4">0</span><span class="s1">] + params[</span><span class="s4">1</span><span class="s1">] * x1_new + params[</span><span class="s4">2</span><span class="s1">] * x2_new</span>
        <span class="s1">assert_allclose(pred6</span><span class="s2">, </span><span class="s1">pred6_correct)</span>

    <span class="s2">def </span><span class="s1">test_stationary_grid(self):</span>

        <span class="s1">endog = np.r_[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4.</span><span class="s1">]</span>
        <span class="s1">exog = np.r_[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">group = np.r_[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span>
        <span class="s1">exog = tools.add_constant(exog)</span>

        <span class="s1">cs = cov_struct.Stationary(max_lag=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">grid=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">model = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group</span><span class="s2">, </span><span class="s1">cov_struct=cs)</span>
        <span class="s1">result = model.fit()</span>
        <span class="s1">se = result.bse * np.sqrt(</span><span class="s4">12 </span><span class="s1">/ </span><span class="s4">9.</span><span class="s1">)  </span><span class="s5"># Stata adjustment</span>

        <span class="s1">assert_allclose(cs.covariance_matrix(np.r_[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">].sum()</span><span class="s2">,</span>
                        <span class="s4">6.4633538285149452</span><span class="s1">)</span>

        <span class="s5"># Obtained from Stata using:</span>
        <span class="s5"># xtgee y x, i(g) vce(robust) corr(Stationary2)</span>
        <span class="s1">assert_allclose(result.params</span><span class="s2">, </span><span class="s1">np.r_[</span>
                        <span class="s4">4.463968</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.0386674</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-5</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-5</span><span class="s1">)</span>
        <span class="s1">assert_allclose(se</span><span class="s2">, </span><span class="s1">np.r_[</span><span class="s4">0.5217202</span><span class="s2">, </span><span class="s4">0.2800333</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-5</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_stationary_nogrid(self):</span>

        <span class="s5"># First test special case where the data follow a grid but we</span>
        <span class="s5"># fit using nogrid</span>
        <span class="s1">endog = np.r_[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4.</span><span class="s1">]</span>
        <span class="s1">exog = np.r_[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">time = np.r_[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">group = np.r_[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span>

        <span class="s1">exog = tools.add_constant(exog)</span>

        <span class="s1">model = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group</span><span class="s2">,</span>
                        <span class="s1">cov_struct=cov_struct.Stationary(max_lag=</span><span class="s4">2</span><span class="s2">,</span>
                                                         <span class="s1">grid=</span><span class="s2">False</span><span class="s1">))</span>
        <span class="s1">result = model.fit()</span>
        <span class="s1">se = result.bse * np.sqrt(</span><span class="s4">12 </span><span class="s1">/ </span><span class="s4">9.</span><span class="s1">)  </span><span class="s5"># Stata adjustment</span>

        <span class="s5"># Obtained from Stata using:</span>
        <span class="s5"># xtgee y x, i(g) vce(robust) corr(Stationary2)</span>
        <span class="s1">assert_allclose(result.params</span><span class="s2">, </span><span class="s1">np.r_[</span>
                        <span class="s4">4.463968</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.0386674</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-5</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-5</span><span class="s1">)</span>
        <span class="s1">assert_allclose(se</span><span class="s2">, </span><span class="s1">np.r_[</span><span class="s4">0.5217202</span><span class="s2">, </span><span class="s4">0.2800333</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-5</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-5</span><span class="s1">)</span>

        <span class="s5"># Smoke test for no grid  # TODO: pytest.mark.smoke&gt;</span>
        <span class="s1">time = np.r_[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">][:</span><span class="s2">, None</span><span class="s1">]</span>
        <span class="s1">model = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group</span><span class="s2">, </span><span class="s1">time=time</span><span class="s2">,</span>
                        <span class="s1">cov_struct=cov_struct.Stationary(max_lag=</span><span class="s4">4</span><span class="s2">,</span>
                                                         <span class="s1">grid=</span><span class="s2">False</span><span class="s1">))</span>
        <span class="s1">model.fit()</span>

    <span class="s2">def </span><span class="s1">test_predict_exposure(self):</span>

        <span class="s1">n = </span><span class="s4">50</span>
        <span class="s1">np.random.seed(</span><span class="s4">34234</span><span class="s1">)</span>
        <span class="s1">X1 = np.random.normal(size=n)</span>
        <span class="s1">X2 = np.random.normal(size=n)</span>
        <span class="s1">groups = np.kron(np.arange(</span><span class="s4">25</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.r_[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">offset = np.random.uniform(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">size=n)</span>
        <span class="s1">exposure = np.random.uniform(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">size=n)</span>
        <span class="s1">Y = np.random.poisson(</span><span class="s4">0.1 </span><span class="s1">* (X1 + X2) + offset +</span>
                              <span class="s1">np.log(exposure)</span><span class="s2">, </span><span class="s1">size=n)</span>
        <span class="s1">data = pd.DataFrame({</span><span class="s3">&quot;Y&quot;</span><span class="s1">: Y</span><span class="s2">, </span><span class="s3">&quot;X1&quot;</span><span class="s1">: X1</span><span class="s2">, </span><span class="s3">&quot;X2&quot;</span><span class="s1">: X2</span><span class="s2">, </span><span class="s3">&quot;groups&quot;</span><span class="s1">: groups</span><span class="s2">,</span>
                             <span class="s3">&quot;offset&quot;</span><span class="s1">: offset</span><span class="s2">, </span><span class="s3">&quot;exposure&quot;</span><span class="s1">: exposure})</span>

        <span class="s1">fml = </span><span class="s3">&quot;Y ~ X1 + X2&quot;</span>
        <span class="s1">model = gee.GEE.from_formula(fml</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">data</span><span class="s2">,</span>
                                     <span class="s1">family=families.Poisson()</span><span class="s2">,</span>
                                     <span class="s1">offset=</span><span class="s3">&quot;offset&quot;</span><span class="s2">, </span><span class="s1">exposure=</span><span class="s3">&quot;exposure&quot;</span><span class="s1">)</span>
        <span class="s1">result = model.fit()</span>
        <span class="s1">assert_equal(result.converged</span><span class="s2">, True</span><span class="s1">)</span>

        <span class="s1">pred1 = result.predict()</span>
        <span class="s1">pred2 = result.predict(offset=data[</span><span class="s3">&quot;offset&quot;</span><span class="s1">])</span>
        <span class="s1">pred3 = result.predict(exposure=data[</span><span class="s3">&quot;exposure&quot;</span><span class="s1">])</span>
        <span class="s1">pred4 = result.predict(</span>
            <span class="s1">offset=data[</span><span class="s3">&quot;offset&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">exposure=data[</span><span class="s3">&quot;exposure&quot;</span><span class="s1">])</span>
        <span class="s1">pred5 = result.predict(exog=data[-</span><span class="s4">10</span><span class="s1">:]</span><span class="s2">,</span>
                               <span class="s1">offset=data[</span><span class="s3">&quot;offset&quot;</span><span class="s1">][-</span><span class="s4">10</span><span class="s1">:]</span><span class="s2">,</span>
                               <span class="s1">exposure=data[</span><span class="s3">&quot;exposure&quot;</span><span class="s1">][-</span><span class="s4">10</span><span class="s1">:])</span>
        <span class="s5"># without patsy</span>
        <span class="s1">pred6 = result.predict(exog=result.model.exog[-</span><span class="s4">10</span><span class="s1">:]</span><span class="s2">,</span>
                               <span class="s1">offset=data[</span><span class="s3">&quot;offset&quot;</span><span class="s1">][-</span><span class="s4">10</span><span class="s1">:]</span><span class="s2">,</span>
                               <span class="s1">exposure=data[</span><span class="s3">&quot;exposure&quot;</span><span class="s1">][-</span><span class="s4">10</span><span class="s1">:]</span><span class="s2">,</span>
                               <span class="s1">transform=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">assert_allclose(pred1</span><span class="s2">, </span><span class="s1">pred2)</span>
        <span class="s1">assert_allclose(pred1</span><span class="s2">, </span><span class="s1">pred3)</span>
        <span class="s1">assert_allclose(pred1</span><span class="s2">, </span><span class="s1">pred4)</span>
        <span class="s1">assert_allclose(pred1[-</span><span class="s4">10</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">pred5)</span>
        <span class="s1">assert_allclose(pred1[-</span><span class="s4">10</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">pred6)</span>

    <span class="s2">def </span><span class="s1">test_predict_exposure_lists(self):</span>

        <span class="s1">n = </span><span class="s4">50</span>
        <span class="s1">np.random.seed(</span><span class="s4">34234</span><span class="s1">)</span>
        <span class="s1">exog = [[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">np.random.normal()</span><span class="s2">, </span><span class="s1">np.random.normal()] </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(n)]</span>
        <span class="s1">groups = list(np.kron(np.arange(</span><span class="s4">25</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.r_[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]))</span>
        <span class="s1">offset = list(np.random.uniform(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">size=n))</span>
        <span class="s1">exposure = list(np.random.uniform(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">size=n))</span>
        <span class="s1">endog = [</span>
            <span class="s1">np.random.poisson(</span>
                <span class="s4">0.1 </span><span class="s1">* (exog_i[</span><span class="s4">1</span><span class="s1">] + exog_i[</span><span class="s4">2</span><span class="s1">]) + offset_i + np.log(exposure_i)</span>
            <span class="s1">)</span>
            <span class="s2">for </span><span class="s1">exog_i</span><span class="s2">, </span><span class="s1">offset_i</span><span class="s2">, </span><span class="s1">exposure_i </span><span class="s2">in </span><span class="s1">zip(exog</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">exposure)</span>
        <span class="s1">]</span>

        <span class="s1">model = gee.GEE(</span>
            <span class="s1">endog</span><span class="s2">,</span>
            <span class="s1">exog</span><span class="s2">,</span>
            <span class="s1">groups=groups</span><span class="s2">,</span>
            <span class="s1">family=families.Poisson()</span><span class="s2">,</span>
            <span class="s1">offset=offset</span><span class="s2">,</span>
            <span class="s1">exposure=exposure</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">result = model.fit()</span>

        <span class="s1">pred1 = result.predict()</span>
        <span class="s1">pred2 = result.predict(exog=exog</span><span class="s2">, </span><span class="s1">offset=offset</span><span class="s2">, </span><span class="s1">exposure=exposure)</span>

        <span class="s1">assert_allclose(pred1</span><span class="s2">, </span><span class="s1">pred2)</span>

    <span class="s2">def </span><span class="s1">test_offset_formula(self):</span>
        <span class="s5"># Test various ways of passing offset and exposure to `from_formula`.</span>

        <span class="s1">n = </span><span class="s4">50</span>
        <span class="s1">np.random.seed(</span><span class="s4">34234</span><span class="s1">)</span>
        <span class="s1">X1 = np.random.normal(size=n)</span>
        <span class="s1">X2 = np.random.normal(size=n)</span>
        <span class="s1">groups = np.kron(np.arange(</span><span class="s4">25</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.r_[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">offset = np.random.uniform(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">size=n)</span>
        <span class="s1">exposure = np.exp(offset)</span>
        <span class="s1">Y = np.random.poisson(</span><span class="s4">0.1 </span><span class="s1">* (X1 + X2) + </span><span class="s4">2 </span><span class="s1">* offset</span><span class="s2">, </span><span class="s1">size=n)</span>
        <span class="s1">data = pd.DataFrame({</span><span class="s3">&quot;Y&quot;</span><span class="s1">: Y</span><span class="s2">, </span><span class="s3">&quot;X1&quot;</span><span class="s1">: X1</span><span class="s2">, </span><span class="s3">&quot;X2&quot;</span><span class="s1">: X2</span><span class="s2">, </span><span class="s3">&quot;groups&quot;</span><span class="s1">: groups</span><span class="s2">,</span>
                             <span class="s3">&quot;offset&quot;</span><span class="s1">: offset</span><span class="s2">, </span><span class="s3">&quot;exposure&quot;</span><span class="s1">: exposure})</span>

        <span class="s1">fml = </span><span class="s3">&quot;Y ~ X1 + X2&quot;</span>
        <span class="s1">model1 = gee.GEE.from_formula(fml</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">data</span><span class="s2">,</span>
                                      <span class="s1">family=families.Poisson()</span><span class="s2">,</span>
                                      <span class="s1">offset=</span><span class="s3">&quot;offset&quot;</span><span class="s1">)</span>
        <span class="s1">result1 = model1.fit()</span>
        <span class="s1">assert_equal(result1.converged</span><span class="s2">, True</span><span class="s1">)</span>

        <span class="s1">model2 = gee.GEE.from_formula(fml</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">data</span><span class="s2">,</span>
                                      <span class="s1">family=families.Poisson()</span><span class="s2">,</span>
                                      <span class="s1">offset=offset)</span>
        <span class="s1">result2 = model2.fit(start_params=result1.params)</span>
        <span class="s1">assert_allclose(result1.params</span><span class="s2">, </span><span class="s1">result2.params)</span>
        <span class="s1">assert_equal(result2.converged</span><span class="s2">, True</span><span class="s1">)</span>

        <span class="s1">model3 = gee.GEE.from_formula(fml</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">data</span><span class="s2">,</span>
                                      <span class="s1">family=families.Poisson()</span><span class="s2">,</span>
                                      <span class="s1">exposure=exposure)</span>
        <span class="s1">result3 = model3.fit(start_params=result1.params)</span>
        <span class="s1">assert_allclose(result1.params</span><span class="s2">, </span><span class="s1">result3.params)</span>
        <span class="s1">assert_equal(result3.converged</span><span class="s2">, True</span><span class="s1">)</span>

        <span class="s1">model4 = gee.GEE.from_formula(fml</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">data</span><span class="s2">,</span>
                                      <span class="s1">family=families.Poisson()</span><span class="s2">,</span>
                                      <span class="s1">exposure=</span><span class="s3">&quot;exposure&quot;</span><span class="s1">)</span>
        <span class="s1">result4 = model4.fit(start_params=result1.params)</span>
        <span class="s1">assert_allclose(result1.params</span><span class="s2">, </span><span class="s1">result4.params)</span>
        <span class="s1">assert_equal(result4.converged</span><span class="s2">, True</span><span class="s1">)</span>

        <span class="s1">model5 = gee.GEE.from_formula(fml</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">data</span><span class="s2">,</span>
                                      <span class="s1">family=families.Poisson()</span><span class="s2">,</span>
                                      <span class="s1">exposure=</span><span class="s3">&quot;exposure&quot;</span><span class="s2">, </span><span class="s1">offset=</span><span class="s3">&quot;offset&quot;</span><span class="s1">)</span>
        <span class="s1">result5 = model5.fit()</span>
        <span class="s1">assert_equal(result5.converged</span><span class="s2">, True</span><span class="s1">)</span>

        <span class="s1">model6 = gee.GEE.from_formula(fml</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">data</span><span class="s2">,</span>
                                      <span class="s1">family=families.Poisson()</span><span class="s2">,</span>
                                      <span class="s1">offset=</span><span class="s4">2 </span><span class="s1">* offset)</span>
        <span class="s1">result6 = model6.fit(start_params=result5.params)</span>
        <span class="s1">assert_allclose(result5.params</span><span class="s2">, </span><span class="s1">result6.params)</span>
        <span class="s1">assert_equal(result6.converged</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_sensitivity(self):</span>

        <span class="s1">va = cov_struct.Exchangeable()</span>
        <span class="s1">family = families.Gaussian()</span>

        <span class="s1">np.random.seed(</span><span class="s4">34234</span><span class="s1">)</span>
        <span class="s1">n = </span><span class="s4">100</span>
        <span class="s1">Y = np.random.normal(size=n)</span>
        <span class="s1">X1 = np.random.normal(size=n)</span>
        <span class="s1">X2 = np.random.normal(size=n)</span>
        <span class="s1">groups = np.kron(np.arange(</span><span class="s4">50</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.r_[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>

        <span class="s1">D = pd.DataFrame({</span><span class="s3">&quot;Y&quot;</span><span class="s1">: Y</span><span class="s2">, </span><span class="s3">&quot;X1&quot;</span><span class="s1">: X1</span><span class="s2">, </span><span class="s3">&quot;X2&quot;</span><span class="s1">: X2})</span>

        <span class="s1">mod = gee.GEE.from_formula(</span><span class="s3">&quot;Y ~ X1 + X2&quot;</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">D</span><span class="s2">,</span>
                                   <span class="s1">family=family</span><span class="s2">, </span><span class="s1">cov_struct=va)</span>
        <span class="s1">rslt = mod.fit()</span>
        <span class="s1">ps = rslt.params_sensitivity(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(len(ps)</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal([x.cov_struct.dep_params </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">ps]</span><span class="s2">,</span>
                            <span class="s1">[</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">])</span>

        <span class="s5"># Regression test</span>
        <span class="s1">assert_almost_equal([x.params[</span><span class="s4">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">ps]</span><span class="s2">,</span>
                            <span class="s1">[</span><span class="s4">0.1696214707458818</span><span class="s2">, </span><span class="s4">0.17836097387799127</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_equivalence(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        The Equivalence covariance structure can represent an 
        exchangeable covariance structure.  Here we check that the 
        results are identical using the two approaches. 
        &quot;&quot;&quot;</span>

        <span class="s1">np.random.seed(</span><span class="s4">3424</span><span class="s1">)</span>
        <span class="s1">endog = np.random.normal(size=</span><span class="s4">20</span><span class="s1">)</span>
        <span class="s1">exog = np.random.normal(size=(</span><span class="s4">20</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">exog[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] = </span><span class="s4">1</span>
        <span class="s1">groups = np.kron(np.arange(</span><span class="s4">5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.ones(</span><span class="s4">4</span><span class="s1">))</span>
        <span class="s1">groups[</span><span class="s4">12</span><span class="s1">:] = </span><span class="s4">3  </span><span class="s5"># Create unequal size groups</span>

        <span class="s5"># Set up an Equivalence covariance structure to mimic an</span>
        <span class="s5"># Exchangeable covariance structure.</span>
        <span class="s1">pairs = {}</span>
        <span class="s1">start = [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">12</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">4</span><span class="s1">):</span>
            <span class="s1">pairs[k] = {}</span>

            <span class="s5"># Diagonal values (variance parameters)</span>
            <span class="s2">if </span><span class="s1">k &lt; </span><span class="s4">3</span><span class="s1">:</span>
                <span class="s1">pairs[k][</span><span class="s4">0</span><span class="s1">] = (start[k] + np.r_[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">,</span>
                               <span class="s1">start[k] + np.r_[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">])</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">pairs[k][</span><span class="s4">0</span><span class="s1">] = (start[k] + np.r_[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">7</span><span class="s1">]</span><span class="s2">,</span>
                               <span class="s1">start[k] + np.r_[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">7</span><span class="s1">])</span>

            <span class="s5"># Off-diagonal pairs (covariance parameters)</span>
            <span class="s2">if </span><span class="s1">k &lt; </span><span class="s4">3</span><span class="s1">:</span>
                <span class="s1">a</span><span class="s2">, </span><span class="s1">b = np.tril_indices(</span><span class="s4">4</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
                <span class="s1">pairs[k][</span><span class="s4">1</span><span class="s1">] = (start[k] + a</span><span class="s2">, </span><span class="s1">start[k] + b)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">a</span><span class="s2">, </span><span class="s1">b = np.tril_indices(</span><span class="s4">8</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
                <span class="s1">pairs[k][</span><span class="s4">1</span><span class="s1">] = (start[k] + a</span><span class="s2">, </span><span class="s1">start[k] + b)</span>

        <span class="s1">ex = cov_struct.Exchangeable()</span>
        <span class="s1">model1 = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">cov_struct=ex)</span>
        <span class="s1">result1 = model1.fit()</span>

        <span class="s2">for </span><span class="s1">return_cov </span><span class="s2">in False, True</span><span class="s1">:</span>

            <span class="s1">ec = cov_struct.Equivalence(pairs</span><span class="s2">, </span><span class="s1">return_cov=return_cov)</span>
            <span class="s1">model2 = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">cov_struct=ec)</span>
            <span class="s1">result2 = model2.fit()</span>

            <span class="s5"># Use large atol/rtol for the correlation case since there</span>
            <span class="s5"># are some small differences in the results due to degree</span>
            <span class="s5"># of freedom differences.</span>
            <span class="s2">if </span><span class="s1">return_cov </span><span class="s2">is True</span><span class="s1">:</span>
                <span class="s1">atol</span><span class="s2">, </span><span class="s1">rtol = </span><span class="s4">1e-6</span><span class="s2">, </span><span class="s4">1e-6</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">atol</span><span class="s2">, </span><span class="s1">rtol = </span><span class="s4">1e-3</span><span class="s2">, </span><span class="s4">1e-3</span>
            <span class="s1">assert_allclose(result1.params</span><span class="s2">, </span><span class="s1">result2.params</span><span class="s2">,</span>
                            <span class="s1">atol=atol</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>
            <span class="s1">assert_allclose(result1.bse</span><span class="s2">, </span><span class="s1">result2.bse</span><span class="s2">, </span><span class="s1">atol=atol</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>
            <span class="s1">assert_allclose(result1.scale</span><span class="s2">, </span><span class="s1">result2.scale</span><span class="s2">, </span><span class="s1">atol=atol</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>

    <span class="s2">def </span><span class="s1">test_equivalence_from_pairs(self):</span>

        <span class="s1">np.random.seed(</span><span class="s4">3424</span><span class="s1">)</span>
        <span class="s1">endog = np.random.normal(size=</span><span class="s4">50</span><span class="s1">)</span>
        <span class="s1">exog = np.random.normal(size=(</span><span class="s4">50</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">exog[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] = </span><span class="s4">1</span>
        <span class="s1">groups = np.kron(np.arange(</span><span class="s4">5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.ones(</span><span class="s4">10</span><span class="s1">))</span>
        <span class="s1">groups[</span><span class="s4">30</span><span class="s1">:] = </span><span class="s4">3  </span><span class="s5"># Create unequal size groups</span>

        <span class="s5"># Set up labels.</span>
        <span class="s1">labels = np.kron(np.arange(</span><span class="s4">5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.ones(</span><span class="s4">10</span><span class="s1">)).astype(np.int32)</span>
        <span class="s1">labels = labels[np.random.permutation(len(labels))]</span>

        <span class="s1">eq = cov_struct.Equivalence(labels=labels</span><span class="s2">, </span><span class="s1">return_cov=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">model1 = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">cov_struct=eq)</span>

        <span class="s5"># Call this directly instead of letting init do it to get the</span>
        <span class="s5"># result before reindexing.</span>
        <span class="s1">eq._pairs_from_labels()</span>

        <span class="s5"># Make sure the size is correct to hold every element.</span>
        <span class="s2">for </span><span class="s1">g </span><span class="s2">in </span><span class="s1">model1.group_labels:</span>
            <span class="s1">p = eq.pairs[g]</span>
            <span class="s1">vl = [len(x[</span><span class="s4">0</span><span class="s1">]) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">p.values()]</span>
            <span class="s1">m = sum(groups == g)</span>
            <span class="s1">assert_allclose(sum(vl)</span><span class="s2">, </span><span class="s1">m * (m + </span><span class="s4">1</span><span class="s1">) / </span><span class="s4">2</span><span class="s1">)</span>

        <span class="s5"># Check for duplicates.</span>
        <span class="s1">ixs = set()</span>
        <span class="s2">for </span><span class="s1">g </span><span class="s2">in </span><span class="s1">model1.group_labels:</span>
            <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">eq.pairs[g].values():</span>
                <span class="s2">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b </span><span class="s2">in </span><span class="s1">zip(v[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">v[</span><span class="s4">1</span><span class="s1">]):</span>
                    <span class="s1">ky = (a</span><span class="s2">, </span><span class="s1">b)</span>
                    <span class="s2">assert </span><span class="s1">ky </span><span class="s2">not in </span><span class="s1">ixs</span>
                    <span class="s1">ixs.add(ky)</span>

        <span class="s5"># Smoke test  # TODO: pytest.mark.smoke?</span>
        <span class="s1">eq = cov_struct.Equivalence(labels=labels</span><span class="s2">, </span><span class="s1">return_cov=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">model1 = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">cov_struct=eq)</span>
        <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s1">warnings.simplefilter(</span><span class="s3">'ignore'</span><span class="s1">)</span>
            <span class="s1">model1.fit(maxiter=</span><span class="s4">2</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">CheckConsistency:</span>

    <span class="s1">start_params = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">test_cov_type(self):</span>
        <span class="s1">mod = self.mod</span>
        <span class="s1">res_robust = mod.fit(start_params=self.start_params)</span>
        <span class="s1">res_naive = mod.fit(start_params=self.start_params</span><span class="s2">,</span>
                            <span class="s1">cov_type=</span><span class="s3">'naive'</span><span class="s1">)</span>
        <span class="s1">res_robust_bc = mod.fit(start_params=self.start_params</span><span class="s2">,</span>
                                <span class="s1">cov_type=</span><span class="s3">'bias_reduced'</span><span class="s1">)</span>

        <span class="s5"># call summary to make sure it does not change cov_type</span>
        <span class="s1">res_naive.summary()</span>
        <span class="s1">res_robust_bc.summary()</span>

        <span class="s5"># check cov_type</span>
        <span class="s1">assert_equal(res_robust.cov_type</span><span class="s2">, </span><span class="s3">'robust'</span><span class="s1">)</span>
        <span class="s1">assert_equal(res_naive.cov_type</span><span class="s2">, </span><span class="s3">'naive'</span><span class="s1">)</span>
        <span class="s1">assert_equal(res_robust_bc.cov_type</span><span class="s2">, </span><span class="s3">'bias_reduced'</span><span class="s1">)</span>

        <span class="s5"># check bse and cov_params</span>
        <span class="s5"># we are comparing different runs of the optimization</span>
        <span class="s5"># bse in ordinal and multinomial have an atol around 5e-10 for two</span>
        <span class="s5"># consecutive calls to fit.</span>
        <span class="s1">rtol = </span><span class="s4">1e-8</span>
        <span class="s2">for </span><span class="s1">(res</span><span class="s2">, </span><span class="s1">cov_type</span><span class="s2">, </span><span class="s1">cov) </span><span class="s2">in </span><span class="s1">[</span>
                <span class="s1">(res_robust</span><span class="s2">, </span><span class="s3">'robust'</span><span class="s2">, </span><span class="s1">res_robust.cov_robust)</span><span class="s2">,</span>
                <span class="s1">(res_naive</span><span class="s2">, </span><span class="s3">'naive'</span><span class="s2">, </span><span class="s1">res_robust.cov_naive)</span><span class="s2">,</span>
                <span class="s1">(res_robust_bc</span><span class="s2">, </span><span class="s3">'bias_reduced'</span><span class="s2">, </span><span class="s1">res_robust_bc.cov_robust_bc)</span>
        <span class="s1">]:</span>
            <span class="s1">bse = np.sqrt(np.diag(cov))</span>
            <span class="s1">assert_allclose(res.bse</span><span class="s2">, </span><span class="s1">bse</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>
            <span class="s2">if </span><span class="s1">cov_type != </span><span class="s3">'bias_reduced'</span><span class="s1">:</span>
                <span class="s5"># cov_type=naive shortcuts calculation of bias reduced</span>
                <span class="s5"># covariance for efficiency</span>
                <span class="s1">bse = res_naive.standard_errors(cov_type=cov_type)</span>
                <span class="s1">assert_allclose(res.bse</span><span class="s2">, </span><span class="s1">bse</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>
            <span class="s1">assert_allclose(res.cov_params()</span><span class="s2">, </span><span class="s1">cov</span><span class="s2">, </span><span class="s1">rtol=rtol</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-10</span><span class="s1">)</span>
            <span class="s1">assert_allclose(res.cov_params_default</span><span class="s2">, </span><span class="s1">cov</span><span class="s2">, </span><span class="s1">rtol=rtol</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-10</span><span class="s1">)</span>

        <span class="s5"># assert that we do not have a copy</span>
        <span class="s1">assert_(res_robust.cov_params_default </span><span class="s2">is </span><span class="s1">res_robust.cov_robust)</span>
        <span class="s1">assert_(res_naive.cov_params_default </span><span class="s2">is </span><span class="s1">res_naive.cov_naive)</span>
        <span class="s1">assert_(res_robust_bc.cov_params_default </span><span class="s2">is</span>
                <span class="s1">res_robust_bc.cov_robust_bc)</span>

        <span class="s5"># check exception for misspelled cov_type</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">mod.fit</span><span class="s2">, </span><span class="s1">cov_type=</span><span class="s3">'robust_bc'</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestGEEPoissonCovType(CheckConsistency):</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>

        <span class="s1">endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group_n = load_data(</span><span class="s3">&quot;gee_poisson_1.csv&quot;</span><span class="s1">)</span>

        <span class="s1">family = families.Poisson()</span>
        <span class="s1">vi = cov_struct.Independence()</span>

        <span class="s1">cls.mod = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group_n</span><span class="s2">, None, </span><span class="s1">family</span><span class="s2">, </span><span class="s1">vi)</span>

        <span class="s1">cls.start_params = np.array([-</span><span class="s4">0.03644504</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.05432094</span><span class="s2">,  </span><span class="s4">0.01566427</span><span class="s2">,</span>
                                     <span class="s4">0.57628591</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.0046566</span><span class="s2">,  </span><span class="s1">-</span><span class="s4">0.47709315</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_wrapper(self):</span>

        <span class="s1">endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group_n = load_data(</span><span class="s3">&quot;gee_poisson_1.csv&quot;</span><span class="s2">,</span>
                                         <span class="s1">icept=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">endog = pd.Series(endog)</span>
        <span class="s1">exog = pd.DataFrame(exog)</span>
        <span class="s1">group_n = pd.Series(group_n)</span>

        <span class="s1">family = families.Poisson()</span>
        <span class="s1">vi = cov_struct.Independence()</span>

        <span class="s1">mod = gee.GEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group_n</span><span class="s2">, None, </span><span class="s1">family</span><span class="s2">, </span><span class="s1">vi)</span>
        <span class="s1">rslt2 = mod.fit()</span>

        <span class="s1">check_wrapper(rslt2)</span>


<span class="s2">class </span><span class="s1">TestGEEPoissonFormulaCovType(CheckConsistency):</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>

        <span class="s1">endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">group_n = load_data(</span><span class="s3">&quot;gee_poisson_1.csv&quot;</span><span class="s1">)</span>

        <span class="s1">family = families.Poisson()</span>
        <span class="s1">vi = cov_struct.Independence()</span>
        <span class="s5"># Test with formulas</span>
        <span class="s1">D = np.concatenate((endog[:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">group_n[:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">exog[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">:])</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">D = pd.DataFrame(D)</span>
        <span class="s1">D.columns = [</span><span class="s3">&quot;Y&quot;</span><span class="s2">, </span><span class="s3">&quot;Id&quot;</span><span class="s2">, </span><span class="s1">] + [</span><span class="s3">&quot;X%d&quot; </span><span class="s1">% (k + </span><span class="s4">1</span><span class="s1">)</span>
                                     <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range(exog.shape[</span><span class="s4">1</span><span class="s1">] - </span><span class="s4">1</span><span class="s1">)]</span>

        <span class="s1">cls.mod = gee.GEE.from_formula(</span><span class="s3">&quot;Y ~ X1 + X2 + X3 + X4 + X5&quot;</span><span class="s2">, </span><span class="s3">&quot;Id&quot;</span><span class="s2">,</span>
                                       <span class="s1">D</span><span class="s2">, </span><span class="s1">family=family</span><span class="s2">, </span><span class="s1">cov_struct=vi)</span>

        <span class="s1">cls.start_params = np.array([-</span><span class="s4">0.03644504</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.05432094</span><span class="s2">,  </span><span class="s4">0.01566427</span><span class="s2">,</span>
                                     <span class="s4">0.57628591</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.0046566</span><span class="s2">,  </span><span class="s1">-</span><span class="s4">0.47709315</span><span class="s1">])</span>


<span class="s2">class </span><span class="s1">TestGEEOrdinalCovType(CheckConsistency):</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>

        <span class="s1">family = families.Binomial()</span>

        <span class="s1">endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">groups = load_data(</span><span class="s3">&quot;gee_ordinal_1.csv&quot;</span><span class="s2">,</span>
                                        <span class="s1">icept=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">va = cov_struct.GlobalOddsRatio(</span><span class="s3">&quot;ordinal&quot;</span><span class="s1">)</span>

        <span class="s1">cls.mod = gee.OrdinalGEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, None, </span><span class="s1">family</span><span class="s2">, </span><span class="s1">va)</span>
        <span class="s1">cls.start_params = np.array([</span><span class="s4">1.09250002</span><span class="s2">, </span><span class="s4">0.0217443</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.39851092</span><span class="s2">,</span>
                                     <span class="s1">-</span><span class="s4">0.01812116</span><span class="s2">, </span><span class="s4">0.03023969</span><span class="s2">, </span><span class="s4">1.18258516</span><span class="s2">,</span>
                                     <span class="s4">0.01803453</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.10203381</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_wrapper(self):</span>

        <span class="s1">endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">groups = load_data(</span><span class="s3">&quot;gee_ordinal_1.csv&quot;</span><span class="s2">,</span>
                                        <span class="s1">icept=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">endog = pd.Series(endog</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">'yendog'</span><span class="s1">)</span>
        <span class="s1">exog = pd.DataFrame(exog)</span>
        <span class="s1">groups = pd.Series(groups</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">'the_group'</span><span class="s1">)</span>

        <span class="s1">family = families.Binomial()</span>
        <span class="s1">va = cov_struct.GlobalOddsRatio(</span><span class="s3">&quot;ordinal&quot;</span><span class="s1">)</span>
        <span class="s1">mod = gee.OrdinalGEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, None, </span><span class="s1">family</span><span class="s2">, </span><span class="s1">va)</span>
        <span class="s1">rslt2 = mod.fit()</span>

        <span class="s1">check_wrapper(rslt2)</span>


<span class="s2">class </span><span class="s1">TestGEEMultinomialCovType(CheckConsistency):</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>

        <span class="s1">endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">groups = load_data(</span><span class="s3">&quot;gee_nominal_1.csv&quot;</span><span class="s2">,</span>
                                        <span class="s1">icept=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s5"># Test with independence correlation</span>
        <span class="s1">va = cov_struct.Independence()</span>
        <span class="s1">cls.mod = gee.NominalGEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">cov_struct=va)</span>
        <span class="s1">cls.start_params = np.array([</span><span class="s4">0.44944752</span><span class="s2">,  </span><span class="s4">0.45569985</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.92007064</span><span class="s2">,</span>
                                     <span class="s1">-</span><span class="s4">0.46766728</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_wrapper(self):</span>

        <span class="s1">endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">groups = load_data(</span><span class="s3">&quot;gee_nominal_1.csv&quot;</span><span class="s2">,</span>
                                        <span class="s1">icept=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">endog = pd.Series(endog</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">'yendog'</span><span class="s1">)</span>
        <span class="s1">exog = pd.DataFrame(exog)</span>
        <span class="s1">groups = pd.Series(groups</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">'the_group'</span><span class="s1">)</span>

        <span class="s1">va = cov_struct.Independence()</span>
        <span class="s1">mod = gee.NominalGEE(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">cov_struct=va)</span>
        <span class="s1">rslt2 = mod.fit()</span>

        <span class="s1">check_wrapper(rslt2)</span>


<span class="s2">def </span><span class="s1">test_regularized_poisson():</span>

    <span class="s1">np.random.seed(</span><span class="s4">8735</span><span class="s1">)</span>

    <span class="s1">ng</span><span class="s2">, </span><span class="s1">gs</span><span class="s2">, </span><span class="s1">p = </span><span class="s4">1000</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span>

    <span class="s1">x = np.random.normal(size=(ng*gs</span><span class="s2">, </span><span class="s1">p))</span>
    <span class="s1">r = </span><span class="s4">0.5</span>
    <span class="s1">x[:</span><span class="s2">, </span><span class="s4">2</span><span class="s1">] = r*x[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">] + np.sqrt(</span><span class="s4">1</span><span class="s1">-r**</span><span class="s4">2</span><span class="s1">)*x[:</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span>
    <span class="s1">lpr = </span><span class="s4">0.7</span><span class="s1">*(x[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">] - x[:</span><span class="s2">, </span><span class="s4">3</span><span class="s1">])</span>
    <span class="s1">mean = np.exp(lpr)</span>
    <span class="s1">y = np.random.poisson(mean)</span>

    <span class="s1">groups = np.kron(np.arange(ng)</span><span class="s2">, </span><span class="s1">np.ones(gs))</span>

    <span class="s1">model = gee.GEE(y</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">groups=groups</span><span class="s2">, </span><span class="s1">family=families.Poisson())</span>
    <span class="s1">result = model.fit_regularized(</span><span class="s4">0.0000001</span><span class="s1">)</span>

    <span class="s1">assert_allclose(result.params</span><span class="s2">, </span><span class="s4">0.7 </span><span class="s1">* np.r_[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">rtol=</span><span class="s4">0.01</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">0.12</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_regularized_gaussian():</span>

    <span class="s5"># Example 1 from Wang et al.</span>

    <span class="s1">np.random.seed(</span><span class="s4">8735</span><span class="s1">)</span>

    <span class="s1">ng</span><span class="s2">, </span><span class="s1">gs</span><span class="s2">, </span><span class="s1">p = </span><span class="s4">200</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">200</span>

    <span class="s1">groups = np.kron(np.arange(ng)</span><span class="s2">, </span><span class="s1">np.ones(gs))</span>

    <span class="s1">x = np.zeros((ng*gs</span><span class="s2">, </span><span class="s1">p))</span>
    <span class="s1">x[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] = </span><span class="s4">1 </span><span class="s1">* (np.random.uniform(size=ng*gs) &lt; </span><span class="s4">0.5</span><span class="s1">)</span>
    <span class="s1">x[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">] = np.random.normal(size=ng*gs)</span>
    <span class="s1">r = </span><span class="s4">0.5</span>
    <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s1">eps = np.random.normal(size=ng*gs)</span>
        <span class="s1">x[:</span><span class="s2">, </span><span class="s1">j] = r * x[:</span><span class="s2">, </span><span class="s1">j-</span><span class="s4">1</span><span class="s1">] + np.sqrt(</span><span class="s4">1 </span><span class="s1">- r**</span><span class="s4">2</span><span class="s1">) * eps</span>
    <span class="s1">lpr = np.dot(x[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">:</span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.r_[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])</span>
    <span class="s1">s = </span><span class="s4">0.4</span>
    <span class="s1">e = np.sqrt(s) * np.kron(np.random.normal(size=ng)</span><span class="s2">, </span><span class="s1">np.ones(gs))</span>
    <span class="s1">e += np.sqrt(</span><span class="s4">1 </span><span class="s1">- s) * np.random.normal(size=ng*gs)</span>

    <span class="s1">y = lpr + e</span>

    <span class="s1">model = gee.GEE(y</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">cov_struct=cov_struct.Exchangeable()</span><span class="s2">, </span><span class="s1">groups=groups)</span>
    <span class="s1">result = model.fit_regularized(</span><span class="s4">0.01</span><span class="s2">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s1">)</span>

    <span class="s1">ex = np.zeros(</span><span class="s4">200</span><span class="s1">)</span>
    <span class="s1">ex[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">4</span><span class="s1">] = np.r_[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span>
    <span class="s1">assert_allclose(result.params</span><span class="s2">, </span><span class="s1">ex</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.01</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">0.2</span><span class="s1">)</span>

    <span class="s1">assert_allclose(model.cov_struct.dep_params</span><span class="s2">, </span><span class="s1">np.r_[s]</span><span class="s2">,</span>
                    <span class="s1">rtol=</span><span class="s4">0.01</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">0.05</span><span class="s1">)</span>


<span class="s1">@pytest.mark.smoke</span>
<span class="s1">@pytest.mark.matplotlib</span>
<span class="s2">def </span><span class="s1">test_plots(close_figures):</span>

    <span class="s1">np.random.seed(</span><span class="s4">378</span><span class="s1">)</span>
    <span class="s1">exog = np.random.normal(size=</span><span class="s4">100</span><span class="s1">)</span>
    <span class="s1">endog = np.random.normal(size=(</span><span class="s4">100</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
    <span class="s1">groups = np.kron(np.arange(</span><span class="s4">50</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.r_[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>

    <span class="s1">model = gee.GEE(exog</span><span class="s2">, </span><span class="s1">endog</span><span class="s2">, </span><span class="s1">groups)</span>
    <span class="s1">result = model.fit()</span>
    <span class="s1">fig = result.plot_added_variable(</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(isinstance(fig</span><span class="s2">, </span><span class="s1">plt.Figure)</span><span class="s2">, True</span><span class="s1">)</span>
    <span class="s1">fig = result.plot_partial_residuals(</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(isinstance(fig</span><span class="s2">, </span><span class="s1">plt.Figure)</span><span class="s2">, True</span><span class="s1">)</span>
    <span class="s1">fig = result.plot_ceres_residuals(</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(isinstance(fig</span><span class="s2">, </span><span class="s1">plt.Figure)</span><span class="s2">, True</span><span class="s1">)</span>
    <span class="s1">fig = result.plot_isotropic_dependence()</span>
    <span class="s1">assert_equal(isinstance(fig</span><span class="s2">, </span><span class="s1">plt.Figure)</span><span class="s2">, True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_missing():</span>
    <span class="s5"># gh-1877</span>
    <span class="s1">data = [[</span><span class="s3">'id'</span><span class="s2">, </span><span class="s3">'al'</span><span class="s2">, </span><span class="s3">'status'</span><span class="s2">, </span><span class="s3">'fake'</span><span class="s2">, </span><span class="s3">'grps'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">'4A'</span><span class="s2">, </span><span class="s3">'A'</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">'5A'</span><span class="s2">, </span><span class="s3">'A'</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">'6A'</span><span class="s2">, </span><span class="s3">'A'</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">'7A'</span><span class="s2">, </span><span class="s3">'A'</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">'8A'</span><span class="s2">, </span><span class="s3">'A'</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">'9A'</span><span class="s2">, </span><span class="s3">'A'</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">'11A'</span><span class="s2">, </span><span class="s3">'A'</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">6</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">'12A'</span><span class="s2">, </span><span class="s3">'A'</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">7</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">'13A'</span><span class="s2">, </span><span class="s3">'A'</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">8</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">'14A'</span><span class="s2">, </span><span class="s3">'A'</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">9</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">'15A'</span><span class="s2">, </span><span class="s3">'A'</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">10</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">'16A'</span><span class="s2">, </span><span class="s3">'A'</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">11</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">'17A'</span><span class="s2">, </span><span class="s3">'A'</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">12</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">'18A'</span><span class="s2">, </span><span class="s3">'A'</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">13</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">'19A'</span><span class="s2">, </span><span class="s3">'A'</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">14</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">'20A'</span><span class="s2">, </span><span class="s3">'A'</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">15</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">'2C'</span><span class="s2">, </span><span class="s3">'C'</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">'3C'</span><span class="s2">, </span><span class="s3">'C'</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">'4C'</span><span class="s2">, </span><span class="s3">'C'</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">'5C'</span><span class="s2">, </span><span class="s3">'C'</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">'6C'</span><span class="s2">, </span><span class="s3">'C'</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">'9C'</span><span class="s2">, </span><span class="s3">'C'</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">'10C'</span><span class="s2">, </span><span class="s3">'C'</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">6</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">'12C'</span><span class="s2">, </span><span class="s3">'C'</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">7</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">'14C'</span><span class="s2">, </span><span class="s3">'C'</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2.5</span><span class="s2">, </span><span class="s4">8</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">'15C'</span><span class="s2">, </span><span class="s3">'C'</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">9</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">'17C'</span><span class="s2">, </span><span class="s3">'C'</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">10</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">'22C'</span><span class="s2">, </span><span class="s3">'C'</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">11</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">'23C'</span><span class="s2">, </span><span class="s3">'C'</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">12</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">'24C'</span><span class="s2">, </span><span class="s3">'C'</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">13</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">'32C'</span><span class="s2">, </span><span class="s3">'C'</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">14</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">'35C'</span><span class="s2">, </span><span class="s3">'C'</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">15</span><span class="s1">]]</span>

    <span class="s1">df = pd.DataFrame(data[</span><span class="s4">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">columns=data[</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">df.loc[df.fake == </span><span class="s4">1</span><span class="s2">, </span><span class="s3">'fake'</span><span class="s1">] = np.nan</span>
    <span class="s1">mod = gee.GEE.from_formula(</span><span class="s3">'status ~ fake'</span><span class="s2">, </span><span class="s1">data=df</span><span class="s2">, </span><span class="s1">groups=</span><span class="s3">'grps'</span><span class="s2">,</span>
                               <span class="s1">cov_struct=cov_struct.Independence()</span><span class="s2">,</span>
                               <span class="s1">family=families.Binomial())</span>

    <span class="s1">df = df.dropna().copy()</span>
    <span class="s1">df[</span><span class="s3">'constant'</span><span class="s1">] = </span><span class="s4">1</span>

    <span class="s1">mod2 = gee.GEE(df.status</span><span class="s2">, </span><span class="s1">df[[</span><span class="s3">'constant'</span><span class="s2">, </span><span class="s3">'fake'</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">groups=df.grps</span><span class="s2">,</span>
                   <span class="s1">cov_struct=cov_struct.Independence()</span><span class="s2">,</span>
                   <span class="s1">family=families.Binomial())</span>

    <span class="s1">assert_equal(mod.endog</span><span class="s2">, </span><span class="s1">mod2.endog)</span>
    <span class="s1">assert_equal(mod.exog</span><span class="s2">, </span><span class="s1">mod2.exog)</span>
    <span class="s1">assert_equal(mod.groups</span><span class="s2">, </span><span class="s1">mod2.groups)</span>

    <span class="s1">res = mod.fit()</span>
    <span class="s1">res2 = mod2.fit()</span>

    <span class="s1">assert_almost_equal(res.params.values</span><span class="s2">, </span><span class="s1">res2.params.values)</span>


<span class="s2">def </span><span class="s1">simple_qic_data(fam):</span>

    <span class="s1">y = np.r_[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">x1 = np.r_[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">x2 = np.r_[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">g = np.r_[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span>
    <span class="s1">x1 = x1[:</span><span class="s2">, None</span><span class="s1">]</span>
    <span class="s1">x2 = x2[:</span><span class="s2">, None</span><span class="s1">]</span>

    <span class="s2">return </span><span class="s1">y</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">g</span>


<span class="s5"># Test quasi-likelihood by numerical integration in two settings</span>
<span class="s5"># where there is a closed form expression.</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;family&quot;</span><span class="s2">, </span><span class="s1">[families.Gaussian</span><span class="s2">, </span><span class="s1">families.Poisson])</span>
<span class="s2">def </span><span class="s1">test_ql_known(family):</span>

    <span class="s1">fam = family()</span>

    <span class="s1">y</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">g = simple_qic_data(family)</span>

    <span class="s1">model1 = gee.GEE(y</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">family=fam</span><span class="s2">, </span><span class="s1">groups=g)</span>
    <span class="s1">result1 = model1.fit(ddof_scale=</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">mean1 = result1.fittedvalues</span>

    <span class="s1">model2 = gee.GEE(y</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">family=fam</span><span class="s2">, </span><span class="s1">groups=g)</span>
    <span class="s1">result2 = model2.fit(ddof_scale=</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">mean2 = result2.fittedvalues</span>

    <span class="s2">if </span><span class="s1">family </span><span class="s2">is </span><span class="s1">families.Gaussian:</span>
        <span class="s1">ql1 = -len(y) / </span><span class="s4">2.</span>
        <span class="s1">ql2 = -len(y) / </span><span class="s4">2.</span>
    <span class="s2">elif </span><span class="s1">family </span><span class="s2">is </span><span class="s1">families.Poisson:</span>
        <span class="s1">c = np.zeros_like(y)</span>
        <span class="s1">ii = y &gt; </span><span class="s4">0</span>
        <span class="s1">c[ii] = y[ii] * np.log(y[ii]) - y[ii]</span>
        <span class="s1">ql1 = np.sum(y * np.log(mean1) - mean1 - c)</span>
        <span class="s1">ql2 = np.sum(y * np.log(mean2) - mean2 - c)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Unknown family&quot;</span><span class="s1">)</span>

    <span class="s1">qle1 = model1.qic(result1.params</span><span class="s2">, </span><span class="s1">result1.scale</span><span class="s2">, </span><span class="s1">result1.cov_params())</span>
    <span class="s1">qle2 = model2.qic(result2.params</span><span class="s2">, </span><span class="s1">result2.scale</span><span class="s2">, </span><span class="s1">result2.cov_params())</span>

    <span class="s1">assert_allclose(ql1</span><span class="s2">, </span><span class="s1">qle1[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-4</span><span class="s1">)</span>
    <span class="s1">assert_allclose(ql2</span><span class="s2">, </span><span class="s1">qle2[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-4</span><span class="s1">)</span>

    <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
        <span class="s1">warnings.simplefilter(</span><span class="s3">&quot;ignore&quot;</span><span class="s1">)</span>
        <span class="s1">qler1 = result1.qic()</span>
        <span class="s1">qler2 = result2.qic()</span>
    <span class="s1">assert_allclose(qler1</span><span class="s2">, </span><span class="s1">qle1[</span><span class="s4">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-5</span><span class="s1">)</span>
    <span class="s1">assert_allclose(qler2</span><span class="s2">, </span><span class="s1">qle2[</span><span class="s4">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-5</span><span class="s1">)</span>


<span class="s5"># Compare differences of QL values computed by numerical integration.</span>
<span class="s5">#  Use difference here so that constants that are inconvenient to compute</span>
<span class="s5">#  cancel out.</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;family&quot;</span><span class="s2">, </span><span class="s1">[families.Gaussian</span><span class="s2">,</span>
                                    <span class="s1">families.Binomial</span><span class="s2">,</span>
                                    <span class="s1">families.Poisson])</span>
<span class="s2">def </span><span class="s1">test_ql_diff(family):</span>

    <span class="s1">fam = family()</span>

    <span class="s1">y</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">g = simple_qic_data(family)</span>

    <span class="s1">model1 = gee.GEE(y</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">family=fam</span><span class="s2">, </span><span class="s1">groups=g)</span>
    <span class="s1">result1 = model1.fit(ddof_scale=</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">mean1 = result1.fittedvalues</span>

    <span class="s1">model2 = gee.GEE(y</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">family=fam</span><span class="s2">, </span><span class="s1">groups=g)</span>
    <span class="s1">result2 = model2.fit(ddof_scale=</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">mean2 = result2.fittedvalues</span>

    <span class="s2">if </span><span class="s1">family </span><span class="s2">is </span><span class="s1">families.Gaussian:</span>
        <span class="s1">qldiff = </span><span class="s4">0</span>
    <span class="s2">elif </span><span class="s1">family </span><span class="s2">is </span><span class="s1">families.Binomial:</span>
        <span class="s1">qldiff = np.sum(y * np.log(mean1 / (</span><span class="s4">1 </span><span class="s1">- mean1)) + np.log(</span><span class="s4">1 </span><span class="s1">- mean1))</span>
        <span class="s1">qldiff -= np.sum(y * np.log(mean2 / (</span><span class="s4">1 </span><span class="s1">- mean2)) + np.log(</span><span class="s4">1 </span><span class="s1">- mean2))</span>
    <span class="s2">elif </span><span class="s1">family </span><span class="s2">is </span><span class="s1">families.Poisson:</span>
        <span class="s1">qldiff = (np.sum(y * np.log(mean1) - mean1)</span>
                  <span class="s1">- np.sum(y * np.log(mean2) - mean2))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;unknown family&quot;</span><span class="s1">)</span>

    <span class="s1">qle1</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_ = model1.qic(result1.params</span><span class="s2">, </span><span class="s1">result1.scale</span><span class="s2">,</span>
                            <span class="s1">result1.cov_params())</span>
    <span class="s1">qle2</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_ = model2.qic(result2.params</span><span class="s2">, </span><span class="s1">result2.scale</span><span class="s2">,</span>
                            <span class="s1">result2.cov_params())</span>

    <span class="s1">assert_allclose(qle1 - qle2</span><span class="s2">, </span><span class="s1">qldiff</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-5</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-5</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_qic_warnings():</span>
    <span class="s2">with </span><span class="s1">pytest.warns(UserWarning):</span>
        <span class="s1">fam = families.Gaussian()</span>
        <span class="s1">y</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">g = simple_qic_data(fam)</span>
        <span class="s1">model = gee.GEE(y</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">family=fam</span><span class="s2">, </span><span class="s1">groups=g)</span>
        <span class="s1">result = model.fit()</span>
        <span class="s1">result.qic()</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;reg&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">False, True</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_quasipoisson(reg):</span>

    <span class="s1">np.random.seed(</span><span class="s4">343</span><span class="s1">)</span>

    <span class="s1">n = </span><span class="s4">1000</span>
    <span class="s1">x = np.random.normal(size=(n</span><span class="s2">, </span><span class="s4">3</span><span class="s1">))</span>
    <span class="s1">g = np.random.gamma(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">size=n)</span>
    <span class="s1">y = np.random.poisson(g)</span>
    <span class="s1">grp = np.kron(np.arange(</span><span class="s4">100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.ones(n // </span><span class="s4">100</span><span class="s1">))</span>

    <span class="s1">model1 = gee.GEE(y</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">family=families.Poisson()</span><span class="s2">, </span><span class="s1">groups=grp</span><span class="s2">,</span>
                     <span class="s1">)</span>
    <span class="s1">model2 = gee.GEE(y</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">family=families.Poisson()</span><span class="s2">, </span><span class="s1">groups=grp</span><span class="s2">,</span>
                     <span class="s1">)</span>

    <span class="s2">if </span><span class="s1">reg:</span>
        <span class="s1">result1 = model1.fit_regularized(pen_wt=</span><span class="s4">0.1</span><span class="s1">)</span>
        <span class="s1">result2 = model2.fit_regularized(pen_wt=</span><span class="s4">0.1</span><span class="s2">, </span><span class="s1">scale=</span><span class="s3">&quot;X2&quot;</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">result1 = model1.fit(cov_type=</span><span class="s3">&quot;naive&quot;</span><span class="s1">)</span>
        <span class="s1">result2 = model2.fit(scale=</span><span class="s3">&quot;X2&quot;</span><span class="s2">, </span><span class="s1">cov_type=</span><span class="s3">&quot;naive&quot;</span><span class="s1">)</span>

    <span class="s5"># The parameter estimates are the same regardless of how</span>
    <span class="s5"># the scale parameter is handled</span>
    <span class="s1">assert_allclose(result1.params</span><span class="s2">, </span><span class="s1">result2.params)</span>

    <span class="s2">if not </span><span class="s1">reg:</span>
        <span class="s5"># The robust covariance does not depend on the scale parameter,</span>
        <span class="s5"># but the naive covariance does.</span>
        <span class="s1">assert_allclose(result2.cov_naive / result1.cov_naive</span><span class="s2">,</span>
                        <span class="s1">result2.scale * np.ones_like(result2.cov_naive))</span>


<span class="s2">def </span><span class="s1">test_grid_ar():</span>

    <span class="s1">np.random.seed(</span><span class="s4">243</span><span class="s1">)</span>

    <span class="s1">r = </span><span class="s4">0.5</span>
    <span class="s1">m = </span><span class="s4">10</span>
    <span class="s1">ng = </span><span class="s4">100</span>
    <span class="s1">ii = np.arange(m)</span>
    <span class="s1">cov = r**np.abs(np.subtract.outer(ii</span><span class="s2">, </span><span class="s1">ii))</span>
    <span class="s1">covr = np.linalg.cholesky(cov)</span>

    <span class="s1">e = [np.dot(covr</span><span class="s2">, </span><span class="s1">np.random.normal(size=m)) </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range(ng)]</span>
    <span class="s1">e = </span><span class="s4">2 </span><span class="s1">* np.concatenate(e)</span>

    <span class="s1">grps = [[k]*m </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range(ng)]</span>
    <span class="s1">grps = np.concatenate(grps)</span>

    <span class="s1">x = np.random.normal(size=(ng*m</span><span class="s2">, </span><span class="s4">3</span><span class="s1">))</span>
    <span class="s1">y = np.dot(x</span><span class="s2">, </span><span class="s1">np.r_[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]) + e</span>

    <span class="s1">model1 = gee.GEE(y</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">groups=grps</span><span class="s2">,</span>
                     <span class="s1">cov_struct=cov_struct.Autoregressive(grid=</span><span class="s2">False</span><span class="s1">))</span>
    <span class="s1">result1 = model1.fit()</span>

    <span class="s1">model2 = gee.GEE(y</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">groups=grps</span><span class="s2">,</span>
                     <span class="s1">cov_struct=cov_struct.Autoregressive(grid=</span><span class="s2">True</span><span class="s1">))</span>
    <span class="s1">result2 = model2.fit()</span>

    <span class="s1">model3 = gee.GEE(y</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">groups=grps</span><span class="s2">,</span>
                     <span class="s1">cov_struct=cov_struct.Stationary(max_lag=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">grid=</span><span class="s2">False</span><span class="s1">))</span>
    <span class="s1">result3 = model3.fit()</span>

    <span class="s1">assert_allclose(result1.cov_struct.dep_params</span><span class="s2">,</span>
                    <span class="s1">result2.cov_struct.dep_params</span><span class="s2">,</span>
                    <span class="s1">rtol=</span><span class="s4">0.05</span><span class="s1">)</span>
    <span class="s1">assert_allclose(result1.cov_struct.dep_params</span><span class="s2">,</span>
                    <span class="s1">result3.cov_struct.dep_params[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.05</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_unstructured_complete():</span>

    <span class="s1">np.random.seed(</span><span class="s4">43</span><span class="s1">)</span>
    <span class="s1">ngrp = </span><span class="s4">400</span>
    <span class="s1">cov = np.asarray([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.7</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.7</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]])</span>
    <span class="s1">covr = np.linalg.cholesky(cov)</span>
    <span class="s1">e = np.random.normal(size=(ngrp</span><span class="s2">, </span><span class="s4">3</span><span class="s1">))</span>
    <span class="s1">e = np.dot(e</span><span class="s2">, </span><span class="s1">covr.T)</span>
    <span class="s1">xmat = np.random.normal(size=(</span><span class="s4">3</span><span class="s1">*ngrp</span><span class="s2">, </span><span class="s4">3</span><span class="s1">))</span>
    <span class="s1">par = np.r_[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0.1</span><span class="s1">]</span>
    <span class="s1">ey = np.dot(xmat</span><span class="s2">, </span><span class="s1">par)</span>
    <span class="s1">y = ey + e.ravel()</span>
    <span class="s1">g = np.kron(np.arange(ngrp)</span><span class="s2">, </span><span class="s1">np.ones(</span><span class="s4">3</span><span class="s1">))</span>
    <span class="s1">t = np.kron(np.ones(ngrp)</span><span class="s2">, </span><span class="s1">np.r_[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]).astype(int)</span>

    <span class="s1">m = gee.GEE(y</span><span class="s2">, </span><span class="s1">xmat</span><span class="s2">, </span><span class="s1">time=t</span><span class="s2">, </span><span class="s1">cov_struct=cov_struct.Unstructured()</span><span class="s2">,</span>
                <span class="s1">groups=g)</span>
    <span class="s1">r = m.fit()</span>

    <span class="s1">assert_allclose(r.params</span><span class="s2">, </span><span class="s1">par</span><span class="s2">, </span><span class="s4">0.05</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>
    <span class="s1">assert_allclose(m.cov_struct.dep_params</span><span class="s2">, </span><span class="s1">cov</span><span class="s2">, </span><span class="s4">0.05</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_unstructured_incomplete():</span>

    <span class="s1">np.random.seed(</span><span class="s4">43</span><span class="s1">)</span>
    <span class="s1">ngrp = </span><span class="s4">400</span>
    <span class="s1">cov = np.asarray([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.7</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.7</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]])</span>
    <span class="s1">covr = np.linalg.cholesky(cov)</span>
    <span class="s1">e = np.random.normal(size=(ngrp</span><span class="s2">, </span><span class="s4">3</span><span class="s1">))</span>
    <span class="s1">e = np.dot(e</span><span class="s2">, </span><span class="s1">covr.T)</span>
    <span class="s1">xmat = np.random.normal(size=(</span><span class="s4">3</span><span class="s1">*ngrp</span><span class="s2">, </span><span class="s4">3</span><span class="s1">))</span>
    <span class="s1">par = np.r_[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0.1</span><span class="s1">]</span>
    <span class="s1">ey = np.dot(xmat</span><span class="s2">, </span><span class="s1">par)</span>

    <span class="s1">yl</span><span class="s2">, </span><span class="s1">xl</span><span class="s2">, </span><span class="s1">tl</span><span class="s2">, </span><span class="s1">gl = []</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">[]</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(ngrp):</span>

        <span class="s5"># Omit one observation from each group of 3</span>
        <span class="s1">ix = [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">ix.pop(i % </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">ix = np.asarray(ix)</span>
        <span class="s1">tl.append(ix)</span>

        <span class="s1">yl.append(ey[</span><span class="s4">3</span><span class="s1">*i + ix] + e[i</span><span class="s2">, </span><span class="s1">ix])</span>
        <span class="s1">x = xmat[</span><span class="s4">3</span><span class="s1">*i + ix</span><span class="s2">, </span><span class="s1">:]</span>
        <span class="s1">xl.append(x)</span>
        <span class="s1">gl.append(i * np.ones(</span><span class="s4">2</span><span class="s1">))</span>

    <span class="s1">y = np.concatenate(yl)</span>
    <span class="s1">x = np.concatenate(xl</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">t = np.concatenate(tl)</span>
    <span class="s1">t = np.asarray(t</span><span class="s2">, </span><span class="s1">dtype=int)</span>
    <span class="s1">g = np.concatenate(gl)</span>

    <span class="s1">m = gee.GEE(y</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">time=t[:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">cov_struct=cov_struct.Unstructured()</span><span class="s2">,</span>
                <span class="s1">groups=g)</span>
    <span class="s1">r = m.fit()</span>

    <span class="s1">assert_allclose(r.params</span><span class="s2">, </span><span class="s1">par</span><span class="s2">, </span><span class="s4">0.05</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>
    <span class="s1">assert_allclose(m.cov_struct.dep_params</span><span class="s2">, </span><span class="s1">cov</span><span class="s2">, </span><span class="s4">0.05</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_ar_covsolve():</span>

    <span class="s1">np.random.seed(</span><span class="s4">123</span><span class="s1">)</span>

    <span class="s1">c = cov_struct.Autoregressive(grid=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">c.dep_params = </span><span class="s4">0.4</span>

    <span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s1">:</span>
        <span class="s2">for </span><span class="s1">q </span><span class="s2">in </span><span class="s4">1</span><span class="s2">, </span><span class="s4">4</span><span class="s1">:</span>

            <span class="s1">ii = np.arange(d)</span>
            <span class="s1">mat = </span><span class="s4">0.4 </span><span class="s1">** np.abs(np.subtract.outer(ii</span><span class="s2">, </span><span class="s1">ii))</span>
            <span class="s1">sd = np.random.uniform(size=d)</span>

            <span class="s2">if </span><span class="s1">q == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">z = np.random.normal(size=d)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">z = np.random.normal(size=(d</span><span class="s2">, </span><span class="s1">q))</span>

            <span class="s1">sm = np.diag(sd)</span>
            <span class="s1">z1 = np.linalg.solve(sm</span><span class="s2">,</span>
                                 <span class="s1">np.linalg.solve(mat</span><span class="s2">, </span><span class="s1">np.linalg.solve(sm</span><span class="s2">, </span><span class="s1">z)))</span>
            <span class="s1">z2 = c.covariance_matrix_solve(np.zeros_like(sd)</span><span class="s2">,</span>
                                           <span class="s1">np.zeros_like(sd)</span><span class="s2">,</span>
                                           <span class="s1">sd</span><span class="s2">, </span><span class="s1">[z])</span>

            <span class="s1">assert_allclose(z1</span><span class="s2">, </span><span class="s1">z2[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-5</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-5</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_ex_covsolve():</span>

    <span class="s1">np.random.seed(</span><span class="s4">123</span><span class="s1">)</span>

    <span class="s1">c = cov_struct.Exchangeable()</span>
    <span class="s1">c.dep_params = </span><span class="s4">0.4</span>

    <span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s1">:</span>
        <span class="s2">for </span><span class="s1">q </span><span class="s2">in </span><span class="s4">1</span><span class="s2">, </span><span class="s4">4</span><span class="s1">:</span>

            <span class="s1">mat = </span><span class="s4">0.4 </span><span class="s1">* np.ones((d</span><span class="s2">, </span><span class="s1">d)) + </span><span class="s4">0.6 </span><span class="s1">* np.eye(d)</span>
            <span class="s1">sd = np.random.uniform(size=d)</span>

            <span class="s2">if </span><span class="s1">q == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">z = np.random.normal(size=d)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">z = np.random.normal(size=(d</span><span class="s2">, </span><span class="s1">q))</span>

            <span class="s1">sm = np.diag(sd)</span>
            <span class="s1">z1 = np.linalg.solve(sm</span><span class="s2">,</span>
                                 <span class="s1">np.linalg.solve(mat</span><span class="s2">, </span><span class="s1">np.linalg.solve(sm</span><span class="s2">, </span><span class="s1">z)))</span>
            <span class="s1">z2 = c.covariance_matrix_solve(np.zeros_like(sd)</span><span class="s2">,</span>
                                           <span class="s1">np.arange(d</span><span class="s2">, </span><span class="s1">dtype=int)</span><span class="s2">,</span>
                                           <span class="s1">sd</span><span class="s2">, </span><span class="s1">[z])</span>

            <span class="s1">assert_allclose(z1</span><span class="s2">, </span><span class="s1">z2[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-5</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-5</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_stationary_covsolve():</span>

    <span class="s1">np.random.seed(</span><span class="s4">123</span><span class="s1">)</span>

    <span class="s1">c = cov_struct.Stationary(grid=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">c.time = np.arange(</span><span class="s4">10</span><span class="s2">, </span><span class="s1">dtype=int)</span>

    <span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s1">:</span>
        <span class="s2">for </span><span class="s1">q </span><span class="s2">in </span><span class="s4">1</span><span class="s2">, </span><span class="s4">4</span><span class="s1">:</span>

            <span class="s1">c.dep_params = (</span><span class="s4">2.0 </span><span class="s1">** (-np.arange(d)))</span>
            <span class="s1">c.max_lag = d - </span><span class="s4">1</span>
            <span class="s1">mat</span><span class="s2">, </span><span class="s1">_ = c.covariance_matrix(np.zeros(d)</span><span class="s2">,</span>
                                         <span class="s1">np.arange(d</span><span class="s2">, </span><span class="s1">dtype=int))</span>
            <span class="s1">sd = np.random.uniform(size=d)</span>

            <span class="s2">if </span><span class="s1">q == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">z = np.random.normal(size=d)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">z = np.random.normal(size=(d</span><span class="s2">, </span><span class="s1">q))</span>

            <span class="s1">sm = np.diag(sd)</span>
            <span class="s1">z1 = np.linalg.solve(sm</span><span class="s2">,</span>
                                 <span class="s1">np.linalg.solve(mat</span><span class="s2">, </span><span class="s1">np.linalg.solve(sm</span><span class="s2">, </span><span class="s1">z)))</span>
            <span class="s1">z2 = c.covariance_matrix_solve(np.zeros_like(sd)</span><span class="s2">,</span>
                                           <span class="s1">np.arange(d</span><span class="s2">, </span><span class="s1">dtype=int)</span><span class="s2">,</span>
                                           <span class="s1">sd</span><span class="s2">, </span><span class="s1">[z])</span>

            <span class="s1">assert_allclose(z1</span><span class="s2">, </span><span class="s1">z2[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-5</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-5</span><span class="s1">)</span>
</pre>
</body>
</html>