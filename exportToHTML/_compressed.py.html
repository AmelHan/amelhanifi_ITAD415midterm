<html>
<head>
<title>_compressed.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_compressed.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Base class for sparse matrix formats using compressed storage.&quot;&quot;&quot;</span>
<span class="s1">__all__ = []</span>

<span class="s2">from </span><span class="s1">warnings </span><span class="s2">import </span><span class="s1">warn</span>
<span class="s2">import </span><span class="s1">operator</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">scipy._lib._util </span><span class="s2">import </span><span class="s1">_prune_array</span>

<span class="s2">from </span><span class="s1">._base </span><span class="s2">import </span><span class="s1">_spbase</span><span class="s2">, </span><span class="s1">issparse</span><span class="s2">, </span><span class="s1">SparseEfficiencyWarning</span>
<span class="s2">from </span><span class="s1">._data </span><span class="s2">import </span><span class="s1">_data_matrix</span><span class="s2">, </span><span class="s1">_minmax_mixin</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">_sparsetools</span>
<span class="s2">from </span><span class="s1">._sparsetools </span><span class="s2">import </span><span class="s1">(get_csr_submatrix</span><span class="s2">, </span><span class="s1">csr_sample_offsets</span><span class="s2">, </span><span class="s1">csr_todense</span><span class="s2">,</span>
                           <span class="s1">csr_sample_values</span><span class="s2">, </span><span class="s1">csr_row_index</span><span class="s2">, </span><span class="s1">csr_row_slice</span><span class="s2">,</span>
                           <span class="s1">csr_column_index1</span><span class="s2">, </span><span class="s1">csr_column_index2)</span>
<span class="s2">from </span><span class="s1">._index </span><span class="s2">import </span><span class="s1">IndexMixin</span>
<span class="s2">from </span><span class="s1">._sputils </span><span class="s2">import </span><span class="s1">(upcast</span><span class="s2">, </span><span class="s1">upcast_char</span><span class="s2">, </span><span class="s1">to_native</span><span class="s2">, </span><span class="s1">isdense</span><span class="s2">, </span><span class="s1">isshape</span><span class="s2">,</span>
                       <span class="s1">getdtype</span><span class="s2">, </span><span class="s1">isscalarlike</span><span class="s2">, </span><span class="s1">isintlike</span><span class="s2">, </span><span class="s1">downcast_intp_index</span><span class="s2">, </span><span class="s1">get_sum_dtype</span><span class="s2">, </span><span class="s1">check_shape</span><span class="s2">,</span>
                       <span class="s1">is_pydata_spmatrix)</span>


<span class="s2">class </span><span class="s1">_cs_matrix(_data_matrix</span><span class="s2">, </span><span class="s1">_minmax_mixin</span><span class="s2">, </span><span class="s1">IndexMixin):</span>
    <span class="s0">&quot;&quot;&quot;base matrix class for compressed row- and column-oriented matrices&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">arg1</span><span class="s2">, </span><span class="s1">shape=</span><span class="s2">None, </span><span class="s1">dtype=</span><span class="s2">None, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">_data_matrix.__init__(self)</span>

        <span class="s2">if </span><span class="s1">issparse(arg1):</span>
            <span class="s2">if </span><span class="s1">arg1.format == self.format </span><span class="s2">and </span><span class="s1">copy:</span>
                <span class="s1">arg1 = arg1.copy()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">arg1 = arg1.asformat(self.format)</span>
            <span class="s1">self._set_self(arg1)</span>

        <span class="s2">elif </span><span class="s1">isinstance(arg1</span><span class="s2">, </span><span class="s1">tuple):</span>
            <span class="s2">if </span><span class="s1">isshape(arg1):</span>
                <span class="s3"># It's a tuple of matrix dimensions (M, N)</span>
                <span class="s3"># create empty matrix</span>
                <span class="s1">self._shape = check_shape(arg1)</span>
                <span class="s1">M</span><span class="s2">, </span><span class="s1">N = self.shape</span>
                <span class="s3"># Select index dtype large enough to pass array and</span>
                <span class="s3"># scalar parameters to sparsetools</span>
                <span class="s1">idx_dtype = self._get_index_dtype(maxval=max(M</span><span class="s2">, </span><span class="s1">N))</span>
                <span class="s1">self.data = np.zeros(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">getdtype(dtype</span><span class="s2">, </span><span class="s1">default=float))</span>
                <span class="s1">self.indices = np.zeros(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">idx_dtype)</span>
                <span class="s1">self.indptr = np.zeros(self._swap((M</span><span class="s2">, </span><span class="s1">N))[</span><span class="s4">0</span><span class="s1">] + </span><span class="s4">1</span><span class="s2">,</span>
                                       <span class="s1">dtype=idx_dtype)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">len(arg1) == </span><span class="s4">2</span><span class="s1">:</span>
                    <span class="s3"># (data, ij) format</span>
                    <span class="s1">other = self.__class__(</span>
                        <span class="s1">self._coo_container(arg1</span><span class="s2">, </span><span class="s1">shape=shape</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
                    <span class="s1">)</span>
                    <span class="s1">self._set_self(other)</span>
                <span class="s2">elif </span><span class="s1">len(arg1) == </span><span class="s4">3</span><span class="s1">:</span>
                    <span class="s3"># (data, indices, indptr) format</span>
                    <span class="s1">(data</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">indptr) = arg1</span>

                    <span class="s3"># Select index dtype large enough to pass array and</span>
                    <span class="s3"># scalar parameters to sparsetools</span>
                    <span class="s1">maxval = </span><span class="s2">None</span>
                    <span class="s2">if </span><span class="s1">shape </span><span class="s2">is not None</span><span class="s1">:</span>
                        <span class="s1">maxval = max(shape)</span>
                    <span class="s1">idx_dtype = self._get_index_dtype((indices</span><span class="s2">, </span><span class="s1">indptr)</span><span class="s2">,</span>
                                                <span class="s1">maxval=maxval</span><span class="s2">,</span>
                                                <span class="s1">check_contents=</span><span class="s2">True</span><span class="s1">)</span>

                    <span class="s1">self.indices = np.array(indices</span><span class="s2">, </span><span class="s1">copy=copy</span><span class="s2">,</span>
                                            <span class="s1">dtype=idx_dtype)</span>
                    <span class="s1">self.indptr = np.array(indptr</span><span class="s2">, </span><span class="s1">copy=copy</span><span class="s2">, </span><span class="s1">dtype=idx_dtype)</span>
                    <span class="s1">self.data = np.array(data</span><span class="s2">, </span><span class="s1">copy=copy</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;unrecognized {}_matrix &quot;</span>
                                     <span class="s5">&quot;constructor usage&quot;</span><span class="s1">.format(self.format))</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># must be dense</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">arg1 = np.asarray(arg1)</span>
            <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;unrecognized {}_matrix constructor usage&quot;</span>
                                 <span class="s5">&quot;&quot;</span><span class="s1">.format(self.format)) </span><span class="s2">from </span><span class="s1">e</span>
            <span class="s1">self._set_self(self.__class__(</span>
                <span class="s1">self._coo_container(arg1</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">))</span>

        <span class="s3"># Read matrix dimensions given, if any</span>
        <span class="s2">if </span><span class="s1">shape </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._shape = check_shape(shape)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.shape </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s3"># shape not already set, try to infer dimensions</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">major_dim = len(self.indptr) - </span><span class="s4">1</span>
                    <span class="s1">minor_dim = self.indices.max() + </span><span class="s4">1</span>
                <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'unable to infer matrix dimensions'</span><span class="s1">) </span><span class="s2">from </span><span class="s1">e</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">self._shape = check_shape(self._swap((major_dim</span><span class="s2">,</span>
                                                          <span class="s1">minor_dim)))</span>

        <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.data = self.data.astype(dtype</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">self.check_format(full_check=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_getnnz(self</span><span class="s2">, </span><span class="s1">axis=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">axis </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">int(self.indptr[-</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">axis &lt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">axis += </span><span class="s4">2</span>
            <span class="s1">axis</span><span class="s2">, </span><span class="s1">_ = self._swap((axis</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">- axis))</span>
            <span class="s1">_</span><span class="s2">, </span><span class="s1">N = self._swap(self.shape)</span>
            <span class="s2">if </span><span class="s1">axis == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">np.bincount(downcast_intp_index(self.indices)</span><span class="s2">,</span>
                                   <span class="s1">minlength=N)</span>
            <span class="s2">elif </span><span class="s1">axis == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">np.diff(self.indptr)</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'axis out of bounds'</span><span class="s1">)</span>

    <span class="s1">_getnnz.__doc__ = _spbase._getnnz.__doc__</span>

    <span class="s2">def </span><span class="s1">_set_self(self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;take the member variables of other and assign them to self&quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">copy:</span>
            <span class="s1">other = other.copy()</span>

        <span class="s1">self.data = other.data</span>
        <span class="s1">self.indices = other.indices</span>
        <span class="s1">self.indptr = other.indptr</span>
        <span class="s1">self._shape = check_shape(other.shape)</span>

    <span class="s2">def </span><span class="s1">check_format(self</span><span class="s2">, </span><span class="s1">full_check=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;check whether the matrix format is valid 
 
        Parameters 
        ---------- 
        full_check : bool, optional 
            If `True`, rigorous check, O(N) operations. Otherwise 
            basic check, O(1) operations (default True). 
        &quot;&quot;&quot;</span>
        <span class="s3"># use _swap to determine proper bounds</span>
        <span class="s1">major_name</span><span class="s2">, </span><span class="s1">minor_name = self._swap((</span><span class="s5">'row'</span><span class="s2">, </span><span class="s5">'column'</span><span class="s1">))</span>
        <span class="s1">major_dim</span><span class="s2">, </span><span class="s1">minor_dim = self._swap(self.shape)</span>

        <span class="s3"># index arrays should have integer data types</span>
        <span class="s2">if </span><span class="s1">self.indptr.dtype.kind != </span><span class="s5">'i'</span><span class="s1">:</span>
            <span class="s1">warn(</span><span class="s5">&quot;indptr array has non-integer dtype ({})&quot;</span>
                 <span class="s5">&quot;&quot;</span><span class="s1">.format(self.indptr.dtype.name)</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.indices.dtype.kind != </span><span class="s5">'i'</span><span class="s1">:</span>
            <span class="s1">warn(</span><span class="s5">&quot;indices array has non-integer dtype ({})&quot;</span>
                 <span class="s5">&quot;&quot;</span><span class="s1">.format(self.indices.dtype.name)</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s4">3</span><span class="s1">)</span>

        <span class="s1">idx_dtype = self._get_index_dtype((self.indptr</span><span class="s2">, </span><span class="s1">self.indices))</span>
        <span class="s1">self.indptr = np.asarray(self.indptr</span><span class="s2">, </span><span class="s1">dtype=idx_dtype)</span>
        <span class="s1">self.indices = np.asarray(self.indices</span><span class="s2">, </span><span class="s1">dtype=idx_dtype)</span>
        <span class="s1">self.data = to_native(self.data)</span>

        <span class="s3"># check array shapes</span>
        <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">[self.data.ndim</span><span class="s2">, </span><span class="s1">self.indices.ndim</span><span class="s2">, </span><span class="s1">self.indptr.ndim]:</span>
            <span class="s2">if </span><span class="s1">x != </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'data, indices, and indptr should be 1-D'</span><span class="s1">)</span>

        <span class="s3"># check index pointer</span>
        <span class="s2">if </span><span class="s1">(len(self.indptr) != major_dim + </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;index pointer size ({}) should be ({})&quot;</span>
                             <span class="s5">&quot;&quot;</span><span class="s1">.format(len(self.indptr)</span><span class="s2">, </span><span class="s1">major_dim + </span><span class="s4">1</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">(self.indptr[</span><span class="s4">0</span><span class="s1">] != </span><span class="s4">0</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;index pointer should start with 0&quot;</span><span class="s1">)</span>

        <span class="s3"># check index and data arrays</span>
        <span class="s2">if </span><span class="s1">(len(self.indices) != len(self.data)):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;indices and data should have the same size&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">(self.indptr[-</span><span class="s4">1</span><span class="s1">] &gt; len(self.indices)):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Last value of index pointer should be less than &quot;</span>
                             <span class="s5">&quot;the size of index and data arrays&quot;</span><span class="s1">)</span>

        <span class="s1">self.prune()</span>

        <span class="s2">if </span><span class="s1">full_check:</span>
            <span class="s3"># check format validity (more expensive)</span>
            <span class="s2">if </span><span class="s1">self.nnz &gt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">self.indices.max() &gt;= minor_dim:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;{} index values must be &lt; {}&quot;</span>
                                     <span class="s5">&quot;&quot;</span><span class="s1">.format(minor_name</span><span class="s2">, </span><span class="s1">minor_dim))</span>
                <span class="s2">if </span><span class="s1">self.indices.min() &lt; </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;{} index values must be &gt;= 0&quot;</span>
                                     <span class="s5">&quot;&quot;</span><span class="s1">.format(minor_name))</span>
                <span class="s2">if </span><span class="s1">np.diff(self.indptr).min() &lt; </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;index pointer values must form a &quot;</span>
                                     <span class="s5">&quot;non-decreasing sequence&quot;</span><span class="s1">)</span>

        <span class="s3"># if not self.has_sorted_indices():</span>
        <span class="s3">#    warn('Indices were not in sorted order.  Sorting indices.')</span>
        <span class="s3">#    self.sort_indices()</span>
        <span class="s3">#    assert(self.has_sorted_indices())</span>
        <span class="s3"># TODO check for duplicates?</span>

    <span class="s3">#######################</span>
    <span class="s3"># Boolean comparisons #</span>
    <span class="s3">#######################</span>

    <span class="s2">def </span><span class="s1">_scalar_binopt(self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">op):</span>
        <span class="s0">&quot;&quot;&quot;Scalar version of self._binopt, for cases in which no new nonzeros 
        are added. Produces a new sparse array in canonical form. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.sum_duplicates()</span>
        <span class="s1">res = self._with_data(op(self.data</span><span class="s2">, </span><span class="s1">other)</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">res.eliminate_zeros()</span>
        <span class="s2">return </span><span class="s1">res</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s3"># Scalar other.</span>
        <span class="s2">if </span><span class="s1">isscalarlike(other):</span>
            <span class="s2">if </span><span class="s1">np.isnan(other):</span>
                <span class="s2">return </span><span class="s1">self.__class__(self.shape</span><span class="s2">, </span><span class="s1">dtype=np.bool_)</span>

            <span class="s2">if </span><span class="s1">other == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">warn(</span><span class="s5">&quot;Comparing a sparse matrix with 0 using == is inefficient&quot;</span>
                     <span class="s5">&quot;, try using != instead.&quot;</span><span class="s2">, </span><span class="s1">SparseEfficiencyWarning</span><span class="s2">,</span>
                     <span class="s1">stacklevel=</span><span class="s4">3</span><span class="s1">)</span>
                <span class="s1">all_true = self.__class__(np.ones(self.shape</span><span class="s2">, </span><span class="s1">dtype=np.bool_))</span>
                <span class="s1">inv = self._scalar_binopt(other</span><span class="s2">, </span><span class="s1">operator.ne)</span>
                <span class="s2">return </span><span class="s1">all_true - inv</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self._scalar_binopt(other</span><span class="s2">, </span><span class="s1">operator.eq)</span>
        <span class="s3"># Dense other.</span>
        <span class="s2">elif </span><span class="s1">isdense(other):</span>
            <span class="s2">return </span><span class="s1">self.todense() == other</span>
        <span class="s3"># Pydata sparse other.</span>
        <span class="s2">elif </span><span class="s1">is_pydata_spmatrix(other):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>
        <span class="s3"># Sparse other.</span>
        <span class="s2">elif </span><span class="s1">issparse(other):</span>
            <span class="s1">warn(</span><span class="s5">&quot;Comparing sparse matrices using == is inefficient, try using&quot;</span>
                 <span class="s5">&quot; != instead.&quot;</span><span class="s2">, </span><span class="s1">SparseEfficiencyWarning</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s4">3</span><span class="s1">)</span>
            <span class="s3"># TODO sparse broadcasting</span>
            <span class="s2">if </span><span class="s1">self.shape != other.shape:</span>
                <span class="s2">return False</span>
            <span class="s2">elif </span><span class="s1">self.format != other.format:</span>
                <span class="s1">other = other.asformat(self.format)</span>
            <span class="s1">res = self._binopt(other</span><span class="s2">, </span><span class="s5">'_ne_'</span><span class="s1">)</span>
            <span class="s1">all_true = self.__class__(np.ones(self.shape</span><span class="s2">, </span><span class="s1">dtype=np.bool_))</span>
            <span class="s2">return </span><span class="s1">all_true - res</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s3"># Scalar other.</span>
        <span class="s2">if </span><span class="s1">isscalarlike(other):</span>
            <span class="s2">if </span><span class="s1">np.isnan(other):</span>
                <span class="s1">warn(</span><span class="s5">&quot;Comparing a sparse matrix with nan using != is&quot;</span>
                     <span class="s5">&quot; inefficient&quot;</span><span class="s2">, </span><span class="s1">SparseEfficiencyWarning</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s4">3</span><span class="s1">)</span>
                <span class="s1">all_true = self.__class__(np.ones(self.shape</span><span class="s2">, </span><span class="s1">dtype=np.bool_))</span>
                <span class="s2">return </span><span class="s1">all_true</span>
            <span class="s2">elif </span><span class="s1">other != </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">warn(</span><span class="s5">&quot;Comparing a sparse matrix with a nonzero scalar using !=&quot;</span>
                     <span class="s5">&quot; is inefficient, try using == instead.&quot;</span><span class="s2">,</span>
                     <span class="s1">SparseEfficiencyWarning</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s4">3</span><span class="s1">)</span>
                <span class="s1">all_true = self.__class__(np.ones(self.shape)</span><span class="s2">, </span><span class="s1">dtype=np.bool_)</span>
                <span class="s1">inv = self._scalar_binopt(other</span><span class="s2">, </span><span class="s1">operator.eq)</span>
                <span class="s2">return </span><span class="s1">all_true - inv</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self._scalar_binopt(other</span><span class="s2">, </span><span class="s1">operator.ne)</span>
        <span class="s3"># Dense other.</span>
        <span class="s2">elif </span><span class="s1">isdense(other):</span>
            <span class="s2">return </span><span class="s1">self.todense() != other</span>
        <span class="s3"># Pydata sparse other.</span>
        <span class="s2">elif </span><span class="s1">is_pydata_spmatrix(other):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>
        <span class="s3"># Sparse other.</span>
        <span class="s2">elif </span><span class="s1">issparse(other):</span>
            <span class="s3"># TODO sparse broadcasting</span>
            <span class="s2">if </span><span class="s1">self.shape != other.shape:</span>
                <span class="s2">return True</span>
            <span class="s2">elif </span><span class="s1">self.format != other.format:</span>
                <span class="s1">other = other.asformat(self.format)</span>
            <span class="s2">return </span><span class="s1">self._binopt(other</span><span class="s2">, </span><span class="s5">'_ne_'</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">_inequality(self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">op_name</span><span class="s2">, </span><span class="s1">bad_scalar_msg):</span>
        <span class="s3"># Scalar other.</span>
        <span class="s2">if </span><span class="s1">isscalarlike(other):</span>
            <span class="s2">if </span><span class="s4">0 </span><span class="s1">== other </span><span class="s2">and </span><span class="s1">op_name </span><span class="s2">in </span><span class="s1">(</span><span class="s5">'_le_'</span><span class="s2">, </span><span class="s5">'_ge_'</span><span class="s1">):</span>
                <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s5">&quot; &gt;= and &lt;= don't work with 0.&quot;</span><span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">op(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">other):</span>
                <span class="s1">warn(bad_scalar_msg</span><span class="s2">, </span><span class="s1">SparseEfficiencyWarning)</span>
                <span class="s1">other_arr = np.empty(self.shape</span><span class="s2">, </span><span class="s1">dtype=np.result_type(other))</span>
                <span class="s1">other_arr.fill(other)</span>
                <span class="s1">other_arr = self.__class__(other_arr)</span>
                <span class="s2">return </span><span class="s1">self._binopt(other_arr</span><span class="s2">, </span><span class="s1">op_name)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self._scalar_binopt(other</span><span class="s2">, </span><span class="s1">op)</span>
        <span class="s3"># Dense other.</span>
        <span class="s2">elif </span><span class="s1">isdense(other):</span>
            <span class="s2">return </span><span class="s1">op(self.todense()</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s3"># Sparse other.</span>
        <span class="s2">elif </span><span class="s1">issparse(other):</span>
            <span class="s3"># TODO sparse broadcasting</span>
            <span class="s2">if </span><span class="s1">self.shape != other.shape:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;inconsistent shapes&quot;</span><span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">self.format != other.format:</span>
                <span class="s1">other = other.asformat(self.format)</span>
            <span class="s2">if </span><span class="s1">op_name </span><span class="s2">not in </span><span class="s1">(</span><span class="s5">'_ge_'</span><span class="s2">, </span><span class="s5">'_le_'</span><span class="s1">):</span>
                <span class="s2">return </span><span class="s1">self._binopt(other</span><span class="s2">, </span><span class="s1">op_name)</span>

            <span class="s1">warn(</span><span class="s5">&quot;Comparing sparse matrices using &gt;= and &lt;= is inefficient, &quot;</span>
                 <span class="s5">&quot;using &lt;, &gt;, or !=, instead.&quot;</span><span class="s2">, </span><span class="s1">SparseEfficiencyWarning)</span>
            <span class="s1">all_true = self.__class__(np.ones(self.shape</span><span class="s2">, </span><span class="s1">dtype=np.bool_))</span>
            <span class="s1">res = self._binopt(other</span><span class="s2">, </span><span class="s5">'_gt_' </span><span class="s2">if </span><span class="s1">op_name == </span><span class="s5">'_le_' </span><span class="s2">else </span><span class="s5">'_lt_'</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">all_true - res</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Operands could not be compared.&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__lt__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._inequality(other</span><span class="s2">, </span><span class="s1">operator.lt</span><span class="s2">, </span><span class="s5">'_lt_'</span><span class="s2">,</span>
                                <span class="s5">&quot;Comparing a sparse matrix with a scalar &quot;</span>
                                <span class="s5">&quot;greater than zero using &lt; is inefficient, &quot;</span>
                                <span class="s5">&quot;try using &gt;= instead.&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__gt__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._inequality(other</span><span class="s2">, </span><span class="s1">operator.gt</span><span class="s2">, </span><span class="s5">'_gt_'</span><span class="s2">,</span>
                                <span class="s5">&quot;Comparing a sparse matrix with a scalar &quot;</span>
                                <span class="s5">&quot;less than zero using &gt; is inefficient, &quot;</span>
                                <span class="s5">&quot;try using &lt;= instead.&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__le__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._inequality(other</span><span class="s2">, </span><span class="s1">operator.le</span><span class="s2">, </span><span class="s5">'_le_'</span><span class="s2">,</span>
                                <span class="s5">&quot;Comparing a sparse matrix with a scalar &quot;</span>
                                <span class="s5">&quot;greater than zero using &lt;= is inefficient, &quot;</span>
                                <span class="s5">&quot;try using &gt; instead.&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__ge__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._inequality(other</span><span class="s2">, </span><span class="s1">operator.ge</span><span class="s2">, </span><span class="s5">'_ge_'</span><span class="s2">,</span>
                                <span class="s5">&quot;Comparing a sparse matrix with a scalar &quot;</span>
                                <span class="s5">&quot;less than zero using &gt;= is inefficient, &quot;</span>
                                <span class="s5">&quot;try using &lt; instead.&quot;</span><span class="s1">)</span>

    <span class="s3">#################################</span>
    <span class="s3"># Arithmetic operator overrides #</span>
    <span class="s3">#################################</span>

    <span class="s2">def </span><span class="s1">_add_dense(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if </span><span class="s1">other.shape != self.shape:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'Incompatible shapes ({} and {})'</span>
                             <span class="s1">.format(self.shape</span><span class="s2">, </span><span class="s1">other.shape))</span>
        <span class="s1">dtype = upcast_char(self.dtype.char</span><span class="s2">, </span><span class="s1">other.dtype.char)</span>
        <span class="s1">order = self._swap(</span><span class="s5">'CF'</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">result = np.array(other</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">order=order</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">M</span><span class="s2">, </span><span class="s1">N = self._swap(self.shape)</span>
        <span class="s1">y = result </span><span class="s2">if </span><span class="s1">result.flags.c_contiguous </span><span class="s2">else </span><span class="s1">result.T</span>
        <span class="s1">csr_todense(M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">self.indptr</span><span class="s2">, </span><span class="s1">self.indices</span><span class="s2">, </span><span class="s1">self.data</span><span class="s2">, </span><span class="s1">y)</span>
        <span class="s2">return </span><span class="s1">self._container(result</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_add_sparse(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._binopt(other</span><span class="s2">, </span><span class="s5">'_plus_'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_sub_sparse(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._binopt(other</span><span class="s2">, </span><span class="s5">'_minus_'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">multiply(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot;Point-wise multiplication by another matrix, vector, or 
        scalar. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Scalar multiplication.</span>
        <span class="s2">if </span><span class="s1">isscalarlike(other):</span>
            <span class="s2">return </span><span class="s1">self._mul_scalar(other)</span>
        <span class="s3"># Sparse matrix or vector.</span>
        <span class="s2">if </span><span class="s1">issparse(other):</span>
            <span class="s2">if </span><span class="s1">self.shape == other.shape:</span>
                <span class="s1">other = self.__class__(other)</span>
                <span class="s2">return </span><span class="s1">self._binopt(other</span><span class="s2">, </span><span class="s5">'_elmul_'</span><span class="s1">)</span>
            <span class="s3"># Single element.</span>
            <span class="s2">elif </span><span class="s1">other.shape == (</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">):</span>
                <span class="s2">return </span><span class="s1">self._mul_scalar(other.toarray()[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>
            <span class="s2">elif </span><span class="s1">self.shape == (</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">):</span>
                <span class="s2">return </span><span class="s1">other._mul_scalar(self.toarray()[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>
            <span class="s3"># A row times a column.</span>
            <span class="s2">elif </span><span class="s1">self.shape[</span><span class="s4">1</span><span class="s1">] == </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">other.shape[</span><span class="s4">0</span><span class="s1">] == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self._mul_sparse_matrix(other.tocsc())</span>
            <span class="s2">elif </span><span class="s1">self.shape[</span><span class="s4">0</span><span class="s1">] == </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">other.shape[</span><span class="s4">1</span><span class="s1">] == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">other._mul_sparse_matrix(self.tocsc())</span>
            <span class="s3"># Row vector times matrix. other is a row.</span>
            <span class="s2">elif </span><span class="s1">other.shape[</span><span class="s4">0</span><span class="s1">] == </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">self.shape[</span><span class="s4">1</span><span class="s1">] == other.shape[</span><span class="s4">1</span><span class="s1">]:</span>
                <span class="s1">other = self._dia_container(</span>
                    <span class="s1">(other.toarray().ravel()</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">,</span>
                    <span class="s1">shape=(other.shape[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">other.shape[</span><span class="s4">1</span><span class="s1">])</span>
                <span class="s1">)</span>
                <span class="s2">return </span><span class="s1">self._mul_sparse_matrix(other)</span>
            <span class="s3"># self is a row.</span>
            <span class="s2">elif </span><span class="s1">self.shape[</span><span class="s4">0</span><span class="s1">] == </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">self.shape[</span><span class="s4">1</span><span class="s1">] == other.shape[</span><span class="s4">1</span><span class="s1">]:</span>
                <span class="s1">copy = self._dia_container(</span>
                    <span class="s1">(self.toarray().ravel()</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">,</span>
                    <span class="s1">shape=(self.shape[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.shape[</span><span class="s4">1</span><span class="s1">])</span>
                <span class="s1">)</span>
                <span class="s2">return </span><span class="s1">other._mul_sparse_matrix(copy)</span>
            <span class="s3"># Column vector times matrix. other is a column.</span>
            <span class="s2">elif </span><span class="s1">other.shape[</span><span class="s4">1</span><span class="s1">] == </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">self.shape[</span><span class="s4">0</span><span class="s1">] == other.shape[</span><span class="s4">0</span><span class="s1">]:</span>
                <span class="s1">other = self._dia_container(</span>
                    <span class="s1">(other.toarray().ravel()</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">,</span>
                    <span class="s1">shape=(other.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">other.shape[</span><span class="s4">0</span><span class="s1">])</span>
                <span class="s1">)</span>
                <span class="s2">return </span><span class="s1">other._mul_sparse_matrix(self)</span>
            <span class="s3"># self is a column.</span>
            <span class="s2">elif </span><span class="s1">self.shape[</span><span class="s4">1</span><span class="s1">] == </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">self.shape[</span><span class="s4">0</span><span class="s1">] == other.shape[</span><span class="s4">0</span><span class="s1">]:</span>
                <span class="s1">copy = self._dia_container(</span>
                    <span class="s1">(self.toarray().ravel()</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">,</span>
                    <span class="s1">shape=(self.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.shape[</span><span class="s4">0</span><span class="s1">])</span>
                <span class="s1">)</span>
                <span class="s2">return </span><span class="s1">copy._mul_sparse_matrix(other)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;inconsistent shapes&quot;</span><span class="s1">)</span>

        <span class="s3"># Assume other is a dense matrix/array, which produces a single-item</span>
        <span class="s3"># object array if other isn't convertible to ndarray.</span>
        <span class="s1">other = np.atleast_2d(other)</span>

        <span class="s2">if </span><span class="s1">other.ndim != </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">np.multiply(self.toarray()</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s3"># Single element / wrapped object.</span>
        <span class="s2">if </span><span class="s1">other.size == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._mul_scalar(other.flat[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s3"># Fast case for trivial sparse matrix.</span>
        <span class="s2">elif </span><span class="s1">self.shape == (</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">np.multiply(self.toarray()[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">other)</span>

        <span class="s1">ret = self.tocoo()</span>
        <span class="s3"># Matching shapes.</span>
        <span class="s2">if </span><span class="s1">self.shape == other.shape:</span>
            <span class="s1">data = np.multiply(ret.data</span><span class="s2">, </span><span class="s1">other[ret.row</span><span class="s2">, </span><span class="s1">ret.col])</span>
        <span class="s3"># Sparse row vector times...</span>
        <span class="s2">elif </span><span class="s1">self.shape[</span><span class="s4">0</span><span class="s1">] == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">other.shape[</span><span class="s4">1</span><span class="s1">] == </span><span class="s4">1</span><span class="s1">:  </span><span class="s3"># Dense column vector.</span>
                <span class="s1">data = np.multiply(ret.data</span><span class="s2">, </span><span class="s1">other)</span>
            <span class="s2">elif </span><span class="s1">other.shape[</span><span class="s4">1</span><span class="s1">] == self.shape[</span><span class="s4">1</span><span class="s1">]:  </span><span class="s3"># Dense matrix.</span>
                <span class="s1">data = np.multiply(ret.data</span><span class="s2">, </span><span class="s1">other[:</span><span class="s2">, </span><span class="s1">ret.col])</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;inconsistent shapes&quot;</span><span class="s1">)</span>
            <span class="s1">row = np.repeat(np.arange(other.shape[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">, </span><span class="s1">len(ret.row))</span>
            <span class="s1">col = np.tile(ret.col</span><span class="s2">, </span><span class="s1">other.shape[</span><span class="s4">0</span><span class="s1">])</span>
            <span class="s2">return </span><span class="s1">self._coo_container(</span>
                <span class="s1">(data.view(np.ndarray).ravel()</span><span class="s2">, </span><span class="s1">(row</span><span class="s2">, </span><span class="s1">col))</span><span class="s2">,</span>
                <span class="s1">shape=(other.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.shape[</span><span class="s4">1</span><span class="s1">])</span><span class="s2">,</span>
                <span class="s1">copy=</span><span class="s2">False</span>
            <span class="s1">)</span>
        <span class="s3"># Sparse column vector times...</span>
        <span class="s2">elif </span><span class="s1">self.shape[</span><span class="s4">1</span><span class="s1">] == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">other.shape[</span><span class="s4">0</span><span class="s1">] == </span><span class="s4">1</span><span class="s1">:  </span><span class="s3"># Dense row vector.</span>
                <span class="s1">data = np.multiply(ret.data[:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">other)</span>
            <span class="s2">elif </span><span class="s1">other.shape[</span><span class="s4">0</span><span class="s1">] == self.shape[</span><span class="s4">0</span><span class="s1">]:  </span><span class="s3"># Dense matrix.</span>
                <span class="s1">data = np.multiply(ret.data[:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">other[ret.row])</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;inconsistent shapes&quot;</span><span class="s1">)</span>
            <span class="s1">row = np.repeat(ret.row</span><span class="s2">, </span><span class="s1">other.shape[</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s1">col = np.tile(np.arange(other.shape[</span><span class="s4">1</span><span class="s1">])</span><span class="s2">, </span><span class="s1">len(ret.col))</span>
            <span class="s2">return </span><span class="s1">self._coo_container(</span>
                <span class="s1">(data.view(np.ndarray).ravel()</span><span class="s2">, </span><span class="s1">(row</span><span class="s2">, </span><span class="s1">col))</span><span class="s2">,</span>
                <span class="s1">shape=(self.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">other.shape[</span><span class="s4">1</span><span class="s1">])</span><span class="s2">,</span>
                <span class="s1">copy=</span><span class="s2">False</span>
            <span class="s1">)</span>
        <span class="s3"># Sparse matrix times dense row vector.</span>
        <span class="s2">elif </span><span class="s1">other.shape[</span><span class="s4">0</span><span class="s1">] == </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">self.shape[</span><span class="s4">1</span><span class="s1">] == other.shape[</span><span class="s4">1</span><span class="s1">]:</span>
            <span class="s1">data = np.multiply(ret.data</span><span class="s2">, </span><span class="s1">other[:</span><span class="s2">, </span><span class="s1">ret.col].ravel())</span>
        <span class="s3"># Sparse matrix times dense column vector.</span>
        <span class="s2">elif </span><span class="s1">other.shape[</span><span class="s4">1</span><span class="s1">] == </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">self.shape[</span><span class="s4">0</span><span class="s1">] == other.shape[</span><span class="s4">0</span><span class="s1">]:</span>
            <span class="s1">data = np.multiply(ret.data</span><span class="s2">, </span><span class="s1">other[ret.row].ravel())</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;inconsistent shapes&quot;</span><span class="s1">)</span>
        <span class="s1">ret.data = data.view(np.ndarray).ravel()</span>
        <span class="s2">return </span><span class="s1">ret</span>

    <span class="s3">###########################</span>
    <span class="s3"># Multiplication handlers #</span>
    <span class="s3">###########################</span>

    <span class="s2">def </span><span class="s1">_mul_vector(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s1">M</span><span class="s2">, </span><span class="s1">N = self.shape</span>

        <span class="s3"># output array</span>
        <span class="s1">result = np.zeros(M</span><span class="s2">, </span><span class="s1">dtype=upcast_char(self.dtype.char</span><span class="s2">,</span>
                                               <span class="s1">other.dtype.char))</span>

        <span class="s3"># csr_matvec or csc_matvec</span>
        <span class="s1">fn = getattr(_sparsetools</span><span class="s2">, </span><span class="s1">self.format + </span><span class="s5">'_matvec'</span><span class="s1">)</span>
        <span class="s1">fn(M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">self.indptr</span><span class="s2">, </span><span class="s1">self.indices</span><span class="s2">, </span><span class="s1">self.data</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">result)</span>

        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">_mul_multivector(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s1">M</span><span class="s2">, </span><span class="s1">N = self.shape</span>
        <span class="s1">n_vecs = other.shape[</span><span class="s4">1</span><span class="s1">]  </span><span class="s3"># number of column vectors</span>

        <span class="s1">result = np.zeros((M</span><span class="s2">, </span><span class="s1">n_vecs)</span><span class="s2">,</span>
                          <span class="s1">dtype=upcast_char(self.dtype.char</span><span class="s2">, </span><span class="s1">other.dtype.char))</span>

        <span class="s3"># csr_matvecs or csc_matvecs</span>
        <span class="s1">fn = getattr(_sparsetools</span><span class="s2">, </span><span class="s1">self.format + </span><span class="s5">'_matvecs'</span><span class="s1">)</span>
        <span class="s1">fn(M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">n_vecs</span><span class="s2">, </span><span class="s1">self.indptr</span><span class="s2">, </span><span class="s1">self.indices</span><span class="s2">, </span><span class="s1">self.data</span><span class="s2">,</span>
           <span class="s1">other.ravel()</span><span class="s2">, </span><span class="s1">result.ravel())</span>

        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">_mul_sparse_matrix(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s1">M</span><span class="s2">, </span><span class="s1">K1 = self.shape</span>
        <span class="s1">K2</span><span class="s2">, </span><span class="s1">N = other.shape</span>

        <span class="s1">major_axis = self._swap((M</span><span class="s2">, </span><span class="s1">N))[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">other = self.__class__(other)  </span><span class="s3"># convert to this format</span>

        <span class="s1">idx_dtype = self._get_index_dtype((self.indptr</span><span class="s2">, </span><span class="s1">self.indices</span><span class="s2">,</span>
                                     <span class="s1">other.indptr</span><span class="s2">, </span><span class="s1">other.indices))</span>

        <span class="s1">fn = getattr(_sparsetools</span><span class="s2">, </span><span class="s1">self.format + </span><span class="s5">'_matmat_maxnnz'</span><span class="s1">)</span>
        <span class="s1">nnz = fn(M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">,</span>
                 <span class="s1">np.asarray(self.indptr</span><span class="s2">, </span><span class="s1">dtype=idx_dtype)</span><span class="s2">,</span>
                 <span class="s1">np.asarray(self.indices</span><span class="s2">, </span><span class="s1">dtype=idx_dtype)</span><span class="s2">,</span>
                 <span class="s1">np.asarray(other.indptr</span><span class="s2">, </span><span class="s1">dtype=idx_dtype)</span><span class="s2">,</span>
                 <span class="s1">np.asarray(other.indices</span><span class="s2">, </span><span class="s1">dtype=idx_dtype))</span>

        <span class="s1">idx_dtype = self._get_index_dtype((self.indptr</span><span class="s2">, </span><span class="s1">self.indices</span><span class="s2">,</span>
                                     <span class="s1">other.indptr</span><span class="s2">, </span><span class="s1">other.indices)</span><span class="s2">,</span>
                                    <span class="s1">maxval=nnz)</span>

        <span class="s1">indptr = np.empty(major_axis + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">dtype=idx_dtype)</span>
        <span class="s1">indices = np.empty(nnz</span><span class="s2">, </span><span class="s1">dtype=idx_dtype)</span>
        <span class="s1">data = np.empty(nnz</span><span class="s2">, </span><span class="s1">dtype=upcast(self.dtype</span><span class="s2">, </span><span class="s1">other.dtype))</span>

        <span class="s1">fn = getattr(_sparsetools</span><span class="s2">, </span><span class="s1">self.format + </span><span class="s5">'_matmat'</span><span class="s1">)</span>
        <span class="s1">fn(M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">np.asarray(self.indptr</span><span class="s2">, </span><span class="s1">dtype=idx_dtype)</span><span class="s2">,</span>
           <span class="s1">np.asarray(self.indices</span><span class="s2">, </span><span class="s1">dtype=idx_dtype)</span><span class="s2">,</span>
           <span class="s1">self.data</span><span class="s2">,</span>
           <span class="s1">np.asarray(other.indptr</span><span class="s2">, </span><span class="s1">dtype=idx_dtype)</span><span class="s2">,</span>
           <span class="s1">np.asarray(other.indices</span><span class="s2">, </span><span class="s1">dtype=idx_dtype)</span><span class="s2">,</span>
           <span class="s1">other.data</span><span class="s2">,</span>
           <span class="s1">indptr</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">data)</span>

        <span class="s2">return </span><span class="s1">self.__class__((data</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">indptr)</span><span class="s2">, </span><span class="s1">shape=(M</span><span class="s2">, </span><span class="s1">N))</span>

    <span class="s2">def </span><span class="s1">diagonal(self</span><span class="s2">, </span><span class="s1">k=</span><span class="s4">0</span><span class="s1">):</span>
        <span class="s1">rows</span><span class="s2">, </span><span class="s1">cols = self.shape</span>
        <span class="s2">if </span><span class="s1">k &lt;= -rows </span><span class="s2">or </span><span class="s1">k &gt;= cols:</span>
            <span class="s2">return </span><span class="s1">np.empty(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">dtype=self.data.dtype)</span>
        <span class="s1">fn = getattr(_sparsetools</span><span class="s2">, </span><span class="s1">self.format + </span><span class="s5">&quot;_diagonal&quot;</span><span class="s1">)</span>
        <span class="s1">y = np.empty(min(rows + min(k</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">cols - max(k</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span><span class="s2">,</span>
                     <span class="s1">dtype=upcast(self.dtype))</span>
        <span class="s1">fn(k</span><span class="s2">, </span><span class="s1">self.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.shape[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.indptr</span><span class="s2">, </span><span class="s1">self.indices</span><span class="s2">,</span>
           <span class="s1">self.data</span><span class="s2">, </span><span class="s1">y)</span>
        <span class="s2">return </span><span class="s1">y</span>

    <span class="s1">diagonal.__doc__ = _spbase.diagonal.__doc__</span>

    <span class="s3">#####################</span>
    <span class="s3"># Other binary ops  #</span>
    <span class="s3">#####################</span>

    <span class="s2">def </span><span class="s1">_maximum_minimum(self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">npop</span><span class="s2">, </span><span class="s1">op_name</span><span class="s2">, </span><span class="s1">dense_check):</span>
        <span class="s2">if </span><span class="s1">isscalarlike(other):</span>
            <span class="s2">if </span><span class="s1">dense_check(other):</span>
                <span class="s1">warn(</span><span class="s5">&quot;Taking maximum (minimum) with &gt; 0 (&lt; 0) number results&quot;</span>
                     <span class="s5">&quot; to a dense matrix.&quot;</span><span class="s2">, </span><span class="s1">SparseEfficiencyWarning</span><span class="s2">,</span>
                     <span class="s1">stacklevel=</span><span class="s4">3</span><span class="s1">)</span>
                <span class="s1">other_arr = np.empty(self.shape</span><span class="s2">, </span><span class="s1">dtype=np.asarray(other).dtype)</span>
                <span class="s1">other_arr.fill(other)</span>
                <span class="s1">other_arr = self.__class__(other_arr)</span>
                <span class="s2">return </span><span class="s1">self._binopt(other_arr</span><span class="s2">, </span><span class="s1">op_name)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.sum_duplicates()</span>
                <span class="s1">new_data = npop(self.data</span><span class="s2">, </span><span class="s1">np.asarray(other))</span>
                <span class="s1">mat = self.__class__((new_data</span><span class="s2">, </span><span class="s1">self.indices</span><span class="s2">, </span><span class="s1">self.indptr)</span><span class="s2">,</span>
                                     <span class="s1">dtype=new_data.dtype</span><span class="s2">, </span><span class="s1">shape=self.shape)</span>
                <span class="s2">return </span><span class="s1">mat</span>
        <span class="s2">elif </span><span class="s1">isdense(other):</span>
            <span class="s2">return </span><span class="s1">npop(self.todense()</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s2">elif </span><span class="s1">issparse(other):</span>
            <span class="s2">return </span><span class="s1">self._binopt(other</span><span class="s2">, </span><span class="s1">op_name)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Operands not compatible.&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">maximum(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._maximum_minimum(other</span><span class="s2">, </span><span class="s1">np.maximum</span><span class="s2">,</span>
                                     <span class="s5">'_maximum_'</span><span class="s2">, lambda </span><span class="s1">x: np.asarray(x) &gt; </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s1">maximum.__doc__ = _spbase.maximum.__doc__</span>

    <span class="s2">def </span><span class="s1">minimum(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self._maximum_minimum(other</span><span class="s2">, </span><span class="s1">np.minimum</span><span class="s2">,</span>
                                     <span class="s5">'_minimum_'</span><span class="s2">, lambda </span><span class="s1">x: np.asarray(x) &lt; </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s1">minimum.__doc__ = _spbase.minimum.__doc__</span>

    <span class="s3">#####################</span>
    <span class="s3"># Reduce operations #</span>
    <span class="s3">#####################</span>

    <span class="s2">def </span><span class="s1">sum(self</span><span class="s2">, </span><span class="s1">axis=</span><span class="s2">None, </span><span class="s1">dtype=</span><span class="s2">None, </span><span class="s1">out=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Sum the matrix over the given axis.  If the axis is None, sum 
        over both rows and columns, returning a scalar. 
        &quot;&quot;&quot;</span>
        <span class="s3"># The _spbase base class already does axis=0 and axis=1 efficiently</span>
        <span class="s3"># so we only do the case axis=None here</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">not </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s5">'blocksize'</span><span class="s1">) </span><span class="s2">and</span>
                <span class="s1">axis </span><span class="s2">in </span><span class="s1">self._swap(((</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)))[</span><span class="s4">0</span><span class="s1">]):</span>
            <span class="s3"># faster than multiplication for large minor axis in CSC/CSR</span>
            <span class="s1">res_dtype = get_sum_dtype(self.dtype)</span>
            <span class="s1">ret = np.zeros(len(self.indptr) - </span><span class="s4">1</span><span class="s2">, </span><span class="s1">dtype=res_dtype)</span>

            <span class="s1">major_index</span><span class="s2">, </span><span class="s1">value = self._minor_reduce(np.add)</span>
            <span class="s1">ret[major_index] = value</span>
            <span class="s1">ret = self._ascontainer(ret)</span>
            <span class="s2">if </span><span class="s1">axis % </span><span class="s4">2 </span><span class="s1">== </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">ret = ret.T</span>

            <span class="s2">if </span><span class="s1">out </span><span class="s2">is not None and </span><span class="s1">out.shape != ret.shape:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'dimensions do not match'</span><span class="s1">)</span>

            <span class="s2">return </span><span class="s1">ret.sum(axis=()</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">out=out)</span>
        <span class="s3"># _spbase will handle the remaining situations when axis</span>
        <span class="s3"># is in {None, -1, 0, 1}</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">_spbase.sum(self</span><span class="s2">, </span><span class="s1">axis=axis</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">out=out)</span>

    <span class="s1">sum.__doc__ = _spbase.sum.__doc__</span>

    <span class="s2">def </span><span class="s1">_minor_reduce(self</span><span class="s2">, </span><span class="s1">ufunc</span><span class="s2">, </span><span class="s1">data=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Reduce nonzeros with a ufunc over the minor axis when non-empty 
 
        Can be applied to a function of self.data by supplying data parameter. 
 
        Warning: this does not call sum_duplicates() 
 
        Returns 
        ------- 
        major_index : array of ints 
            Major indices where nonzero 
 
        value : array of self.dtype 
            Reduce result for nonzeros in each major_index 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">data </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">data = self.data</span>
        <span class="s1">major_index = np.flatnonzero(np.diff(self.indptr))</span>
        <span class="s1">value = ufunc.reduceat(data</span><span class="s2">,</span>
                               <span class="s1">downcast_intp_index(self.indptr[major_index]))</span>
        <span class="s2">return </span><span class="s1">major_index</span><span class="s2">, </span><span class="s1">value</span>

    <span class="s3">#######################</span>
    <span class="s3"># Getting and Setting #</span>
    <span class="s3">#######################</span>

    <span class="s2">def </span><span class="s1">_get_intXint(self</span><span class="s2">, </span><span class="s1">row</span><span class="s2">, </span><span class="s1">col):</span>
        <span class="s1">M</span><span class="s2">, </span><span class="s1">N = self._swap(self.shape)</span>
        <span class="s1">major</span><span class="s2">, </span><span class="s1">minor = self._swap((row</span><span class="s2">, </span><span class="s1">col))</span>
        <span class="s1">indptr</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">data = get_csr_submatrix(</span>
            <span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">self.indptr</span><span class="s2">, </span><span class="s1">self.indices</span><span class="s2">, </span><span class="s1">self.data</span><span class="s2">,</span>
            <span class="s1">major</span><span class="s2">, </span><span class="s1">major + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">minor</span><span class="s2">, </span><span class="s1">minor + </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">data.sum(dtype=self.dtype)</span>

    <span class="s2">def </span><span class="s1">_get_sliceXslice(self</span><span class="s2">, </span><span class="s1">row</span><span class="s2">, </span><span class="s1">col):</span>
        <span class="s1">major</span><span class="s2">, </span><span class="s1">minor = self._swap((row</span><span class="s2">, </span><span class="s1">col))</span>
        <span class="s2">if </span><span class="s1">major.step </span><span class="s2">in </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">and </span><span class="s1">minor.step </span><span class="s2">in </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, None</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">self._get_submatrix(major</span><span class="s2">, </span><span class="s1">minor</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self._major_slice(major)._minor_slice(minor)</span>

    <span class="s2">def </span><span class="s1">_get_arrayXarray(self</span><span class="s2">, </span><span class="s1">row</span><span class="s2">, </span><span class="s1">col):</span>
        <span class="s3"># inner indexing</span>
        <span class="s1">idx_dtype = self.indices.dtype</span>
        <span class="s1">M</span><span class="s2">, </span><span class="s1">N = self._swap(self.shape)</span>
        <span class="s1">major</span><span class="s2">, </span><span class="s1">minor = self._swap((row</span><span class="s2">, </span><span class="s1">col))</span>
        <span class="s1">major = np.asarray(major</span><span class="s2">, </span><span class="s1">dtype=idx_dtype)</span>
        <span class="s1">minor = np.asarray(minor</span><span class="s2">, </span><span class="s1">dtype=idx_dtype)</span>

        <span class="s1">val = np.empty(major.size</span><span class="s2">, </span><span class="s1">dtype=self.dtype)</span>
        <span class="s1">csr_sample_values(M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">self.indptr</span><span class="s2">, </span><span class="s1">self.indices</span><span class="s2">, </span><span class="s1">self.data</span><span class="s2">,</span>
                          <span class="s1">major.size</span><span class="s2">, </span><span class="s1">major.ravel()</span><span class="s2">, </span><span class="s1">minor.ravel()</span><span class="s2">, </span><span class="s1">val)</span>
        <span class="s2">if </span><span class="s1">major.ndim == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._ascontainer(val)</span>
        <span class="s2">return </span><span class="s1">self.__class__(val.reshape(major.shape))</span>

    <span class="s2">def </span><span class="s1">_get_columnXarray(self</span><span class="s2">, </span><span class="s1">row</span><span class="s2">, </span><span class="s1">col):</span>
        <span class="s3"># outer indexing</span>
        <span class="s1">major</span><span class="s2">, </span><span class="s1">minor = self._swap((row</span><span class="s2">, </span><span class="s1">col))</span>
        <span class="s2">return </span><span class="s1">self._major_index_fancy(major)._minor_index_fancy(minor)</span>

    <span class="s2">def </span><span class="s1">_major_index_fancy(self</span><span class="s2">, </span><span class="s1">idx):</span>
        <span class="s0">&quot;&quot;&quot;Index along the major axis where idx is an array of ints. 
        &quot;&quot;&quot;</span>
        <span class="s1">idx_dtype = self.indices.dtype</span>
        <span class="s1">indices = np.asarray(idx</span><span class="s2">, </span><span class="s1">dtype=idx_dtype).ravel()</span>

        <span class="s1">_</span><span class="s2">, </span><span class="s1">N = self._swap(self.shape)</span>
        <span class="s1">M = len(indices)</span>
        <span class="s1">new_shape = self._swap((M</span><span class="s2">, </span><span class="s1">N))</span>
        <span class="s2">if </span><span class="s1">M == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.__class__(new_shape</span><span class="s2">, </span><span class="s1">dtype=self.dtype)</span>

        <span class="s1">row_nnz = self.indptr[indices + </span><span class="s4">1</span><span class="s1">] - self.indptr[indices]</span>
        <span class="s1">idx_dtype = self.indices.dtype</span>
        <span class="s1">res_indptr = np.zeros(M+</span><span class="s4">1</span><span class="s2">, </span><span class="s1">dtype=idx_dtype)</span>
        <span class="s1">np.cumsum(row_nnz</span><span class="s2">, </span><span class="s1">out=res_indptr[</span><span class="s4">1</span><span class="s1">:])</span>

        <span class="s1">nnz = res_indptr[-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">res_indices = np.empty(nnz</span><span class="s2">, </span><span class="s1">dtype=idx_dtype)</span>
        <span class="s1">res_data = np.empty(nnz</span><span class="s2">, </span><span class="s1">dtype=self.dtype)</span>
        <span class="s1">csr_row_index(M</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">self.indptr</span><span class="s2">, </span><span class="s1">self.indices</span><span class="s2">, </span><span class="s1">self.data</span><span class="s2">,</span>
                      <span class="s1">res_indices</span><span class="s2">, </span><span class="s1">res_data)</span>

        <span class="s2">return </span><span class="s1">self.__class__((res_data</span><span class="s2">, </span><span class="s1">res_indices</span><span class="s2">, </span><span class="s1">res_indptr)</span><span class="s2">,</span>
                              <span class="s1">shape=new_shape</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_major_slice(self</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Index along the major axis where idx is a slice object. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">idx == slice(</span><span class="s2">None</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">self.copy() </span><span class="s2">if </span><span class="s1">copy </span><span class="s2">else </span><span class="s1">self</span>

        <span class="s1">M</span><span class="s2">, </span><span class="s1">N = self._swap(self.shape)</span>
        <span class="s1">start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">step = idx.indices(M)</span>
        <span class="s1">M = len(range(start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">step))</span>
        <span class="s1">new_shape = self._swap((M</span><span class="s2">, </span><span class="s1">N))</span>
        <span class="s2">if </span><span class="s1">M == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.__class__(new_shape</span><span class="s2">, </span><span class="s1">dtype=self.dtype)</span>

        <span class="s3"># Work out what slices are needed for `row_nnz`</span>
        <span class="s3"># start,stop can be -1, only if step is negative</span>
        <span class="s1">start0</span><span class="s2">, </span><span class="s1">stop0 = start</span><span class="s2">, </span><span class="s1">stop</span>
        <span class="s2">if </span><span class="s1">stop == -</span><span class="s4">1 </span><span class="s2">and </span><span class="s1">start &gt;= </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">stop0 = </span><span class="s2">None</span>
        <span class="s1">start1</span><span class="s2">, </span><span class="s1">stop1 = start + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">stop + </span><span class="s4">1</span>

        <span class="s1">row_nnz = self.indptr[start1:stop1:step] - \</span>
            <span class="s1">self.indptr[start0:stop0:step]</span>
        <span class="s1">idx_dtype = self.indices.dtype</span>
        <span class="s1">res_indptr = np.zeros(M+</span><span class="s4">1</span><span class="s2">, </span><span class="s1">dtype=idx_dtype)</span>
        <span class="s1">np.cumsum(row_nnz</span><span class="s2">, </span><span class="s1">out=res_indptr[</span><span class="s4">1</span><span class="s1">:])</span>

        <span class="s2">if </span><span class="s1">step == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">all_idx = slice(self.indptr[start]</span><span class="s2">, </span><span class="s1">self.indptr[stop])</span>
            <span class="s1">res_indices = np.array(self.indices[all_idx]</span><span class="s2">, </span><span class="s1">copy=copy)</span>
            <span class="s1">res_data = np.array(self.data[all_idx]</span><span class="s2">, </span><span class="s1">copy=copy)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">nnz = res_indptr[-</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">res_indices = np.empty(nnz</span><span class="s2">, </span><span class="s1">dtype=idx_dtype)</span>
            <span class="s1">res_data = np.empty(nnz</span><span class="s2">, </span><span class="s1">dtype=self.dtype)</span>
            <span class="s1">csr_row_slice(start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">step</span><span class="s2">, </span><span class="s1">self.indptr</span><span class="s2">, </span><span class="s1">self.indices</span><span class="s2">,</span>
                          <span class="s1">self.data</span><span class="s2">, </span><span class="s1">res_indices</span><span class="s2">, </span><span class="s1">res_data)</span>

        <span class="s2">return </span><span class="s1">self.__class__((res_data</span><span class="s2">, </span><span class="s1">res_indices</span><span class="s2">, </span><span class="s1">res_indptr)</span><span class="s2">,</span>
                              <span class="s1">shape=new_shape</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_minor_index_fancy(self</span><span class="s2">, </span><span class="s1">idx):</span>
        <span class="s0">&quot;&quot;&quot;Index along the minor axis where idx is an array of ints. 
        &quot;&quot;&quot;</span>
        <span class="s1">idx_dtype = self.indices.dtype</span>
        <span class="s1">idx = np.asarray(idx</span><span class="s2">, </span><span class="s1">dtype=idx_dtype).ravel()</span>

        <span class="s1">M</span><span class="s2">, </span><span class="s1">N = self._swap(self.shape)</span>
        <span class="s1">k = len(idx)</span>
        <span class="s1">new_shape = self._swap((M</span><span class="s2">, </span><span class="s1">k))</span>
        <span class="s2">if </span><span class="s1">k == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.__class__(new_shape</span><span class="s2">, </span><span class="s1">dtype=self.dtype)</span>

        <span class="s3"># pass 1: count idx entries and compute new indptr</span>
        <span class="s1">col_offsets = np.zeros(N</span><span class="s2">, </span><span class="s1">dtype=idx_dtype)</span>
        <span class="s1">res_indptr = np.empty_like(self.indptr)</span>
        <span class="s1">csr_column_index1(k</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">self.indptr</span><span class="s2">, </span><span class="s1">self.indices</span><span class="s2">,</span>
                          <span class="s1">col_offsets</span><span class="s2">, </span><span class="s1">res_indptr)</span>

        <span class="s3"># pass 2: copy indices/data for selected idxs</span>
        <span class="s1">col_order = np.argsort(idx).astype(idx_dtype</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">nnz = res_indptr[-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">res_indices = np.empty(nnz</span><span class="s2">, </span><span class="s1">dtype=idx_dtype)</span>
        <span class="s1">res_data = np.empty(nnz</span><span class="s2">, </span><span class="s1">dtype=self.dtype)</span>
        <span class="s1">csr_column_index2(col_order</span><span class="s2">, </span><span class="s1">col_offsets</span><span class="s2">, </span><span class="s1">len(self.indices)</span><span class="s2">,</span>
                          <span class="s1">self.indices</span><span class="s2">, </span><span class="s1">self.data</span><span class="s2">, </span><span class="s1">res_indices</span><span class="s2">, </span><span class="s1">res_data)</span>
        <span class="s2">return </span><span class="s1">self.__class__((res_data</span><span class="s2">, </span><span class="s1">res_indices</span><span class="s2">, </span><span class="s1">res_indptr)</span><span class="s2">,</span>
                              <span class="s1">shape=new_shape</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_minor_slice(self</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Index along the minor axis where idx is a slice object. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">idx == slice(</span><span class="s2">None</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">self.copy() </span><span class="s2">if </span><span class="s1">copy </span><span class="s2">else </span><span class="s1">self</span>

        <span class="s1">M</span><span class="s2">, </span><span class="s1">N = self._swap(self.shape)</span>
        <span class="s1">start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">step = idx.indices(N)</span>
        <span class="s1">N = len(range(start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">step))</span>
        <span class="s2">if </span><span class="s1">N == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.__class__(self._swap((M</span><span class="s2">, </span><span class="s1">N))</span><span class="s2">, </span><span class="s1">dtype=self.dtype)</span>
        <span class="s2">if </span><span class="s1">step == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._get_submatrix(minor=idx</span><span class="s2">, </span><span class="s1">copy=copy)</span>
        <span class="s3"># TODO: don't fall back to fancy indexing here</span>
        <span class="s2">return </span><span class="s1">self._minor_index_fancy(np.arange(start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">step))</span>

    <span class="s2">def </span><span class="s1">_get_submatrix(self</span><span class="s2">, </span><span class="s1">major=</span><span class="s2">None, </span><span class="s1">minor=</span><span class="s2">None, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Return a submatrix of this matrix. 
 
        major, minor: None, int, or slice with step 1 
        &quot;&quot;&quot;</span>
        <span class="s1">M</span><span class="s2">, </span><span class="s1">N = self._swap(self.shape)</span>
        <span class="s1">i0</span><span class="s2">, </span><span class="s1">i1 = _process_slice(major</span><span class="s2">, </span><span class="s1">M)</span>
        <span class="s1">j0</span><span class="s2">, </span><span class="s1">j1 = _process_slice(minor</span><span class="s2">, </span><span class="s1">N)</span>

        <span class="s2">if </span><span class="s1">i0 == </span><span class="s4">0 </span><span class="s2">and </span><span class="s1">j0 == </span><span class="s4">0 </span><span class="s2">and </span><span class="s1">i1 == M </span><span class="s2">and </span><span class="s1">j1 == N:</span>
            <span class="s2">return </span><span class="s1">self.copy() </span><span class="s2">if </span><span class="s1">copy </span><span class="s2">else </span><span class="s1">self</span>

        <span class="s1">indptr</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">data = get_csr_submatrix(</span>
            <span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">self.indptr</span><span class="s2">, </span><span class="s1">self.indices</span><span class="s2">, </span><span class="s1">self.data</span><span class="s2">, </span><span class="s1">i0</span><span class="s2">, </span><span class="s1">i1</span><span class="s2">, </span><span class="s1">j0</span><span class="s2">, </span><span class="s1">j1)</span>

        <span class="s1">shape = self._swap((i1 - i0</span><span class="s2">, </span><span class="s1">j1 - j0))</span>
        <span class="s2">return </span><span class="s1">self.__class__((data</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">indptr)</span><span class="s2">, </span><span class="s1">shape=shape</span><span class="s2">,</span>
                              <span class="s1">dtype=self.dtype</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_set_intXint(self</span><span class="s2">, </span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s1">i</span><span class="s2">, </span><span class="s1">j = self._swap((row</span><span class="s2">, </span><span class="s1">col))</span>
        <span class="s1">self._set_many(i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s2">def </span><span class="s1">_set_arrayXarray(self</span><span class="s2">, </span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s1">i</span><span class="s2">, </span><span class="s1">j = self._swap((row</span><span class="s2">, </span><span class="s1">col))</span>
        <span class="s1">self._set_many(i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s2">def </span><span class="s1">_set_arrayXarray_sparse(self</span><span class="s2">, </span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s3"># clear entries that will be overwritten</span>
        <span class="s1">self._zero_many(*self._swap((row</span><span class="s2">, </span><span class="s1">col)))</span>

        <span class="s1">M</span><span class="s2">, </span><span class="s1">N = row.shape  </span><span class="s3"># matches col.shape</span>
        <span class="s1">broadcast_row = M != </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">x.shape[</span><span class="s4">0</span><span class="s1">] == </span><span class="s4">1</span>
        <span class="s1">broadcast_col = N != </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">x.shape[</span><span class="s4">1</span><span class="s1">] == </span><span class="s4">1</span>
        <span class="s1">r</span><span class="s2">, </span><span class="s1">c = x.row</span><span class="s2">, </span><span class="s1">x.col</span>

        <span class="s1">x = np.asarray(x.data</span><span class="s2">, </span><span class="s1">dtype=self.dtype)</span>
        <span class="s2">if </span><span class="s1">x.size == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return</span>

        <span class="s2">if </span><span class="s1">broadcast_row:</span>
            <span class="s1">r = np.repeat(np.arange(M)</span><span class="s2">, </span><span class="s1">len(r))</span>
            <span class="s1">c = np.tile(c</span><span class="s2">, </span><span class="s1">M)</span>
            <span class="s1">x = np.tile(x</span><span class="s2">, </span><span class="s1">M)</span>
        <span class="s2">if </span><span class="s1">broadcast_col:</span>
            <span class="s1">r = np.repeat(r</span><span class="s2">, </span><span class="s1">N)</span>
            <span class="s1">c = np.tile(np.arange(N)</span><span class="s2">, </span><span class="s1">len(c))</span>
            <span class="s1">x = np.repeat(x</span><span class="s2">, </span><span class="s1">N)</span>
        <span class="s3"># only assign entries in the new sparsity structure</span>
        <span class="s1">i</span><span class="s2">, </span><span class="s1">j = self._swap((row[r</span><span class="s2">, </span><span class="s1">c]</span><span class="s2">, </span><span class="s1">col[r</span><span class="s2">, </span><span class="s1">c]))</span>
        <span class="s1">self._set_many(i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s2">def </span><span class="s1">_setdiag(self</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">k):</span>
        <span class="s2">if </span><span class="s4">0 </span><span class="s2">in </span><span class="s1">self.shape:</span>
            <span class="s2">return</span>

        <span class="s1">M</span><span class="s2">, </span><span class="s1">N = self.shape</span>
        <span class="s1">broadcast = (values.ndim == </span><span class="s4">0</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">k &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">broadcast:</span>
                <span class="s1">max_index = min(M + k</span><span class="s2">, </span><span class="s1">N)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">max_index = min(M + k</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">len(values))</span>
            <span class="s1">i = np.arange(max_index</span><span class="s2">, </span><span class="s1">dtype=self.indices.dtype)</span>
            <span class="s1">j = np.arange(max_index</span><span class="s2">, </span><span class="s1">dtype=self.indices.dtype)</span>
            <span class="s1">i -= k</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">broadcast:</span>
                <span class="s1">max_index = min(M</span><span class="s2">, </span><span class="s1">N - k)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">max_index = min(M</span><span class="s2">, </span><span class="s1">N - k</span><span class="s2">, </span><span class="s1">len(values))</span>
            <span class="s1">i = np.arange(max_index</span><span class="s2">, </span><span class="s1">dtype=self.indices.dtype)</span>
            <span class="s1">j = np.arange(max_index</span><span class="s2">, </span><span class="s1">dtype=self.indices.dtype)</span>
            <span class="s1">j += k</span>

        <span class="s2">if not </span><span class="s1">broadcast:</span>
            <span class="s1">values = values[:len(i)]</span>

        <span class="s1">self[i</span><span class="s2">, </span><span class="s1">j] = values</span>

    <span class="s2">def </span><span class="s1">_prepare_indices(self</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">j):</span>
        <span class="s1">M</span><span class="s2">, </span><span class="s1">N = self._swap(self.shape)</span>

        <span class="s2">def </span><span class="s1">check_bounds(indices</span><span class="s2">, </span><span class="s1">bound):</span>
            <span class="s1">idx = indices.max()</span>
            <span class="s2">if </span><span class="s1">idx &gt;= bound:</span>
                <span class="s2">raise </span><span class="s1">IndexError(</span><span class="s5">'index (%d) out of range (&gt;= %d)' </span><span class="s1">%</span>
                                 <span class="s1">(idx</span><span class="s2">, </span><span class="s1">bound))</span>
            <span class="s1">idx = indices.min()</span>
            <span class="s2">if </span><span class="s1">idx &lt; -bound:</span>
                <span class="s2">raise </span><span class="s1">IndexError(</span><span class="s5">'index (%d) out of range (&lt; -%d)' </span><span class="s1">%</span>
                                 <span class="s1">(idx</span><span class="s2">, </span><span class="s1">bound))</span>

        <span class="s1">i = np.array(i</span><span class="s2">, </span><span class="s1">dtype=self.indices.dtype</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False, </span><span class="s1">ndmin=</span><span class="s4">1</span><span class="s1">).ravel()</span>
        <span class="s1">j = np.array(j</span><span class="s2">, </span><span class="s1">dtype=self.indices.dtype</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False, </span><span class="s1">ndmin=</span><span class="s4">1</span><span class="s1">).ravel()</span>
        <span class="s1">check_bounds(i</span><span class="s2">, </span><span class="s1">M)</span>
        <span class="s1">check_bounds(j</span><span class="s2">, </span><span class="s1">N)</span>
        <span class="s2">return </span><span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">M</span><span class="s2">, </span><span class="s1">N</span>

    <span class="s2">def </span><span class="s1">_set_many(self</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s0">&quot;&quot;&quot;Sets value at each (i, j) to x 
 
        Here (i,j) index major and minor respectively, and must not contain 
        duplicate entries. 
        &quot;&quot;&quot;</span>
        <span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">M</span><span class="s2">, </span><span class="s1">N = self._prepare_indices(i</span><span class="s2">, </span><span class="s1">j)</span>
        <span class="s1">x = np.array(x</span><span class="s2">, </span><span class="s1">dtype=self.dtype</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False, </span><span class="s1">ndmin=</span><span class="s4">1</span><span class="s1">).ravel()</span>

        <span class="s1">n_samples = x.size</span>
        <span class="s1">offsets = np.empty(n_samples</span><span class="s2">, </span><span class="s1">dtype=self.indices.dtype)</span>
        <span class="s1">ret = csr_sample_offsets(M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">self.indptr</span><span class="s2">, </span><span class="s1">self.indices</span><span class="s2">, </span><span class="s1">n_samples</span><span class="s2">,</span>
                                 <span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">offsets)</span>
        <span class="s2">if </span><span class="s1">ret == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s3"># rinse and repeat</span>
            <span class="s1">self.sum_duplicates()</span>
            <span class="s1">csr_sample_offsets(M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">self.indptr</span><span class="s2">, </span><span class="s1">self.indices</span><span class="s2">, </span><span class="s1">n_samples</span><span class="s2">,</span>
                               <span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">offsets)</span>

        <span class="s2">if </span><span class="s1">-</span><span class="s4">1 </span><span class="s2">not in </span><span class="s1">offsets:</span>
            <span class="s3"># only affects existing non-zero cells</span>
            <span class="s1">self.data[offsets] = x</span>
            <span class="s2">return</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">warn(</span><span class="s5">&quot;Changing the sparsity structure of a {}_matrix is expensive.&quot;</span>
                 <span class="s5">&quot; lil_matrix is more efficient.&quot;</span><span class="s1">.format(self.format)</span><span class="s2">,</span>
                 <span class="s1">SparseEfficiencyWarning</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s4">3</span><span class="s1">)</span>
            <span class="s3"># replace where possible</span>
            <span class="s1">mask = offsets &gt; -</span><span class="s4">1</span>
            <span class="s1">self.data[offsets[mask]] = x[mask]</span>
            <span class="s3"># only insertions remain</span>
            <span class="s1">mask = ~mask</span>
            <span class="s1">i = i[mask]</span>
            <span class="s1">i[i &lt; </span><span class="s4">0</span><span class="s1">] += M</span>
            <span class="s1">j = j[mask]</span>
            <span class="s1">j[j &lt; </span><span class="s4">0</span><span class="s1">] += N</span>
            <span class="s1">self._insert_many(i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">x[mask])</span>

    <span class="s2">def </span><span class="s1">_zero_many(self</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">j):</span>
        <span class="s0">&quot;&quot;&quot;Sets value at each (i, j) to zero, preserving sparsity structure. 
 
        Here (i,j) index major and minor respectively. 
        &quot;&quot;&quot;</span>
        <span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">M</span><span class="s2">, </span><span class="s1">N = self._prepare_indices(i</span><span class="s2">, </span><span class="s1">j)</span>

        <span class="s1">n_samples = len(i)</span>
        <span class="s1">offsets = np.empty(n_samples</span><span class="s2">, </span><span class="s1">dtype=self.indices.dtype)</span>
        <span class="s1">ret = csr_sample_offsets(M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">self.indptr</span><span class="s2">, </span><span class="s1">self.indices</span><span class="s2">, </span><span class="s1">n_samples</span><span class="s2">,</span>
                                 <span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">offsets)</span>
        <span class="s2">if </span><span class="s1">ret == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s3"># rinse and repeat</span>
            <span class="s1">self.sum_duplicates()</span>
            <span class="s1">csr_sample_offsets(M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">self.indptr</span><span class="s2">, </span><span class="s1">self.indices</span><span class="s2">, </span><span class="s1">n_samples</span><span class="s2">,</span>
                               <span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">offsets)</span>

        <span class="s3"># only assign zeros to the existing sparsity structure</span>
        <span class="s1">self.data[offsets[offsets &gt; -</span><span class="s4">1</span><span class="s1">]] = </span><span class="s4">0</span>

    <span class="s2">def </span><span class="s1">_insert_many(self</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s0">&quot;&quot;&quot;Inserts new nonzero at each (i, j) with value x 
 
        Here (i,j) index major and minor respectively. 
        i, j and x must be non-empty, 1d arrays. 
        Inserts each major group (e.g. all entries per row) at a time. 
        Maintains has_sorted_indices property. 
        Modifies i, j, x in place. 
        &quot;&quot;&quot;</span>
        <span class="s1">order = np.argsort(i</span><span class="s2">, </span><span class="s1">kind=</span><span class="s5">'mergesort'</span><span class="s1">)  </span><span class="s3"># stable for duplicates</span>
        <span class="s1">i = i.take(order</span><span class="s2">, </span><span class="s1">mode=</span><span class="s5">'clip'</span><span class="s1">)</span>
        <span class="s1">j = j.take(order</span><span class="s2">, </span><span class="s1">mode=</span><span class="s5">'clip'</span><span class="s1">)</span>
        <span class="s1">x = x.take(order</span><span class="s2">, </span><span class="s1">mode=</span><span class="s5">'clip'</span><span class="s1">)</span>

        <span class="s1">do_sort = self.has_sorted_indices</span>

        <span class="s3"># Update index data type</span>
        <span class="s1">idx_dtype = self._get_index_dtype((self.indices</span><span class="s2">, </span><span class="s1">self.indptr)</span><span class="s2">,</span>
                                    <span class="s1">maxval=(self.indptr[-</span><span class="s4">1</span><span class="s1">] + x.size))</span>
        <span class="s1">self.indptr = np.asarray(self.indptr</span><span class="s2">, </span><span class="s1">dtype=idx_dtype)</span>
        <span class="s1">self.indices = np.asarray(self.indices</span><span class="s2">, </span><span class="s1">dtype=idx_dtype)</span>
        <span class="s1">i = np.asarray(i</span><span class="s2">, </span><span class="s1">dtype=idx_dtype)</span>
        <span class="s1">j = np.asarray(j</span><span class="s2">, </span><span class="s1">dtype=idx_dtype)</span>

        <span class="s3"># Collate old and new in chunks by major index</span>
        <span class="s1">indices_parts = []</span>
        <span class="s1">data_parts = []</span>
        <span class="s1">ui</span><span class="s2">, </span><span class="s1">ui_indptr = np.unique(i</span><span class="s2">, </span><span class="s1">return_index=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">ui_indptr = np.append(ui_indptr</span><span class="s2">, </span><span class="s1">len(j))</span>
        <span class="s1">new_nnzs = np.diff(ui_indptr)</span>
        <span class="s1">prev = </span><span class="s4">0</span>
        <span class="s2">for </span><span class="s1">c</span><span class="s2">, </span><span class="s1">(ii</span><span class="s2">, </span><span class="s1">js</span><span class="s2">, </span><span class="s1">je) </span><span class="s2">in </span><span class="s1">enumerate(zip(ui</span><span class="s2">, </span><span class="s1">ui_indptr</span><span class="s2">, </span><span class="s1">ui_indptr[</span><span class="s4">1</span><span class="s1">:])):</span>
            <span class="s3"># old entries</span>
            <span class="s1">start = self.indptr[prev]</span>
            <span class="s1">stop = self.indptr[ii]</span>
            <span class="s1">indices_parts.append(self.indices[start:stop])</span>
            <span class="s1">data_parts.append(self.data[start:stop])</span>

            <span class="s3"># handle duplicate j: keep last setting</span>
            <span class="s1">uj</span><span class="s2">, </span><span class="s1">uj_indptr = np.unique(j[js:je][::-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">return_index=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">len(uj) == je - js:</span>
                <span class="s1">indices_parts.append(j[js:je])</span>
                <span class="s1">data_parts.append(x[js:je])</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">indices_parts.append(j[js:je][::-</span><span class="s4">1</span><span class="s1">][uj_indptr])</span>
                <span class="s1">data_parts.append(x[js:je][::-</span><span class="s4">1</span><span class="s1">][uj_indptr])</span>
                <span class="s1">new_nnzs[c] = len(uj)</span>

            <span class="s1">prev = ii</span>

        <span class="s3"># remaining old entries</span>
        <span class="s1">start = self.indptr[ii]</span>
        <span class="s1">indices_parts.append(self.indices[start:])</span>
        <span class="s1">data_parts.append(self.data[start:])</span>

        <span class="s3"># update attributes</span>
        <span class="s1">self.indices = np.concatenate(indices_parts)</span>
        <span class="s1">self.data = np.concatenate(data_parts)</span>
        <span class="s1">nnzs = np.empty(self.indptr.shape</span><span class="s2">, </span><span class="s1">dtype=idx_dtype)</span>
        <span class="s1">nnzs[</span><span class="s4">0</span><span class="s1">] = idx_dtype(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">indptr_diff = np.diff(self.indptr)</span>
        <span class="s1">indptr_diff[ui] += new_nnzs</span>
        <span class="s1">nnzs[</span><span class="s4">1</span><span class="s1">:] = indptr_diff</span>
        <span class="s1">self.indptr = np.cumsum(nnzs</span><span class="s2">, </span><span class="s1">out=nnzs)</span>

        <span class="s2">if </span><span class="s1">do_sort:</span>
            <span class="s3"># TODO: only sort where necessary</span>
            <span class="s1">self.has_sorted_indices = </span><span class="s2">False</span>
            <span class="s1">self.sort_indices()</span>

        <span class="s1">self.check_format(full_check=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s3">######################</span>
    <span class="s3"># Conversion methods #</span>
    <span class="s3">######################</span>

    <span class="s2">def </span><span class="s1">tocoo(self</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s1">major_dim</span><span class="s2">, </span><span class="s1">minor_dim = self._swap(self.shape)</span>
        <span class="s1">minor_indices = self.indices</span>
        <span class="s1">major_indices = np.empty(len(minor_indices)</span><span class="s2">, </span><span class="s1">dtype=self.indices.dtype)</span>
        <span class="s1">_sparsetools.expandptr(major_dim</span><span class="s2">, </span><span class="s1">self.indptr</span><span class="s2">, </span><span class="s1">major_indices)</span>
        <span class="s1">row</span><span class="s2">, </span><span class="s1">col = self._swap((major_indices</span><span class="s2">, </span><span class="s1">minor_indices))</span>

        <span class="s2">return </span><span class="s1">self._coo_container(</span>
            <span class="s1">(self.data</span><span class="s2">, </span><span class="s1">(row</span><span class="s2">, </span><span class="s1">col))</span><span class="s2">, </span><span class="s1">self.shape</span><span class="s2">, </span><span class="s1">copy=copy</span><span class="s2">,</span>
            <span class="s1">dtype=self.dtype</span>
        <span class="s1">)</span>

    <span class="s1">tocoo.__doc__ = _spbase.tocoo.__doc__</span>

    <span class="s2">def </span><span class="s1">toarray(self</span><span class="s2">, </span><span class="s1">order=</span><span class="s2">None, </span><span class="s1">out=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">out </span><span class="s2">is None and </span><span class="s1">order </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">order = self._swap(</span><span class="s5">'cf'</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">out = self._process_toarray_args(order</span><span class="s2">, </span><span class="s1">out)</span>
        <span class="s2">if not </span><span class="s1">(out.flags.c_contiguous </span><span class="s2">or </span><span class="s1">out.flags.f_contiguous):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'Output array must be C or F contiguous'</span><span class="s1">)</span>
        <span class="s3"># align ideal order with output array order</span>
        <span class="s2">if </span><span class="s1">out.flags.c_contiguous:</span>
            <span class="s1">x = self.tocsr()</span>
            <span class="s1">y = out</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">x = self.tocsc()</span>
            <span class="s1">y = out.T</span>
        <span class="s1">M</span><span class="s2">, </span><span class="s1">N = x._swap(x.shape)</span>
        <span class="s1">csr_todense(M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">x.indptr</span><span class="s2">, </span><span class="s1">x.indices</span><span class="s2">, </span><span class="s1">x.data</span><span class="s2">, </span><span class="s1">y)</span>
        <span class="s2">return </span><span class="s1">out</span>

    <span class="s1">toarray.__doc__ = _spbase.toarray.__doc__</span>

    <span class="s3">##############################################################</span>
    <span class="s3"># methods that examine or modify the internal data structure #</span>
    <span class="s3">##############################################################</span>

    <span class="s2">def </span><span class="s1">eliminate_zeros(self):</span>
        <span class="s0">&quot;&quot;&quot;Remove zero entries from the matrix 
 
        This is an *in place* operation. 
        &quot;&quot;&quot;</span>
        <span class="s1">M</span><span class="s2">, </span><span class="s1">N = self._swap(self.shape)</span>
        <span class="s1">_sparsetools.csr_eliminate_zeros(M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">self.indptr</span><span class="s2">, </span><span class="s1">self.indices</span><span class="s2">,</span>
                                         <span class="s1">self.data)</span>
        <span class="s1">self.prune()  </span><span class="s3"># nnz may have changed</span>

    <span class="s2">def </span><span class="s1">__get_has_canonical_format(self):</span>
        <span class="s0">&quot;&quot;&quot;Determine whether the matrix has sorted indices and no duplicates 
 
        Returns 
            - True: if the above applies 
            - False: otherwise 
 
        has_canonical_format implies has_sorted_indices, so if the latter flag 
        is False, so will the former be; if the former is found True, the 
        latter flag is also set. 
        &quot;&quot;&quot;</span>

        <span class="s3"># first check to see if result was cached</span>
        <span class="s2">if not </span><span class="s1">getattr(self</span><span class="s2">, </span><span class="s5">'_has_sorted_indices'</span><span class="s2">, True</span><span class="s1">):</span>
            <span class="s3"># not sorted =&gt; not canonical</span>
            <span class="s1">self._has_canonical_format = </span><span class="s2">False</span>
        <span class="s2">elif not </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s5">'_has_canonical_format'</span><span class="s1">):</span>
            <span class="s1">self.has_canonical_format = bool(</span>
                <span class="s1">_sparsetools.csr_has_canonical_format(</span>
                    <span class="s1">len(self.indptr) - </span><span class="s4">1</span><span class="s2">, </span><span class="s1">self.indptr</span><span class="s2">, </span><span class="s1">self.indices))</span>
        <span class="s2">return </span><span class="s1">self._has_canonical_format</span>

    <span class="s2">def </span><span class="s1">__set_has_canonical_format(self</span><span class="s2">, </span><span class="s1">val):</span>
        <span class="s1">self._has_canonical_format = bool(val)</span>
        <span class="s2">if </span><span class="s1">val:</span>
            <span class="s1">self.has_sorted_indices = </span><span class="s2">True</span>

    <span class="s1">has_canonical_format = property(fget=__get_has_canonical_format</span><span class="s2">,</span>
                                    <span class="s1">fset=__set_has_canonical_format)</span>

    <span class="s2">def </span><span class="s1">sum_duplicates(self):</span>
        <span class="s0">&quot;&quot;&quot;Eliminate duplicate matrix entries by adding them together 
 
        This is an *in place* operation. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.has_canonical_format:</span>
            <span class="s2">return</span>
        <span class="s1">self.sort_indices()</span>

        <span class="s1">M</span><span class="s2">, </span><span class="s1">N = self._swap(self.shape)</span>
        <span class="s1">_sparsetools.csr_sum_duplicates(M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">self.indptr</span><span class="s2">, </span><span class="s1">self.indices</span><span class="s2">,</span>
                                        <span class="s1">self.data)</span>

        <span class="s1">self.prune()  </span><span class="s3"># nnz may have changed</span>
        <span class="s1">self.has_canonical_format = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">__get_sorted(self):</span>
        <span class="s0">&quot;&quot;&quot;Determine whether the matrix has sorted indices 
 
        Returns 
            - True: if the indices of the matrix are in sorted order 
            - False: otherwise 
 
        &quot;&quot;&quot;</span>

        <span class="s3"># first check to see if result was cached</span>
        <span class="s2">if not </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s5">'_has_sorted_indices'</span><span class="s1">):</span>
            <span class="s1">self._has_sorted_indices = bool(</span>
                <span class="s1">_sparsetools.csr_has_sorted_indices(</span>
                    <span class="s1">len(self.indptr) - </span><span class="s4">1</span><span class="s2">, </span><span class="s1">self.indptr</span><span class="s2">, </span><span class="s1">self.indices))</span>
        <span class="s2">return </span><span class="s1">self._has_sorted_indices</span>

    <span class="s2">def </span><span class="s1">__set_sorted(self</span><span class="s2">, </span><span class="s1">val):</span>
        <span class="s1">self._has_sorted_indices = bool(val)</span>

    <span class="s1">has_sorted_indices = property(fget=__get_sorted</span><span class="s2">, </span><span class="s1">fset=__set_sorted)</span>

    <span class="s2">def </span><span class="s1">sorted_indices(self):</span>
        <span class="s0">&quot;&quot;&quot;Return a copy of this matrix with sorted indices 
        &quot;&quot;&quot;</span>
        <span class="s1">A = self.copy()</span>
        <span class="s1">A.sort_indices()</span>
        <span class="s2">return </span><span class="s1">A</span>

        <span class="s3"># an alternative that has linear complexity is the following</span>
        <span class="s3"># although the previous option is typically faster</span>
        <span class="s3"># return self.toother().toother()</span>

    <span class="s2">def </span><span class="s1">sort_indices(self):</span>
        <span class="s0">&quot;&quot;&quot;Sort the indices of this matrix *in place* 
        &quot;&quot;&quot;</span>

        <span class="s2">if not </span><span class="s1">self.has_sorted_indices:</span>
            <span class="s1">_sparsetools.csr_sort_indices(len(self.indptr) - </span><span class="s4">1</span><span class="s2">, </span><span class="s1">self.indptr</span><span class="s2">,</span>
                                          <span class="s1">self.indices</span><span class="s2">, </span><span class="s1">self.data)</span>
            <span class="s1">self.has_sorted_indices = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">prune(self):</span>
        <span class="s0">&quot;&quot;&quot;Remove empty space after all non-zero elements. 
        &quot;&quot;&quot;</span>
        <span class="s1">major_dim = self._swap(self.shape)[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">len(self.indptr) != major_dim + </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'index pointer has invalid length'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">len(self.indices) &lt; self.nnz:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'indices array has fewer than nnz elements'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">len(self.data) &lt; self.nnz:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'data array has fewer than nnz elements'</span><span class="s1">)</span>

        <span class="s1">self.indices = _prune_array(self.indices[:self.nnz])</span>
        <span class="s1">self.data = _prune_array(self.data[:self.nnz])</span>

    <span class="s2">def </span><span class="s1">resize(self</span><span class="s2">, </span><span class="s1">*shape):</span>
        <span class="s1">shape = check_shape(shape)</span>
        <span class="s2">if </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s5">'blocksize'</span><span class="s1">):</span>
            <span class="s1">bm</span><span class="s2">, </span><span class="s1">bn = self.blocksize</span>
            <span class="s1">new_M</span><span class="s2">, </span><span class="s1">rm = divmod(shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">bm)</span>
            <span class="s1">new_N</span><span class="s2">, </span><span class="s1">rn = divmod(shape[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">bn)</span>
            <span class="s2">if </span><span class="s1">rm </span><span class="s2">or </span><span class="s1">rn:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;shape must be divisible into {} blocks. &quot;</span>
                                 <span class="s5">&quot;Got {}&quot;</span><span class="s1">.format(self.blocksize</span><span class="s2">, </span><span class="s1">shape))</span>
            <span class="s1">M</span><span class="s2">, </span><span class="s1">N = self.shape[</span><span class="s4">0</span><span class="s1">] // bm</span><span class="s2">, </span><span class="s1">self.shape[</span><span class="s4">1</span><span class="s1">] // bn</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">new_M</span><span class="s2">, </span><span class="s1">new_N = self._swap(shape)</span>
            <span class="s1">M</span><span class="s2">, </span><span class="s1">N = self._swap(self.shape)</span>

        <span class="s2">if </span><span class="s1">new_M &lt; M:</span>
            <span class="s1">self.indices = self.indices[:self.indptr[new_M]]</span>
            <span class="s1">self.data = self.data[:self.indptr[new_M]]</span>
            <span class="s1">self.indptr = self.indptr[:new_M + </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s2">elif </span><span class="s1">new_M &gt; M:</span>
            <span class="s1">self.indptr = np.resize(self.indptr</span><span class="s2">, </span><span class="s1">new_M + </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">self.indptr[M + </span><span class="s4">1</span><span class="s1">:].fill(self.indptr[M])</span>

        <span class="s2">if </span><span class="s1">new_N &lt; N:</span>
            <span class="s1">mask = self.indices &lt; new_N</span>
            <span class="s2">if not </span><span class="s1">np.all(mask):</span>
                <span class="s1">self.indices = self.indices[mask]</span>
                <span class="s1">self.data = self.data[mask]</span>
                <span class="s1">major_index</span><span class="s2">, </span><span class="s1">val = self._minor_reduce(np.add</span><span class="s2">, </span><span class="s1">mask)</span>
                <span class="s1">self.indptr.fill(</span><span class="s4">0</span><span class="s1">)</span>
                <span class="s1">self.indptr[</span><span class="s4">1</span><span class="s1">:][major_index] = val</span>
                <span class="s1">np.cumsum(self.indptr</span><span class="s2">, </span><span class="s1">out=self.indptr)</span>

        <span class="s1">self._shape = shape</span>

    <span class="s1">resize.__doc__ = _spbase.resize.__doc__</span>

    <span class="s3">###################</span>
    <span class="s3"># utility methods #</span>
    <span class="s3">###################</span>

    <span class="s3"># needed by _data_matrix</span>
    <span class="s2">def </span><span class="s1">_with_data(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Returns a matrix with the same sparsity structure as self, 
        but with different data.  By default the structure arrays 
        (i.e. .indptr and .indices) are copied. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">copy:</span>
            <span class="s2">return </span><span class="s1">self.__class__((data</span><span class="s2">, </span><span class="s1">self.indices.copy()</span><span class="s2">,</span>
                                   <span class="s1">self.indptr.copy())</span><span class="s2">,</span>
                                  <span class="s1">shape=self.shape</span><span class="s2">,</span>
                                  <span class="s1">dtype=data.dtype)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.__class__((data</span><span class="s2">, </span><span class="s1">self.indices</span><span class="s2">, </span><span class="s1">self.indptr)</span><span class="s2">,</span>
                                  <span class="s1">shape=self.shape</span><span class="s2">, </span><span class="s1">dtype=data.dtype)</span>

    <span class="s2">def </span><span class="s1">_binopt(self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">op):</span>
        <span class="s0">&quot;&quot;&quot;apply the binary operation fn to two sparse matrices.&quot;&quot;&quot;</span>
        <span class="s1">other = self.__class__(other)</span>

        <span class="s3"># e.g. csr_plus_csr, csr_minus_csr, etc.</span>
        <span class="s1">fn = getattr(_sparsetools</span><span class="s2">, </span><span class="s1">self.format + op + self.format)</span>

        <span class="s1">maxnnz = self.nnz + other.nnz</span>
        <span class="s1">idx_dtype = self._get_index_dtype((self.indptr</span><span class="s2">, </span><span class="s1">self.indices</span><span class="s2">,</span>
                                     <span class="s1">other.indptr</span><span class="s2">, </span><span class="s1">other.indices)</span><span class="s2">,</span>
                                    <span class="s1">maxval=maxnnz)</span>
        <span class="s1">indptr = np.empty(self.indptr.shape</span><span class="s2">, </span><span class="s1">dtype=idx_dtype)</span>
        <span class="s1">indices = np.empty(maxnnz</span><span class="s2">, </span><span class="s1">dtype=idx_dtype)</span>

        <span class="s1">bool_ops = [</span><span class="s5">'_ne_'</span><span class="s2">, </span><span class="s5">'_lt_'</span><span class="s2">, </span><span class="s5">'_gt_'</span><span class="s2">, </span><span class="s5">'_le_'</span><span class="s2">, </span><span class="s5">'_ge_'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">op </span><span class="s2">in </span><span class="s1">bool_ops:</span>
            <span class="s1">data = np.empty(maxnnz</span><span class="s2">, </span><span class="s1">dtype=np.bool_)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">data = np.empty(maxnnz</span><span class="s2">, </span><span class="s1">dtype=upcast(self.dtype</span><span class="s2">, </span><span class="s1">other.dtype))</span>

        <span class="s1">fn(self.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.shape[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
           <span class="s1">np.asarray(self.indptr</span><span class="s2">, </span><span class="s1">dtype=idx_dtype)</span><span class="s2">,</span>
           <span class="s1">np.asarray(self.indices</span><span class="s2">, </span><span class="s1">dtype=idx_dtype)</span><span class="s2">,</span>
           <span class="s1">self.data</span><span class="s2">,</span>
           <span class="s1">np.asarray(other.indptr</span><span class="s2">, </span><span class="s1">dtype=idx_dtype)</span><span class="s2">,</span>
           <span class="s1">np.asarray(other.indices</span><span class="s2">, </span><span class="s1">dtype=idx_dtype)</span><span class="s2">,</span>
           <span class="s1">other.data</span><span class="s2">,</span>
           <span class="s1">indptr</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">data)</span>

        <span class="s1">A = self.__class__((data</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">indptr)</span><span class="s2">, </span><span class="s1">shape=self.shape)</span>
        <span class="s1">A.prune()</span>

        <span class="s2">return </span><span class="s1">A</span>

    <span class="s2">def </span><span class="s1">_divide_sparse(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Divide this matrix by a second sparse matrix. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">other.shape != self.shape:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'inconsistent shapes'</span><span class="s1">)</span>

        <span class="s1">r = self._binopt(other</span><span class="s2">, </span><span class="s5">'_eldiv_'</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">np.issubdtype(r.dtype</span><span class="s2">, </span><span class="s1">np.inexact):</span>
            <span class="s3"># Eldiv leaves entries outside the combined sparsity</span>
            <span class="s3"># pattern empty, so they must be filled manually.</span>
            <span class="s3"># Everything outside of other's sparsity is NaN, and everything</span>
            <span class="s3"># inside it is either zero or defined by eldiv.</span>
            <span class="s1">out = np.empty(self.shape</span><span class="s2">, </span><span class="s1">dtype=self.dtype)</span>
            <span class="s1">out.fill(np.nan)</span>
            <span class="s1">row</span><span class="s2">, </span><span class="s1">col = other.nonzero()</span>
            <span class="s1">out[row</span><span class="s2">, </span><span class="s1">col] = </span><span class="s4">0</span>
            <span class="s1">r = r.tocoo()</span>
            <span class="s1">out[r.row</span><span class="s2">, </span><span class="s1">r.col] = r.data</span>
            <span class="s1">out = self._container(out)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># integers types go with nan &lt;-&gt; 0</span>
            <span class="s1">out = r</span>

        <span class="s2">return </span><span class="s1">out</span>


<span class="s2">def </span><span class="s1">_process_slice(sl</span><span class="s2">, </span><span class="s1">num):</span>
    <span class="s2">if </span><span class="s1">sl </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">i0</span><span class="s2">, </span><span class="s1">i1 = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">num</span>
    <span class="s2">elif </span><span class="s1">isinstance(sl</span><span class="s2">, </span><span class="s1">slice):</span>
        <span class="s1">i0</span><span class="s2">, </span><span class="s1">i1</span><span class="s2">, </span><span class="s1">stride = sl.indices(num)</span>
        <span class="s2">if </span><span class="s1">stride != </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'slicing with step != 1 not supported'</span><span class="s1">)</span>
        <span class="s1">i0 = min(i0</span><span class="s2">, </span><span class="s1">i1)  </span><span class="s3"># give an empty slice when i0 &gt; i1</span>
    <span class="s2">elif </span><span class="s1">isintlike(sl):</span>
        <span class="s2">if </span><span class="s1">sl &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">sl += num</span>
        <span class="s1">i0</span><span class="s2">, </span><span class="s1">i1 = sl</span><span class="s2">, </span><span class="s1">sl + </span><span class="s4">1</span>
        <span class="s2">if </span><span class="s1">i0 &lt; </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">i1 &gt; num:</span>
            <span class="s2">raise </span><span class="s1">IndexError(</span><span class="s5">'index out of bounds: 0 &lt;= %d &lt; %d &lt;= %d' </span><span class="s1">%</span>
                             <span class="s1">(i0</span><span class="s2">, </span><span class="s1">i1</span><span class="s2">, </span><span class="s1">num))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s5">'expected slice or scalar'</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">i0</span><span class="s2">, </span><span class="s1">i1</span>
</pre>
</body>
</html>