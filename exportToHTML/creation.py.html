<html>
<head>
<title>creation.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
creation.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">itertools</span>
<span class="s0">from </span><span class="s1">collections.abc </span><span class="s0">import </span><span class="s1">Sequence</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">partial</span>
<span class="s0">from </span><span class="s1">itertools </span><span class="s0">import </span><span class="s1">product</span>
<span class="s0">from </span><span class="s1">numbers </span><span class="s0">import </span><span class="s1">Integral</span><span class="s0">, </span><span class="s1">Number</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">tlz </span><span class="s0">import </span><span class="s1">sliding_window</span>

<span class="s0">from </span><span class="s1">dask.array </span><span class="s0">import </span><span class="s1">chunk</span>
<span class="s0">from </span><span class="s1">dask.array.backends </span><span class="s0">import </span><span class="s1">array_creation_dispatch</span>
<span class="s0">from </span><span class="s1">dask.array.core </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Array</span><span class="s0">,</span>
    <span class="s1">asarray</span><span class="s0">,</span>
    <span class="s1">block</span><span class="s0">,</span>
    <span class="s1">blockwise</span><span class="s0">,</span>
    <span class="s1">broadcast_arrays</span><span class="s0">,</span>
    <span class="s1">broadcast_to</span><span class="s0">,</span>
    <span class="s1">concatenate</span><span class="s0">,</span>
    <span class="s1">normalize_chunks</span><span class="s0">,</span>
    <span class="s1">stack</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">dask.array.numpy_compat </span><span class="s0">import </span><span class="s1">AxisError</span>
<span class="s0">from </span><span class="s1">dask.array.ufunc </span><span class="s0">import </span><span class="s1">greater_equal</span><span class="s0">, </span><span class="s1">rint</span>
<span class="s0">from </span><span class="s1">dask.array.utils </span><span class="s0">import </span><span class="s1">meta_from_array</span>
<span class="s0">from </span><span class="s1">dask.array.wrap </span><span class="s0">import </span><span class="s1">empty</span><span class="s0">, </span><span class="s1">full</span><span class="s0">, </span><span class="s1">ones</span><span class="s0">, </span><span class="s1">zeros</span>
<span class="s0">from </span><span class="s1">dask.base </span><span class="s0">import </span><span class="s1">tokenize</span>
<span class="s0">from </span><span class="s1">dask.highlevelgraph </span><span class="s0">import </span><span class="s1">HighLevelGraph</span>
<span class="s0">from </span><span class="s1">dask.utils </span><span class="s0">import </span><span class="s1">cached_cumsum</span><span class="s0">, </span><span class="s1">derived_from</span><span class="s0">, </span><span class="s1">is_cupy_type</span>


<span class="s0">def </span><span class="s1">to_backend(x: Array</span><span class="s0">, </span><span class="s1">backend: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None, </span><span class="s1">**kwargs):</span>
    <span class="s2">&quot;&quot;&quot;Move an Array collection to a new backend 
 
    Parameters 
    ---------- 
    x : Array 
        The input Array collection. 
    backend : str, Optional 
        The name of the new backend to move to. The default 
        is the current &quot;array.backend&quot; configuration. 
 
    Returns 
    ------- 
    dask.Array 
        A new Array collection with the backend specified 
        by ``backend``. 
    &quot;&quot;&quot;</span>
    <span class="s3"># Get desired backend</span>
    <span class="s1">backend = backend </span><span class="s0">or </span><span class="s1">array_creation_dispatch.backend</span>
    <span class="s3"># Check that &quot;backend&quot; has a registered entrypoint</span>
    <span class="s1">backend_entrypoint = array_creation_dispatch.dispatch(backend)</span>
    <span class="s3"># Call `ArrayBackendEntrypoint.to_backend`</span>
    <span class="s0">return </span><span class="s1">backend_entrypoint.to_backend(x</span><span class="s0">, </span><span class="s1">**kwargs)</span>


<span class="s0">def </span><span class="s1">empty_like(a</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s0">None, </span><span class="s1">order=</span><span class="s4">&quot;C&quot;</span><span class="s0">, </span><span class="s1">chunks=</span><span class="s0">None, </span><span class="s1">name=</span><span class="s0">None, </span><span class="s1">shape=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Return a new array with the same shape and type as a given array. 
 
    Parameters 
    ---------- 
    a : array_like 
        The shape and data-type of `a` define these same attributes of the 
        returned array. 
    dtype : data-type, optional 
        Overrides the data type of the result. 
    order : {'C', 'F'}, optional 
        Whether to store multidimensional data in C- or Fortran-contiguous 
        (row- or column-wise) order in memory. 
    chunks : sequence of ints 
        The number of samples on each block. Note that the last block will have 
        fewer samples if ``len(array) % chunks != 0``. 
    name : str, optional 
        An optional keyname for the array. Defaults to hashing the input 
        keyword arguments. 
    shape : int or sequence of ints, optional. 
        Overrides the shape of the result. 
 
    Returns 
    ------- 
    out : ndarray 
        Array of uninitialized (arbitrary) data with the same 
        shape and type as `a`. 
 
    See Also 
    -------- 
    ones_like : Return an array of ones with shape and type of input. 
    zeros_like : Return an array of zeros with shape and type of input. 
    empty : Return a new uninitialized array. 
    ones : Return a new array setting values to one. 
    zeros : Return a new array setting values to zero. 
 
    Notes 
    ----- 
    This function does *not* initialize the returned array; to do that use 
    `zeros_like` or `ones_like` instead.  It may be marginally faster than 
    the functions that do set the array values. 
    &quot;&quot;&quot;</span>

    <span class="s1">a = asarray(a</span><span class="s0">, </span><span class="s1">name=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">shape</span><span class="s0">, </span><span class="s1">chunks = _get_like_function_shapes_chunks(a</span><span class="s0">, </span><span class="s1">chunks</span><span class="s0">, </span><span class="s1">shape)</span>

    <span class="s3"># if shape is nan we cannot rely on regular empty function, we use</span>
    <span class="s3"># generic map_blocks.</span>
    <span class="s0">if </span><span class="s1">np.isnan(shape).any():</span>
        <span class="s0">return </span><span class="s1">a.map_blocks(partial(np.empty_like</span><span class="s0">, </span><span class="s1">dtype=(dtype </span><span class="s0">or </span><span class="s1">a.dtype)))</span>

    <span class="s0">return </span><span class="s1">empty(</span>
        <span class="s1">shape</span><span class="s0">,</span>
        <span class="s1">dtype=(dtype </span><span class="s0">or </span><span class="s1">a.dtype)</span><span class="s0">,</span>
        <span class="s1">order=order</span><span class="s0">,</span>
        <span class="s1">chunks=chunks</span><span class="s0">,</span>
        <span class="s1">name=name</span><span class="s0">,</span>
        <span class="s1">meta=a._meta</span><span class="s0">,</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">ones_like(a</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s0">None, </span><span class="s1">order=</span><span class="s4">&quot;C&quot;</span><span class="s0">, </span><span class="s1">chunks=</span><span class="s0">None, </span><span class="s1">name=</span><span class="s0">None, </span><span class="s1">shape=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Return an array of ones with the same shape and type as a given array. 
 
    Parameters 
    ---------- 
    a : array_like 
        The shape and data-type of `a` define these same attributes of 
        the returned array. 
    dtype : data-type, optional 
        Overrides the data type of the result. 
    order : {'C', 'F'}, optional 
        Whether to store multidimensional data in C- or Fortran-contiguous 
        (row- or column-wise) order in memory. 
    chunks : sequence of ints 
        The number of samples on each block. Note that the last block will have 
        fewer samples if ``len(array) % chunks != 0``. 
    name : str, optional 
        An optional keyname for the array. Defaults to hashing the input 
        keyword arguments. 
    shape : int or sequence of ints, optional. 
        Overrides the shape of the result. 
 
    Returns 
    ------- 
    out : ndarray 
        Array of ones with the same shape and type as `a`. 
 
    See Also 
    -------- 
    zeros_like : Return an array of zeros with shape and type of input. 
    empty_like : Return an empty array with shape and type of input. 
    zeros : Return a new array setting values to zero. 
    ones : Return a new array setting values to one. 
    empty : Return a new uninitialized array. 
    &quot;&quot;&quot;</span>

    <span class="s1">a = asarray(a</span><span class="s0">, </span><span class="s1">name=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">shape</span><span class="s0">, </span><span class="s1">chunks = _get_like_function_shapes_chunks(a</span><span class="s0">, </span><span class="s1">chunks</span><span class="s0">, </span><span class="s1">shape)</span>

    <span class="s3"># if shape is nan we cannot rely on regular ones function, we use</span>
    <span class="s3"># generic map_blocks.</span>
    <span class="s0">if </span><span class="s1">np.isnan(shape).any():</span>
        <span class="s0">return </span><span class="s1">a.map_blocks(partial(np.ones_like</span><span class="s0">, </span><span class="s1">dtype=(dtype </span><span class="s0">or </span><span class="s1">a.dtype)))</span>

    <span class="s0">return </span><span class="s1">ones(</span>
        <span class="s1">shape</span><span class="s0">,</span>
        <span class="s1">dtype=(dtype </span><span class="s0">or </span><span class="s1">a.dtype)</span><span class="s0">,</span>
        <span class="s1">order=order</span><span class="s0">,</span>
        <span class="s1">chunks=chunks</span><span class="s0">,</span>
        <span class="s1">name=name</span><span class="s0">,</span>
        <span class="s1">meta=a._meta</span><span class="s0">,</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">zeros_like(a</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s0">None, </span><span class="s1">order=</span><span class="s4">&quot;C&quot;</span><span class="s0">, </span><span class="s1">chunks=</span><span class="s0">None, </span><span class="s1">name=</span><span class="s0">None, </span><span class="s1">shape=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Return an array of zeros with the same shape and type as a given array. 
 
    Parameters 
    ---------- 
    a : array_like 
        The shape and data-type of `a` define these same attributes of 
        the returned array. 
    dtype : data-type, optional 
        Overrides the data type of the result. 
    order : {'C', 'F'}, optional 
        Whether to store multidimensional data in C- or Fortran-contiguous 
        (row- or column-wise) order in memory. 
    chunks : sequence of ints 
        The number of samples on each block. Note that the last block will have 
        fewer samples if ``len(array) % chunks != 0``. 
    name : str, optional 
        An optional keyname for the array. Defaults to hashing the input 
        keyword arguments. 
    shape : int or sequence of ints, optional. 
        Overrides the shape of the result. 
 
    Returns 
    ------- 
    out : ndarray 
        Array of zeros with the same shape and type as `a`. 
 
    See Also 
    -------- 
    ones_like : Return an array of ones with shape and type of input. 
    empty_like : Return an empty array with shape and type of input. 
    zeros : Return a new array setting values to zero. 
    ones : Return a new array setting values to one. 
    empty : Return a new uninitialized array. 
    &quot;&quot;&quot;</span>

    <span class="s1">a = asarray(a</span><span class="s0">, </span><span class="s1">name=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">shape</span><span class="s0">, </span><span class="s1">chunks = _get_like_function_shapes_chunks(a</span><span class="s0">, </span><span class="s1">chunks</span><span class="s0">, </span><span class="s1">shape)</span>

    <span class="s3"># if shape is nan we cannot rely on regular zeros function, we use</span>
    <span class="s3"># generic map_blocks.</span>
    <span class="s0">if </span><span class="s1">np.isnan(shape).any():</span>
        <span class="s0">return </span><span class="s1">a.map_blocks(partial(np.zeros_like</span><span class="s0">, </span><span class="s1">dtype=(dtype </span><span class="s0">or </span><span class="s1">a.dtype)))</span>

    <span class="s0">return </span><span class="s1">zeros(</span>
        <span class="s1">shape</span><span class="s0">,</span>
        <span class="s1">dtype=(dtype </span><span class="s0">or </span><span class="s1">a.dtype)</span><span class="s0">,</span>
        <span class="s1">order=order</span><span class="s0">,</span>
        <span class="s1">chunks=chunks</span><span class="s0">,</span>
        <span class="s1">name=name</span><span class="s0">,</span>
        <span class="s1">meta=a._meta</span><span class="s0">,</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">full_like(a</span><span class="s0">, </span><span class="s1">fill_value</span><span class="s0">, </span><span class="s1">order=</span><span class="s4">&quot;C&quot;</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s0">None, </span><span class="s1">chunks=</span><span class="s0">None, </span><span class="s1">name=</span><span class="s0">None, </span><span class="s1">shape=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Return a full array with the same shape and type as a given array. 
 
    Parameters 
    ---------- 
    a : array_like 
        The shape and data-type of `a` define these same attributes of 
        the returned array. 
    fill_value : scalar 
        Fill value. 
    dtype : data-type, optional 
        Overrides the data type of the result. 
    order : {'C', 'F'}, optional 
        Whether to store multidimensional data in C- or Fortran-contiguous 
        (row- or column-wise) order in memory. 
    chunks : sequence of ints 
        The number of samples on each block. Note that the last block will have 
        fewer samples if ``len(array) % chunks != 0``. 
    name : str, optional 
        An optional keyname for the array. Defaults to hashing the input 
        keyword arguments. 
    shape : int or sequence of ints, optional. 
        Overrides the shape of the result. 
 
    Returns 
    ------- 
    out : ndarray 
        Array of `fill_value` with the same shape and type as `a`. 
 
    See Also 
    -------- 
    zeros_like : Return an array of zeros with shape and type of input. 
    ones_like : Return an array of ones with shape and type of input. 
    empty_like : Return an empty array with shape and type of input. 
    zeros : Return a new array setting values to zero. 
    ones : Return a new array setting values to one. 
    empty : Return a new uninitialized array. 
    full : Fill a new array. 
    &quot;&quot;&quot;</span>

    <span class="s1">a = asarray(a</span><span class="s0">, </span><span class="s1">name=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">shape</span><span class="s0">, </span><span class="s1">chunks = _get_like_function_shapes_chunks(a</span><span class="s0">, </span><span class="s1">chunks</span><span class="s0">, </span><span class="s1">shape)</span>

    <span class="s3"># if shape is nan we cannot rely on regular full function, we use</span>
    <span class="s3"># generic map_blocks.</span>
    <span class="s0">if </span><span class="s1">np.isnan(shape).any():</span>
        <span class="s0">return </span><span class="s1">a.map_blocks(partial(np.full_like</span><span class="s0">, </span><span class="s1">dtype=(dtype </span><span class="s0">or </span><span class="s1">a.dtype))</span><span class="s0">, </span><span class="s1">fill_value)</span>

    <span class="s0">return </span><span class="s1">full(</span>
        <span class="s1">shape</span><span class="s0">,</span>
        <span class="s1">fill_value</span><span class="s0">,</span>
        <span class="s1">dtype=(dtype </span><span class="s0">or </span><span class="s1">a.dtype)</span><span class="s0">,</span>
        <span class="s1">order=order</span><span class="s0">,</span>
        <span class="s1">chunks=chunks</span><span class="s0">,</span>
        <span class="s1">name=name</span><span class="s0">,</span>
        <span class="s1">meta=a._meta</span><span class="s0">,</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">_get_like_function_shapes_chunks(a</span><span class="s0">, </span><span class="s1">chunks</span><span class="s0">, </span><span class="s1">shape):</span>
    <span class="s2">&quot;&quot;&quot; 
    Helper function for finding shapes and chunks for *_like() 
    array creation functions. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">shape </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">shape = a.shape</span>
        <span class="s0">if </span><span class="s1">chunks </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">chunks = a.chunks</span>
    <span class="s0">elif </span><span class="s1">chunks </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">chunks = </span><span class="s4">&quot;auto&quot;</span>
    <span class="s0">return </span><span class="s1">shape</span><span class="s0">, </span><span class="s1">chunks</span>


<span class="s0">def </span><span class="s1">linspace(</span>
    <span class="s1">start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">num=</span><span class="s5">50</span><span class="s0">, </span><span class="s1">endpoint=</span><span class="s0">True, </span><span class="s1">retstep=</span><span class="s0">False, </span><span class="s1">chunks=</span><span class="s4">&quot;auto&quot;</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s0">None</span>
<span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Return `num` evenly spaced values over the closed interval [`start`, 
    `stop`]. 
 
    Parameters 
    ---------- 
    start : scalar 
        The starting value of the sequence. 
    stop : scalar 
        The last value of the sequence. 
    num : int, optional 
        Number of samples to include in the returned dask array, including the 
        endpoints. Default is 50. 
    endpoint : bool, optional 
        If True, ``stop`` is the last sample. Otherwise, it is not included. 
        Default is True. 
    retstep : bool, optional 
        If True, return (samples, step), where step is the spacing between 
        samples. Default is False. 
    chunks :  int 
        The number of samples on each block. Note that the last block will have 
        fewer samples if `num % blocksize != 0` 
    dtype : dtype, optional 
        The type of the output array. 
 
    Returns 
    ------- 
    samples : dask array 
    step : float, optional 
        Only returned if ``retstep`` is True. Size of spacing between samples. 
 
 
    See Also 
    -------- 
    dask.array.arange 
    &quot;&quot;&quot;</span>
    <span class="s1">num = int(num)</span>

    <span class="s0">if </span><span class="s1">dtype </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">dtype = np.linspace(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">).dtype</span>

    <span class="s1">chunks = normalize_chunks(chunks</span><span class="s0">, </span><span class="s1">(num</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>

    <span class="s1">range_ = stop - start</span>

    <span class="s1">div = (num - </span><span class="s5">1</span><span class="s1">) </span><span class="s0">if </span><span class="s1">endpoint </span><span class="s0">else </span><span class="s1">num</span>
    <span class="s0">if </span><span class="s1">div == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">div = </span><span class="s5">1</span>

    <span class="s1">step = float(range_) / div</span>

    <span class="s1">name = </span><span class="s4">&quot;linspace-&quot; </span><span class="s1">+ tokenize((start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">num</span><span class="s0">, </span><span class="s1">endpoint</span><span class="s0">, </span><span class="s1">chunks</span><span class="s0">, </span><span class="s1">dtype))</span>

    <span class="s1">dsk = {}</span>
    <span class="s1">blockstart = start</span>

    <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">bs </span><span class="s0">in </span><span class="s1">enumerate(chunks[</span><span class="s5">0</span><span class="s1">]):</span>
        <span class="s1">bs_space = bs - </span><span class="s5">1 </span><span class="s0">if </span><span class="s1">endpoint </span><span class="s0">else </span><span class="s1">bs</span>
        <span class="s1">blockstop = blockstart + (bs_space * step)</span>
        <span class="s1">task = (</span>
            <span class="s1">partial(chunk.linspace</span><span class="s0">, </span><span class="s1">endpoint=endpoint</span><span class="s0">, </span><span class="s1">dtype=dtype)</span><span class="s0">,</span>
            <span class="s1">blockstart</span><span class="s0">,</span>
            <span class="s1">blockstop</span><span class="s0">,</span>
            <span class="s1">bs</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">blockstart = blockstart + (step * bs)</span>
        <span class="s1">dsk[(name</span><span class="s0">, </span><span class="s1">i)] = task</span>

    <span class="s0">if </span><span class="s1">retstep:</span>
        <span class="s0">return </span><span class="s1">Array(dsk</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">chunks</span><span class="s0">, </span><span class="s1">dtype=dtype)</span><span class="s0">, </span><span class="s1">step</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">Array(dsk</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">chunks</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>


<span class="s1">@array_creation_dispatch.register_inplace(</span><span class="s4">&quot;numpy&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">arange(*args</span><span class="s0">, </span><span class="s1">chunks=</span><span class="s4">&quot;auto&quot;</span><span class="s0">, </span><span class="s1">like=</span><span class="s0">None, </span><span class="s1">dtype=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
    <span class="s2">&quot;&quot;&quot; 
    Return evenly spaced values from `start` to `stop` with step size `step`. 
 
    The values are half-open [start, stop), so including start and excluding 
    stop. This is basically the same as python's range function but for dask 
    arrays. 
 
    When using a non-integer step, such as 0.1, the results will often not be 
    consistent. It is better to use linspace for these cases. 
 
    Parameters 
    ---------- 
    start : int, optional 
        The starting value of the sequence. The default is 0. 
    stop : int 
        The end of the interval, this value is excluded from the interval. 
    step : int, optional 
        The spacing between the values. The default is 1 when not specified. 
        The last value of the sequence. 
    chunks :  int 
        The number of samples on each block. Note that the last block will have 
        fewer samples if ``len(array) % chunks != 0``. 
        Defaults to &quot;auto&quot; which will automatically determine chunk sizes. 
    dtype : numpy.dtype 
        Output dtype. Omit to infer it from start, stop, step 
        Defaults to ``None``. 
    like : array type or ``None`` 
        Array to extract meta from. Defaults to ``None``. 
 
    Returns 
    ------- 
    samples : dask array 
 
    See Also 
    -------- 
    dask.array.linspace 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">len(args) == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">start = </span><span class="s5">0</span>
        <span class="s1">stop = args[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">step = </span><span class="s5">1</span>
    <span class="s0">elif </span><span class="s1">len(args) == </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s1">start = args[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">stop = args[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">step = </span><span class="s5">1</span>
    <span class="s0">elif </span><span class="s1">len(args) == </span><span class="s5">3</span><span class="s1">:</span>
        <span class="s1">start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">step = args</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span>
            <span class="s4">&quot;&quot;&quot; 
        arange takes 3 positional arguments: arange([start], stop, [step]) 
        &quot;&quot;&quot;</span>
        <span class="s1">)</span>

    <span class="s1">num = int(max(np.ceil((stop - start) / step)</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span>

    <span class="s1">meta = meta_from_array(like) </span><span class="s0">if </span><span class="s1">like </span><span class="s0">is not None else None</span>

    <span class="s0">if </span><span class="s1">dtype </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">dtype = np.arange(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">step * num </span><span class="s0">if </span><span class="s1">num </span><span class="s0">else </span><span class="s1">step).dtype</span>

    <span class="s1">chunks = normalize_chunks(chunks</span><span class="s0">, </span><span class="s1">(num</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>

    <span class="s0">if </span><span class="s1">kwargs:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Unexpected keyword argument(s): %s&quot; </span><span class="s1">% </span><span class="s4">&quot;,&quot;</span><span class="s1">.join(kwargs.keys()))</span>

    <span class="s1">name = </span><span class="s4">&quot;arange-&quot; </span><span class="s1">+ tokenize((start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">step</span><span class="s0">, </span><span class="s1">chunks</span><span class="s0">, </span><span class="s1">dtype))</span>
    <span class="s1">dsk = {}</span>
    <span class="s1">elem_count = </span><span class="s5">0</span>

    <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">bs </span><span class="s0">in </span><span class="s1">enumerate(chunks[</span><span class="s5">0</span><span class="s1">]):</span>
        <span class="s1">blockstart = start + (elem_count * step)</span>
        <span class="s1">blockstop = start + ((elem_count + bs) * step)</span>
        <span class="s1">task = (</span>
            <span class="s1">partial(chunk.arange</span><span class="s0">, </span><span class="s1">like=like)</span><span class="s0">,</span>
            <span class="s1">blockstart</span><span class="s0">,</span>
            <span class="s1">blockstop</span><span class="s0">,</span>
            <span class="s1">step</span><span class="s0">,</span>
            <span class="s1">bs</span><span class="s0">,</span>
            <span class="s1">dtype</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">dsk[(name</span><span class="s0">, </span><span class="s1">i)] = task</span>
        <span class="s1">elem_count += bs</span>

    <span class="s0">return </span><span class="s1">Array(dsk</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">chunks</span><span class="s0">, </span><span class="s1">dtype=dtype</span><span class="s0">, </span><span class="s1">meta=meta)</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">meshgrid(*xi</span><span class="s0">, </span><span class="s1">sparse=</span><span class="s0">False, </span><span class="s1">indexing=</span><span class="s4">&quot;xy&quot;</span><span class="s0">, </span><span class="s1">**kwargs):</span>
    <span class="s1">sparse = bool(sparse)</span>

    <span class="s0">if </span><span class="s4">&quot;copy&quot; </span><span class="s0">in </span><span class="s1">kwargs:</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;`copy` not supported&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">kwargs:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;unsupported keyword argument(s) provided&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">indexing </span><span class="s0">not in </span><span class="s1">(</span><span class="s4">&quot;ij&quot;</span><span class="s0">, </span><span class="s4">&quot;xy&quot;</span><span class="s1">):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;`indexing` must be `'ij'` or `'xy'`&quot;</span><span class="s1">)</span>

    <span class="s1">xi = [asarray(e) </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">xi]</span>
    <span class="s1">xi = [e.flatten() </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">xi]</span>

    <span class="s0">if </span><span class="s1">indexing == </span><span class="s4">&quot;xy&quot; </span><span class="s0">and </span><span class="s1">len(xi) &gt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">xi[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">xi[</span><span class="s5">1</span><span class="s1">] = xi[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">xi[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s1">grid = []</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(xi)):</span>
        <span class="s1">s = len(xi) * [</span><span class="s0">None</span><span class="s1">]</span>
        <span class="s1">s[i] = slice(</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">s = tuple(s)</span>

        <span class="s1">r = xi[i][s]</span>

        <span class="s1">grid.append(r)</span>

    <span class="s0">if not </span><span class="s1">sparse:</span>
        <span class="s1">grid = broadcast_arrays(*grid)</span>

    <span class="s0">if </span><span class="s1">indexing == </span><span class="s4">&quot;xy&quot; </span><span class="s0">and </span><span class="s1">len(xi) &gt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">grid[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">grid[</span><span class="s5">1</span><span class="s1">] = grid[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">grid[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s0">return </span><span class="s1">grid</span>


<span class="s0">def </span><span class="s1">indices(dimensions</span><span class="s0">, </span><span class="s1">dtype=int</span><span class="s0">, </span><span class="s1">chunks=</span><span class="s4">&quot;auto&quot;</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Implements NumPy's ``indices`` for Dask Arrays. 
 
    Generates a grid of indices covering the dimensions provided. 
 
    The final array has the shape ``(len(dimensions), *dimensions)``. The 
    chunks are used to specify the chunking for axis 1 up to 
    ``len(dimensions)``. The 0th axis always has chunks of length 1. 
 
    Parameters 
    ---------- 
    dimensions : sequence of ints 
        The shape of the index grid. 
    dtype : dtype, optional 
        Type to use for the array. Default is ``int``. 
    chunks : sequence of ints, str 
        The size of each block.  Must be one of the following forms: 
 
        - A blocksize like (500, 1000) 
        - A size in bytes, like &quot;100 MiB&quot; which will choose a uniform 
          block-like shape 
        - The word &quot;auto&quot; which acts like the above, but uses a configuration 
          value ``array.chunk-size`` for the chunk size 
 
        Note that the last block will have fewer samples if ``len(array) % chunks != 0``. 
 
    Returns 
    ------- 
    grid : dask array 
    &quot;&quot;&quot;</span>
    <span class="s1">dimensions = tuple(dimensions)</span>
    <span class="s1">dtype = np.dtype(dtype)</span>
    <span class="s1">chunks = normalize_chunks(chunks</span><span class="s0">, </span><span class="s1">shape=dimensions</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>

    <span class="s0">if </span><span class="s1">len(dimensions) != len(chunks):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Need same number of chunks as dimensions.&quot;</span><span class="s1">)</span>

    <span class="s1">xi = []</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(dimensions)):</span>
        <span class="s1">xi.append(arange(dimensions[i]</span><span class="s0">, </span><span class="s1">dtype=dtype</span><span class="s0">, </span><span class="s1">chunks=(chunks[i]</span><span class="s0">,</span><span class="s1">)))</span>

    <span class="s1">grid = []</span>
    <span class="s0">if </span><span class="s1">all(dimensions):</span>
        <span class="s1">grid = meshgrid(*xi</span><span class="s0">, </span><span class="s1">indexing=</span><span class="s4">&quot;ij&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">grid:</span>
        <span class="s1">grid = stack(grid)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">grid = empty((len(dimensions)</span><span class="s0">,</span><span class="s1">) + dimensions</span><span class="s0">, </span><span class="s1">dtype=dtype</span><span class="s0">, </span><span class="s1">chunks=(</span><span class="s5">1</span><span class="s0">,</span><span class="s1">) + chunks)</span>

    <span class="s0">return </span><span class="s1">grid</span>


<span class="s0">def </span><span class="s1">eye(N</span><span class="s0">, </span><span class="s1">chunks=</span><span class="s4">&quot;auto&quot;</span><span class="s0">, </span><span class="s1">M=</span><span class="s0">None, </span><span class="s1">k=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">dtype=float):</span>
    <span class="s2">&quot;&quot;&quot; 
    Return a 2-D Array with ones on the diagonal and zeros elsewhere. 
 
    Parameters 
    ---------- 
    N : int 
      Number of rows in the output. 
    chunks : int, str 
        How to chunk the array. Must be one of the following forms: 
 
        -   A blocksize like 1000. 
        -   A size in bytes, like &quot;100 MiB&quot; which will choose a uniform 
            block-like shape 
        -   The word &quot;auto&quot; which acts like the above, but uses a configuration 
            value ``array.chunk-size`` for the chunk size 
    M : int, optional 
      Number of columns in the output. If None, defaults to `N`. 
    k : int, optional 
      Index of the diagonal: 0 (the default) refers to the main diagonal, 
      a positive value refers to an upper diagonal, and a negative value 
      to a lower diagonal. 
    dtype : data-type, optional 
      Data-type of the returned array. 
 
    Returns 
    ------- 
    I : Array of shape (N,M) 
      An array where all elements are equal to zero, except for the `k`-th 
      diagonal, whose values are equal to one. 
    &quot;&quot;&quot;</span>
    <span class="s1">eye = {}</span>
    <span class="s0">if </span><span class="s1">M </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">M = N</span>
    <span class="s0">if </span><span class="s1">dtype </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">dtype = float</span>

    <span class="s0">if not </span><span class="s1">isinstance(chunks</span><span class="s0">, </span><span class="s1">(int</span><span class="s0">, </span><span class="s1">str)):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;chunks must be an int or string&quot;</span><span class="s1">)</span>

    <span class="s1">vchunks</span><span class="s0">, </span><span class="s1">hchunks = normalize_chunks(chunks</span><span class="s0">, </span><span class="s1">shape=(N</span><span class="s0">, </span><span class="s1">M)</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">chunks = vchunks[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s1">token = tokenize(N</span><span class="s0">, </span><span class="s1">chunks</span><span class="s0">, </span><span class="s1">M</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">dtype)</span>
    <span class="s1">name_eye = </span><span class="s4">&quot;eye-&quot; </span><span class="s1">+ token</span>

    <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">vchunk </span><span class="s0">in </span><span class="s1">enumerate(vchunks):</span>
        <span class="s0">for </span><span class="s1">j</span><span class="s0">, </span><span class="s1">hchunk </span><span class="s0">in </span><span class="s1">enumerate(hchunks):</span>
            <span class="s0">if </span><span class="s1">(j - i - </span><span class="s5">1</span><span class="s1">) * chunks &lt;= k &lt;= (j - i + </span><span class="s5">1</span><span class="s1">) * chunks:</span>
                <span class="s1">eye[name_eye</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">j] = (</span>
                    <span class="s1">np.eye</span><span class="s0">,</span>
                    <span class="s1">vchunk</span><span class="s0">,</span>
                    <span class="s1">hchunk</span><span class="s0">,</span>
                    <span class="s1">k - (j - i) * chunks</span><span class="s0">,</span>
                    <span class="s1">dtype</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">eye[name_eye</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">j] = (np.zeros</span><span class="s0">, </span><span class="s1">(vchunk</span><span class="s0">, </span><span class="s1">hchunk)</span><span class="s0">, </span><span class="s1">dtype)</span>
    <span class="s0">return </span><span class="s1">Array(eye</span><span class="s0">, </span><span class="s1">name_eye</span><span class="s0">, </span><span class="s1">shape=(N</span><span class="s0">, </span><span class="s1">M)</span><span class="s0">, </span><span class="s1">chunks=(chunks</span><span class="s0">, </span><span class="s1">chunks)</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">diag(v</span><span class="s0">, </span><span class="s1">k=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s0">if not </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">np.ndarray) </span><span class="s0">and not </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">Array):</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">f&quot;v must be a dask array or numpy array, got </span><span class="s0">{</span><span class="s1">type(v)</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">)</span>

    <span class="s1">name = </span><span class="s4">&quot;diag-&quot; </span><span class="s1">+ tokenize(v</span><span class="s0">, </span><span class="s1">k)</span>

    <span class="s1">meta = meta_from_array(v</span><span class="s0">, </span><span class="s5">2 </span><span class="s0">if </span><span class="s1">v.ndim == </span><span class="s5">1 </span><span class="s0">else </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">np.ndarray) </span><span class="s0">or </span><span class="s1">(</span>
        <span class="s1">hasattr(v</span><span class="s0">, </span><span class="s4">&quot;__array_function__&quot;</span><span class="s1">) </span><span class="s0">and not </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">Array)</span>
    <span class="s1">):</span>
        <span class="s0">if </span><span class="s1">v.ndim == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">m = abs(k)</span>
            <span class="s1">chunks = ((v.shape[</span><span class="s5">0</span><span class="s1">] + m</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(v.shape[</span><span class="s5">0</span><span class="s1">] + m</span><span class="s0">,</span><span class="s1">))</span>
            <span class="s1">dsk = {(name</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">): (np.diag</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">k)}</span>
        <span class="s0">elif </span><span class="s1">v.ndim == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">kdiag_row_start = max(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">-k)</span>
            <span class="s1">kdiag_row_stop = min(v.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">v.shape[</span><span class="s5">1</span><span class="s1">] - k)</span>
            <span class="s1">len_kdiag = kdiag_row_stop - kdiag_row_start</span>
            <span class="s1">chunks = ((</span><span class="s5">0</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span><span class="s1">) </span><span class="s0">if </span><span class="s1">len_kdiag &lt;= </span><span class="s5">0 </span><span class="s0">else </span><span class="s1">((len_kdiag</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span><span class="s1">)</span>
            <span class="s1">dsk = {(name</span><span class="s0">, </span><span class="s5">0</span><span class="s1">): (np.diag</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">k)}</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Array must be 1d or 2d only&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">Array(dsk</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">chunks</span><span class="s0">, </span><span class="s1">meta=meta)</span>

    <span class="s0">if </span><span class="s1">v.ndim != </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">v.ndim != </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Array must be 1d or 2d only&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">k == </span><span class="s5">0 </span><span class="s0">and </span><span class="s1">v.chunks[</span><span class="s5">0</span><span class="s1">] == v.chunks[</span><span class="s5">1</span><span class="s1">]:</span>
            <span class="s1">dsk = {</span>
                <span class="s1">(name</span><span class="s0">, </span><span class="s1">i): (np.diag</span><span class="s0">, </span><span class="s1">row[i]) </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">row </span><span class="s0">in </span><span class="s1">enumerate(v.__dask_keys__())</span>
            <span class="s1">}</span>
            <span class="s1">graph = HighLevelGraph.from_collections(name</span><span class="s0">, </span><span class="s1">dsk</span><span class="s0">, </span><span class="s1">dependencies=[v])</span>
            <span class="s0">return </span><span class="s1">Array(graph</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">(v.chunks[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">meta=meta)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">diagonal(v</span><span class="s0">, </span><span class="s1">k)</span>

    <span class="s0">if </span><span class="s1">k == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">chunks_1d = v.chunks[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">blocks = v.__dask_keys__()</span>
        <span class="s1">dsk = {}</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">m </span><span class="s0">in </span><span class="s1">enumerate(chunks_1d):</span>
            <span class="s0">for </span><span class="s1">j</span><span class="s0">, </span><span class="s1">n </span><span class="s0">in </span><span class="s1">enumerate(chunks_1d):</span>
                <span class="s1">key = (name</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">j)</span>
                <span class="s0">if </span><span class="s1">i == j:</span>
                    <span class="s1">dsk[key] = (np.diag</span><span class="s0">, </span><span class="s1">blocks[i])</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">dsk[key] = (np.zeros</span><span class="s0">, </span><span class="s1">(m</span><span class="s0">, </span><span class="s1">n))</span>
                    <span class="s1">dsk[key] = (partial(np.zeros_like</span><span class="s0">, </span><span class="s1">shape=(m</span><span class="s0">, </span><span class="s1">n))</span><span class="s0">, </span><span class="s1">meta)</span>

        <span class="s1">graph = HighLevelGraph.from_collections(name</span><span class="s0">, </span><span class="s1">dsk</span><span class="s0">, </span><span class="s1">dependencies=[v])</span>
        <span class="s0">return </span><span class="s1">Array(graph</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">(chunks_1d</span><span class="s0">, </span><span class="s1">chunks_1d)</span><span class="s0">, </span><span class="s1">meta=meta)</span>

    <span class="s0">elif </span><span class="s1">k &gt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">pad(diag(v)</span><span class="s0">, </span><span class="s1">[[</span><span class="s5">0</span><span class="s0">, </span><span class="s1">k]</span><span class="s0">, </span><span class="s1">[k</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">&quot;constant&quot;</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">k &lt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">pad(diag(v)</span><span class="s0">, </span><span class="s1">[[-k</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">0</span><span class="s0">, </span><span class="s1">-k]]</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">&quot;constant&quot;</span><span class="s1">)</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">diagonal(a</span><span class="s0">, </span><span class="s1">offset=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">axis1=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">axis2=</span><span class="s5">1</span><span class="s1">):</span>
    <span class="s1">name = </span><span class="s4">&quot;diagonal-&quot; </span><span class="s1">+ tokenize(a</span><span class="s0">, </span><span class="s1">offset</span><span class="s0">, </span><span class="s1">axis1</span><span class="s0">, </span><span class="s1">axis2)</span>

    <span class="s0">if </span><span class="s1">a.ndim &lt; </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s3"># NumPy uses `diag` as we do here.</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;diag requires an array of at least two dimensions&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_axis_fmt(axis</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">ndim):</span>
        <span class="s0">if </span><span class="s1">axis &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">t = ndim + axis</span>
            <span class="s0">if </span><span class="s1">t &lt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">msg = </span><span class="s4">&quot;{}: axis {} is out of bounds for array of dimension {}&quot;</span>
                <span class="s0">raise </span><span class="s1">AxisError(msg.format(name</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">ndim))</span>
            <span class="s1">axis = t</span>
        <span class="s0">return </span><span class="s1">axis</span>

    <span class="s0">def </span><span class="s1">pop_axes(chunks</span><span class="s0">, </span><span class="s1">axis1</span><span class="s0">, </span><span class="s1">axis2):</span>
        <span class="s1">chunks = list(chunks)</span>
        <span class="s1">chunks.pop(axis2)</span>
        <span class="s1">chunks.pop(axis1)</span>
        <span class="s0">return </span><span class="s1">tuple(chunks)</span>

    <span class="s1">axis1 = _axis_fmt(axis1</span><span class="s0">, </span><span class="s4">&quot;axis1&quot;</span><span class="s0">, </span><span class="s1">a.ndim)</span>
    <span class="s1">axis2 = _axis_fmt(axis2</span><span class="s0">, </span><span class="s4">&quot;axis2&quot;</span><span class="s0">, </span><span class="s1">a.ndim)</span>

    <span class="s0">if </span><span class="s1">axis1 == axis2:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;axis1 and axis2 cannot be the same&quot;</span><span class="s1">)</span>

    <span class="s1">a = asarray(a)</span>
    <span class="s1">k = offset</span>
    <span class="s0">if </span><span class="s1">axis1 &gt; axis2:</span>
        <span class="s1">axis1</span><span class="s0">, </span><span class="s1">axis2 = axis2</span><span class="s0">, </span><span class="s1">axis1</span>
        <span class="s1">k = -offset</span>

    <span class="s1">free_axes = set(range(a.ndim)) - {axis1</span><span class="s0">, </span><span class="s1">axis2}</span>
    <span class="s1">free_indices = list(product(*(range(a.numblocks[i]) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">free_axes)))</span>
    <span class="s1">ndims_free = len(free_axes)</span>

    <span class="s3"># equation of diagonal: i = j - k</span>
    <span class="s1">kdiag_row_start = max(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">-k)</span>
    <span class="s1">kdiag_col_start = max(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">k)</span>
    <span class="s1">kdiag_row_stop = min(a.shape[axis1]</span><span class="s0">, </span><span class="s1">a.shape[axis2] - k)</span>
    <span class="s1">len_kdiag = kdiag_row_stop - kdiag_row_start</span>

    <span class="s0">if </span><span class="s1">len_kdiag &lt;= </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">xp = np</span>

        <span class="s0">if </span><span class="s1">is_cupy_type(a._meta):</span>
            <span class="s0">import </span><span class="s1">cupy</span>

            <span class="s1">xp = cupy</span>

        <span class="s1">out_chunks = pop_axes(a.chunks</span><span class="s0">, </span><span class="s1">axis1</span><span class="s0">, </span><span class="s1">axis2) + ((</span><span class="s5">0</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s1">dsk = dict()</span>
        <span class="s0">for </span><span class="s1">free_idx </span><span class="s0">in </span><span class="s1">free_indices:</span>
            <span class="s1">shape = tuple(</span>
                <span class="s1">out_chunks[axis][free_idx[axis]] </span><span class="s0">for </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">range(ndims_free)</span>
            <span class="s1">)</span>
            <span class="s1">dsk[(name</span><span class="s0">,</span><span class="s1">) + free_idx + (</span><span class="s5">0</span><span class="s0">,</span><span class="s1">)] = (</span>
                <span class="s1">partial(xp.empty</span><span class="s0">, </span><span class="s1">dtype=a.dtype)</span><span class="s0">,</span>
                <span class="s1">shape + (</span><span class="s5">0</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s1">meta = meta_from_array(a</span><span class="s0">, </span><span class="s1">ndims_free + </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">Array(dsk</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">out_chunks</span><span class="s0">, </span><span class="s1">meta=meta)</span>

    <span class="s3"># compute row index ranges for chunks along axis1:</span>
    <span class="s1">row_stops_ = np.cumsum(a.chunks[axis1])</span>
    <span class="s1">row_starts = np.roll(row_stops_</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">row_starts[</span><span class="s5">0</span><span class="s1">] = </span><span class="s5">0</span>

    <span class="s3"># compute column index ranges for chunks along axis2:</span>
    <span class="s1">col_stops_ = np.cumsum(a.chunks[axis2])</span>
    <span class="s1">col_starts = np.roll(col_stops_</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">col_starts[</span><span class="s5">0</span><span class="s1">] = </span><span class="s5">0</span>

    <span class="s3"># locate first chunk containing diagonal:</span>
    <span class="s1">row_blockid = np.arange(a.numblocks[axis1])</span>
    <span class="s1">col_blockid = np.arange(a.numblocks[axis2])</span>

    <span class="s1">row_filter = (row_starts &lt;= kdiag_row_start) &amp; (kdiag_row_start &lt; row_stops_)</span>
    <span class="s1">col_filter = (col_starts &lt;= kdiag_col_start) &amp; (kdiag_col_start &lt; col_stops_)</span>
    <span class="s1">(I</span><span class="s0">,</span><span class="s1">) = row_blockid[row_filter]</span>
    <span class="s1">(J</span><span class="s0">,</span><span class="s1">) = col_blockid[col_filter]</span>

    <span class="s3"># follow k-diagonal through chunks while constructing dask graph:</span>
    <span class="s1">dsk = dict()</span>
    <span class="s1">i = </span><span class="s5">0</span>
    <span class="s1">kdiag_chunks = ()</span>
    <span class="s0">while </span><span class="s1">kdiag_row_start &lt; a.shape[axis1] </span><span class="s0">and </span><span class="s1">kdiag_col_start &lt; a.shape[axis2]:</span>
        <span class="s3"># localize block info:</span>
        <span class="s1">nrows</span><span class="s0">, </span><span class="s1">ncols = a.chunks[axis1][I]</span><span class="s0">, </span><span class="s1">a.chunks[axis2][J]</span>
        <span class="s1">kdiag_row_start -= row_starts[I]</span>
        <span class="s1">kdiag_col_start -= col_starts[J]</span>
        <span class="s1">k = -kdiag_row_start </span><span class="s0">if </span><span class="s1">kdiag_row_start &gt; </span><span class="s5">0 </span><span class="s0">else </span><span class="s1">kdiag_col_start</span>
        <span class="s1">kdiag_row_end = min(nrows</span><span class="s0">, </span><span class="s1">ncols - k)</span>
        <span class="s1">kdiag_len = kdiag_row_end - kdiag_row_start</span>

        <span class="s3"># increment dask graph:</span>
        <span class="s0">for </span><span class="s1">free_idx </span><span class="s0">in </span><span class="s1">free_indices:</span>
            <span class="s1">input_idx = (</span>
                <span class="s1">free_idx[:axis1]</span>
                <span class="s1">+ (I</span><span class="s0">,</span><span class="s1">)</span>
                <span class="s1">+ free_idx[axis1 : axis2 - </span><span class="s5">1</span><span class="s1">]</span>
                <span class="s1">+ (J</span><span class="s0">,</span><span class="s1">)</span>
                <span class="s1">+ free_idx[axis2 - </span><span class="s5">1 </span><span class="s1">:]</span>
            <span class="s1">)</span>
            <span class="s1">output_idx = free_idx + (i</span><span class="s0">,</span><span class="s1">)</span>
            <span class="s1">dsk[(name</span><span class="s0">,</span><span class="s1">) + output_idx] = (</span>
                <span class="s1">np.diagonal</span><span class="s0">,</span>
                <span class="s1">(a.name</span><span class="s0">,</span><span class="s1">) + input_idx</span><span class="s0">,</span>
                <span class="s1">k</span><span class="s0">,</span>
                <span class="s1">axis1</span><span class="s0">,</span>
                <span class="s1">axis2</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s1">kdiag_chunks += (kdiag_len</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s3"># prepare for next iteration:</span>
        <span class="s1">i += </span><span class="s5">1</span>
        <span class="s1">kdiag_row_start = kdiag_row_end + row_starts[I]</span>
        <span class="s1">kdiag_col_start = min(ncols</span><span class="s0">, </span><span class="s1">nrows + k) + col_starts[J]</span>
        <span class="s1">I = I + </span><span class="s5">1 </span><span class="s0">if </span><span class="s1">kdiag_row_start == row_stops_[I] </span><span class="s0">else </span><span class="s1">I</span>
        <span class="s1">J = J + </span><span class="s5">1 </span><span class="s0">if </span><span class="s1">kdiag_col_start == col_stops_[J] </span><span class="s0">else </span><span class="s1">J</span>

    <span class="s1">out_chunks = pop_axes(a.chunks</span><span class="s0">, </span><span class="s1">axis1</span><span class="s0">, </span><span class="s1">axis2) + (kdiag_chunks</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s1">graph = HighLevelGraph.from_collections(name</span><span class="s0">, </span><span class="s1">dsk</span><span class="s0">, </span><span class="s1">dependencies=[a])</span>
    <span class="s1">meta = meta_from_array(a</span><span class="s0">, </span><span class="s1">ndims_free + </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array(graph</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">out_chunks</span><span class="s0">, </span><span class="s1">meta=meta)</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">tri(N</span><span class="s0">, </span><span class="s1">M=</span><span class="s0">None, </span><span class="s1">k=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">dtype=float</span><span class="s0">, </span><span class="s1">chunks=</span><span class="s4">&quot;auto&quot;</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">like=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">if </span><span class="s1">M </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">M = N</span>

    <span class="s1">chunks = normalize_chunks(chunks</span><span class="s0">, </span><span class="s1">shape=(N</span><span class="s0">, </span><span class="s1">M)</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>

    <span class="s1">m = greater_equal(</span>
        <span class="s1">arange(N</span><span class="s0">, </span><span class="s1">chunks=chunks[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">like=like).reshape(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">N).T</span><span class="s0">,</span>
        <span class="s1">arange(-k</span><span class="s0">, </span><span class="s1">M - k</span><span class="s0">, </span><span class="s1">chunks=chunks[</span><span class="s5">1</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">like=like)</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s3"># Avoid making a copy if the requested type is already bool</span>
    <span class="s1">m = m.astype(dtype</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">m</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">fromfunction(func</span><span class="s0">, </span><span class="s1">chunks=</span><span class="s4">&quot;auto&quot;</span><span class="s0">, </span><span class="s1">shape=</span><span class="s0">None, </span><span class="s1">dtype=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
    <span class="s1">dtype = dtype </span><span class="s0">or </span><span class="s1">float</span>
    <span class="s1">chunks = normalize_chunks(chunks</span><span class="s0">, </span><span class="s1">shape</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>

    <span class="s1">inds = tuple(range(len(shape)))</span>

    <span class="s1">arrs = [arange(s</span><span class="s0">, </span><span class="s1">dtype=dtype</span><span class="s0">, </span><span class="s1">chunks=c) </span><span class="s0">for </span><span class="s1">s</span><span class="s0">, </span><span class="s1">c </span><span class="s0">in </span><span class="s1">zip(shape</span><span class="s0">, </span><span class="s1">chunks)]</span>
    <span class="s1">arrs = meshgrid(*arrs</span><span class="s0">, </span><span class="s1">indexing=</span><span class="s4">&quot;ij&quot;</span><span class="s1">)</span>

    <span class="s1">args = sum(zip(arrs</span><span class="s0">, </span><span class="s1">itertools.repeat(inds))</span><span class="s0">, </span><span class="s1">())</span>

    <span class="s1">res = blockwise(func</span><span class="s0">, </span><span class="s1">inds</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">token=</span><span class="s4">&quot;fromfunction&quot;</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">return </span><span class="s1">res</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">repeat(a</span><span class="s0">, </span><span class="s1">repeats</span><span class="s0">, </span><span class="s1">axis=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">a.ndim == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">axis = </span><span class="s5">0</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;Must supply an integer axis value&quot;</span><span class="s1">)</span>

    <span class="s0">if not </span><span class="s1">isinstance(repeats</span><span class="s0">, </span><span class="s1">Integral):</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;Only integer valued repeats supported&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">-a.ndim &lt;= axis &lt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">axis += a.ndim</span>
    <span class="s0">elif not </span><span class="s5">0 </span><span class="s1">&lt;= axis &lt;= a.ndim - </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;axis(=%d) out of bounds&quot; </span><span class="s1">% axis)</span>

    <span class="s0">if </span><span class="s1">repeats == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">a[tuple(slice(</span><span class="s0">None</span><span class="s1">) </span><span class="s0">if </span><span class="s1">d != axis </span><span class="s0">else </span><span class="s1">slice(</span><span class="s5">0</span><span class="s1">) </span><span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">range(a.ndim))]</span>
    <span class="s0">elif </span><span class="s1">repeats == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">a</span>

    <span class="s1">cchunks = cached_cumsum(a.chunks[axis]</span><span class="s0">, </span><span class="s1">initial_zero=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">slices = []</span>
    <span class="s0">for </span><span class="s1">c_start</span><span class="s0">, </span><span class="s1">c_stop </span><span class="s0">in </span><span class="s1">sliding_window(</span><span class="s5">2</span><span class="s0">, </span><span class="s1">cchunks):</span>
        <span class="s1">ls = np.linspace(c_start</span><span class="s0">, </span><span class="s1">c_stop</span><span class="s0">, </span><span class="s1">repeats).round(</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">ls_start</span><span class="s0">, </span><span class="s1">ls_stop </span><span class="s0">in </span><span class="s1">sliding_window(</span><span class="s5">2</span><span class="s0">, </span><span class="s1">ls):</span>
            <span class="s0">if </span><span class="s1">ls_start != ls_stop:</span>
                <span class="s1">slices.append(slice(ls_start</span><span class="s0">, </span><span class="s1">ls_stop))</span>

    <span class="s1">all_slice = slice(</span><span class="s0">None, None, None</span><span class="s1">)</span>
    <span class="s1">slices = [</span>
        <span class="s1">(all_slice</span><span class="s0">,</span><span class="s1">) * axis + (s</span><span class="s0">,</span><span class="s1">) + (all_slice</span><span class="s0">,</span><span class="s1">) * (a.ndim - axis - </span><span class="s5">1</span><span class="s1">) </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">slices</span>
    <span class="s1">]</span>

    <span class="s1">slabs = [a[slc] </span><span class="s0">for </span><span class="s1">slc </span><span class="s0">in </span><span class="s1">slices]</span>

    <span class="s1">out = []</span>
    <span class="s0">for </span><span class="s1">slab </span><span class="s0">in </span><span class="s1">slabs:</span>
        <span class="s1">chunks = list(slab.chunks)</span>
        <span class="s0">assert </span><span class="s1">len(chunks[axis]) == </span><span class="s5">1</span>
        <span class="s1">chunks[axis] = (chunks[axis][</span><span class="s5">0</span><span class="s1">] * repeats</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s1">chunks = tuple(chunks)</span>
        <span class="s1">result = slab.map_blocks(</span>
            <span class="s1">np.repeat</span><span class="s0">, </span><span class="s1">repeats</span><span class="s0">, </span><span class="s1">axis=axis</span><span class="s0">, </span><span class="s1">chunks=chunks</span><span class="s0">, </span><span class="s1">dtype=slab.dtype</span>
        <span class="s1">)</span>
        <span class="s1">out.append(result)</span>

    <span class="s0">return </span><span class="s1">concatenate(out</span><span class="s0">, </span><span class="s1">axis=axis)</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">tile(A</span><span class="s0">, </span><span class="s1">reps):</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">tup = tuple(reps)</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s1">tup = (reps</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">any(i &lt; </span><span class="s5">0 </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">tup):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Negative `reps` are not allowed.&quot;</span><span class="s1">)</span>
    <span class="s1">c = asarray(A)</span>

    <span class="s0">if </span><span class="s1">all(tup):</span>
        <span class="s0">for </span><span class="s1">nrep </span><span class="s0">in </span><span class="s1">tup[::-</span><span class="s5">1</span><span class="s1">]:</span>
            <span class="s1">c = nrep * [c]</span>
        <span class="s0">return </span><span class="s1">block(c)</span>

    <span class="s1">d = len(tup)</span>
    <span class="s0">if </span><span class="s1">d &lt; c.ndim:</span>
        <span class="s1">tup = (</span><span class="s5">1</span><span class="s0">,</span><span class="s1">) * (c.ndim - d) + tup</span>
    <span class="s0">if </span><span class="s1">c.ndim &lt; d:</span>
        <span class="s1">shape = (</span><span class="s5">1</span><span class="s0">,</span><span class="s1">) * (d - c.ndim) + c.shape</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">shape = c.shape</span>
    <span class="s1">shape_out = tuple(s * t </span><span class="s0">for </span><span class="s1">s</span><span class="s0">, </span><span class="s1">t </span><span class="s0">in </span><span class="s1">zip(shape</span><span class="s0">, </span><span class="s1">tup))</span>
    <span class="s0">return </span><span class="s1">empty(shape=shape_out</span><span class="s0">, </span><span class="s1">dtype=c.dtype)</span>


<span class="s0">def </span><span class="s1">expand_pad_value(array</span><span class="s0">, </span><span class="s1">pad_value):</span>
    <span class="s0">if </span><span class="s1">isinstance(pad_value</span><span class="s0">, </span><span class="s1">Number) </span><span class="s0">or </span><span class="s1">getattr(pad_value</span><span class="s0">, </span><span class="s4">&quot;ndim&quot;</span><span class="s0">, None</span><span class="s1">) == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">pad_value = array.ndim * ((pad_value</span><span class="s0">, </span><span class="s1">pad_value)</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">(</span>
        <span class="s1">isinstance(pad_value</span><span class="s0">, </span><span class="s1">Sequence)</span>
        <span class="s0">and </span><span class="s1">all(isinstance(pw</span><span class="s0">, </span><span class="s1">Number) </span><span class="s0">for </span><span class="s1">pw </span><span class="s0">in </span><span class="s1">pad_value)</span>
        <span class="s0">and </span><span class="s1">len(pad_value) == </span><span class="s5">1</span>
    <span class="s1">):</span>
        <span class="s1">pad_value = array.ndim * ((pad_value[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">pad_value[</span><span class="s5">0</span><span class="s1">])</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">(</span>
        <span class="s1">isinstance(pad_value</span><span class="s0">, </span><span class="s1">Sequence)</span>
        <span class="s0">and </span><span class="s1">len(pad_value) == </span><span class="s5">2</span>
        <span class="s0">and </span><span class="s1">all(isinstance(pw</span><span class="s0">, </span><span class="s1">Number) </span><span class="s0">for </span><span class="s1">pw </span><span class="s0">in </span><span class="s1">pad_value)</span>
    <span class="s1">):</span>
        <span class="s1">pad_value = array.ndim * (tuple(pad_value)</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">(</span>
        <span class="s1">isinstance(pad_value</span><span class="s0">, </span><span class="s1">Sequence)</span>
        <span class="s0">and </span><span class="s1">len(pad_value) == array.ndim</span>
        <span class="s0">and </span><span class="s1">all(isinstance(pw</span><span class="s0">, </span><span class="s1">Sequence) </span><span class="s0">for </span><span class="s1">pw </span><span class="s0">in </span><span class="s1">pad_value)</span>
        <span class="s0">and </span><span class="s1">all((len(pw) == </span><span class="s5">2</span><span class="s1">) </span><span class="s0">for </span><span class="s1">pw </span><span class="s0">in </span><span class="s1">pad_value)</span>
        <span class="s0">and </span><span class="s1">all(all(isinstance(w</span><span class="s0">, </span><span class="s1">Number) </span><span class="s0">for </span><span class="s1">w </span><span class="s0">in </span><span class="s1">pw) </span><span class="s0">for </span><span class="s1">pw </span><span class="s0">in </span><span class="s1">pad_value)</span>
    <span class="s1">):</span>
        <span class="s1">pad_value = tuple(tuple(pw) </span><span class="s0">for </span><span class="s1">pw </span><span class="s0">in </span><span class="s1">pad_value)</span>
    <span class="s0">elif </span><span class="s1">(</span>
        <span class="s1">isinstance(pad_value</span><span class="s0">, </span><span class="s1">Sequence)</span>
        <span class="s0">and </span><span class="s1">len(pad_value) == </span><span class="s5">1</span>
        <span class="s0">and </span><span class="s1">isinstance(pad_value[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">Sequence)</span>
        <span class="s0">and </span><span class="s1">len(pad_value[</span><span class="s5">0</span><span class="s1">]) == </span><span class="s5">2</span>
        <span class="s0">and </span><span class="s1">all(isinstance(pw</span><span class="s0">, </span><span class="s1">Number) </span><span class="s0">for </span><span class="s1">pw </span><span class="s0">in </span><span class="s1">pad_value[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s1">):</span>
        <span class="s1">pad_value = array.ndim * (tuple(pad_value[</span><span class="s5">0</span><span class="s1">])</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;`pad_value` must be composed of integral typed values.&quot;</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">pad_value</span>


<span class="s0">def </span><span class="s1">get_pad_shapes_chunks(array</span><span class="s0">, </span><span class="s1">pad_width</span><span class="s0">, </span><span class="s1">axes):</span>
    <span class="s2">&quot;&quot;&quot; 
    Helper function for finding shapes and chunks of end pads. 
    &quot;&quot;&quot;</span>

    <span class="s1">pad_shapes = [list(array.shape)</span><span class="s0">, </span><span class="s1">list(array.shape)]</span>
    <span class="s1">pad_chunks = [list(array.chunks)</span><span class="s0">, </span><span class="s1">list(array.chunks)]</span>

    <span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">axes:</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">2</span><span class="s1">):</span>
            <span class="s1">pad_shapes[i][d] = pad_width[d][i]</span>
            <span class="s1">pad_chunks[i][d] = (pad_width[d][i]</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s1">pad_shapes = [tuple(s) </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">pad_shapes]</span>
    <span class="s1">pad_chunks = [tuple(c) </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">pad_chunks]</span>

    <span class="s0">return </span><span class="s1">pad_shapes</span><span class="s0">, </span><span class="s1">pad_chunks</span>


<span class="s0">def </span><span class="s1">linear_ramp_chunk(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">num</span><span class="s0">, </span><span class="s1">dim</span><span class="s0">, </span><span class="s1">step):</span>
    <span class="s2">&quot;&quot;&quot; 
    Helper function to find the linear ramp for a chunk. 
    &quot;&quot;&quot;</span>
    <span class="s1">num1 = num + </span><span class="s5">1</span>

    <span class="s1">shape = list(start.shape)</span>
    <span class="s1">shape[dim] = num</span>
    <span class="s1">shape = tuple(shape)</span>

    <span class="s1">dtype = np.dtype(start.dtype)</span>

    <span class="s1">result = np.empty_like(start</span><span class="s0">, </span><span class="s1">shape=shape</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">np.ndindex(start.shape):</span>
        <span class="s1">j = list(i)</span>
        <span class="s1">j[dim] = slice(</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">j = tuple(j)</span>

        <span class="s1">result[j] = np.linspace(start[i]</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">num1</span><span class="s0">, </span><span class="s1">dtype=dtype)[</span><span class="s5">1</span><span class="s1">:][::step]</span>

    <span class="s0">return </span><span class="s1">result</span>


<span class="s0">def </span><span class="s1">pad_edge(array</span><span class="s0">, </span><span class="s1">pad_width</span><span class="s0">, </span><span class="s1">mode</span><span class="s0">, </span><span class="s1">**kwargs):</span>
    <span class="s2">&quot;&quot;&quot; 
    Helper function for padding edges. 
 
    Handles the cases where the only the values on the edge are needed. 
    &quot;&quot;&quot;</span>

    <span class="s1">kwargs = {k: expand_pad_value(array</span><span class="s0">, </span><span class="s1">v) </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">kwargs.items()}</span>

    <span class="s1">result = array</span>
    <span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">range(array.ndim):</span>
        <span class="s1">pad_shapes</span><span class="s0">, </span><span class="s1">pad_chunks = get_pad_shapes_chunks(result</span><span class="s0">, </span><span class="s1">pad_width</span><span class="s0">, </span><span class="s1">(d</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">pad_arrays = [result</span><span class="s0">, </span><span class="s1">result]</span>

        <span class="s0">if </span><span class="s1">mode == </span><span class="s4">&quot;constant&quot;</span><span class="s1">:</span>
            <span class="s0">from </span><span class="s1">dask.array.utils </span><span class="s0">import </span><span class="s1">asarray_safe</span>

            <span class="s1">constant_values = kwargs[</span><span class="s4">&quot;constant_values&quot;</span><span class="s1">][d]</span>
            <span class="s1">constant_values = [</span>
                <span class="s1">asarray_safe(c</span><span class="s0">, </span><span class="s1">like=meta_from_array(array)</span><span class="s0">, </span><span class="s1">dtype=result.dtype)</span>
                <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">constant_values</span>
            <span class="s1">]</span>

            <span class="s1">pad_arrays = [</span>
                <span class="s1">broadcast_to(v</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">c)</span>
                <span class="s0">for </span><span class="s1">v</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">c </span><span class="s0">in </span><span class="s1">zip(constant_values</span><span class="s0">, </span><span class="s1">pad_shapes</span><span class="s0">, </span><span class="s1">pad_chunks)</span>
            <span class="s1">]</span>
        <span class="s0">elif </span><span class="s1">mode </span><span class="s0">in </span><span class="s1">[</span><span class="s4">&quot;edge&quot;</span><span class="s0">, </span><span class="s4">&quot;linear_ramp&quot;</span><span class="s1">]:</span>
            <span class="s1">pad_slices = [result.ndim * [slice(</span><span class="s0">None</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">result.ndim * [slice(</span><span class="s0">None</span><span class="s1">)]]</span>
            <span class="s1">pad_slices[</span><span class="s5">0</span><span class="s1">][d] = slice(</span><span class="s0">None, </span><span class="s5">1</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s1">pad_slices[</span><span class="s5">1</span><span class="s1">][d] = slice(-</span><span class="s5">1</span><span class="s0">, None, None</span><span class="s1">)</span>
            <span class="s1">pad_slices = [tuple(sl) </span><span class="s0">for </span><span class="s1">sl </span><span class="s0">in </span><span class="s1">pad_slices]</span>

            <span class="s1">pad_arrays = [result[sl] </span><span class="s0">for </span><span class="s1">sl </span><span class="s0">in </span><span class="s1">pad_slices]</span>

            <span class="s0">if </span><span class="s1">mode == </span><span class="s4">&quot;edge&quot;</span><span class="s1">:</span>
                <span class="s1">pad_arrays = [</span>
                    <span class="s1">broadcast_to(a</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">c)</span>
                    <span class="s0">for </span><span class="s1">a</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">c </span><span class="s0">in </span><span class="s1">zip(pad_arrays</span><span class="s0">, </span><span class="s1">pad_shapes</span><span class="s0">, </span><span class="s1">pad_chunks)</span>
                <span class="s1">]</span>
            <span class="s0">elif </span><span class="s1">mode == </span><span class="s4">&quot;linear_ramp&quot;</span><span class="s1">:</span>
                <span class="s1">end_values = kwargs[</span><span class="s4">&quot;end_values&quot;</span><span class="s1">][d]</span>

                <span class="s1">pad_arrays = [</span>
                    <span class="s1">a.map_blocks(</span>
                        <span class="s1">linear_ramp_chunk</span><span class="s0">,</span>
                        <span class="s1">ev</span><span class="s0">,</span>
                        <span class="s1">pw</span><span class="s0">,</span>
                        <span class="s1">chunks=c</span><span class="s0">,</span>
                        <span class="s1">dtype=result.dtype</span><span class="s0">,</span>
                        <span class="s1">dim=d</span><span class="s0">,</span>
                        <span class="s1">step=(</span><span class="s5">2 </span><span class="s1">* i - </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">)</span>
                    <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">(a</span><span class="s0">, </span><span class="s1">ev</span><span class="s0">, </span><span class="s1">pw</span><span class="s0">, </span><span class="s1">c) </span><span class="s0">in </span><span class="s1">enumerate(</span>
                        <span class="s1">zip(pad_arrays</span><span class="s0">, </span><span class="s1">end_values</span><span class="s0">, </span><span class="s1">pad_width[d]</span><span class="s0">, </span><span class="s1">pad_chunks)</span>
                    <span class="s1">)</span>
                <span class="s1">]</span>
        <span class="s0">elif </span><span class="s1">mode == </span><span class="s4">&quot;empty&quot;</span><span class="s1">:</span>
            <span class="s1">pad_arrays = [</span>
                <span class="s1">empty_like(array</span><span class="s0">, </span><span class="s1">shape=s</span><span class="s0">, </span><span class="s1">dtype=array.dtype</span><span class="s0">, </span><span class="s1">chunks=c)</span>
                <span class="s0">for </span><span class="s1">s</span><span class="s0">, </span><span class="s1">c </span><span class="s0">in </span><span class="s1">zip(pad_shapes</span><span class="s0">, </span><span class="s1">pad_chunks)</span>
            <span class="s1">]</span>

        <span class="s1">result = concatenate([pad_arrays[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">result</span><span class="s0">, </span><span class="s1">pad_arrays[</span><span class="s5">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">axis=d)</span>

    <span class="s0">return </span><span class="s1">result</span>


<span class="s0">def </span><span class="s1">pad_reuse(array</span><span class="s0">, </span><span class="s1">pad_width</span><span class="s0">, </span><span class="s1">mode</span><span class="s0">, </span><span class="s1">**kwargs):</span>
    <span class="s2">&quot;&quot;&quot; 
    Helper function for padding boundaries with values in the array. 
 
    Handles the cases where the padding is constructed from values in 
    the array. Namely by reflecting them or tiling them to create periodic 
    boundary constraints. 
    &quot;&quot;&quot;</span>

    <span class="s0">if </span><span class="s1">mode </span><span class="s0">in </span><span class="s1">{</span><span class="s4">&quot;reflect&quot;</span><span class="s0">, </span><span class="s4">&quot;symmetric&quot;</span><span class="s1">}:</span>
        <span class="s1">reflect_type = kwargs.get(</span><span class="s4">&quot;reflect&quot;</span><span class="s0">, </span><span class="s4">&quot;even&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">reflect_type == </span><span class="s4">&quot;odd&quot;</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;`pad` does not support `reflect_type` of `odd`.&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">reflect_type != </span><span class="s4">&quot;even&quot;</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;unsupported value for reflect_type, must be one of (`even`, `odd`)&quot;</span>
            <span class="s1">)</span>

    <span class="s1">result = np.empty(array.ndim * (</span><span class="s5">3</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=object)</span>
    <span class="s0">for </span><span class="s1">idx </span><span class="s0">in </span><span class="s1">np.ndindex(result.shape):</span>
        <span class="s1">select = []</span>
        <span class="s1">orient = []</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">pw </span><span class="s0">in </span><span class="s1">zip(idx</span><span class="s0">, </span><span class="s1">array.shape</span><span class="s0">, </span><span class="s1">pad_width):</span>
            <span class="s0">if </span><span class="s1">mode == </span><span class="s4">&quot;wrap&quot;</span><span class="s1">:</span>
                <span class="s1">pw = pw[::-</span><span class="s5">1</span><span class="s1">]</span>

            <span class="s0">if </span><span class="s1">i &lt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">mode == </span><span class="s4">&quot;reflect&quot;</span><span class="s1">:</span>
                    <span class="s1">select.append(slice(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">pw[</span><span class="s5">0</span><span class="s1">] + </span><span class="s5">1</span><span class="s0">, None</span><span class="s1">))</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">select.append(slice(</span><span class="s0">None, </span><span class="s1">pw[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, None</span><span class="s1">))</span>
            <span class="s0">elif </span><span class="s1">i &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">mode == </span><span class="s4">&quot;reflect&quot;</span><span class="s1">:</span>
                    <span class="s1">select.append(slice(s - pw[</span><span class="s5">1</span><span class="s1">] - </span><span class="s5">1</span><span class="s0">, </span><span class="s1">s - </span><span class="s5">1</span><span class="s0">, None</span><span class="s1">))</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">select.append(slice(s - pw[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, None, None</span><span class="s1">))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">select.append(slice(</span><span class="s0">None</span><span class="s1">))</span>

            <span class="s0">if </span><span class="s1">i != </span><span class="s5">1 </span><span class="s0">and </span><span class="s1">mode </span><span class="s0">in </span><span class="s1">[</span><span class="s4">&quot;reflect&quot;</span><span class="s0">, </span><span class="s4">&quot;symmetric&quot;</span><span class="s1">]:</span>
                <span class="s1">orient.append(slice(</span><span class="s0">None, None, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">orient.append(slice(</span><span class="s0">None</span><span class="s1">))</span>

        <span class="s1">select = tuple(select)</span>
        <span class="s1">orient = tuple(orient)</span>

        <span class="s0">if </span><span class="s1">mode == </span><span class="s4">&quot;wrap&quot;</span><span class="s1">:</span>
            <span class="s1">idx = tuple(</span><span class="s5">2 </span><span class="s1">- i </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">idx)</span>

        <span class="s1">result[idx] = array[select][orient]</span>

    <span class="s1">result = block(result.tolist())</span>

    <span class="s0">return </span><span class="s1">result</span>


<span class="s0">def </span><span class="s1">pad_stats(array</span><span class="s0">, </span><span class="s1">pad_width</span><span class="s0">, </span><span class="s1">mode</span><span class="s0">, </span><span class="s1">stat_length):</span>
    <span class="s2">&quot;&quot;&quot; 
    Helper function for padding boundaries with statistics from the array. 
 
    In cases where the padding requires computations of statistics from part 
    or all of the array, this function helps compute those statistics as 
    requested and then adds those statistics onto the boundaries of the array. 
    &quot;&quot;&quot;</span>

    <span class="s0">if </span><span class="s1">mode == </span><span class="s4">&quot;median&quot;</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;`pad` does not support `mode` of `median`.&quot;</span><span class="s1">)</span>

    <span class="s1">stat_length = expand_pad_value(array</span><span class="s0">, </span><span class="s1">stat_length)</span>

    <span class="s1">result = np.empty(array.ndim * (</span><span class="s5">3</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=object)</span>
    <span class="s0">for </span><span class="s1">idx </span><span class="s0">in </span><span class="s1">np.ndindex(result.shape):</span>
        <span class="s1">axes = []</span>
        <span class="s1">select = []</span>
        <span class="s1">pad_shape = []</span>
        <span class="s1">pad_chunks = []</span>
        <span class="s0">for </span><span class="s1">d</span><span class="s0">, </span><span class="s1">(i</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">w</span><span class="s0">, </span><span class="s1">l) </span><span class="s0">in </span><span class="s1">enumerate(</span>
            <span class="s1">zip(idx</span><span class="s0">, </span><span class="s1">array.shape</span><span class="s0">, </span><span class="s1">array.chunks</span><span class="s0">, </span><span class="s1">pad_width</span><span class="s0">, </span><span class="s1">stat_length)</span>
        <span class="s1">):</span>
            <span class="s0">if </span><span class="s1">i &lt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">axes.append(d)</span>
                <span class="s1">select.append(slice(</span><span class="s0">None, </span><span class="s1">l[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, None</span><span class="s1">))</span>
                <span class="s1">pad_shape.append(w[</span><span class="s5">0</span><span class="s1">])</span>
                <span class="s1">pad_chunks.append(w[</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s0">elif </span><span class="s1">i &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">axes.append(d)</span>
                <span class="s1">select.append(slice(s - l[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, None, None</span><span class="s1">))</span>
                <span class="s1">pad_shape.append(w[</span><span class="s5">1</span><span class="s1">])</span>
                <span class="s1">pad_chunks.append(w[</span><span class="s5">1</span><span class="s1">])</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">select.append(slice(</span><span class="s0">None</span><span class="s1">))</span>
                <span class="s1">pad_shape.append(s)</span>
                <span class="s1">pad_chunks.append(c)</span>

        <span class="s1">axes = tuple(axes)</span>
        <span class="s1">select = tuple(select)</span>
        <span class="s1">pad_shape = tuple(pad_shape)</span>
        <span class="s1">pad_chunks = tuple(pad_chunks)</span>

        <span class="s1">result_idx = array[select]</span>
        <span class="s0">if </span><span class="s1">axes:</span>
            <span class="s0">if </span><span class="s1">mode == </span><span class="s4">&quot;maximum&quot;</span><span class="s1">:</span>
                <span class="s1">result_idx = result_idx.max(axis=axes</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s0">elif </span><span class="s1">mode == </span><span class="s4">&quot;mean&quot;</span><span class="s1">:</span>
                <span class="s1">result_idx = result_idx.mean(axis=axes</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s0">elif </span><span class="s1">mode == </span><span class="s4">&quot;minimum&quot;</span><span class="s1">:</span>
                <span class="s1">result_idx = result_idx.min(axis=axes</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">)</span>

            <span class="s1">result_idx = broadcast_to(result_idx</span><span class="s0">, </span><span class="s1">pad_shape</span><span class="s0">, </span><span class="s1">chunks=pad_chunks)</span>

            <span class="s0">if </span><span class="s1">mode == </span><span class="s4">&quot;mean&quot;</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">np.issubdtype(array.dtype</span><span class="s0">, </span><span class="s1">np.integer):</span>
                    <span class="s1">result_idx = rint(result_idx)</span>
                <span class="s1">result_idx = result_idx.astype(array.dtype)</span>

        <span class="s1">result[idx] = result_idx</span>

    <span class="s1">result = block(result.tolist())</span>

    <span class="s0">return </span><span class="s1">result</span>


<span class="s0">def </span><span class="s1">wrapped_pad_func(array</span><span class="s0">, </span><span class="s1">pad_func</span><span class="s0">, </span><span class="s1">iaxis_pad_width</span><span class="s0">, </span><span class="s1">iaxis</span><span class="s0">, </span><span class="s1">pad_func_kwargs):</span>
    <span class="s1">result = np.empty_like(array)</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">np.ndindex(array.shape[:iaxis] + array.shape[iaxis + </span><span class="s5">1 </span><span class="s1">:]):</span>
        <span class="s1">i = i[:iaxis] + (slice(</span><span class="s0">None</span><span class="s1">)</span><span class="s0">,</span><span class="s1">) + i[iaxis:]</span>
        <span class="s1">result[i] = pad_func(array[i]</span><span class="s0">, </span><span class="s1">iaxis_pad_width</span><span class="s0">, </span><span class="s1">iaxis</span><span class="s0">, </span><span class="s1">pad_func_kwargs)</span>

    <span class="s0">return </span><span class="s1">result</span>


<span class="s0">def </span><span class="s1">pad_udf(array</span><span class="s0">, </span><span class="s1">pad_width</span><span class="s0">, </span><span class="s1">mode</span><span class="s0">, </span><span class="s1">**kwargs):</span>
    <span class="s2">&quot;&quot;&quot; 
    Helper function for padding boundaries with a user defined function. 
 
    In cases where the padding requires a custom user defined function be 
    applied to the array, this function assists in the prepping and 
    application of this function to the Dask Array to construct the desired 
    boundaries. 
    &quot;&quot;&quot;</span>

    <span class="s1">result = pad_edge(array</span><span class="s0">, </span><span class="s1">pad_width</span><span class="s0">, </span><span class="s4">&quot;constant&quot;</span><span class="s0">, </span><span class="s1">constant_values=</span><span class="s5">0</span><span class="s1">)</span>

    <span class="s1">chunks = result.chunks</span>
    <span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">range(result.ndim):</span>
        <span class="s1">result = result.rechunk(</span>
            <span class="s1">chunks[:d] + (result.shape[d : d + </span><span class="s5">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">) + chunks[d + </span><span class="s5">1 </span><span class="s1">:]</span>
        <span class="s1">)</span>

        <span class="s1">result = result.map_blocks(</span>
            <span class="s1">wrapped_pad_func</span><span class="s0">,</span>
            <span class="s1">name=</span><span class="s4">&quot;pad&quot;</span><span class="s0">,</span>
            <span class="s1">dtype=result.dtype</span><span class="s0">,</span>
            <span class="s1">pad_func=mode</span><span class="s0">,</span>
            <span class="s1">iaxis_pad_width=pad_width[d]</span><span class="s0">,</span>
            <span class="s1">iaxis=d</span><span class="s0">,</span>
            <span class="s1">pad_func_kwargs=kwargs</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">result = result.rechunk(chunks)</span>

    <span class="s0">return </span><span class="s1">result</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">pad(array</span><span class="s0">, </span><span class="s1">pad_width</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">&quot;constant&quot;</span><span class="s0">, </span><span class="s1">**kwargs):</span>
    <span class="s1">array = asarray(array)</span>

    <span class="s1">pad_width = expand_pad_value(array</span><span class="s0">, </span><span class="s1">pad_width)</span>

    <span class="s0">if </span><span class="s1">callable(mode):</span>
        <span class="s0">return </span><span class="s1">pad_udf(array</span><span class="s0">, </span><span class="s1">pad_width</span><span class="s0">, </span><span class="s1">mode</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s3"># Make sure that no unsupported keywords were passed for the current mode</span>
    <span class="s1">allowed_kwargs = {</span>
        <span class="s4">&quot;empty&quot;</span><span class="s1">: []</span><span class="s0">,</span>
        <span class="s4">&quot;edge&quot;</span><span class="s1">: []</span><span class="s0">,</span>
        <span class="s4">&quot;wrap&quot;</span><span class="s1">: []</span><span class="s0">,</span>
        <span class="s4">&quot;constant&quot;</span><span class="s1">: [</span><span class="s4">&quot;constant_values&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s4">&quot;linear_ramp&quot;</span><span class="s1">: [</span><span class="s4">&quot;end_values&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s4">&quot;maximum&quot;</span><span class="s1">: [</span><span class="s4">&quot;stat_length&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s4">&quot;mean&quot;</span><span class="s1">: [</span><span class="s4">&quot;stat_length&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s4">&quot;median&quot;</span><span class="s1">: [</span><span class="s4">&quot;stat_length&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s4">&quot;minimum&quot;</span><span class="s1">: [</span><span class="s4">&quot;stat_length&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s4">&quot;reflect&quot;</span><span class="s1">: [</span><span class="s4">&quot;reflect_type&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s4">&quot;symmetric&quot;</span><span class="s1">: [</span><span class="s4">&quot;reflect_type&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">}</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">unsupported_kwargs = set(kwargs) - set(allowed_kwargs[mode])</span>
    <span class="s0">except </span><span class="s1">KeyError </span><span class="s0">as </span><span class="s1">e:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;mode '</span><span class="s0">{</span><span class="s1">mode</span><span class="s0">}</span><span class="s4">' is not supported&quot;</span><span class="s1">) </span><span class="s0">from </span><span class="s1">e</span>
    <span class="s0">if </span><span class="s1">unsupported_kwargs:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span>
            <span class="s4">&quot;unsupported keyword arguments for mode '{}': {}&quot;</span><span class="s1">.format(</span>
                <span class="s1">mode</span><span class="s0">, </span><span class="s1">unsupported_kwargs</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">mode </span><span class="s0">in </span><span class="s1">{</span><span class="s4">&quot;maximum&quot;</span><span class="s0">, </span><span class="s4">&quot;mean&quot;</span><span class="s0">, </span><span class="s4">&quot;median&quot;</span><span class="s0">, </span><span class="s4">&quot;minimum&quot;</span><span class="s1">}:</span>
        <span class="s1">stat_length = kwargs.get(</span><span class="s4">&quot;stat_length&quot;</span><span class="s0">, </span><span class="s1">tuple((n</span><span class="s0">, </span><span class="s1">n) </span><span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">array.shape))</span>
        <span class="s0">return </span><span class="s1">pad_stats(array</span><span class="s0">, </span><span class="s1">pad_width</span><span class="s0">, </span><span class="s1">mode</span><span class="s0">, </span><span class="s1">stat_length)</span>
    <span class="s0">elif </span><span class="s1">mode == </span><span class="s4">&quot;constant&quot;</span><span class="s1">:</span>
        <span class="s1">kwargs.setdefault(</span><span class="s4">&quot;constant_values&quot;</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">pad_edge(array</span><span class="s0">, </span><span class="s1">pad_width</span><span class="s0">, </span><span class="s1">mode</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">elif </span><span class="s1">mode == </span><span class="s4">&quot;linear_ramp&quot;</span><span class="s1">:</span>
        <span class="s1">kwargs.setdefault(</span><span class="s4">&quot;end_values&quot;</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">pad_edge(array</span><span class="s0">, </span><span class="s1">pad_width</span><span class="s0">, </span><span class="s1">mode</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">elif </span><span class="s1">mode </span><span class="s0">in </span><span class="s1">{</span><span class="s4">&quot;edge&quot;</span><span class="s0">, </span><span class="s4">&quot;empty&quot;</span><span class="s1">}:</span>
        <span class="s0">return </span><span class="s1">pad_edge(array</span><span class="s0">, </span><span class="s1">pad_width</span><span class="s0">, </span><span class="s1">mode)</span>
    <span class="s0">elif </span><span class="s1">mode </span><span class="s0">in </span><span class="s1">[</span><span class="s4">&quot;reflect&quot;</span><span class="s0">, </span><span class="s4">&quot;symmetric&quot;</span><span class="s0">, </span><span class="s4">&quot;wrap&quot;</span><span class="s1">]:</span>
        <span class="s0">return </span><span class="s1">pad_reuse(array</span><span class="s0">, </span><span class="s1">pad_width</span><span class="s0">, </span><span class="s1">mode</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">raise </span><span class="s1">RuntimeError(</span><span class="s4">&quot;unreachable&quot;</span><span class="s1">)</span>
</pre>
</body>
</html>