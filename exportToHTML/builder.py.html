<html>
<head>
<title>builder.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
builder.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
colorLib.builder: Build COLR/CPAL tables from scratch 
 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">collections</span>
<span class="s2">import </span><span class="s1">copy</span>
<span class="s2">import </span><span class="s1">enum</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">partial</span>
<span class="s2">from </span><span class="s1">math </span><span class="s2">import </span><span class="s1">ceil</span><span class="s2">, </span><span class="s1">log</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">Dict</span><span class="s2">,</span>
    <span class="s1">Generator</span><span class="s2">,</span>
    <span class="s1">Iterable</span><span class="s2">,</span>
    <span class="s1">List</span><span class="s2">,</span>
    <span class="s1">Mapping</span><span class="s2">,</span>
    <span class="s1">Optional</span><span class="s2">,</span>
    <span class="s1">Sequence</span><span class="s2">,</span>
    <span class="s1">Tuple</span><span class="s2">,</span>
    <span class="s1">Type</span><span class="s2">,</span>
    <span class="s1">TypeVar</span><span class="s2">,</span>
    <span class="s1">Union</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">fontTools.misc.arrayTools </span><span class="s2">import </span><span class="s1">intRect</span>
<span class="s2">from </span><span class="s1">fontTools.misc.fixedTools </span><span class="s2">import </span><span class="s1">fixedToFloat</span>
<span class="s2">from </span><span class="s1">fontTools.misc.treeTools </span><span class="s2">import </span><span class="s1">build_n_ary_tree</span>
<span class="s2">from </span><span class="s1">fontTools.ttLib.tables </span><span class="s2">import </span><span class="s1">C_O_L_R_</span>
<span class="s2">from </span><span class="s1">fontTools.ttLib.tables </span><span class="s2">import </span><span class="s1">C_P_A_L_</span>
<span class="s2">from </span><span class="s1">fontTools.ttLib.tables </span><span class="s2">import </span><span class="s1">_n_a_m_e</span>
<span class="s2">from </span><span class="s1">fontTools.ttLib.tables </span><span class="s2">import </span><span class="s1">otTables </span><span class="s2">as </span><span class="s1">ot</span>
<span class="s2">from </span><span class="s1">fontTools.ttLib.tables.otTables </span><span class="s2">import </span><span class="s1">ExtendMode</span><span class="s2">, </span><span class="s1">CompositeMode</span>
<span class="s2">from </span><span class="s1">.errors </span><span class="s2">import </span><span class="s1">ColorLibError</span>
<span class="s2">from </span><span class="s1">.geometry </span><span class="s2">import </span><span class="s1">round_start_circle_stable_containment</span>
<span class="s2">from </span><span class="s1">.table_builder </span><span class="s2">import </span><span class="s1">BuildCallback</span><span class="s2">, </span><span class="s1">TableBuilder</span>


<span class="s3"># TODO move type aliases to colorLib.types?</span>
<span class="s1">T = TypeVar(</span><span class="s4">&quot;T&quot;</span><span class="s1">)</span>
<span class="s1">_Kwargs = Mapping[str</span><span class="s2">, </span><span class="s1">Any]</span>
<span class="s1">_PaintInput = Union[int</span><span class="s2">, </span><span class="s1">_Kwargs</span><span class="s2">, </span><span class="s1">ot.Paint</span><span class="s2">, </span><span class="s1">Tuple[str</span><span class="s2">, </span><span class="s4">&quot;_PaintInput&quot;</span><span class="s1">]]</span>
<span class="s1">_PaintInputList = Sequence[_PaintInput]</span>
<span class="s1">_ColorGlyphsDict = Dict[str</span><span class="s2">, </span><span class="s1">Union[_PaintInputList</span><span class="s2">, </span><span class="s1">_PaintInput]]</span>
<span class="s1">_ColorGlyphsV0Dict = Dict[str</span><span class="s2">, </span><span class="s1">Sequence[Tuple[str</span><span class="s2">, </span><span class="s1">int]]]</span>
<span class="s1">_ClipBoxInput = Union[</span>
    <span class="s1">Tuple[int</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">int]</span><span class="s2">,  </span><span class="s3"># format 1, variable</span>
    <span class="s1">Tuple[int</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">int]</span><span class="s2">,  </span><span class="s3"># format 0, non-variable</span>
    <span class="s1">ot.ClipBox</span><span class="s2">,</span>
<span class="s1">]</span>


<span class="s1">MAX_PAINT_COLR_LAYER_COUNT = </span><span class="s5">255</span>
<span class="s1">_DEFAULT_ALPHA = </span><span class="s5">1.0</span>
<span class="s1">_MAX_REUSE_LEN = </span><span class="s5">32</span>


<span class="s2">def </span><span class="s1">_beforeBuildPaintRadialGradient(paint</span><span class="s2">, </span><span class="s1">source):</span>
    <span class="s1">x0 = source[</span><span class="s4">&quot;x0&quot;</span><span class="s1">]</span>
    <span class="s1">y0 = source[</span><span class="s4">&quot;y0&quot;</span><span class="s1">]</span>
    <span class="s1">r0 = source[</span><span class="s4">&quot;r0&quot;</span><span class="s1">]</span>
    <span class="s1">x1 = source[</span><span class="s4">&quot;x1&quot;</span><span class="s1">]</span>
    <span class="s1">y1 = source[</span><span class="s4">&quot;y1&quot;</span><span class="s1">]</span>
    <span class="s1">r1 = source[</span><span class="s4">&quot;r1&quot;</span><span class="s1">]</span>

    <span class="s3"># TODO apparently no builder_test confirms this works (?)</span>

    <span class="s3"># avoid abrupt change after rounding when c0 is near c1's perimeter</span>
    <span class="s1">c = round_start_circle_stable_containment((x0</span><span class="s2">, </span><span class="s1">y0)</span><span class="s2">, </span><span class="s1">r0</span><span class="s2">, </span><span class="s1">(x1</span><span class="s2">, </span><span class="s1">y1)</span><span class="s2">, </span><span class="s1">r1)</span>
    <span class="s1">x0</span><span class="s2">, </span><span class="s1">y0 = c.centre</span>
    <span class="s1">r0 = c.radius</span>

    <span class="s3"># update source to ensure paint is built with corrected values</span>
    <span class="s1">source[</span><span class="s4">&quot;x0&quot;</span><span class="s1">] = x0</span>
    <span class="s1">source[</span><span class="s4">&quot;y0&quot;</span><span class="s1">] = y0</span>
    <span class="s1">source[</span><span class="s4">&quot;r0&quot;</span><span class="s1">] = r0</span>
    <span class="s1">source[</span><span class="s4">&quot;x1&quot;</span><span class="s1">] = x1</span>
    <span class="s1">source[</span><span class="s4">&quot;y1&quot;</span><span class="s1">] = y1</span>
    <span class="s1">source[</span><span class="s4">&quot;r1&quot;</span><span class="s1">] = r1</span>

    <span class="s2">return </span><span class="s1">paint</span><span class="s2">, </span><span class="s1">source</span>


<span class="s2">def </span><span class="s1">_defaultColorStop():</span>
    <span class="s1">colorStop = ot.ColorStop()</span>
    <span class="s1">colorStop.Alpha = _DEFAULT_ALPHA</span>
    <span class="s2">return </span><span class="s1">colorStop</span>


<span class="s2">def </span><span class="s1">_defaultVarColorStop():</span>
    <span class="s1">colorStop = ot.VarColorStop()</span>
    <span class="s1">colorStop.Alpha = _DEFAULT_ALPHA</span>
    <span class="s2">return </span><span class="s1">colorStop</span>


<span class="s2">def </span><span class="s1">_defaultColorLine():</span>
    <span class="s1">colorLine = ot.ColorLine()</span>
    <span class="s1">colorLine.Extend = ExtendMode.PAD</span>
    <span class="s2">return </span><span class="s1">colorLine</span>


<span class="s2">def </span><span class="s1">_defaultVarColorLine():</span>
    <span class="s1">colorLine = ot.VarColorLine()</span>
    <span class="s1">colorLine.Extend = ExtendMode.PAD</span>
    <span class="s2">return </span><span class="s1">colorLine</span>


<span class="s2">def </span><span class="s1">_defaultPaintSolid():</span>
    <span class="s1">paint = ot.Paint()</span>
    <span class="s1">paint.Alpha = _DEFAULT_ALPHA</span>
    <span class="s2">return </span><span class="s1">paint</span>


<span class="s2">def </span><span class="s1">_buildPaintCallbacks():</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">(</span>
            <span class="s1">BuildCallback.BEFORE_BUILD</span><span class="s2">,</span>
            <span class="s1">ot.Paint</span><span class="s2">,</span>
            <span class="s1">ot.PaintFormat.PaintRadialGradient</span><span class="s2">,</span>
        <span class="s1">): _beforeBuildPaintRadialGradient</span><span class="s2">,</span>
        <span class="s1">(</span>
            <span class="s1">BuildCallback.BEFORE_BUILD</span><span class="s2">,</span>
            <span class="s1">ot.Paint</span><span class="s2">,</span>
            <span class="s1">ot.PaintFormat.PaintVarRadialGradient</span><span class="s2">,</span>
        <span class="s1">): _beforeBuildPaintRadialGradient</span><span class="s2">,</span>
        <span class="s1">(BuildCallback.CREATE_DEFAULT</span><span class="s2">, </span><span class="s1">ot.ColorStop): _defaultColorStop</span><span class="s2">,</span>
        <span class="s1">(BuildCallback.CREATE_DEFAULT</span><span class="s2">, </span><span class="s1">ot.VarColorStop): _defaultVarColorStop</span><span class="s2">,</span>
        <span class="s1">(BuildCallback.CREATE_DEFAULT</span><span class="s2">, </span><span class="s1">ot.ColorLine): _defaultColorLine</span><span class="s2">,</span>
        <span class="s1">(BuildCallback.CREATE_DEFAULT</span><span class="s2">, </span><span class="s1">ot.VarColorLine): _defaultVarColorLine</span><span class="s2">,</span>
        <span class="s1">(</span>
            <span class="s1">BuildCallback.CREATE_DEFAULT</span><span class="s2">,</span>
            <span class="s1">ot.Paint</span><span class="s2">,</span>
            <span class="s1">ot.PaintFormat.PaintSolid</span><span class="s2">,</span>
        <span class="s1">): _defaultPaintSolid</span><span class="s2">,</span>
        <span class="s1">(</span>
            <span class="s1">BuildCallback.CREATE_DEFAULT</span><span class="s2">,</span>
            <span class="s1">ot.Paint</span><span class="s2">,</span>
            <span class="s1">ot.PaintFormat.PaintVarSolid</span><span class="s2">,</span>
        <span class="s1">): _defaultPaintSolid</span><span class="s2">,</span>
    <span class="s1">}</span>


<span class="s2">def </span><span class="s1">populateCOLRv0(</span>
    <span class="s1">table: ot.COLR</span><span class="s2">,</span>
    <span class="s1">colorGlyphsV0: _ColorGlyphsV0Dict</span><span class="s2">,</span>
    <span class="s1">glyphMap: Optional[Mapping[str</span><span class="s2">, </span><span class="s1">int]] = </span><span class="s2">None,</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Build v0 color layers and add to existing COLR table. 
 
    Args: 
        table: a raw ``otTables.COLR()`` object (not ttLib's ``table_C_O_L_R_``). 
        colorGlyphsV0: map of base glyph names to lists of (layer glyph names, 
            color palette index) tuples. Can be empty. 
        glyphMap: a map from glyph names to glyph indices, as returned from 
            ``TTFont.getReverseGlyphMap()``, to optionally sort base records by GID. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">glyphMap </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">colorGlyphItems = sorted(</span>
            <span class="s1">colorGlyphsV0.items()</span><span class="s2">, </span><span class="s1">key=</span><span class="s2">lambda </span><span class="s1">item: glyphMap[item[</span><span class="s5">0</span><span class="s1">]]</span>
        <span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">colorGlyphItems = colorGlyphsV0.items()</span>
    <span class="s1">baseGlyphRecords = []</span>
    <span class="s1">layerRecords = []</span>
    <span class="s2">for </span><span class="s1">baseGlyph</span><span class="s2">, </span><span class="s1">layers </span><span class="s2">in </span><span class="s1">colorGlyphItems:</span>
        <span class="s1">baseRec = ot.BaseGlyphRecord()</span>
        <span class="s1">baseRec.BaseGlyph = baseGlyph</span>
        <span class="s1">baseRec.FirstLayerIndex = len(layerRecords)</span>
        <span class="s1">baseRec.NumLayers = len(layers)</span>
        <span class="s1">baseGlyphRecords.append(baseRec)</span>

        <span class="s2">for </span><span class="s1">layerGlyph</span><span class="s2">, </span><span class="s1">paletteIndex </span><span class="s2">in </span><span class="s1">layers:</span>
            <span class="s1">layerRec = ot.LayerRecord()</span>
            <span class="s1">layerRec.LayerGlyph = layerGlyph</span>
            <span class="s1">layerRec.PaletteIndex = paletteIndex</span>
            <span class="s1">layerRecords.append(layerRec)</span>

    <span class="s1">table.BaseGlyphRecordArray = table.LayerRecordArray = </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">baseGlyphRecords:</span>
        <span class="s1">table.BaseGlyphRecordArray = ot.BaseGlyphRecordArray()</span>
        <span class="s1">table.BaseGlyphRecordArray.BaseGlyphRecord = baseGlyphRecords</span>
    <span class="s2">if </span><span class="s1">layerRecords:</span>
        <span class="s1">table.LayerRecordArray = ot.LayerRecordArray()</span>
        <span class="s1">table.LayerRecordArray.LayerRecord = layerRecords</span>
    <span class="s1">table.BaseGlyphRecordCount = len(baseGlyphRecords)</span>
    <span class="s1">table.LayerRecordCount = len(layerRecords)</span>


<span class="s2">def </span><span class="s1">buildCOLR(</span>
    <span class="s1">colorGlyphs: _ColorGlyphsDict</span><span class="s2">,</span>
    <span class="s1">version: Optional[int] = </span><span class="s2">None,</span>
    <span class="s1">*</span><span class="s2">,</span>
    <span class="s1">glyphMap: Optional[Mapping[str</span><span class="s2">, </span><span class="s1">int]] = </span><span class="s2">None,</span>
    <span class="s1">varStore: Optional[ot.VarStore] = </span><span class="s2">None,</span>
    <span class="s1">varIndexMap: Optional[ot.DeltaSetIndexMap] = </span><span class="s2">None,</span>
    <span class="s1">clipBoxes: Optional[Dict[str</span><span class="s2">, </span><span class="s1">_ClipBoxInput]] = </span><span class="s2">None,</span>
    <span class="s1">allowLayerReuse: bool = </span><span class="s2">True,</span>
<span class="s1">) -&gt; C_O_L_R_.table_C_O_L_R_:</span>
    <span class="s0">&quot;&quot;&quot;Build COLR table from color layers mapping. 
 
    Args: 
 
        colorGlyphs: map of base glyph name to, either list of (layer glyph name, 
            color palette index) tuples for COLRv0; or a single ``Paint`` (dict) or 
            list of ``Paint`` for COLRv1. 
        version: the version of COLR table. If None, the version is determined 
            by the presence of COLRv1 paints or variation data (varStore), which 
            require version 1; otherwise, if all base glyphs use only simple color 
            layers, version 0 is used. 
        glyphMap: a map from glyph names to glyph indices, as returned from 
            TTFont.getReverseGlyphMap(), to optionally sort base records by GID. 
        varStore: Optional ItemVarationStore for deltas associated with v1 layer. 
        varIndexMap: Optional DeltaSetIndexMap for deltas associated with v1 layer. 
        clipBoxes: Optional map of base glyph name to clip box 4- or 5-tuples: 
            (xMin, yMin, xMax, yMax) or (xMin, yMin, xMax, yMax, varIndexBase). 
 
    Returns: 
        A new COLR table. 
    &quot;&quot;&quot;</span>
    <span class="s1">self = C_O_L_R_.table_C_O_L_R_()</span>

    <span class="s2">if </span><span class="s1">varStore </span><span class="s2">is not None and </span><span class="s1">version == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Can't add VarStore to COLRv0&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">version </span><span class="s2">in </span><span class="s1">(</span><span class="s2">None, </span><span class="s5">0</span><span class="s1">) </span><span class="s2">and not </span><span class="s1">varStore:</span>
        <span class="s3"># split color glyphs into v0 and v1 and encode separately</span>
        <span class="s1">colorGlyphsV0</span><span class="s2">, </span><span class="s1">colorGlyphsV1 = _split_color_glyphs_by_version(colorGlyphs)</span>
        <span class="s2">if </span><span class="s1">version == </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">colorGlyphsV1:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Can't encode COLRv1 glyphs in COLRv0&quot;</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s3"># unless explicitly requested for v1 or have variations, in which case</span>
        <span class="s3"># we encode all color glyph as v1</span>
        <span class="s1">colorGlyphsV0</span><span class="s2">, </span><span class="s1">colorGlyphsV1 = {}</span><span class="s2">, </span><span class="s1">colorGlyphs</span>

    <span class="s1">colr = ot.COLR()</span>

    <span class="s1">populateCOLRv0(colr</span><span class="s2">, </span><span class="s1">colorGlyphsV0</span><span class="s2">, </span><span class="s1">glyphMap)</span>

    <span class="s1">colr.LayerList</span><span class="s2">, </span><span class="s1">colr.BaseGlyphList = buildColrV1(</span>
        <span class="s1">colorGlyphsV1</span><span class="s2">,</span>
        <span class="s1">glyphMap</span><span class="s2">,</span>
        <span class="s1">allowLayerReuse=allowLayerReuse</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s2">if </span><span class="s1">version </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">version = </span><span class="s5">1 </span><span class="s2">if </span><span class="s1">(varStore </span><span class="s2">or </span><span class="s1">colorGlyphsV1) </span><span class="s2">else </span><span class="s5">0</span>
    <span class="s2">elif </span><span class="s1">version </span><span class="s2">not in </span><span class="s1">(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(version)</span>
    <span class="s1">self.version = colr.Version = version</span>

    <span class="s2">if </span><span class="s1">version == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">self.ColorLayers = self._decompileColorLayersV0(colr)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">colr.ClipList = buildClipList(clipBoxes) </span><span class="s2">if </span><span class="s1">clipBoxes </span><span class="s2">else None</span>
        <span class="s1">colr.VarIndexMap = varIndexMap</span>
        <span class="s1">colr.VarStore = varStore</span>
        <span class="s1">self.table = colr</span>

    <span class="s2">return </span><span class="s1">self</span>


<span class="s2">def </span><span class="s1">buildClipList(clipBoxes: Dict[str</span><span class="s2">, </span><span class="s1">_ClipBoxInput]) -&gt; ot.ClipList:</span>
    <span class="s1">clipList = ot.ClipList()</span>
    <span class="s1">clipList.Format = </span><span class="s5">1</span>
    <span class="s1">clipList.clips = {name: buildClipBox(box) </span><span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">box </span><span class="s2">in </span><span class="s1">clipBoxes.items()}</span>
    <span class="s2">return </span><span class="s1">clipList</span>


<span class="s2">def </span><span class="s1">buildClipBox(clipBox: _ClipBoxInput) -&gt; ot.ClipBox:</span>
    <span class="s2">if </span><span class="s1">isinstance(clipBox</span><span class="s2">, </span><span class="s1">ot.ClipBox):</span>
        <span class="s2">return </span><span class="s1">clipBox</span>
    <span class="s1">n = len(clipBox)</span>
    <span class="s1">clip = ot.ClipBox()</span>
    <span class="s2">if </span><span class="s1">n </span><span class="s2">not in </span><span class="s1">(</span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Invalid ClipBox: expected 4 or 5 values, found </span><span class="s2">{</span><span class="s1">n</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>
    <span class="s1">clip.xMin</span><span class="s2">, </span><span class="s1">clip.yMin</span><span class="s2">, </span><span class="s1">clip.xMax</span><span class="s2">, </span><span class="s1">clip.yMax = intRect(clipBox[:</span><span class="s5">4</span><span class="s1">])</span>
    <span class="s1">clip.Format = int(n == </span><span class="s5">5</span><span class="s1">) + </span><span class="s5">1</span>
    <span class="s2">if </span><span class="s1">n == </span><span class="s5">5</span><span class="s1">:</span>
        <span class="s1">clip.VarIndexBase = int(clipBox[</span><span class="s5">4</span><span class="s1">])</span>
    <span class="s2">return </span><span class="s1">clip</span>


<span class="s2">class </span><span class="s1">ColorPaletteType(enum.IntFlag):</span>
    <span class="s1">USABLE_WITH_LIGHT_BACKGROUND = </span><span class="s5">0x0001</span>
    <span class="s1">USABLE_WITH_DARK_BACKGROUND = </span><span class="s5">0x0002</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_missing_(cls</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s3"># enforce reserved bits</span>
        <span class="s2">if </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">int) </span><span class="s2">and </span><span class="s1">(value &lt; </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">value &amp; </span><span class="s5">0xFFFC </span><span class="s1">!= </span><span class="s5">0</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">value</span><span class="s2">} </span><span class="s4">is not a valid </span><span class="s2">{</span><span class="s1">cls.__name__</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">super()._missing_(value)</span>


<span class="s3"># None, 'abc' or {'en': 'abc', 'de': 'xyz'}</span>
<span class="s1">_OptionalLocalizedString = Union[</span><span class="s2">None, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">Dict[str</span><span class="s2">, </span><span class="s1">str]]</span>


<span class="s2">def </span><span class="s1">buildPaletteLabels(</span>
    <span class="s1">labels: Iterable[_OptionalLocalizedString]</span><span class="s2">, </span><span class="s1">nameTable: _n_a_m_e.table__n_a_m_e</span>
<span class="s1">) -&gt; List[Optional[int]]:</span>
    <span class="s2">return </span><span class="s1">[</span>
        <span class="s1">nameTable.addMultilingualName(l</span><span class="s2">, </span><span class="s1">mac=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">isinstance(l</span><span class="s2">, </span><span class="s1">dict)</span>
        <span class="s2">else </span><span class="s1">C_P_A_L_.table_C_P_A_L_.NO_NAME_ID</span>
        <span class="s2">if </span><span class="s1">l </span><span class="s2">is None</span>
        <span class="s2">else </span><span class="s1">nameTable.addMultilingualName({</span><span class="s4">&quot;en&quot;</span><span class="s1">: l}</span><span class="s2">, </span><span class="s1">mac=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">labels</span>
    <span class="s1">]</span>


<span class="s2">def </span><span class="s1">buildCPAL(</span>
    <span class="s1">palettes: Sequence[Sequence[Tuple[float</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">float]]]</span><span class="s2">,</span>
    <span class="s1">paletteTypes: Optional[Sequence[ColorPaletteType]] = </span><span class="s2">None,</span>
    <span class="s1">paletteLabels: Optional[Sequence[_OptionalLocalizedString]] = </span><span class="s2">None,</span>
    <span class="s1">paletteEntryLabels: Optional[Sequence[_OptionalLocalizedString]] = </span><span class="s2">None,</span>
    <span class="s1">nameTable: Optional[_n_a_m_e.table__n_a_m_e] = </span><span class="s2">None,</span>
<span class="s1">) -&gt; C_P_A_L_.table_C_P_A_L_:</span>
    <span class="s0">&quot;&quot;&quot;Build CPAL table from list of color palettes. 
 
    Args: 
        palettes: list of lists of colors encoded as tuples of (R, G, B, A) floats 
            in the range [0..1]. 
        paletteTypes: optional list of ColorPaletteType, one for each palette. 
        paletteLabels: optional list of palette labels. Each lable can be either: 
            None (no label), a string (for for default English labels), or a 
            localized string (as a dict keyed with BCP47 language codes). 
        paletteEntryLabels: optional list of palette entry labels, one for each 
            palette entry (see paletteLabels). 
        nameTable: optional name table where to store palette and palette entry 
            labels. Required if either paletteLabels or paletteEntryLabels is set. 
 
    Return: 
        A new CPAL v0 or v1 table, if custom palette types or labels are specified. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">len({len(p) </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">palettes}) != </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ColorLibError(</span><span class="s4">&quot;color palettes have different lengths&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">(paletteLabels </span><span class="s2">or </span><span class="s1">paletteEntryLabels) </span><span class="s2">and not </span><span class="s1">nameTable:</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span>
            <span class="s4">&quot;nameTable is required if palette or palette entries have labels&quot;</span>
        <span class="s1">)</span>

    <span class="s1">cpal = C_P_A_L_.table_C_P_A_L_()</span>
    <span class="s1">cpal.numPaletteEntries = len(palettes[</span><span class="s5">0</span><span class="s1">])</span>

    <span class="s1">cpal.palettes = []</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">palette </span><span class="s2">in </span><span class="s1">enumerate(palettes):</span>
        <span class="s1">colors = []</span>
        <span class="s2">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">color </span><span class="s2">in </span><span class="s1">enumerate(palette):</span>
            <span class="s2">if not </span><span class="s1">isinstance(color</span><span class="s2">, </span><span class="s1">tuple) </span><span class="s2">or </span><span class="s1">len(color) != </span><span class="s5">4</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ColorLibError(</span>
                    <span class="s4">f&quot;In palette[</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">][</span><span class="s2">{</span><span class="s1">j</span><span class="s2">}</span><span class="s4">]: expected (R, G, B, A) tuple, got </span><span class="s2">{</span><span class="s1">color</span><span class="s2">!r}</span><span class="s4">&quot;</span>
                <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">any(v &gt; </span><span class="s5">1 </span><span class="s2">or </span><span class="s1">v &lt; </span><span class="s5">0 </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">color):</span>
                <span class="s2">raise </span><span class="s1">ColorLibError(</span>
                    <span class="s4">f&quot;palette[</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">][</span><span class="s2">{</span><span class="s1">j</span><span class="s2">}</span><span class="s4">] has invalid out-of-range [0..1] color: </span><span class="s2">{</span><span class="s1">color</span><span class="s2">!r}</span><span class="s4">&quot;</span>
                <span class="s1">)</span>
            <span class="s3"># input colors are RGBA, CPAL encodes them as BGRA</span>
            <span class="s1">red</span><span class="s2">, </span><span class="s1">green</span><span class="s2">, </span><span class="s1">blue</span><span class="s2">, </span><span class="s1">alpha = color</span>
            <span class="s1">colors.append(</span>
                <span class="s1">C_P_A_L_.Color(*(round(v * </span><span class="s5">255</span><span class="s1">) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">(blue</span><span class="s2">, </span><span class="s1">green</span><span class="s2">, </span><span class="s1">red</span><span class="s2">, </span><span class="s1">alpha)))</span>
            <span class="s1">)</span>
        <span class="s1">cpal.palettes.append(colors)</span>

    <span class="s2">if </span><span class="s1">any(v </span><span class="s2">is not None for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">(paletteTypes</span><span class="s2">, </span><span class="s1">paletteLabels</span><span class="s2">, </span><span class="s1">paletteEntryLabels)):</span>
        <span class="s1">cpal.version = </span><span class="s5">1</span>

        <span class="s2">if </span><span class="s1">paletteTypes </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">len(paletteTypes) != len(palettes):</span>
                <span class="s2">raise </span><span class="s1">ColorLibError(</span>
                    <span class="s4">f&quot;Expected </span><span class="s2">{</span><span class="s1">len(palettes)</span><span class="s2">} </span><span class="s4">paletteTypes, got </span><span class="s2">{</span><span class="s1">len(paletteTypes)</span><span class="s2">}</span><span class="s4">&quot;</span>
                <span class="s1">)</span>
            <span class="s1">cpal.paletteTypes = [ColorPaletteType(t).value </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">paletteTypes]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">cpal.paletteTypes = [C_P_A_L_.table_C_P_A_L_.DEFAULT_PALETTE_TYPE] * len(</span>
                <span class="s1">palettes</span>
            <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">paletteLabels </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">len(paletteLabels) != len(palettes):</span>
                <span class="s2">raise </span><span class="s1">ColorLibError(</span>
                    <span class="s4">f&quot;Expected </span><span class="s2">{</span><span class="s1">len(palettes)</span><span class="s2">} </span><span class="s4">paletteLabels, got </span><span class="s2">{</span><span class="s1">len(paletteLabels)</span><span class="s2">}</span><span class="s4">&quot;</span>
                <span class="s1">)</span>
            <span class="s1">cpal.paletteLabels = buildPaletteLabels(paletteLabels</span><span class="s2">, </span><span class="s1">nameTable)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">cpal.paletteLabels = [C_P_A_L_.table_C_P_A_L_.NO_NAME_ID] * len(palettes)</span>

        <span class="s2">if </span><span class="s1">paletteEntryLabels </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">len(paletteEntryLabels) != cpal.numPaletteEntries:</span>
                <span class="s2">raise </span><span class="s1">ColorLibError(</span>
                    <span class="s4">f&quot;Expected </span><span class="s2">{</span><span class="s1">cpal.numPaletteEntries</span><span class="s2">} </span><span class="s4">paletteEntryLabels, &quot;</span>
                    <span class="s4">f&quot;got </span><span class="s2">{</span><span class="s1">len(paletteEntryLabels)</span><span class="s2">}</span><span class="s4">&quot;</span>
                <span class="s1">)</span>
            <span class="s1">cpal.paletteEntryLabels = buildPaletteLabels(paletteEntryLabels</span><span class="s2">, </span><span class="s1">nameTable)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">cpal.paletteEntryLabels = [</span>
                <span class="s1">C_P_A_L_.table_C_P_A_L_.NO_NAME_ID</span>
            <span class="s1">] * cpal.numPaletteEntries</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">cpal.version = </span><span class="s5">0</span>

    <span class="s2">return </span><span class="s1">cpal</span>


<span class="s3"># COLR v1 tables</span>
<span class="s3"># See draft proposal at: https://github.com/googlefonts/colr-gradients-spec</span>


<span class="s2">def </span><span class="s1">_is_colrv0_layer(layer: Any) -&gt; bool:</span>
    <span class="s3"># Consider as COLRv0 layer any sequence of length 2 (be it tuple or list) in which</span>
    <span class="s3"># the first element is a str (the layerGlyph) and the second element is an int</span>
    <span class="s3"># (CPAL paletteIndex).</span>
    <span class="s3"># https://github.com/googlefonts/ufo2ft/issues/426</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">layerGlyph</span><span class="s2">, </span><span class="s1">paletteIndex = layer</span>
    <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">ValueError):</span>
        <span class="s2">return False</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">isinstance(layerGlyph</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">isinstance(paletteIndex</span><span class="s2">, </span><span class="s1">int)</span>


<span class="s2">def </span><span class="s1">_split_color_glyphs_by_version(</span>
    <span class="s1">colorGlyphs: _ColorGlyphsDict</span><span class="s2">,</span>
<span class="s1">) -&gt; Tuple[_ColorGlyphsV0Dict</span><span class="s2">, </span><span class="s1">_ColorGlyphsDict]:</span>
    <span class="s1">colorGlyphsV0 = {}</span>
    <span class="s1">colorGlyphsV1 = {}</span>
    <span class="s2">for </span><span class="s1">baseGlyph</span><span class="s2">, </span><span class="s1">layers </span><span class="s2">in </span><span class="s1">colorGlyphs.items():</span>
        <span class="s2">if </span><span class="s1">all(_is_colrv0_layer(l) </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">layers):</span>
            <span class="s1">colorGlyphsV0[baseGlyph] = layers</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">colorGlyphsV1[baseGlyph] = layers</span>

    <span class="s3"># sanity check</span>
    <span class="s2">assert </span><span class="s1">set(colorGlyphs) == (set(colorGlyphsV0) | set(colorGlyphsV1))</span>

    <span class="s2">return </span><span class="s1">colorGlyphsV0</span><span class="s2">, </span><span class="s1">colorGlyphsV1</span>


<span class="s2">def </span><span class="s1">_reuse_ranges(num_layers: int) -&gt; Generator[Tuple[int</span><span class="s2">, </span><span class="s1">int]</span><span class="s2">, None, None</span><span class="s1">]:</span>
    <span class="s3"># TODO feels like something itertools might have already</span>
    <span class="s2">for </span><span class="s1">lbound </span><span class="s2">in </span><span class="s1">range(num_layers):</span>
        <span class="s3"># Reuse of very large #s of layers is relatively unlikely</span>
        <span class="s3"># +2: we want sequences of at least 2</span>
        <span class="s3"># otData handles single-record duplication</span>
        <span class="s2">for </span><span class="s1">ubound </span><span class="s2">in </span><span class="s1">range(</span>
            <span class="s1">lbound + </span><span class="s5">2</span><span class="s2">, </span><span class="s1">min(num_layers + </span><span class="s5">1</span><span class="s2">, </span><span class="s1">lbound + </span><span class="s5">2 </span><span class="s1">+ _MAX_REUSE_LEN)</span>
        <span class="s1">):</span>
            <span class="s2">yield </span><span class="s1">(lbound</span><span class="s2">, </span><span class="s1">ubound)</span>


<span class="s2">class </span><span class="s1">LayerReuseCache:</span>
    <span class="s1">reusePool: Mapping[Tuple[Any</span><span class="s2">, </span><span class="s1">...]</span><span class="s2">, </span><span class="s1">int]</span>
    <span class="s1">tuples: Mapping[int</span><span class="s2">, </span><span class="s1">Tuple[Any</span><span class="s2">, </span><span class="s1">...]]</span>
    <span class="s1">keepAlive: List[ot.Paint]  </span><span class="s3"># we need id to remain valid</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self.reusePool = {}</span>
        <span class="s1">self.tuples = {}</span>
        <span class="s1">self.keepAlive = []</span>

    <span class="s2">def </span><span class="s1">_paint_tuple(self</span><span class="s2">, </span><span class="s1">paint: ot.Paint):</span>
        <span class="s3"># start simple, who even cares about cyclic graphs or interesting field types</span>
        <span class="s2">def </span><span class="s1">_tuple_safe(value):</span>
            <span class="s2">if </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">enum.Enum):</span>
                <span class="s2">return </span><span class="s1">value</span>
            <span class="s2">elif </span><span class="s1">hasattr(value</span><span class="s2">, </span><span class="s4">&quot;__dict__&quot;</span><span class="s1">):</span>
                <span class="s2">return </span><span class="s1">tuple(</span>
                    <span class="s1">(k</span><span class="s2">, </span><span class="s1">_tuple_safe(v)) </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">sorted(value.__dict__.items())</span>
                <span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">collections.abc.MutableSequence):</span>
                <span class="s2">return </span><span class="s1">tuple(_tuple_safe(e) </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">value)</span>
            <span class="s2">return </span><span class="s1">value</span>

        <span class="s3"># Cache the tuples for individual Paint instead of the whole sequence</span>
        <span class="s3"># because the seq could be a transient slice</span>
        <span class="s1">result = self.tuples.get(id(paint)</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">result </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">result = _tuple_safe(paint)</span>
            <span class="s1">self.tuples[id(paint)] = result</span>
            <span class="s1">self.keepAlive.append(paint)</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">_as_tuple(self</span><span class="s2">, </span><span class="s1">paints: Sequence[ot.Paint]) -&gt; Tuple[Any</span><span class="s2">, </span><span class="s1">...]:</span>
        <span class="s2">return </span><span class="s1">tuple(self._paint_tuple(p) </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">paints)</span>

    <span class="s2">def </span><span class="s1">try_reuse(self</span><span class="s2">, </span><span class="s1">layers: List[ot.Paint]) -&gt; List[ot.Paint]:</span>
        <span class="s1">found_reuse = </span><span class="s2">True</span>
        <span class="s2">while </span><span class="s1">found_reuse:</span>
            <span class="s1">found_reuse = </span><span class="s2">False</span>

            <span class="s1">ranges = sorted(</span>
                <span class="s1">_reuse_ranges(len(layers))</span><span class="s2">,</span>
                <span class="s1">key=</span><span class="s2">lambda </span><span class="s1">t: (t[</span><span class="s5">1</span><span class="s1">] - t[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">t[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">t[</span><span class="s5">0</span><span class="s1">])</span><span class="s2">,</span>
                <span class="s1">reverse=</span><span class="s2">True,</span>
            <span class="s1">)</span>
            <span class="s2">for </span><span class="s1">lbound</span><span class="s2">, </span><span class="s1">ubound </span><span class="s2">in </span><span class="s1">ranges:</span>
                <span class="s1">reuse_lbound = self.reusePool.get(</span>
                    <span class="s1">self._as_tuple(layers[lbound:ubound])</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span>
                <span class="s1">)</span>
                <span class="s2">if </span><span class="s1">reuse_lbound == -</span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s2">continue</span>
                <span class="s1">new_slice = ot.Paint()</span>
                <span class="s1">new_slice.Format = int(ot.PaintFormat.PaintColrLayers)</span>
                <span class="s1">new_slice.NumLayers = ubound - lbound</span>
                <span class="s1">new_slice.FirstLayerIndex = reuse_lbound</span>
                <span class="s1">layers = layers[:lbound] + [new_slice] + layers[ubound:]</span>
                <span class="s1">found_reuse = </span><span class="s2">True</span>
                <span class="s2">break</span>
        <span class="s2">return </span><span class="s1">layers</span>

    <span class="s2">def </span><span class="s1">add(self</span><span class="s2">, </span><span class="s1">layers: List[ot.Paint]</span><span class="s2">, </span><span class="s1">first_layer_index: int):</span>
        <span class="s2">for </span><span class="s1">lbound</span><span class="s2">, </span><span class="s1">ubound </span><span class="s2">in </span><span class="s1">_reuse_ranges(len(layers)):</span>
            <span class="s1">self.reusePool[self._as_tuple(layers[lbound:ubound])] = (</span>
                <span class="s1">lbound + first_layer_index</span>
            <span class="s1">)</span>


<span class="s2">class </span><span class="s1">LayerListBuilder:</span>
    <span class="s1">layers: List[ot.Paint]</span>
    <span class="s1">cache: LayerReuseCache</span>
    <span class="s1">allowLayerReuse: bool</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">allowLayerReuse=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s1">self.layers = []</span>
        <span class="s2">if </span><span class="s1">allowLayerReuse:</span>
            <span class="s1">self.cache = LayerReuseCache()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.cache = </span><span class="s2">None</span>

        <span class="s3"># We need to intercept construction of PaintColrLayers</span>
        <span class="s1">callbacks = _buildPaintCallbacks()</span>
        <span class="s1">callbacks[</span>
            <span class="s1">(</span>
                <span class="s1">BuildCallback.BEFORE_BUILD</span><span class="s2">,</span>
                <span class="s1">ot.Paint</span><span class="s2">,</span>
                <span class="s1">ot.PaintFormat.PaintColrLayers</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s1">] = self._beforeBuildPaintColrLayers</span>
        <span class="s1">self.tableBuilder = TableBuilder(callbacks)</span>

    <span class="s3"># COLR layers is unusual in that it modifies shared state</span>
    <span class="s3"># so we need a callback into an object</span>
    <span class="s2">def </span><span class="s1">_beforeBuildPaintColrLayers(self</span><span class="s2">, </span><span class="s1">dest</span><span class="s2">, </span><span class="s1">source):</span>
        <span class="s3"># Sketchy gymnastics: a sequence input will have dropped it's layers</span>
        <span class="s3"># into NumLayers; get it back</span>
        <span class="s2">if </span><span class="s1">isinstance(source.get(</span><span class="s4">&quot;NumLayers&quot;</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">, </span><span class="s1">collections.abc.Sequence):</span>
            <span class="s1">layers = source[</span><span class="s4">&quot;NumLayers&quot;</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">layers = source[</span><span class="s4">&quot;Layers&quot;</span><span class="s1">]</span>

        <span class="s3"># Convert maps seqs or whatever into typed objects</span>
        <span class="s1">layers = [self.buildPaint(l) </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">layers]</span>

        <span class="s3"># No reason to have a colr layers with just one entry</span>
        <span class="s2">if </span><span class="s1">len(layers) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">layers[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">{}</span>

        <span class="s2">if </span><span class="s1">self.cache </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s3"># Look for reuse, with preference to longer sequences</span>
            <span class="s3"># This may make the layer list smaller</span>
            <span class="s1">layers = self.cache.try_reuse(layers)</span>

        <span class="s3"># The layer list is now final; if it's too big we need to tree it</span>
        <span class="s1">is_tree = len(layers) &gt; MAX_PAINT_COLR_LAYER_COUNT</span>
        <span class="s1">layers = build_n_ary_tree(layers</span><span class="s2">, </span><span class="s1">n=MAX_PAINT_COLR_LAYER_COUNT)</span>

        <span class="s3"># We now have a tree of sequences with Paint leaves.</span>
        <span class="s3"># Convert the sequences into PaintColrLayers.</span>
        <span class="s2">def </span><span class="s1">listToColrLayers(layer):</span>
            <span class="s2">if </span><span class="s1">isinstance(layer</span><span class="s2">, </span><span class="s1">collections.abc.Sequence):</span>
                <span class="s2">return </span><span class="s1">self.buildPaint(</span>
                    <span class="s1">{</span>
                        <span class="s4">&quot;Format&quot;</span><span class="s1">: ot.PaintFormat.PaintColrLayers</span><span class="s2">,</span>
                        <span class="s4">&quot;Layers&quot;</span><span class="s1">: [listToColrLayers(l) </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">layer]</span><span class="s2">,</span>
                    <span class="s1">}</span>
                <span class="s1">)</span>
            <span class="s2">return </span><span class="s1">layer</span>

        <span class="s1">layers = [listToColrLayers(l) </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">layers]</span>

        <span class="s3"># No reason to have a colr layers with just one entry</span>
        <span class="s2">if </span><span class="s1">len(layers) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">layers[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">{}</span>

        <span class="s1">paint = ot.Paint()</span>
        <span class="s1">paint.Format = int(ot.PaintFormat.PaintColrLayers)</span>
        <span class="s1">paint.NumLayers = len(layers)</span>
        <span class="s1">paint.FirstLayerIndex = len(self.layers)</span>
        <span class="s1">self.layers.extend(layers)</span>

        <span class="s3"># Register our parts for reuse provided we aren't a tree</span>
        <span class="s3"># If we are a tree the leaves registered for reuse and that will suffice</span>
        <span class="s2">if </span><span class="s1">self.cache </span><span class="s2">is not None and not </span><span class="s1">is_tree:</span>
            <span class="s1">self.cache.add(layers</span><span class="s2">, </span><span class="s1">paint.FirstLayerIndex)</span>

        <span class="s3"># we've fully built dest; empty source prevents generalized build from kicking in</span>
        <span class="s2">return </span><span class="s1">paint</span><span class="s2">, </span><span class="s1">{}</span>

    <span class="s2">def </span><span class="s1">buildPaint(self</span><span class="s2">, </span><span class="s1">paint: _PaintInput) -&gt; ot.Paint:</span>
        <span class="s2">return </span><span class="s1">self.tableBuilder.build(ot.Paint</span><span class="s2">, </span><span class="s1">paint)</span>

    <span class="s2">def </span><span class="s1">build(self) -&gt; Optional[ot.LayerList]:</span>
        <span class="s2">if not </span><span class="s1">self.layers:</span>
            <span class="s2">return None</span>
        <span class="s1">layers = ot.LayerList()</span>
        <span class="s1">layers.LayerCount = len(self.layers)</span>
        <span class="s1">layers.Paint = self.layers</span>
        <span class="s2">return </span><span class="s1">layers</span>


<span class="s2">def </span><span class="s1">buildBaseGlyphPaintRecord(</span>
    <span class="s1">baseGlyph: str</span><span class="s2">, </span><span class="s1">layerBuilder: LayerListBuilder</span><span class="s2">, </span><span class="s1">paint: _PaintInput</span>
<span class="s1">) -&gt; ot.BaseGlyphList:</span>
    <span class="s1">self = ot.BaseGlyphPaintRecord()</span>
    <span class="s1">self.BaseGlyph = baseGlyph</span>
    <span class="s1">self.Paint = layerBuilder.buildPaint(paint)</span>
    <span class="s2">return </span><span class="s1">self</span>


<span class="s2">def </span><span class="s1">_format_glyph_errors(errors: Mapping[str</span><span class="s2">, </span><span class="s1">Exception]) -&gt; str:</span>
    <span class="s1">lines = []</span>
    <span class="s2">for </span><span class="s1">baseGlyph</span><span class="s2">, </span><span class="s1">error </span><span class="s2">in </span><span class="s1">sorted(errors.items()):</span>
        <span class="s1">lines.append(</span><span class="s4">f&quot;    </span><span class="s2">{</span><span class="s1">baseGlyph</span><span class="s2">} </span><span class="s4">=&gt; </span><span class="s2">{</span><span class="s1">type(error).__name__</span><span class="s2">}</span><span class="s4">: </span><span class="s2">{</span><span class="s1">error</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s1">.join(lines)</span>


<span class="s2">def </span><span class="s1">buildColrV1(</span>
    <span class="s1">colorGlyphs: _ColorGlyphsDict</span><span class="s2">,</span>
    <span class="s1">glyphMap: Optional[Mapping[str</span><span class="s2">, </span><span class="s1">int]] = </span><span class="s2">None,</span>
    <span class="s1">*</span><span class="s2">,</span>
    <span class="s1">allowLayerReuse: bool = </span><span class="s2">True,</span>
<span class="s1">) -&gt; Tuple[Optional[ot.LayerList]</span><span class="s2">, </span><span class="s1">ot.BaseGlyphList]:</span>
    <span class="s2">if </span><span class="s1">glyphMap </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">colorGlyphItems = sorted(</span>
            <span class="s1">colorGlyphs.items()</span><span class="s2">, </span><span class="s1">key=</span><span class="s2">lambda </span><span class="s1">item: glyphMap[item[</span><span class="s5">0</span><span class="s1">]]</span>
        <span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">colorGlyphItems = colorGlyphs.items()</span>

    <span class="s1">errors = {}</span>
    <span class="s1">baseGlyphs = []</span>
    <span class="s1">layerBuilder = LayerListBuilder(allowLayerReuse=allowLayerReuse)</span>
    <span class="s2">for </span><span class="s1">baseGlyph</span><span class="s2">, </span><span class="s1">paint </span><span class="s2">in </span><span class="s1">colorGlyphItems:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">baseGlyphs.append(buildBaseGlyphPaintRecord(baseGlyph</span><span class="s2">, </span><span class="s1">layerBuilder</span><span class="s2">, </span><span class="s1">paint))</span>

        <span class="s2">except </span><span class="s1">(ColorLibError</span><span class="s2">, </span><span class="s1">OverflowError</span><span class="s2">, </span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">TypeError) </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s1">errors[baseGlyph] = e</span>

    <span class="s2">if </span><span class="s1">errors:</span>
        <span class="s1">failed_glyphs = _format_glyph_errors(errors)</span>
        <span class="s1">exc = ColorLibError(</span><span class="s4">f&quot;Failed to build BaseGlyphList:</span><span class="s2">\n{</span><span class="s1">failed_glyphs</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s1">exc.errors = errors</span>
        <span class="s2">raise </span><span class="s1">exc </span><span class="s2">from </span><span class="s1">next(iter(errors.values()))</span>

    <span class="s1">layers = layerBuilder.build()</span>
    <span class="s1">glyphs = ot.BaseGlyphList()</span>
    <span class="s1">glyphs.BaseGlyphCount = len(baseGlyphs)</span>
    <span class="s1">glyphs.BaseGlyphPaintRecord = baseGlyphs</span>
    <span class="s2">return </span><span class="s1">(layers</span><span class="s2">, </span><span class="s1">glyphs)</span>
</pre>
</body>
</html>