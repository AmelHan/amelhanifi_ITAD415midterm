<html>
<head>
<title>palettes.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
palettes.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">colorsys</span>
<span class="s0">from </span><span class="s1">itertools </span><span class="s0">import </span><span class="s1">cycle</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">matplotlib </span><span class="s0">as </span><span class="s1">mpl</span>

<span class="s0">from </span><span class="s1">.external </span><span class="s0">import </span><span class="s1">husl</span>

<span class="s0">from </span><span class="s1">.utils </span><span class="s0">import </span><span class="s1">desaturate</span><span class="s0">, </span><span class="s1">get_color_cycle</span>
<span class="s0">from </span><span class="s1">.colors </span><span class="s0">import </span><span class="s1">xkcd_rgb</span><span class="s0">, </span><span class="s1">crayons</span>
<span class="s0">from </span><span class="s1">._compat </span><span class="s0">import </span><span class="s1">get_colormap</span>


<span class="s1">__all__ = [</span><span class="s2">&quot;color_palette&quot;</span><span class="s0">, </span><span class="s2">&quot;hls_palette&quot;</span><span class="s0">, </span><span class="s2">&quot;husl_palette&quot;</span><span class="s0">, </span><span class="s2">&quot;mpl_palette&quot;</span><span class="s0">,</span>
           <span class="s2">&quot;dark_palette&quot;</span><span class="s0">, </span><span class="s2">&quot;light_palette&quot;</span><span class="s0">, </span><span class="s2">&quot;diverging_palette&quot;</span><span class="s0">,</span>
           <span class="s2">&quot;blend_palette&quot;</span><span class="s0">, </span><span class="s2">&quot;xkcd_palette&quot;</span><span class="s0">, </span><span class="s2">&quot;crayon_palette&quot;</span><span class="s0">,</span>
           <span class="s2">&quot;cubehelix_palette&quot;</span><span class="s0">, </span><span class="s2">&quot;set_color_codes&quot;</span><span class="s1">]</span>


<span class="s1">SEABORN_PALETTES = dict(</span>
    <span class="s1">deep=[</span><span class="s2">&quot;#4C72B0&quot;</span><span class="s0">, </span><span class="s2">&quot;#DD8452&quot;</span><span class="s0">, </span><span class="s2">&quot;#55A868&quot;</span><span class="s0">, </span><span class="s2">&quot;#C44E52&quot;</span><span class="s0">, </span><span class="s2">&quot;#8172B3&quot;</span><span class="s0">,</span>
          <span class="s2">&quot;#937860&quot;</span><span class="s0">, </span><span class="s2">&quot;#DA8BC3&quot;</span><span class="s0">, </span><span class="s2">&quot;#8C8C8C&quot;</span><span class="s0">, </span><span class="s2">&quot;#CCB974&quot;</span><span class="s0">, </span><span class="s2">&quot;#64B5CD&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">deep6=[</span><span class="s2">&quot;#4C72B0&quot;</span><span class="s0">, </span><span class="s2">&quot;#55A868&quot;</span><span class="s0">, </span><span class="s2">&quot;#C44E52&quot;</span><span class="s0">,</span>
           <span class="s2">&quot;#8172B3&quot;</span><span class="s0">, </span><span class="s2">&quot;#CCB974&quot;</span><span class="s0">, </span><span class="s2">&quot;#64B5CD&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">muted=[</span><span class="s2">&quot;#4878D0&quot;</span><span class="s0">, </span><span class="s2">&quot;#EE854A&quot;</span><span class="s0">, </span><span class="s2">&quot;#6ACC64&quot;</span><span class="s0">, </span><span class="s2">&quot;#D65F5F&quot;</span><span class="s0">, </span><span class="s2">&quot;#956CB4&quot;</span><span class="s0">,</span>
           <span class="s2">&quot;#8C613C&quot;</span><span class="s0">, </span><span class="s2">&quot;#DC7EC0&quot;</span><span class="s0">, </span><span class="s2">&quot;#797979&quot;</span><span class="s0">, </span><span class="s2">&quot;#D5BB67&quot;</span><span class="s0">, </span><span class="s2">&quot;#82C6E2&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">muted6=[</span><span class="s2">&quot;#4878D0&quot;</span><span class="s0">, </span><span class="s2">&quot;#6ACC64&quot;</span><span class="s0">, </span><span class="s2">&quot;#D65F5F&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;#956CB4&quot;</span><span class="s0">, </span><span class="s2">&quot;#D5BB67&quot;</span><span class="s0">, </span><span class="s2">&quot;#82C6E2&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">pastel=[</span><span class="s2">&quot;#A1C9F4&quot;</span><span class="s0">, </span><span class="s2">&quot;#FFB482&quot;</span><span class="s0">, </span><span class="s2">&quot;#8DE5A1&quot;</span><span class="s0">, </span><span class="s2">&quot;#FF9F9B&quot;</span><span class="s0">, </span><span class="s2">&quot;#D0BBFF&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;#DEBB9B&quot;</span><span class="s0">, </span><span class="s2">&quot;#FAB0E4&quot;</span><span class="s0">, </span><span class="s2">&quot;#CFCFCF&quot;</span><span class="s0">, </span><span class="s2">&quot;#FFFEA3&quot;</span><span class="s0">, </span><span class="s2">&quot;#B9F2F0&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">pastel6=[</span><span class="s2">&quot;#A1C9F4&quot;</span><span class="s0">, </span><span class="s2">&quot;#8DE5A1&quot;</span><span class="s0">, </span><span class="s2">&quot;#FF9F9B&quot;</span><span class="s0">,</span>
             <span class="s2">&quot;#D0BBFF&quot;</span><span class="s0">, </span><span class="s2">&quot;#FFFEA3&quot;</span><span class="s0">, </span><span class="s2">&quot;#B9F2F0&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">bright=[</span><span class="s2">&quot;#023EFF&quot;</span><span class="s0">, </span><span class="s2">&quot;#FF7C00&quot;</span><span class="s0">, </span><span class="s2">&quot;#1AC938&quot;</span><span class="s0">, </span><span class="s2">&quot;#E8000B&quot;</span><span class="s0">, </span><span class="s2">&quot;#8B2BE2&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;#9F4800&quot;</span><span class="s0">, </span><span class="s2">&quot;#F14CC1&quot;</span><span class="s0">, </span><span class="s2">&quot;#A3A3A3&quot;</span><span class="s0">, </span><span class="s2">&quot;#FFC400&quot;</span><span class="s0">, </span><span class="s2">&quot;#00D7FF&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">bright6=[</span><span class="s2">&quot;#023EFF&quot;</span><span class="s0">, </span><span class="s2">&quot;#1AC938&quot;</span><span class="s0">, </span><span class="s2">&quot;#E8000B&quot;</span><span class="s0">,</span>
             <span class="s2">&quot;#8B2BE2&quot;</span><span class="s0">, </span><span class="s2">&quot;#FFC400&quot;</span><span class="s0">, </span><span class="s2">&quot;#00D7FF&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">dark=[</span><span class="s2">&quot;#001C7F&quot;</span><span class="s0">, </span><span class="s2">&quot;#B1400D&quot;</span><span class="s0">, </span><span class="s2">&quot;#12711C&quot;</span><span class="s0">, </span><span class="s2">&quot;#8C0800&quot;</span><span class="s0">, </span><span class="s2">&quot;#591E71&quot;</span><span class="s0">,</span>
          <span class="s2">&quot;#592F0D&quot;</span><span class="s0">, </span><span class="s2">&quot;#A23582&quot;</span><span class="s0">, </span><span class="s2">&quot;#3C3C3C&quot;</span><span class="s0">, </span><span class="s2">&quot;#B8850A&quot;</span><span class="s0">, </span><span class="s2">&quot;#006374&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">dark6=[</span><span class="s2">&quot;#001C7F&quot;</span><span class="s0">, </span><span class="s2">&quot;#12711C&quot;</span><span class="s0">, </span><span class="s2">&quot;#8C0800&quot;</span><span class="s0">,</span>
           <span class="s2">&quot;#591E71&quot;</span><span class="s0">, </span><span class="s2">&quot;#B8850A&quot;</span><span class="s0">, </span><span class="s2">&quot;#006374&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">colorblind=[</span><span class="s2">&quot;#0173B2&quot;</span><span class="s0">, </span><span class="s2">&quot;#DE8F05&quot;</span><span class="s0">, </span><span class="s2">&quot;#029E73&quot;</span><span class="s0">, </span><span class="s2">&quot;#D55E00&quot;</span><span class="s0">, </span><span class="s2">&quot;#CC78BC&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;#CA9161&quot;</span><span class="s0">, </span><span class="s2">&quot;#FBAFE4&quot;</span><span class="s0">, </span><span class="s2">&quot;#949494&quot;</span><span class="s0">, </span><span class="s2">&quot;#ECE133&quot;</span><span class="s0">, </span><span class="s2">&quot;#56B4E9&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">colorblind6=[</span><span class="s2">&quot;#0173B2&quot;</span><span class="s0">, </span><span class="s2">&quot;#029E73&quot;</span><span class="s0">, </span><span class="s2">&quot;#D55E00&quot;</span><span class="s0">,</span>
                 <span class="s2">&quot;#CC78BC&quot;</span><span class="s0">, </span><span class="s2">&quot;#ECE133&quot;</span><span class="s0">, </span><span class="s2">&quot;#56B4E9&quot;</span><span class="s1">]</span>
<span class="s1">)</span>


<span class="s1">MPL_QUAL_PALS = {</span>
    <span class="s2">&quot;tab10&quot;</span><span class="s1">: </span><span class="s3">10</span><span class="s0">, </span><span class="s2">&quot;tab20&quot;</span><span class="s1">: </span><span class="s3">20</span><span class="s0">, </span><span class="s2">&quot;tab20b&quot;</span><span class="s1">: </span><span class="s3">20</span><span class="s0">, </span><span class="s2">&quot;tab20c&quot;</span><span class="s1">: </span><span class="s3">20</span><span class="s0">,</span>
    <span class="s2">&quot;Set1&quot;</span><span class="s1">: </span><span class="s3">9</span><span class="s0">, </span><span class="s2">&quot;Set2&quot;</span><span class="s1">: </span><span class="s3">8</span><span class="s0">, </span><span class="s2">&quot;Set3&quot;</span><span class="s1">: </span><span class="s3">12</span><span class="s0">,</span>
    <span class="s2">&quot;Accent&quot;</span><span class="s1">: </span><span class="s3">8</span><span class="s0">, </span><span class="s2">&quot;Paired&quot;</span><span class="s1">: </span><span class="s3">12</span><span class="s0">,</span>
    <span class="s2">&quot;Pastel1&quot;</span><span class="s1">: </span><span class="s3">9</span><span class="s0">, </span><span class="s2">&quot;Pastel2&quot;</span><span class="s1">: </span><span class="s3">8</span><span class="s0">, </span><span class="s2">&quot;Dark2&quot;</span><span class="s1">: </span><span class="s3">8</span><span class="s0">,</span>
<span class="s1">}</span>


<span class="s1">QUAL_PALETTE_SIZES = MPL_QUAL_PALS.copy()</span>
<span class="s1">QUAL_PALETTE_SIZES.update({k: len(v) </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">SEABORN_PALETTES.items()})</span>
<span class="s1">QUAL_PALETTES = list(QUAL_PALETTE_SIZES.keys())</span>


<span class="s0">class </span><span class="s1">_ColorPalette(list):</span>
    <span class="s4">&quot;&quot;&quot;Set the color palette in a with statement, otherwise be a list.&quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__enter__(self):</span>
        <span class="s4">&quot;&quot;&quot;Open the context.&quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">.rcmod </span><span class="s0">import </span><span class="s1">set_palette</span>
        <span class="s1">self._orig_palette = color_palette()</span>
        <span class="s1">set_palette(self)</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">__exit__(self</span><span class="s0">, </span><span class="s1">*args):</span>
        <span class="s4">&quot;&quot;&quot;Close the context.&quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">.rcmod </span><span class="s0">import </span><span class="s1">set_palette</span>
        <span class="s1">set_palette(self._orig_palette)</span>

    <span class="s0">def </span><span class="s1">as_hex(self):</span>
        <span class="s4">&quot;&quot;&quot;Return a color palette with hex codes instead of RGB values.&quot;&quot;&quot;</span>
        <span class="s1">hex = [mpl.colors.rgb2hex(rgb) </span><span class="s0">for </span><span class="s1">rgb </span><span class="s0">in </span><span class="s1">self]</span>
        <span class="s0">return </span><span class="s1">_ColorPalette(hex)</span>

    <span class="s0">def </span><span class="s1">_repr_html_(self):</span>
        <span class="s4">&quot;&quot;&quot;Rich display of the color palette in an HTML frontend.&quot;&quot;&quot;</span>
        <span class="s1">s = </span><span class="s3">55</span>
        <span class="s1">n = len(self)</span>
        <span class="s1">html = </span><span class="s2">f'&lt;svg  width=&quot;</span><span class="s0">{</span><span class="s1">n * s</span><span class="s0">}</span><span class="s2">&quot; height=&quot;</span><span class="s0">{</span><span class="s1">s</span><span class="s0">}</span><span class="s2">&quot;&gt;'</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">c </span><span class="s0">in </span><span class="s1">enumerate(self.as_hex()):</span>
            <span class="s1">html += (</span>
                <span class="s2">f'&lt;rect x=&quot;</span><span class="s0">{</span><span class="s1">i * s</span><span class="s0">}</span><span class="s2">&quot; y=&quot;0&quot; width=&quot;</span><span class="s0">{</span><span class="s1">s</span><span class="s0">}</span><span class="s2">&quot; height=&quot;</span><span class="s0">{</span><span class="s1">s</span><span class="s0">}</span><span class="s2">&quot; style=&quot;fill:</span><span class="s0">{</span><span class="s1">c</span><span class="s0">}</span><span class="s2">;'</span>
                <span class="s2">'stroke-width:2;stroke:rgb(255,255,255)&quot;/&gt;'</span>
            <span class="s1">)</span>
        <span class="s1">html += </span><span class="s2">'&lt;/svg&gt;'</span>
        <span class="s0">return </span><span class="s1">html</span>


<span class="s0">def </span><span class="s1">_patch_colormap_display():</span>
    <span class="s4">&quot;&quot;&quot;Simplify the rich display of matplotlib color maps in a notebook.&quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">_repr_png_(self):</span>
        <span class="s4">&quot;&quot;&quot;Generate a PNG representation of the Colormap.&quot;&quot;&quot;</span>
        <span class="s0">import </span><span class="s1">io</span>
        <span class="s0">from </span><span class="s1">PIL </span><span class="s0">import </span><span class="s1">Image</span>
        <span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
        <span class="s1">IMAGE_SIZE = (</span><span class="s3">400</span><span class="s0">, </span><span class="s3">50</span><span class="s1">)</span>
        <span class="s1">X = np.tile(np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">IMAGE_SIZE[</span><span class="s3">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">(IMAGE_SIZE[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">pixels = self(X</span><span class="s0">, </span><span class="s1">bytes=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">png_bytes = io.BytesIO()</span>
        <span class="s1">Image.fromarray(pixels).save(png_bytes</span><span class="s0">, </span><span class="s1">format=</span><span class="s2">'png'</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">png_bytes.getvalue()</span>

    <span class="s0">def </span><span class="s1">_repr_html_(self):</span>
        <span class="s4">&quot;&quot;&quot;Generate an HTML representation of the Colormap.&quot;&quot;&quot;</span>
        <span class="s0">import </span><span class="s1">base64</span>
        <span class="s1">png_bytes = self._repr_png_()</span>
        <span class="s1">png_base64 = base64.b64encode(png_bytes).decode(</span><span class="s2">'ascii'</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">(</span><span class="s2">'&lt;img '</span>
                <span class="s1">+ </span><span class="s2">'alt=&quot;' </span><span class="s1">+ self.name + </span><span class="s2">' color map&quot; '</span>
                <span class="s1">+ </span><span class="s2">'title=&quot;' </span><span class="s1">+ self.name + </span><span class="s2">'&quot;'</span>
                <span class="s1">+ </span><span class="s2">'src=&quot;data:image/png;base64,' </span><span class="s1">+ png_base64 + </span><span class="s2">'&quot;&gt;'</span><span class="s1">)</span>

    <span class="s1">mpl.colors.Colormap._repr_png_ = _repr_png_</span>
    <span class="s1">mpl.colors.Colormap._repr_html_ = _repr_html_</span>


<span class="s0">def </span><span class="s1">color_palette(palette=</span><span class="s0">None, </span><span class="s1">n_colors=</span><span class="s0">None, </span><span class="s1">desat=</span><span class="s0">None, </span><span class="s1">as_cmap=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Return a list of colors or continuous colormap defining a palette. 
 
    Possible ``palette`` values include: 
        - Name of a seaborn palette (deep, muted, bright, pastel, dark, colorblind) 
        - Name of matplotlib colormap 
        - 'husl' or 'hls' 
        - 'ch:&lt;cubehelix arguments&gt;' 
        - 'light:&lt;color&gt;', 'dark:&lt;color&gt;', 'blend:&lt;color&gt;,&lt;color&gt;', 
        - A sequence of colors in any format matplotlib accepts 
 
    Calling this function with ``palette=None`` will return the current 
    matplotlib color cycle. 
 
    This function can also be used in a ``with`` statement to temporarily 
    set the color cycle for a plot or set of plots. 
 
    See the :ref:`tutorial &lt;palette_tutorial&gt;` for more information. 
 
    Parameters 
    ---------- 
    palette : None, string, or sequence, optional 
        Name of palette or None to return current palette. If a sequence, input 
        colors are used but possibly cycled and desaturated. 
    n_colors : int, optional 
        Number of colors in the palette. If ``None``, the default will depend 
        on how ``palette`` is specified. Named palettes default to 6 colors, 
        but grabbing the current palette or passing in a list of colors will 
        not change the number of colors unless this is specified. Asking for 
        more colors than exist in the palette will cause it to cycle. Ignored 
        when ``as_cmap`` is True. 
    desat : float, optional 
        Proportion to desaturate each color by. 
    as_cmap : bool 
        If True, return a :class:`matplotlib.colors.ListedColormap`. 
 
    Returns 
    ------- 
    list of RGB tuples or :class:`matplotlib.colors.ListedColormap` 
 
    See Also 
    -------- 
    set_palette : Set the default color cycle for all plots. 
    set_color_codes : Reassign color codes like ``&quot;b&quot;``, ``&quot;g&quot;``, etc. to 
                      colors from one of the seaborn palettes. 
 
    Examples 
    -------- 
 
    .. include:: ../docstrings/color_palette.rst 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">palette </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">palette = get_color_cycle()</span>
        <span class="s0">if </span><span class="s1">n_colors </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">n_colors = len(palette)</span>

    <span class="s0">elif not </span><span class="s1">isinstance(palette</span><span class="s0">, </span><span class="s1">str):</span>
        <span class="s1">palette = palette</span>
        <span class="s0">if </span><span class="s1">n_colors </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">n_colors = len(palette)</span>
    <span class="s0">else</span><span class="s1">:</span>

        <span class="s0">if </span><span class="s1">n_colors </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s5"># Use all colors in a qualitative palette or 6 of another kind</span>
            <span class="s1">n_colors = QUAL_PALETTE_SIZES.get(palette</span><span class="s0">, </span><span class="s3">6</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">palette </span><span class="s0">in </span><span class="s1">SEABORN_PALETTES:</span>
            <span class="s5"># Named &quot;seaborn variant&quot; of matplotlib default color cycle</span>
            <span class="s1">palette = SEABORN_PALETTES[palette]</span>

        <span class="s0">elif </span><span class="s1">palette == </span><span class="s2">&quot;hls&quot;</span><span class="s1">:</span>
            <span class="s5"># Evenly spaced colors in cylindrical RGB space</span>
            <span class="s1">palette = hls_palette(n_colors</span><span class="s0">, </span><span class="s1">as_cmap=as_cmap)</span>

        <span class="s0">elif </span><span class="s1">palette == </span><span class="s2">&quot;husl&quot;</span><span class="s1">:</span>
            <span class="s5"># Evenly spaced colors in cylindrical Lab space</span>
            <span class="s1">palette = husl_palette(n_colors</span><span class="s0">, </span><span class="s1">as_cmap=as_cmap)</span>

        <span class="s0">elif </span><span class="s1">palette.lower() == </span><span class="s2">&quot;jet&quot;</span><span class="s1">:</span>
            <span class="s5"># Paternalism</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;No.&quot;</span><span class="s1">)</span>

        <span class="s0">elif </span><span class="s1">palette.startswith(</span><span class="s2">&quot;ch:&quot;</span><span class="s1">):</span>
            <span class="s5"># Cubehelix palette with params specified in string</span>
            <span class="s1">args</span><span class="s0">, </span><span class="s1">kwargs = _parse_cubehelix_args(palette)</span>
            <span class="s1">palette = cubehelix_palette(n_colors</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs</span><span class="s0">, </span><span class="s1">as_cmap=as_cmap)</span>

        <span class="s0">elif </span><span class="s1">palette.startswith(</span><span class="s2">&quot;light:&quot;</span><span class="s1">):</span>
            <span class="s5"># light palette to color specified in string</span>
            <span class="s1">_</span><span class="s0">, </span><span class="s1">color = palette.split(</span><span class="s2">&quot;:&quot;</span><span class="s1">)</span>
            <span class="s1">reverse = color.endswith(</span><span class="s2">&quot;_r&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">reverse:</span>
                <span class="s1">color = color[:-</span><span class="s3">2</span><span class="s1">]</span>
            <span class="s1">palette = light_palette(color</span><span class="s0">, </span><span class="s1">n_colors</span><span class="s0">, </span><span class="s1">reverse=reverse</span><span class="s0">, </span><span class="s1">as_cmap=as_cmap)</span>

        <span class="s0">elif </span><span class="s1">palette.startswith(</span><span class="s2">&quot;dark:&quot;</span><span class="s1">):</span>
            <span class="s5"># light palette to color specified in string</span>
            <span class="s1">_</span><span class="s0">, </span><span class="s1">color = palette.split(</span><span class="s2">&quot;:&quot;</span><span class="s1">)</span>
            <span class="s1">reverse = color.endswith(</span><span class="s2">&quot;_r&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">reverse:</span>
                <span class="s1">color = color[:-</span><span class="s3">2</span><span class="s1">]</span>
            <span class="s1">palette = dark_palette(color</span><span class="s0">, </span><span class="s1">n_colors</span><span class="s0">, </span><span class="s1">reverse=reverse</span><span class="s0">, </span><span class="s1">as_cmap=as_cmap)</span>

        <span class="s0">elif </span><span class="s1">palette.startswith(</span><span class="s2">&quot;blend:&quot;</span><span class="s1">):</span>
            <span class="s5"># blend palette between colors specified in string</span>
            <span class="s1">_</span><span class="s0">, </span><span class="s1">colors = palette.split(</span><span class="s2">&quot;:&quot;</span><span class="s1">)</span>
            <span class="s1">colors = colors.split(</span><span class="s2">&quot;,&quot;</span><span class="s1">)</span>
            <span class="s1">palette = blend_palette(colors</span><span class="s0">, </span><span class="s1">n_colors</span><span class="s0">, </span><span class="s1">as_cmap=as_cmap)</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s5"># Perhaps a named matplotlib colormap?</span>
                <span class="s1">palette = mpl_palette(palette</span><span class="s0">, </span><span class="s1">n_colors</span><span class="s0">, </span><span class="s1">as_cmap=as_cmap)</span>
            <span class="s0">except </span><span class="s1">(ValueError</span><span class="s0">, </span><span class="s1">KeyError):  </span><span class="s5"># Error class changed in mpl36</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">palette</span><span class="s0">!r} </span><span class="s2">is not a valid palette name&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">desat </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">palette = [desaturate(c</span><span class="s0">, </span><span class="s1">desat) </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">palette]</span>

    <span class="s0">if not </span><span class="s1">as_cmap:</span>

        <span class="s5"># Always return as many colors as we asked for</span>
        <span class="s1">pal_cycle = cycle(palette)</span>
        <span class="s1">palette = [next(pal_cycle) </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(n_colors)]</span>

        <span class="s5"># Always return in r, g, b tuple format</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">palette = map(mpl.colors.colorConverter.to_rgb</span><span class="s0">, </span><span class="s1">palette)</span>
            <span class="s1">palette = _ColorPalette(palette)</span>
        <span class="s0">except </span><span class="s1">ValueError:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">f&quot;Could not generate a palette for </span><span class="s0">{</span><span class="s1">palette</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">palette</span>


<span class="s0">def </span><span class="s1">hls_palette(n_colors=</span><span class="s3">6</span><span class="s0">, </span><span class="s1">h=</span><span class="s3">.01</span><span class="s0">, </span><span class="s1">l=</span><span class="s3">.6</span><span class="s0">, </span><span class="s1">s=</span><span class="s3">.65</span><span class="s0">, </span><span class="s1">as_cmap=</span><span class="s0">False</span><span class="s1">):  </span><span class="s5"># noqa</span>
    <span class="s4">&quot;&quot;&quot; 
    Return hues with constant lightness and saturation in the HLS system. 
 
    The hues are evenly sampled along a circular path. The resulting palette will be 
    appropriate for categorical or cyclical data. 
 
    The `h`, `l`, and `s` values should be between 0 and 1. 
 
    .. note:: 
        While the separation of the resulting colors will be mathematically 
        constant, the HLS system does not construct a perceptually-uniform space, 
        so their apparent intensity will vary. 
 
    Parameters 
    ---------- 
    n_colors : int 
        Number of colors in the palette. 
    h : float 
        The value of the first hue. 
    l : float 
        The lightness value. 
    s : float 
        The saturation intensity. 
    as_cmap : bool 
        If True, return a matplotlib colormap object. 
 
    Returns 
    ------- 
    palette 
        list of RGB tuples or :class:`matplotlib.colors.ListedColormap` 
 
    See Also 
    -------- 
    husl_palette : Make a palette using evenly spaced hues in the HUSL system. 
 
    Examples 
    -------- 
    .. include:: ../docstrings/hls_palette.rst 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">as_cmap:</span>
        <span class="s1">n_colors = </span><span class="s3">256</span>
    <span class="s1">hues = np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">int(n_colors) + </span><span class="s3">1</span><span class="s1">)[:-</span><span class="s3">1</span><span class="s1">]</span>
    <span class="s1">hues += h</span>
    <span class="s1">hues %= </span><span class="s3">1</span>
    <span class="s1">hues -= hues.astype(int)</span>
    <span class="s1">palette = [colorsys.hls_to_rgb(h_i</span><span class="s0">, </span><span class="s1">l</span><span class="s0">, </span><span class="s1">s) </span><span class="s0">for </span><span class="s1">h_i </span><span class="s0">in </span><span class="s1">hues]</span>
    <span class="s0">if </span><span class="s1">as_cmap:</span>
        <span class="s0">return </span><span class="s1">mpl.colors.ListedColormap(palette</span><span class="s0">, </span><span class="s2">&quot;hls&quot;</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">_ColorPalette(palette)</span>


<span class="s0">def </span><span class="s1">husl_palette(n_colors=</span><span class="s3">6</span><span class="s0">, </span><span class="s1">h=</span><span class="s3">.01</span><span class="s0">, </span><span class="s1">s=</span><span class="s3">.9</span><span class="s0">, </span><span class="s1">l=</span><span class="s3">.65</span><span class="s0">, </span><span class="s1">as_cmap=</span><span class="s0">False</span><span class="s1">):  </span><span class="s5"># noqa</span>
    <span class="s4">&quot;&quot;&quot; 
    Return hues with constant lightness and saturation in the HUSL system. 
 
    The hues are evenly sampled along a circular path. The resulting palette will be 
    appropriate for categorical or cyclical data. 
 
    The `h`, `l`, and `s` values should be between 0 and 1. 
 
    This function is similar to :func:`hls_palette`, but it uses a nonlinear color 
    space that is more perceptually uniform. 
 
    Parameters 
    ---------- 
    n_colors : int 
        Number of colors in the palette. 
    h : float 
        The value of the first hue. 
    l : float 
        The lightness value. 
    s : float 
        The saturation intensity. 
    as_cmap : bool 
        If True, return a matplotlib colormap object. 
 
    Returns 
    ------- 
    palette 
        list of RGB tuples or :class:`matplotlib.colors.ListedColormap` 
 
    See Also 
    -------- 
    hls_palette : Make a palette using evenly spaced hues in the HSL system. 
 
    Examples 
    -------- 
    .. include:: ../docstrings/husl_palette.rst 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">as_cmap:</span>
        <span class="s1">n_colors = </span><span class="s3">256</span>
    <span class="s1">hues = np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">int(n_colors) + </span><span class="s3">1</span><span class="s1">)[:-</span><span class="s3">1</span><span class="s1">]</span>
    <span class="s1">hues += h</span>
    <span class="s1">hues %= </span><span class="s3">1</span>
    <span class="s1">hues *= </span><span class="s3">359</span>
    <span class="s1">s *= </span><span class="s3">99</span>
    <span class="s1">l *= </span><span class="s3">99  </span><span class="s5"># noqa</span>
    <span class="s1">palette = [_color_to_rgb((h_i</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">l)</span><span class="s0">, </span><span class="s1">input=</span><span class="s2">&quot;husl&quot;</span><span class="s1">) </span><span class="s0">for </span><span class="s1">h_i </span><span class="s0">in </span><span class="s1">hues]</span>
    <span class="s0">if </span><span class="s1">as_cmap:</span>
        <span class="s0">return </span><span class="s1">mpl.colors.ListedColormap(palette</span><span class="s0">, </span><span class="s2">&quot;hsl&quot;</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">_ColorPalette(palette)</span>


<span class="s0">def </span><span class="s1">mpl_palette(name</span><span class="s0">, </span><span class="s1">n_colors=</span><span class="s3">6</span><span class="s0">, </span><span class="s1">as_cmap=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Return a palette or colormap from the matplotlib registry. 
 
    For continuous palettes, evenly-spaced discrete samples are chosen while 
    excluding the minimum and maximum value in the colormap to provide better 
    contrast at the extremes. 
 
    For qualitative palettes (e.g. those from colorbrewer), exact values are 
    indexed (rather than interpolated), but fewer than `n_colors` can be returned 
    if the palette does not define that many. 
 
    Parameters 
    ---------- 
    name : string 
        Name of the palette. This should be a named matplotlib colormap. 
    n_colors : int 
        Number of discrete colors in the palette. 
 
    Returns 
    ------- 
    list of RGB tuples or :class:`matplotlib.colors.ListedColormap` 
 
    Examples 
    -------- 
    .. include:: ../docstrings/mpl_palette.rst 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">name.endswith(</span><span class="s2">&quot;_d&quot;</span><span class="s1">):</span>
        <span class="s1">sub_name = name[:-</span><span class="s3">2</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">sub_name.endswith(</span><span class="s2">&quot;_r&quot;</span><span class="s1">):</span>
            <span class="s1">reverse = </span><span class="s0">True</span>
            <span class="s1">sub_name = sub_name[:-</span><span class="s3">2</span><span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">reverse = </span><span class="s0">False</span>
        <span class="s1">pal = color_palette(sub_name</span><span class="s0">, </span><span class="s3">2</span><span class="s1">) + [</span><span class="s2">&quot;#333333&quot;</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">reverse:</span>
            <span class="s1">pal = pal[::-</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">cmap = blend_palette(pal</span><span class="s0">, </span><span class="s1">n_colors</span><span class="s0">, </span><span class="s1">as_cmap=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">cmap = get_colormap(name)</span>

    <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">MPL_QUAL_PALS:</span>
        <span class="s1">bins = np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">MPL_QUAL_PALS[name])[:n_colors]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">bins = np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">int(n_colors) + </span><span class="s3">2</span><span class="s1">)[</span><span class="s3">1</span><span class="s1">:-</span><span class="s3">1</span><span class="s1">]</span>
    <span class="s1">palette = list(map(tuple</span><span class="s0">, </span><span class="s1">cmap(bins)[:</span><span class="s0">, </span><span class="s1">:</span><span class="s3">3</span><span class="s1">]))</span>

    <span class="s0">if </span><span class="s1">as_cmap:</span>
        <span class="s0">return </span><span class="s1">cmap</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">_ColorPalette(palette)</span>


<span class="s0">def </span><span class="s1">_color_to_rgb(color</span><span class="s0">, </span><span class="s1">input):</span>
    <span class="s4">&quot;&quot;&quot;Add some more flexibility to color choices.&quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">input == </span><span class="s2">&quot;hls&quot;</span><span class="s1">:</span>
        <span class="s1">color = colorsys.hls_to_rgb(*color)</span>
    <span class="s0">elif </span><span class="s1">input == </span><span class="s2">&quot;husl&quot;</span><span class="s1">:</span>
        <span class="s1">color = husl.husl_to_rgb(*color)</span>
        <span class="s1">color = tuple(np.clip(color</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
    <span class="s0">elif </span><span class="s1">input == </span><span class="s2">&quot;xkcd&quot;</span><span class="s1">:</span>
        <span class="s1">color = xkcd_rgb[color]</span>

    <span class="s0">return </span><span class="s1">mpl.colors.to_rgb(color)</span>


<span class="s0">def </span><span class="s1">dark_palette(color</span><span class="s0">, </span><span class="s1">n_colors=</span><span class="s3">6</span><span class="s0">, </span><span class="s1">reverse=</span><span class="s0">False, </span><span class="s1">as_cmap=</span><span class="s0">False, </span><span class="s1">input=</span><span class="s2">&quot;rgb&quot;</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Make a sequential palette that blends from dark to ``color``. 
 
    This kind of palette is good for data that range between relatively 
    uninteresting low values and interesting high values. 
 
    The ``color`` parameter can be specified in a number of ways, including 
    all options for defining a color in matplotlib and several additional 
    color spaces that are handled by seaborn. You can also use the database 
    of named colors from the XKCD color survey. 
 
    If you are using the IPython notebook, you can also choose this palette 
    interactively with the :func:`choose_dark_palette` function. 
 
    Parameters 
    ---------- 
    color : base color for high values 
        hex, rgb-tuple, or html color name 
    n_colors : int, optional 
        number of colors in the palette 
    reverse : bool, optional 
        if True, reverse the direction of the blend 
    as_cmap : bool, optional 
        If True, return a :class:`matplotlib.colors.ListedColormap`. 
    input : {'rgb', 'hls', 'husl', xkcd'} 
        Color space to interpret the input color. The first three options 
        apply to tuple inputs and the latter applies to string inputs. 
 
    Returns 
    ------- 
    palette 
        list of RGB tuples or :class:`matplotlib.colors.ListedColormap` 
 
    See Also 
    -------- 
    light_palette : Create a sequential palette with bright low values. 
    diverging_palette : Create a diverging palette with two colors. 
 
    Examples 
    -------- 
    .. include:: ../docstrings/dark_palette.rst 
 
    &quot;&quot;&quot;</span>
    <span class="s1">rgb = _color_to_rgb(color</span><span class="s0">, </span><span class="s1">input)</span>
    <span class="s1">hue</span><span class="s0">, </span><span class="s1">sat</span><span class="s0">, </span><span class="s1">_ = husl.rgb_to_husl(*rgb)</span>
    <span class="s1">gray_s</span><span class="s0">, </span><span class="s1">gray_l = </span><span class="s3">.15 </span><span class="s1">* sat</span><span class="s0">, </span><span class="s3">15</span>
    <span class="s1">gray = _color_to_rgb((hue</span><span class="s0">, </span><span class="s1">gray_s</span><span class="s0">, </span><span class="s1">gray_l)</span><span class="s0">, </span><span class="s1">input=</span><span class="s2">&quot;husl&quot;</span><span class="s1">)</span>
    <span class="s1">colors = [rgb</span><span class="s0">, </span><span class="s1">gray] </span><span class="s0">if </span><span class="s1">reverse </span><span class="s0">else </span><span class="s1">[gray</span><span class="s0">, </span><span class="s1">rgb]</span>
    <span class="s0">return </span><span class="s1">blend_palette(colors</span><span class="s0">, </span><span class="s1">n_colors</span><span class="s0">, </span><span class="s1">as_cmap)</span>


<span class="s0">def </span><span class="s1">light_palette(color</span><span class="s0">, </span><span class="s1">n_colors=</span><span class="s3">6</span><span class="s0">, </span><span class="s1">reverse=</span><span class="s0">False, </span><span class="s1">as_cmap=</span><span class="s0">False, </span><span class="s1">input=</span><span class="s2">&quot;rgb&quot;</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Make a sequential palette that blends from light to ``color``. 
 
    The ``color`` parameter can be specified in a number of ways, including 
    all options for defining a color in matplotlib and several additional 
    color spaces that are handled by seaborn. You can also use the database 
    of named colors from the XKCD color survey. 
 
    If you are using a Jupyter notebook, you can also choose this palette 
    interactively with the :func:`choose_light_palette` function. 
 
    Parameters 
    ---------- 
    color : base color for high values 
        hex code, html color name, or tuple in `input` space. 
    n_colors : int, optional 
        number of colors in the palette 
    reverse : bool, optional 
        if True, reverse the direction of the blend 
    as_cmap : bool, optional 
        If True, return a :class:`matplotlib.colors.ListedColormap`. 
    input : {'rgb', 'hls', 'husl', xkcd'} 
        Color space to interpret the input color. The first three options 
        apply to tuple inputs and the latter applies to string inputs. 
 
    Returns 
    ------- 
    palette 
        list of RGB tuples or :class:`matplotlib.colors.ListedColormap` 
 
    See Also 
    -------- 
    dark_palette : Create a sequential palette with dark low values. 
    diverging_palette : Create a diverging palette with two colors. 
 
    Examples 
    -------- 
    .. include:: ../docstrings/light_palette.rst 
 
    &quot;&quot;&quot;</span>
    <span class="s1">rgb = _color_to_rgb(color</span><span class="s0">, </span><span class="s1">input)</span>
    <span class="s1">hue</span><span class="s0">, </span><span class="s1">sat</span><span class="s0">, </span><span class="s1">_ = husl.rgb_to_husl(*rgb)</span>
    <span class="s1">gray_s</span><span class="s0">, </span><span class="s1">gray_l = </span><span class="s3">.15 </span><span class="s1">* sat</span><span class="s0">, </span><span class="s3">95</span>
    <span class="s1">gray = _color_to_rgb((hue</span><span class="s0">, </span><span class="s1">gray_s</span><span class="s0">, </span><span class="s1">gray_l)</span><span class="s0">, </span><span class="s1">input=</span><span class="s2">&quot;husl&quot;</span><span class="s1">)</span>
    <span class="s1">colors = [rgb</span><span class="s0">, </span><span class="s1">gray] </span><span class="s0">if </span><span class="s1">reverse </span><span class="s0">else </span><span class="s1">[gray</span><span class="s0">, </span><span class="s1">rgb]</span>
    <span class="s0">return </span><span class="s1">blend_palette(colors</span><span class="s0">, </span><span class="s1">n_colors</span><span class="s0">, </span><span class="s1">as_cmap)</span>


<span class="s0">def </span><span class="s1">diverging_palette(h_neg</span><span class="s0">, </span><span class="s1">h_pos</span><span class="s0">, </span><span class="s1">s=</span><span class="s3">75</span><span class="s0">, </span><span class="s1">l=</span><span class="s3">50</span><span class="s0">, </span><span class="s1">sep=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">6</span><span class="s0">,  </span><span class="s5"># noqa</span>
                      <span class="s1">center=</span><span class="s2">&quot;light&quot;</span><span class="s0">, </span><span class="s1">as_cmap=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Make a diverging palette between two HUSL colors. 
 
    If you are using the IPython notebook, you can also choose this palette 
    interactively with the :func:`choose_diverging_palette` function. 
 
    Parameters 
    ---------- 
    h_neg, h_pos : float in [0, 359] 
        Anchor hues for negative and positive extents of the map. 
    s : float in [0, 100], optional 
        Anchor saturation for both extents of the map. 
    l : float in [0, 100], optional 
        Anchor lightness for both extents of the map. 
    sep : int, optional 
        Size of the intermediate region. 
    n : int, optional 
        Number of colors in the palette (if not returning a cmap) 
    center : {&quot;light&quot;, &quot;dark&quot;}, optional 
        Whether the center of the palette is light or dark 
    as_cmap : bool, optional 
        If True, return a :class:`matplotlib.colors.ListedColormap`. 
 
    Returns 
    ------- 
    palette 
        list of RGB tuples or :class:`matplotlib.colors.ListedColormap` 
 
    See Also 
    -------- 
    dark_palette : Create a sequential palette with dark values. 
    light_palette : Create a sequential palette with light values. 
 
    Examples 
    -------- 
    .. include: ../docstrings/diverging_palette.rst 
 
    &quot;&quot;&quot;</span>
    <span class="s1">palfunc = dict(dark=dark_palette</span><span class="s0">, </span><span class="s1">light=light_palette)[center]</span>
    <span class="s1">n_half = int(</span><span class="s3">128 </span><span class="s1">- (sep // </span><span class="s3">2</span><span class="s1">))</span>
    <span class="s1">neg = palfunc((h_neg</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">l)</span><span class="s0">, </span><span class="s1">n_half</span><span class="s0">, </span><span class="s1">reverse=</span><span class="s0">True, </span><span class="s1">input=</span><span class="s2">&quot;husl&quot;</span><span class="s1">)</span>
    <span class="s1">pos = palfunc((h_pos</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">l)</span><span class="s0">, </span><span class="s1">n_half</span><span class="s0">, </span><span class="s1">input=</span><span class="s2">&quot;husl&quot;</span><span class="s1">)</span>
    <span class="s1">midpoint = dict(light=[(</span><span class="s3">.95</span><span class="s0">, </span><span class="s3">.95</span><span class="s0">, </span><span class="s3">.95</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">dark=[(</span><span class="s3">.133</span><span class="s0">, </span><span class="s3">.133</span><span class="s0">, </span><span class="s3">.133</span><span class="s1">)])[center]</span>
    <span class="s1">mid = midpoint * sep</span>
    <span class="s1">pal = blend_palette(np.concatenate([neg</span><span class="s0">, </span><span class="s1">mid</span><span class="s0">, </span><span class="s1">pos])</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">as_cmap=as_cmap)</span>
    <span class="s0">return </span><span class="s1">pal</span>


<span class="s0">def </span><span class="s1">blend_palette(colors</span><span class="s0">, </span><span class="s1">n_colors=</span><span class="s3">6</span><span class="s0">, </span><span class="s1">as_cmap=</span><span class="s0">False, </span><span class="s1">input=</span><span class="s2">&quot;rgb&quot;</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Make a palette that blends between a list of colors. 
 
    Parameters 
    ---------- 
    colors : sequence of colors in various formats interpreted by `input` 
        hex code, html color name, or tuple in `input` space. 
    n_colors : int, optional 
        Number of colors in the palette. 
    as_cmap : bool, optional 
        If True, return a :class:`matplotlib.colors.ListedColormap`. 
 
    Returns 
    ------- 
    palette 
        list of RGB tuples or :class:`matplotlib.colors.ListedColormap` 
 
    Examples 
    -------- 
    .. include: ../docstrings/blend_palette.rst 
 
    &quot;&quot;&quot;</span>
    <span class="s1">colors = [_color_to_rgb(color</span><span class="s0">, </span><span class="s1">input) </span><span class="s0">for </span><span class="s1">color </span><span class="s0">in </span><span class="s1">colors]</span>
    <span class="s1">name = </span><span class="s2">&quot;blend&quot;</span>
    <span class="s1">pal = mpl.colors.LinearSegmentedColormap.from_list(name</span><span class="s0">, </span><span class="s1">colors)</span>
    <span class="s0">if not </span><span class="s1">as_cmap:</span>
        <span class="s1">rgb_array = pal(np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">int(n_colors)))[:</span><span class="s0">, </span><span class="s1">:</span><span class="s3">3</span><span class="s1">]  </span><span class="s5"># no alpha</span>
        <span class="s1">pal = _ColorPalette(map(tuple</span><span class="s0">, </span><span class="s1">rgb_array))</span>
    <span class="s0">return </span><span class="s1">pal</span>


<span class="s0">def </span><span class="s1">xkcd_palette(colors):</span>
    <span class="s4">&quot;&quot;&quot;Make a palette with color names from the xkcd color survey. 
 
    See xkcd for the full list of colors: https://xkcd.com/color/rgb/ 
 
    This is just a simple wrapper around the `seaborn.xkcd_rgb` dictionary. 
 
    Parameters 
    ---------- 
    colors : list of strings 
        List of keys in the `seaborn.xkcd_rgb` dictionary. 
 
    Returns 
    ------- 
    palette 
        A list of colors as RGB tuples. 
 
    See Also 
    -------- 
    crayon_palette : Make a palette with Crayola crayon colors. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">palette = [xkcd_rgb[name] </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">colors]</span>
    <span class="s0">return </span><span class="s1">color_palette(palette</span><span class="s0">, </span><span class="s1">len(palette))</span>


<span class="s0">def </span><span class="s1">crayon_palette(colors):</span>
    <span class="s4">&quot;&quot;&quot;Make a palette with color names from Crayola crayons. 
 
    Colors are taken from here: 
    https://en.wikipedia.org/wiki/List_of_Crayola_crayon_colors 
 
    This is just a simple wrapper around the `seaborn.crayons` dictionary. 
 
    Parameters 
    ---------- 
    colors : list of strings 
        List of keys in the `seaborn.crayons` dictionary. 
 
    Returns 
    ------- 
    palette 
        A list of colors as RGB tuples. 
 
    See Also 
    -------- 
    xkcd_palette : Make a palette with named colors from the XKCD color survey. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">palette = [crayons[name] </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">colors]</span>
    <span class="s0">return </span><span class="s1">color_palette(palette</span><span class="s0">, </span><span class="s1">len(palette))</span>


<span class="s0">def </span><span class="s1">cubehelix_palette(n_colors=</span><span class="s3">6</span><span class="s0">, </span><span class="s1">start=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">rot=</span><span class="s3">.4</span><span class="s0">, </span><span class="s1">gamma=</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">hue=</span><span class="s3">0.8</span><span class="s0">,</span>
                      <span class="s1">light=</span><span class="s3">.85</span><span class="s0">, </span><span class="s1">dark=</span><span class="s3">.15</span><span class="s0">, </span><span class="s1">reverse=</span><span class="s0">False, </span><span class="s1">as_cmap=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Make a sequential palette from the cubehelix system. 
 
    This produces a colormap with linearly-decreasing (or increasing) 
    brightness. That means that information will be preserved if printed to 
    black and white or viewed by someone who is colorblind.  &quot;cubehelix&quot; is 
    also available as a matplotlib-based palette, but this function gives the 
    user more control over the look of the palette and has a different set of 
    defaults. 
 
    In addition to using this function, it is also possible to generate a 
    cubehelix palette generally in seaborn using a string starting with 
    `ch:` and containing other parameters (e.g. `&quot;ch:s=.25,r=-.5&quot;`). 
 
    Parameters 
    ---------- 
    n_colors : int 
        Number of colors in the palette. 
    start : float, 0 &lt;= start &lt;= 3 
        The hue value at the start of the helix. 
    rot : float 
        Rotations around the hue wheel over the range of the palette. 
    gamma : float 0 &lt;= gamma 
        Nonlinearity to emphasize dark (gamma &lt; 1) or light (gamma &gt; 1) colors. 
    hue : float, 0 &lt;= hue &lt;= 1 
        Saturation of the colors. 
    dark : float 0 &lt;= dark &lt;= 1 
        Intensity of the darkest color in the palette. 
    light : float 0 &lt;= light &lt;= 1 
        Intensity of the lightest color in the palette. 
    reverse : bool 
        If True, the palette will go from dark to light. 
    as_cmap : bool 
        If True, return a :class:`matplotlib.colors.ListedColormap`. 
 
    Returns 
    ------- 
    palette 
        list of RGB tuples or :class:`matplotlib.colors.ListedColormap` 
 
    See Also 
    -------- 
    choose_cubehelix_palette : Launch an interactive widget to select cubehelix 
                               palette parameters. 
    dark_palette : Create a sequential palette with dark low values. 
    light_palette : Create a sequential palette with bright low values. 
 
    References 
    ---------- 
    Green, D. A. (2011). &quot;A colour scheme for the display of astronomical 
    intensity images&quot;. Bulletin of the Astromical Society of India, Vol. 39, 
    p. 289-295. 
 
    Examples 
    -------- 
    .. include:: ../docstrings/cubehelix_palette.rst 
 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">get_color_function(p0</span><span class="s0">, </span><span class="s1">p1):</span>
        <span class="s5"># Copied from matplotlib because it lives in private module</span>
        <span class="s0">def </span><span class="s1">color(x):</span>
            <span class="s5"># Apply gamma factor to emphasise low or high intensity values</span>
            <span class="s1">xg = x ** gamma</span>

            <span class="s5"># Calculate amplitude and angle of deviation from the black</span>
            <span class="s5"># to white diagonal in the plane of constant</span>
            <span class="s5"># perceived intensity.</span>
            <span class="s1">a = hue * xg * (</span><span class="s3">1 </span><span class="s1">- xg) / </span><span class="s3">2</span>

            <span class="s1">phi = </span><span class="s3">2 </span><span class="s1">* np.pi * (start / </span><span class="s3">3 </span><span class="s1">+ rot * x)</span>

            <span class="s0">return </span><span class="s1">xg + a * (p0 * np.cos(phi) + p1 * np.sin(phi))</span>
        <span class="s0">return </span><span class="s1">color</span>

    <span class="s1">cdict = {</span>
        <span class="s2">&quot;red&quot;</span><span class="s1">: get_color_function(-</span><span class="s3">0.14861</span><span class="s0">, </span><span class="s3">1.78277</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s2">&quot;green&quot;</span><span class="s1">: get_color_function(-</span><span class="s3">0.29227</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.90649</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s2">&quot;blue&quot;</span><span class="s1">: get_color_function(</span><span class="s3">1.97294</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">}</span>

    <span class="s1">cmap = mpl.colors.LinearSegmentedColormap(</span><span class="s2">&quot;cubehelix&quot;</span><span class="s0">, </span><span class="s1">cdict)</span>

    <span class="s1">x = np.linspace(light</span><span class="s0">, </span><span class="s1">dark</span><span class="s0">, </span><span class="s1">int(n_colors))</span>
    <span class="s1">pal = cmap(x)[:</span><span class="s0">, </span><span class="s1">:</span><span class="s3">3</span><span class="s1">].tolist()</span>
    <span class="s0">if </span><span class="s1">reverse:</span>
        <span class="s1">pal = pal[::-</span><span class="s3">1</span><span class="s1">]</span>

    <span class="s0">if </span><span class="s1">as_cmap:</span>
        <span class="s1">x_256 = np.linspace(light</span><span class="s0">, </span><span class="s1">dark</span><span class="s0">, </span><span class="s3">256</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">reverse:</span>
            <span class="s1">x_256 = x_256[::-</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">pal_256 = cmap(x_256)</span>
        <span class="s1">cmap = mpl.colors.ListedColormap(pal_256</span><span class="s0">, </span><span class="s2">&quot;seaborn_cubehelix&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">cmap</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">_ColorPalette(pal)</span>


<span class="s0">def </span><span class="s1">_parse_cubehelix_args(argstr):</span>
    <span class="s4">&quot;&quot;&quot;Turn stringified cubehelix params into args/kwargs.&quot;&quot;&quot;</span>

    <span class="s0">if </span><span class="s1">argstr.startswith(</span><span class="s2">&quot;ch:&quot;</span><span class="s1">):</span>
        <span class="s1">argstr = argstr[</span><span class="s3">3</span><span class="s1">:]</span>

    <span class="s0">if </span><span class="s1">argstr.endswith(</span><span class="s2">&quot;_r&quot;</span><span class="s1">):</span>
        <span class="s1">reverse = </span><span class="s0">True</span>
        <span class="s1">argstr = argstr[:-</span><span class="s3">2</span><span class="s1">]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">reverse = </span><span class="s0">False</span>

    <span class="s0">if not </span><span class="s1">argstr:</span>
        <span class="s0">return </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;reverse&quot;</span><span class="s1">: reverse}</span>

    <span class="s1">all_args = argstr.split(</span><span class="s2">&quot;,&quot;</span><span class="s1">)</span>

    <span class="s1">args = [float(a.strip(</span><span class="s2">&quot; &quot;</span><span class="s1">)) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">all_args </span><span class="s0">if </span><span class="s2">&quot;=&quot; </span><span class="s0">not in </span><span class="s1">a]</span>

    <span class="s1">kwargs = [a.split(</span><span class="s2">&quot;=&quot;</span><span class="s1">) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">all_args </span><span class="s0">if </span><span class="s2">&quot;=&quot; </span><span class="s0">in </span><span class="s1">a]</span>
    <span class="s1">kwargs = {k.strip(</span><span class="s2">&quot; &quot;</span><span class="s1">): float(v.strip(</span><span class="s2">&quot; &quot;</span><span class="s1">)) </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">kwargs}</span>

    <span class="s1">kwarg_map = dict(</span>
        <span class="s1">s=</span><span class="s2">&quot;start&quot;</span><span class="s0">, </span><span class="s1">r=</span><span class="s2">&quot;rot&quot;</span><span class="s0">, </span><span class="s1">g=</span><span class="s2">&quot;gamma&quot;</span><span class="s0">,</span>
        <span class="s1">h=</span><span class="s2">&quot;hue&quot;</span><span class="s0">, </span><span class="s1">l=</span><span class="s2">&quot;light&quot;</span><span class="s0">, </span><span class="s1">d=</span><span class="s2">&quot;dark&quot;</span><span class="s0">,  </span><span class="s5"># noqa: E741</span>
    <span class="s1">)</span>

    <span class="s1">kwargs = {kwarg_map.get(k</span><span class="s0">, </span><span class="s1">k): v </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">kwargs.items()}</span>

    <span class="s0">if </span><span class="s1">reverse:</span>
        <span class="s1">kwargs[</span><span class="s2">&quot;reverse&quot;</span><span class="s1">] = </span><span class="s0">True</span>

    <span class="s0">return </span><span class="s1">args</span><span class="s0">, </span><span class="s1">kwargs</span>


<span class="s0">def </span><span class="s1">set_color_codes(palette=</span><span class="s2">&quot;deep&quot;</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Change how matplotlib color shorthands are interpreted. 
 
    Calling this will change how shorthand codes like &quot;b&quot; or &quot;g&quot; 
    are interpreted by matplotlib in subsequent plots. 
 
    Parameters 
    ---------- 
    palette : {deep, muted, pastel, dark, bright, colorblind} 
        Named seaborn palette to use as the source of colors. 
 
    See Also 
    -------- 
    set : Color codes can be set through the high-level seaborn style 
          manager. 
    set_palette : Color codes can also be set through the function that 
                  sets the matplotlib color cycle. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">palette == </span><span class="s2">&quot;reset&quot;</span><span class="s1">:</span>
        <span class="s1">colors = [</span>
            <span class="s1">(</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">0.</span><span class="s0">, </span><span class="s3">1.</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">.5</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">0.</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">.75</span><span class="s0">, </span><span class="s3">0.</span><span class="s0">, </span><span class="s3">.75</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">.75</span><span class="s0">, </span><span class="s3">.75</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">.75</span><span class="s0">, </span><span class="s3">.75</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">0.</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">)</span>
        <span class="s1">]</span>
    <span class="s0">elif not </span><span class="s1">isinstance(palette</span><span class="s0">, </span><span class="s1">str):</span>
        <span class="s1">err = </span><span class="s2">&quot;set_color_codes requires a named seaborn palette&quot;</span>
        <span class="s0">raise </span><span class="s1">TypeError(err)</span>
    <span class="s0">elif </span><span class="s1">palette </span><span class="s0">in </span><span class="s1">SEABORN_PALETTES:</span>
        <span class="s0">if not </span><span class="s1">palette.endswith(</span><span class="s2">&quot;6&quot;</span><span class="s1">):</span>
            <span class="s1">palette = palette + </span><span class="s2">&quot;6&quot;</span>
        <span class="s1">colors = SEABORN_PALETTES[palette] + [(</span><span class="s3">.1</span><span class="s0">, </span><span class="s3">.1</span><span class="s0">, </span><span class="s3">.1</span><span class="s1">)]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">err = </span><span class="s2">f&quot;Cannot set colors with palette '</span><span class="s0">{</span><span class="s1">palette</span><span class="s0">}</span><span class="s2">'&quot;</span>
        <span class="s0">raise </span><span class="s1">ValueError(err)</span>

    <span class="s0">for </span><span class="s1">code</span><span class="s0">, </span><span class="s1">color </span><span class="s0">in </span><span class="s1">zip(</span><span class="s2">&quot;bgrmyck&quot;</span><span class="s0">, </span><span class="s1">colors):</span>
        <span class="s1">rgb = mpl.colors.colorConverter.to_rgb(color)</span>
        <span class="s1">mpl.colors.colorConverter.colors[code] = rgb</span>
</pre>
</body>
</html>