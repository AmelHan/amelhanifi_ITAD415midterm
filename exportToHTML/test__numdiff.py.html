<html>
<head>
<title>test__numdiff.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test__numdiff.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">math</span>
<span class="s0">from </span><span class="s1">itertools </span><span class="s0">import </span><span class="s1">product</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">assert_allclose</span><span class="s0">, </span><span class="s1">assert_equal</span><span class="s0">, </span><span class="s1">assert_</span>
<span class="s0">from </span><span class="s1">pytest </span><span class="s0">import </span><span class="s1">raises </span><span class="s0">as </span><span class="s1">assert_raises</span>

<span class="s0">from </span><span class="s1">scipy.sparse </span><span class="s0">import </span><span class="s1">csr_matrix</span><span class="s0">, </span><span class="s1">csc_matrix</span><span class="s0">, </span><span class="s1">lil_matrix</span>

<span class="s0">from </span><span class="s1">scipy.optimize._numdiff </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">_adjust_scheme_to_bounds</span><span class="s0">, </span><span class="s1">approx_derivative</span><span class="s0">, </span><span class="s1">check_derivative</span><span class="s0">,</span>
    <span class="s1">group_columns</span><span class="s0">, </span><span class="s1">_eps_for_method</span><span class="s0">, </span><span class="s1">_compute_absolute_step)</span>


<span class="s0">def </span><span class="s1">test_group_columns():</span>
    <span class="s1">structure = [</span>
        <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span>
    <span class="s1">]</span>
    <span class="s0">for </span><span class="s1">transform </span><span class="s0">in </span><span class="s1">[np.asarray</span><span class="s0">, </span><span class="s1">csr_matrix</span><span class="s0">, </span><span class="s1">csc_matrix</span><span class="s0">, </span><span class="s1">lil_matrix]:</span>
        <span class="s1">A = transform(structure)</span>
        <span class="s1">order = np.arange(</span><span class="s2">6</span><span class="s1">)</span>
        <span class="s1">groups_true = np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">groups = group_columns(A</span><span class="s0">, </span><span class="s1">order)</span>
        <span class="s1">assert_equal(groups</span><span class="s0">, </span><span class="s1">groups_true)</span>

        <span class="s1">order = [</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span>
        <span class="s1">groups_true = np.array([</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">groups = group_columns(A</span><span class="s0">, </span><span class="s1">order)</span>
        <span class="s1">assert_equal(groups</span><span class="s0">, </span><span class="s1">groups_true)</span>

    <span class="s3"># Test repeatability.</span>
    <span class="s1">groups_1 = group_columns(A)</span>
    <span class="s1">groups_2 = group_columns(A)</span>
    <span class="s1">assert_equal(groups_1</span><span class="s0">, </span><span class="s1">groups_2)</span>


<span class="s0">def </span><span class="s1">test_correct_fp_eps():</span>
    <span class="s3"># check that relative step size is correct for FP size</span>
    <span class="s1">EPS = np.finfo(np.float64).eps</span>
    <span class="s1">relative_step = {</span><span class="s4">&quot;2-point&quot;</span><span class="s1">: EPS**</span><span class="s2">0.5</span><span class="s0">,</span>
                    <span class="s4">&quot;3-point&quot;</span><span class="s1">: EPS**(</span><span class="s2">1</span><span class="s1">/</span><span class="s2">3</span><span class="s1">)</span><span class="s0">,</span>
                     <span class="s4">&quot;cs&quot;</span><span class="s1">: EPS**</span><span class="s2">0.5</span><span class="s1">}</span>
    <span class="s0">for </span><span class="s1">method </span><span class="s0">in </span><span class="s1">[</span><span class="s4">'2-point'</span><span class="s0">, </span><span class="s4">'3-point'</span><span class="s0">, </span><span class="s4">'cs'</span><span class="s1">]:</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">_eps_for_method(np.float64</span><span class="s0">, </span><span class="s1">np.float64</span><span class="s0">, </span><span class="s1">method)</span><span class="s0">,</span>
            <span class="s1">relative_step[method])</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">_eps_for_method(np.complex128</span><span class="s0">, </span><span class="s1">np.complex128</span><span class="s0">, </span><span class="s1">method)</span><span class="s0">,</span>
            <span class="s1">relative_step[method]</span>
        <span class="s1">)</span>

    <span class="s3"># check another FP size</span>
    <span class="s1">EPS = np.finfo(np.float32).eps</span>
    <span class="s1">relative_step = {</span><span class="s4">&quot;2-point&quot;</span><span class="s1">: EPS**</span><span class="s2">0.5</span><span class="s0">,</span>
                    <span class="s4">&quot;3-point&quot;</span><span class="s1">: EPS**(</span><span class="s2">1</span><span class="s1">/</span><span class="s2">3</span><span class="s1">)</span><span class="s0">,</span>
                     <span class="s4">&quot;cs&quot;</span><span class="s1">: EPS**</span><span class="s2">0.5</span><span class="s1">}</span>

    <span class="s0">for </span><span class="s1">method </span><span class="s0">in </span><span class="s1">[</span><span class="s4">'2-point'</span><span class="s0">, </span><span class="s4">'3-point'</span><span class="s0">, </span><span class="s4">'cs'</span><span class="s1">]:</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">_eps_for_method(np.float64</span><span class="s0">, </span><span class="s1">np.float32</span><span class="s0">, </span><span class="s1">method)</span><span class="s0">,</span>
            <span class="s1">relative_step[method]</span>
        <span class="s1">)</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">_eps_for_method(np.float32</span><span class="s0">, </span><span class="s1">np.float64</span><span class="s0">, </span><span class="s1">method)</span><span class="s0">,</span>
            <span class="s1">relative_step[method]</span>
        <span class="s1">)</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">_eps_for_method(np.float32</span><span class="s0">, </span><span class="s1">np.float32</span><span class="s0">, </span><span class="s1">method)</span><span class="s0">,</span>
            <span class="s1">relative_step[method]</span>
        <span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestAdjustSchemeToBounds:</span>
    <span class="s0">def </span><span class="s1">test_no_bounds(self):</span>
        <span class="s1">x0 = np.zeros(</span><span class="s2">3</span><span class="s1">)</span>
        <span class="s1">h = np.full(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">1e-2</span><span class="s1">)</span>
        <span class="s1">inf_lower = np.empty_like(x0)</span>
        <span class="s1">inf_upper = np.empty_like(x0)</span>
        <span class="s1">inf_lower.fill(-np.inf)</span>
        <span class="s1">inf_upper.fill(np.inf)</span>

        <span class="s1">h_adjusted</span><span class="s0">, </span><span class="s1">one_sided = _adjust_scheme_to_bounds(</span>
            <span class="s1">x0</span><span class="s0">, </span><span class="s1">h</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s4">'1-sided'</span><span class="s0">, </span><span class="s1">inf_lower</span><span class="s0">, </span><span class="s1">inf_upper)</span>
        <span class="s1">assert_allclose(h_adjusted</span><span class="s0">, </span><span class="s1">h)</span>
        <span class="s1">assert_(np.all(one_sided))</span>

        <span class="s1">h_adjusted</span><span class="s0">, </span><span class="s1">one_sided = _adjust_scheme_to_bounds(</span>
            <span class="s1">x0</span><span class="s0">, </span><span class="s1">h</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s4">'1-sided'</span><span class="s0">, </span><span class="s1">inf_lower</span><span class="s0">, </span><span class="s1">inf_upper)</span>
        <span class="s1">assert_allclose(h_adjusted</span><span class="s0">, </span><span class="s1">h)</span>
        <span class="s1">assert_(np.all(one_sided))</span>

        <span class="s1">h_adjusted</span><span class="s0">, </span><span class="s1">one_sided = _adjust_scheme_to_bounds(</span>
            <span class="s1">x0</span><span class="s0">, </span><span class="s1">h</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s4">'2-sided'</span><span class="s0">, </span><span class="s1">inf_lower</span><span class="s0">, </span><span class="s1">inf_upper)</span>
        <span class="s1">assert_allclose(h_adjusted</span><span class="s0">, </span><span class="s1">h)</span>
        <span class="s1">assert_(np.all(~one_sided))</span>

        <span class="s1">h_adjusted</span><span class="s0">, </span><span class="s1">one_sided = _adjust_scheme_to_bounds(</span>
            <span class="s1">x0</span><span class="s0">, </span><span class="s1">h</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s4">'2-sided'</span><span class="s0">, </span><span class="s1">inf_lower</span><span class="s0">, </span><span class="s1">inf_upper)</span>
        <span class="s1">assert_allclose(h_adjusted</span><span class="s0">, </span><span class="s1">h)</span>
        <span class="s1">assert_(np.all(~one_sided))</span>

    <span class="s0">def </span><span class="s1">test_with_bound(self):</span>
        <span class="s1">x0 = np.array([</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.85</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.85</span><span class="s1">])</span>
        <span class="s1">lb = -np.ones(</span><span class="s2">3</span><span class="s1">)</span>
        <span class="s1">ub = np.ones(</span><span class="s2">3</span><span class="s1">)</span>
        <span class="s1">h = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]) * </span><span class="s2">1e-1</span>

        <span class="s1">h_adjusted</span><span class="s0">, </span><span class="s1">_ = _adjust_scheme_to_bounds(x0</span><span class="s0">, </span><span class="s1">h</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s4">'1-sided'</span><span class="s0">, </span><span class="s1">lb</span><span class="s0">, </span><span class="s1">ub)</span>
        <span class="s1">assert_allclose(h_adjusted</span><span class="s0">, </span><span class="s1">h)</span>

        <span class="s1">h_adjusted</span><span class="s0">, </span><span class="s1">_ = _adjust_scheme_to_bounds(x0</span><span class="s0">, </span><span class="s1">h</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s4">'1-sided'</span><span class="s0">, </span><span class="s1">lb</span><span class="s0">, </span><span class="s1">ub)</span>
        <span class="s1">assert_allclose(h_adjusted</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]) * </span><span class="s2">1e-1</span><span class="s1">)</span>

        <span class="s1">h_adjusted</span><span class="s0">, </span><span class="s1">one_sided = _adjust_scheme_to_bounds(</span>
            <span class="s1">x0</span><span class="s0">, </span><span class="s1">h</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s4">'2-sided'</span><span class="s0">, </span><span class="s1">lb</span><span class="s0">, </span><span class="s1">ub)</span>
        <span class="s1">assert_allclose(h_adjusted</span><span class="s0">, </span><span class="s1">np.abs(h))</span>
        <span class="s1">assert_(np.all(~one_sided))</span>

        <span class="s1">h_adjusted</span><span class="s0">, </span><span class="s1">one_sided = _adjust_scheme_to_bounds(</span>
            <span class="s1">x0</span><span class="s0">, </span><span class="s1">h</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s4">'2-sided'</span><span class="s0">, </span><span class="s1">lb</span><span class="s0">, </span><span class="s1">ub)</span>
        <span class="s1">assert_allclose(h_adjusted</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]) * </span><span class="s2">1e-1</span><span class="s1">)</span>
        <span class="s1">assert_equal(one_sided</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s0">False, True, True</span><span class="s1">]))</span>

    <span class="s0">def </span><span class="s1">test_tight_bounds(self):</span>
        <span class="s1">lb = np.array([-</span><span class="s2">0.03</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.03</span><span class="s1">])</span>
        <span class="s1">ub = np.array([</span><span class="s2">0.05</span><span class="s0">, </span><span class="s2">0.05</span><span class="s1">])</span>
        <span class="s1">x0 = np.array([</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.03</span><span class="s1">])</span>
        <span class="s1">h = np.array([-</span><span class="s2">0.1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.1</span><span class="s1">])</span>

        <span class="s1">h_adjusted</span><span class="s0">, </span><span class="s1">_ = _adjust_scheme_to_bounds(x0</span><span class="s0">, </span><span class="s1">h</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s4">'1-sided'</span><span class="s0">, </span><span class="s1">lb</span><span class="s0">, </span><span class="s1">ub)</span>
        <span class="s1">assert_allclose(h_adjusted</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">0.05</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.06</span><span class="s1">]))</span>

        <span class="s1">h_adjusted</span><span class="s0">, </span><span class="s1">_ = _adjust_scheme_to_bounds(x0</span><span class="s0">, </span><span class="s1">h</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s4">'1-sided'</span><span class="s0">, </span><span class="s1">lb</span><span class="s0">, </span><span class="s1">ub)</span>
        <span class="s1">assert_allclose(h_adjusted</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">0.025</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.03</span><span class="s1">]))</span>

        <span class="s1">h_adjusted</span><span class="s0">, </span><span class="s1">one_sided = _adjust_scheme_to_bounds(</span>
            <span class="s1">x0</span><span class="s0">, </span><span class="s1">h</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s4">'2-sided'</span><span class="s0">, </span><span class="s1">lb</span><span class="s0">, </span><span class="s1">ub)</span>
        <span class="s1">assert_allclose(h_adjusted</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">0.03</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.03</span><span class="s1">]))</span>
        <span class="s1">assert_equal(one_sided</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s0">False, True</span><span class="s1">]))</span>

        <span class="s1">h_adjusted</span><span class="s0">, </span><span class="s1">one_sided = _adjust_scheme_to_bounds(</span>
            <span class="s1">x0</span><span class="s0">, </span><span class="s1">h</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s4">'2-sided'</span><span class="s0">, </span><span class="s1">lb</span><span class="s0">, </span><span class="s1">ub)</span>
        <span class="s1">assert_allclose(h_adjusted</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">0.015</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.015</span><span class="s1">]))</span>
        <span class="s1">assert_equal(one_sided</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s0">False, True</span><span class="s1">]))</span>


<span class="s0">class </span><span class="s1">TestApproxDerivativesDense:</span>
    <span class="s0">def </span><span class="s1">fun_scalar_scalar(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s1">np.sinh(x)</span>

    <span class="s0">def </span><span class="s1">jac_scalar_scalar(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s1">np.cosh(x)</span>

    <span class="s0">def </span><span class="s1">fun_scalar_vector(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s1">np.array([x[</span><span class="s2">0</span><span class="s1">]**</span><span class="s2">2</span><span class="s0">, </span><span class="s1">np.tan(x[</span><span class="s2">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">np.exp(x[</span><span class="s2">0</span><span class="s1">])])</span>

    <span class="s0">def </span><span class="s1">jac_scalar_vector(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s1">np.array(</span>
            <span class="s1">[</span><span class="s2">2 </span><span class="s1">* x[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.cos(x[</span><span class="s2">0</span><span class="s1">]) ** -</span><span class="s2">2</span><span class="s0">, </span><span class="s1">np.exp(x[</span><span class="s2">0</span><span class="s1">])]).reshape(-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">fun_vector_scalar(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s1">np.sin(x[</span><span class="s2">0</span><span class="s1">] * x[</span><span class="s2">1</span><span class="s1">]) * np.log(x[</span><span class="s2">0</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">wrong_dimensions_fun(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s1">np.array([x**</span><span class="s2">2</span><span class="s0">, </span><span class="s1">np.tan(x)</span><span class="s0">, </span><span class="s1">np.exp(x)])</span>

    <span class="s0">def </span><span class="s1">jac_vector_scalar(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s1">np.array([</span>
            <span class="s1">x[</span><span class="s2">1</span><span class="s1">] * np.cos(x[</span><span class="s2">0</span><span class="s1">] * x[</span><span class="s2">1</span><span class="s1">]) * np.log(x[</span><span class="s2">0</span><span class="s1">]) +</span>
            <span class="s1">np.sin(x[</span><span class="s2">0</span><span class="s1">] * x[</span><span class="s2">1</span><span class="s1">]) / x[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">x[</span><span class="s2">0</span><span class="s1">] * np.cos(x[</span><span class="s2">0</span><span class="s1">] * x[</span><span class="s2">1</span><span class="s1">]) * np.log(x[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">])</span>

    <span class="s0">def </span><span class="s1">fun_vector_vector(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s1">np.array([</span>
            <span class="s1">x[</span><span class="s2">0</span><span class="s1">] * np.sin(x[</span><span class="s2">1</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">x[</span><span class="s2">1</span><span class="s1">] * np.cos(x[</span><span class="s2">0</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">x[</span><span class="s2">0</span><span class="s1">] ** </span><span class="s2">3 </span><span class="s1">* x[</span><span class="s2">1</span><span class="s1">] ** -</span><span class="s2">0.5</span>
        <span class="s1">])</span>

    <span class="s0">def </span><span class="s1">jac_vector_vector(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s1">np.array([</span>
            <span class="s1">[np.sin(x[</span><span class="s2">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">x[</span><span class="s2">0</span><span class="s1">] * np.cos(x[</span><span class="s2">1</span><span class="s1">])]</span><span class="s0">,</span>
            <span class="s1">[-x[</span><span class="s2">1</span><span class="s1">] * np.sin(x[</span><span class="s2">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">np.cos(x[</span><span class="s2">0</span><span class="s1">])]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">3 </span><span class="s1">* x[</span><span class="s2">0</span><span class="s1">] ** </span><span class="s2">2 </span><span class="s1">* x[</span><span class="s2">1</span><span class="s1">] ** -</span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.5 </span><span class="s1">* x[</span><span class="s2">0</span><span class="s1">] ** </span><span class="s2">3 </span><span class="s1">* x[</span><span class="s2">1</span><span class="s1">] ** -</span><span class="s2">1.5</span><span class="s1">]</span>
        <span class="s1">])</span>

    <span class="s0">def </span><span class="s1">fun_parametrized(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">c0</span><span class="s0">, </span><span class="s1">c1=</span><span class="s2">1.0</span><span class="s1">):</span>
        <span class="s0">return </span><span class="s1">np.array([np.exp(c0 * x[</span><span class="s2">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">np.exp(c1 * x[</span><span class="s2">1</span><span class="s1">])])</span>

    <span class="s0">def </span><span class="s1">jac_parametrized(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">c0</span><span class="s0">, </span><span class="s1">c1=</span><span class="s2">0.1</span><span class="s1">):</span>
        <span class="s0">return </span><span class="s1">np.array([</span>
            <span class="s1">[c0 * np.exp(c0 * x[</span><span class="s2">0</span><span class="s1">])</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s1">c1 * np.exp(c1 * x[</span><span class="s2">1</span><span class="s1">])]</span>
        <span class="s1">])</span>

    <span class="s0">def </span><span class="s1">fun_with_nan(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s1">x </span><span class="s0">if </span><span class="s1">np.abs(x) &lt;= </span><span class="s2">1e-8 </span><span class="s0">else </span><span class="s1">np.nan</span>

    <span class="s0">def </span><span class="s1">jac_with_nan(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s2">1.0 </span><span class="s0">if </span><span class="s1">np.abs(x) &lt;= </span><span class="s2">1e-8 </span><span class="s0">else </span><span class="s1">np.nan</span>

    <span class="s0">def </span><span class="s1">fun_zero_jacobian(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s1">np.array([x[</span><span class="s2">0</span><span class="s1">] * x[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.cos(x[</span><span class="s2">0</span><span class="s1">] * x[</span><span class="s2">1</span><span class="s1">])])</span>

    <span class="s0">def </span><span class="s1">jac_zero_jacobian(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s1">np.array([</span>
            <span class="s1">[x[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x[</span><span class="s2">0</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">[-x[</span><span class="s2">1</span><span class="s1">] * np.sin(x[</span><span class="s2">0</span><span class="s1">] * x[</span><span class="s2">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">-x[</span><span class="s2">0</span><span class="s1">] * np.sin(x[</span><span class="s2">0</span><span class="s1">] * x[</span><span class="s2">1</span><span class="s1">])]</span>
        <span class="s1">])</span>

    <span class="s0">def </span><span class="s1">jac_non_numpy(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s3"># x can be a scalar or an array [val].</span>
        <span class="s3"># Cast to true scalar before handing over to math.exp</span>
        <span class="s1">xp = np.asarray(x).item()</span>
        <span class="s0">return </span><span class="s1">math.exp(xp)</span>

    <span class="s0">def </span><span class="s1">test_scalar_scalar(self):</span>
        <span class="s1">x0 = </span><span class="s2">1.0</span>
        <span class="s1">jac_diff_2 = approx_derivative(self.fun_scalar_scalar</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                                       <span class="s1">method=</span><span class="s4">'2-point'</span><span class="s1">)</span>
        <span class="s1">jac_diff_3 = approx_derivative(self.fun_scalar_scalar</span><span class="s0">, </span><span class="s1">x0)</span>
        <span class="s1">jac_diff_4 = approx_derivative(self.fun_scalar_scalar</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                                       <span class="s1">method=</span><span class="s4">'cs'</span><span class="s1">)</span>
        <span class="s1">jac_true = self.jac_scalar_scalar(x0)</span>
        <span class="s1">assert_allclose(jac_diff_2</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(jac_diff_3</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-9</span><span class="s1">)</span>
        <span class="s1">assert_allclose(jac_diff_4</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-12</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_scalar_scalar_abs_step(self):</span>
        <span class="s3"># can approx_derivative use abs_step?</span>
        <span class="s1">x0 = </span><span class="s2">1.0</span>
        <span class="s1">jac_diff_2 = approx_derivative(self.fun_scalar_scalar</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                                       <span class="s1">method=</span><span class="s4">'2-point'</span><span class="s0">, </span><span class="s1">abs_step=</span><span class="s2">1.49e-8</span><span class="s1">)</span>
        <span class="s1">jac_diff_3 = approx_derivative(self.fun_scalar_scalar</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                                       <span class="s1">abs_step=</span><span class="s2">1.49e-8</span><span class="s1">)</span>
        <span class="s1">jac_diff_4 = approx_derivative(self.fun_scalar_scalar</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                                       <span class="s1">method=</span><span class="s4">'cs'</span><span class="s0">, </span><span class="s1">abs_step=</span><span class="s2">1.49e-8</span><span class="s1">)</span>
        <span class="s1">jac_true = self.jac_scalar_scalar(x0)</span>
        <span class="s1">assert_allclose(jac_diff_2</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(jac_diff_3</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-9</span><span class="s1">)</span>
        <span class="s1">assert_allclose(jac_diff_4</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-12</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_scalar_vector(self):</span>
        <span class="s1">x0 = </span><span class="s2">0.5</span>
        <span class="s1">jac_diff_2 = approx_derivative(self.fun_scalar_vector</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                                       <span class="s1">method=</span><span class="s4">'2-point'</span><span class="s1">)</span>
        <span class="s1">jac_diff_3 = approx_derivative(self.fun_scalar_vector</span><span class="s0">, </span><span class="s1">x0)</span>
        <span class="s1">jac_diff_4 = approx_derivative(self.fun_scalar_vector</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                                       <span class="s1">method=</span><span class="s4">'cs'</span><span class="s1">)</span>
        <span class="s1">jac_true = self.jac_scalar_vector(np.atleast_1d(x0))</span>
        <span class="s1">assert_allclose(jac_diff_2</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(jac_diff_3</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-9</span><span class="s1">)</span>
        <span class="s1">assert_allclose(jac_diff_4</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-12</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_vector_scalar(self):</span>
        <span class="s1">x0 = np.array([</span><span class="s2">100.0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.5</span><span class="s1">])</span>
        <span class="s1">jac_diff_2 = approx_derivative(self.fun_vector_scalar</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                                       <span class="s1">method=</span><span class="s4">'2-point'</span><span class="s1">)</span>
        <span class="s1">jac_diff_3 = approx_derivative(self.fun_vector_scalar</span><span class="s0">, </span><span class="s1">x0)</span>
        <span class="s1">jac_diff_4 = approx_derivative(self.fun_vector_scalar</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                                       <span class="s1">method=</span><span class="s4">'cs'</span><span class="s1">)</span>
        <span class="s1">jac_true = self.jac_vector_scalar(x0)</span>
        <span class="s1">assert_allclose(jac_diff_2</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(jac_diff_3</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-7</span><span class="s1">)</span>
        <span class="s1">assert_allclose(jac_diff_4</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-12</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_vector_scalar_abs_step(self):</span>
        <span class="s3"># can approx_derivative use abs_step?</span>
        <span class="s1">x0 = np.array([</span><span class="s2">100.0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.5</span><span class="s1">])</span>
        <span class="s1">jac_diff_2 = approx_derivative(self.fun_vector_scalar</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                                       <span class="s1">method=</span><span class="s4">'2-point'</span><span class="s0">, </span><span class="s1">abs_step=</span><span class="s2">1.49e-8</span><span class="s1">)</span>
        <span class="s1">jac_diff_3 = approx_derivative(self.fun_vector_scalar</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                                       <span class="s1">abs_step=</span><span class="s2">1.49e-8</span><span class="s0">, </span><span class="s1">rel_step=np.inf)</span>
        <span class="s1">jac_diff_4 = approx_derivative(self.fun_vector_scalar</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                                       <span class="s1">method=</span><span class="s4">'cs'</span><span class="s0">, </span><span class="s1">abs_step=</span><span class="s2">1.49e-8</span><span class="s1">)</span>
        <span class="s1">jac_true = self.jac_vector_scalar(x0)</span>
        <span class="s1">assert_allclose(jac_diff_2</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(jac_diff_3</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">3e-9</span><span class="s1">)</span>
        <span class="s1">assert_allclose(jac_diff_4</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-12</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_vector_vector(self):</span>
        <span class="s1">x0 = np.array([-</span><span class="s2">100.0</span><span class="s0">, </span><span class="s2">0.2</span><span class="s1">])</span>
        <span class="s1">jac_diff_2 = approx_derivative(self.fun_vector_vector</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                                       <span class="s1">method=</span><span class="s4">'2-point'</span><span class="s1">)</span>
        <span class="s1">jac_diff_3 = approx_derivative(self.fun_vector_vector</span><span class="s0">, </span><span class="s1">x0)</span>
        <span class="s1">jac_diff_4 = approx_derivative(self.fun_vector_vector</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                                       <span class="s1">method=</span><span class="s4">'cs'</span><span class="s1">)</span>
        <span class="s1">jac_true = self.jac_vector_vector(x0)</span>
        <span class="s1">assert_allclose(jac_diff_2</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-5</span><span class="s1">)</span>
        <span class="s1">assert_allclose(jac_diff_3</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(jac_diff_4</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-12</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_wrong_dimensions(self):</span>
        <span class="s1">x0 = </span><span class="s2">1.0</span>
        <span class="s1">assert_raises(RuntimeError</span><span class="s0">, </span><span class="s1">approx_derivative</span><span class="s0">,</span>
                      <span class="s1">self.wrong_dimensions_fun</span><span class="s0">, </span><span class="s1">x0)</span>
        <span class="s1">f0 = self.wrong_dimensions_fun(np.atleast_1d(x0))</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">approx_derivative</span><span class="s0">,</span>
                      <span class="s1">self.wrong_dimensions_fun</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">f0=f0)</span>

    <span class="s0">def </span><span class="s1">test_custom_rel_step(self):</span>
        <span class="s1">x0 = np.array([-</span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">0.1</span><span class="s1">])</span>
        <span class="s1">jac_diff_2 = approx_derivative(self.fun_vector_vector</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                                       <span class="s1">method=</span><span class="s4">'2-point'</span><span class="s0">, </span><span class="s1">rel_step=</span><span class="s2">1e-4</span><span class="s1">)</span>
        <span class="s1">jac_diff_3 = approx_derivative(self.fun_vector_vector</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                                       <span class="s1">rel_step=</span><span class="s2">1e-4</span><span class="s1">)</span>
        <span class="s1">jac_true = self.jac_vector_vector(x0)</span>
        <span class="s1">assert_allclose(jac_diff_2</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-2</span><span class="s1">)</span>
        <span class="s1">assert_allclose(jac_diff_3</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-4</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_options(self):</span>
        <span class="s1">x0 = np.array([</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">c0 = -</span><span class="s2">1.0</span>
        <span class="s1">c1 = </span><span class="s2">1.0</span>
        <span class="s1">lb = </span><span class="s2">0.0</span>
        <span class="s1">ub = </span><span class="s2">2.0</span>
        <span class="s1">f0 = self.fun_parametrized(x0</span><span class="s0">, </span><span class="s1">c0</span><span class="s0">, </span><span class="s1">c1=c1)</span>
        <span class="s1">rel_step = np.array([-</span><span class="s2">1e-6</span><span class="s0">, </span><span class="s2">1e-7</span><span class="s1">])</span>
        <span class="s1">jac_true = self.jac_parametrized(x0</span><span class="s0">, </span><span class="s1">c0</span><span class="s0">, </span><span class="s1">c1)</span>
        <span class="s1">jac_diff_2 = approx_derivative(</span>
            <span class="s1">self.fun_parametrized</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'2-point'</span><span class="s0">, </span><span class="s1">rel_step=rel_step</span><span class="s0">,</span>
            <span class="s1">f0=f0</span><span class="s0">, </span><span class="s1">args=(c0</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">kwargs=dict(c1=c1)</span><span class="s0">, </span><span class="s1">bounds=(lb</span><span class="s0">, </span><span class="s1">ub))</span>
        <span class="s1">jac_diff_3 = approx_derivative(</span>
            <span class="s1">self.fun_parametrized</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">rel_step=rel_step</span><span class="s0">,</span>
            <span class="s1">f0=f0</span><span class="s0">, </span><span class="s1">args=(c0</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">kwargs=dict(c1=c1)</span><span class="s0">, </span><span class="s1">bounds=(lb</span><span class="s0">, </span><span class="s1">ub))</span>
        <span class="s1">assert_allclose(jac_diff_2</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(jac_diff_3</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-9</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_with_bounds_2_point(self):</span>
        <span class="s1">lb = -np.ones(</span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">ub = np.ones(</span><span class="s2">2</span><span class="s1">)</span>

        <span class="s1">x0 = np.array([-</span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">0.2</span><span class="s1">])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">approx_derivative</span><span class="s0">,</span>
                      <span class="s1">self.fun_vector_vector</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">bounds=(lb</span><span class="s0">, </span><span class="s1">ub))</span>

        <span class="s1">x0 = np.array([-</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">jac_diff = approx_derivative(self.fun_vector_vector</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                                     <span class="s1">method=</span><span class="s4">'2-point'</span><span class="s0">, </span><span class="s1">bounds=(lb</span><span class="s0">, </span><span class="s1">ub))</span>
        <span class="s1">jac_true = self.jac_vector_vector(x0)</span>
        <span class="s1">assert_allclose(jac_diff</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-6</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_with_bounds_3_point(self):</span>
        <span class="s1">lb = np.array([</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">ub = np.array([</span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s1">])</span>

        <span class="s1">x0 = np.array([</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s1">])</span>
        <span class="s1">jac_true = self.jac_vector_vector(x0)</span>

        <span class="s1">jac_diff = approx_derivative(self.fun_vector_vector</span><span class="s0">, </span><span class="s1">x0)</span>
        <span class="s1">assert_allclose(jac_diff</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-9</span><span class="s1">)</span>

        <span class="s1">jac_diff = approx_derivative(self.fun_vector_vector</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                                     <span class="s1">bounds=(lb</span><span class="s0">, </span><span class="s1">np.inf))</span>
        <span class="s1">assert_allclose(jac_diff</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-9</span><span class="s1">)</span>

        <span class="s1">jac_diff = approx_derivative(self.fun_vector_vector</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                                     <span class="s1">bounds=(-np.inf</span><span class="s0">, </span><span class="s1">ub))</span>
        <span class="s1">assert_allclose(jac_diff</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-9</span><span class="s1">)</span>

        <span class="s1">jac_diff = approx_derivative(self.fun_vector_vector</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                                     <span class="s1">bounds=(lb</span><span class="s0">, </span><span class="s1">ub))</span>
        <span class="s1">assert_allclose(jac_diff</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-9</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_tight_bounds(self):</span>
        <span class="s1">x0 = np.array([</span><span class="s2">10.0</span><span class="s0">, </span><span class="s2">10.0</span><span class="s1">])</span>
        <span class="s1">lb = x0 - </span><span class="s2">3e-9</span>
        <span class="s1">ub = x0 + </span><span class="s2">2e-9</span>
        <span class="s1">jac_true = self.jac_vector_vector(x0)</span>
        <span class="s1">jac_diff = approx_derivative(</span>
            <span class="s1">self.fun_vector_vector</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'2-point'</span><span class="s0">, </span><span class="s1">bounds=(lb</span><span class="s0">, </span><span class="s1">ub))</span>
        <span class="s1">assert_allclose(jac_diff</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-6</span><span class="s1">)</span>
        <span class="s1">jac_diff = approx_derivative(</span>
            <span class="s1">self.fun_vector_vector</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'2-point'</span><span class="s0">,</span>
            <span class="s1">rel_step=</span><span class="s2">1e-6</span><span class="s0">, </span><span class="s1">bounds=(lb</span><span class="s0">, </span><span class="s1">ub))</span>
        <span class="s1">assert_allclose(jac_diff</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-6</span><span class="s1">)</span>

        <span class="s1">jac_diff = approx_derivative(</span>
            <span class="s1">self.fun_vector_vector</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">bounds=(lb</span><span class="s0">, </span><span class="s1">ub))</span>
        <span class="s1">assert_allclose(jac_diff</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-6</span><span class="s1">)</span>
        <span class="s1">jac_diff = approx_derivative(</span>
            <span class="s1">self.fun_vector_vector</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">rel_step=</span><span class="s2">1e-6</span><span class="s0">, </span><span class="s1">bounds=(lb</span><span class="s0">, </span><span class="s1">ub))</span>
        <span class="s1">assert_allclose(jac_true</span><span class="s0">, </span><span class="s1">jac_diff</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-6</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_bound_switches(self):</span>
        <span class="s1">lb = -</span><span class="s2">1e-8</span>
        <span class="s1">ub = </span><span class="s2">1e-8</span>
        <span class="s1">x0 = </span><span class="s2">0.0</span>
        <span class="s1">jac_true = self.jac_with_nan(x0)</span>
        <span class="s1">jac_diff_2 = approx_derivative(</span>
            <span class="s1">self.fun_with_nan</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'2-point'</span><span class="s0">, </span><span class="s1">rel_step=</span><span class="s2">1e-6</span><span class="s0">,</span>
            <span class="s1">bounds=(lb</span><span class="s0">, </span><span class="s1">ub))</span>
        <span class="s1">jac_diff_3 = approx_derivative(</span>
            <span class="s1">self.fun_with_nan</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">rel_step=</span><span class="s2">1e-6</span><span class="s0">, </span><span class="s1">bounds=(lb</span><span class="s0">, </span><span class="s1">ub))</span>
        <span class="s1">assert_allclose(jac_diff_2</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(jac_diff_3</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-9</span><span class="s1">)</span>

        <span class="s1">x0 = </span><span class="s2">1e-8</span>
        <span class="s1">jac_true = self.jac_with_nan(x0)</span>
        <span class="s1">jac_diff_2 = approx_derivative(</span>
            <span class="s1">self.fun_with_nan</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'2-point'</span><span class="s0">, </span><span class="s1">rel_step=</span><span class="s2">1e-6</span><span class="s0">,</span>
            <span class="s1">bounds=(lb</span><span class="s0">, </span><span class="s1">ub))</span>
        <span class="s1">jac_diff_3 = approx_derivative(</span>
            <span class="s1">self.fun_with_nan</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">rel_step=</span><span class="s2">1e-6</span><span class="s0">, </span><span class="s1">bounds=(lb</span><span class="s0">, </span><span class="s1">ub))</span>
        <span class="s1">assert_allclose(jac_diff_2</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(jac_diff_3</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-9</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_non_numpy(self):</span>
        <span class="s1">x0 = </span><span class="s2">1.0</span>
        <span class="s1">jac_true = self.jac_non_numpy(x0)</span>
        <span class="s1">jac_diff_2 = approx_derivative(self.jac_non_numpy</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                                       <span class="s1">method=</span><span class="s4">'2-point'</span><span class="s1">)</span>
        <span class="s1">jac_diff_3 = approx_derivative(self.jac_non_numpy</span><span class="s0">, </span><span class="s1">x0)</span>
        <span class="s1">assert_allclose(jac_diff_2</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(jac_diff_3</span><span class="s0">, </span><span class="s1">jac_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-8</span><span class="s1">)</span>

        <span class="s3"># math.exp cannot handle complex arguments, hence this raises</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">approx_derivative</span><span class="s0">, </span><span class="s1">self.jac_non_numpy</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                      <span class="s1">**dict(method=</span><span class="s4">'cs'</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_fp(self):</span>
        <span class="s3"># checks that approx_derivative works for FP size other than 64.</span>
        <span class="s3"># Example is derived from the minimal working example in gh12991.</span>
        <span class="s1">np.random.seed(</span><span class="s2">1</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">func(p</span><span class="s0">, </span><span class="s1">x):</span>
            <span class="s0">return </span><span class="s1">p[</span><span class="s2">0</span><span class="s1">] + p[</span><span class="s2">1</span><span class="s1">] * x</span>

        <span class="s0">def </span><span class="s1">err(p</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y):</span>
            <span class="s0">return </span><span class="s1">func(p</span><span class="s0">, </span><span class="s1">x) - y</span>

        <span class="s1">x = np.linspace(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">100</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">y = np.random.random(</span><span class="s2">100</span><span class="s1">).astype(np.float64)</span>
        <span class="s1">p0 = np.array([-</span><span class="s2">1.0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.0</span><span class="s1">])</span>

        <span class="s1">jac_fp64 = approx_derivative(err</span><span class="s0">, </span><span class="s1">p0</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'2-point'</span><span class="s0">, </span><span class="s1">args=(x</span><span class="s0">, </span><span class="s1">y))</span>

        <span class="s3"># parameter vector is float32, func output is float64</span>
        <span class="s1">jac_fp = approx_derivative(err</span><span class="s0">, </span><span class="s1">p0.astype(np.float32)</span><span class="s0">,</span>
                                   <span class="s1">method=</span><span class="s4">'2-point'</span><span class="s0">, </span><span class="s1">args=(x</span><span class="s0">, </span><span class="s1">y))</span>
        <span class="s0">assert </span><span class="s1">err(p0</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y).dtype == np.float64</span>
        <span class="s1">assert_allclose(jac_fp</span><span class="s0">, </span><span class="s1">jac_fp64</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-3</span><span class="s1">)</span>

        <span class="s3"># parameter vector is float64, func output is float32</span>
        <span class="s0">def </span><span class="s1">err_fp32(p):</span>
            <span class="s0">return </span><span class="s1">err(p</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y).astype(np.float32)</span>
        <span class="s1">jac_fp = approx_derivative(err_fp32</span><span class="s0">, </span><span class="s1">p0</span><span class="s0">,</span>
                                   <span class="s1">method=</span><span class="s4">'2-point'</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">err_fp32(p0).dtype == np.float32</span>
        <span class="s1">assert_allclose(jac_fp</span><span class="s0">, </span><span class="s1">jac_fp64</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-3</span><span class="s1">)</span>

        <span class="s3"># check upper bound of error on the derivative for 2-point</span>
        <span class="s0">def </span><span class="s1">f(x):</span>
            <span class="s0">return </span><span class="s1">np.sin(x)</span>
        <span class="s0">def </span><span class="s1">g(x):</span>
            <span class="s0">return </span><span class="s1">np.cos(x)</span>
        <span class="s0">def </span><span class="s1">hess(x):</span>
            <span class="s0">return </span><span class="s1">-np.sin(x)</span>

        <span class="s0">def </span><span class="s1">calc_atol(h</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">hess</span><span class="s0">, </span><span class="s1">EPS):</span>
            <span class="s3"># truncation error</span>
            <span class="s1">t0 = h / </span><span class="s2">2 </span><span class="s1">* max(np.abs(hess(x0))</span><span class="s0">, </span><span class="s1">np.abs(hess(x0 + h)))</span>
            <span class="s3"># roundoff error. There may be a divisor (&gt;1) missing from</span>
            <span class="s3"># the following line, so this contribution is possibly</span>
            <span class="s3"># overestimated</span>
            <span class="s1">t1 = EPS / h * max(np.abs(f(x0))</span><span class="s0">, </span><span class="s1">np.abs(f(x0 + h)))</span>
            <span class="s0">return </span><span class="s1">t0 + t1</span>

        <span class="s0">for </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">[np.float16</span><span class="s0">, </span><span class="s1">np.float32</span><span class="s0">, </span><span class="s1">np.float64]:</span>
            <span class="s1">EPS = np.finfo(dtype).eps</span>
            <span class="s1">x0 = np.array(</span><span class="s2">1.0</span><span class="s1">).astype(dtype)</span>
            <span class="s1">h = _compute_absolute_step(</span><span class="s0">None, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">f(x0)</span><span class="s0">, </span><span class="s4">'2-point'</span><span class="s1">)</span>
            <span class="s1">atol = calc_atol(h</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">hess</span><span class="s0">, </span><span class="s1">EPS)</span>
            <span class="s1">err = approx_derivative(f</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'2-point'</span><span class="s0">,</span>
                                    <span class="s1">abs_step=h) - g(x0)</span>
            <span class="s0">assert </span><span class="s1">abs(err) &lt; atol</span>

    <span class="s0">def </span><span class="s1">test_check_derivative(self):</span>
        <span class="s1">x0 = np.array([-</span><span class="s2">10.0</span><span class="s0">, </span><span class="s2">10</span><span class="s1">])</span>
        <span class="s1">accuracy = check_derivative(self.fun_vector_vector</span><span class="s0">,</span>
                                    <span class="s1">self.jac_vector_vector</span><span class="s0">, </span><span class="s1">x0)</span>
        <span class="s1">assert_(accuracy &lt; </span><span class="s2">1e-9</span><span class="s1">)</span>
        <span class="s1">accuracy = check_derivative(self.fun_vector_vector</span><span class="s0">,</span>
                                    <span class="s1">self.jac_vector_vector</span><span class="s0">, </span><span class="s1">x0)</span>
        <span class="s1">assert_(accuracy &lt; </span><span class="s2">1e-6</span><span class="s1">)</span>

        <span class="s1">x0 = np.array([</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">])</span>
        <span class="s1">accuracy = check_derivative(self.fun_zero_jacobian</span><span class="s0">,</span>
                                    <span class="s1">self.jac_zero_jacobian</span><span class="s0">, </span><span class="s1">x0)</span>
        <span class="s1">assert_(accuracy == </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">accuracy = check_derivative(self.fun_zero_jacobian</span><span class="s0">,</span>
                                    <span class="s1">self.jac_zero_jacobian</span><span class="s0">, </span><span class="s1">x0)</span>
        <span class="s1">assert_(accuracy == </span><span class="s2">0</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestApproxDerivativeSparse:</span>
    <span class="s3"># Example from Numerical Optimization 2nd edition, p. 198.</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">np.random.seed(</span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">self.n = </span><span class="s2">50</span>
        <span class="s1">self.lb = -</span><span class="s2">0.1 </span><span class="s1">* (</span><span class="s2">1 </span><span class="s1">+ np.arange(self.n))</span>
        <span class="s1">self.ub = </span><span class="s2">0.1 </span><span class="s1">* (</span><span class="s2">1 </span><span class="s1">+ np.arange(self.n))</span>
        <span class="s1">self.x0 = np.empty(self.n)</span>
        <span class="s1">self.x0[::</span><span class="s2">2</span><span class="s1">] = (</span><span class="s2">1 </span><span class="s1">- </span><span class="s2">1e-7</span><span class="s1">) * self.lb[::</span><span class="s2">2</span><span class="s1">]</span>
        <span class="s1">self.x0[</span><span class="s2">1</span><span class="s1">::</span><span class="s2">2</span><span class="s1">] = (</span><span class="s2">1 </span><span class="s1">- </span><span class="s2">1e-7</span><span class="s1">) * self.ub[</span><span class="s2">1</span><span class="s1">::</span><span class="s2">2</span><span class="s1">]</span>

        <span class="s1">self.J_true = self.jac(self.x0)</span>

    <span class="s0">def </span><span class="s1">fun(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s1">e = x[</span><span class="s2">1</span><span class="s1">:]**</span><span class="s2">3 </span><span class="s1">- x[:-</span><span class="s2">1</span><span class="s1">]**</span><span class="s2">2</span>
        <span class="s0">return </span><span class="s1">np.hstack((</span><span class="s2">0</span><span class="s0">, </span><span class="s2">3 </span><span class="s1">* e)) + np.hstack((</span><span class="s2">2 </span><span class="s1">* e</span><span class="s0">, </span><span class="s2">0</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">jac(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s1">n = x.size</span>
        <span class="s1">J = np.zeros((n</span><span class="s0">, </span><span class="s1">n))</span>
        <span class="s1">J[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">] = -</span><span class="s2">4 </span><span class="s1">* x[</span><span class="s2">0</span><span class="s1">]</span>
        <span class="s1">J[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">] = </span><span class="s2">6 </span><span class="s1">* x[</span><span class="s2">1</span><span class="s1">]**</span><span class="s2">2</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">n - </span><span class="s2">1</span><span class="s1">):</span>
            <span class="s1">J[i</span><span class="s0">, </span><span class="s1">i - </span><span class="s2">1</span><span class="s1">] = -</span><span class="s2">6 </span><span class="s1">* x[i-</span><span class="s2">1</span><span class="s1">]</span>
            <span class="s1">J[i</span><span class="s0">, </span><span class="s1">i] = </span><span class="s2">9 </span><span class="s1">* x[i]**</span><span class="s2">2 </span><span class="s1">- </span><span class="s2">4 </span><span class="s1">* x[i]</span>
            <span class="s1">J[i</span><span class="s0">, </span><span class="s1">i + </span><span class="s2">1</span><span class="s1">] = </span><span class="s2">6 </span><span class="s1">* x[i+</span><span class="s2">1</span><span class="s1">]**</span><span class="s2">2</span>
        <span class="s1">J[-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">] = </span><span class="s2">9 </span><span class="s1">* x[-</span><span class="s2">1</span><span class="s1">]**</span><span class="s2">2</span>
        <span class="s1">J[-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s1">] = -</span><span class="s2">6 </span><span class="s1">* x[-</span><span class="s2">2</span><span class="s1">]</span>

        <span class="s0">return </span><span class="s1">J</span>

    <span class="s0">def </span><span class="s1">structure(self</span><span class="s0">, </span><span class="s1">n):</span>
        <span class="s1">A = np.zeros((n</span><span class="s0">, </span><span class="s1">n)</span><span class="s0">, </span><span class="s1">dtype=int)</span>
        <span class="s1">A[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">] = </span><span class="s2">1</span>
        <span class="s1">A[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">] = </span><span class="s2">1</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">n - </span><span class="s2">1</span><span class="s1">):</span>
            <span class="s1">A[i</span><span class="s0">, </span><span class="s1">i - </span><span class="s2">1</span><span class="s1">: i + </span><span class="s2">2</span><span class="s1">] = </span><span class="s2">1</span>
        <span class="s1">A[-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">] = </span><span class="s2">1</span>
        <span class="s1">A[-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s1">] = </span><span class="s2">1</span>

        <span class="s0">return </span><span class="s1">A</span>

    <span class="s0">def </span><span class="s1">test_all(self):</span>
        <span class="s1">A = self.structure(self.n)</span>
        <span class="s1">order = np.arange(self.n)</span>
        <span class="s1">groups_1 = group_columns(A</span><span class="s0">, </span><span class="s1">order)</span>
        <span class="s1">np.random.shuffle(order)</span>
        <span class="s1">groups_2 = group_columns(A</span><span class="s0">, </span><span class="s1">order)</span>

        <span class="s0">for </span><span class="s1">method</span><span class="s0">, </span><span class="s1">groups</span><span class="s0">, </span><span class="s1">l</span><span class="s0">, </span><span class="s1">u </span><span class="s0">in </span><span class="s1">product(</span>
                <span class="s1">[</span><span class="s4">'2-point'</span><span class="s0">, </span><span class="s4">'3-point'</span><span class="s0">, </span><span class="s4">'cs'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[groups_1</span><span class="s0">, </span><span class="s1">groups_2]</span><span class="s0">,</span>
                <span class="s1">[-np.inf</span><span class="s0">, </span><span class="s1">self.lb]</span><span class="s0">, </span><span class="s1">[np.inf</span><span class="s0">, </span><span class="s1">self.ub]):</span>
            <span class="s1">J = approx_derivative(self.fun</span><span class="s0">, </span><span class="s1">self.x0</span><span class="s0">, </span><span class="s1">method=method</span><span class="s0">,</span>
                                  <span class="s1">bounds=(l</span><span class="s0">, </span><span class="s1">u)</span><span class="s0">, </span><span class="s1">sparsity=(A</span><span class="s0">, </span><span class="s1">groups))</span>
            <span class="s1">assert_(isinstance(J</span><span class="s0">, </span><span class="s1">csr_matrix))</span>
            <span class="s1">assert_allclose(J.toarray()</span><span class="s0">, </span><span class="s1">self.J_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-6</span><span class="s1">)</span>

            <span class="s1">rel_step = np.full_like(self.x0</span><span class="s0">, </span><span class="s2">1e-8</span><span class="s1">)</span>
            <span class="s1">rel_step[::</span><span class="s2">2</span><span class="s1">] *= -</span><span class="s2">1</span>
            <span class="s1">J = approx_derivative(self.fun</span><span class="s0">, </span><span class="s1">self.x0</span><span class="s0">, </span><span class="s1">method=method</span><span class="s0">,</span>
                                  <span class="s1">rel_step=rel_step</span><span class="s0">, </span><span class="s1">sparsity=(A</span><span class="s0">, </span><span class="s1">groups))</span>
            <span class="s1">assert_allclose(J.toarray()</span><span class="s0">, </span><span class="s1">self.J_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-5</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_no_precomputed_groups(self):</span>
        <span class="s1">A = self.structure(self.n)</span>
        <span class="s1">J = approx_derivative(self.fun</span><span class="s0">, </span><span class="s1">self.x0</span><span class="s0">, </span><span class="s1">sparsity=A)</span>
        <span class="s1">assert_allclose(J.toarray()</span><span class="s0">, </span><span class="s1">self.J_true</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-6</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_equivalence(self):</span>
        <span class="s1">structure = np.ones((self.n</span><span class="s0">, </span><span class="s1">self.n)</span><span class="s0">, </span><span class="s1">dtype=int)</span>
        <span class="s1">groups = np.arange(self.n)</span>
        <span class="s0">for </span><span class="s1">method </span><span class="s0">in </span><span class="s1">[</span><span class="s4">'2-point'</span><span class="s0">, </span><span class="s4">'3-point'</span><span class="s0">, </span><span class="s4">'cs'</span><span class="s1">]:</span>
            <span class="s1">J_dense = approx_derivative(self.fun</span><span class="s0">, </span><span class="s1">self.x0</span><span class="s0">, </span><span class="s1">method=method)</span>
            <span class="s1">J_sparse = approx_derivative(</span>
                <span class="s1">self.fun</span><span class="s0">, </span><span class="s1">self.x0</span><span class="s0">, </span><span class="s1">sparsity=(structure</span><span class="s0">, </span><span class="s1">groups)</span><span class="s0">, </span><span class="s1">method=method)</span>
            <span class="s1">assert_allclose(J_dense</span><span class="s0">, </span><span class="s1">J_sparse.toarray()</span><span class="s0">,</span>
                            <span class="s1">rtol=</span><span class="s2">5e-16</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">7e-15</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_check_derivative(self):</span>
        <span class="s0">def </span><span class="s1">jac(x):</span>
            <span class="s0">return </span><span class="s1">csr_matrix(self.jac(x))</span>

        <span class="s1">accuracy = check_derivative(self.fun</span><span class="s0">, </span><span class="s1">jac</span><span class="s0">, </span><span class="s1">self.x0</span><span class="s0">,</span>
                                    <span class="s1">bounds=(self.lb</span><span class="s0">, </span><span class="s1">self.ub))</span>
        <span class="s1">assert_(accuracy &lt; </span><span class="s2">1e-9</span><span class="s1">)</span>

        <span class="s1">accuracy = check_derivative(self.fun</span><span class="s0">, </span><span class="s1">jac</span><span class="s0">, </span><span class="s1">self.x0</span><span class="s0">,</span>
                                    <span class="s1">bounds=(self.lb</span><span class="s0">, </span><span class="s1">self.ub))</span>
        <span class="s1">assert_(accuracy &lt; </span><span class="s2">1e-9</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestApproxDerivativeLinearOperator:</span>

    <span class="s0">def </span><span class="s1">fun_scalar_scalar(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s1">np.sinh(x)</span>

    <span class="s0">def </span><span class="s1">jac_scalar_scalar(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s1">np.cosh(x)</span>

    <span class="s0">def </span><span class="s1">fun_scalar_vector(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s1">np.array([x[</span><span class="s2">0</span><span class="s1">]**</span><span class="s2">2</span><span class="s0">, </span><span class="s1">np.tan(x[</span><span class="s2">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">np.exp(x[</span><span class="s2">0</span><span class="s1">])])</span>

    <span class="s0">def </span><span class="s1">jac_scalar_vector(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s1">np.array(</span>
            <span class="s1">[</span><span class="s2">2 </span><span class="s1">* x[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.cos(x[</span><span class="s2">0</span><span class="s1">]) ** -</span><span class="s2">2</span><span class="s0">, </span><span class="s1">np.exp(x[</span><span class="s2">0</span><span class="s1">])]).reshape(-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">fun_vector_scalar(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s1">np.sin(x[</span><span class="s2">0</span><span class="s1">] * x[</span><span class="s2">1</span><span class="s1">]) * np.log(x[</span><span class="s2">0</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">jac_vector_scalar(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s1">np.array([</span>
            <span class="s1">x[</span><span class="s2">1</span><span class="s1">] * np.cos(x[</span><span class="s2">0</span><span class="s1">] * x[</span><span class="s2">1</span><span class="s1">]) * np.log(x[</span><span class="s2">0</span><span class="s1">]) +</span>
            <span class="s1">np.sin(x[</span><span class="s2">0</span><span class="s1">] * x[</span><span class="s2">1</span><span class="s1">]) / x[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">x[</span><span class="s2">0</span><span class="s1">] * np.cos(x[</span><span class="s2">0</span><span class="s1">] * x[</span><span class="s2">1</span><span class="s1">]) * np.log(x[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">])</span>

    <span class="s0">def </span><span class="s1">fun_vector_vector(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s1">np.array([</span>
            <span class="s1">x[</span><span class="s2">0</span><span class="s1">] * np.sin(x[</span><span class="s2">1</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">x[</span><span class="s2">1</span><span class="s1">] * np.cos(x[</span><span class="s2">0</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">x[</span><span class="s2">0</span><span class="s1">] ** </span><span class="s2">3 </span><span class="s1">* x[</span><span class="s2">1</span><span class="s1">] ** -</span><span class="s2">0.5</span>
        <span class="s1">])</span>

    <span class="s0">def </span><span class="s1">jac_vector_vector(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s1">np.array([</span>
            <span class="s1">[np.sin(x[</span><span class="s2">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">x[</span><span class="s2">0</span><span class="s1">] * np.cos(x[</span><span class="s2">1</span><span class="s1">])]</span><span class="s0">,</span>
            <span class="s1">[-x[</span><span class="s2">1</span><span class="s1">] * np.sin(x[</span><span class="s2">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">np.cos(x[</span><span class="s2">0</span><span class="s1">])]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">3 </span><span class="s1">* x[</span><span class="s2">0</span><span class="s1">] ** </span><span class="s2">2 </span><span class="s1">* x[</span><span class="s2">1</span><span class="s1">] ** -</span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.5 </span><span class="s1">* x[</span><span class="s2">0</span><span class="s1">] ** </span><span class="s2">3 </span><span class="s1">* x[</span><span class="s2">1</span><span class="s1">] ** -</span><span class="s2">1.5</span><span class="s1">]</span>
        <span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_scalar_scalar(self):</span>
        <span class="s1">x0 = </span><span class="s2">1.0</span>
        <span class="s1">jac_diff_2 = approx_derivative(self.fun_scalar_scalar</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                                       <span class="s1">method=</span><span class="s4">'2-point'</span><span class="s0">,</span>
                                       <span class="s1">as_linear_operator=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">jac_diff_3 = approx_derivative(self.fun_scalar_scalar</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                                       <span class="s1">as_linear_operator=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">jac_diff_4 = approx_derivative(self.fun_scalar_scalar</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                                       <span class="s1">method=</span><span class="s4">'cs'</span><span class="s0">,</span>
                                       <span class="s1">as_linear_operator=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">jac_true = self.jac_scalar_scalar(x0)</span>
        <span class="s1">np.random.seed(</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">10</span><span class="s1">):</span>
            <span class="s1">p = np.random.uniform(-</span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s1">size=(</span><span class="s2">1</span><span class="s0">,</span><span class="s1">))</span>
            <span class="s1">assert_allclose(jac_diff_2.dot(p)</span><span class="s0">, </span><span class="s1">jac_true*p</span><span class="s0">,</span>
                            <span class="s1">rtol=</span><span class="s2">1e-5</span><span class="s1">)</span>
            <span class="s1">assert_allclose(jac_diff_3.dot(p)</span><span class="s0">, </span><span class="s1">jac_true*p</span><span class="s0">,</span>
                            <span class="s1">rtol=</span><span class="s2">5e-6</span><span class="s1">)</span>
            <span class="s1">assert_allclose(jac_diff_4.dot(p)</span><span class="s0">, </span><span class="s1">jac_true*p</span><span class="s0">,</span>
                            <span class="s1">rtol=</span><span class="s2">5e-6</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_scalar_vector(self):</span>
        <span class="s1">x0 = </span><span class="s2">0.5</span>
        <span class="s1">jac_diff_2 = approx_derivative(self.fun_scalar_vector</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                                       <span class="s1">method=</span><span class="s4">'2-point'</span><span class="s0">,</span>
                                       <span class="s1">as_linear_operator=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">jac_diff_3 = approx_derivative(self.fun_scalar_vector</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                                       <span class="s1">as_linear_operator=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">jac_diff_4 = approx_derivative(self.fun_scalar_vector</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                                       <span class="s1">method=</span><span class="s4">'cs'</span><span class="s0">,</span>
                                       <span class="s1">as_linear_operator=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">jac_true = self.jac_scalar_vector(np.atleast_1d(x0))</span>
        <span class="s1">np.random.seed(</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">10</span><span class="s1">):</span>
            <span class="s1">p = np.random.uniform(-</span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s1">size=(</span><span class="s2">1</span><span class="s0">,</span><span class="s1">))</span>
            <span class="s1">assert_allclose(jac_diff_2.dot(p)</span><span class="s0">, </span><span class="s1">jac_true.dot(p)</span><span class="s0">,</span>
                            <span class="s1">rtol=</span><span class="s2">1e-5</span><span class="s1">)</span>
            <span class="s1">assert_allclose(jac_diff_3.dot(p)</span><span class="s0">, </span><span class="s1">jac_true.dot(p)</span><span class="s0">,</span>
                            <span class="s1">rtol=</span><span class="s2">5e-6</span><span class="s1">)</span>
            <span class="s1">assert_allclose(jac_diff_4.dot(p)</span><span class="s0">, </span><span class="s1">jac_true.dot(p)</span><span class="s0">,</span>
                            <span class="s1">rtol=</span><span class="s2">5e-6</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_vector_scalar(self):</span>
        <span class="s1">x0 = np.array([</span><span class="s2">100.0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.5</span><span class="s1">])</span>
        <span class="s1">jac_diff_2 = approx_derivative(self.fun_vector_scalar</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                                       <span class="s1">method=</span><span class="s4">'2-point'</span><span class="s0">,</span>
                                       <span class="s1">as_linear_operator=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">jac_diff_3 = approx_derivative(self.fun_vector_scalar</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                                       <span class="s1">as_linear_operator=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">jac_diff_4 = approx_derivative(self.fun_vector_scalar</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                                       <span class="s1">method=</span><span class="s4">'cs'</span><span class="s0">,</span>
                                       <span class="s1">as_linear_operator=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">jac_true = self.jac_vector_scalar(x0)</span>
        <span class="s1">np.random.seed(</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">10</span><span class="s1">):</span>
            <span class="s1">p = np.random.uniform(-</span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s1">size=x0.shape)</span>
            <span class="s1">assert_allclose(jac_diff_2.dot(p)</span><span class="s0">, </span><span class="s1">np.atleast_1d(jac_true.dot(p))</span><span class="s0">,</span>
                            <span class="s1">rtol=</span><span class="s2">1e-5</span><span class="s1">)</span>
            <span class="s1">assert_allclose(jac_diff_3.dot(p)</span><span class="s0">, </span><span class="s1">np.atleast_1d(jac_true.dot(p))</span><span class="s0">,</span>
                            <span class="s1">rtol=</span><span class="s2">5e-6</span><span class="s1">)</span>
            <span class="s1">assert_allclose(jac_diff_4.dot(p)</span><span class="s0">, </span><span class="s1">np.atleast_1d(jac_true.dot(p))</span><span class="s0">,</span>
                            <span class="s1">rtol=</span><span class="s2">1e-7</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_vector_vector(self):</span>
        <span class="s1">x0 = np.array([-</span><span class="s2">100.0</span><span class="s0">, </span><span class="s2">0.2</span><span class="s1">])</span>
        <span class="s1">jac_diff_2 = approx_derivative(self.fun_vector_vector</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                                       <span class="s1">method=</span><span class="s4">'2-point'</span><span class="s0">,</span>
                                       <span class="s1">as_linear_operator=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">jac_diff_3 = approx_derivative(self.fun_vector_vector</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                                       <span class="s1">as_linear_operator=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">jac_diff_4 = approx_derivative(self.fun_vector_vector</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                                       <span class="s1">method=</span><span class="s4">'cs'</span><span class="s0">,</span>
                                       <span class="s1">as_linear_operator=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">jac_true = self.jac_vector_vector(x0)</span>
        <span class="s1">np.random.seed(</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">10</span><span class="s1">):</span>
            <span class="s1">p = np.random.uniform(-</span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s1">size=x0.shape)</span>
            <span class="s1">assert_allclose(jac_diff_2.dot(p)</span><span class="s0">, </span><span class="s1">jac_true.dot(p)</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-5</span><span class="s1">)</span>
            <span class="s1">assert_allclose(jac_diff_3.dot(p)</span><span class="s0">, </span><span class="s1">jac_true.dot(p)</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-6</span><span class="s1">)</span>
            <span class="s1">assert_allclose(jac_diff_4.dot(p)</span><span class="s0">, </span><span class="s1">jac_true.dot(p)</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-7</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_exception(self):</span>
        <span class="s1">x0 = np.array([-</span><span class="s2">100.0</span><span class="s0">, </span><span class="s2">0.2</span><span class="s1">])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">approx_derivative</span><span class="s0">,</span>
                      <span class="s1">self.fun_vector_vector</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">,</span>
                      <span class="s1">method=</span><span class="s4">'2-point'</span><span class="s0">, </span><span class="s1">bounds=(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">np.inf))</span>


<span class="s0">def </span><span class="s1">test_absolute_step_sign():</span>
    <span class="s3"># test for gh12487</span>
    <span class="s3"># if an absolute step is specified for 2-point differences make sure that</span>
    <span class="s3"># the side corresponds to the step. i.e. if step is positive then forward</span>
    <span class="s3"># differences should be used, if step is negative then backwards</span>
    <span class="s3"># differences should be used.</span>

    <span class="s3"># function has double discontinuity at x = [-1, -1]</span>
    <span class="s3"># first component is \/, second component is /\</span>
    <span class="s0">def </span><span class="s1">f(x):</span>
        <span class="s0">return </span><span class="s1">-np.abs(x[</span><span class="s2">0</span><span class="s1">] + </span><span class="s2">1</span><span class="s1">) + np.abs(x[</span><span class="s2">1</span><span class="s1">] + </span><span class="s2">1</span><span class="s1">)</span>

    <span class="s3"># check that the forward difference is used</span>
    <span class="s1">grad = approx_derivative(f</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'2-point'</span><span class="s0">, </span><span class="s1">abs_step=</span><span class="s2">1e-8</span><span class="s1">)</span>
    <span class="s1">assert_allclose(grad</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>

    <span class="s3"># check that the backwards difference is used</span>
    <span class="s1">grad = approx_derivative(f</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'2-point'</span><span class="s0">, </span><span class="s1">abs_step=-</span><span class="s2">1e-8</span><span class="s1">)</span>
    <span class="s1">assert_allclose(grad</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.0</span><span class="s1">])</span>

    <span class="s3"># check that the forwards difference is used with a step for both</span>
    <span class="s3"># parameters</span>
    <span class="s1">grad = approx_derivative(</span>
        <span class="s1">f</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'2-point'</span><span class="s0">, </span><span class="s1">abs_step=[</span><span class="s2">1e-8</span><span class="s0">, </span><span class="s2">1e-8</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">assert_allclose(grad</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>

    <span class="s3"># check that we can mix forward/backwards steps.</span>
    <span class="s1">grad = approx_derivative(</span>
        <span class="s1">f</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'2-point'</span><span class="s0">, </span><span class="s1">abs_step=[</span><span class="s2">1e-8</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1e-8</span><span class="s1">]</span>
     <span class="s1">)</span>
    <span class="s1">assert_allclose(grad</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1.0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.0</span><span class="s1">])</span>
    <span class="s1">grad = approx_derivative(</span>
        <span class="s1">f</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'2-point'</span><span class="s0">, </span><span class="s1">abs_step=[-</span><span class="s2">1e-8</span><span class="s0">, </span><span class="s2">1e-8</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">assert_allclose(grad</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>

    <span class="s3"># the forward step should reverse to a backwards step if it runs into a</span>
    <span class="s3"># bound</span>
    <span class="s3"># This is kind of tested in TestAdjustSchemeToBounds, but only for a lower level</span>
    <span class="s3"># function.</span>
    <span class="s1">grad = approx_derivative(</span>
        <span class="s1">f</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'2-point'</span><span class="s0">, </span><span class="s1">abs_step=</span><span class="s2">1e-8</span><span class="s0">,</span>
        <span class="s1">bounds=(-np.inf</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">assert_allclose(grad</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.0</span><span class="s1">])</span>

    <span class="s1">grad = approx_derivative(</span>
        <span class="s1">f</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'2-point'</span><span class="s0">, </span><span class="s1">abs_step=-</span><span class="s2">1e-8</span><span class="s0">, </span><span class="s1">bounds=(-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">np.inf)</span>
    <span class="s1">)</span>
    <span class="s1">assert_allclose(grad</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">test__compute_absolute_step():</span>
    <span class="s3"># tests calculation of absolute step from rel_step</span>
    <span class="s1">methods = [</span><span class="s4">'2-point'</span><span class="s0">, </span><span class="s4">'3-point'</span><span class="s0">, </span><span class="s4">'cs'</span><span class="s1">]</span>

    <span class="s1">x0 = np.array([</span><span class="s2">1e-5</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1e5</span><span class="s1">])</span>

    <span class="s1">EPS = np.finfo(np.float64).eps</span>
    <span class="s1">relative_step = {</span>
        <span class="s4">&quot;2-point&quot;</span><span class="s1">: EPS**</span><span class="s2">0.5</span><span class="s0">,</span>
        <span class="s4">&quot;3-point&quot;</span><span class="s1">: EPS**(</span><span class="s2">1</span><span class="s1">/</span><span class="s2">3</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s4">&quot;cs&quot;</span><span class="s1">: EPS**</span><span class="s2">0.5</span>
    <span class="s1">}</span>
    <span class="s1">f0 = np.array(</span><span class="s2">1.0</span><span class="s1">)</span>

    <span class="s0">for </span><span class="s1">method </span><span class="s0">in </span><span class="s1">methods:</span>
        <span class="s1">rel_step = relative_step[method]</span>
        <span class="s1">correct_step = np.array([rel_step</span><span class="s0">,</span>
                                 <span class="s1">rel_step * </span><span class="s2">1.</span><span class="s0">,</span>
                                 <span class="s1">rel_step * </span><span class="s2">1.</span><span class="s0">,</span>
                                 <span class="s1">rel_step * np.abs(x0[</span><span class="s2">3</span><span class="s1">])])</span>

        <span class="s1">abs_step = _compute_absolute_step(</span><span class="s0">None, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">f0</span><span class="s0">, </span><span class="s1">method)</span>
        <span class="s1">assert_allclose(abs_step</span><span class="s0">, </span><span class="s1">correct_step)</span>

        <span class="s1">sign_x0 = (-x0 &gt;= </span><span class="s2">0</span><span class="s1">).astype(float) * </span><span class="s2">2 </span><span class="s1">- </span><span class="s2">1</span>
        <span class="s1">abs_step = _compute_absolute_step(</span><span class="s0">None, </span><span class="s1">-x0</span><span class="s0">, </span><span class="s1">f0</span><span class="s0">, </span><span class="s1">method)</span>
        <span class="s1">assert_allclose(abs_step</span><span class="s0">, </span><span class="s1">sign_x0 * correct_step)</span>

    <span class="s3"># if a relative step is provided it should be used</span>
    <span class="s1">rel_step = np.array([</span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">100</span><span class="s1">])</span>
    <span class="s1">correct_step = np.array([rel_step[</span><span class="s2">0</span><span class="s1">] * x0[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
                             <span class="s1">relative_step[</span><span class="s4">'2-point'</span><span class="s1">]</span><span class="s0">,</span>
                             <span class="s1">rel_step[</span><span class="s2">2</span><span class="s1">] * </span><span class="s2">1.</span><span class="s0">,</span>
                             <span class="s1">rel_step[</span><span class="s2">3</span><span class="s1">] * np.abs(x0[</span><span class="s2">3</span><span class="s1">])])</span>

    <span class="s1">abs_step = _compute_absolute_step(rel_step</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">f0</span><span class="s0">, </span><span class="s4">'2-point'</span><span class="s1">)</span>
    <span class="s1">assert_allclose(abs_step</span><span class="s0">, </span><span class="s1">correct_step)</span>

    <span class="s1">sign_x0 = (-x0 &gt;= </span><span class="s2">0</span><span class="s1">).astype(float) * </span><span class="s2">2 </span><span class="s1">- </span><span class="s2">1</span>
    <span class="s1">abs_step = _compute_absolute_step(rel_step</span><span class="s0">, </span><span class="s1">-x0</span><span class="s0">, </span><span class="s1">f0</span><span class="s0">, </span><span class="s4">'2-point'</span><span class="s1">)</span>
    <span class="s1">assert_allclose(abs_step</span><span class="s0">, </span><span class="s1">sign_x0 * correct_step)</span>
</pre>
</body>
</html>