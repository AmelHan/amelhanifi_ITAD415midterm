<html>
<head>
<title>_bsplines.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_bsplines.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">operator</span>
<span class="s0">from </span><span class="s1">math </span><span class="s0">import </span><span class="s1">prod</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy.core.multiarray </span><span class="s0">import </span><span class="s1">normalize_axis_index</span>
<span class="s0">from </span><span class="s1">scipy.linalg </span><span class="s0">import </span><span class="s1">(get_lapack_funcs</span><span class="s0">, </span><span class="s1">LinAlgError</span><span class="s0">,</span>
                          <span class="s1">cholesky_banded</span><span class="s0">, </span><span class="s1">cho_solve_banded</span><span class="s0">,</span>
                          <span class="s1">solve</span><span class="s0">, </span><span class="s1">solve_banded)</span>
<span class="s0">from </span><span class="s1">scipy.optimize </span><span class="s0">import </span><span class="s1">minimize_scalar</span>
<span class="s0">from </span><span class="s1">. </span><span class="s0">import </span><span class="s1">_bspl</span>
<span class="s0">from </span><span class="s1">. </span><span class="s0">import </span><span class="s1">_fitpack_impl</span>
<span class="s0">from </span><span class="s1">scipy.sparse </span><span class="s0">import </span><span class="s1">csr_array</span>
<span class="s0">from </span><span class="s1">scipy.special </span><span class="s0">import </span><span class="s1">poch</span>
<span class="s0">from </span><span class="s1">itertools </span><span class="s0">import </span><span class="s1">combinations</span>

<span class="s1">__all__ = [</span><span class="s2">&quot;BSpline&quot;</span><span class="s0">, </span><span class="s2">&quot;make_interp_spline&quot;</span><span class="s0">, </span><span class="s2">&quot;make_lsq_spline&quot;</span><span class="s0">,</span>
           <span class="s2">&quot;make_smoothing_spline&quot;</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">_get_dtype(dtype):</span>
    <span class="s3">&quot;&quot;&quot;Return np.complex128 for complex dtypes, np.float64 otherwise.&quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">np.issubdtype(dtype</span><span class="s0">, </span><span class="s1">np.complexfloating):</span>
        <span class="s0">return </span><span class="s1">np.complex_</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">np.float_</span>


<span class="s0">def </span><span class="s1">_as_float_array(x</span><span class="s0">, </span><span class="s1">check_finite=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Convert the input into a C contiguous float array. 
 
    NB: Upcasts half- and single-precision floats to double precision. 
    &quot;&quot;&quot;</span>
    <span class="s1">x = np.ascontiguousarray(x)</span>
    <span class="s1">dtyp = _get_dtype(x.dtype)</span>
    <span class="s1">x = x.astype(dtyp</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">check_finite </span><span class="s0">and not </span><span class="s1">np.isfinite(x).all():</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Array must not contain infs or nans.&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">x</span>


<span class="s0">def </span><span class="s1">_dual_poly(j</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">y):</span>
    <span class="s3">&quot;&quot;&quot; 
    Dual polynomial of the B-spline B_{j,k,t} - 
    polynomial which is associated with B_{j,k,t}: 
    $p_{j,k}(y) = (y - t_{j+1})(y - t_{j+2})...(y - t_{j+k})$ 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">k == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s4">1</span>
    <span class="s0">return </span><span class="s1">np.prod([(y - t[j + i]) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">k + </span><span class="s4">1</span><span class="s1">)])</span>


<span class="s0">def </span><span class="s1">_diff_dual_poly(j</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">t):</span>
    <span class="s3">&quot;&quot;&quot; 
    d-th derivative of the dual polynomial $p_{j,k}(y)$ 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">d == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">_dual_poly(j</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s0">if </span><span class="s1">d == k:</span>
        <span class="s0">return </span><span class="s1">poch(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">k)</span>
    <span class="s1">comb = list(combinations(range(j + </span><span class="s4">1</span><span class="s0">, </span><span class="s1">j + k + </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">d))</span>
    <span class="s1">res = </span><span class="s4">0</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(comb) * len(comb[</span><span class="s4">0</span><span class="s1">])):</span>
        <span class="s1">res += np.prod([(y - t[j + p]) </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">k + </span><span class="s4">1</span><span class="s1">)</span>
                        <span class="s0">if </span><span class="s1">(j + p) </span><span class="s0">not in </span><span class="s1">comb[i//d]])</span>
    <span class="s0">return </span><span class="s1">res</span>


<span class="s0">class </span><span class="s1">BSpline:</span>
    <span class="s3">r&quot;&quot;&quot;Univariate spline in the B-spline basis. 
 
    .. math:: 
 
        S(x) = \sum_{j=0}^{n-1} c_j  B_{j, k; t}(x) 
 
    where :math:`B_{j, k; t}` are B-spline basis functions of degree `k` 
    and knots `t`. 
 
    Parameters 
    ---------- 
    t : ndarray, shape (n+k+1,) 
        knots 
    c : ndarray, shape (&gt;=n, ...) 
        spline coefficients 
    k : int 
        B-spline degree 
    extrapolate : bool or 'periodic', optional 
        whether to extrapolate beyond the base interval, ``t[k] .. t[n]``, 
        or to return nans. 
        If True, extrapolates the first and last polynomial pieces of b-spline 
        functions active on the base interval. 
        If 'periodic', periodic extrapolation is used. 
        Default is True. 
    axis : int, optional 
        Interpolation axis. Default is zero. 
 
    Attributes 
    ---------- 
    t : ndarray 
        knot vector 
    c : ndarray 
        spline coefficients 
    k : int 
        spline degree 
    extrapolate : bool 
        If True, extrapolates the first and last polynomial pieces of b-spline 
        functions active on the base interval. 
    axis : int 
        Interpolation axis. 
    tck : tuple 
        A read-only equivalent of ``(self.t, self.c, self.k)`` 
 
    Methods 
    ------- 
    __call__ 
    basis_element 
    derivative 
    antiderivative 
    integrate 
    construct_fast 
    design_matrix 
    from_power_basis 
 
    Notes 
    ----- 
    B-spline basis elements are defined via 
 
    .. math:: 
 
        B_{i, 0}(x) = 1, \textrm{if $t_i \le x &lt; t_{i+1}$, otherwise $0$,} 
 
        B_{i, k}(x) = \frac{x - t_i}{t_{i+k} - t_i} B_{i, k-1}(x) 
                 + \frac{t_{i+k+1} - x}{t_{i+k+1} - t_{i+1}} B_{i+1, k-1}(x) 
 
    **Implementation details** 
 
    - At least ``k+1`` coefficients are required for a spline of degree `k`, 
      so that ``n &gt;= k+1``. Additional coefficients, ``c[j]`` with 
      ``j &gt; n``, are ignored. 
 
    - B-spline basis elements of degree `k` form a partition of unity on the 
      *base interval*, ``t[k] &lt;= x &lt;= t[n]``. 
 
 
    Examples 
    -------- 
 
    Translating the recursive definition of B-splines into Python code, we have: 
 
    &gt;&gt;&gt; def B(x, k, i, t): 
    ...    if k == 0: 
    ...       return 1.0 if t[i] &lt;= x &lt; t[i+1] else 0.0 
    ...    if t[i+k] == t[i]: 
    ...       c1 = 0.0 
    ...    else: 
    ...       c1 = (x - t[i])/(t[i+k] - t[i]) * B(x, k-1, i, t) 
    ...    if t[i+k+1] == t[i+1]: 
    ...       c2 = 0.0 
    ...    else: 
    ...       c2 = (t[i+k+1] - x)/(t[i+k+1] - t[i+1]) * B(x, k-1, i+1, t) 
    ...    return c1 + c2 
 
    &gt;&gt;&gt; def bspline(x, t, c, k): 
    ...    n = len(t) - k - 1 
    ...    assert (n &gt;= k+1) and (len(c) &gt;= n) 
    ...    return sum(c[i] * B(x, k, i, t) for i in range(n)) 
 
    Note that this is an inefficient (if straightforward) way to 
    evaluate B-splines --- this spline class does it in an equivalent, 
    but much more efficient way. 
 
    Here we construct a quadratic spline function on the base interval 
    ``2 &lt;= x &lt;= 4`` and compare with the naive way of evaluating the spline: 
 
    &gt;&gt;&gt; from scipy.interpolate import BSpline 
    &gt;&gt;&gt; k = 2 
    &gt;&gt;&gt; t = [0, 1, 2, 3, 4, 5, 6] 
    &gt;&gt;&gt; c = [-1, 2, 0, -1] 
    &gt;&gt;&gt; spl = BSpline(t, c, k) 
    &gt;&gt;&gt; spl(2.5) 
    array(1.375) 
    &gt;&gt;&gt; bspline(2.5, t, c, k) 
    1.375 
 
    Note that outside of the base interval results differ. This is because 
    `BSpline` extrapolates the first and last polynomial pieces of B-spline 
    functions active on the base interval. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; xx = np.linspace(1.5, 4.5, 50) 
    &gt;&gt;&gt; ax.plot(xx, [bspline(x, t, c ,k) for x in xx], 'r-', lw=3, label='naive') 
    &gt;&gt;&gt; ax.plot(xx, spl(xx), 'b-', lw=4, alpha=0.7, label='BSpline') 
    &gt;&gt;&gt; ax.grid(True) 
    &gt;&gt;&gt; ax.legend(loc='best') 
    &gt;&gt;&gt; plt.show() 
 
 
    References 
    ---------- 
    .. [1] Tom Lyche and Knut Morken, Spline methods, 
        http://www.uio.no/studier/emner/matnat/ifi/INF-MAT5340/v05/undervisningsmateriale/ 
    .. [2] Carl de Boor, A practical guide to splines, Springer, 2001. 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">extrapolate=</span><span class="s0">True, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">):</span>
        <span class="s1">super().__init__()</span>

        <span class="s1">self.k = operator.index(k)</span>
        <span class="s1">self.c = np.asarray(c)</span>
        <span class="s1">self.t = np.ascontiguousarray(t</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>

        <span class="s0">if </span><span class="s1">extrapolate == </span><span class="s2">'periodic'</span><span class="s1">:</span>
            <span class="s1">self.extrapolate = extrapolate</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.extrapolate = bool(extrapolate)</span>

        <span class="s1">n = self.t.shape[</span><span class="s4">0</span><span class="s1">] - self.k - </span><span class="s4">1</span>

        <span class="s1">axis = normalize_axis_index(axis</span><span class="s0">, </span><span class="s1">self.c.ndim)</span>

        <span class="s5"># Note that the normalized axis is stored in the object.</span>
        <span class="s1">self.axis = axis</span>
        <span class="s0">if </span><span class="s1">axis != </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s5"># roll the interpolation axis to be the first one in self.c</span>
            <span class="s5"># More specifically, the target shape for self.c is (n, ...),</span>
            <span class="s5"># and axis !=0 means that we have c.shape (..., n, ...)</span>
            <span class="s5">#                                               ^</span>
            <span class="s5">#                                              axis</span>
            <span class="s1">self.c = np.moveaxis(self.c</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">k &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Spline order cannot be negative.&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">self.t.ndim != </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Knot vector must be one-dimensional.&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">n &lt; self.k + </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Need at least %d knots for degree %d&quot; </span><span class="s1">%</span>
                             <span class="s1">(</span><span class="s4">2</span><span class="s1">*k + </span><span class="s4">2</span><span class="s0">, </span><span class="s1">k))</span>
        <span class="s0">if </span><span class="s1">(np.diff(self.t) &lt; </span><span class="s4">0</span><span class="s1">).any():</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Knots must be in a non-decreasing order.&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">len(np.unique(self.t[k:n+</span><span class="s4">1</span><span class="s1">])) &lt; </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Need at least two internal knots.&quot;</span><span class="s1">)</span>
        <span class="s0">if not </span><span class="s1">np.isfinite(self.t).all():</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Knots should not have nans or infs.&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">self.c.ndim &lt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Coefficients must be at least 1-dimensional.&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">self.c.shape[</span><span class="s4">0</span><span class="s1">] &lt; n:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Knots, coefficients and degree are inconsistent.&quot;</span><span class="s1">)</span>

        <span class="s1">dt = _get_dtype(self.c.dtype)</span>
        <span class="s1">self.c = np.ascontiguousarray(self.c</span><span class="s0">, </span><span class="s1">dtype=dt)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">construct_fast(cls</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">extrapolate=</span><span class="s0">True, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Construct a spline without making checks. 
 
        Accepts same parameters as the regular constructor. Input arrays 
        `t` and `c` must of correct shape and dtype. 
        &quot;&quot;&quot;</span>
        <span class="s1">self = object.__new__(cls)</span>
        <span class="s1">self.t</span><span class="s0">, </span><span class="s1">self.c</span><span class="s0">, </span><span class="s1">self.k = t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k</span>
        <span class="s1">self.extrapolate = extrapolate</span>
        <span class="s1">self.axis = axis</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">tck(self):</span>
        <span class="s3">&quot;&quot;&quot;Equivalent to ``(self.t, self.c, self.k)`` (read-only). 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.t</span><span class="s0">, </span><span class="s1">self.c</span><span class="s0">, </span><span class="s1">self.k</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">basis_element(cls</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">extrapolate=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Return a B-spline basis element ``B(x | t[0], ..., t[k+1])``. 
 
        Parameters 
        ---------- 
        t : ndarray, shape (k+2,) 
            internal knots 
        extrapolate : bool or 'periodic', optional 
            whether to extrapolate beyond the base interval, ``t[0] .. t[k+1]``, 
            or to return nans. 
            If 'periodic', periodic extrapolation is used. 
            Default is True. 
 
        Returns 
        ------- 
        basis_element : callable 
            A callable representing a B-spline basis element for the knot 
            vector `t`. 
 
        Notes 
        ----- 
        The degree of the B-spline, `k`, is inferred from the length of `t` as 
        ``len(t)-2``. The knot vector is constructed by appending and prepending 
        ``k+1`` elements to internal knots `t`. 
 
        Examples 
        -------- 
 
        Construct a cubic B-spline: 
 
        &gt;&gt;&gt; import numpy as np 
        &gt;&gt;&gt; from scipy.interpolate import BSpline 
        &gt;&gt;&gt; b = BSpline.basis_element([0, 1, 2, 3, 4]) 
        &gt;&gt;&gt; k = b.k 
        &gt;&gt;&gt; b.t[k:-k] 
        array([ 0.,  1.,  2.,  3.,  4.]) 
        &gt;&gt;&gt; k 
        3 
 
        Construct a quadratic B-spline on ``[0, 1, 1, 2]``, and compare 
        to its explicit form: 
 
        &gt;&gt;&gt; t = [0, 1, 1, 2] 
        &gt;&gt;&gt; b = BSpline.basis_element(t) 
        &gt;&gt;&gt; def f(x): 
        ...     return np.where(x &lt; 1, x*x, (2. - x)**2) 
 
        &gt;&gt;&gt; import matplotlib.pyplot as plt 
        &gt;&gt;&gt; fig, ax = plt.subplots() 
        &gt;&gt;&gt; x = np.linspace(0, 2, 51) 
        &gt;&gt;&gt; ax.plot(x, b(x), 'g', lw=3) 
        &gt;&gt;&gt; ax.plot(x, f(x), 'r', lw=8, alpha=0.4) 
        &gt;&gt;&gt; ax.grid(True) 
        &gt;&gt;&gt; plt.show() 
 
        &quot;&quot;&quot;</span>
        <span class="s1">k = len(t) - </span><span class="s4">2</span>
        <span class="s1">t = _as_float_array(t)</span>
        <span class="s1">t = np.r_[(t[</span><span class="s4">0</span><span class="s1">]-</span><span class="s4">1</span><span class="s0">,</span><span class="s1">) * k</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">(t[-</span><span class="s4">1</span><span class="s1">]+</span><span class="s4">1</span><span class="s0">,</span><span class="s1">) * k]</span>
        <span class="s1">c = np.zeros_like(t)</span>
        <span class="s1">c[k] = </span><span class="s4">1.</span>
        <span class="s0">return </span><span class="s1">cls.construct_fast(t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">extrapolate)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">design_matrix(cls</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">extrapolate=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Returns a design matrix as a CSR format sparse array. 
 
        Parameters 
        ---------- 
        x : array_like, shape (n,) 
            Points to evaluate the spline at. 
        t : array_like, shape (nt,) 
            Sorted 1D array of knots. 
        k : int 
            B-spline degree. 
        extrapolate : bool or 'periodic', optional 
            Whether to extrapolate based on the first and last intervals 
            or raise an error. If 'periodic', periodic extrapolation is used. 
            Default is False. 
 
            .. versionadded:: 1.10.0 
 
        Returns 
        ------- 
        design_matrix : `csr_array` object 
            Sparse matrix in CSR format where each row contains all the basis 
            elements of the input row (first row = basis elements of x[0], 
            ..., last row = basis elements x[-1]). 
 
        Examples 
        -------- 
        Construct a design matrix for a B-spline 
 
        &gt;&gt;&gt; from scipy.interpolate import make_interp_spline, BSpline 
        &gt;&gt;&gt; import numpy as np 
        &gt;&gt;&gt; x = np.linspace(0, np.pi * 2, 4) 
        &gt;&gt;&gt; y = np.sin(x) 
        &gt;&gt;&gt; k = 3 
        &gt;&gt;&gt; bspl = make_interp_spline(x, y, k=k) 
        &gt;&gt;&gt; design_matrix = bspl.design_matrix(x, bspl.t, k) 
        &gt;&gt;&gt; design_matrix.toarray() 
        [[1.        , 0.        , 0.        , 0.        ], 
        [0.2962963 , 0.44444444, 0.22222222, 0.03703704], 
        [0.03703704, 0.22222222, 0.44444444, 0.2962963 ], 
        [0.        , 0.        , 0.        , 1.        ]] 
 
        Construct a design matrix for some vector of knots 
 
        &gt;&gt;&gt; k = 2 
        &gt;&gt;&gt; t = [-1, 0, 1, 2, 3, 4, 5, 6] 
        &gt;&gt;&gt; x = [1, 2, 3, 4] 
        &gt;&gt;&gt; design_matrix = BSpline.design_matrix(x, t, k).toarray() 
        &gt;&gt;&gt; design_matrix 
        [[0.5, 0.5, 0. , 0. , 0. ], 
        [0. , 0.5, 0.5, 0. , 0. ], 
        [0. , 0. , 0.5, 0.5, 0. ], 
        [0. , 0. , 0. , 0.5, 0.5]] 
 
        This result is equivalent to the one created in the sparse format 
 
        &gt;&gt;&gt; c = np.eye(len(t) - k - 1) 
        &gt;&gt;&gt; design_matrix_gh = BSpline(t, c, k)(x) 
        &gt;&gt;&gt; np.allclose(design_matrix, design_matrix_gh, atol=1e-14) 
        True 
 
        Notes 
        ----- 
        .. versionadded:: 1.8.0 
 
        In each row of the design matrix all the basis elements are evaluated 
        at the certain point (first row - x[0], ..., last row - x[-1]). 
 
        `nt` is a length of the vector of knots: as far as there are 
        `nt - k - 1` basis elements, `nt` should be not less than `2 * k + 2` 
        to have at least `k + 1` basis element. 
 
        Out of bounds `x` raises a ValueError. 
        &quot;&quot;&quot;</span>
        <span class="s1">x = _as_float_array(x</span><span class="s0">, True</span><span class="s1">)</span>
        <span class="s1">t = _as_float_array(t</span><span class="s0">, True</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">extrapolate != </span><span class="s2">'periodic'</span><span class="s1">:</span>
            <span class="s1">extrapolate = bool(extrapolate)</span>

        <span class="s0">if </span><span class="s1">k &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Spline order cannot be negative.&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">t.ndim != </span><span class="s4">1 </span><span class="s0">or </span><span class="s1">np.any(t[</span><span class="s4">1</span><span class="s1">:] &lt; t[:-</span><span class="s4">1</span><span class="s1">]):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">f&quot;Expect t to be a 1-D sorted array_like, but &quot;</span>
                             <span class="s2">f&quot;got t=</span><span class="s0">{</span><span class="s1">t</span><span class="s0">}</span><span class="s2">.&quot;</span><span class="s1">)</span>
        <span class="s5"># There are `nt - k - 1` basis elements in a BSpline built on the</span>
        <span class="s5"># vector of knots with length `nt`, so to have at least `k + 1` basis</span>
        <span class="s5"># elements we need to have at least `2 * k + 2` elements in the vector</span>
        <span class="s5"># of knots.</span>
        <span class="s0">if </span><span class="s1">len(t) &lt; </span><span class="s4">2 </span><span class="s1">* k + </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">f&quot;Length t is not enough for k=</span><span class="s0">{</span><span class="s1">k</span><span class="s0">}</span><span class="s2">.&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">extrapolate == </span><span class="s2">'periodic'</span><span class="s1">:</span>
            <span class="s5"># With periodic extrapolation we map x to the segment</span>
            <span class="s5"># [t[k], t[n]].</span>
            <span class="s1">n = t.size - k - </span><span class="s4">1</span>
            <span class="s1">x = t[k] + (x - t[k]) % (t[n] - t[k])</span>
            <span class="s1">extrapolate = </span><span class="s0">False</span>
        <span class="s0">elif not </span><span class="s1">extrapolate </span><span class="s0">and </span><span class="s1">(</span>
            <span class="s1">(min(x) &lt; t[k]) </span><span class="s0">or </span><span class="s1">(max(x) &gt; t[t.shape[</span><span class="s4">0</span><span class="s1">] - k - </span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">):</span>
            <span class="s5"># Checks from `find_interval` function</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">f'Out of bounds w/ x = </span><span class="s0">{</span><span class="s1">x</span><span class="s0">}</span><span class="s2">.'</span><span class="s1">)</span>

        <span class="s5"># Compute number of non-zeros of final CSR array in order to determine</span>
        <span class="s5"># the dtype of indices and indptr of the CSR array.</span>
        <span class="s1">n = x.shape[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">nnz = n * (k + </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">nnz &lt; np.iinfo(np.int32).max:</span>
            <span class="s1">int_dtype = np.int32</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">int_dtype = np.int64</span>
        <span class="s5"># Preallocate indptr and indices</span>
        <span class="s1">indices = np.empty(n * (k + </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=int_dtype)</span>
        <span class="s1">indptr = np.arange(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">(n + </span><span class="s4">1</span><span class="s1">) * (k + </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">k + </span><span class="s4">1</span><span class="s0">, </span><span class="s1">dtype=int_dtype)</span>

        <span class="s5"># indptr is not passed to Cython as it is already fully computed</span>
        <span class="s1">data</span><span class="s0">, </span><span class="s1">indices = _bspl._make_design_matrix(</span>
            <span class="s1">x</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">extrapolate</span><span class="s0">, </span><span class="s1">indices</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">csr_array(</span>
            <span class="s1">(data</span><span class="s0">, </span><span class="s1">indices</span><span class="s0">, </span><span class="s1">indptr)</span><span class="s0">,</span>
            <span class="s1">shape=(x.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">t.shape[</span><span class="s4">0</span><span class="s1">] - k - </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">nu=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">extrapolate=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Evaluate a spline function. 
 
        Parameters 
        ---------- 
        x : array_like 
            points to evaluate the spline at. 
        nu : int, optional 
            derivative to evaluate (default is 0). 
        extrapolate : bool or 'periodic', optional 
            whether to extrapolate based on the first and last intervals 
            or return nans. If 'periodic', periodic extrapolation is used. 
            Default is `self.extrapolate`. 
 
        Returns 
        ------- 
        y : array_like 
            Shape is determined by replacing the interpolation axis 
            in the coefficient array with the shape of `x`. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">extrapolate </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">extrapolate = self.extrapolate</span>
        <span class="s1">x = np.asarray(x)</span>
        <span class="s1">x_shape</span><span class="s0">, </span><span class="s1">x_ndim = x.shape</span><span class="s0">, </span><span class="s1">x.ndim</span>
        <span class="s1">x = np.ascontiguousarray(x.ravel()</span><span class="s0">, </span><span class="s1">dtype=np.float_)</span>

        <span class="s5"># With periodic extrapolation we map x to the segment</span>
        <span class="s5"># [self.t[k], self.t[n]].</span>
        <span class="s0">if </span><span class="s1">extrapolate == </span><span class="s2">'periodic'</span><span class="s1">:</span>
            <span class="s1">n = self.t.size - self.k - </span><span class="s4">1</span>
            <span class="s1">x = self.t[self.k] + (x - self.t[self.k]) % (self.t[n] -</span>
                                                         <span class="s1">self.t[self.k])</span>
            <span class="s1">extrapolate = </span><span class="s0">False</span>

        <span class="s1">out = np.empty((len(x)</span><span class="s0">, </span><span class="s1">prod(self.c.shape[</span><span class="s4">1</span><span class="s1">:]))</span><span class="s0">, </span><span class="s1">dtype=self.c.dtype)</span>
        <span class="s1">self._ensure_c_contiguous()</span>
        <span class="s1">self._evaluate(x</span><span class="s0">, </span><span class="s1">nu</span><span class="s0">, </span><span class="s1">extrapolate</span><span class="s0">, </span><span class="s1">out)</span>
        <span class="s1">out = out.reshape(x_shape + self.c.shape[</span><span class="s4">1</span><span class="s1">:])</span>
        <span class="s0">if </span><span class="s1">self.axis != </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s5"># transpose to move the calculated values to the interpolation axis</span>
            <span class="s1">l = list(range(out.ndim))</span>
            <span class="s1">l = l[x_ndim:x_ndim+self.axis] + l[:x_ndim] + l[x_ndim+self.axis:]</span>
            <span class="s1">out = out.transpose(l)</span>
        <span class="s0">return </span><span class="s1">out</span>

    <span class="s0">def </span><span class="s1">_evaluate(self</span><span class="s0">, </span><span class="s1">xp</span><span class="s0">, </span><span class="s1">nu</span><span class="s0">, </span><span class="s1">extrapolate</span><span class="s0">, </span><span class="s1">out):</span>
        <span class="s1">_bspl.evaluate_spline(self.t</span><span class="s0">, </span><span class="s1">self.c.reshape(self.c.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span>
                              <span class="s1">self.k</span><span class="s0">, </span><span class="s1">xp</span><span class="s0">, </span><span class="s1">nu</span><span class="s0">, </span><span class="s1">extrapolate</span><span class="s0">, </span><span class="s1">out)</span>

    <span class="s0">def </span><span class="s1">_ensure_c_contiguous(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        c and t may be modified by the user. The Cython code expects 
        that they are C contiguous. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">self.t.flags.c_contiguous:</span>
            <span class="s1">self.t = self.t.copy()</span>
        <span class="s0">if not </span><span class="s1">self.c.flags.c_contiguous:</span>
            <span class="s1">self.c = self.c.copy()</span>

    <span class="s0">def </span><span class="s1">derivative(self</span><span class="s0">, </span><span class="s1">nu=</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Return a B-spline representing the derivative. 
 
        Parameters 
        ---------- 
        nu : int, optional 
            Derivative order. 
            Default is 1. 
 
        Returns 
        ------- 
        b : BSpline object 
            A new instance representing the derivative. 
 
        See Also 
        -------- 
        splder, splantider 
 
        &quot;&quot;&quot;</span>
        <span class="s1">c = self.c</span>
        <span class="s5"># pad the c array if needed</span>
        <span class="s1">ct = len(self.t) - len(c)</span>
        <span class="s0">if </span><span class="s1">ct &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">c = np.r_[c</span><span class="s0">, </span><span class="s1">np.zeros((ct</span><span class="s0">,</span><span class="s1">) + c.shape[</span><span class="s4">1</span><span class="s1">:])]</span>
        <span class="s1">tck = _fitpack_impl.splder((self.t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">self.k)</span><span class="s0">, </span><span class="s1">nu)</span>
        <span class="s0">return </span><span class="s1">self.construct_fast(*tck</span><span class="s0">, </span><span class="s1">extrapolate=self.extrapolate</span><span class="s0">,</span>
                                   <span class="s1">axis=self.axis)</span>

    <span class="s0">def </span><span class="s1">antiderivative(self</span><span class="s0">, </span><span class="s1">nu=</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Return a B-spline representing the antiderivative. 
 
        Parameters 
        ---------- 
        nu : int, optional 
            Antiderivative order. Default is 1. 
 
        Returns 
        ------- 
        b : BSpline object 
            A new instance representing the antiderivative. 
 
        Notes 
        ----- 
        If antiderivative is computed and ``self.extrapolate='periodic'``, 
        it will be set to False for the returned instance. This is done because 
        the antiderivative is no longer periodic and its correct evaluation 
        outside of the initially given x interval is difficult. 
 
        See Also 
        -------- 
        splder, splantider 
 
        &quot;&quot;&quot;</span>
        <span class="s1">c = self.c</span>
        <span class="s5"># pad the c array if needed</span>
        <span class="s1">ct = len(self.t) - len(c)</span>
        <span class="s0">if </span><span class="s1">ct &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">c = np.r_[c</span><span class="s0">, </span><span class="s1">np.zeros((ct</span><span class="s0">,</span><span class="s1">) + c.shape[</span><span class="s4">1</span><span class="s1">:])]</span>
        <span class="s1">tck = _fitpack_impl.splantider((self.t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">self.k)</span><span class="s0">, </span><span class="s1">nu)</span>

        <span class="s0">if </span><span class="s1">self.extrapolate == </span><span class="s2">'periodic'</span><span class="s1">:</span>
            <span class="s1">extrapolate = </span><span class="s0">False</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">extrapolate = self.extrapolate</span>

        <span class="s0">return </span><span class="s1">self.construct_fast(*tck</span><span class="s0">, </span><span class="s1">extrapolate=extrapolate</span><span class="s0">,</span>
                                   <span class="s1">axis=self.axis)</span>

    <span class="s0">def </span><span class="s1">integrate(self</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">extrapolate=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Compute a definite integral of the spline. 
 
        Parameters 
        ---------- 
        a : float 
            Lower limit of integration. 
        b : float 
            Upper limit of integration. 
        extrapolate : bool or 'periodic', optional 
            whether to extrapolate beyond the base interval, 
            ``t[k] .. t[-k-1]``, or take the spline to be zero outside of the 
            base interval. If 'periodic', periodic extrapolation is used. 
            If None (default), use `self.extrapolate`. 
 
        Returns 
        ------- 
        I : array_like 
            Definite integral of the spline over the interval ``[a, b]``. 
 
        Examples 
        -------- 
        Construct the linear spline ``x if x &lt; 1 else 2 - x`` on the base 
        interval :math:`[0, 2]`, and integrate it 
 
        &gt;&gt;&gt; from scipy.interpolate import BSpline 
        &gt;&gt;&gt; b = BSpline.basis_element([0, 1, 2]) 
        &gt;&gt;&gt; b.integrate(0, 1) 
        array(0.5) 
 
        If the integration limits are outside of the base interval, the result 
        is controlled by the `extrapolate` parameter 
 
        &gt;&gt;&gt; b.integrate(-1, 1) 
        array(0.0) 
        &gt;&gt;&gt; b.integrate(-1, 1, extrapolate=False) 
        array(0.5) 
 
        &gt;&gt;&gt; import matplotlib.pyplot as plt 
        &gt;&gt;&gt; fig, ax = plt.subplots() 
        &gt;&gt;&gt; ax.grid(True) 
        &gt;&gt;&gt; ax.axvline(0, c='r', lw=5, alpha=0.5)  # base interval 
        &gt;&gt;&gt; ax.axvline(2, c='r', lw=5, alpha=0.5) 
        &gt;&gt;&gt; xx = [-1, 1, 2] 
        &gt;&gt;&gt; ax.plot(xx, b(xx)) 
        &gt;&gt;&gt; plt.show() 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">extrapolate </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">extrapolate = self.extrapolate</span>

        <span class="s5"># Prepare self.t and self.c.</span>
        <span class="s1">self._ensure_c_contiguous()</span>

        <span class="s5"># Swap integration bounds if needed.</span>
        <span class="s1">sign = </span><span class="s4">1</span>
        <span class="s0">if </span><span class="s1">b &lt; a:</span>
            <span class="s1">a</span><span class="s0">, </span><span class="s1">b = b</span><span class="s0">, </span><span class="s1">a</span>
            <span class="s1">sign = -</span><span class="s4">1</span>
        <span class="s1">n = self.t.size - self.k - </span><span class="s4">1</span>

        <span class="s0">if </span><span class="s1">extrapolate != </span><span class="s2">&quot;periodic&quot; </span><span class="s0">and not </span><span class="s1">extrapolate:</span>
            <span class="s5"># Shrink the integration interval, if needed.</span>
            <span class="s1">a = max(a</span><span class="s0">, </span><span class="s1">self.t[self.k])</span>
            <span class="s1">b = min(b</span><span class="s0">, </span><span class="s1">self.t[n])</span>

            <span class="s0">if </span><span class="s1">self.c.ndim == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s5"># Fast path: use FITPACK's routine</span>
                <span class="s5"># (cf _fitpack_impl.splint).</span>
                <span class="s1">integral = _fitpack_impl.splint(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">self.tck)</span>
                <span class="s0">return </span><span class="s1">integral * sign</span>

        <span class="s1">out = np.empty((</span><span class="s4">2</span><span class="s0">, </span><span class="s1">prod(self.c.shape[</span><span class="s4">1</span><span class="s1">:]))</span><span class="s0">, </span><span class="s1">dtype=self.c.dtype)</span>

        <span class="s5"># Compute the antiderivative.</span>
        <span class="s1">c = self.c</span>
        <span class="s1">ct = len(self.t) - len(c)</span>
        <span class="s0">if </span><span class="s1">ct &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">c = np.r_[c</span><span class="s0">, </span><span class="s1">np.zeros((ct</span><span class="s0">,</span><span class="s1">) + c.shape[</span><span class="s4">1</span><span class="s1">:])]</span>
        <span class="s1">ta</span><span class="s0">, </span><span class="s1">ca</span><span class="s0">, </span><span class="s1">ka = _fitpack_impl.splantider((self.t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">self.k)</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">extrapolate == </span><span class="s2">'periodic'</span><span class="s1">:</span>
            <span class="s5"># Split the integral into the part over period (can be several</span>
            <span class="s5"># of them) and the remaining part.</span>

            <span class="s1">ts</span><span class="s0">, </span><span class="s1">te = self.t[self.k]</span><span class="s0">, </span><span class="s1">self.t[n]</span>
            <span class="s1">period = te - ts</span>
            <span class="s1">interval = b - a</span>
            <span class="s1">n_periods</span><span class="s0">, </span><span class="s1">left = divmod(interval</span><span class="s0">, </span><span class="s1">period)</span>

            <span class="s0">if </span><span class="s1">n_periods &gt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s5"># Evaluate the difference of antiderivatives.</span>
                <span class="s1">x = np.asarray([ts</span><span class="s0">, </span><span class="s1">te]</span><span class="s0">, </span><span class="s1">dtype=np.float_)</span>
                <span class="s1">_bspl.evaluate_spline(ta</span><span class="s0">, </span><span class="s1">ca.reshape(ca.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span>
                                      <span class="s1">ka</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, False, </span><span class="s1">out)</span>
                <span class="s1">integral = out[</span><span class="s4">1</span><span class="s1">] - out[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s1">integral *= n_periods</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">integral = np.zeros((</span><span class="s4">1</span><span class="s0">, </span><span class="s1">prod(self.c.shape[</span><span class="s4">1</span><span class="s1">:]))</span><span class="s0">,</span>
                                    <span class="s1">dtype=self.c.dtype)</span>

            <span class="s5"># Map a to [ts, te], b is always a + left.</span>
            <span class="s1">a = ts + (a - ts) % period</span>
            <span class="s1">b = a + left</span>

            <span class="s5"># If b &lt;= te then we need to integrate over [a, b], otherwise</span>
            <span class="s5"># over [a, te] and from xs to what is remained.</span>
            <span class="s0">if </span><span class="s1">b &lt;= te:</span>
                <span class="s1">x = np.asarray([a</span><span class="s0">, </span><span class="s1">b]</span><span class="s0">, </span><span class="s1">dtype=np.float_)</span>
                <span class="s1">_bspl.evaluate_spline(ta</span><span class="s0">, </span><span class="s1">ca.reshape(ca.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span>
                                      <span class="s1">ka</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, False, </span><span class="s1">out)</span>
                <span class="s1">integral += out[</span><span class="s4">1</span><span class="s1">] - out[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">x = np.asarray([a</span><span class="s0">, </span><span class="s1">te]</span><span class="s0">, </span><span class="s1">dtype=np.float_)</span>
                <span class="s1">_bspl.evaluate_spline(ta</span><span class="s0">, </span><span class="s1">ca.reshape(ca.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span>
                                      <span class="s1">ka</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, False, </span><span class="s1">out)</span>
                <span class="s1">integral += out[</span><span class="s4">1</span><span class="s1">] - out[</span><span class="s4">0</span><span class="s1">]</span>

                <span class="s1">x = np.asarray([ts</span><span class="s0">, </span><span class="s1">ts + b - te]</span><span class="s0">, </span><span class="s1">dtype=np.float_)</span>
                <span class="s1">_bspl.evaluate_spline(ta</span><span class="s0">, </span><span class="s1">ca.reshape(ca.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span>
                                      <span class="s1">ka</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, False, </span><span class="s1">out)</span>
                <span class="s1">integral += out[</span><span class="s4">1</span><span class="s1">] - out[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s5"># Evaluate the difference of antiderivatives.</span>
            <span class="s1">x = np.asarray([a</span><span class="s0">, </span><span class="s1">b]</span><span class="s0">, </span><span class="s1">dtype=np.float_)</span>
            <span class="s1">_bspl.evaluate_spline(ta</span><span class="s0">, </span><span class="s1">ca.reshape(ca.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span>
                                  <span class="s1">ka</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">extrapolate</span><span class="s0">, </span><span class="s1">out)</span>
            <span class="s1">integral = out[</span><span class="s4">1</span><span class="s1">] - out[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s1">integral *= sign</span>
        <span class="s0">return </span><span class="s1">integral.reshape(ca.shape[</span><span class="s4">1</span><span class="s1">:])</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_power_basis(cls</span><span class="s0">, </span><span class="s1">pp</span><span class="s0">, </span><span class="s1">bc_type=</span><span class="s2">'not-a-knot'</span><span class="s1">):</span>
        <span class="s3">r&quot;&quot;&quot; 
        Construct a polynomial in the B-spline basis 
        from a piecewise polynomial in the power basis. 
 
        For now, accepts ``CubicSpline`` instances only. 
 
        Parameters 
        ---------- 
        pp : CubicSpline 
            A piecewise polynomial in the power basis, as created 
            by ``CubicSpline`` 
        bc_type : string, optional 
            Boundary condition type as in ``CubicSpline``: one of the 
            ``not-a-knot``, ``natural``, ``clamped``, or ``periodic``. 
            Necessary for construction an instance of ``BSpline`` class. 
            Default is ``not-a-knot``. 
 
        Returns 
        ------- 
        b : BSpline object 
            A new instance representing the initial polynomial 
            in the B-spline basis. 
 
        Notes 
        ----- 
        .. versionadded:: 1.8.0 
 
        Accepts only ``CubicSpline`` instances for now. 
 
        The algorithm follows from differentiation 
        the Marsden's identity [1]: each of coefficients of spline 
        interpolation function in the B-spline basis is computed as follows: 
 
        .. math:: 
 
            c_j = \sum_{m=0}^{k} \frac{(k-m)!}{k!} 
                       c_{m,i} (-1)^{k-m} D^m p_{j,k}(x_i) 
 
        :math:`c_{m, i}` - a coefficient of CubicSpline, 
        :math:`D^m p_{j, k}(x_i)` - an m-th defivative of a dual polynomial 
        in :math:`x_i`. 
 
        ``k`` always equals 3 for now. 
 
        First ``n - 2`` coefficients are computed in :math:`x_i = x_j`, e.g. 
 
        .. math:: 
 
            c_1 = \sum_{m=0}^{k} \frac{(k-1)!}{k!} c_{m,1} D^m p_{j,3}(x_1) 
 
        Last ``nod + 2`` coefficients are computed in ``x[-2]``, 
        ``nod`` - number of derivatives at the ends. 
 
        For example, consider :math:`x = [0, 1, 2, 3, 4]`, 
        :math:`y = [1, 1, 1, 1, 1]` and bc_type = ``natural`` 
 
        The coefficients of CubicSpline in the power basis: 
 
        :math:`[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], 
        [0, 0, 0, 0, 0], [1, 1, 1, 1, 1]]` 
 
        The knot vector: :math:`t = [0, 0, 0, 0, 1, 2, 3, 4, 4, 4, 4]` 
 
        In this case 
 
        .. math:: 
 
            c_j = \frac{0!}{k!} c_{3, i} k! = c_{3, i} = 1,~j = 0, ..., 6 
 
        References 
        ---------- 
        .. [1] Tom Lyche and Knut Morken, Spline Methods, 2005, Section 3.1.2 
 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">._cubic </span><span class="s0">import </span><span class="s1">CubicSpline</span>
        <span class="s0">if not </span><span class="s1">isinstance(pp</span><span class="s0">, </span><span class="s1">CubicSpline):</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s2">&quot;Only CubicSpline objects are accepted&quot;</span>
                                      <span class="s2">&quot;for now. Got %s instead.&quot; </span><span class="s1">% type(pp))</span>
        <span class="s1">x = pp.x</span>
        <span class="s1">coef = pp.c</span>
        <span class="s1">k = pp.c.shape[</span><span class="s4">0</span><span class="s1">] - </span><span class="s4">1</span>
        <span class="s1">n = x.shape[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s0">if </span><span class="s1">bc_type == </span><span class="s2">'not-a-knot'</span><span class="s1">:</span>
            <span class="s1">t = _not_a_knot(x</span><span class="s0">, </span><span class="s1">k)</span>
        <span class="s0">elif </span><span class="s1">bc_type == </span><span class="s2">'natural' </span><span class="s0">or </span><span class="s1">bc_type == </span><span class="s2">'clamped'</span><span class="s1">:</span>
            <span class="s1">t = _augknt(x</span><span class="s0">, </span><span class="s1">k)</span>
        <span class="s0">elif </span><span class="s1">bc_type == </span><span class="s2">'periodic'</span><span class="s1">:</span>
            <span class="s1">t = _periodic_knots(x</span><span class="s0">, </span><span class="s1">k)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">'Unknown boundary condition: %s' </span><span class="s1">% bc_type)</span>

        <span class="s1">nod = t.shape[</span><span class="s4">0</span><span class="s1">] - (n + k + </span><span class="s4">1</span><span class="s1">)  </span><span class="s5"># number of derivatives at the ends</span>
        <span class="s1">c = np.zeros(n + nod</span><span class="s0">, </span><span class="s1">dtype=pp.c.dtype)</span>
        <span class="s0">for </span><span class="s1">m </span><span class="s0">in </span><span class="s1">range(k + </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(n - </span><span class="s4">2</span><span class="s1">):</span>
                <span class="s1">c[i] += poch(k + </span><span class="s4">1</span><span class="s0">, </span><span class="s1">-m) * coef[m</span><span class="s0">, </span><span class="s1">i]\</span>
                        <span class="s1">* np.power(-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">k - m)\</span>
                        <span class="s1">* _diff_dual_poly(i</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">x[i]</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">t)</span>
            <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(n - </span><span class="s4">2</span><span class="s0">, </span><span class="s1">n + nod):</span>
                <span class="s1">c[j] += poch(k + </span><span class="s4">1</span><span class="s0">, </span><span class="s1">-m) * coef[m</span><span class="s0">, </span><span class="s1">n - </span><span class="s4">2</span><span class="s1">]\</span>
                        <span class="s1">* np.power(-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">k - m)\</span>
                        <span class="s1">* _diff_dual_poly(j</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">x[n - </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">t)</span>
        <span class="s0">return </span><span class="s1">cls.construct_fast(t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">pp.extrapolate</span><span class="s0">, </span><span class="s1">pp.axis)</span>


<span class="s5">#################################</span>
<span class="s5">#  Interpolating spline helpers #</span>
<span class="s5">#################################</span>

<span class="s0">def </span><span class="s1">_not_a_knot(x</span><span class="s0">, </span><span class="s1">k):</span>
    <span class="s3">&quot;&quot;&quot;Given data x, construct the knot vector w/ not-a-knot BC. 
    cf de Boor, XIII(12).&quot;&quot;&quot;</span>
    <span class="s1">x = np.asarray(x)</span>
    <span class="s0">if </span><span class="s1">k % </span><span class="s4">2 </span><span class="s1">!= </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Odd degree for now only. Got %s.&quot; </span><span class="s1">% k)</span>

    <span class="s1">m = (k - </span><span class="s4">1</span><span class="s1">) // </span><span class="s4">2</span>
    <span class="s1">t = x[m+</span><span class="s4">1</span><span class="s1">:-m-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">t = np.r_[(x[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">,</span><span class="s1">)*(k+</span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">(x[-</span><span class="s4">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">)*(k+</span><span class="s4">1</span><span class="s1">)]</span>
    <span class="s0">return </span><span class="s1">t</span>


<span class="s0">def </span><span class="s1">_augknt(x</span><span class="s0">, </span><span class="s1">k):</span>
    <span class="s3">&quot;&quot;&quot;Construct a knot vector appropriate for the order-k interpolation.&quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">np.r_[(x[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">,</span><span class="s1">)*k</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">(x[-</span><span class="s4">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">)*k]</span>


<span class="s0">def </span><span class="s1">_convert_string_aliases(deriv</span><span class="s0">, </span><span class="s1">target_shape):</span>
    <span class="s0">if </span><span class="s1">isinstance(deriv</span><span class="s0">, </span><span class="s1">str):</span>
        <span class="s0">if </span><span class="s1">deriv == </span><span class="s2">&quot;clamped&quot;</span><span class="s1">:</span>
            <span class="s1">deriv = [(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.zeros(target_shape))]</span>
        <span class="s0">elif </span><span class="s1">deriv == </span><span class="s2">&quot;natural&quot;</span><span class="s1">:</span>
            <span class="s1">deriv = [(</span><span class="s4">2</span><span class="s0">, </span><span class="s1">np.zeros(target_shape))]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Unknown boundary condition : %s&quot; </span><span class="s1">% deriv)</span>
    <span class="s0">return </span><span class="s1">deriv</span>


<span class="s0">def </span><span class="s1">_process_deriv_spec(deriv):</span>
    <span class="s0">if </span><span class="s1">deriv </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">ords</span><span class="s0">, </span><span class="s1">vals = zip(*deriv)</span>
        <span class="s0">except </span><span class="s1">TypeError </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s1">msg = (</span><span class="s2">&quot;Derivatives, `bc_type`, should be specified as a pair of &quot;</span>
                   <span class="s2">&quot;iterables of pairs of (order, value).&quot;</span><span class="s1">)</span>
            <span class="s0">raise </span><span class="s1">ValueError(msg) </span><span class="s0">from </span><span class="s1">e</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">ords</span><span class="s0">, </span><span class="s1">vals = []</span><span class="s0">, </span><span class="s1">[]</span>
    <span class="s0">return </span><span class="s1">np.atleast_1d(ords</span><span class="s0">, </span><span class="s1">vals)</span>


<span class="s0">def </span><span class="s1">_woodbury_algorithm(A</span><span class="s0">, </span><span class="s1">ur</span><span class="s0">, </span><span class="s1">ll</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">k):</span>
    <span class="s3">''' 
    Solve a cyclic banded linear system with upper right 
    and lower blocks of size ``(k-1) / 2`` using 
    the Woodbury formula 
 
    Parameters 
    ---------- 
    A : 2-D array, shape(k, n) 
        Matrix of diagonals of original matrix (see 
        ``solve_banded`` documentation). 
    ur : 2-D array, shape(bs, bs) 
        Upper right block matrix. 
    ll : 2-D array, shape(bs, bs) 
        Lower left block matrix. 
    b : 1-D array, shape(n,) 
        Vector of constant terms of the system of linear equations. 
    k : int 
        B-spline degree. 
 
    Returns 
    ------- 
    c : 1-D array, shape(n,) 
        Solution of the original system of linear equations. 
 
    Notes 
    ----- 
    This algorithm works only for systems with banded matrix A plus 
    a correction term U @ V.T, where the matrix U @ V.T gives upper right 
    and lower left block of A 
    The system is solved with the following steps: 
        1.  New systems of linear equations are constructed: 
            A @ z_i = u_i, 
            u_i - columnn vector of U, 
            i = 1, ..., k - 1 
        2.  Matrix Z is formed from vectors z_i: 
            Z = [ z_1 | z_2 | ... | z_{k - 1} ] 
        3.  Matrix H = (1 + V.T @ Z)^{-1} 
        4.  The system A' @ y = b is solved 
        5.  x = y - Z @ (H @ V.T @ y) 
    Also, ``n`` should be greater than ``k``, otherwise corner block 
    elements will intersect with diagonals. 
 
    Examples 
    -------- 
    Consider the case of n = 8, k = 5 (size of blocks - 2 x 2). 
    The matrix of a system:       U:          V: 
      x  x  x  *  *  a  b         a b 0 0     0 0 1 0 
      x  x  x  x  *  *  c         0 c 0 0     0 0 0 1 
      x  x  x  x  x  *  *         0 0 0 0     0 0 0 0 
      *  x  x  x  x  x  *         0 0 0 0     0 0 0 0 
      *  *  x  x  x  x  x         0 0 0 0     0 0 0 0 
      d  *  *  x  x  x  x         0 0 d 0     1 0 0 0 
      e  f  *  *  x  x  x         0 0 e f     0 1 0 0 
 
    References 
    ---------- 
    .. [1] William H. Press, Saul A. Teukolsky, William T. Vetterling 
           and Brian P. Flannery, Numerical Recipes, 2007, Section 2.7.3 
 
    '''</span>
    <span class="s1">k_mod = k - k % </span><span class="s4">2</span>
    <span class="s1">bs = int((k - </span><span class="s4">1</span><span class="s1">) / </span><span class="s4">2</span><span class="s1">) + (k + </span><span class="s4">1</span><span class="s1">) % </span><span class="s4">2</span>

    <span class="s1">n = A.shape[</span><span class="s4">1</span><span class="s1">] + </span><span class="s4">1</span>
    <span class="s1">U = np.zeros((n - </span><span class="s4">1</span><span class="s0">, </span><span class="s1">k_mod))</span>
    <span class="s1">VT = np.zeros((k_mod</span><span class="s0">, </span><span class="s1">n - </span><span class="s4">1</span><span class="s1">))  </span><span class="s5"># V transpose</span>

    <span class="s5"># upper right block</span>
    <span class="s1">U[:bs</span><span class="s0">, </span><span class="s1">:bs] = ur</span>
    <span class="s1">VT[np.arange(bs)</span><span class="s0">, </span><span class="s1">np.arange(bs) - bs] = </span><span class="s4">1</span>

    <span class="s5"># lower left block</span>
    <span class="s1">U[-bs:</span><span class="s0">, </span><span class="s1">-bs:] = ll</span>
    <span class="s1">VT[np.arange(bs) - bs</span><span class="s0">, </span><span class="s1">np.arange(bs)] = </span><span class="s4">1</span>

    <span class="s1">Z = solve_banded((bs</span><span class="s0">, </span><span class="s1">bs)</span><span class="s0">, </span><span class="s1">A</span><span class="s0">, </span><span class="s1">U)</span>

    <span class="s1">H = solve(np.identity(k_mod) + VT @ Z</span><span class="s0">, </span><span class="s1">np.identity(k_mod))</span>

    <span class="s1">y = solve_banded((bs</span><span class="s0">, </span><span class="s1">bs)</span><span class="s0">, </span><span class="s1">A</span><span class="s0">, </span><span class="s1">b)</span>
    <span class="s1">c = y - Z @ (H @ (VT @ y))</span>

    <span class="s0">return </span><span class="s1">c</span>


<span class="s0">def </span><span class="s1">_periodic_knots(x</span><span class="s0">, </span><span class="s1">k):</span>
    <span class="s3">''' 
    returns vector of nodes on circle 
    '''</span>
    <span class="s1">xc = np.copy(x)</span>
    <span class="s1">n = len(xc)</span>
    <span class="s0">if </span><span class="s1">k % </span><span class="s4">2 </span><span class="s1">== </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">dx = np.diff(xc)</span>
        <span class="s1">xc[</span><span class="s4">1</span><span class="s1">: -</span><span class="s4">1</span><span class="s1">] -= dx[:-</span><span class="s4">1</span><span class="s1">] / </span><span class="s4">2</span>
    <span class="s1">dx = np.diff(xc)</span>
    <span class="s1">t = np.zeros(n + </span><span class="s4">2 </span><span class="s1">* k)</span>
    <span class="s1">t[k: -k] = xc</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">k):</span>
        <span class="s5"># filling first `k` elements in descending order</span>
        <span class="s1">t[k - i - </span><span class="s4">1</span><span class="s1">] = t[k - i] - dx[-(i % (n - </span><span class="s4">1</span><span class="s1">)) - </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s5"># filling last `k` elements in ascending order</span>
        <span class="s1">t[-k + i] = t[-k + i - </span><span class="s4">1</span><span class="s1">] + dx[i % (n - </span><span class="s4">1</span><span class="s1">)]</span>
    <span class="s0">return </span><span class="s1">t</span>


<span class="s0">def </span><span class="s1">_make_interp_per_full_matr(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">k):</span>
    <span class="s3">''' 
    Returns a solution of a system for B-spline interpolation with periodic 
    boundary conditions. First ``k - 1`` rows of matrix are condtions of 
    periodicity (continuity of ``k - 1`` derivatives at the boundary points). 
    Last ``n`` rows are interpolation conditions. 
    RHS is ``k - 1`` zeros and ``n`` ordinates in this case. 
 
    Parameters 
    ---------- 
    x : 1-D array, shape (n,) 
        Values of x - coordinate of a given set of points. 
    y : 1-D array, shape (n,) 
        Values of y - coordinate of a given set of points. 
    t : 1-D array, shape(n+2*k,) 
        Vector of knots. 
    k : int 
        The maximum degree of spline 
 
    Returns 
    ------- 
    c : 1-D array, shape (n+k-1,) 
        B-spline coefficients 
 
    Notes 
    ----- 
    ``t`` is supposed to be taken on circle. 
 
    '''</span>

    <span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">t = map(np.asarray</span><span class="s0">, </span><span class="s1">(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">t))</span>

    <span class="s1">n = x.size</span>
    <span class="s5"># LHS: the collocation matrix + derivatives at edges</span>
    <span class="s1">matr = np.zeros((n + k - </span><span class="s4">1</span><span class="s0">, </span><span class="s1">n + k - </span><span class="s4">1</span><span class="s1">))</span>

    <span class="s5"># derivatives at x[0] and x[-1]:</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(k - </span><span class="s4">1</span><span class="s1">):</span>
        <span class="s1">bb = _bspl.evaluate_all_bspl(t</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">x[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">nu=i + </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">matr[i</span><span class="s0">, </span><span class="s1">: k + </span><span class="s4">1</span><span class="s1">] += bb</span>
        <span class="s1">bb = _bspl.evaluate_all_bspl(t</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">x[-</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">n + k - </span><span class="s4">1</span><span class="s0">, </span><span class="s1">nu=i + </span><span class="s4">1</span><span class="s1">)[:-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">matr[i</span><span class="s0">, </span><span class="s1">-k:] -= bb</span>

    <span class="s5"># collocation matrix</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(n):</span>
        <span class="s1">xval = x[i]</span>
        <span class="s5"># find interval</span>
        <span class="s0">if </span><span class="s1">xval == t[k]:</span>
            <span class="s1">left = k</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">left = np.searchsorted(t</span><span class="s0">, </span><span class="s1">xval) - </span><span class="s4">1</span>

        <span class="s5"># fill a row</span>
        <span class="s1">bb = _bspl.evaluate_all_bspl(t</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">xval</span><span class="s0">, </span><span class="s1">left)</span>
        <span class="s1">matr[i + k - </span><span class="s4">1</span><span class="s0">, </span><span class="s1">left-k:left+</span><span class="s4">1</span><span class="s1">] = bb</span>

    <span class="s5"># RHS</span>
    <span class="s1">b = np.r_[[</span><span class="s4">0</span><span class="s1">] * (k - </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">y]</span>

    <span class="s1">c = solve(matr</span><span class="s0">, </span><span class="s1">b)</span>
    <span class="s0">return </span><span class="s1">c</span>


<span class="s0">def </span><span class="s1">_make_periodic_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">axis):</span>
    <span class="s3">''' 
    Compute the (coefficients of) interpolating B-spline with periodic 
    boundary conditions. 
 
    Parameters 
    ---------- 
    x : array_like, shape (n,) 
        Abscissas. 
    y : array_like, shape (n,) 
        Ordinates. 
    k : int 
        B-spline degree. 
    t : array_like, shape (n + 2 * k,). 
        Knots taken on a circle, ``k`` on the left and ``k`` on the right 
        of the vector ``x``. 
 
    Returns 
    ------- 
    b : a BSpline object of the degree ``k`` and with knots ``t``. 
 
    Notes 
    ----- 
    The original system is formed by ``n + k - 1`` equations where the first 
    ``k - 1`` of them stand for the ``k - 1`` derivatives continuity on the 
    edges while the other equations correspond to an interpolating case 
    (matching all the input points). Due to a special form of knot vector, it 
    can be proved that in the original system the first and last ``k`` 
    coefficients of a spline function are the same, respectively. It follows 
    from the fact that all ``k - 1`` derivatives are equal term by term at ends 
    and that the matrix of the original system of linear equations is 
    non-degenerate. So, we can reduce the number of equations to ``n - 1`` 
    (first ``k - 1`` equations could be reduced). Another trick of this 
    implementation is cyclic shift of values of B-splines due to equality of 
    ``k`` unknown coefficients. With this we can receive matrix of the system 
    with upper right and lower left blocks, and ``k`` diagonals.  It allows 
    to use Woodbury formula to optimize the computations. 
 
    '''</span>
    <span class="s1">n = y.shape[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s1">extradim = prod(y.shape[</span><span class="s4">1</span><span class="s1">:])</span>
    <span class="s1">y_new = y.reshape(n</span><span class="s0">, </span><span class="s1">extradim)</span>
    <span class="s1">c = np.zeros((n + k - </span><span class="s4">1</span><span class="s0">, </span><span class="s1">extradim))</span>

    <span class="s5"># n &lt;= k case is solved with full matrix</span>
    <span class="s0">if </span><span class="s1">n &lt;= k:</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(extradim):</span>
            <span class="s1">c[:</span><span class="s0">, </span><span class="s1">i] = _make_interp_per_full_matr(x</span><span class="s0">, </span><span class="s1">y_new[:</span><span class="s0">, </span><span class="s1">i]</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">k)</span>
        <span class="s1">c = np.ascontiguousarray(c.reshape((n + k - </span><span class="s4">1</span><span class="s0">,</span><span class="s1">) + y.shape[</span><span class="s4">1</span><span class="s1">:]))</span>
        <span class="s0">return </span><span class="s1">BSpline.construct_fast(t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">extrapolate=</span><span class="s2">'periodic'</span><span class="s0">, </span><span class="s1">axis=axis)</span>

    <span class="s1">nt = len(t) - k - </span><span class="s4">1</span>

    <span class="s5"># size of block elements</span>
    <span class="s1">kul = int(k / </span><span class="s4">2</span><span class="s1">)</span>

    <span class="s5"># kl = ku = k</span>
    <span class="s1">ab = np.zeros((</span><span class="s4">3 </span><span class="s1">* k + </span><span class="s4">1</span><span class="s0">, </span><span class="s1">nt)</span><span class="s0">, </span><span class="s1">dtype=np.float_</span><span class="s0">, </span><span class="s1">order=</span><span class="s2">'F'</span><span class="s1">)</span>

    <span class="s5"># upper right and lower left blocks</span>
    <span class="s1">ur = np.zeros((kul</span><span class="s0">, </span><span class="s1">kul))</span>
    <span class="s1">ll = np.zeros_like(ur)</span>

    <span class="s5"># `offset` is made to shift all the non-zero elements to the end of the</span>
    <span class="s5"># matrix</span>
    <span class="s1">_bspl._colloc(x</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">ab</span><span class="s0">, </span><span class="s1">offset=k)</span>

    <span class="s5"># remove zeros before the matrix</span>
    <span class="s1">ab = ab[-k - (k + </span><span class="s4">1</span><span class="s1">) % </span><span class="s4">2</span><span class="s1">:</span><span class="s0">, </span><span class="s1">:]</span>

    <span class="s5"># The least elements in rows (except repetitions) are diagonals</span>
    <span class="s5"># of block matrices. Upper right matrix is an upper triangular</span>
    <span class="s5"># matrix while lower left is a lower triangular one.</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(kul):</span>
        <span class="s1">ur += np.diag(ab[-i - </span><span class="s4">1</span><span class="s0">, </span><span class="s1">i: kul]</span><span class="s0">, </span><span class="s1">k=i)</span>
        <span class="s1">ll += np.diag(ab[i</span><span class="s0">, </span><span class="s1">-kul - (k % </span><span class="s4">2</span><span class="s1">): n - </span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">2 </span><span class="s1">* kul - i]</span><span class="s0">, </span><span class="s1">k=-i)</span>

    <span class="s5"># remove elements that occur in the last point</span>
    <span class="s5"># (first and last points are equivalent)</span>
    <span class="s1">A = ab[:</span><span class="s0">, </span><span class="s1">kul: -k + kul]</span>

    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(extradim):</span>
        <span class="s1">cc = _woodbury_algorithm(A</span><span class="s0">, </span><span class="s1">ur</span><span class="s0">, </span><span class="s1">ll</span><span class="s0">, </span><span class="s1">y_new[:</span><span class="s0">, </span><span class="s1">i][:-</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">k)</span>
        <span class="s1">c[:</span><span class="s0">, </span><span class="s1">i] = np.concatenate((cc[-kul:]</span><span class="s0">, </span><span class="s1">cc</span><span class="s0">, </span><span class="s1">cc[:kul + k % </span><span class="s4">2</span><span class="s1">]))</span>
    <span class="s1">c = np.ascontiguousarray(c.reshape((n + k - </span><span class="s4">1</span><span class="s0">,</span><span class="s1">) + y.shape[</span><span class="s4">1</span><span class="s1">:]))</span>
    <span class="s0">return </span><span class="s1">BSpline.construct_fast(t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">extrapolate=</span><span class="s2">'periodic'</span><span class="s0">, </span><span class="s1">axis=axis)</span>


<span class="s0">def </span><span class="s1">make_interp_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">k=</span><span class="s4">3</span><span class="s0">, </span><span class="s1">t=</span><span class="s0">None, </span><span class="s1">bc_type=</span><span class="s0">None, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s0">,</span>
                       <span class="s1">check_finite=</span><span class="s0">True</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Compute the (coefficients of) interpolating B-spline. 
 
    Parameters 
    ---------- 
    x : array_like, shape (n,) 
        Abscissas. 
    y : array_like, shape (n, ...) 
        Ordinates. 
    k : int, optional 
        B-spline degree. Default is cubic, ``k = 3``. 
    t : array_like, shape (nt + k + 1,), optional. 
        Knots. 
        The number of knots needs to agree with the number of data points and 
        the number of derivatives at the edges. Specifically, ``nt - n`` must 
        equal ``len(deriv_l) + len(deriv_r)``. 
    bc_type : 2-tuple or None 
        Boundary conditions. 
        Default is None, which means choosing the boundary conditions 
        automatically. Otherwise, it must be a length-two tuple where the first 
        element (``deriv_l``) sets the boundary conditions at ``x[0]`` and 
        the second element (``deriv_r``) sets the boundary conditions at 
        ``x[-1]``. Each of these must be an iterable of pairs 
        ``(order, value)`` which gives the values of derivatives of specified 
        orders at the given edge of the interpolation interval. 
        Alternatively, the following string aliases are recognized: 
 
        * ``&quot;clamped&quot;``: The first derivatives at the ends are zero. This is 
           equivalent to ``bc_type=([(1, 0.0)], [(1, 0.0)])``. 
        * ``&quot;natural&quot;``: The second derivatives at ends are zero. This is 
          equivalent to ``bc_type=([(2, 0.0)], [(2, 0.0)])``. 
        * ``&quot;not-a-knot&quot;`` (default): The first and second segments are the 
          same polynomial. This is equivalent to having ``bc_type=None``. 
        * ``&quot;periodic&quot;``: The values and the first ``k-1`` derivatives at the 
          ends are equivalent. 
 
    axis : int, optional 
        Interpolation axis. Default is 0. 
    check_finite : bool, optional 
        Whether to check that the input arrays contain only finite numbers. 
        Disabling may give a performance gain, but may result in problems 
        (crashes, non-termination) if the inputs do contain infinities or NaNs. 
        Default is True. 
 
    Returns 
    ------- 
    b : a BSpline object of the degree ``k`` and with knots ``t``. 
 
    See Also 
    -------- 
    BSpline : base class representing the B-spline objects 
    CubicSpline : a cubic spline in the polynomial basis 
    make_lsq_spline : a similar factory function for spline fitting 
    UnivariateSpline : a wrapper over FITPACK spline fitting routines 
    splrep : a wrapper over FITPACK spline fitting routines 
 
    Examples 
    -------- 
 
    Use cubic interpolation on Chebyshev nodes: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; def cheb_nodes(N): 
    ...     jj = 2.*np.arange(N) + 1 
    ...     x = np.cos(np.pi * jj / 2 / N)[::-1] 
    ...     return x 
 
    &gt;&gt;&gt; x = cheb_nodes(20) 
    &gt;&gt;&gt; y = np.sqrt(1 - x**2) 
 
    &gt;&gt;&gt; from scipy.interpolate import BSpline, make_interp_spline 
    &gt;&gt;&gt; b = make_interp_spline(x, y) 
    &gt;&gt;&gt; np.allclose(b(x), y) 
    True 
 
    Note that the default is a cubic spline with a not-a-knot boundary condition 
 
    &gt;&gt;&gt; b.k 
    3 
 
    Here we use a 'natural' spline, with zero 2nd derivatives at edges: 
 
    &gt;&gt;&gt; l, r = [(2, 0.0)], [(2, 0.0)] 
    &gt;&gt;&gt; b_n = make_interp_spline(x, y, bc_type=(l, r))  # or, bc_type=&quot;natural&quot; 
    &gt;&gt;&gt; np.allclose(b_n(x), y) 
    True 
    &gt;&gt;&gt; x0, x1 = x[0], x[-1] 
    &gt;&gt;&gt; np.allclose([b_n(x0, 2), b_n(x1, 2)], [0, 0]) 
    True 
 
    Interpolation of parametric curves is also supported. As an example, we 
    compute a discretization of a snail curve in polar coordinates 
 
    &gt;&gt;&gt; phi = np.linspace(0, 2.*np.pi, 40) 
    &gt;&gt;&gt; r = 0.3 + np.cos(phi) 
    &gt;&gt;&gt; x, y = r*np.cos(phi), r*np.sin(phi)  # convert to Cartesian coordinates 
 
    Build an interpolating curve, parameterizing it by the angle 
 
    &gt;&gt;&gt; spl = make_interp_spline(phi, np.c_[x, y]) 
 
    Evaluate the interpolant on a finer grid (note that we transpose the result 
    to unpack it into a pair of x- and y-arrays) 
 
    &gt;&gt;&gt; phi_new = np.linspace(0, 2.*np.pi, 100) 
    &gt;&gt;&gt; x_new, y_new = spl(phi_new).T 
 
    Plot the result 
 
    &gt;&gt;&gt; plt.plot(x, y, 'o') 
    &gt;&gt;&gt; plt.plot(x_new, y_new, '-') 
    &gt;&gt;&gt; plt.show() 
 
    Build a B-spline curve with 2 dimensional y 
 
    &gt;&gt;&gt; x = np.linspace(0, 2*np.pi, 10) 
    &gt;&gt;&gt; y = np.array([np.sin(x), np.cos(x)]) 
 
    Periodic condition is satisfied because y coordinates of points on the ends 
    are equivalent 
 
    &gt;&gt;&gt; ax = plt.axes(projection='3d') 
    &gt;&gt;&gt; xx = np.linspace(0, 2*np.pi, 100) 
    &gt;&gt;&gt; bspl = make_interp_spline(x, y, k=5, bc_type='periodic', axis=1) 
    &gt;&gt;&gt; ax.plot3D(xx, *bspl(xx)) 
    &gt;&gt;&gt; ax.scatter3D(x, *y, color='red') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s5"># convert string aliases for the boundary conditions</span>
    <span class="s0">if </span><span class="s1">bc_type </span><span class="s0">is None or </span><span class="s1">bc_type == </span><span class="s2">'not-a-knot' </span><span class="s0">or </span><span class="s1">bc_type == </span><span class="s2">'periodic'</span><span class="s1">:</span>
        <span class="s1">deriv_l</span><span class="s0">, </span><span class="s1">deriv_r = </span><span class="s0">None, None</span>
    <span class="s0">elif </span><span class="s1">isinstance(bc_type</span><span class="s0">, </span><span class="s1">str):</span>
        <span class="s1">deriv_l</span><span class="s0">, </span><span class="s1">deriv_r = bc_type</span><span class="s0">, </span><span class="s1">bc_type</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">deriv_l</span><span class="s0">, </span><span class="s1">deriv_r = bc_type</span>
        <span class="s0">except </span><span class="s1">TypeError </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Unknown boundary condition: %s&quot; </span><span class="s1">% bc_type) </span><span class="s0">from </span><span class="s1">e</span>

    <span class="s1">y = np.asarray(y)</span>

    <span class="s1">axis = normalize_axis_index(axis</span><span class="s0">, </span><span class="s1">y.ndim)</span>

    <span class="s1">x = _as_float_array(x</span><span class="s0">, </span><span class="s1">check_finite)</span>
    <span class="s1">y = _as_float_array(y</span><span class="s0">, </span><span class="s1">check_finite)</span>

    <span class="s1">y = np.moveaxis(y</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)    </span><span class="s5"># now internally interp axis is zero</span>

    <span class="s5"># sanity check the input</span>
    <span class="s0">if </span><span class="s1">bc_type == </span><span class="s2">'periodic' </span><span class="s0">and not </span><span class="s1">np.allclose(y[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">y[-</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">1e-15</span><span class="s1">):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;First and last points does not match while &quot;</span>
                         <span class="s2">&quot;periodic case expected&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">x.size != y.shape[</span><span class="s4">0</span><span class="s1">]:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'Shapes of x {} and y {} are incompatible'</span>
                         <span class="s1">.format(x.shape</span><span class="s0">, </span><span class="s1">y.shape))</span>
    <span class="s0">if </span><span class="s1">np.any(x[</span><span class="s4">1</span><span class="s1">:] == x[:-</span><span class="s4">1</span><span class="s1">]):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Expect x to not have duplicates&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">x.ndim != </span><span class="s4">1 </span><span class="s0">or </span><span class="s1">np.any(x[</span><span class="s4">1</span><span class="s1">:] &lt; x[:-</span><span class="s4">1</span><span class="s1">]):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Expect x to be a 1D strictly increasing sequence.&quot;</span><span class="s1">)</span>

    <span class="s5"># special-case k=0 right away</span>
    <span class="s0">if </span><span class="s1">k == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">any(_ </span><span class="s0">is not None for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">(t</span><span class="s0">, </span><span class="s1">deriv_l</span><span class="s0">, </span><span class="s1">deriv_r)):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Too much info for k=0: t and bc_type can only &quot;</span>
                             <span class="s2">&quot;be None.&quot;</span><span class="s1">)</span>
        <span class="s1">t = np.r_[x</span><span class="s0">, </span><span class="s1">x[-</span><span class="s4">1</span><span class="s1">]]</span>
        <span class="s1">c = np.asarray(y)</span>
        <span class="s1">c = np.ascontiguousarray(c</span><span class="s0">, </span><span class="s1">dtype=_get_dtype(c.dtype))</span>
        <span class="s0">return </span><span class="s1">BSpline.construct_fast(t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">axis=axis)</span>

    <span class="s5"># special-case k=1 (e.g., Lyche and Morken, Eq.(2.16))</span>
    <span class="s0">if </span><span class="s1">k == </span><span class="s4">1 </span><span class="s0">and </span><span class="s1">t </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">if not </span><span class="s1">(deriv_l </span><span class="s0">is None and </span><span class="s1">deriv_r </span><span class="s0">is None</span><span class="s1">):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Too much info for k=1: bc_type can only be None.&quot;</span><span class="s1">)</span>
        <span class="s1">t = np.r_[x[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">x[-</span><span class="s4">1</span><span class="s1">]]</span>
        <span class="s1">c = np.asarray(y)</span>
        <span class="s1">c = np.ascontiguousarray(c</span><span class="s0">, </span><span class="s1">dtype=_get_dtype(c.dtype))</span>
        <span class="s0">return </span><span class="s1">BSpline.construct_fast(t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">axis=axis)</span>

    <span class="s1">k = operator.index(k)</span>

    <span class="s0">if </span><span class="s1">bc_type == </span><span class="s2">'periodic' </span><span class="s0">and </span><span class="s1">t </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s2">&quot;For periodic case t is constructed &quot;</span>
                                  <span class="s2">&quot;automatically and can not be passed &quot;</span>
                                  <span class="s2">&quot;manually&quot;</span><span class="s1">)</span>

    <span class="s5"># come up with a sensible knot vector, if needed</span>
    <span class="s0">if </span><span class="s1">t </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">deriv_l </span><span class="s0">is None and </span><span class="s1">deriv_r </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">bc_type == </span><span class="s2">'periodic'</span><span class="s1">:</span>
                <span class="s1">t = _periodic_knots(x</span><span class="s0">, </span><span class="s1">k)</span>
            <span class="s0">elif </span><span class="s1">k == </span><span class="s4">2</span><span class="s1">:</span>
                <span class="s5"># OK, it's a bit ad hoc: Greville sites + omit</span>
                <span class="s5"># 2nd and 2nd-to-last points, a la not-a-knot</span>
                <span class="s1">t = (x[</span><span class="s4">1</span><span class="s1">:] + x[:-</span><span class="s4">1</span><span class="s1">]) / </span><span class="s4">2.</span>
                <span class="s1">t = np.r_[(x[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">,</span><span class="s1">)*(k+</span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span>
                          <span class="s1">t[</span><span class="s4">1</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">]</span><span class="s0">,</span>
                          <span class="s1">(x[-</span><span class="s4">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">)*(k+</span><span class="s4">1</span><span class="s1">)]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">t = _not_a_knot(x</span><span class="s0">, </span><span class="s1">k)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">t = _augknt(x</span><span class="s0">, </span><span class="s1">k)</span>

    <span class="s1">t = _as_float_array(t</span><span class="s0">, </span><span class="s1">check_finite)</span>

    <span class="s0">if </span><span class="s1">k &lt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Expect non-negative k.&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">t.ndim != </span><span class="s4">1 </span><span class="s0">or </span><span class="s1">np.any(t[</span><span class="s4">1</span><span class="s1">:] &lt; t[:-</span><span class="s4">1</span><span class="s1">]):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Expect t to be a 1-D sorted array_like.&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">t.size &lt; x.size + k + </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'Got %d knots, need at least %d.' </span><span class="s1">%</span>
                         <span class="s1">(t.size</span><span class="s0">, </span><span class="s1">x.size + k + </span><span class="s4">1</span><span class="s1">))</span>
    <span class="s0">if </span><span class="s1">(x[</span><span class="s4">0</span><span class="s1">] &lt; t[k]) </span><span class="s0">or </span><span class="s1">(x[-</span><span class="s4">1</span><span class="s1">] &gt; t[-k]):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'Out of bounds w/ x = %s.' </span><span class="s1">% x)</span>

    <span class="s0">if </span><span class="s1">bc_type == </span><span class="s2">'periodic'</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">_make_periodic_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">axis)</span>

    <span class="s5"># Here : deriv_l, r = [(nu, value), ...]</span>
    <span class="s1">deriv_l = _convert_string_aliases(deriv_l</span><span class="s0">, </span><span class="s1">y.shape[</span><span class="s4">1</span><span class="s1">:])</span>
    <span class="s1">deriv_l_ords</span><span class="s0">, </span><span class="s1">deriv_l_vals = _process_deriv_spec(deriv_l)</span>
    <span class="s1">nleft = deriv_l_ords.shape[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s1">deriv_r = _convert_string_aliases(deriv_r</span><span class="s0">, </span><span class="s1">y.shape[</span><span class="s4">1</span><span class="s1">:])</span>
    <span class="s1">deriv_r_ords</span><span class="s0">, </span><span class="s1">deriv_r_vals = _process_deriv_spec(deriv_r)</span>
    <span class="s1">nright = deriv_r_ords.shape[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s5"># have `n` conditions for `nt` coefficients; need nt-n derivatives</span>
    <span class="s1">n = x.size</span>
    <span class="s1">nt = t.size - k - </span><span class="s4">1</span>

    <span class="s0">if </span><span class="s1">nt - n != nleft + nright:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;The number of derivatives at boundaries does not &quot;</span>
                         <span class="s2">&quot;match: expected {}, got {}+{}&quot;</span><span class="s1">.format(nt-n</span><span class="s0">, </span><span class="s1">nleft</span><span class="s0">, </span><span class="s1">nright))</span>

    <span class="s5"># bail out if the `y` array is zero-sized</span>
    <span class="s0">if </span><span class="s1">y.size == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">c = np.zeros((nt</span><span class="s0">,</span><span class="s1">) + y.shape[</span><span class="s4">1</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">dtype=float)</span>
        <span class="s0">return </span><span class="s1">BSpline.construct_fast(t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">axis=axis)</span>

    <span class="s5"># set up the LHS: the collocation matrix + derivatives at boundaries</span>
    <span class="s1">kl = ku = k</span>
    <span class="s1">ab = np.zeros((</span><span class="s4">2</span><span class="s1">*kl + ku + </span><span class="s4">1</span><span class="s0">, </span><span class="s1">nt)</span><span class="s0">, </span><span class="s1">dtype=np.float_</span><span class="s0">, </span><span class="s1">order=</span><span class="s2">'F'</span><span class="s1">)</span>
    <span class="s1">_bspl._colloc(x</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">ab</span><span class="s0">, </span><span class="s1">offset=nleft)</span>
    <span class="s0">if </span><span class="s1">nleft &gt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">_bspl._handle_lhs_derivatives(t</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">x[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ab</span><span class="s0">, </span><span class="s1">kl</span><span class="s0">, </span><span class="s1">ku</span><span class="s0">, </span><span class="s1">deriv_l_ords)</span>
    <span class="s0">if </span><span class="s1">nright &gt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">_bspl._handle_lhs_derivatives(t</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">x[-</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ab</span><span class="s0">, </span><span class="s1">kl</span><span class="s0">, </span><span class="s1">ku</span><span class="s0">, </span><span class="s1">deriv_r_ords</span><span class="s0">,</span>
                                      <span class="s1">offset=nt-nright)</span>

    <span class="s5"># set up the RHS: values to interpolate (+ derivative values, if any)</span>
    <span class="s1">extradim = prod(y.shape[</span><span class="s4">1</span><span class="s1">:])</span>
    <span class="s1">rhs = np.empty((nt</span><span class="s0">, </span><span class="s1">extradim)</span><span class="s0">, </span><span class="s1">dtype=y.dtype)</span>
    <span class="s0">if </span><span class="s1">nleft &gt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">rhs[:nleft] = deriv_l_vals.reshape(-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">extradim)</span>
    <span class="s1">rhs[nleft:nt - nright] = y.reshape(-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">extradim)</span>
    <span class="s0">if </span><span class="s1">nright &gt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">rhs[nt - nright:] = deriv_r_vals.reshape(-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">extradim)</span>

    <span class="s5"># solve Ab @ x = rhs; this is the relevant part of linalg.solve_banded</span>
    <span class="s0">if </span><span class="s1">check_finite:</span>
        <span class="s1">ab</span><span class="s0">, </span><span class="s1">rhs = map(np.asarray_chkfinite</span><span class="s0">, </span><span class="s1">(ab</span><span class="s0">, </span><span class="s1">rhs))</span>
    <span class="s1">gbsv</span><span class="s0">, </span><span class="s1">= get_lapack_funcs((</span><span class="s2">'gbsv'</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(ab</span><span class="s0">, </span><span class="s1">rhs))</span>
    <span class="s1">lu</span><span class="s0">, </span><span class="s1">piv</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">info = gbsv(kl</span><span class="s0">, </span><span class="s1">ku</span><span class="s0">, </span><span class="s1">ab</span><span class="s0">, </span><span class="s1">rhs</span><span class="s0">,</span>
                            <span class="s1">overwrite_ab=</span><span class="s0">True, </span><span class="s1">overwrite_b=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">info &gt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">LinAlgError(</span><span class="s2">&quot;Collocation matrix is singular.&quot;</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">info &lt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'illegal value in %d-th argument of internal gbsv' </span><span class="s1">% -info)</span>

    <span class="s1">c = np.ascontiguousarray(c.reshape((nt</span><span class="s0">,</span><span class="s1">) + y.shape[</span><span class="s4">1</span><span class="s1">:]))</span>
    <span class="s0">return </span><span class="s1">BSpline.construct_fast(t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">axis=axis)</span>


<span class="s0">def </span><span class="s1">make_lsq_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">k=</span><span class="s4">3</span><span class="s0">, </span><span class="s1">w=</span><span class="s0">None, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">check_finite=</span><span class="s0">True</span><span class="s1">):</span>
    <span class="s3">r&quot;&quot;&quot;Compute the (coefficients of) an LSQ (Least SQuared) based 
    fitting B-spline. 
 
    The result is a linear combination 
 
    .. math:: 
 
            S(x) = \sum_j c_j B_j(x; t) 
 
    of the B-spline basis elements, :math:`B_j(x; t)`, which minimizes 
 
    .. math:: 
 
        \sum_{j} \left( w_j \times (S(x_j) - y_j) \right)^2 
 
    Parameters 
    ---------- 
    x : array_like, shape (m,) 
        Abscissas. 
    y : array_like, shape (m, ...) 
        Ordinates. 
    t : array_like, shape (n + k + 1,). 
        Knots. 
        Knots and data points must satisfy Schoenberg-Whitney conditions. 
    k : int, optional 
        B-spline degree. Default is cubic, ``k = 3``. 
    w : array_like, shape (m,), optional 
        Weights for spline fitting. Must be positive. If ``None``, 
        then weights are all equal. 
        Default is ``None``. 
    axis : int, optional 
        Interpolation axis. Default is zero. 
    check_finite : bool, optional 
        Whether to check that the input arrays contain only finite numbers. 
        Disabling may give a performance gain, but may result in problems 
        (crashes, non-termination) if the inputs do contain infinities or NaNs. 
        Default is True. 
 
    Returns 
    ------- 
    b : a BSpline object of the degree ``k`` with knots ``t``. 
 
    See Also 
    -------- 
    BSpline : base class representing the B-spline objects 
    make_interp_spline : a similar factory function for interpolating splines 
    LSQUnivariateSpline : a FITPACK-based spline fitting routine 
    splrep : a FITPACK-based fitting routine 
 
    Notes 
    ----- 
    The number of data points must be larger than the spline degree ``k``. 
 
    Knots ``t`` must satisfy the Schoenberg-Whitney conditions, 
    i.e., there must be a subset of data points ``x[j]`` such that 
    ``t[j] &lt; x[j] &lt; t[j+k+1]``, for ``j=0, 1,...,n-k-2``. 
 
    Examples 
    -------- 
    Generate some noisy data: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; x = np.linspace(-3, 3, 50) 
    &gt;&gt;&gt; y = np.exp(-x**2) + 0.1 * rng.standard_normal(50) 
 
    Now fit a smoothing cubic spline with a pre-defined internal knots. 
    Here we make the knot vector (k+1)-regular by adding boundary knots: 
 
    &gt;&gt;&gt; from scipy.interpolate import make_lsq_spline, BSpline 
    &gt;&gt;&gt; t = [-1, 0, 1] 
    &gt;&gt;&gt; k = 3 
    &gt;&gt;&gt; t = np.r_[(x[0],)*(k+1), 
    ...           t, 
    ...           (x[-1],)*(k+1)] 
    &gt;&gt;&gt; spl = make_lsq_spline(x, y, t, k) 
 
    For comparison, we also construct an interpolating spline for the same 
    set of data: 
 
    &gt;&gt;&gt; from scipy.interpolate import make_interp_spline 
    &gt;&gt;&gt; spl_i = make_interp_spline(x, y) 
 
    Plot both: 
 
    &gt;&gt;&gt; xs = np.linspace(-3, 3, 100) 
    &gt;&gt;&gt; plt.plot(x, y, 'ro', ms=5) 
    &gt;&gt;&gt; plt.plot(xs, spl(xs), 'g-', lw=3, label='LSQ spline') 
    &gt;&gt;&gt; plt.plot(xs, spl_i(xs), 'b-', lw=3, alpha=0.7, label='interp spline') 
    &gt;&gt;&gt; plt.legend(loc='best') 
    &gt;&gt;&gt; plt.show() 
 
    **NaN handling**: If the input arrays contain ``nan`` values, the result is 
    not useful since the underlying spline fitting routines cannot deal with 
    ``nan``. A workaround is to use zero weights for not-a-number data points: 
 
    &gt;&gt;&gt; y[8] = np.nan 
    &gt;&gt;&gt; w = np.isnan(y) 
    &gt;&gt;&gt; y[w] = 0. 
    &gt;&gt;&gt; tck = make_lsq_spline(x, y, t, w=~w) 
 
    Notice the need to replace a ``nan`` by a numerical value (precise value 
    does not matter as long as the corresponding weight is zero.) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x = _as_float_array(x</span><span class="s0">, </span><span class="s1">check_finite)</span>
    <span class="s1">y = _as_float_array(y</span><span class="s0">, </span><span class="s1">check_finite)</span>
    <span class="s1">t = _as_float_array(t</span><span class="s0">, </span><span class="s1">check_finite)</span>
    <span class="s0">if </span><span class="s1">w </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">w = _as_float_array(w</span><span class="s0">, </span><span class="s1">check_finite)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">w = np.ones_like(x)</span>
    <span class="s1">k = operator.index(k)</span>

    <span class="s1">axis = normalize_axis_index(axis</span><span class="s0">, </span><span class="s1">y.ndim)</span>

    <span class="s1">y = np.moveaxis(y</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)    </span><span class="s5"># now internally interp axis is zero</span>

    <span class="s0">if </span><span class="s1">x.ndim != </span><span class="s4">1 </span><span class="s0">or </span><span class="s1">np.any(x[</span><span class="s4">1</span><span class="s1">:] - x[:-</span><span class="s4">1</span><span class="s1">] &lt;= </span><span class="s4">0</span><span class="s1">):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Expect x to be a 1-D sorted array_like.&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">x.shape[</span><span class="s4">0</span><span class="s1">] &lt; k+</span><span class="s4">1</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Need more x points.&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">k &lt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Expect non-negative k.&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">t.ndim != </span><span class="s4">1 </span><span class="s0">or </span><span class="s1">np.any(t[</span><span class="s4">1</span><span class="s1">:] - t[:-</span><span class="s4">1</span><span class="s1">] &lt; </span><span class="s4">0</span><span class="s1">):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Expect t to be a 1-D sorted array_like.&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">x.size != y.shape[</span><span class="s4">0</span><span class="s1">]:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'Shapes of x {} and y {} are incompatible'</span>
                         <span class="s1">.format(x.shape</span><span class="s0">, </span><span class="s1">y.shape))</span>
    <span class="s0">if </span><span class="s1">k &gt; </span><span class="s4">0 </span><span class="s0">and </span><span class="s1">np.any((x &lt; t[k]) | (x &gt; t[-k])):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'Out of bounds w/ x = %s.' </span><span class="s1">% x)</span>
    <span class="s0">if </span><span class="s1">x.size != w.size:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'Shapes of x {} and w {} are incompatible'</span>
                         <span class="s1">.format(x.shape</span><span class="s0">, </span><span class="s1">w.shape))</span>

    <span class="s5"># number of coefficients</span>
    <span class="s1">n = t.size - k - </span><span class="s4">1</span>

    <span class="s5"># construct A.T @ A and rhs with A the collocation matrix, and</span>
    <span class="s5"># rhs = A.T @ y for solving the LSQ problem  ``A.T @ A @ c = A.T @ y``</span>
    <span class="s1">lower = </span><span class="s0">True</span>
    <span class="s1">extradim = prod(y.shape[</span><span class="s4">1</span><span class="s1">:])</span>
    <span class="s1">ab = np.zeros((k+</span><span class="s4">1</span><span class="s0">, </span><span class="s1">n)</span><span class="s0">, </span><span class="s1">dtype=np.float_</span><span class="s0">, </span><span class="s1">order=</span><span class="s2">'F'</span><span class="s1">)</span>
    <span class="s1">rhs = np.zeros((n</span><span class="s0">, </span><span class="s1">extradim)</span><span class="s0">, </span><span class="s1">dtype=y.dtype</span><span class="s0">, </span><span class="s1">order=</span><span class="s2">'F'</span><span class="s1">)</span>
    <span class="s1">_bspl._norm_eq_lsq(x</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">k</span><span class="s0">,</span>
                       <span class="s1">y.reshape(-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">extradim)</span><span class="s0">,</span>
                       <span class="s1">w</span><span class="s0">,</span>
                       <span class="s1">ab</span><span class="s0">, </span><span class="s1">rhs)</span>
    <span class="s1">rhs = rhs.reshape((n</span><span class="s0">,</span><span class="s1">) + y.shape[</span><span class="s4">1</span><span class="s1">:])</span>

    <span class="s5"># have observation matrix &amp; rhs, can solve the LSQ problem</span>
    <span class="s1">cho_decomp = cholesky_banded(ab</span><span class="s0">, </span><span class="s1">overwrite_ab=</span><span class="s0">True, </span><span class="s1">lower=lower</span><span class="s0">,</span>
                                 <span class="s1">check_finite=check_finite)</span>
    <span class="s1">c = cho_solve_banded((cho_decomp</span><span class="s0">, </span><span class="s1">lower)</span><span class="s0">, </span><span class="s1">rhs</span><span class="s0">, </span><span class="s1">overwrite_b=</span><span class="s0">True,</span>
                         <span class="s1">check_finite=check_finite)</span>

    <span class="s1">c = np.ascontiguousarray(c)</span>
    <span class="s0">return </span><span class="s1">BSpline.construct_fast(t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">axis=axis)</span>


<span class="s5">#############################</span>
<span class="s5">#  Smoothing spline helpers #</span>
<span class="s5">#############################</span>

<span class="s0">def </span><span class="s1">_compute_optimal_gcv_parameter(X</span><span class="s0">, </span><span class="s1">wE</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">w):</span>
    <span class="s3">&quot;&quot;&quot; 
    Returns an optimal regularization parameter from the GCV criteria [1]. 
 
    Parameters 
    ---------- 
    X : array, shape (5, n) 
        5 bands of the design matrix ``X`` stored in LAPACK banded storage. 
    wE : array, shape (5, n) 
        5 bands of the penalty matrix :math:`W^{-1} E` stored in LAPACK banded 
        storage. 
    y : array, shape (n,) 
        Ordinates. 
    w : array, shape (n,) 
        Vector of weights. 
 
    Returns 
    ------- 
    lam : float 
        An optimal from the GCV criteria point of view regularization 
        parameter. 
 
    Notes 
    ----- 
    No checks are performed. 
 
    References 
    ---------- 
    .. [1] G. Wahba, &quot;Estimating the smoothing parameter&quot; in Spline models 
        for observational data, Philadelphia, Pennsylvania: Society for 
        Industrial and Applied Mathematics, 1990, pp. 45-65. 
        :doi:`10.1137/1.9781611970128` 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">compute_banded_symmetric_XT_W_Y(X</span><span class="s0">, </span><span class="s1">w</span><span class="s0">, </span><span class="s1">Y):</span>
        <span class="s3">&quot;&quot;&quot; 
        Assuming that the product :math:`X^T W Y` is symmetric and both ``X`` 
        and ``Y`` are 5-banded, compute the unique bands of the product. 
 
        Parameters 
        ---------- 
        X : array, shape (5, n) 
            5 bands of the matrix ``X`` stored in LAPACK banded storage. 
        w : array, shape (n,) 
            Array of weights 
        Y : array, shape (5, n) 
            5 bands of the matrix ``Y`` stored in LAPACK banded storage. 
 
        Returns 
        ------- 
        res : array, shape (4, n) 
            The result of the product :math:`X^T Y` stored in the banded way. 
 
        Notes 
        ----- 
        As far as the matrices ``X`` and ``Y`` are 5-banded, their product 
        :math:`X^T W Y` is 7-banded. It is also symmetric, so we can store only 
        unique diagonals. 
 
        &quot;&quot;&quot;</span>
        <span class="s5"># compute W Y</span>
        <span class="s1">W_Y = np.copy(Y)</span>

        <span class="s1">W_Y[</span><span class="s4">2</span><span class="s1">] *= w</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">2</span><span class="s1">):</span>
            <span class="s1">W_Y[i</span><span class="s0">, </span><span class="s4">2 </span><span class="s1">- i:] *= w[:-</span><span class="s4">2 </span><span class="s1">+ i]</span>
            <span class="s1">W_Y[</span><span class="s4">3 </span><span class="s1">+ i</span><span class="s0">, </span><span class="s1">:-</span><span class="s4">1 </span><span class="s1">- i] *= w[</span><span class="s4">1 </span><span class="s1">+ i:]</span>

        <span class="s1">n = X.shape[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">res = np.zeros((</span><span class="s4">4</span><span class="s0">, </span><span class="s1">n))</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(n):</span>
            <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(min(n-i</span><span class="s0">, </span><span class="s4">4</span><span class="s1">)):</span>
                <span class="s1">res[-j-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">i + j] = sum(X[j:</span><span class="s0">, </span><span class="s1">i] * W_Y[:</span><span class="s4">5</span><span class="s1">-j</span><span class="s0">, </span><span class="s1">i + j])</span>
        <span class="s0">return </span><span class="s1">res</span>

    <span class="s0">def </span><span class="s1">compute_b_inv(A):</span>
        <span class="s3">&quot;&quot;&quot; 
        Inverse 3 central bands of matrix :math:`A=U^T D^{-1} U` assuming that 
        ``U`` is a unit upper triangular banded matrix using an algorithm 
        proposed in [1]. 
 
        Parameters 
        ---------- 
        A : array, shape (4, n) 
            Matrix to inverse, stored in LAPACK banded storage. 
 
        Returns 
        ------- 
        B : array, shape (4, n) 
            3 unique bands of the symmetric matrix that is an inverse to ``A``. 
            The first row is filled with zeros. 
 
        Notes 
        ----- 
        The algorithm is based on the cholesky decomposition and, therefore, 
        in case matrix ``A`` is close to not positive defined, the function 
        raises LinalgError. 
 
        Both matrices ``A`` and ``B`` are stored in LAPACK banded storage. 
 
        References 
        ---------- 
        .. [1] M. F. Hutchinson and F. R. de Hoog, &quot;Smoothing noisy data with 
            spline functions,&quot; Numerische Mathematik, vol. 47, no. 1, 
            pp. 99-106, 1985. 
            :doi:`10.1007/BF01389878` 
 
        &quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">find_b_inv_elem(i</span><span class="s0">, </span><span class="s1">j</span><span class="s0">, </span><span class="s1">U</span><span class="s0">, </span><span class="s1">D</span><span class="s0">, </span><span class="s1">B):</span>
            <span class="s1">rng = min(</span><span class="s4">3</span><span class="s0">, </span><span class="s1">n - i - </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">rng_sum = </span><span class="s4">0.</span>
            <span class="s0">if </span><span class="s1">j == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s5"># use 2-nd formula from [1]</span>
                <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">rng + </span><span class="s4">1</span><span class="s1">):</span>
                    <span class="s1">rng_sum -= U[-k - </span><span class="s4">1</span><span class="s0">, </span><span class="s1">i + k] * B[-k - </span><span class="s4">1</span><span class="s0">, </span><span class="s1">i + k]</span>
                <span class="s1">rng_sum += D[i]</span>
                <span class="s1">B[-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">i] = rng_sum</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s5"># use 1-st formula from [1]</span>
                <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">rng + </span><span class="s4">1</span><span class="s1">):</span>
                    <span class="s1">diag = abs(k - j)</span>
                    <span class="s1">ind = i + min(k</span><span class="s0">, </span><span class="s1">j)</span>
                    <span class="s1">rng_sum -= U[-k - </span><span class="s4">1</span><span class="s0">, </span><span class="s1">i + k] * B[-diag - </span><span class="s4">1</span><span class="s0">, </span><span class="s1">ind + diag]</span>
                <span class="s1">B[-j - </span><span class="s4">1</span><span class="s0">, </span><span class="s1">i + j] = rng_sum</span>

        <span class="s1">U = cholesky_banded(A)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">5</span><span class="s1">):</span>
            <span class="s1">U[-i</span><span class="s0">, </span><span class="s1">i-</span><span class="s4">1</span><span class="s1">:] /= U[-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">:-i+</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">D = </span><span class="s4">1. </span><span class="s1">/ (U[-</span><span class="s4">1</span><span class="s1">])**</span><span class="s4">2</span>
        <span class="s1">U[-</span><span class="s4">1</span><span class="s1">] /= U[-</span><span class="s4">1</span><span class="s1">]</span>

        <span class="s1">n = U.shape[</span><span class="s4">1</span><span class="s1">]</span>

        <span class="s1">B = np.zeros(shape=(</span><span class="s4">4</span><span class="s0">, </span><span class="s1">n))</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(n - </span><span class="s4">1</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(min(</span><span class="s4">3</span><span class="s0">, </span><span class="s1">n - i - </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">):</span>
                <span class="s1">find_b_inv_elem(i</span><span class="s0">, </span><span class="s1">j</span><span class="s0">, </span><span class="s1">U</span><span class="s0">, </span><span class="s1">D</span><span class="s0">, </span><span class="s1">B)</span>
        <span class="s5"># the first row contains garbage and should be removed</span>
        <span class="s1">B[</span><span class="s4">0</span><span class="s1">] = [</span><span class="s4">0.</span><span class="s1">] * n</span>
        <span class="s0">return </span><span class="s1">B</span>

    <span class="s0">def </span><span class="s1">_gcv(lam</span><span class="s0">, </span><span class="s1">X</span><span class="s0">, </span><span class="s1">XtWX</span><span class="s0">, </span><span class="s1">wE</span><span class="s0">, </span><span class="s1">XtE):</span>
        <span class="s3">r&quot;&quot;&quot; 
        Computes the generalized cross-validation criteria [1]. 
 
        Parameters 
        ---------- 
        lam : float, (:math:`\lambda \geq 0`) 
            Regularization parameter. 
        X : array, shape (5, n) 
            Matrix is stored in LAPACK banded storage. 
        XtWX : array, shape (4, n) 
            Product :math:`X^T W X` stored in LAPACK banded storage. 
        wE : array, shape (5, n) 
            Matrix :math:`W^{-1} E` stored in LAPACK banded storage. 
        XtE : array, shape (4, n) 
            Product :math:`X^T E` stored in LAPACK banded storage. 
 
        Returns 
        ------- 
        res : float 
            Value of the GCV criteria with the regularization parameter 
            :math:`\lambda`. 
 
        Notes 
        ----- 
        Criteria is computed from the formula (1.3.2) [3]: 
 
        .. math: 
 
        GCV(\lambda) = \dfrac{1}{n} \sum\limits_{k = 1}^{n} \dfrac{ \left( 
        y_k - f_{\lambda}(x_k) \right)^2}{\left( 1 - \Tr{A}/n\right)^2}$. 
        The criteria is discussed in section 1.3 [3]. 
 
        The numerator is computed using (2.2.4) [3] and the denominator is 
        computed using an algorithm from [2] (see in the ``compute_b_inv`` 
        function). 
 
        References 
        ---------- 
        .. [1] G. Wahba, &quot;Estimating the smoothing parameter&quot; in Spline models 
            for observational data, Philadelphia, Pennsylvania: Society for 
            Industrial and Applied Mathematics, 1990, pp. 45-65. 
            :doi:`10.1137/1.9781611970128` 
        .. [2] M. F. Hutchinson and F. R. de Hoog, &quot;Smoothing noisy data with 
            spline functions,&quot; Numerische Mathematik, vol. 47, no. 1, 
            pp. 99-106, 1985. 
            :doi:`10.1007/BF01389878` 
        .. [3] E. Zemlyanoy, &quot;Generalized cross-validation smoothing splines&quot;, 
            BSc thesis, 2022. Might be available (in Russian) 
            `here &lt;https://www.hse.ru/ba/am/students/diplomas/620910604&gt;`_ 
 
        &quot;&quot;&quot;</span>
        <span class="s5"># Compute the numerator from (2.2.4) [3]</span>
        <span class="s1">n = X.shape[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">c = solve_banded((</span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">X + lam * wE</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">res = np.zeros(n)</span>
        <span class="s5"># compute ``W^{-1} E c`` with respect to banded-storage of ``E``</span>
        <span class="s1">tmp = wE * c</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(n):</span>
            <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(max(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">i - n + </span><span class="s4">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">min(</span><span class="s4">5</span><span class="s0">, </span><span class="s1">i + </span><span class="s4">3</span><span class="s1">)):</span>
                <span class="s1">res[i] += tmp[j</span><span class="s0">, </span><span class="s1">i + </span><span class="s4">2 </span><span class="s1">- j]</span>
        <span class="s1">numer = np.linalg.norm(lam * res)**</span><span class="s4">2 </span><span class="s1">/ n</span>

        <span class="s5"># compute the denominator</span>
        <span class="s1">lhs = XtWX + lam * XtE</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">b_banded = compute_b_inv(lhs)</span>
            <span class="s5"># compute the trace of the product b_banded @ XtX</span>
            <span class="s1">tr = b_banded * XtWX</span>
            <span class="s1">tr[:-</span><span class="s4">1</span><span class="s1">] *= </span><span class="s4">2</span>
            <span class="s5"># find the denominator</span>
            <span class="s1">denom = (</span><span class="s4">1 </span><span class="s1">- sum(sum(tr)) / n)**</span><span class="s4">2</span>
        <span class="s0">except </span><span class="s1">LinAlgError:</span>
            <span class="s5"># cholesky decomposition cannot be performed</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'Seems like the problem is ill-posed'</span><span class="s1">)</span>

        <span class="s1">res = numer / denom</span>

        <span class="s0">return </span><span class="s1">res</span>

    <span class="s1">n = X.shape[</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s1">XtWX = compute_banded_symmetric_XT_W_Y(X</span><span class="s0">, </span><span class="s1">w</span><span class="s0">, </span><span class="s1">X)</span>
    <span class="s1">XtE = compute_banded_symmetric_XT_W_Y(X</span><span class="s0">, </span><span class="s1">w</span><span class="s0">, </span><span class="s1">wE)</span>

    <span class="s0">def </span><span class="s1">fun(lam):</span>
        <span class="s0">return </span><span class="s1">_gcv(lam</span><span class="s0">, </span><span class="s1">X</span><span class="s0">, </span><span class="s1">XtWX</span><span class="s0">, </span><span class="s1">wE</span><span class="s0">, </span><span class="s1">XtE)</span>

    <span class="s1">gcv_est = minimize_scalar(fun</span><span class="s0">, </span><span class="s1">bounds=(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">n)</span><span class="s0">, </span><span class="s1">method=</span><span class="s2">'Bounded'</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">gcv_est.success:</span>
        <span class="s0">return </span><span class="s1">gcv_est.x</span>
    <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">f&quot;Unable to find minimum of the GCV &quot;</span>
                     <span class="s2">f&quot;function: </span><span class="s0">{</span><span class="s1">gcv_est.message</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">_coeff_of_divided_diff(x):</span>
    <span class="s3">&quot;&quot;&quot; 
    Returns the coefficients of the divided difference. 
 
    Parameters 
    ---------- 
    x : array, shape (n,) 
        Array which is used for the computation of divided difference. 
 
    Returns 
    ------- 
    res : array_like, shape (n,) 
        Coefficients of the divided difference. 
 
    Notes 
    ----- 
    Vector ``x`` should have unique elements, otherwise an error division by 
    zero might be raised. 
 
    No checks are performed. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">n = x.shape[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">res = np.zeros(n)</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(n):</span>
        <span class="s1">pp = </span><span class="s4">1.</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(n):</span>
            <span class="s0">if </span><span class="s1">k != i:</span>
                <span class="s1">pp *= (x[i] - x[k])</span>
        <span class="s1">res[i] = </span><span class="s4">1. </span><span class="s1">/ pp</span>
    <span class="s0">return </span><span class="s1">res</span>


<span class="s0">def </span><span class="s1">make_smoothing_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">w=</span><span class="s0">None, </span><span class="s1">lam=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">r&quot;&quot;&quot; 
    Compute the (coefficients of) smoothing cubic spline function using 
    ``lam`` to control the tradeoff between the amount of smoothness of the 
    curve and its proximity to the data. In case ``lam`` is None, using the 
    GCV criteria [1] to find it. 
 
    A smoothing spline is found as a solution to the regularized weighted 
    linear regression problem: 
 
    .. math:: 
 
        \sum\limits_{i=1}^n w_i\lvert y_i - f(x_i) \rvert^2 + 
        \lambda\int\limits_{x_1}^{x_n} (f^{(2)}(u))^2 d u 
 
    where :math:`f` is a spline function, :math:`w` is a vector of weights and 
    :math:`\lambda` is a regularization parameter. 
 
    If ``lam`` is None, we use the GCV criteria to find an optimal 
    regularization parameter, otherwise we solve the regularized weighted 
    linear regression problem with given parameter. The parameter controls 
    the tradeoff in the following way: the larger the parameter becomes, the 
    smoother the function gets. 
 
    Parameters 
    ---------- 
    x : array_like, shape (n,) 
        Abscissas. `n` must be larger than 5. 
    y : array_like, shape (n,) 
        Ordinates. `n` must be larger than 5. 
    w : array_like, shape (n,), optional 
        Vector of weights. Default is ``np.ones_like(x)``. 
    lam : float, (:math:`\lambda \geq 0`), optional 
        Regularization parameter. If ``lam`` is None, then it is found from 
        the GCV criteria. Default is None. 
 
    Returns 
    ------- 
    func : a BSpline object. 
        A callable representing a spline in the B-spline basis 
        as a solution of the problem of smoothing splines using 
        the GCV criteria [1] in case ``lam`` is None, otherwise using the 
        given parameter ``lam``. 
 
    Notes 
    ----- 
    This algorithm is a clean room reimplementation of the algorithm 
    introduced by Woltring in FORTRAN [2]. The original version cannot be used 
    in SciPy source code because of the license issues. The details of the 
    reimplementation are discussed here (available only in Russian) [4]. 
 
    If the vector of weights ``w`` is None, we assume that all the points are 
    equal in terms of weights, and vector of weights is vector of ones. 
 
    Note that in weighted residual sum of squares, weights are not squared: 
    :math:`\sum\limits_{i=1}^n w_i\lvert y_i - f(x_i) \rvert^2` while in 
    ``splrep`` the sum is built from the squared weights. 
 
    In cases when the initial problem is ill-posed (for example, the product 
    :math:`X^T W X` where :math:`X` is a design matrix is not a positive 
    defined matrix) a ValueError is raised. 
 
    References 
    ---------- 
    .. [1] G. Wahba, &quot;Estimating the smoothing parameter&quot; in Spline models for 
        observational data, Philadelphia, Pennsylvania: Society for Industrial 
        and Applied Mathematics, 1990, pp. 45-65. 
        :doi:`10.1137/1.9781611970128` 
    .. [2] H. J. Woltring, A Fortran package for generalized, cross-validatory 
        spline smoothing and differentiation, Advances in Engineering 
        Software, vol. 8, no. 2, pp. 104-113, 1986. 
        :doi:`10.1016/0141-1195(86)90098-7` 
    .. [3] T. Hastie, J. Friedman, and R. Tisbshirani, &quot;Smoothing Splines&quot; in 
        The elements of Statistical Learning: Data Mining, Inference, and 
        prediction, New York: Springer, 2017, pp. 241-249. 
        :doi:`10.1007/978-0-387-84858-7` 
    .. [4] E. Zemlyanoy, &quot;Generalized cross-validation smoothing splines&quot;, 
        BSc thesis, 2022. 
        `&lt;https://www.hse.ru/ba/am/students/diplomas/620910604&gt;`_ (in 
        Russian) 
 
    Examples 
    -------- 
    Generate some noisy data 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; np.random.seed(1234) 
    &gt;&gt;&gt; n = 200 
    &gt;&gt;&gt; def func(x): 
    ...    return x**3 + x**2 * np.sin(4 * x) 
    &gt;&gt;&gt; x = np.sort(np.random.random_sample(n) * 4 - 2) 
    &gt;&gt;&gt; y = func(x) + np.random.normal(scale=1.5, size=n) 
 
    Make a smoothing spline function 
 
    &gt;&gt;&gt; from scipy.interpolate import make_smoothing_spline 
    &gt;&gt;&gt; spl = make_smoothing_spline(x, y) 
 
    Plot both 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; grid = np.linspace(x[0], x[-1], 400) 
    &gt;&gt;&gt; plt.plot(grid, spl(grid), label='Spline') 
    &gt;&gt;&gt; plt.plot(grid, func(grid), label='Original function') 
    &gt;&gt;&gt; plt.scatter(x, y, marker='.') 
    &gt;&gt;&gt; plt.legend(loc='best') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>

    <span class="s1">x = np.ascontiguousarray(x</span><span class="s0">, </span><span class="s1">dtype=float)</span>
    <span class="s1">y = np.ascontiguousarray(y</span><span class="s0">, </span><span class="s1">dtype=float)</span>

    <span class="s0">if </span><span class="s1">any(x[</span><span class="s4">1</span><span class="s1">:] - x[:-</span><span class="s4">1</span><span class="s1">] &lt;= </span><span class="s4">0</span><span class="s1">):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'``x`` should be an ascending array'</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">x.ndim != </span><span class="s4">1 </span><span class="s0">or </span><span class="s1">y.ndim != </span><span class="s4">1 </span><span class="s0">or </span><span class="s1">x.shape[</span><span class="s4">0</span><span class="s1">] != y.shape[</span><span class="s4">0</span><span class="s1">]:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'``x`` and ``y`` should be one dimensional and the'</span>
                         <span class="s2">' same size'</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">w </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">w = np.ones(len(x))</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">w = np.ascontiguousarray(w)</span>
        <span class="s0">if </span><span class="s1">any(w &lt;= </span><span class="s4">0</span><span class="s1">):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'Invalid vector of weights'</span><span class="s1">)</span>

    <span class="s1">t = np.r_[[x[</span><span class="s4">0</span><span class="s1">]] * </span><span class="s4">3</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">[x[-</span><span class="s4">1</span><span class="s1">]] * </span><span class="s4">3</span><span class="s1">]</span>
    <span class="s1">n = x.shape[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s0">if </span><span class="s1">n &lt;= </span><span class="s4">4</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'``x`` and ``y`` length must be larger than 5'</span><span class="s1">)</span>

    <span class="s5"># It is known that the solution to the stated minimization problem exists</span>
    <span class="s5"># and is a natural cubic spline with vector of knots equal to the unique</span>
    <span class="s5"># elements of ``x`` [3], so we will solve the problem in the basis of</span>
    <span class="s5"># natural splines.</span>

    <span class="s5"># create design matrix in the B-spline basis</span>
    <span class="s1">X_bspl = BSpline.design_matrix(x</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span>
    <span class="s5"># move from B-spline basis to the basis of natural splines using equations</span>
    <span class="s5"># (2.1.7) [4]</span>
    <span class="s5"># central elements</span>
    <span class="s1">X = np.zeros((</span><span class="s4">5</span><span class="s0">, </span><span class="s1">n))</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">4</span><span class="s1">):</span>
        <span class="s1">X[i</span><span class="s0">, </span><span class="s4">2</span><span class="s1">: -</span><span class="s4">2</span><span class="s1">] = X_bspl[i: i - </span><span class="s4">4</span><span class="s0">, </span><span class="s4">3</span><span class="s1">: -</span><span class="s4">3</span><span class="s1">][np.diag_indices(n - </span><span class="s4">4</span><span class="s1">)]</span>

    <span class="s5"># first elements</span>
    <span class="s1">X[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">] = X_bspl[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">X[</span><span class="s4">2</span><span class="s0">, </span><span class="s1">:</span><span class="s4">2</span><span class="s1">] = ((x[</span><span class="s4">2</span><span class="s1">] + x[</span><span class="s4">1</span><span class="s1">] - </span><span class="s4">2 </span><span class="s1">* x[</span><span class="s4">0</span><span class="s1">]) * X_bspl[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">X_bspl[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">] + X_bspl[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">])</span>
    <span class="s1">X[</span><span class="s4">3</span><span class="s0">, </span><span class="s1">:</span><span class="s4">2</span><span class="s1">] = ((x[</span><span class="s4">2</span><span class="s1">] - x[</span><span class="s4">0</span><span class="s1">]) * X_bspl[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">X_bspl[</span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s1">])</span>

    <span class="s5"># last elements</span>
    <span class="s1">X[</span><span class="s4">1</span><span class="s0">, </span><span class="s1">-</span><span class="s4">2</span><span class="s1">:] = (X_bspl[-</span><span class="s4">3</span><span class="s0">, </span><span class="s1">-</span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(x[-</span><span class="s4">1</span><span class="s1">] - x[-</span><span class="s4">3</span><span class="s1">]) * X_bspl[-</span><span class="s4">2</span><span class="s0">, </span><span class="s1">-</span><span class="s4">2</span><span class="s1">])</span>
    <span class="s1">X[</span><span class="s4">2</span><span class="s0">, </span><span class="s1">-</span><span class="s4">2</span><span class="s1">:] = (X_bspl[-</span><span class="s4">2</span><span class="s0">, </span><span class="s1">-</span><span class="s4">3</span><span class="s1">] + X_bspl[-</span><span class="s4">2</span><span class="s0">, </span><span class="s1">-</span><span class="s4">2</span><span class="s1">]</span><span class="s0">,</span>
                 <span class="s1">(</span><span class="s4">2 </span><span class="s1">* x[-</span><span class="s4">1</span><span class="s1">] - x[-</span><span class="s4">2</span><span class="s1">] - x[-</span><span class="s4">3</span><span class="s1">]) * X_bspl[-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">X[</span><span class="s4">3</span><span class="s0">, </span><span class="s1">-</span><span class="s4">2</span><span class="s1">] = X_bspl[-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s5"># create penalty matrix and divide it by vector of weights: W^{-1} E</span>
    <span class="s1">wE = np.zeros((</span><span class="s4">5</span><span class="s0">, </span><span class="s1">n))</span>
    <span class="s1">wE[</span><span class="s4">2</span><span class="s1">:</span><span class="s0">, </span><span class="s4">0</span><span class="s1">] = _coeff_of_divided_diff(x[:</span><span class="s4">3</span><span class="s1">]) / w[:</span><span class="s4">3</span><span class="s1">]</span>
    <span class="s1">wE[</span><span class="s4">1</span><span class="s1">:</span><span class="s0">, </span><span class="s4">1</span><span class="s1">] = _coeff_of_divided_diff(x[:</span><span class="s4">4</span><span class="s1">]) / w[:</span><span class="s4">4</span><span class="s1">]</span>
    <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">2</span><span class="s0">, </span><span class="s1">n - </span><span class="s4">2</span><span class="s1">):</span>
        <span class="s1">wE[:</span><span class="s0">, </span><span class="s1">j] = (x[j+</span><span class="s4">2</span><span class="s1">] - x[j-</span><span class="s4">2</span><span class="s1">]) * _coeff_of_divided_diff(x[j-</span><span class="s4">2</span><span class="s1">:j+</span><span class="s4">3</span><span class="s1">])\</span>
                   <span class="s1">/ w[j-</span><span class="s4">2</span><span class="s1">: j+</span><span class="s4">3</span><span class="s1">]</span>

    <span class="s1">wE[:-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">-</span><span class="s4">2</span><span class="s1">] = -_coeff_of_divided_diff(x[-</span><span class="s4">4</span><span class="s1">:]) / w[-</span><span class="s4">4</span><span class="s1">:]</span>
    <span class="s1">wE[:-</span><span class="s4">2</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">] = _coeff_of_divided_diff(x[-</span><span class="s4">3</span><span class="s1">:]) / w[-</span><span class="s4">3</span><span class="s1">:]</span>
    <span class="s1">wE *= </span><span class="s4">6</span>

    <span class="s0">if </span><span class="s1">lam </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">lam = _compute_optimal_gcv_parameter(X</span><span class="s0">, </span><span class="s1">wE</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">w)</span>
    <span class="s0">elif </span><span class="s1">lam &lt; </span><span class="s4">0.</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'Regularization parameter should be non-negative'</span><span class="s1">)</span>

    <span class="s5"># solve the initial problem in the basis of natural splines</span>
    <span class="s1">c = solve_banded((</span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">X + lam * wE</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s5"># move back to B-spline basis using equations (2.2.10) [4]</span>
    <span class="s1">c_ = np.r_[c[</span><span class="s4">0</span><span class="s1">] * (t[</span><span class="s4">5</span><span class="s1">] + t[</span><span class="s4">4</span><span class="s1">] - </span><span class="s4">2 </span><span class="s1">* t[</span><span class="s4">3</span><span class="s1">]) + c[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">,</span>
               <span class="s1">c[</span><span class="s4">0</span><span class="s1">] * (t[</span><span class="s4">5</span><span class="s1">] - t[</span><span class="s4">3</span><span class="s1">]) + c[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">,</span>
               <span class="s1">c[</span><span class="s4">1</span><span class="s1">: -</span><span class="s4">1</span><span class="s1">]</span><span class="s0">,</span>
               <span class="s1">c[-</span><span class="s4">1</span><span class="s1">] * (t[-</span><span class="s4">4</span><span class="s1">] - t[-</span><span class="s4">6</span><span class="s1">]) + c[-</span><span class="s4">2</span><span class="s1">]</span><span class="s0">,</span>
               <span class="s1">c[-</span><span class="s4">1</span><span class="s1">] * (</span><span class="s4">2 </span><span class="s1">* t[-</span><span class="s4">4</span><span class="s1">] - t[-</span><span class="s4">5</span><span class="s1">] - t[-</span><span class="s4">6</span><span class="s1">]) + c[-</span><span class="s4">2</span><span class="s1">]]</span>

    <span class="s0">return </span><span class="s1">BSpline.construct_fast(t</span><span class="s0">, </span><span class="s1">c_</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span>
</pre>
</body>
</html>