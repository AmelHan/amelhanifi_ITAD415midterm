<html>
<head>
<title>_expm_multiply.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_expm_multiply.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Compute the action of the matrix exponential.&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">warnings </span><span class="s2">import </span><span class="s1">warn</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">import </span><span class="s1">scipy.linalg</span>
<span class="s2">import </span><span class="s1">scipy.sparse.linalg</span>
<span class="s2">from </span><span class="s1">scipy.linalg._decomp_qr </span><span class="s2">import </span><span class="s1">qr</span>
<span class="s2">from </span><span class="s1">scipy.sparse._sputils </span><span class="s2">import </span><span class="s1">is_pydata_spmatrix</span>
<span class="s2">from </span><span class="s1">scipy.sparse.linalg </span><span class="s2">import </span><span class="s1">aslinearoperator</span>
<span class="s2">from </span><span class="s1">scipy.sparse.linalg._interface </span><span class="s2">import </span><span class="s1">IdentityOperator</span>
<span class="s2">from </span><span class="s1">scipy.sparse.linalg._onenormest </span><span class="s2">import </span><span class="s1">onenormest</span>

<span class="s1">__all__ = [</span><span class="s3">'expm_multiply'</span><span class="s1">]</span>


<span class="s2">def </span><span class="s1">_exact_inf_norm(A):</span>
    <span class="s4"># A compatibility function which should eventually disappear.</span>
    <span class="s2">if </span><span class="s1">scipy.sparse.issparse(A):</span>
        <span class="s2">return </span><span class="s1">max(abs(A).sum(axis=</span><span class="s5">1</span><span class="s1">).flat)</span>
    <span class="s2">elif </span><span class="s1">is_pydata_spmatrix(A):</span>
        <span class="s2">return </span><span class="s1">max(abs(A).sum(axis=</span><span class="s5">1</span><span class="s1">))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">np.linalg.norm(A</span><span class="s2">, </span><span class="s1">np.inf)</span>


<span class="s2">def </span><span class="s1">_exact_1_norm(A):</span>
    <span class="s4"># A compatibility function which should eventually disappear.</span>
    <span class="s2">if </span><span class="s1">scipy.sparse.issparse(A):</span>
        <span class="s2">return </span><span class="s1">max(abs(A).sum(axis=</span><span class="s5">0</span><span class="s1">).flat)</span>
    <span class="s2">elif </span><span class="s1">is_pydata_spmatrix(A):</span>
        <span class="s2">return </span><span class="s1">max(abs(A).sum(axis=</span><span class="s5">0</span><span class="s1">))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">np.linalg.norm(A</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_trace(A):</span>
    <span class="s4"># A compatibility function which should eventually disappear.</span>
    <span class="s2">if </span><span class="s1">is_pydata_spmatrix(A):</span>
        <span class="s2">return </span><span class="s1">A.to_scipy_sparse().trace()</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">A.trace()</span>


<span class="s2">def </span><span class="s1">traceest(A</span><span class="s2">, </span><span class="s1">m3</span><span class="s2">, </span><span class="s1">seed=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Estimate `np.trace(A)` using `3*m3` matrix-vector products. 
 
    The result is not deterministic. 
 
    Parameters 
    ---------- 
    A : LinearOperator 
        Linear operator whose trace will be estimated. Has to be square. 
    m3 : int 
        Number of matrix-vector products divided by 3 used to estimate the 
        trace. 
    seed : optional 
        Seed for `numpy.random.default_rng`. 
        Can be provided to obtain deterministic results. 
 
    Returns 
    ------- 
    trace : LinearOperator.dtype 
        Estimate of the trace 
 
    Notes 
    ----- 
    This is the Hutch++ algorithm given in [1]_. 
 
    References 
    ---------- 
    .. [1] Meyer, Raphael A., Cameron Musco, Christopher Musco, and David P. 
       Woodruff. &quot;Hutch++: Optimal Stochastic Trace Estimation.&quot; In Symposium 
       on Simplicity in Algorithms (SOSA), pp. 142-155. Society for Industrial 
       and Applied Mathematics, 2021 
       https://doi.org/10.1137/1.9781611976496.16 
 
    &quot;&quot;&quot;</span>
    <span class="s1">rng = np.random.default_rng(seed)</span>
    <span class="s2">if </span><span class="s1">len(A.shape) != </span><span class="s5">2 </span><span class="s2">or </span><span class="s1">A.shape[-</span><span class="s5">1</span><span class="s1">] != A.shape[-</span><span class="s5">2</span><span class="s1">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Expected A to be like a square matrix.&quot;</span><span class="s1">)</span>
    <span class="s1">n = A.shape[-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">S = rng.choice([-</span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">+</span><span class="s5">1.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[n</span><span class="s2">, </span><span class="s1">m3])</span>
    <span class="s1">Q</span><span class="s2">, </span><span class="s1">_ = qr(A.matmat(S)</span><span class="s2">, </span><span class="s1">overwrite_a=</span><span class="s2">True, </span><span class="s1">mode=</span><span class="s3">'economic'</span><span class="s1">)</span>
    <span class="s1">trQAQ = np.trace(Q.conj().T @ A.matmat(Q))</span>
    <span class="s1">G = rng.choice([-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">+</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[n</span><span class="s2">, </span><span class="s1">m3])</span>
    <span class="s1">right = G - Q@(Q.conj().T @ G)</span>
    <span class="s1">trGAG = np.trace(right.conj().T @ A.matmat(right))</span>
    <span class="s2">return </span><span class="s1">trQAQ + trGAG/m3</span>


<span class="s2">def </span><span class="s1">_ident_like(A):</span>
    <span class="s4"># A compatibility function which should eventually disappear.</span>
    <span class="s2">if </span><span class="s1">scipy.sparse.issparse(A):</span>
        <span class="s4"># Creates a sparse matrix in dia format</span>
        <span class="s1">out = scipy.sparse.eye(A.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">A.shape[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=A.dtype)</span>
        <span class="s2">if </span><span class="s1">isinstance(A</span><span class="s2">, </span><span class="s1">scipy.sparse.spmatrix):</span>
            <span class="s2">return </span><span class="s1">out.asformat(A.format)</span>
        <span class="s2">return </span><span class="s1">scipy.sparse.dia_array(out).asformat(A.format)</span>
    <span class="s2">elif </span><span class="s1">is_pydata_spmatrix(A):</span>
        <span class="s2">import </span><span class="s1">sparse</span>
        <span class="s2">return </span><span class="s1">sparse.eye(A.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">A.shape[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=A.dtype)</span>
    <span class="s2">elif </span><span class="s1">isinstance(A</span><span class="s2">, </span><span class="s1">scipy.sparse.linalg.LinearOperator):</span>
        <span class="s2">return </span><span class="s1">IdentityOperator(A.shape</span><span class="s2">, </span><span class="s1">dtype=A.dtype)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">np.eye(A.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">A.shape[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=A.dtype)</span>


<span class="s2">def </span><span class="s1">expm_multiply(A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">start=</span><span class="s2">None, </span><span class="s1">stop=</span><span class="s2">None, </span><span class="s1">num=</span><span class="s2">None,</span>
                  <span class="s1">endpoint=</span><span class="s2">None, </span><span class="s1">traceA=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the action of the matrix exponential of A on B. 
 
    Parameters 
    ---------- 
    A : transposable linear operator 
        The operator whose exponential is of interest. 
    B : ndarray 
        The matrix or vector to be multiplied by the matrix exponential of A. 
    start : scalar, optional 
        The starting time point of the sequence. 
    stop : scalar, optional 
        The end time point of the sequence, unless `endpoint` is set to False. 
        In that case, the sequence consists of all but the last of ``num + 1`` 
        evenly spaced time points, so that `stop` is excluded. 
        Note that the step size changes when `endpoint` is False. 
    num : int, optional 
        Number of time points to use. 
    endpoint : bool, optional 
        If True, `stop` is the last time point.  Otherwise, it is not included. 
    traceA : scalar, optional 
        Trace of `A`. If not given the trace is estimated for linear operators, 
        or calculated exactly for sparse matrices. It is used to precondition 
        `A`, thus an approximate trace is acceptable. 
        For linear operators, `traceA` should be provided to ensure performance 
        as the estimation is not guaranteed to be reliable for all cases. 
 
        .. versionadded:: 1.9.0 
 
    Returns 
    ------- 
    expm_A_B : ndarray 
         The result of the action :math:`e^{t_k A} B`. 
 
    Warns 
    ----- 
    UserWarning 
        If `A` is a linear operator and ``traceA=None`` (default). 
 
    Notes 
    ----- 
    The optional arguments defining the sequence of evenly spaced time points 
    are compatible with the arguments of `numpy.linspace`. 
 
    The output ndarray shape is somewhat complicated so I explain it here. 
    The ndim of the output could be either 1, 2, or 3. 
    It would be 1 if you are computing the expm action on a single vector 
    at a single time point. 
    It would be 2 if you are computing the expm action on a vector 
    at multiple time points, or if you are computing the expm action 
    on a matrix at a single time point. 
    It would be 3 if you want the action on a matrix with multiple 
    columns at multiple time points. 
    If multiple time points are requested, expm_A_B[0] will always 
    be the action of the expm at the first time point, 
    regardless of whether the action is on a vector or a matrix. 
 
    References 
    ---------- 
    .. [1] Awad H. Al-Mohy and Nicholas J. Higham (2011) 
           &quot;Computing the Action of the Matrix Exponential, 
           with an Application to Exponential Integrators.&quot; 
           SIAM Journal on Scientific Computing, 
           33 (2). pp. 488-511. ISSN 1064-8275 
           http://eprints.ma.man.ac.uk/1591/ 
 
    .. [2] Nicholas J. Higham and Awad H. Al-Mohy (2010) 
           &quot;Computing Matrix Functions.&quot; 
           Acta Numerica, 
           19. 159-208. ISSN 0962-4929 
           http://eprints.ma.man.ac.uk/1451/ 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.sparse import csc_matrix 
    &gt;&gt;&gt; from scipy.sparse.linalg import expm, expm_multiply 
    &gt;&gt;&gt; A = csc_matrix([[1, 0], [0, 1]]) 
    &gt;&gt;&gt; A.toarray() 
    array([[1, 0], 
           [0, 1]], dtype=int64) 
    &gt;&gt;&gt; B = np.array([np.exp(-1.), np.exp(-2.)]) 
    &gt;&gt;&gt; B 
    array([ 0.36787944,  0.13533528]) 
    &gt;&gt;&gt; expm_multiply(A, B, start=1, stop=2, num=3, endpoint=True) 
    array([[ 1.        ,  0.36787944], 
           [ 1.64872127,  0.60653066], 
           [ 2.71828183,  1.        ]]) 
    &gt;&gt;&gt; expm(A).dot(B)                  # Verify 1st timestep 
    array([ 1.        ,  0.36787944]) 
    &gt;&gt;&gt; expm(1.5*A).dot(B)              # Verify 2nd timestep 
    array([ 1.64872127,  0.60653066]) 
    &gt;&gt;&gt; expm(2*A).dot(B)                # Verify 3rd timestep 
    array([ 2.71828183,  1.        ]) 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">all(arg </span><span class="s2">is None for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">(start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">num</span><span class="s2">, </span><span class="s1">endpoint)):</span>
        <span class="s1">X = _expm_multiply_simple(A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">traceA=traceA)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">X</span><span class="s2">, </span><span class="s1">status = _expm_multiply_interval(A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">num</span><span class="s2">,</span>
                                            <span class="s1">endpoint</span><span class="s2">, </span><span class="s1">traceA=traceA)</span>
    <span class="s2">return </span><span class="s1">X</span>


<span class="s2">def </span><span class="s1">_expm_multiply_simple(A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">t=</span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">traceA=</span><span class="s2">None, </span><span class="s1">balance=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the action of the matrix exponential at a single time point. 
 
    Parameters 
    ---------- 
    A : transposable linear operator 
        The operator whose exponential is of interest. 
    B : ndarray 
        The matrix to be multiplied by the matrix exponential of A. 
    t : float 
        A time point. 
    traceA : scalar, optional 
        Trace of `A`. If not given the trace is estimated for linear operators, 
        or calculated exactly for sparse matrices. It is used to precondition 
        `A`, thus an approximate trace is acceptable 
    balance : bool 
        Indicates whether or not to apply balancing. 
 
    Returns 
    ------- 
    F : ndarray 
        :math:`e^{t A} B` 
 
    Notes 
    ----- 
    This is algorithm (3.2) in Al-Mohy and Higham (2011). 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">balance:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>
    <span class="s2">if </span><span class="s1">len(A.shape) != </span><span class="s5">2 </span><span class="s2">or </span><span class="s1">A.shape[</span><span class="s5">0</span><span class="s1">] != A.shape[</span><span class="s5">1</span><span class="s1">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'expected A to be like a square matrix'</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">A.shape[</span><span class="s5">1</span><span class="s1">] != B.shape[</span><span class="s5">0</span><span class="s1">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'shapes of matrices A {} and B {} are incompatible'</span>
                         <span class="s1">.format(A.shape</span><span class="s2">, </span><span class="s1">B.shape))</span>
    <span class="s1">ident = _ident_like(A)</span>
    <span class="s1">is_linear_operator = isinstance(A</span><span class="s2">, </span><span class="s1">scipy.sparse.linalg.LinearOperator)</span>
    <span class="s1">n = A.shape[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s2">if </span><span class="s1">len(B.shape) == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">n0 = </span><span class="s5">1</span>
    <span class="s2">elif </span><span class="s1">len(B.shape) == </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s1">n0 = B.shape[</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'expected B to be like a matrix or a vector'</span><span class="s1">)</span>
    <span class="s1">u_d = </span><span class="s5">2</span><span class="s1">**-</span><span class="s5">53</span>
    <span class="s1">tol = u_d</span>
    <span class="s2">if </span><span class="s1">traceA </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">is_linear_operator:</span>
            <span class="s1">warn(</span><span class="s3">&quot;Trace of LinearOperator not available, it will be estimated.&quot;</span>
                 <span class="s3">&quot; Provide `traceA` to ensure performance.&quot;</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s5">3</span><span class="s1">)</span>
        <span class="s4"># m3=1 is bit arbitrary choice, a more accurate trace (larger m3) might</span>
        <span class="s4"># speed up exponential calculation, but trace estimation is more costly</span>
        <span class="s1">traceA = traceest(A</span><span class="s2">, </span><span class="s1">m3=</span><span class="s5">1</span><span class="s1">) </span><span class="s2">if </span><span class="s1">is_linear_operator </span><span class="s2">else </span><span class="s1">_trace(A)</span>
    <span class="s1">mu = traceA / float(n)</span>
    <span class="s1">A = A - mu * ident</span>
    <span class="s1">A_1_norm = onenormest(A) </span><span class="s2">if </span><span class="s1">is_linear_operator </span><span class="s2">else </span><span class="s1">_exact_1_norm(A)</span>
    <span class="s2">if </span><span class="s1">t*A_1_norm == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">m_star</span><span class="s2">, </span><span class="s1">s = </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">ell = </span><span class="s5">2</span>
        <span class="s1">norm_info = LazyOperatorNormInfo(t*A</span><span class="s2">, </span><span class="s1">A_1_norm=t*A_1_norm</span><span class="s2">, </span><span class="s1">ell=ell)</span>
        <span class="s1">m_star</span><span class="s2">, </span><span class="s1">s = _fragment_3_1(norm_info</span><span class="s2">, </span><span class="s1">n0</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">, </span><span class="s1">ell=ell)</span>
    <span class="s2">return </span><span class="s1">_expm_multiply_simple_core(A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">mu</span><span class="s2">, </span><span class="s1">m_star</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">, </span><span class="s1">balance)</span>


<span class="s2">def </span><span class="s1">_expm_multiply_simple_core(A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">mu</span><span class="s2">, </span><span class="s1">m_star</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">tol=</span><span class="s2">None, </span><span class="s1">balance=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    A helper function. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">balance:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>
    <span class="s2">if </span><span class="s1">tol </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">u_d = </span><span class="s5">2 </span><span class="s1">** -</span><span class="s5">53</span>
        <span class="s1">tol = u_d</span>
    <span class="s1">F = B</span>
    <span class="s1">eta = np.exp(t*mu / float(s))</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(s):</span>
        <span class="s1">c1 = _exact_inf_norm(B)</span>
        <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(m_star):</span>
            <span class="s1">coeff = t / float(s*(j+</span><span class="s5">1</span><span class="s1">))</span>
            <span class="s1">B = coeff * A.dot(B)</span>
            <span class="s1">c2 = _exact_inf_norm(B)</span>
            <span class="s1">F = F + B</span>
            <span class="s2">if </span><span class="s1">c1 + c2 &lt;= tol * _exact_inf_norm(F):</span>
                <span class="s2">break</span>
            <span class="s1">c1 = c2</span>
        <span class="s1">F = eta * F</span>
        <span class="s1">B = F</span>
    <span class="s2">return </span><span class="s1">F</span>


<span class="s4"># This table helps to compute bounds.</span>
<span class="s4"># They seem to have been difficult to calculate, involving symbolic</span>
<span class="s4"># manipulation of equations, followed by numerical root finding.</span>
<span class="s1">_theta = {</span>
        <span class="s4"># The first 30 values are from table A.3 of Computing Matrix Functions.</span>
        <span class="s5">1</span><span class="s1">: </span><span class="s5">2.29e-16</span><span class="s2">,</span>
        <span class="s5">2</span><span class="s1">: </span><span class="s5">2.58e-8</span><span class="s2">,</span>
        <span class="s5">3</span><span class="s1">: </span><span class="s5">1.39e-5</span><span class="s2">,</span>
        <span class="s5">4</span><span class="s1">: </span><span class="s5">3.40e-4</span><span class="s2">,</span>
        <span class="s5">5</span><span class="s1">: </span><span class="s5">2.40e-3</span><span class="s2">,</span>
        <span class="s5">6</span><span class="s1">: </span><span class="s5">9.07e-3</span><span class="s2">,</span>
        <span class="s5">7</span><span class="s1">: </span><span class="s5">2.38e-2</span><span class="s2">,</span>
        <span class="s5">8</span><span class="s1">: </span><span class="s5">5.00e-2</span><span class="s2">,</span>
        <span class="s5">9</span><span class="s1">: </span><span class="s5">8.96e-2</span><span class="s2">,</span>
        <span class="s5">10</span><span class="s1">: </span><span class="s5">1.44e-1</span><span class="s2">,</span>
        <span class="s4"># 11</span>
        <span class="s5">11</span><span class="s1">: </span><span class="s5">2.14e-1</span><span class="s2">,</span>
        <span class="s5">12</span><span class="s1">: </span><span class="s5">3.00e-1</span><span class="s2">,</span>
        <span class="s5">13</span><span class="s1">: </span><span class="s5">4.00e-1</span><span class="s2">,</span>
        <span class="s5">14</span><span class="s1">: </span><span class="s5">5.14e-1</span><span class="s2">,</span>
        <span class="s5">15</span><span class="s1">: </span><span class="s5">6.41e-1</span><span class="s2">,</span>
        <span class="s5">16</span><span class="s1">: </span><span class="s5">7.81e-1</span><span class="s2">,</span>
        <span class="s5">17</span><span class="s1">: </span><span class="s5">9.31e-1</span><span class="s2">,</span>
        <span class="s5">18</span><span class="s1">: </span><span class="s5">1.09</span><span class="s2">,</span>
        <span class="s5">19</span><span class="s1">: </span><span class="s5">1.26</span><span class="s2">,</span>
        <span class="s5">20</span><span class="s1">: </span><span class="s5">1.44</span><span class="s2">,</span>
        <span class="s4"># 21</span>
        <span class="s5">21</span><span class="s1">: </span><span class="s5">1.62</span><span class="s2">,</span>
        <span class="s5">22</span><span class="s1">: </span><span class="s5">1.82</span><span class="s2">,</span>
        <span class="s5">23</span><span class="s1">: </span><span class="s5">2.01</span><span class="s2">,</span>
        <span class="s5">24</span><span class="s1">: </span><span class="s5">2.22</span><span class="s2">,</span>
        <span class="s5">25</span><span class="s1">: </span><span class="s5">2.43</span><span class="s2">,</span>
        <span class="s5">26</span><span class="s1">: </span><span class="s5">2.64</span><span class="s2">,</span>
        <span class="s5">27</span><span class="s1">: </span><span class="s5">2.86</span><span class="s2">,</span>
        <span class="s5">28</span><span class="s1">: </span><span class="s5">3.08</span><span class="s2">,</span>
        <span class="s5">29</span><span class="s1">: </span><span class="s5">3.31</span><span class="s2">,</span>
        <span class="s5">30</span><span class="s1">: </span><span class="s5">3.54</span><span class="s2">,</span>
        <span class="s4"># The rest are from table 3.1 of</span>
        <span class="s4"># Computing the Action of the Matrix Exponential.</span>
        <span class="s5">35</span><span class="s1">: </span><span class="s5">4.7</span><span class="s2">,</span>
        <span class="s5">40</span><span class="s1">: </span><span class="s5">6.0</span><span class="s2">,</span>
        <span class="s5">45</span><span class="s1">: </span><span class="s5">7.2</span><span class="s2">,</span>
        <span class="s5">50</span><span class="s1">: </span><span class="s5">8.5</span><span class="s2">,</span>
        <span class="s5">55</span><span class="s1">: </span><span class="s5">9.9</span><span class="s2">,</span>
        <span class="s1">}</span>


<span class="s2">def </span><span class="s1">_onenormest_matrix_power(A</span><span class="s2">, </span><span class="s1">p</span><span class="s2">,</span>
        <span class="s1">t=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">itmax=</span><span class="s5">5</span><span class="s2">, </span><span class="s1">compute_v=</span><span class="s2">False, </span><span class="s1">compute_w=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Efficiently estimate the 1-norm of A^p. 
 
    Parameters 
    ---------- 
    A : ndarray 
        Matrix whose 1-norm of a power is to be computed. 
    p : int 
        Non-negative integer power. 
    t : int, optional 
        A positive parameter controlling the tradeoff between 
        accuracy versus time and memory usage. 
        Larger values take longer and use more memory 
        but give more accurate output. 
    itmax : int, optional 
        Use at most this many iterations. 
    compute_v : bool, optional 
        Request a norm-maximizing linear operator input vector if True. 
    compute_w : bool, optional 
        Request a norm-maximizing linear operator output vector if True. 
 
    Returns 
    ------- 
    est : float 
        An underestimate of the 1-norm of the sparse matrix. 
    v : ndarray, optional 
        The vector such that ||Av||_1 == est*||v||_1. 
        It can be thought of as an input to the linear operator 
        that gives an output with particularly large norm. 
    w : ndarray, optional 
        The vector Av which has relatively large 1-norm. 
        It can be thought of as an output of the linear operator 
        that is relatively large in norm compared to the input. 
 
    &quot;&quot;&quot;</span>
    <span class="s4">#XXX Eventually turn this into an API function in the  _onenormest module,</span>
    <span class="s4">#XXX and remove its underscore,</span>
    <span class="s4">#XXX but wait until expm_multiply goes into scipy.</span>
    <span class="s2">from </span><span class="s1">scipy.sparse.linalg._onenormest </span><span class="s2">import </span><span class="s1">onenormest</span>
    <span class="s2">return </span><span class="s1">onenormest(aslinearoperator(A) ** p)</span>

<span class="s2">class </span><span class="s1">LazyOperatorNormInfo:</span>
    <span class="s0">&quot;&quot;&quot; 
    Information about an operator is lazily computed. 
 
    The information includes the exact 1-norm of the operator, 
    in addition to estimates of 1-norms of powers of the operator. 
    This uses the notation of Computing the Action (2011). 
    This class is specialized enough to probably not be of general interest 
    outside of this module. 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">A</span><span class="s2">, </span><span class="s1">A_1_norm=</span><span class="s2">None, </span><span class="s1">ell=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">scale=</span><span class="s5">1</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Provide the operator and some norm-related information. 
 
        Parameters 
        ---------- 
        A : linear operator 
            The operator of interest. 
        A_1_norm : float, optional 
            The exact 1-norm of A. 
        ell : int, optional 
            A technical parameter controlling norm estimation quality. 
        scale : int, optional 
            If specified, return the norms of scale*A instead of A. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._A = A</span>
        <span class="s1">self._A_1_norm = A_1_norm</span>
        <span class="s1">self._ell = ell</span>
        <span class="s1">self._d = {}</span>
        <span class="s1">self._scale = scale</span>

    <span class="s2">def </span><span class="s1">set_scale(self</span><span class="s2">,</span><span class="s1">scale):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the scale parameter. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._scale = scale</span>

    <span class="s2">def </span><span class="s1">onenorm(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Compute the exact 1-norm. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._A_1_norm </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._A_1_norm = _exact_1_norm(self._A)</span>
        <span class="s2">return </span><span class="s1">self._scale*self._A_1_norm</span>

    <span class="s2">def </span><span class="s1">d(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s0">&quot;&quot;&quot; 
        Lazily estimate d_p(A) ~= || A^p ||^(1/p) where ||.|| is the 1-norm. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">p </span><span class="s2">not in </span><span class="s1">self._d:</span>
            <span class="s1">est = _onenormest_matrix_power(self._A</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">self._ell)</span>
            <span class="s1">self._d[p] = est ** (</span><span class="s5">1.0 </span><span class="s1">/ p)</span>
        <span class="s2">return </span><span class="s1">self._scale*self._d[p]</span>

    <span class="s2">def </span><span class="s1">alpha(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s0">&quot;&quot;&quot; 
        Lazily compute max(d(p), d(p+1)). 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">max(self.d(p)</span><span class="s2">, </span><span class="s1">self.d(p+</span><span class="s5">1</span><span class="s1">))</span>

<span class="s2">def </span><span class="s1">_compute_cost_div_m(m</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">norm_info):</span>
    <span class="s0">&quot;&quot;&quot; 
    A helper function for computing bounds. 
 
    This is equation (3.10). 
    It measures cost in terms of the number of required matrix products. 
 
    Parameters 
    ---------- 
    m : int 
        A valid key of _theta. 
    p : int 
        A matrix power. 
    norm_info : LazyOperatorNormInfo 
        Information about 1-norms of related operators. 
 
    Returns 
    ------- 
    cost_div_m : int 
        Required number of matrix products divided by m. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">int(np.ceil(norm_info.alpha(p) / _theta[m]))</span>


<span class="s2">def </span><span class="s1">_compute_p_max(m_max):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the largest positive integer p such that p*(p-1) &lt;= m_max + 1. 
 
    Do this in a slightly dumb way, but safe and not too slow. 
 
    Parameters 
    ---------- 
    m_max : int 
        A count related to bounds. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">sqrt_m_max = np.sqrt(m_max)</span>
    <span class="s1">p_low = int(np.floor(sqrt_m_max))</span>
    <span class="s1">p_high = int(np.ceil(sqrt_m_max + </span><span class="s5">1</span><span class="s1">))</span>
    <span class="s2">return </span><span class="s1">max(p </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range(p_low</span><span class="s2">, </span><span class="s1">p_high+</span><span class="s5">1</span><span class="s1">) </span><span class="s2">if </span><span class="s1">p*(p-</span><span class="s5">1</span><span class="s1">) &lt;= m_max + </span><span class="s5">1</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_fragment_3_1(norm_info</span><span class="s2">, </span><span class="s1">n0</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">, </span><span class="s1">m_max=</span><span class="s5">55</span><span class="s2">, </span><span class="s1">ell=</span><span class="s5">2</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    A helper function for the _expm_multiply_* functions. 
 
    Parameters 
    ---------- 
    norm_info : LazyOperatorNormInfo 
        Information about norms of certain linear operators of interest. 
    n0 : int 
        Number of columns in the _expm_multiply_* B matrix. 
    tol : float 
        Expected to be 
        :math:`2^{-24}` for single precision or 
        :math:`2^{-53}` for double precision. 
    m_max : int 
        A value related to a bound. 
    ell : int 
        The number of columns used in the 1-norm approximation. 
        This is usually taken to be small, maybe between 1 and 5. 
 
    Returns 
    ------- 
    best_m : int 
        Related to bounds for error control. 
    best_s : int 
        Amount of scaling. 
 
    Notes 
    ----- 
    This is code fragment (3.1) in Al-Mohy and Higham (2011). 
    The discussion of default values for m_max and ell 
    is given between the definitions of equation (3.11) 
    and the definition of equation (3.12). 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">ell &lt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'expected ell to be a positive integer'</span><span class="s1">)</span>
    <span class="s1">best_m = </span><span class="s2">None</span>
    <span class="s1">best_s = </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">_condition_3_13(norm_info.onenorm()</span><span class="s2">, </span><span class="s1">n0</span><span class="s2">, </span><span class="s1">m_max</span><span class="s2">, </span><span class="s1">ell):</span>
        <span class="s2">for </span><span class="s1">m</span><span class="s2">, </span><span class="s1">theta </span><span class="s2">in </span><span class="s1">_theta.items():</span>
            <span class="s1">s = int(np.ceil(norm_info.onenorm() / theta))</span>
            <span class="s2">if </span><span class="s1">best_m </span><span class="s2">is None or </span><span class="s1">m * s &lt; best_m * best_s:</span>
                <span class="s1">best_m = m</span>
                <span class="s1">best_s = s</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s4"># Equation (3.11).</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">2</span><span class="s2">, </span><span class="s1">_compute_p_max(m_max) + </span><span class="s5">1</span><span class="s1">):</span>
            <span class="s2">for </span><span class="s1">m </span><span class="s2">in </span><span class="s1">range(p*(p-</span><span class="s5">1</span><span class="s1">)-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">m_max+</span><span class="s5">1</span><span class="s1">):</span>
                <span class="s2">if </span><span class="s1">m </span><span class="s2">in </span><span class="s1">_theta:</span>
                    <span class="s1">s = _compute_cost_div_m(m</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">norm_info)</span>
                    <span class="s2">if </span><span class="s1">best_m </span><span class="s2">is None or </span><span class="s1">m * s &lt; best_m * best_s:</span>
                        <span class="s1">best_m = m</span>
                        <span class="s1">best_s = s</span>
        <span class="s1">best_s = max(best_s</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">best_m</span><span class="s2">, </span><span class="s1">best_s</span>


<span class="s2">def </span><span class="s1">_condition_3_13(A_1_norm</span><span class="s2">, </span><span class="s1">n0</span><span class="s2">, </span><span class="s1">m_max</span><span class="s2">, </span><span class="s1">ell):</span>
    <span class="s0">&quot;&quot;&quot; 
    A helper function for the _expm_multiply_* functions. 
 
    Parameters 
    ---------- 
    A_1_norm : float 
        The precomputed 1-norm of A. 
    n0 : int 
        Number of columns in the _expm_multiply_* B matrix. 
    m_max : int 
        A value related to a bound. 
    ell : int 
        The number of columns used in the 1-norm approximation. 
        This is usually taken to be small, maybe between 1 and 5. 
 
    Returns 
    ------- 
    value : bool 
        Indicates whether or not the condition has been met. 
 
    Notes 
    ----- 
    This is condition (3.13) in Al-Mohy and Higham (2011). 
 
    &quot;&quot;&quot;</span>

    <span class="s4"># This is the rhs of equation (3.12).</span>
    <span class="s1">p_max = _compute_p_max(m_max)</span>
    <span class="s1">a = </span><span class="s5">2 </span><span class="s1">* ell * p_max * (p_max + </span><span class="s5">3</span><span class="s1">)</span>

    <span class="s4"># Evaluate the condition (3.13).</span>
    <span class="s1">b = _theta[m_max] / float(n0 * m_max)</span>
    <span class="s2">return </span><span class="s1">A_1_norm &lt;= a * b</span>


<span class="s2">def </span><span class="s1">_expm_multiply_interval(A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">start=</span><span class="s2">None, </span><span class="s1">stop=</span><span class="s2">None, </span><span class="s1">num=</span><span class="s2">None,</span>
                            <span class="s1">endpoint=</span><span class="s2">None, </span><span class="s1">traceA=</span><span class="s2">None, </span><span class="s1">balance=</span><span class="s2">False,</span>
                            <span class="s1">status_only=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the action of the matrix exponential at multiple time points. 
 
    Parameters 
    ---------- 
    A : transposable linear operator 
        The operator whose exponential is of interest. 
    B : ndarray 
        The matrix to be multiplied by the matrix exponential of A. 
    start : scalar, optional 
        The starting time point of the sequence. 
    stop : scalar, optional 
        The end time point of the sequence, unless `endpoint` is set to False. 
        In that case, the sequence consists of all but the last of ``num + 1`` 
        evenly spaced time points, so that `stop` is excluded. 
        Note that the step size changes when `endpoint` is False. 
    num : int, optional 
        Number of time points to use. 
    traceA : scalar, optional 
        Trace of `A`. If not given the trace is estimated for linear operators, 
        or calculated exactly for sparse matrices. It is used to precondition 
        `A`, thus an approximate trace is acceptable 
    endpoint : bool, optional 
        If True, `stop` is the last time point. Otherwise, it is not included. 
    balance : bool 
        Indicates whether or not to apply balancing. 
    status_only : bool 
        A flag that is set to True for some debugging and testing operations. 
 
    Returns 
    ------- 
    F : ndarray 
        :math:`e^{t_k A} B` 
    status : int 
        An integer status for testing and debugging. 
 
    Notes 
    ----- 
    This is algorithm (5.2) in Al-Mohy and Higham (2011). 
 
    There seems to be a typo, where line 15 of the algorithm should be 
    moved to line 6.5 (between lines 6 and 7). 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">balance:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>
    <span class="s2">if </span><span class="s1">len(A.shape) != </span><span class="s5">2 </span><span class="s2">or </span><span class="s1">A.shape[</span><span class="s5">0</span><span class="s1">] != A.shape[</span><span class="s5">1</span><span class="s1">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'expected A to be like a square matrix'</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">A.shape[</span><span class="s5">1</span><span class="s1">] != B.shape[</span><span class="s5">0</span><span class="s1">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'shapes of matrices A {} and B {} are incompatible'</span>
                         <span class="s1">.format(A.shape</span><span class="s2">, </span><span class="s1">B.shape))</span>
    <span class="s1">ident = _ident_like(A)</span>
    <span class="s1">is_linear_operator = isinstance(A</span><span class="s2">, </span><span class="s1">scipy.sparse.linalg.LinearOperator)</span>
    <span class="s1">n = A.shape[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s2">if </span><span class="s1">len(B.shape) == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">n0 = </span><span class="s5">1</span>
    <span class="s2">elif </span><span class="s1">len(B.shape) == </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s1">n0 = B.shape[</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'expected B to be like a matrix or a vector'</span><span class="s1">)</span>
    <span class="s1">u_d = </span><span class="s5">2</span><span class="s1">**-</span><span class="s5">53</span>
    <span class="s1">tol = u_d</span>
    <span class="s2">if </span><span class="s1">traceA </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">is_linear_operator:</span>
            <span class="s1">warn(</span><span class="s3">&quot;Trace of LinearOperator not available, it will be estimated.&quot;</span>
                 <span class="s3">&quot; Provide `traceA` to ensure performance.&quot;</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s5">3</span><span class="s1">)</span>
        <span class="s4"># m3=5 is bit arbitrary choice, a more accurate trace (larger m3) might</span>
        <span class="s4"># speed up exponential calculation, but trace estimation is also costly</span>
        <span class="s4"># an educated guess would need to consider the number of time points</span>
        <span class="s1">traceA = traceest(A</span><span class="s2">, </span><span class="s1">m3=</span><span class="s5">5</span><span class="s1">) </span><span class="s2">if </span><span class="s1">is_linear_operator </span><span class="s2">else </span><span class="s1">_trace(A)</span>
    <span class="s1">mu = traceA / float(n)</span>

    <span class="s4"># Get the linspace samples, attempting to preserve the linspace defaults.</span>
    <span class="s1">linspace_kwargs = {</span><span class="s3">'retstep'</span><span class="s1">: </span><span class="s2">True</span><span class="s1">}</span>
    <span class="s2">if </span><span class="s1">num </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">linspace_kwargs[</span><span class="s3">'num'</span><span class="s1">] = num</span>
    <span class="s2">if </span><span class="s1">endpoint </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">linspace_kwargs[</span><span class="s3">'endpoint'</span><span class="s1">] = endpoint</span>
    <span class="s1">samples</span><span class="s2">, </span><span class="s1">step = np.linspace(start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">**linspace_kwargs)</span>

    <span class="s4"># Convert the linspace output to the notation used by the publication.</span>
    <span class="s1">nsamples = len(samples)</span>
    <span class="s2">if </span><span class="s1">nsamples &lt; </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'at least two time points are required'</span><span class="s1">)</span>
    <span class="s1">q = nsamples - </span><span class="s5">1</span>
    <span class="s1">h = step</span>
    <span class="s1">t_0 = samples[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">t_q = samples[q]</span>

    <span class="s4"># Define the output ndarray.</span>
    <span class="s4"># Use an ndim=3 shape, such that the last two indices</span>
    <span class="s4"># are the ones that may be involved in level 3 BLAS operations.</span>
    <span class="s1">X_shape = (nsamples</span><span class="s2">,</span><span class="s1">) + B.shape</span>
    <span class="s1">X = np.empty(X_shape</span><span class="s2">, </span><span class="s1">dtype=np.result_type(A.dtype</span><span class="s2">, </span><span class="s1">B.dtype</span><span class="s2">, </span><span class="s1">float))</span>
    <span class="s1">t = t_q - t_0</span>
    <span class="s1">A = A - mu * ident</span>
    <span class="s1">A_1_norm = onenormest(A) </span><span class="s2">if </span><span class="s1">is_linear_operator </span><span class="s2">else </span><span class="s1">_exact_1_norm(A)</span>
    <span class="s1">ell = </span><span class="s5">2</span>
    <span class="s1">norm_info = LazyOperatorNormInfo(t*A</span><span class="s2">, </span><span class="s1">A_1_norm=t*A_1_norm</span><span class="s2">, </span><span class="s1">ell=ell)</span>
    <span class="s2">if </span><span class="s1">t*A_1_norm == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">m_star</span><span class="s2">, </span><span class="s1">s = </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">m_star</span><span class="s2">, </span><span class="s1">s = _fragment_3_1(norm_info</span><span class="s2">, </span><span class="s1">n0</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">, </span><span class="s1">ell=ell)</span>

    <span class="s4"># Compute the expm action up to the initial time point.</span>
    <span class="s1">X[</span><span class="s5">0</span><span class="s1">] = _expm_multiply_simple_core(A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">t_0</span><span class="s2">, </span><span class="s1">mu</span><span class="s2">, </span><span class="s1">m_star</span><span class="s2">, </span><span class="s1">s)</span>

    <span class="s4"># Compute the expm action at the rest of the time points.</span>
    <span class="s2">if </span><span class="s1">q &lt;= s:</span>
        <span class="s2">if </span><span class="s1">status_only:</span>
            <span class="s2">return </span><span class="s5">0</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">_expm_multiply_interval_core_0(A</span><span class="s2">, </span><span class="s1">X</span><span class="s2">,</span>
                    <span class="s1">h</span><span class="s2">, </span><span class="s1">mu</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">norm_info</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">, </span><span class="s1">ell</span><span class="s2">,</span><span class="s1">n0)</span>
    <span class="s2">elif not </span><span class="s1">(q % s):</span>
        <span class="s2">if </span><span class="s1">status_only:</span>
            <span class="s2">return </span><span class="s5">1</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">_expm_multiply_interval_core_1(A</span><span class="s2">, </span><span class="s1">X</span><span class="s2">,</span>
                    <span class="s1">h</span><span class="s2">, </span><span class="s1">mu</span><span class="s2">, </span><span class="s1">m_star</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">tol)</span>
    <span class="s2">elif </span><span class="s1">(q % s):</span>
        <span class="s2">if </span><span class="s1">status_only:</span>
            <span class="s2">return </span><span class="s5">2</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">_expm_multiply_interval_core_2(A</span><span class="s2">, </span><span class="s1">X</span><span class="s2">,</span>
                    <span class="s1">h</span><span class="s2">, </span><span class="s1">mu</span><span class="s2">, </span><span class="s1">m_star</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">tol)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">Exception(</span><span class="s3">'internal error'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_expm_multiply_interval_core_0(A</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">mu</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">norm_info</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">, </span><span class="s1">ell</span><span class="s2">, </span><span class="s1">n0):</span>
    <span class="s0">&quot;&quot;&quot; 
    A helper function, for the case q &lt;= s. 
    &quot;&quot;&quot;</span>

    <span class="s4"># Compute the new values of m_star and s which should be applied</span>
    <span class="s4"># over intervals of size t/q</span>
    <span class="s2">if </span><span class="s1">norm_info.onenorm() == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">m_star</span><span class="s2">, </span><span class="s1">s = </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">norm_info.set_scale(</span><span class="s5">1.</span><span class="s1">/q)</span>
        <span class="s1">m_star</span><span class="s2">, </span><span class="s1">s = _fragment_3_1(norm_info</span><span class="s2">, </span><span class="s1">n0</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">, </span><span class="s1">ell=ell)</span>
        <span class="s1">norm_info.set_scale(</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range(q):</span>
        <span class="s1">X[k+</span><span class="s5">1</span><span class="s1">] = _expm_multiply_simple_core(A</span><span class="s2">, </span><span class="s1">X[k]</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">mu</span><span class="s2">, </span><span class="s1">m_star</span><span class="s2">, </span><span class="s1">s)</span>
    <span class="s2">return </span><span class="s1">X</span><span class="s2">, </span><span class="s5">0</span>


<span class="s2">def </span><span class="s1">_expm_multiply_interval_core_1(A</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">mu</span><span class="s2">, </span><span class="s1">m_star</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">tol):</span>
    <span class="s0">&quot;&quot;&quot; 
    A helper function, for the case q &gt; s and q % s == 0. 
    &quot;&quot;&quot;</span>
    <span class="s1">d = q // s</span>
    <span class="s1">input_shape = X.shape[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s1">K_shape = (m_star + </span><span class="s5">1</span><span class="s2">, </span><span class="s1">) + input_shape</span>
    <span class="s1">K = np.empty(K_shape</span><span class="s2">, </span><span class="s1">dtype=X.dtype)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(s):</span>
        <span class="s1">Z = X[i*d]</span>
        <span class="s1">K[</span><span class="s5">0</span><span class="s1">] = Z</span>
        <span class="s1">high_p = </span><span class="s5">0</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">d+</span><span class="s5">1</span><span class="s1">):</span>
            <span class="s1">F = K[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">c1 = _exact_inf_norm(F)</span>
            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">m_star+</span><span class="s5">1</span><span class="s1">):</span>
                <span class="s2">if </span><span class="s1">p &gt; high_p:</span>
                    <span class="s1">K[p] = h * A.dot(K[p-</span><span class="s5">1</span><span class="s1">]) / float(p)</span>
                <span class="s1">coeff = float(pow(k</span><span class="s2">, </span><span class="s1">p))</span>
                <span class="s1">F = F + coeff * K[p]</span>
                <span class="s1">inf_norm_K_p_1 = _exact_inf_norm(K[p])</span>
                <span class="s1">c2 = coeff * inf_norm_K_p_1</span>
                <span class="s2">if </span><span class="s1">c1 + c2 &lt;= tol * _exact_inf_norm(F):</span>
                    <span class="s2">break</span>
                <span class="s1">c1 = c2</span>
            <span class="s1">X[k + i*d] = np.exp(k*h*mu) * F</span>
    <span class="s2">return </span><span class="s1">X</span><span class="s2">, </span><span class="s5">1</span>


<span class="s2">def </span><span class="s1">_expm_multiply_interval_core_2(A</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">mu</span><span class="s2">, </span><span class="s1">m_star</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">tol):</span>
    <span class="s0">&quot;&quot;&quot; 
    A helper function, for the case q &gt; s and q % s &gt; 0. 
    &quot;&quot;&quot;</span>
    <span class="s1">d = q // s</span>
    <span class="s1">j = q // d</span>
    <span class="s1">r = q - d * j</span>
    <span class="s1">input_shape = X.shape[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s1">K_shape = (m_star + </span><span class="s5">1</span><span class="s2">, </span><span class="s1">) + input_shape</span>
    <span class="s1">K = np.empty(K_shape</span><span class="s2">, </span><span class="s1">dtype=X.dtype)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(j + </span><span class="s5">1</span><span class="s1">):</span>
        <span class="s1">Z = X[i*d]</span>
        <span class="s1">K[</span><span class="s5">0</span><span class="s1">] = Z</span>
        <span class="s1">high_p = </span><span class="s5">0</span>
        <span class="s2">if </span><span class="s1">i &lt; j:</span>
            <span class="s1">effective_d = d</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">effective_d = r</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">effective_d+</span><span class="s5">1</span><span class="s1">):</span>
            <span class="s1">F = K[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">c1 = _exact_inf_norm(F)</span>
            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">m_star+</span><span class="s5">1</span><span class="s1">):</span>
                <span class="s2">if </span><span class="s1">p == high_p + </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">K[p] = h * A.dot(K[p-</span><span class="s5">1</span><span class="s1">]) / float(p)</span>
                    <span class="s1">high_p = p</span>
                <span class="s1">coeff = float(pow(k</span><span class="s2">, </span><span class="s1">p))</span>
                <span class="s1">F = F + coeff * K[p]</span>
                <span class="s1">inf_norm_K_p_1 = _exact_inf_norm(K[p])</span>
                <span class="s1">c2 = coeff * inf_norm_K_p_1</span>
                <span class="s2">if </span><span class="s1">c1 + c2 &lt;= tol * _exact_inf_norm(F):</span>
                    <span class="s2">break</span>
                <span class="s1">c1 = c2</span>
            <span class="s1">X[k + i*d] = np.exp(k*h*mu) * F</span>
    <span class="s2">return </span><span class="s1">X</span><span class="s2">, </span><span class="s5">2</span>
</pre>
</body>
</html>