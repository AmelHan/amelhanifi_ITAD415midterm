<html>
<head>
<title>test_kdtree.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_kdtree.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright Anne M. Archibald 2008</span>
<span class="s0"># Released under the scipy license</span>

<span class="s2">import </span><span class="s1">os</span>
<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">(assert_equal</span><span class="s2">, </span><span class="s1">assert_array_equal</span><span class="s2">, </span><span class="s1">assert_</span><span class="s2">,</span>
                           <span class="s1">assert_almost_equal</span><span class="s2">, </span><span class="s1">assert_array_almost_equal</span><span class="s2">,</span>
                           <span class="s1">assert_allclose)</span>
<span class="s2">from </span><span class="s1">pytest </span><span class="s2">import </span><span class="s1">raises </span><span class="s2">as </span><span class="s1">assert_raises</span>
<span class="s2">import </span><span class="s1">pytest</span>
<span class="s2">from </span><span class="s1">platform </span><span class="s2">import </span><span class="s1">python_implementation</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">scipy.spatial </span><span class="s2">import </span><span class="s1">KDTree</span><span class="s2">, </span><span class="s1">Rectangle</span><span class="s2">, </span><span class="s1">distance_matrix</span><span class="s2">, </span><span class="s1">cKDTree</span>
<span class="s2">from </span><span class="s1">scipy.spatial._ckdtree </span><span class="s2">import </span><span class="s1">cKDTreeNode</span>
<span class="s2">from </span><span class="s1">scipy.spatial </span><span class="s2">import </span><span class="s1">minkowski_distance</span>

<span class="s2">import </span><span class="s1">itertools</span>

<span class="s1">@pytest.fixture(params=[KDTree</span><span class="s2">, </span><span class="s1">cKDTree])</span>
<span class="s2">def </span><span class="s1">kdtree_type(request):</span>
    <span class="s2">return </span><span class="s1">request.param</span>


<span class="s2">def </span><span class="s1">KDTreeTest(kls):</span>
    <span class="s3">&quot;&quot;&quot;Class decorator to create test cases for KDTree and cKDTree 
 
    Tests use the class variable ``kdtree_type`` as the tree constructor. 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">kls.__name__.startswith(</span><span class="s4">'_Test'</span><span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s4">&quot;Expected a class name starting with _Test&quot;</span><span class="s1">)</span>

    <span class="s2">for </span><span class="s1">tree </span><span class="s2">in </span><span class="s1">(KDTree</span><span class="s2">, </span><span class="s1">cKDTree):</span>
        <span class="s1">test_name = kls.__name__[</span><span class="s5">1</span><span class="s1">:] + </span><span class="s4">'_' </span><span class="s1">+ tree.__name__</span>

        <span class="s2">if </span><span class="s1">test_name </span><span class="s2">in </span><span class="s1">globals():</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s4">&quot;Duplicated test name: &quot; </span><span class="s1">+ test_name)</span>

        <span class="s0"># Create a new sub-class with kdtree_type defined</span>
        <span class="s1">test_case = type(test_name</span><span class="s2">, </span><span class="s1">(kls</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">{</span><span class="s4">'kdtree_type'</span><span class="s1">: tree})</span>
        <span class="s1">globals()[test_name] = test_case</span>
    <span class="s2">return </span><span class="s1">kls</span>


<span class="s2">def </span><span class="s1">distance_box(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">boxsize):</span>
    <span class="s1">diff = a - b</span>
    <span class="s1">diff[diff &gt; </span><span class="s5">0.5 </span><span class="s1">* boxsize] -= boxsize</span>
    <span class="s1">diff[diff &lt; -</span><span class="s5">0.5 </span><span class="s1">* boxsize] += boxsize</span>
    <span class="s1">d = minkowski_distance(diff</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">p)</span>
    <span class="s2">return </span><span class="s1">d</span>

<span class="s2">class </span><span class="s1">ConsistencyTests:</span>
    <span class="s2">def </span><span class="s1">distance(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s2">return </span><span class="s1">minkowski_distance(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">p)</span>

    <span class="s2">def </span><span class="s1">test_nearest(self):</span>
        <span class="s1">x = self.x</span>
        <span class="s1">d</span><span class="s2">, </span><span class="s1">i = self.kdtree.query(x</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(d**</span><span class="s5">2</span><span class="s2">, </span><span class="s1">np.sum((x-self.data[i])**</span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">eps = </span><span class="s5">1e-8</span>
        <span class="s1">assert_(np.all(np.sum((self.data-x[np.newaxis</span><span class="s2">, </span><span class="s1">:])**</span><span class="s5">2</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">1</span><span class="s1">) &gt; d**</span><span class="s5">2</span><span class="s1">-eps))</span>

    <span class="s2">def </span><span class="s1">test_m_nearest(self):</span>
        <span class="s1">x = self.x</span>
        <span class="s1">m = self.m</span>
        <span class="s1">dd</span><span class="s2">, </span><span class="s1">ii = self.kdtree.query(x</span><span class="s2">, </span><span class="s1">m)</span>
        <span class="s1">d = np.amax(dd)</span>
        <span class="s1">i = ii[np.argmax(dd)]</span>
        <span class="s1">assert_almost_equal(d**</span><span class="s5">2</span><span class="s2">, </span><span class="s1">np.sum((x-self.data[i])**</span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">eps = </span><span class="s5">1e-8</span>
        <span class="s1">assert_equal(np.sum(np.sum((self.data-x[np.newaxis</span><span class="s2">, </span><span class="s1">:])**</span><span class="s5">2</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">1</span><span class="s1">) &lt; d**</span><span class="s5">2</span><span class="s1">+eps)</span><span class="s2">, </span><span class="s1">m)</span>

    <span class="s2">def </span><span class="s1">test_points_near(self):</span>
        <span class="s1">x = self.x</span>
        <span class="s1">d = self.d</span>
        <span class="s1">dd</span><span class="s2">, </span><span class="s1">ii = self.kdtree.query(x</span><span class="s2">, </span><span class="s1">k=self.kdtree.n</span><span class="s2">, </span><span class="s1">distance_upper_bound=d)</span>
        <span class="s1">eps = </span><span class="s5">1e-8</span>
        <span class="s1">hits = </span><span class="s5">0</span>
        <span class="s2">for </span><span class="s1">near_d</span><span class="s2">, </span><span class="s1">near_i </span><span class="s2">in </span><span class="s1">zip(dd</span><span class="s2">, </span><span class="s1">ii):</span>
            <span class="s2">if </span><span class="s1">near_d == np.inf:</span>
                <span class="s2">continue</span>
            <span class="s1">hits += </span><span class="s5">1</span>
            <span class="s1">assert_almost_equal(near_d**</span><span class="s5">2</span><span class="s2">, </span><span class="s1">np.sum((x-self.data[near_i])**</span><span class="s5">2</span><span class="s1">))</span>
            <span class="s1">assert_(near_d &lt; d+eps</span><span class="s2">, </span><span class="s4">f&quot;near_d=</span><span class="s2">{</span><span class="s1">near_d</span><span class="s2">:</span><span class="s4">g</span><span class="s2">} </span><span class="s4">should be less than </span><span class="s2">{</span><span class="s1">d</span><span class="s2">:</span><span class="s4">g</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.sum(self.distance(self.data</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s5">2</span><span class="s1">) &lt; d**</span><span class="s5">2</span><span class="s1">+eps)</span><span class="s2">, </span><span class="s1">hits)</span>

    <span class="s2">def </span><span class="s1">test_points_near_l1(self):</span>
        <span class="s1">x = self.x</span>
        <span class="s1">d = self.d</span>
        <span class="s1">dd</span><span class="s2">, </span><span class="s1">ii = self.kdtree.query(x</span><span class="s2">, </span><span class="s1">k=self.kdtree.n</span><span class="s2">, </span><span class="s1">p=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">distance_upper_bound=d)</span>
        <span class="s1">eps = </span><span class="s5">1e-8</span>
        <span class="s1">hits = </span><span class="s5">0</span>
        <span class="s2">for </span><span class="s1">near_d</span><span class="s2">, </span><span class="s1">near_i </span><span class="s2">in </span><span class="s1">zip(dd</span><span class="s2">, </span><span class="s1">ii):</span>
            <span class="s2">if </span><span class="s1">near_d == np.inf:</span>
                <span class="s2">continue</span>
            <span class="s1">hits += </span><span class="s5">1</span>
            <span class="s1">assert_almost_equal(near_d</span><span class="s2">, </span><span class="s1">self.distance(x</span><span class="s2">, </span><span class="s1">self.data[near_i]</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>
            <span class="s1">assert_(near_d &lt; d+eps</span><span class="s2">, </span><span class="s4">f&quot;near_d=</span><span class="s2">{</span><span class="s1">near_d</span><span class="s2">:</span><span class="s4">g</span><span class="s2">} </span><span class="s4">should be less than </span><span class="s2">{</span><span class="s1">d</span><span class="s2">:</span><span class="s4">g</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.sum(self.distance(self.data</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s5">1</span><span class="s1">) &lt; d+eps)</span><span class="s2">, </span><span class="s1">hits)</span>

    <span class="s2">def </span><span class="s1">test_points_near_linf(self):</span>
        <span class="s1">x = self.x</span>
        <span class="s1">d = self.d</span>
        <span class="s1">dd</span><span class="s2">, </span><span class="s1">ii = self.kdtree.query(x</span><span class="s2">, </span><span class="s1">k=self.kdtree.n</span><span class="s2">, </span><span class="s1">p=np.inf</span><span class="s2">, </span><span class="s1">distance_upper_bound=d)</span>
        <span class="s1">eps = </span><span class="s5">1e-8</span>
        <span class="s1">hits = </span><span class="s5">0</span>
        <span class="s2">for </span><span class="s1">near_d</span><span class="s2">, </span><span class="s1">near_i </span><span class="s2">in </span><span class="s1">zip(dd</span><span class="s2">, </span><span class="s1">ii):</span>
            <span class="s2">if </span><span class="s1">near_d == np.inf:</span>
                <span class="s2">continue</span>
            <span class="s1">hits += </span><span class="s5">1</span>
            <span class="s1">assert_almost_equal(near_d</span><span class="s2">, </span><span class="s1">self.distance(x</span><span class="s2">, </span><span class="s1">self.data[near_i]</span><span class="s2">, </span><span class="s1">np.inf))</span>
            <span class="s1">assert_(near_d &lt; d+eps</span><span class="s2">, </span><span class="s4">f&quot;near_d=</span><span class="s2">{</span><span class="s1">near_d</span><span class="s2">:</span><span class="s4">g</span><span class="s2">} </span><span class="s4">should be less than </span><span class="s2">{</span><span class="s1">d</span><span class="s2">:</span><span class="s4">g</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.sum(self.distance(self.data</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">np.inf) &lt; d+eps)</span><span class="s2">, </span><span class="s1">hits)</span>

    <span class="s2">def </span><span class="s1">test_approx(self):</span>
        <span class="s1">x = self.x</span>
        <span class="s1">k = self.k</span>
        <span class="s1">eps = </span><span class="s5">0.1</span>
        <span class="s1">d_real</span><span class="s2">, </span><span class="s1">i_real = self.kdtree.query(x</span><span class="s2">, </span><span class="s1">k)</span>
        <span class="s1">d</span><span class="s2">, </span><span class="s1">i = self.kdtree.query(x</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">eps=eps)</span>
        <span class="s1">assert_(np.all(d &lt;= d_real*(</span><span class="s5">1</span><span class="s1">+eps)))</span>


<span class="s1">@KDTreeTest</span>
<span class="s2">class </span><span class="s1">_Test_random(ConsistencyTests):</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.n = </span><span class="s5">100</span>
        <span class="s1">self.m = </span><span class="s5">4</span>
        <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
        <span class="s1">self.data = np.random.randn(self.n</span><span class="s2">, </span><span class="s1">self.m)</span>
        <span class="s1">self.kdtree = self.kdtree_type(self.data</span><span class="s2">, </span><span class="s1">leafsize=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">self.x = np.random.randn(self.m)</span>
        <span class="s1">self.d = </span><span class="s5">0.2</span>
        <span class="s1">self.k = </span><span class="s5">10</span>


<span class="s1">@KDTreeTest</span>
<span class="s2">class </span><span class="s1">_Test_random_far(_Test_random):</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">super().setup_method()</span>
        <span class="s1">self.x = np.random.randn(self.m)+</span><span class="s5">10</span>


<span class="s1">@KDTreeTest</span>
<span class="s2">class </span><span class="s1">_Test_small(ConsistencyTests):</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.data = np.array([[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]])</span>
        <span class="s1">self.kdtree = self.kdtree_type(self.data)</span>
        <span class="s1">self.n = self.kdtree.n</span>
        <span class="s1">self.m = self.kdtree.m</span>
        <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
        <span class="s1">self.x = np.random.randn(</span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">self.d = </span><span class="s5">0.5</span>
        <span class="s1">self.k = </span><span class="s5">4</span>

    <span class="s2">def </span><span class="s1">test_nearest(self):</span>
        <span class="s1">assert_array_equal(</span>
                <span class="s1">self.kdtree.query((</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0.1</span><span class="s1">)</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_nearest_two(self):</span>
        <span class="s1">assert_array_equal(</span>
                <span class="s1">self.kdtree.query((</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0.1</span><span class="s1">)</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">([</span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">0.9</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]))</span>


<span class="s1">@KDTreeTest</span>
<span class="s2">class </span><span class="s1">_Test_small_nonleaf(_Test_small):</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">super().setup_method()</span>
        <span class="s1">self.kdtree = self.kdtree_type(self.data</span><span class="s2">, </span><span class="s1">leafsize=</span><span class="s5">1</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">Test_vectorization_KDTree:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.data = np.array([[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]])</span>
        <span class="s1">self.kdtree = KDTree(self.data)</span>

    <span class="s2">def </span><span class="s1">test_single_query(self):</span>
        <span class="s1">d</span><span class="s2">, </span><span class="s1">i = self.kdtree.query(np.array([</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]))</span>
        <span class="s1">assert_(isinstance(d</span><span class="s2">, </span><span class="s1">float))</span>
        <span class="s1">assert_(np.issubdtype(i</span><span class="s2">, </span><span class="s1">np.signedinteger))</span>

    <span class="s2">def </span><span class="s1">test_vectorized_query(self):</span>
        <span class="s1">d</span><span class="s2">, </span><span class="s1">i = self.kdtree.query(np.zeros((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)))</span>
        <span class="s1">assert_equal(np.shape(d)</span><span class="s2">, </span><span class="s1">(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">assert_equal(np.shape(i)</span><span class="s2">, </span><span class="s1">(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">4</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_single_query_multiple_neighbors(self):</span>
        <span class="s1">s = </span><span class="s5">23</span>
        <span class="s1">kk = self.kdtree.n+s</span>
        <span class="s1">d</span><span class="s2">, </span><span class="s1">i = self.kdtree.query(np.array([</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">])</span><span class="s2">, </span><span class="s1">k=kk)</span>
        <span class="s1">assert_equal(np.shape(d)</span><span class="s2">, </span><span class="s1">(kk</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">assert_equal(np.shape(i)</span><span class="s2">, </span><span class="s1">(kk</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">assert_(np.all(~np.isfinite(d[-s:])))</span>
        <span class="s1">assert_(np.all(i[-s:] == self.kdtree.n))</span>

    <span class="s2">def </span><span class="s1">test_vectorized_query_multiple_neighbors(self):</span>
        <span class="s1">s = </span><span class="s5">23</span>
        <span class="s1">kk = self.kdtree.n+s</span>
        <span class="s1">d</span><span class="s2">, </span><span class="s1">i = self.kdtree.query(np.zeros((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">3</span><span class="s1">))</span><span class="s2">, </span><span class="s1">k=kk)</span>
        <span class="s1">assert_equal(np.shape(d)</span><span class="s2">, </span><span class="s1">(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s1">kk))</span>
        <span class="s1">assert_equal(np.shape(i)</span><span class="s2">, </span><span class="s1">(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s1">kk))</span>
        <span class="s1">assert_(np.all(~np.isfinite(d[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">-s:])))</span>
        <span class="s1">assert_(np.all(i[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">-s:] == self.kdtree.n))</span>

    <span class="s2">def </span><span class="s1">test_query_raises_for_k_none(self):</span>
        <span class="s1">x = </span><span class="s5">1.0</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;k must be an integer or*&quot;</span><span class="s1">):</span>
            <span class="s1">self.kdtree.query(x</span><span class="s2">, </span><span class="s1">k=</span><span class="s2">None</span><span class="s1">)</span>

<span class="s2">class </span><span class="s1">Test_vectorization_cKDTree:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.data = np.array([[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]])</span>
        <span class="s1">self.kdtree = cKDTree(self.data)</span>

    <span class="s2">def </span><span class="s1">test_single_query(self):</span>
        <span class="s1">d</span><span class="s2">, </span><span class="s1">i = self.kdtree.query([</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">])</span>
        <span class="s1">assert_(isinstance(d</span><span class="s2">, </span><span class="s1">float))</span>
        <span class="s1">assert_(isinstance(i</span><span class="s2">, </span><span class="s1">int))</span>

    <span class="s2">def </span><span class="s1">test_vectorized_query(self):</span>
        <span class="s1">d</span><span class="s2">, </span><span class="s1">i = self.kdtree.query(np.zeros((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)))</span>
        <span class="s1">assert_equal(np.shape(d)</span><span class="s2">, </span><span class="s1">(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">assert_equal(np.shape(i)</span><span class="s2">, </span><span class="s1">(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">4</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_vectorized_query_noncontiguous_values(self):</span>
        <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
        <span class="s1">qs = np.random.randn(</span><span class="s5">3</span><span class="s2">, </span><span class="s5">1000</span><span class="s1">).T</span>
        <span class="s1">ds</span><span class="s2">, </span><span class="s1">i_s = self.kdtree.query(qs)</span>
        <span class="s2">for </span><span class="s1">q</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">i </span><span class="s2">in </span><span class="s1">zip(qs</span><span class="s2">, </span><span class="s1">ds</span><span class="s2">, </span><span class="s1">i_s):</span>
            <span class="s1">assert_equal(self.kdtree.query(q)</span><span class="s2">, </span><span class="s1">(d</span><span class="s2">, </span><span class="s1">i))</span>

    <span class="s2">def </span><span class="s1">test_single_query_multiple_neighbors(self):</span>
        <span class="s1">s = </span><span class="s5">23</span>
        <span class="s1">kk = self.kdtree.n+s</span>
        <span class="s1">d</span><span class="s2">, </span><span class="s1">i = self.kdtree.query([</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">k=kk)</span>
        <span class="s1">assert_equal(np.shape(d)</span><span class="s2">, </span><span class="s1">(kk</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">assert_equal(np.shape(i)</span><span class="s2">, </span><span class="s1">(kk</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">assert_(np.all(~np.isfinite(d[-s:])))</span>
        <span class="s1">assert_(np.all(i[-s:] == self.kdtree.n))</span>

    <span class="s2">def </span><span class="s1">test_vectorized_query_multiple_neighbors(self):</span>
        <span class="s1">s = </span><span class="s5">23</span>
        <span class="s1">kk = self.kdtree.n+s</span>
        <span class="s1">d</span><span class="s2">, </span><span class="s1">i = self.kdtree.query(np.zeros((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">3</span><span class="s1">))</span><span class="s2">, </span><span class="s1">k=kk)</span>
        <span class="s1">assert_equal(np.shape(d)</span><span class="s2">, </span><span class="s1">(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s1">kk))</span>
        <span class="s1">assert_equal(np.shape(i)</span><span class="s2">, </span><span class="s1">(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s1">kk))</span>
        <span class="s1">assert_(np.all(~np.isfinite(d[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">-s:])))</span>
        <span class="s1">assert_(np.all(i[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">-s:] == self.kdtree.n))</span>

<span class="s2">class </span><span class="s1">ball_consistency:</span>
    <span class="s1">tol = </span><span class="s5">0.0</span>

    <span class="s2">def </span><span class="s1">distance(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s2">return </span><span class="s1">minkowski_distance(a * </span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">b * </span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">p)</span>

    <span class="s2">def </span><span class="s1">test_in_ball(self):</span>
        <span class="s1">x = np.atleast_2d(self.x)</span>
        <span class="s1">d = np.broadcast_to(self.d</span><span class="s2">, </span><span class="s1">x.shape[:-</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">l = self.T.query_ball_point(x</span><span class="s2">, </span><span class="s1">self.d</span><span class="s2">, </span><span class="s1">p=self.p</span><span class="s2">, </span><span class="s1">eps=self.eps)</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">ind </span><span class="s2">in </span><span class="s1">enumerate(l):</span>
            <span class="s1">dist = self.distance(self.data[ind]</span><span class="s2">, </span><span class="s1">x[i]</span><span class="s2">, </span><span class="s1">self.p) - d[i]*(</span><span class="s5">1.</span><span class="s1">+self.eps)</span>
            <span class="s1">norm = self.distance(self.data[ind]</span><span class="s2">, </span><span class="s1">x[i]</span><span class="s2">, </span><span class="s1">self.p) + d[i]*(</span><span class="s5">1.</span><span class="s1">+self.eps)</span>
            <span class="s1">assert_array_equal(dist &lt; self.tol * norm</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_found_all(self):</span>
        <span class="s1">x = np.atleast_2d(self.x)</span>
        <span class="s1">d = np.broadcast_to(self.d</span><span class="s2">, </span><span class="s1">x.shape[:-</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">l = self.T.query_ball_point(x</span><span class="s2">, </span><span class="s1">self.d</span><span class="s2">, </span><span class="s1">p=self.p</span><span class="s2">, </span><span class="s1">eps=self.eps)</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">ind </span><span class="s2">in </span><span class="s1">enumerate(l):</span>
            <span class="s1">c = np.ones(self.T.n</span><span class="s2">, </span><span class="s1">dtype=bool)</span>
            <span class="s1">c[ind] = </span><span class="s2">False</span>
            <span class="s1">dist = self.distance(self.data[c]</span><span class="s2">, </span><span class="s1">x[i]</span><span class="s2">, </span><span class="s1">self.p) - d[i]/(</span><span class="s5">1.</span><span class="s1">+self.eps)</span>
            <span class="s1">norm = self.distance(self.data[c]</span><span class="s2">, </span><span class="s1">x[i]</span><span class="s2">, </span><span class="s1">self.p) + d[i]/(</span><span class="s5">1.</span><span class="s1">+self.eps)</span>
            <span class="s1">assert_array_equal(dist &gt; -self.tol * norm</span><span class="s2">, True</span><span class="s1">)</span>

<span class="s1">@KDTreeTest</span>
<span class="s2">class </span><span class="s1">_Test_random_ball(ball_consistency):</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">n = </span><span class="s5">100</span>
        <span class="s1">m = </span><span class="s5">4</span>
        <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
        <span class="s1">self.data = np.random.randn(n</span><span class="s2">, </span><span class="s1">m)</span>
        <span class="s1">self.T = self.kdtree_type(self.data</span><span class="s2">, </span><span class="s1">leafsize=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">self.x = np.random.randn(m)</span>
        <span class="s1">self.p = </span><span class="s5">2.</span>
        <span class="s1">self.eps = </span><span class="s5">0</span>
        <span class="s1">self.d = </span><span class="s5">0.2</span>


<span class="s1">@KDTreeTest</span>
<span class="s2">class </span><span class="s1">_Test_random_ball_periodic(ball_consistency):</span>
    <span class="s2">def </span><span class="s1">distance(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s2">return </span><span class="s1">distance_box(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s5">1.0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">n = </span><span class="s5">10000</span>
        <span class="s1">m = </span><span class="s5">4</span>
        <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
        <span class="s1">self.data = np.random.uniform(size=(n</span><span class="s2">, </span><span class="s1">m))</span>
        <span class="s1">self.T = self.kdtree_type(self.data</span><span class="s2">, </span><span class="s1">leafsize=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">boxsize=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">self.x = np.full(m</span><span class="s2">, </span><span class="s5">0.1</span><span class="s1">)</span>
        <span class="s1">self.p = </span><span class="s5">2.</span>
        <span class="s1">self.eps = </span><span class="s5">0</span>
        <span class="s1">self.d = </span><span class="s5">0.2</span>

    <span class="s2">def </span><span class="s1">test_in_ball_outside(self):</span>
        <span class="s1">l = self.T.query_ball_point(self.x + </span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">self.d</span><span class="s2">, </span><span class="s1">p=self.p</span><span class="s2">, </span><span class="s1">eps=self.eps)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">l:</span>
            <span class="s1">assert_(self.distance(self.data[i]</span><span class="s2">, </span><span class="s1">self.x</span><span class="s2">, </span><span class="s1">self.p) &lt;= self.d*(</span><span class="s5">1.</span><span class="s1">+self.eps))</span>
        <span class="s1">l = self.T.query_ball_point(self.x - </span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">self.d</span><span class="s2">, </span><span class="s1">p=self.p</span><span class="s2">, </span><span class="s1">eps=self.eps)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">l:</span>
            <span class="s1">assert_(self.distance(self.data[i]</span><span class="s2">, </span><span class="s1">self.x</span><span class="s2">, </span><span class="s1">self.p) &lt;= self.d*(</span><span class="s5">1.</span><span class="s1">+self.eps))</span>

    <span class="s2">def </span><span class="s1">test_found_all_outside(self):</span>
        <span class="s1">c = np.ones(self.T.n</span><span class="s2">, </span><span class="s1">dtype=bool)</span>
        <span class="s1">l = self.T.query_ball_point(self.x + </span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">self.d</span><span class="s2">, </span><span class="s1">p=self.p</span><span class="s2">, </span><span class="s1">eps=self.eps)</span>
        <span class="s1">c[l] = </span><span class="s2">False</span>
        <span class="s1">assert_(np.all(self.distance(self.data[c]</span><span class="s2">, </span><span class="s1">self.x</span><span class="s2">, </span><span class="s1">self.p) &gt;= self.d/(</span><span class="s5">1.</span><span class="s1">+self.eps)))</span>

        <span class="s1">l = self.T.query_ball_point(self.x - </span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">self.d</span><span class="s2">, </span><span class="s1">p=self.p</span><span class="s2">, </span><span class="s1">eps=self.eps)</span>
        <span class="s1">c[l] = </span><span class="s2">False</span>
        <span class="s1">assert_(np.all(self.distance(self.data[c]</span><span class="s2">, </span><span class="s1">self.x</span><span class="s2">, </span><span class="s1">self.p) &gt;= self.d/(</span><span class="s5">1.</span><span class="s1">+self.eps)))</span>


<span class="s1">@KDTreeTest</span>
<span class="s2">class </span><span class="s1">_Test_random_ball_largep_issue9890(ball_consistency):</span>

    <span class="s0"># allow some roundoff errors due to numerical issues</span>
    <span class="s1">tol = </span><span class="s5">1e-13</span>

    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">n = </span><span class="s5">1000</span>
        <span class="s1">m = </span><span class="s5">2</span>
        <span class="s1">np.random.seed(</span><span class="s5">123</span><span class="s1">)</span>
        <span class="s1">self.data = np.random.randint(</span><span class="s5">100</span><span class="s2">, </span><span class="s5">1000</span><span class="s2">, </span><span class="s1">size=(n</span><span class="s2">, </span><span class="s1">m))</span>
        <span class="s1">self.T = self.kdtree_type(self.data)</span>
        <span class="s1">self.x = self.data</span>
        <span class="s1">self.p = </span><span class="s5">100</span>
        <span class="s1">self.eps = </span><span class="s5">0</span>
        <span class="s1">self.d = </span><span class="s5">10</span>


<span class="s1">@KDTreeTest</span>
<span class="s2">class </span><span class="s1">_Test_random_ball_approx(_Test_random_ball):</span>

    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">super().setup_method()</span>
        <span class="s1">self.eps = </span><span class="s5">0.1</span>


<span class="s1">@KDTreeTest</span>
<span class="s2">class </span><span class="s1">_Test_random_ball_approx_periodic(_Test_random_ball):</span>

    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">super().setup_method()</span>
        <span class="s1">self.eps = </span><span class="s5">0.1</span>


<span class="s1">@KDTreeTest</span>
<span class="s2">class </span><span class="s1">_Test_random_ball_far(_Test_random_ball):</span>

    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">super().setup_method()</span>
        <span class="s1">self.d = </span><span class="s5">2.</span>

<span class="s1">@KDTreeTest</span>
<span class="s2">class </span><span class="s1">_Test_random_ball_far_periodic(_Test_random_ball_periodic):</span>

    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">super().setup_method()</span>
        <span class="s1">self.d = </span><span class="s5">2.</span>


<span class="s1">@KDTreeTest</span>
<span class="s2">class </span><span class="s1">_Test_random_ball_l1(_Test_random_ball):</span>

    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">super().setup_method()</span>
        <span class="s1">self.p = </span><span class="s5">1</span>


<span class="s1">@KDTreeTest</span>
<span class="s2">class </span><span class="s1">_Test_random_ball_linf(_Test_random_ball):</span>

    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">super().setup_method()</span>
        <span class="s1">self.p = np.inf</span>


<span class="s2">def </span><span class="s1">test_random_ball_vectorized(kdtree_type):</span>
    <span class="s1">n = </span><span class="s5">20</span>
    <span class="s1">m = </span><span class="s5">5</span>
    <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
    <span class="s1">T = kdtree_type(np.random.randn(n</span><span class="s2">, </span><span class="s1">m))</span>

    <span class="s1">r = T.query_ball_point(np.random.randn(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s1">m)</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(r.shape</span><span class="s2">, </span><span class="s1">(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">))</span>
    <span class="s1">assert_(isinstance(r[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">list))</span>


<span class="s2">def </span><span class="s1">test_query_ball_point_multithreading(kdtree_type):</span>
    <span class="s1">np.random.seed(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">n = </span><span class="s5">5000</span>
    <span class="s1">k = </span><span class="s5">2</span>
    <span class="s1">points = np.random.randn(n</span><span class="s2">, </span><span class="s1">k)</span>
    <span class="s1">T = kdtree_type(points)</span>
    <span class="s1">l1 = T.query_ball_point(points</span><span class="s2">, </span><span class="s5">0.003</span><span class="s2">, </span><span class="s1">workers=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">l2 = T.query_ball_point(points</span><span class="s2">, </span><span class="s5">0.003</span><span class="s2">, </span><span class="s1">workers=</span><span class="s5">64</span><span class="s1">)</span>
    <span class="s1">l3 = T.query_ball_point(points</span><span class="s2">, </span><span class="s5">0.003</span><span class="s2">, </span><span class="s1">workers=-</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(n):</span>
        <span class="s2">if </span><span class="s1">l1[i] </span><span class="s2">or </span><span class="s1">l2[i]:</span>
            <span class="s1">assert_array_equal(l1[i]</span><span class="s2">, </span><span class="s1">l2[i])</span>

    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(n):</span>
        <span class="s2">if </span><span class="s1">l1[i] </span><span class="s2">or </span><span class="s1">l3[i]:</span>
            <span class="s1">assert_array_equal(l1[i]</span><span class="s2">, </span><span class="s1">l3[i])</span>


<span class="s2">class </span><span class="s1">two_trees_consistency:</span>

    <span class="s2">def </span><span class="s1">distance(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s2">return </span><span class="s1">minkowski_distance(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">p)</span>

    <span class="s2">def </span><span class="s1">test_all_in_ball(self):</span>
        <span class="s1">r = self.T1.query_ball_tree(self.T2</span><span class="s2">, </span><span class="s1">self.d</span><span class="s2">, </span><span class="s1">p=self.p</span><span class="s2">, </span><span class="s1">eps=self.eps)</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">l </span><span class="s2">in </span><span class="s1">enumerate(r):</span>
            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">l:</span>
                <span class="s1">assert_(self.distance(self.data1[i]</span><span class="s2">, </span><span class="s1">self.data2[j]</span><span class="s2">, </span><span class="s1">self.p) &lt;= self.d*(</span><span class="s5">1.</span><span class="s1">+self.eps))</span>

    <span class="s2">def </span><span class="s1">test_found_all(self):</span>
        <span class="s1">r = self.T1.query_ball_tree(self.T2</span><span class="s2">, </span><span class="s1">self.d</span><span class="s2">, </span><span class="s1">p=self.p</span><span class="s2">, </span><span class="s1">eps=self.eps)</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">l </span><span class="s2">in </span><span class="s1">enumerate(r):</span>
            <span class="s1">c = np.ones(self.T2.n</span><span class="s2">, </span><span class="s1">dtype=bool)</span>
            <span class="s1">c[l] = </span><span class="s2">False</span>
            <span class="s1">assert_(np.all(self.distance(self.data2[c]</span><span class="s2">, </span><span class="s1">self.data1[i]</span><span class="s2">, </span><span class="s1">self.p) &gt;= self.d/(</span><span class="s5">1.</span><span class="s1">+self.eps)))</span>


<span class="s1">@KDTreeTest</span>
<span class="s2">class </span><span class="s1">_Test_two_random_trees(two_trees_consistency):</span>

    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">n = </span><span class="s5">50</span>
        <span class="s1">m = </span><span class="s5">4</span>
        <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
        <span class="s1">self.data1 = np.random.randn(n</span><span class="s2">, </span><span class="s1">m)</span>
        <span class="s1">self.T1 = self.kdtree_type(self.data1</span><span class="s2">, </span><span class="s1">leafsize=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">self.data2 = np.random.randn(n</span><span class="s2">, </span><span class="s1">m)</span>
        <span class="s1">self.T2 = self.kdtree_type(self.data2</span><span class="s2">, </span><span class="s1">leafsize=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">self.p = </span><span class="s5">2.</span>
        <span class="s1">self.eps = </span><span class="s5">0</span>
        <span class="s1">self.d = </span><span class="s5">0.2</span>


<span class="s1">@KDTreeTest</span>
<span class="s2">class </span><span class="s1">_Test_two_random_trees_periodic(two_trees_consistency):</span>
    <span class="s2">def </span><span class="s1">distance(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s2">return </span><span class="s1">distance_box(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s5">1.0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">n = </span><span class="s5">50</span>
        <span class="s1">m = </span><span class="s5">4</span>
        <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
        <span class="s1">self.data1 = np.random.uniform(size=(n</span><span class="s2">, </span><span class="s1">m))</span>
        <span class="s1">self.T1 = self.kdtree_type(self.data1</span><span class="s2">, </span><span class="s1">leafsize=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">boxsize=</span><span class="s5">1.0</span><span class="s1">)</span>
        <span class="s1">self.data2 = np.random.uniform(size=(n</span><span class="s2">, </span><span class="s1">m))</span>
        <span class="s1">self.T2 = self.kdtree_type(self.data2</span><span class="s2">, </span><span class="s1">leafsize=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">boxsize=</span><span class="s5">1.0</span><span class="s1">)</span>
        <span class="s1">self.p = </span><span class="s5">2.</span>
        <span class="s1">self.eps = </span><span class="s5">0</span>
        <span class="s1">self.d = </span><span class="s5">0.2</span>


<span class="s1">@KDTreeTest</span>
<span class="s2">class </span><span class="s1">_Test_two_random_trees_far(_Test_two_random_trees):</span>

    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">super().setup_method()</span>
        <span class="s1">self.d = </span><span class="s5">2</span>


<span class="s1">@KDTreeTest</span>
<span class="s2">class </span><span class="s1">_Test_two_random_trees_far_periodic(_Test_two_random_trees_periodic):</span>

    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">super().setup_method()</span>
        <span class="s1">self.d = </span><span class="s5">2</span>


<span class="s1">@KDTreeTest</span>
<span class="s2">class </span><span class="s1">_Test_two_random_trees_linf(_Test_two_random_trees):</span>

    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">super().setup_method()</span>
        <span class="s1">self.p = np.inf</span>


<span class="s1">@KDTreeTest</span>
<span class="s2">class </span><span class="s1">_Test_two_random_trees_linf_periodic(_Test_two_random_trees_periodic):</span>

    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">super().setup_method()</span>
        <span class="s1">self.p = np.inf</span>


<span class="s2">class </span><span class="s1">Test_rectangle:</span>

    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rect = Rectangle([</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_min_inside(self):</span>
        <span class="s1">assert_almost_equal(self.rect.min_distance_point([</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.5</span><span class="s1">])</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_min_one_side(self):</span>
        <span class="s1">assert_almost_equal(self.rect.min_distance_point([</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">1.5</span><span class="s1">])</span><span class="s2">, </span><span class="s5">0.5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_min_two_sides(self):</span>
        <span class="s1">assert_almost_equal(self.rect.min_distance_point([</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s1">])</span><span class="s2">, </span><span class="s1">np.sqrt(</span><span class="s5">2</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_max_inside(self):</span>
        <span class="s1">assert_almost_equal(self.rect.max_distance_point([</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.5</span><span class="s1">])</span><span class="s2">, </span><span class="s5">1</span><span class="s1">/np.sqrt(</span><span class="s5">2</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_max_one_side(self):</span>
        <span class="s1">assert_almost_equal(self.rect.max_distance_point([</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">1.5</span><span class="s1">])</span><span class="s2">, </span><span class="s1">np.hypot(</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">1.5</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_max_two_sides(self):</span>
        <span class="s1">assert_almost_equal(self.rect.max_distance_point([</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s1">])</span><span class="s2">, </span><span class="s5">2</span><span class="s1">*np.sqrt(</span><span class="s5">2</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_split(self):</span>
        <span class="s1">less</span><span class="s2">, </span><span class="s1">greater = self.rect.split(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0.1</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(less.maxes</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(less.mins</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(greater.maxes</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(greater.mins</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">test_distance_l2():</span>
    <span class="s1">assert_almost_equal(minkowski_distance([</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.sqrt(</span><span class="s5">2</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">test_distance_l1():</span>
    <span class="s1">assert_almost_equal(minkowski_distance([</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_distance_linf():</span>
    <span class="s1">assert_almost_equal(minkowski_distance([</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.inf)</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_distance_vectorization():</span>
    <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
    <span class="s1">x = np.random.randn(</span><span class="s5">10</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span>
    <span class="s1">y = np.random.randn(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">7</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span>
    <span class="s1">assert_equal(minkowski_distance(x</span><span class="s2">, </span><span class="s1">y).shape</span><span class="s2">, </span><span class="s1">(</span><span class="s5">10</span><span class="s2">, </span><span class="s5">7</span><span class="s1">))</span>


<span class="s2">class </span><span class="s1">count_neighbors_consistency:</span>
    <span class="s2">def </span><span class="s1">test_one_radius(self):</span>
        <span class="s1">r = </span><span class="s5">0.2</span>
        <span class="s1">assert_equal(self.T1.count_neighbors(self.T2</span><span class="s2">, </span><span class="s1">r)</span><span class="s2">,</span>
                <span class="s1">np.sum([len(l) </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">self.T1.query_ball_tree(self.T2</span><span class="s2">, </span><span class="s1">r)]))</span>

    <span class="s2">def </span><span class="s1">test_large_radius(self):</span>
        <span class="s1">r = </span><span class="s5">1000</span>
        <span class="s1">assert_equal(self.T1.count_neighbors(self.T2</span><span class="s2">, </span><span class="s1">r)</span><span class="s2">,</span>
                <span class="s1">np.sum([len(l) </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">self.T1.query_ball_tree(self.T2</span><span class="s2">, </span><span class="s1">r)]))</span>

    <span class="s2">def </span><span class="s1">test_multiple_radius(self):</span>
        <span class="s1">rs = np.exp(np.linspace(np.log(</span><span class="s5">0.01</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.log(</span><span class="s5">10</span><span class="s1">)</span><span class="s2">, </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s1">results = self.T1.count_neighbors(self.T2</span><span class="s2">, </span><span class="s1">rs)</span>
        <span class="s1">assert_(np.all(np.diff(results) &gt;= </span><span class="s5">0</span><span class="s1">))</span>
        <span class="s2">for </span><span class="s1">r</span><span class="s2">, </span><span class="s1">result </span><span class="s2">in </span><span class="s1">zip(rs</span><span class="s2">, </span><span class="s1">results):</span>
            <span class="s1">assert_equal(self.T1.count_neighbors(self.T2</span><span class="s2">, </span><span class="s1">r)</span><span class="s2">, </span><span class="s1">result)</span>

<span class="s1">@KDTreeTest</span>
<span class="s2">class </span><span class="s1">_Test_count_neighbors(count_neighbors_consistency):</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">n = </span><span class="s5">50</span>
        <span class="s1">m = </span><span class="s5">2</span>
        <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
        <span class="s1">self.T1 = self.kdtree_type(np.random.randn(n</span><span class="s2">, </span><span class="s1">m)</span><span class="s2">, </span><span class="s1">leafsize=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">self.T2 = self.kdtree_type(np.random.randn(n</span><span class="s2">, </span><span class="s1">m)</span><span class="s2">, </span><span class="s1">leafsize=</span><span class="s5">2</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">sparse_distance_matrix_consistency:</span>

    <span class="s2">def </span><span class="s1">distance(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s2">return </span><span class="s1">minkowski_distance(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">p)</span>

    <span class="s2">def </span><span class="s1">test_consistency_with_neighbors(self):</span>
        <span class="s1">M = self.T1.sparse_distance_matrix(self.T2</span><span class="s2">, </span><span class="s1">self.r)</span>
        <span class="s1">r = self.T1.query_ball_tree(self.T2</span><span class="s2">, </span><span class="s1">self.r)</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">l </span><span class="s2">in </span><span class="s1">enumerate(r):</span>
            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">l:</span>
                <span class="s1">assert_almost_equal(M[i</span><span class="s2">, </span><span class="s1">j]</span><span class="s2">,</span>
                                    <span class="s1">self.distance(self.T1.data[i]</span><span class="s2">, </span><span class="s1">self.T2.data[j]</span><span class="s2">, </span><span class="s1">self.p)</span><span class="s2">,</span>
                                    <span class="s1">decimal=</span><span class="s5">14</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">((i</span><span class="s2">, </span><span class="s1">j)</span><span class="s2">, </span><span class="s1">d) </span><span class="s2">in </span><span class="s1">M.items():</span>
            <span class="s1">assert_(j </span><span class="s2">in </span><span class="s1">r[i])</span>

    <span class="s2">def </span><span class="s1">test_zero_distance(self):</span>
        <span class="s0"># raises an exception for bug 870 (FIXME: Does it?)</span>
        <span class="s1">self.T1.sparse_distance_matrix(self.T1</span><span class="s2">, </span><span class="s1">self.r)</span>

    <span class="s2">def </span><span class="s1">test_consistency(self):</span>
        <span class="s0"># Test consistency with a distance_matrix</span>
        <span class="s1">M1 = self.T1.sparse_distance_matrix(self.T2</span><span class="s2">, </span><span class="s1">self.r)</span>
        <span class="s1">expected = distance_matrix(self.T1.data</span><span class="s2">, </span><span class="s1">self.T2.data)</span>
        <span class="s1">expected[expected &gt; self.r] = </span><span class="s5">0</span>
        <span class="s1">assert_array_almost_equal(M1.toarray()</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s5">14</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_against_logic_error_regression(self):</span>
        <span class="s0"># regression test for gh-5077 logic error</span>
        <span class="s1">np.random.seed(</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">too_many = np.array(np.random.randn(</span><span class="s5">18</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=int)</span>
        <span class="s1">tree = self.kdtree_type(</span>
            <span class="s1">too_many</span><span class="s2">, </span><span class="s1">balanced_tree=</span><span class="s2">False, </span><span class="s1">compact_nodes=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">d = tree.sparse_distance_matrix(tree</span><span class="s2">, </span><span class="s5">3</span><span class="s1">).toarray()</span>
        <span class="s1">assert_array_almost_equal(d</span><span class="s2">, </span><span class="s1">d.T</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s5">14</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_ckdtree_return_types(self):</span>
        <span class="s0"># brute-force reference</span>
        <span class="s1">ref = np.zeros((self.n</span><span class="s2">, </span><span class="s1">self.n))</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.n):</span>
            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(self.n):</span>
                <span class="s1">v = self.data1[i</span><span class="s2">, </span><span class="s1">:] - self.data2[j</span><span class="s2">, </span><span class="s1">:]</span>
                <span class="s1">ref[i</span><span class="s2">, </span><span class="s1">j] = np.dot(v</span><span class="s2">, </span><span class="s1">v)</span>
        <span class="s1">ref = np.sqrt(ref)</span>
        <span class="s1">ref[ref &gt; self.r] = </span><span class="s5">0.</span>
        <span class="s0"># test return type 'dict'</span>
        <span class="s1">dist = np.zeros((self.n</span><span class="s2">, </span><span class="s1">self.n))</span>
        <span class="s1">r = self.T1.sparse_distance_matrix(self.T2</span><span class="s2">, </span><span class="s1">self.r</span><span class="s2">, </span><span class="s1">output_type=</span><span class="s4">'dict'</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">j </span><span class="s2">in </span><span class="s1">r.keys():</span>
            <span class="s1">dist[i</span><span class="s2">, </span><span class="s1">j] = r[(i</span><span class="s2">, </span><span class="s1">j)]</span>
        <span class="s1">assert_array_almost_equal(ref</span><span class="s2">, </span><span class="s1">dist</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s5">14</span><span class="s1">)</span>
        <span class="s0"># test return type 'ndarray'</span>
        <span class="s1">dist = np.zeros((self.n</span><span class="s2">, </span><span class="s1">self.n))</span>
        <span class="s1">r = self.T1.sparse_distance_matrix(self.T2</span><span class="s2">, </span><span class="s1">self.r</span><span class="s2">,</span>
            <span class="s1">output_type=</span><span class="s4">'ndarray'</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range(r.shape[</span><span class="s5">0</span><span class="s1">]):</span>
            <span class="s1">i = r[</span><span class="s4">'i'</span><span class="s1">][k]</span>
            <span class="s1">j = r[</span><span class="s4">'j'</span><span class="s1">][k]</span>
            <span class="s1">v = r[</span><span class="s4">'v'</span><span class="s1">][k]</span>
            <span class="s1">dist[i</span><span class="s2">, </span><span class="s1">j] = v</span>
        <span class="s1">assert_array_almost_equal(ref</span><span class="s2">, </span><span class="s1">dist</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s5">14</span><span class="s1">)</span>
        <span class="s0"># test return type 'dok_matrix'</span>
        <span class="s1">r = self.T1.sparse_distance_matrix(self.T2</span><span class="s2">, </span><span class="s1">self.r</span><span class="s2">,</span>
            <span class="s1">output_type=</span><span class="s4">'dok_matrix'</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(ref</span><span class="s2">, </span><span class="s1">r.toarray()</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s5">14</span><span class="s1">)</span>
        <span class="s0"># test return type 'coo_matrix'</span>
        <span class="s1">r = self.T1.sparse_distance_matrix(self.T2</span><span class="s2">, </span><span class="s1">self.r</span><span class="s2">,</span>
            <span class="s1">output_type=</span><span class="s4">'coo_matrix'</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(ref</span><span class="s2">, </span><span class="s1">r.toarray()</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s5">14</span><span class="s1">)</span>


<span class="s1">@KDTreeTest</span>
<span class="s2">class </span><span class="s1">_Test_sparse_distance_matrix(sparse_distance_matrix_consistency):</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">n = </span><span class="s5">50</span>
        <span class="s1">m = </span><span class="s5">4</span>
        <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
        <span class="s1">data1 = np.random.randn(n</span><span class="s2">, </span><span class="s1">m)</span>
        <span class="s1">data2 = np.random.randn(n</span><span class="s2">, </span><span class="s1">m)</span>
        <span class="s1">self.T1 = self.kdtree_type(data1</span><span class="s2">, </span><span class="s1">leafsize=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">self.T2 = self.kdtree_type(data2</span><span class="s2">, </span><span class="s1">leafsize=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">self.r = </span><span class="s5">0.5</span>
        <span class="s1">self.p = </span><span class="s5">2</span>
        <span class="s1">self.data1 = data1</span>
        <span class="s1">self.data2 = data2</span>
        <span class="s1">self.n = n</span>
        <span class="s1">self.m = m</span>


<span class="s2">def </span><span class="s1">test_distance_matrix():</span>
    <span class="s1">m = </span><span class="s5">10</span>
    <span class="s1">n = </span><span class="s5">11</span>
    <span class="s1">k = </span><span class="s5">4</span>
    <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
    <span class="s1">xs = np.random.randn(m</span><span class="s2">, </span><span class="s1">k)</span>
    <span class="s1">ys = np.random.randn(n</span><span class="s2">, </span><span class="s1">k)</span>
    <span class="s1">ds = distance_matrix(xs</span><span class="s2">, </span><span class="s1">ys)</span>
    <span class="s1">assert_equal(ds.shape</span><span class="s2">, </span><span class="s1">(m</span><span class="s2">, </span><span class="s1">n))</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(m):</span>
        <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(n):</span>
            <span class="s1">assert_almost_equal(minkowski_distance(xs[i]</span><span class="s2">, </span><span class="s1">ys[j])</span><span class="s2">, </span><span class="s1">ds[i</span><span class="s2">, </span><span class="s1">j])</span>


<span class="s2">def </span><span class="s1">test_distance_matrix_looping():</span>
    <span class="s1">m = </span><span class="s5">10</span>
    <span class="s1">n = </span><span class="s5">11</span>
    <span class="s1">k = </span><span class="s5">4</span>
    <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
    <span class="s1">xs = np.random.randn(m</span><span class="s2">, </span><span class="s1">k)</span>
    <span class="s1">ys = np.random.randn(n</span><span class="s2">, </span><span class="s1">k)</span>
    <span class="s1">ds = distance_matrix(xs</span><span class="s2">, </span><span class="s1">ys)</span>
    <span class="s1">dsl = distance_matrix(xs</span><span class="s2">, </span><span class="s1">ys</span><span class="s2">, </span><span class="s1">threshold=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(ds</span><span class="s2">, </span><span class="s1">dsl)</span>


<span class="s2">def </span><span class="s1">check_onetree_query(T</span><span class="s2">, </span><span class="s1">d):</span>
    <span class="s1">r = T.query_ball_tree(T</span><span class="s2">, </span><span class="s1">d)</span>
    <span class="s1">s = set()</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">l </span><span class="s2">in </span><span class="s1">enumerate(r):</span>
        <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">l:</span>
            <span class="s2">if </span><span class="s1">i &lt; j:</span>
                <span class="s1">s.add((i</span><span class="s2">, </span><span class="s1">j))</span>

    <span class="s1">assert_(s == T.query_pairs(d))</span>

<span class="s2">def </span><span class="s1">test_onetree_query(kdtree_type):</span>
    <span class="s1">np.random.seed(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">n = </span><span class="s5">50</span>
    <span class="s1">k = </span><span class="s5">4</span>
    <span class="s1">points = np.random.randn(n</span><span class="s2">, </span><span class="s1">k)</span>
    <span class="s1">T = kdtree_type(points)</span>
    <span class="s1">check_onetree_query(T</span><span class="s2">, </span><span class="s5">0.1</span><span class="s1">)</span>

    <span class="s1">points = np.random.randn(</span><span class="s5">3</span><span class="s1">*n</span><span class="s2">, </span><span class="s1">k)</span>
    <span class="s1">points[:n] *= </span><span class="s5">0.001</span>
    <span class="s1">points[n:</span><span class="s5">2</span><span class="s1">*n] += </span><span class="s5">2</span>
    <span class="s1">T = kdtree_type(points)</span>
    <span class="s1">check_onetree_query(T</span><span class="s2">, </span><span class="s5">0.1</span><span class="s1">)</span>
    <span class="s1">check_onetree_query(T</span><span class="s2">, </span><span class="s5">0.001</span><span class="s1">)</span>
    <span class="s1">check_onetree_query(T</span><span class="s2">, </span><span class="s5">0.00001</span><span class="s1">)</span>
    <span class="s1">check_onetree_query(T</span><span class="s2">, </span><span class="s5">1e-6</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_query_pairs_single_node(kdtree_type):</span>
    <span class="s1">tree = kdtree_type([[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]])</span>
    <span class="s1">assert_equal(tree.query_pairs(</span><span class="s5">0.5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">set())</span>


<span class="s2">def </span><span class="s1">test_kdtree_query_pairs(kdtree_type):</span>
    <span class="s1">np.random.seed(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">n = </span><span class="s5">50</span>
    <span class="s1">k = </span><span class="s5">2</span>
    <span class="s1">r = </span><span class="s5">0.1</span>
    <span class="s1">r2 = r**</span><span class="s5">2</span>
    <span class="s1">points = np.random.randn(n</span><span class="s2">, </span><span class="s1">k)</span>
    <span class="s1">T = kdtree_type(points)</span>
    <span class="s0"># brute force reference</span>
    <span class="s1">brute = set()</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(n):</span>
        <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(i+</span><span class="s5">1</span><span class="s2">, </span><span class="s1">n):</span>
            <span class="s1">v = points[i</span><span class="s2">, </span><span class="s1">:] - points[j</span><span class="s2">, </span><span class="s1">:]</span>
            <span class="s2">if </span><span class="s1">np.dot(v</span><span class="s2">, </span><span class="s1">v) &lt;= r2:</span>
                <span class="s1">brute.add((i</span><span class="s2">, </span><span class="s1">j))</span>
    <span class="s1">l0 = sorted(brute)</span>
    <span class="s0"># test default return type</span>
    <span class="s1">s = T.query_pairs(r)</span>
    <span class="s1">l1 = sorted(s)</span>
    <span class="s1">assert_array_equal(l0</span><span class="s2">, </span><span class="s1">l1)</span>
    <span class="s0"># test return type 'set'</span>
    <span class="s1">s = T.query_pairs(r</span><span class="s2">, </span><span class="s1">output_type=</span><span class="s4">'set'</span><span class="s1">)</span>
    <span class="s1">l1 = sorted(s)</span>
    <span class="s1">assert_array_equal(l0</span><span class="s2">, </span><span class="s1">l1)</span>
    <span class="s0"># test return type 'ndarray'</span>
    <span class="s1">s = set()</span>
    <span class="s1">arr = T.query_pairs(r</span><span class="s2">, </span><span class="s1">output_type=</span><span class="s4">'ndarray'</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(arr.shape[</span><span class="s5">0</span><span class="s1">]):</span>
        <span class="s1">s.add((int(arr[i</span><span class="s2">, </span><span class="s5">0</span><span class="s1">])</span><span class="s2">, </span><span class="s1">int(arr[i</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])))</span>
    <span class="s1">l2 = sorted(s)</span>
    <span class="s1">assert_array_equal(l0</span><span class="s2">, </span><span class="s1">l2)</span>


<span class="s2">def </span><span class="s1">test_query_pairs_eps(kdtree_type):</span>
    <span class="s1">spacing = np.sqrt(</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s0"># irrational spacing to have potential rounding errors</span>
    <span class="s1">x_range = np.linspace(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">3 </span><span class="s1">* spacing</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
    <span class="s1">y_range = np.linspace(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">3 </span><span class="s1">* spacing</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
    <span class="s1">xy_array = [(xi</span><span class="s2">, </span><span class="s1">yi) </span><span class="s2">for </span><span class="s1">xi </span><span class="s2">in </span><span class="s1">x_range </span><span class="s2">for </span><span class="s1">yi </span><span class="s2">in </span><span class="s1">y_range]</span>
    <span class="s1">tree = kdtree_type(xy_array)</span>
    <span class="s1">pairs_eps = tree.query_pairs(r=spacing</span><span class="s2">, </span><span class="s1">eps=</span><span class="s5">.1</span><span class="s1">)</span>
    <span class="s0"># result: 24 with eps, 16 without due to rounding</span>
    <span class="s1">pairs = tree.query_pairs(r=spacing * </span><span class="s5">1.01</span><span class="s1">)</span>
    <span class="s0"># result: 24</span>
    <span class="s1">assert_equal(pairs</span><span class="s2">, </span><span class="s1">pairs_eps)</span>


<span class="s2">def </span><span class="s1">test_ball_point_ints(kdtree_type):</span>
    <span class="s0"># Regression test for #1373.</span>
    <span class="s1">x</span><span class="s2">, </span><span class="s1">y = np.mgrid[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">4</span><span class="s2">, </span><span class="s5">0</span><span class="s1">:</span><span class="s5">4</span><span class="s1">]</span>
    <span class="s1">points = list(zip(x.ravel()</span><span class="s2">, </span><span class="s1">y.ravel()))</span>
    <span class="s1">tree = kdtree_type(points)</span>
    <span class="s1">assert_equal(sorted([</span><span class="s5">4</span><span class="s2">, </span><span class="s5">8</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">12</span><span class="s1">])</span><span class="s2">,</span>
                 <span class="s1">sorted(tree.query_ball_point((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)))</span>
    <span class="s1">points = np.asarray(points</span><span class="s2">, </span><span class="s1">dtype=float)</span>
    <span class="s1">tree = kdtree_type(points)</span>
    <span class="s1">assert_equal(sorted([</span><span class="s5">4</span><span class="s2">, </span><span class="s5">8</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">12</span><span class="s1">])</span><span class="s2">,</span>
                 <span class="s1">sorted(tree.query_ball_point((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)))</span>


<span class="s2">def </span><span class="s1">test_kdtree_comparisons():</span>
    <span class="s0"># Regression test: node comparisons were done wrong in 0.12 w/Py3.</span>
    <span class="s1">nodes = [KDTree.node() </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">3</span><span class="s1">)]</span>
    <span class="s1">assert_equal(sorted(nodes)</span><span class="s2">, </span><span class="s1">sorted(nodes[::-</span><span class="s5">1</span><span class="s1">]))</span>


<span class="s2">def </span><span class="s1">test_kdtree_build_modes(kdtree_type):</span>
    <span class="s0"># check if different build modes for KDTree give similar query results</span>
    <span class="s1">np.random.seed(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">n = </span><span class="s5">5000</span>
    <span class="s1">k = </span><span class="s5">4</span>
    <span class="s1">points = np.random.randn(n</span><span class="s2">, </span><span class="s1">k)</span>
    <span class="s1">T1 = kdtree_type(points).query(points</span><span class="s2">, </span><span class="s1">k=</span><span class="s5">5</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">T2 = kdtree_type(points</span><span class="s2">, </span><span class="s1">compact_nodes=</span><span class="s2">False</span><span class="s1">).query(points</span><span class="s2">, </span><span class="s1">k=</span><span class="s5">5</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">T3 = kdtree_type(points</span><span class="s2">, </span><span class="s1">balanced_tree=</span><span class="s2">False</span><span class="s1">).query(points</span><span class="s2">, </span><span class="s1">k=</span><span class="s5">5</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">T4 = kdtree_type(points</span><span class="s2">, </span><span class="s1">compact_nodes=</span><span class="s2">False,</span>
                     <span class="s1">balanced_tree=</span><span class="s2">False</span><span class="s1">).query(points</span><span class="s2">, </span><span class="s1">k=</span><span class="s5">5</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">assert_array_equal(T1</span><span class="s2">, </span><span class="s1">T2)</span>
    <span class="s1">assert_array_equal(T1</span><span class="s2">, </span><span class="s1">T3)</span>
    <span class="s1">assert_array_equal(T1</span><span class="s2">, </span><span class="s1">T4)</span>

<span class="s2">def </span><span class="s1">test_kdtree_pickle(kdtree_type):</span>
    <span class="s0"># test if it is possible to pickle a KDTree</span>
    <span class="s2">import </span><span class="s1">pickle</span>
    <span class="s1">np.random.seed(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">n = </span><span class="s5">50</span>
    <span class="s1">k = </span><span class="s5">4</span>
    <span class="s1">points = np.random.randn(n</span><span class="s2">, </span><span class="s1">k)</span>
    <span class="s1">T1 = kdtree_type(points)</span>
    <span class="s1">tmp = pickle.dumps(T1)</span>
    <span class="s1">T2 = pickle.loads(tmp)</span>
    <span class="s1">T1 = T1.query(points</span><span class="s2">, </span><span class="s1">k=</span><span class="s5">5</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">T2 = T2.query(points</span><span class="s2">, </span><span class="s1">k=</span><span class="s5">5</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">assert_array_equal(T1</span><span class="s2">, </span><span class="s1">T2)</span>

<span class="s2">def </span><span class="s1">test_kdtree_pickle_boxsize(kdtree_type):</span>
    <span class="s0"># test if it is possible to pickle a periodic KDTree</span>
    <span class="s2">import </span><span class="s1">pickle</span>
    <span class="s1">np.random.seed(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">n = </span><span class="s5">50</span>
    <span class="s1">k = </span><span class="s5">4</span>
    <span class="s1">points = np.random.uniform(size=(n</span><span class="s2">, </span><span class="s1">k))</span>
    <span class="s1">T1 = kdtree_type(points</span><span class="s2">, </span><span class="s1">boxsize=</span><span class="s5">1.0</span><span class="s1">)</span>
    <span class="s1">tmp = pickle.dumps(T1)</span>
    <span class="s1">T2 = pickle.loads(tmp)</span>
    <span class="s1">T1 = T1.query(points</span><span class="s2">, </span><span class="s1">k=</span><span class="s5">5</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">T2 = T2.query(points</span><span class="s2">, </span><span class="s1">k=</span><span class="s5">5</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">assert_array_equal(T1</span><span class="s2">, </span><span class="s1">T2)</span>

<span class="s2">def </span><span class="s1">test_kdtree_copy_data(kdtree_type):</span>
    <span class="s0"># check if copy_data=True makes the kd-tree</span>
    <span class="s0"># impervious to data corruption by modification of</span>
    <span class="s0"># the data arrray</span>
    <span class="s1">np.random.seed(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">n = </span><span class="s5">5000</span>
    <span class="s1">k = </span><span class="s5">4</span>
    <span class="s1">points = np.random.randn(n</span><span class="s2">, </span><span class="s1">k)</span>
    <span class="s1">T = kdtree_type(points</span><span class="s2">, </span><span class="s1">copy_data=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">q = points.copy()</span>
    <span class="s1">T1 = T.query(q</span><span class="s2">, </span><span class="s1">k=</span><span class="s5">5</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">points[...] = np.random.randn(n</span><span class="s2">, </span><span class="s1">k)</span>
    <span class="s1">T2 = T.query(q</span><span class="s2">, </span><span class="s1">k=</span><span class="s5">5</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">assert_array_equal(T1</span><span class="s2">, </span><span class="s1">T2)</span>

<span class="s2">def </span><span class="s1">test_ckdtree_parallel(kdtree_type</span><span class="s2">, </span><span class="s1">monkeypatch):</span>
    <span class="s0"># check if parallel=True also generates correct query results</span>
    <span class="s1">np.random.seed(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">n = </span><span class="s5">5000</span>
    <span class="s1">k = </span><span class="s5">4</span>
    <span class="s1">points = np.random.randn(n</span><span class="s2">, </span><span class="s1">k)</span>
    <span class="s1">T = kdtree_type(points)</span>
    <span class="s1">T1 = T.query(points</span><span class="s2">, </span><span class="s1">k=</span><span class="s5">5</span><span class="s2">, </span><span class="s1">workers=</span><span class="s5">64</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">T2 = T.query(points</span><span class="s2">, </span><span class="s1">k=</span><span class="s5">5</span><span class="s2">, </span><span class="s1">workers=-</span><span class="s5">1</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">T3 = T.query(points</span><span class="s2">, </span><span class="s1">k=</span><span class="s5">5</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">assert_array_equal(T1</span><span class="s2">, </span><span class="s1">T2)</span>
    <span class="s1">assert_array_equal(T1</span><span class="s2">, </span><span class="s1">T3)</span>

    <span class="s1">monkeypatch.setattr(os</span><span class="s2">, </span><span class="s4">'cpu_count'</span><span class="s2">, lambda</span><span class="s1">: </span><span class="s2">None</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;Cannot determine the&quot;</span><span class="s1">):</span>
        <span class="s1">T.query(points</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">workers=-</span><span class="s5">1</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_ckdtree_view():</span>
    <span class="s0"># Check that the nodes can be correctly viewed from Python.</span>
    <span class="s0"># This test also sanity checks each node in the cKDTree, and</span>
    <span class="s0"># thus verifies the internal structure of the kd-tree.</span>
    <span class="s1">np.random.seed(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">n = </span><span class="s5">100</span>
    <span class="s1">k = </span><span class="s5">4</span>
    <span class="s1">points = np.random.randn(n</span><span class="s2">, </span><span class="s1">k)</span>
    <span class="s1">kdtree = cKDTree(points)</span>

    <span class="s0"># walk the whole kd-tree and sanity check each node</span>
    <span class="s2">def </span><span class="s1">recurse_tree(n):</span>
        <span class="s1">assert_(isinstance(n</span><span class="s2">, </span><span class="s1">cKDTreeNode))</span>
        <span class="s2">if </span><span class="s1">n.split_dim == -</span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">assert_(n.lesser </span><span class="s2">is None</span><span class="s1">)</span>
            <span class="s1">assert_(n.greater </span><span class="s2">is None</span><span class="s1">)</span>
            <span class="s1">assert_(n.indices.shape[</span><span class="s5">0</span><span class="s1">] &lt;= kdtree.leafsize)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">recurse_tree(n.lesser)</span>
            <span class="s1">recurse_tree(n.greater)</span>
            <span class="s1">x = n.lesser.data_points[:</span><span class="s2">, </span><span class="s1">n.split_dim]</span>
            <span class="s1">y = n.greater.data_points[:</span><span class="s2">, </span><span class="s1">n.split_dim]</span>
            <span class="s1">assert_(x.max() &lt; y.min())</span>

    <span class="s1">recurse_tree(kdtree.tree)</span>
    <span class="s0"># check that indices are correctly retrieved</span>
    <span class="s1">n = kdtree.tree</span>
    <span class="s1">assert_array_equal(np.sort(n.indices)</span><span class="s2">, </span><span class="s1">range(</span><span class="s5">100</span><span class="s1">))</span>
    <span class="s0"># check that data_points are correctly retrieved</span>
    <span class="s1">assert_array_equal(kdtree.data[n.indices</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">n.data_points)</span>

<span class="s0"># KDTree is specialized to type double points, so no need to make</span>
<span class="s0"># a unit test corresponding to test_ball_point_ints()</span>

<span class="s2">def </span><span class="s1">test_kdtree_list_k(kdtree_type):</span>
    <span class="s0"># check kdtree periodic boundary</span>
    <span class="s1">n = </span><span class="s5">200</span>
    <span class="s1">m = </span><span class="s5">2</span>
    <span class="s1">klist = [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]</span>
    <span class="s1">kint = </span><span class="s5">3</span>

    <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
    <span class="s1">data = np.random.uniform(size=(n</span><span class="s2">, </span><span class="s1">m))</span>
    <span class="s1">kdtree = kdtree_type(data</span><span class="s2">, </span><span class="s1">leafsize=</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s0"># check agreement between arange(1, k+1) and k</span>
    <span class="s1">dd</span><span class="s2">, </span><span class="s1">ii = kdtree.query(data</span><span class="s2">, </span><span class="s1">klist)</span>
    <span class="s1">dd1</span><span class="s2">, </span><span class="s1">ii1 = kdtree.query(data</span><span class="s2">, </span><span class="s1">kint)</span>
    <span class="s1">assert_equal(dd</span><span class="s2">, </span><span class="s1">dd1)</span>
    <span class="s1">assert_equal(ii</span><span class="s2">, </span><span class="s1">ii1)</span>

    <span class="s0"># now check skipping one element</span>
    <span class="s1">klist = np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s1">])</span>
    <span class="s1">kint = </span><span class="s5">3</span>
    <span class="s1">dd</span><span class="s2">, </span><span class="s1">ii = kdtree.query(data</span><span class="s2">, </span><span class="s1">kint)</span>
    <span class="s1">dd1</span><span class="s2">, </span><span class="s1">ii1 = kdtree.query(data</span><span class="s2">, </span><span class="s1">klist)</span>
    <span class="s1">assert_equal(dd1</span><span class="s2">, </span><span class="s1">dd[...</span><span class="s2">, </span><span class="s1">klist - </span><span class="s5">1</span><span class="s1">])</span>
    <span class="s1">assert_equal(ii1</span><span class="s2">, </span><span class="s1">ii[...</span><span class="s2">, </span><span class="s1">klist - </span><span class="s5">1</span><span class="s1">])</span>

    <span class="s0"># check k == 1 special case</span>
    <span class="s0"># and k == [1] non-special case</span>
    <span class="s1">dd</span><span class="s2">, </span><span class="s1">ii = kdtree.query(data</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">dd1</span><span class="s2">, </span><span class="s1">ii1 = kdtree.query(data</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s1">assert_equal(len(dd.shape)</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(len(dd1.shape)</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">assert_equal(dd</span><span class="s2">, </span><span class="s1">np.ravel(dd1))</span>
    <span class="s1">assert_equal(ii</span><span class="s2">, </span><span class="s1">np.ravel(ii1))</span>

<span class="s2">def </span><span class="s1">test_kdtree_box(kdtree_type):</span>
    <span class="s0"># check ckdtree periodic boundary</span>
    <span class="s1">n = </span><span class="s5">2000</span>
    <span class="s1">m = </span><span class="s5">3</span>
    <span class="s1">k = </span><span class="s5">3</span>
    <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
    <span class="s1">data = np.random.uniform(size=(n</span><span class="s2">, </span><span class="s1">m))</span>
    <span class="s1">kdtree = kdtree_type(data</span><span class="s2">, </span><span class="s1">leafsize=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">boxsize=</span><span class="s5">1.0</span><span class="s1">)</span>

    <span class="s0"># use the standard python KDTree for the simulated periodic box</span>
    <span class="s1">kdtree2 = kdtree_type(data</span><span class="s2">, </span><span class="s1">leafsize=</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3.0</span><span class="s2">, </span><span class="s1">np.inf]:</span>
        <span class="s1">dd</span><span class="s2">, </span><span class="s1">ii = kdtree.query(data</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">p=p)</span>

        <span class="s1">dd1</span><span class="s2">, </span><span class="s1">ii1 = kdtree.query(data + </span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">p=p)</span>
        <span class="s1">assert_almost_equal(dd</span><span class="s2">, </span><span class="s1">dd1)</span>
        <span class="s1">assert_equal(ii</span><span class="s2">, </span><span class="s1">ii1)</span>

        <span class="s1">dd1</span><span class="s2">, </span><span class="s1">ii1 = kdtree.query(data - </span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">p=p)</span>
        <span class="s1">assert_almost_equal(dd</span><span class="s2">, </span><span class="s1">dd1)</span>
        <span class="s1">assert_equal(ii</span><span class="s2">, </span><span class="s1">ii1)</span>

        <span class="s1">dd2</span><span class="s2">, </span><span class="s1">ii2 = simulate_periodic_box(kdtree2</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">boxsize=</span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">p=p)</span>
        <span class="s1">assert_almost_equal(dd</span><span class="s2">, </span><span class="s1">dd2)</span>
        <span class="s1">assert_equal(ii</span><span class="s2">, </span><span class="s1">ii2)</span>

<span class="s2">def </span><span class="s1">test_kdtree_box_0boxsize(kdtree_type):</span>
    <span class="s0"># check ckdtree periodic boundary that mimics non-periodic</span>
    <span class="s1">n = </span><span class="s5">2000</span>
    <span class="s1">m = </span><span class="s5">2</span>
    <span class="s1">k = </span><span class="s5">3</span>
    <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
    <span class="s1">data = np.random.uniform(size=(n</span><span class="s2">, </span><span class="s1">m))</span>
    <span class="s1">kdtree = kdtree_type(data</span><span class="s2">, </span><span class="s1">leafsize=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">boxsize=</span><span class="s5">0.0</span><span class="s1">)</span>

    <span class="s0"># use the standard python KDTree for the simulated periodic box</span>
    <span class="s1">kdtree2 = kdtree_type(data</span><span class="s2">, </span><span class="s1">leafsize=</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">np.inf]:</span>
        <span class="s1">dd</span><span class="s2">, </span><span class="s1">ii = kdtree.query(data</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">p=p)</span>

        <span class="s1">dd1</span><span class="s2">, </span><span class="s1">ii1 = kdtree2.query(data</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">p=p)</span>
        <span class="s1">assert_almost_equal(dd</span><span class="s2">, </span><span class="s1">dd1)</span>
        <span class="s1">assert_equal(ii</span><span class="s2">, </span><span class="s1">ii1)</span>

<span class="s2">def </span><span class="s1">test_kdtree_box_upper_bounds(kdtree_type):</span>
    <span class="s1">data = np.linspace(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">10</span><span class="s1">).reshape(-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">data[:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">] += </span><span class="s5">10</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">kdtree_type(data</span><span class="s2">, </span><span class="s1">leafsize=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">boxsize=</span><span class="s5">1.0</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">kdtree_type(data</span><span class="s2">, </span><span class="s1">leafsize=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">boxsize=(</span><span class="s5">0.0</span><span class="s2">, </span><span class="s5">2.0</span><span class="s1">))</span>
    <span class="s0"># skip a dimension.</span>
    <span class="s1">kdtree_type(data</span><span class="s2">, </span><span class="s1">leafsize=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">boxsize=(</span><span class="s5">2.0</span><span class="s2">, </span><span class="s5">0.0</span><span class="s1">))</span>

<span class="s2">def </span><span class="s1">test_kdtree_box_lower_bounds(kdtree_type):</span>
    <span class="s1">data = np.linspace(-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">10</span><span class="s1">)</span>
    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">kdtree_type</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">leafsize=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">boxsize=</span><span class="s5">1.0</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">simulate_periodic_box(kdtree</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">boxsize</span><span class="s2">, </span><span class="s1">p):</span>
    <span class="s1">dd = []</span>
    <span class="s1">ii = []</span>
    <span class="s1">x = np.arange(</span><span class="s5">3 </span><span class="s1">** data.shape[</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s1">nn = np.array(np.unravel_index(x</span><span class="s2">, </span><span class="s1">[</span><span class="s5">3</span><span class="s1">] * data.shape[</span><span class="s5">1</span><span class="s1">])).T</span>
    <span class="s1">nn = nn - </span><span class="s5">1.0</span>
    <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">nn:</span>
        <span class="s1">image = data + n * </span><span class="s5">1.0 </span><span class="s1">* boxsize</span>
        <span class="s1">dd2</span><span class="s2">, </span><span class="s1">ii2 = kdtree.query(image</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">p=p)</span>
        <span class="s1">dd2 = dd2.reshape(-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">k)</span>
        <span class="s1">ii2 = ii2.reshape(-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">k)</span>
        <span class="s1">dd.append(dd2)</span>
        <span class="s1">ii.append(ii2)</span>
    <span class="s1">dd = np.concatenate(dd</span><span class="s2">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">ii = np.concatenate(ii</span><span class="s2">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s1">result = np.empty([len(data)</span><span class="s2">, </span><span class="s1">len(nn) * k]</span><span class="s2">, </span><span class="s1">dtype=[</span>
            <span class="s1">(</span><span class="s4">'ii'</span><span class="s2">, </span><span class="s4">'i8'</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s4">'dd'</span><span class="s2">, </span><span class="s4">'f8'</span><span class="s1">)])</span>
    <span class="s1">result[</span><span class="s4">'ii'</span><span class="s1">][:] = ii</span>
    <span class="s1">result[</span><span class="s4">'dd'</span><span class="s1">][:] = dd</span>
    <span class="s1">result.sort(order=</span><span class="s4">'dd'</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">result[</span><span class="s4">'dd'</span><span class="s1">][:</span><span class="s2">, </span><span class="s1">:k]</span><span class="s2">, </span><span class="s1">result[</span><span class="s4">'ii'</span><span class="s1">][:</span><span class="s2">, </span><span class="s1">:k]</span>


<span class="s1">@pytest.mark.skipif(python_implementation() == </span><span class="s4">'PyPy'</span><span class="s2">,</span>
                    <span class="s1">reason=</span><span class="s4">&quot;Fails on PyPy CI runs. See #9507&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_ckdtree_memuse():</span>
    <span class="s0"># unit test adaptation of gh-5630</span>

    <span class="s0"># NOTE: this will fail when run via valgrind,</span>
    <span class="s0"># because rss is no longer a reliable memory usage indicator.</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">import </span><span class="s1">resource</span>
    <span class="s2">except </span><span class="s1">ImportError:</span>
        <span class="s0"># resource is not available on Windows</span>
        <span class="s2">return</span>
    <span class="s0"># Make some data</span>
    <span class="s1">dx</span><span class="s2">, </span><span class="s1">dy = </span><span class="s5">0.05</span><span class="s2">, </span><span class="s5">0.05</span>
    <span class="s1">y</span><span class="s2">, </span><span class="s1">x = np.mgrid[slice(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">5 </span><span class="s1">+ dy</span><span class="s2">, </span><span class="s1">dy)</span><span class="s2">,</span>
                    <span class="s1">slice(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">5 </span><span class="s1">+ dx</span><span class="s2">, </span><span class="s1">dx)]</span>
    <span class="s1">z = np.sin(x)**</span><span class="s5">10 </span><span class="s1">+ np.cos(</span><span class="s5">10 </span><span class="s1">+ y*x) * np.cos(x)</span>
    <span class="s1">z_copy = np.empty_like(z)</span>
    <span class="s1">z_copy[:] = z</span>
    <span class="s0"># Place FILLVAL in z_copy at random number of random locations</span>
    <span class="s1">FILLVAL = </span><span class="s5">99.</span>
    <span class="s1">mask = np.random.randint(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">z.size</span><span class="s2">, </span><span class="s1">np.random.randint(</span><span class="s5">50</span><span class="s1">) + </span><span class="s5">5</span><span class="s1">)</span>
    <span class="s1">z_copy.flat[mask] = FILLVAL</span>
    <span class="s1">igood = np.vstack(np.nonzero(x != FILLVAL)).T</span>
    <span class="s1">ibad = np.vstack(np.nonzero(x == FILLVAL)).T</span>
    <span class="s1">mem_use = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss</span>
    <span class="s0"># burn-in</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">10</span><span class="s1">):</span>
        <span class="s1">tree = cKDTree(igood)</span>
    <span class="s0"># count memleaks while constructing and querying cKDTree</span>
    <span class="s1">num_leaks = </span><span class="s5">0</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">100</span><span class="s1">):</span>
        <span class="s1">mem_use = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss</span>
        <span class="s1">tree = cKDTree(igood)</span>
        <span class="s1">dist</span><span class="s2">, </span><span class="s1">iquery = tree.query(ibad</span><span class="s2">, </span><span class="s1">k=</span><span class="s5">4</span><span class="s2">, </span><span class="s1">p=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">new_mem_use = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss</span>
        <span class="s2">if </span><span class="s1">new_mem_use &gt; mem_use:</span>
            <span class="s1">num_leaks += </span><span class="s5">1</span>
    <span class="s0"># ideally zero leaks, but errors might accidentally happen</span>
    <span class="s0"># outside cKDTree</span>
    <span class="s1">assert_(num_leaks &lt; </span><span class="s5">10</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">test_kdtree_weights(kdtree_type):</span>

    <span class="s1">data = np.linspace(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">4</span><span class="s1">).reshape(-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">tree1 = kdtree_type(data</span><span class="s2">, </span><span class="s1">leafsize=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">weights = np.ones(len(data)</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s4">'f4'</span><span class="s1">)</span>

    <span class="s1">nw = tree1._build_weights(weights)</span>
    <span class="s1">assert_array_equal(nw</span><span class="s2">, </span><span class="s1">[</span><span class="s5">4</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span>

    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">tree1._build_weights</span><span class="s2">, </span><span class="s1">weights[:-</span><span class="s5">1</span><span class="s1">])</span>

    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">10</span><span class="s1">):</span>
        <span class="s0"># since weights are uniform, these shall agree:</span>
        <span class="s1">c1 = tree1.count_neighbors(tree1</span><span class="s2">, </span><span class="s1">np.linspace(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s1">i))</span>
        <span class="s1">c2 = tree1.count_neighbors(tree1</span><span class="s2">, </span><span class="s1">np.linspace(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s1">i)</span><span class="s2">,</span>
                <span class="s1">weights=(weights</span><span class="s2">, </span><span class="s1">weights))</span>
        <span class="s1">c3 = tree1.count_neighbors(tree1</span><span class="s2">, </span><span class="s1">np.linspace(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s1">i)</span><span class="s2">,</span>
                <span class="s1">weights=(weights</span><span class="s2">, None</span><span class="s1">))</span>
        <span class="s1">c4 = tree1.count_neighbors(tree1</span><span class="s2">, </span><span class="s1">np.linspace(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s1">i)</span><span class="s2">,</span>
                <span class="s1">weights=(</span><span class="s2">None, </span><span class="s1">weights))</span>
        <span class="s1">tree1.count_neighbors(tree1</span><span class="s2">, </span><span class="s1">np.linspace(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s1">i)</span><span class="s2">,</span>
                <span class="s1">weights=weights)</span>

        <span class="s1">assert_array_equal(c1</span><span class="s2">, </span><span class="s1">c2)</span>
        <span class="s1">assert_array_equal(c1</span><span class="s2">, </span><span class="s1">c3)</span>
        <span class="s1">assert_array_equal(c1</span><span class="s2">, </span><span class="s1">c4)</span>

    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(data)):</span>
        <span class="s0"># this tests removal of one data point by setting weight to 0</span>
        <span class="s1">w1 = weights.copy()</span>
        <span class="s1">w1[i] = </span><span class="s5">0</span>
        <span class="s1">data2 = data[w1 != </span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">tree2 = kdtree_type(data2)</span>

        <span class="s1">c1 = tree1.count_neighbors(tree1</span><span class="s2">, </span><span class="s1">np.linspace(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">100</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">weights=(w1</span><span class="s2">, </span><span class="s1">w1))</span>
        <span class="s0"># &quot;c2 is correct&quot;</span>
        <span class="s1">c2 = tree2.count_neighbors(tree2</span><span class="s2">, </span><span class="s1">np.linspace(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">100</span><span class="s1">))</span>

        <span class="s1">assert_array_equal(c1</span><span class="s2">, </span><span class="s1">c2)</span>

        <span class="s0">#this asserts for two different trees, singular weights</span>
        <span class="s0"># crashes</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">tree1.count_neighbors</span><span class="s2">,</span>
            <span class="s1">tree2</span><span class="s2">, </span><span class="s1">np.linspace(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">weights=w1)</span>

<span class="s2">def </span><span class="s1">test_kdtree_count_neighbous_multiple_r(kdtree_type):</span>
    <span class="s1">n = </span><span class="s5">2000</span>
    <span class="s1">m = </span><span class="s5">2</span>
    <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
    <span class="s1">data = np.random.normal(size=(n</span><span class="s2">, </span><span class="s1">m))</span>
    <span class="s1">kdtree = kdtree_type(data</span><span class="s2">, </span><span class="s1">leafsize=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">r0 = [</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0.01</span><span class="s2">, </span><span class="s5">0.01</span><span class="s2">, </span><span class="s5">0.02</span><span class="s2">, </span><span class="s5">0.05</span><span class="s1">]</span>
    <span class="s1">i0 = np.arange(len(r0))</span>
    <span class="s1">n0 = kdtree.count_neighbors(kdtree</span><span class="s2">, </span><span class="s1">r0)</span>
    <span class="s1">nnc = kdtree.count_neighbors(kdtree</span><span class="s2">, </span><span class="s1">r0</span><span class="s2">, </span><span class="s1">cumulative=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">assert_equal(n0</span><span class="s2">, </span><span class="s1">nnc.cumsum())</span>

    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">r </span><span class="s2">in </span><span class="s1">zip(itertools.permutations(i0)</span><span class="s2">,</span>
                    <span class="s1">itertools.permutations(r0)):</span>
        <span class="s0"># permute n0 by i and it shall agree</span>
        <span class="s1">n = kdtree.count_neighbors(kdtree</span><span class="s2">, </span><span class="s1">r)</span>
        <span class="s1">assert_array_equal(n</span><span class="s2">, </span><span class="s1">n0[list(i)])</span>

<span class="s2">def </span><span class="s1">test_len0_arrays(kdtree_type):</span>
    <span class="s0"># make sure len-0 arrays are handled correctly</span>
    <span class="s0"># in range queries (gh-5639)</span>
    <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
    <span class="s1">X = np.random.rand(</span><span class="s5">10</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">Y = np.random.rand(</span><span class="s5">10</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">tree = kdtree_type(X)</span>
    <span class="s0"># query_ball_point (single)</span>
    <span class="s1">d</span><span class="s2">, </span><span class="s1">i = tree.query([</span><span class="s5">.5</span><span class="s2">, </span><span class="s5">.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">k=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">z = tree.query_ball_point([</span><span class="s5">.5</span><span class="s2">, </span><span class="s5">.5</span><span class="s1">]</span><span class="s2">, </span><span class="s5">0.1</span><span class="s1">*d)</span>
    <span class="s1">assert_array_equal(z</span><span class="s2">, </span><span class="s1">[])</span>
    <span class="s0"># query_ball_point (multiple)</span>
    <span class="s1">d</span><span class="s2">, </span><span class="s1">i = tree.query(Y</span><span class="s2">, </span><span class="s1">k=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">mind = d.min()</span>
    <span class="s1">z = tree.query_ball_point(Y</span><span class="s2">, </span><span class="s5">0.1</span><span class="s1">*mind)</span>
    <span class="s1">y = np.empty(shape=(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=object)</span>
    <span class="s1">y.fill([])</span>
    <span class="s1">assert_array_equal(y</span><span class="s2">, </span><span class="s1">z)</span>
    <span class="s0"># query_ball_tree</span>
    <span class="s1">other = kdtree_type(Y)</span>
    <span class="s1">y = tree.query_ball_tree(other</span><span class="s2">, </span><span class="s5">0.1</span><span class="s1">*mind)</span>
    <span class="s1">assert_array_equal(</span><span class="s5">10</span><span class="s1">*[[]]</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s0"># count_neighbors</span>
    <span class="s1">y = tree.count_neighbors(other</span><span class="s2">, </span><span class="s5">0.1</span><span class="s1">*mind)</span>
    <span class="s1">assert_(y == </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s0"># sparse_distance_matrix</span>
    <span class="s1">y = tree.sparse_distance_matrix(other</span><span class="s2">, </span><span class="s5">0.1</span><span class="s1">*mind</span><span class="s2">, </span><span class="s1">output_type=</span><span class="s4">'dok_matrix'</span><span class="s1">)</span>
    <span class="s1">assert_array_equal(y == np.zeros((</span><span class="s5">10</span><span class="s2">, </span><span class="s5">10</span><span class="s1">))</span><span class="s2">, True</span><span class="s1">)</span>
    <span class="s1">y = tree.sparse_distance_matrix(other</span><span class="s2">, </span><span class="s5">0.1</span><span class="s1">*mind</span><span class="s2">, </span><span class="s1">output_type=</span><span class="s4">'coo_matrix'</span><span class="s1">)</span>
    <span class="s1">assert_array_equal(y == np.zeros((</span><span class="s5">10</span><span class="s2">, </span><span class="s5">10</span><span class="s1">))</span><span class="s2">, True</span><span class="s1">)</span>
    <span class="s1">y = tree.sparse_distance_matrix(other</span><span class="s2">, </span><span class="s5">0.1</span><span class="s1">*mind</span><span class="s2">, </span><span class="s1">output_type=</span><span class="s4">'dict'</span><span class="s1">)</span>
    <span class="s1">assert_equal(y</span><span class="s2">, </span><span class="s1">{})</span>
    <span class="s1">y = tree.sparse_distance_matrix(other</span><span class="s2">, </span><span class="s5">0.1</span><span class="s1">*mind</span><span class="s2">, </span><span class="s1">output_type=</span><span class="s4">'ndarray'</span><span class="s1">)</span>
    <span class="s1">_dtype = [(</span><span class="s4">'i'</span><span class="s2">, </span><span class="s1">np.intp)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'j'</span><span class="s2">, </span><span class="s1">np.intp)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'v'</span><span class="s2">, </span><span class="s1">np.float64)]</span>
    <span class="s1">res_dtype = np.dtype(_dtype</span><span class="s2">, </span><span class="s1">align=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">z = np.empty(shape=(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=res_dtype)</span>
    <span class="s1">assert_array_equal(y</span><span class="s2">, </span><span class="s1">z)</span>
    <span class="s0"># query_pairs</span>
    <span class="s1">d</span><span class="s2">, </span><span class="s1">i = tree.query(X</span><span class="s2">, </span><span class="s1">k=</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">mind = d[:</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">].min()</span>
    <span class="s1">y = tree.query_pairs(</span><span class="s5">0.1</span><span class="s1">*mind</span><span class="s2">, </span><span class="s1">output_type=</span><span class="s4">'set'</span><span class="s1">)</span>
    <span class="s1">assert_equal(y</span><span class="s2">, </span><span class="s1">set())</span>
    <span class="s1">y = tree.query_pairs(</span><span class="s5">0.1</span><span class="s1">*mind</span><span class="s2">, </span><span class="s1">output_type=</span><span class="s4">'ndarray'</span><span class="s1">)</span>
    <span class="s1">z = np.empty(shape=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.intp)</span>
    <span class="s1">assert_array_equal(y</span><span class="s2">, </span><span class="s1">z)</span>

<span class="s2">def </span><span class="s1">test_kdtree_duplicated_inputs(kdtree_type):</span>
    <span class="s0"># check kdtree with duplicated inputs</span>
    <span class="s1">n = </span><span class="s5">1024</span>
    <span class="s2">for </span><span class="s1">m </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">8</span><span class="s1">):</span>
        <span class="s1">data = np.ones((n</span><span class="s2">, </span><span class="s1">m))</span>
        <span class="s1">data[n//</span><span class="s5">2</span><span class="s1">:] = </span><span class="s5">2</span>

        <span class="s2">for </span><span class="s1">balanced</span><span class="s2">, </span><span class="s1">compact </span><span class="s2">in </span><span class="s1">itertools.product((</span><span class="s2">False, True</span><span class="s1">)</span><span class="s2">, </span><span class="s1">repeat=</span><span class="s5">2</span><span class="s1">):</span>
            <span class="s1">kdtree = kdtree_type(data</span><span class="s2">, </span><span class="s1">balanced_tree=balanced</span><span class="s2">,</span>
                                 <span class="s1">compact_nodes=compact</span><span class="s2">, </span><span class="s1">leafsize=</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s2">assert </span><span class="s1">kdtree.size == </span><span class="s5">3</span>

            <span class="s1">tree = (kdtree.tree </span><span class="s2">if </span><span class="s1">kdtree_type </span><span class="s2">is </span><span class="s1">cKDTree </span><span class="s2">else</span>
                    <span class="s1">kdtree.tree._node)</span>

            <span class="s1">assert_equal(</span>
                <span class="s1">np.sort(tree.lesser.indices)</span><span class="s2">,</span>
                <span class="s1">np.arange(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">n // </span><span class="s5">2</span><span class="s1">))</span>
            <span class="s1">assert_equal(</span>
                <span class="s1">np.sort(tree.greater.indices)</span><span class="s2">,</span>
                <span class="s1">np.arange(n // </span><span class="s5">2</span><span class="s2">, </span><span class="s1">n))</span>


<span class="s2">def </span><span class="s1">test_kdtree_noncumulative_nondecreasing(kdtree_type):</span>
    <span class="s0"># check kdtree with duplicated inputs</span>

    <span class="s0"># it shall not divide more than 3 nodes.</span>
    <span class="s0"># root left (1), and right (2)</span>
    <span class="s1">kdtree = kdtree_type([[</span><span class="s5">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">leafsize=</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">kdtree.count_neighbors</span><span class="s2">,</span>
        <span class="s1">kdtree</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">cumulative=</span><span class="s2">False</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">test_short_knn(kdtree_type):</span>

    <span class="s0"># The test case is based on github: #6425 by @SteveDoyle2</span>

    <span class="s1">xyz = np.array([</span>
        <span class="s1">[</span><span class="s5">0.</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s5">0.</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s5">1.01</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s5">0.</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s5">0.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">0.</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s5">0.</span><span class="s2">, </span><span class="s5">1.01</span><span class="s2">, </span><span class="s5">0.</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s5">0.</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">0.</span><span class="s1">]]</span><span class="s2">,</span>
    <span class="s1">dtype=</span><span class="s4">'float64'</span><span class="s1">)</span>

    <span class="s1">ckdt = kdtree_type(xyz)</span>

    <span class="s1">deq</span><span class="s2">, </span><span class="s1">ieq = ckdt.query(xyz</span><span class="s2">, </span><span class="s1">k=</span><span class="s5">4</span><span class="s2">, </span><span class="s1">distance_upper_bound=</span><span class="s5">0.2</span><span class="s1">)</span>

    <span class="s1">assert_array_almost_equal(deq</span><span class="s2">,</span>
            <span class="s1">[[</span><span class="s5">0.</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">np.inf]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">0.</span><span class="s2">, </span><span class="s5">0.01</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">np.inf]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">0.</span><span class="s2">, </span><span class="s5">0.01</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">np.inf]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">0.</span><span class="s2">, </span><span class="s5">0.01</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">np.inf]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">0.</span><span class="s2">, </span><span class="s5">0.01</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">np.inf]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">0.</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">np.inf]])</span>

<span class="s2">def </span><span class="s1">test_query_ball_point_vector_r(kdtree_type):</span>

    <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
    <span class="s1">data = np.random.normal(size=(</span><span class="s5">100</span><span class="s2">, </span><span class="s5">3</span><span class="s1">))</span>
    <span class="s1">query = np.random.normal(size=(</span><span class="s5">100</span><span class="s2">, </span><span class="s5">3</span><span class="s1">))</span>
    <span class="s1">tree = kdtree_type(data)</span>
    <span class="s1">d = np.random.uniform(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0.3</span><span class="s2">, </span><span class="s1">size=len(query))</span>

    <span class="s1">rvector = tree.query_ball_point(query</span><span class="s2">, </span><span class="s1">d)</span>
    <span class="s1">rscalar = [tree.query_ball_point(qi</span><span class="s2">, </span><span class="s1">di) </span><span class="s2">for </span><span class="s1">qi</span><span class="s2">, </span><span class="s1">di </span><span class="s2">in </span><span class="s1">zip(query</span><span class="s2">, </span><span class="s1">d)]</span>
    <span class="s2">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b </span><span class="s2">in </span><span class="s1">zip(rvector</span><span class="s2">, </span><span class="s1">rscalar):</span>
        <span class="s1">assert_array_equal(sorted(a)</span><span class="s2">, </span><span class="s1">sorted(b))</span>

<span class="s2">def </span><span class="s1">test_query_ball_point_length(kdtree_type):</span>

    <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
    <span class="s1">data = np.random.normal(size=(</span><span class="s5">100</span><span class="s2">, </span><span class="s5">3</span><span class="s1">))</span>
    <span class="s1">query = np.random.normal(size=(</span><span class="s5">100</span><span class="s2">, </span><span class="s5">3</span><span class="s1">))</span>
    <span class="s1">tree = kdtree_type(data)</span>
    <span class="s1">d = </span><span class="s5">0.3</span>

    <span class="s1">length = tree.query_ball_point(query</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">return_length=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">length2 = [len(ind) </span><span class="s2">for </span><span class="s1">ind </span><span class="s2">in </span><span class="s1">tree.query_ball_point(query</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">return_length=</span><span class="s2">False</span><span class="s1">)]</span>
    <span class="s1">length3 = [len(tree.query_ball_point(qi</span><span class="s2">, </span><span class="s1">d)) </span><span class="s2">for </span><span class="s1">qi </span><span class="s2">in </span><span class="s1">query]</span>
    <span class="s1">length4 = [tree.query_ball_point(qi</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">return_length=</span><span class="s2">True</span><span class="s1">) </span><span class="s2">for </span><span class="s1">qi </span><span class="s2">in </span><span class="s1">query]</span>
    <span class="s1">assert_array_equal(length</span><span class="s2">, </span><span class="s1">length2)</span>
    <span class="s1">assert_array_equal(length</span><span class="s2">, </span><span class="s1">length3)</span>
    <span class="s1">assert_array_equal(length</span><span class="s2">, </span><span class="s1">length4)</span>

<span class="s2">def </span><span class="s1">test_discontiguous(kdtree_type):</span>

    <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
    <span class="s1">data = np.random.normal(size=(</span><span class="s5">100</span><span class="s2">, </span><span class="s5">3</span><span class="s1">))</span>
    <span class="s1">d_contiguous = np.arange(</span><span class="s5">100</span><span class="s1">) * </span><span class="s5">0.04</span>
    <span class="s1">d_discontiguous = np.ascontiguousarray(</span>
                          <span class="s1">np.arange(</span><span class="s5">100</span><span class="s1">)[::-</span><span class="s5">1</span><span class="s1">] * </span><span class="s5">0.04</span><span class="s1">)[::-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">query_contiguous = np.random.normal(size=(</span><span class="s5">100</span><span class="s2">, </span><span class="s5">3</span><span class="s1">))</span>
    <span class="s1">query_discontiguous = np.ascontiguousarray(query_contiguous.T).T</span>
    <span class="s2">assert </span><span class="s1">query_discontiguous.strides[-</span><span class="s5">1</span><span class="s1">] != query_contiguous.strides[-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s2">assert </span><span class="s1">d_discontiguous.strides[-</span><span class="s5">1</span><span class="s1">] != d_contiguous.strides[-</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s1">tree = kdtree_type(data)</span>

    <span class="s1">length1 = tree.query_ball_point(query_contiguous</span><span class="s2">,</span>
                                    <span class="s1">d_contiguous</span><span class="s2">, </span><span class="s1">return_length=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">length2 = tree.query_ball_point(query_discontiguous</span><span class="s2">,</span>
                                    <span class="s1">d_discontiguous</span><span class="s2">, </span><span class="s1">return_length=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s1">assert_array_equal(length1</span><span class="s2">, </span><span class="s1">length2)</span>

    <span class="s1">d1</span><span class="s2">, </span><span class="s1">i1 = tree.query(query_contiguous</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">d2</span><span class="s2">, </span><span class="s1">i2 = tree.query(query_discontiguous</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s1">assert_array_equal(d1</span><span class="s2">, </span><span class="s1">d2)</span>
    <span class="s1">assert_array_equal(i1</span><span class="s2">, </span><span class="s1">i2)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;balanced_tree, compact_nodes&quot;</span><span class="s2">,</span>
    <span class="s1">[(</span><span class="s2">True, False</span><span class="s1">)</span><span class="s2">,</span>
     <span class="s1">(</span><span class="s2">True, True</span><span class="s1">)</span><span class="s2">,</span>
     <span class="s1">(</span><span class="s2">False, False</span><span class="s1">)</span><span class="s2">,</span>
     <span class="s1">(</span><span class="s2">False, True</span><span class="s1">)])</span>
<span class="s2">def </span><span class="s1">test_kdtree_empty_input(kdtree_type</span><span class="s2">, </span><span class="s1">balanced_tree</span><span class="s2">, </span><span class="s1">compact_nodes):</span>
    <span class="s0"># https://github.com/scipy/scipy/issues/5040</span>
    <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
    <span class="s1">empty_v3 = np.empty(shape=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s1">))</span>
    <span class="s1">query_v3 = np.ones(shape=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s1">))</span>
    <span class="s1">query_v2 = np.ones(shape=(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">))</span>

    <span class="s1">tree = kdtree_type(empty_v3</span><span class="s2">, </span><span class="s1">balanced_tree=balanced_tree</span><span class="s2">,</span>
                       <span class="s1">compact_nodes=compact_nodes)</span>
    <span class="s1">length = tree.query_ball_point(query_v3</span><span class="s2">, </span><span class="s5">0.3</span><span class="s2">, </span><span class="s1">return_length=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">length == </span><span class="s5">0</span>

    <span class="s1">dd</span><span class="s2">, </span><span class="s1">ii = tree.query(query_v2</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">ii.shape == (</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">dd.shape == (</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">np.isinf(dd).all()</span>

    <span class="s1">N = tree.count_neighbors(tree</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(N</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">])</span>

    <span class="s1">M = tree.sparse_distance_matrix(tree</span><span class="s2">, </span><span class="s5">0.3</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">M.shape == (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>

<span class="s1">@KDTreeTest</span>
<span class="s2">class </span><span class="s1">_Test_sorted_query_ball_point:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
        <span class="s1">self.x = np.random.randn(</span><span class="s5">100</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">self.ckdt = self.kdtree_type(self.x)</span>

    <span class="s2">def </span><span class="s1">test_return_sorted_True(self):</span>
        <span class="s1">idxs_list = self.ckdt.query_ball_point(self.x</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s1">return_sorted=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">idxs </span><span class="s2">in </span><span class="s1">idxs_list:</span>
            <span class="s1">assert_array_equal(idxs</span><span class="s2">, </span><span class="s1">sorted(idxs))</span>

        <span class="s2">for </span><span class="s1">xi </span><span class="s2">in </span><span class="s1">self.x:</span>
            <span class="s1">idxs = self.ckdt.query_ball_point(xi</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s1">return_sorted=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">assert_array_equal(idxs</span><span class="s2">, </span><span class="s1">sorted(idxs))</span>

    <span class="s2">def </span><span class="s1">test_return_sorted_None(self):</span>
        <span class="s3">&quot;&quot;&quot;Previous behavior was to sort the returned indices if there were 
        multiple points per query but not sort them if there was a single point 
        per query.&quot;&quot;&quot;</span>
        <span class="s1">idxs_list = self.ckdt.query_ball_point(self.x</span><span class="s2">, </span><span class="s5">1.</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">idxs </span><span class="s2">in </span><span class="s1">idxs_list:</span>
            <span class="s1">assert_array_equal(idxs</span><span class="s2">, </span><span class="s1">sorted(idxs))</span>

        <span class="s1">idxs_list_single = [self.ckdt.query_ball_point(xi</span><span class="s2">, </span><span class="s5">1.</span><span class="s1">) </span><span class="s2">for </span><span class="s1">xi </span><span class="s2">in </span><span class="s1">self.x]</span>
        <span class="s1">idxs_list_False = self.ckdt.query_ball_point(self.x</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s1">return_sorted=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">idxs0</span><span class="s2">, </span><span class="s1">idxs1 </span><span class="s2">in </span><span class="s1">zip(idxs_list_False</span><span class="s2">, </span><span class="s1">idxs_list_single):</span>
            <span class="s1">assert_array_equal(idxs0</span><span class="s2">, </span><span class="s1">idxs1)</span>


<span class="s2">def </span><span class="s1">test_kdtree_complex_data():</span>
    <span class="s0"># Test that KDTree rejects complex input points (gh-9108)</span>
    <span class="s1">points = np.random.rand(</span><span class="s5">10</span><span class="s2">, </span><span class="s5">2</span><span class="s1">).view(complex)</span>

    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;complex data&quot;</span><span class="s1">):</span>
        <span class="s1">t = KDTree(points)</span>

    <span class="s1">t = KDTree(points.real)</span>

    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;complex data&quot;</span><span class="s1">):</span>
        <span class="s1">t.query(points)</span>

    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;complex data&quot;</span><span class="s1">):</span>
        <span class="s1">t.query_ball_point(points</span><span class="s2">, </span><span class="s1">r=</span><span class="s5">1</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_kdtree_tree_access():</span>
    <span class="s0"># Test KDTree.tree can be used to traverse the KDTree</span>
    <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
    <span class="s1">points = np.random.rand(</span><span class="s5">100</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
    <span class="s1">t = KDTree(points)</span>
    <span class="s1">root = t.tree</span>

    <span class="s2">assert </span><span class="s1">isinstance(root</span><span class="s2">, </span><span class="s1">KDTree.innernode)</span>
    <span class="s2">assert </span><span class="s1">root.children == points.shape[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s0"># Visit the tree and assert some basic properties for each node</span>
    <span class="s1">nodes = [root]</span>
    <span class="s2">while </span><span class="s1">nodes:</span>
        <span class="s1">n = nodes.pop(-</span><span class="s5">1</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">isinstance(n</span><span class="s2">, </span><span class="s1">KDTree.leafnode):</span>
            <span class="s2">assert </span><span class="s1">isinstance(n.children</span><span class="s2">, </span><span class="s1">int)</span>
            <span class="s2">assert </span><span class="s1">n.children == len(n.idx)</span>
            <span class="s1">assert_array_equal(points[n.idx]</span><span class="s2">, </span><span class="s1">n._node.data_points)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">isinstance(n</span><span class="s2">, </span><span class="s1">KDTree.innernode)</span>
            <span class="s2">assert </span><span class="s1">isinstance(n.split_dim</span><span class="s2">, </span><span class="s1">int)</span>
            <span class="s2">assert </span><span class="s5">0 </span><span class="s1">&lt;= n.split_dim &lt; t.m</span>
            <span class="s2">assert </span><span class="s1">isinstance(n.split</span><span class="s2">, </span><span class="s1">float)</span>
            <span class="s2">assert </span><span class="s1">isinstance(n.children</span><span class="s2">, </span><span class="s1">int)</span>
            <span class="s2">assert </span><span class="s1">n.children == n.less.children + n.greater.children</span>
            <span class="s1">nodes.append(n.greater)</span>
            <span class="s1">nodes.append(n.less)</span>


<span class="s2">def </span><span class="s1">test_kdtree_attributes():</span>
    <span class="s0"># Test KDTree's attributes are available</span>
    <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
    <span class="s1">points = np.random.rand(</span><span class="s5">100</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
    <span class="s1">t = KDTree(points)</span>

    <span class="s2">assert </span><span class="s1">isinstance(t.m</span><span class="s2">, </span><span class="s1">int)</span>
    <span class="s2">assert </span><span class="s1">t.n == points.shape[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s2">assert </span><span class="s1">isinstance(t.n</span><span class="s2">, </span><span class="s1">int)</span>
    <span class="s2">assert </span><span class="s1">t.m == points.shape[</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s2">assert </span><span class="s1">isinstance(t.leafsize</span><span class="s2">, </span><span class="s1">int)</span>
    <span class="s2">assert </span><span class="s1">t.leafsize == </span><span class="s5">10</span>

    <span class="s1">assert_array_equal(t.maxes</span><span class="s2">, </span><span class="s1">np.amax(points</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">))</span>
    <span class="s1">assert_array_equal(t.mins</span><span class="s2">, </span><span class="s1">np.amin(points</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">))</span>
    <span class="s2">assert </span><span class="s1">t.data </span><span class="s2">is </span><span class="s1">points</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;kdtree_class&quot;</span><span class="s2">, </span><span class="s1">[KDTree</span><span class="s2">, </span><span class="s1">cKDTree])</span>
<span class="s2">def </span><span class="s1">test_kdtree_count_neighbors_weighted(kdtree_class):</span>
    <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
    <span class="s1">r = np.arange(</span><span class="s5">0.05</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0.05</span><span class="s1">)</span>

    <span class="s1">A = np.random.random(</span><span class="s5">21</span><span class="s1">).reshape((</span><span class="s5">7</span><span class="s2">,</span><span class="s5">3</span><span class="s1">))</span>
    <span class="s1">B = np.random.random(</span><span class="s5">45</span><span class="s1">).reshape((</span><span class="s5">15</span><span class="s2">,</span><span class="s5">3</span><span class="s1">))</span>

    <span class="s1">wA = np.random.random(</span><span class="s5">7</span><span class="s1">)</span>
    <span class="s1">wB = np.random.random(</span><span class="s5">15</span><span class="s1">)</span>

    <span class="s1">kdA = kdtree_class(A)</span>
    <span class="s1">kdB = kdtree_class(B)</span>

    <span class="s1">nAB = kdA.count_neighbors(kdB</span><span class="s2">, </span><span class="s1">r</span><span class="s2">, </span><span class="s1">cumulative=</span><span class="s2">False, </span><span class="s1">weights=(wA</span><span class="s2">,</span><span class="s1">wB))</span>

    <span class="s0"># Compare against brute-force</span>
    <span class="s1">weights = wA[</span><span class="s2">None, </span><span class="s1">:] * wB[:</span><span class="s2">, None</span><span class="s1">]</span>
    <span class="s1">dist = np.linalg.norm(A[</span><span class="s2">None, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:] - B[:</span><span class="s2">, None, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">expect = [np.sum(weights[(prev_radius &lt; dist) &amp; (dist &lt;= radius)])</span>
              <span class="s2">for </span><span class="s1">prev_radius</span><span class="s2">, </span><span class="s1">radius </span><span class="s2">in </span><span class="s1">zip(itertools.chain([</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">r[:-</span><span class="s5">1</span><span class="s1">])</span><span class="s2">, </span><span class="s1">r)]</span>
    <span class="s1">assert_allclose(nAB</span><span class="s2">, </span><span class="s1">expect)</span>


<span class="s2">def </span><span class="s1">test_kdtree_nan():</span>
    <span class="s1">vals = [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s1">-</span><span class="s5">10</span><span class="s2">, </span><span class="s5">7</span><span class="s2">, </span><span class="s1">-</span><span class="s5">4</span><span class="s2">, </span><span class="s1">-</span><span class="s5">16</span><span class="s2">, </span><span class="s1">-</span><span class="s5">6</span><span class="s2">, </span><span class="s5">6</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s1">-</span><span class="s5">11</span><span class="s1">]</span>
    <span class="s1">n = len(vals)</span>
    <span class="s1">data = np.concatenate([vals</span><span class="s2">, </span><span class="s1">np.full(n</span><span class="s2">, </span><span class="s1">np.nan)])[:</span><span class="s2">, None</span><span class="s1">]</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;must be finite&quot;</span><span class="s1">):</span>
        <span class="s1">KDTree(data)</span>


<span class="s2">def </span><span class="s1">test_nonfinite_inputs_gh_18223():</span>
    <span class="s1">rng = np.random.default_rng(</span><span class="s5">12345</span><span class="s1">)</span>
    <span class="s1">coords = rng.uniform(size=(</span><span class="s5">100</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">low=</span><span class="s5">0.0</span><span class="s2">, </span><span class="s1">high=</span><span class="s5">0.1</span><span class="s1">)</span>
    <span class="s1">t = KDTree(coords</span><span class="s2">, </span><span class="s1">balanced_tree=</span><span class="s2">False, </span><span class="s1">compact_nodes=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">bad_coord = [np.nan </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">3</span><span class="s1">)]</span>

    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;must be finite&quot;</span><span class="s1">):</span>
        <span class="s1">t.query(bad_coord)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;must be finite&quot;</span><span class="s1">):</span>
        <span class="s1">t.query_ball_point(bad_coord</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s1">coords[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:] = np.nan</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;must be finite&quot;</span><span class="s1">):</span>
        <span class="s1">KDTree(coords</span><span class="s2">, </span><span class="s1">balanced_tree=</span><span class="s2">True, </span><span class="s1">compact_nodes=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;must be finite&quot;</span><span class="s1">):</span>
        <span class="s1">KDTree(coords</span><span class="s2">, </span><span class="s1">balanced_tree=</span><span class="s2">False, </span><span class="s1">compact_nodes=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;must be finite&quot;</span><span class="s1">):</span>
        <span class="s1">KDTree(coords</span><span class="s2">, </span><span class="s1">balanced_tree=</span><span class="s2">True, </span><span class="s1">compact_nodes=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;must be finite&quot;</span><span class="s1">):</span>
        <span class="s1">KDTree(coords</span><span class="s2">, </span><span class="s1">balanced_tree=</span><span class="s2">False, </span><span class="s1">compact_nodes=</span><span class="s2">False</span><span class="s1">)</span>
</pre>
</body>
</html>