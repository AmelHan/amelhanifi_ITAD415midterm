<html>
<head>
<title>contour.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
contour.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Classes to support contour plotting and labelling for the Axes class. 
&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">contextlib </span><span class="s2">import </span><span class="s1">ExitStack</span>
<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">import </span><span class="s1">math</span>
<span class="s2">from </span><span class="s1">numbers </span><span class="s2">import </span><span class="s1">Integral</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy </span><span class="s2">import </span><span class="s1">ma</span>

<span class="s2">import </span><span class="s1">matplotlib </span><span class="s2">as </span><span class="s1">mpl</span>
<span class="s2">from </span><span class="s1">matplotlib </span><span class="s2">import </span><span class="s1">_api</span><span class="s2">, </span><span class="s1">_docstring</span>
<span class="s2">from </span><span class="s1">matplotlib.backend_bases </span><span class="s2">import </span><span class="s1">MouseButton</span>
<span class="s2">from </span><span class="s1">matplotlib.lines </span><span class="s2">import </span><span class="s1">Line2D</span>
<span class="s2">from </span><span class="s1">matplotlib.path </span><span class="s2">import </span><span class="s1">Path</span>
<span class="s2">from </span><span class="s1">matplotlib.text </span><span class="s2">import </span><span class="s1">Text</span>
<span class="s2">import </span><span class="s1">matplotlib.ticker </span><span class="s2">as </span><span class="s1">ticker</span>
<span class="s2">import </span><span class="s1">matplotlib.cm </span><span class="s2">as </span><span class="s1">cm</span>
<span class="s2">import </span><span class="s1">matplotlib.colors </span><span class="s2">as </span><span class="s1">mcolors</span>
<span class="s2">import </span><span class="s1">matplotlib.collections </span><span class="s2">as </span><span class="s1">mcoll</span>
<span class="s2">import </span><span class="s1">matplotlib.font_manager </span><span class="s2">as </span><span class="s1">font_manager</span>
<span class="s2">import </span><span class="s1">matplotlib.cbook </span><span class="s2">as </span><span class="s1">cbook</span>
<span class="s2">import </span><span class="s1">matplotlib.patches </span><span class="s2">as </span><span class="s1">mpatches</span>
<span class="s2">import </span><span class="s1">matplotlib.transforms </span><span class="s2">as </span><span class="s1">mtransforms</span>


<span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.7&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">&quot;Text.set_transform_rotates_text&quot;</span><span class="s1">)</span>
<span class="s2">class </span><span class="s1">ClabelText(Text):</span>
    <span class="s0">&quot;&quot;&quot; 
    Unlike the ordinary text, the get_rotation returns an updated 
    angle in the pixel coordinate assuming that the input rotation is 
    an angle in data coordinate (or whatever transform set). 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">get_rotation(self):</span>
        <span class="s1">new_angle</span><span class="s2">, </span><span class="s1">= self.get_transform().transform_angles(</span>
            <span class="s1">[super().get_rotation()]</span><span class="s2">, </span><span class="s1">[self.get_position()])</span>
        <span class="s2">return </span><span class="s1">new_angle</span>


<span class="s2">def </span><span class="s1">_contour_labeler_event_handler(cs</span><span class="s2">, </span><span class="s1">inline</span><span class="s2">, </span><span class="s1">inline_spacing</span><span class="s2">, </span><span class="s1">event):</span>
    <span class="s1">canvas = cs.axes.figure.canvas</span>
    <span class="s1">is_button = event.name == </span><span class="s3">&quot;button_press_event&quot;</span>
    <span class="s1">is_key = event.name == </span><span class="s3">&quot;key_press_event&quot;</span>
    <span class="s4"># Quit (even if not in infinite mode; this is consistent with</span>
    <span class="s4"># MATLAB and sometimes quite useful, but will require the user to</span>
    <span class="s4"># test how many points were actually returned before using data).</span>
    <span class="s2">if </span><span class="s1">(is_button </span><span class="s2">and </span><span class="s1">event.button == MouseButton.MIDDLE</span>
            <span class="s2">or </span><span class="s1">is_key </span><span class="s2">and </span><span class="s1">event.key </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;escape&quot;</span><span class="s2">, </span><span class="s3">&quot;enter&quot;</span><span class="s1">]):</span>
        <span class="s1">canvas.stop_event_loop()</span>
    <span class="s4"># Pop last click.</span>
    <span class="s2">elif </span><span class="s1">(is_button </span><span class="s2">and </span><span class="s1">event.button == MouseButton.RIGHT</span>
          <span class="s2">or </span><span class="s1">is_key </span><span class="s2">and </span><span class="s1">event.key </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;backspace&quot;</span><span class="s2">, </span><span class="s3">&quot;delete&quot;</span><span class="s1">]):</span>
        <span class="s4"># Unfortunately, if one is doing inline labels, then there is currently</span>
        <span class="s4"># no way to fix the broken contour - once humpty-dumpty is broken, he</span>
        <span class="s4"># can't be put back together.  In inline mode, this does nothing.</span>
        <span class="s2">if not </span><span class="s1">inline:</span>
            <span class="s1">cs.pop_label()</span>
            <span class="s1">canvas.draw()</span>
    <span class="s4"># Add new click.</span>
    <span class="s2">elif </span><span class="s1">(is_button </span><span class="s2">and </span><span class="s1">event.button == MouseButton.LEFT</span>
          <span class="s4"># On macOS/gtk, some keys return None.</span>
          <span class="s2">or </span><span class="s1">is_key </span><span class="s2">and </span><span class="s1">event.key </span><span class="s2">is not None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">cs.axes.contains(event)[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s1">cs.add_label_near(event.x</span><span class="s2">, </span><span class="s1">event.y</span><span class="s2">, </span><span class="s1">transform=</span><span class="s2">False,</span>
                              <span class="s1">inline=inline</span><span class="s2">, </span><span class="s1">inline_spacing=inline_spacing)</span>
            <span class="s1">canvas.draw()</span>


<span class="s2">class </span><span class="s1">ContourLabeler:</span>
    <span class="s0">&quot;&quot;&quot;Mixin to provide labelling capability to `.ContourSet`.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">clabel(self</span><span class="s2">, </span><span class="s1">levels=</span><span class="s2">None, </span><span class="s1">*</span><span class="s2">,</span>
               <span class="s1">fontsize=</span><span class="s2">None, </span><span class="s1">inline=</span><span class="s2">True, </span><span class="s1">inline_spacing=</span><span class="s5">5</span><span class="s2">, </span><span class="s1">fmt=</span><span class="s2">None,</span>
               <span class="s1">colors=</span><span class="s2">None, </span><span class="s1">use_clabeltext=</span><span class="s2">False, </span><span class="s1">manual=</span><span class="s2">False,</span>
               <span class="s1">rightside_up=</span><span class="s2">True, </span><span class="s1">zorder=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Label a contour plot. 
 
        Adds labels to line contours in this `.ContourSet` (which inherits from 
        this mixin class). 
 
        Parameters 
        ---------- 
        levels : array-like, optional 
            A list of level values, that should be labeled. The list must be 
            a subset of ``cs.levels``. If not given, all levels are labeled. 
 
        fontsize : str or float, default: :rc:`font.size` 
            Size in points or relative size e.g., 'smaller', 'x-large'. 
            See `.Text.set_size` for accepted string values. 
 
        colors : color or colors or None, default: None 
            The label colors: 
 
            - If *None*, the color of each label matches the color of 
              the corresponding contour. 
 
            - If one string color, e.g., *colors* = 'r' or *colors* = 
              'red', all labels will be plotted in this color. 
 
            - If a tuple of colors (string, float, RGB, etc), different labels 
              will be plotted in different colors in the order specified. 
 
        inline : bool, default: True 
            If ``True`` the underlying contour is removed where the label is 
            placed. 
 
        inline_spacing : float, default: 5 
            Space in pixels to leave on each side of label when placing inline. 
 
            This spacing will be exact for labels at locations where the 
            contour is straight, less so for labels on curved contours. 
 
        fmt : `.Formatter` or str or callable or dict, optional 
            How the levels are formatted: 
 
            - If a `.Formatter`, it is used to format all levels at once, using 
              its `.Formatter.format_ticks` method. 
            - If a str, it is interpreted as a %-style format string. 
            - If a callable, it is called with one level at a time and should 
              return the corresponding label. 
            - If a dict, it should directly map levels to labels. 
 
            The default is to use a standard `.ScalarFormatter`. 
 
        manual : bool or iterable, default: False 
            If ``True``, contour labels will be placed manually using 
            mouse clicks. Click the first button near a contour to 
            add a label, click the second button (or potentially both 
            mouse buttons at once) to finish adding labels. The third 
            button can be used to remove the last label added, but 
            only if labels are not inline. Alternatively, the keyboard 
            can be used to select label locations (enter to end label 
            placement, delete or backspace act like the third mouse button, 
            and any other key will select a label location). 
 
            *manual* can also be an iterable object of (x, y) tuples. 
            Contour labels will be created as if mouse is clicked at each 
            (x, y) position. 
 
        rightside_up : bool, default: True 
            If ``True``, label rotations will always be plus 
            or minus 90 degrees from level. 
 
        use_clabeltext : bool, default: False 
            If ``True``, use `.Text.set_transform_rotates_text` to ensure that 
            label rotation is updated whenever the axes aspect changes. 
 
        zorder : float or None, default: ``(2 + contour.get_zorder())`` 
            zorder of the contour labels. 
 
        Returns 
        ------- 
        labels 
            A list of `.Text` instances for the labels. 
        &quot;&quot;&quot;</span>

        <span class="s4"># clabel basically takes the input arguments and uses them to</span>
        <span class="s4"># add a list of &quot;label specific&quot; attributes to the ContourSet</span>
        <span class="s4"># object.  These attributes are all of the form label* and names</span>
        <span class="s4"># should be fairly self explanatory.</span>
        <span class="s4">#</span>
        <span class="s4"># Once these attributes are set, clabel passes control to the</span>
        <span class="s4"># labels method (case of automatic label placement) or</span>
        <span class="s4"># `BlockingContourLabeler` (case of manual label placement).</span>

        <span class="s2">if </span><span class="s1">fmt </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">fmt = ticker.ScalarFormatter(useOffset=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s1">fmt.create_dummy_axis()</span>
        <span class="s1">self.labelFmt = fmt</span>
        <span class="s1">self._use_clabeltext = use_clabeltext</span>
        <span class="s4"># Detect if manual selection is desired and remove from argument list.</span>
        <span class="s1">self.labelManual = manual</span>
        <span class="s1">self.rightside_up = rightside_up</span>
        <span class="s1">self._clabel_zorder = </span><span class="s5">2 </span><span class="s1">+ self.get_zorder() </span><span class="s2">if </span><span class="s1">zorder </span><span class="s2">is None else </span><span class="s1">zorder</span>

        <span class="s2">if </span><span class="s1">levels </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">levels = self.levels</span>
            <span class="s1">indices = list(range(len(self.cvalues)))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">levlabs = list(levels)</span>
            <span class="s1">indices</span><span class="s2">, </span><span class="s1">levels = []</span><span class="s2">, </span><span class="s1">[]</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">lev </span><span class="s2">in </span><span class="s1">enumerate(self.levels):</span>
                <span class="s2">if </span><span class="s1">lev </span><span class="s2">in </span><span class="s1">levlabs:</span>
                    <span class="s1">indices.append(i)</span>
                    <span class="s1">levels.append(lev)</span>
            <span class="s2">if </span><span class="s1">len(levels) &lt; len(levlabs):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;Specified levels </span><span class="s2">{</span><span class="s1">levlabs</span><span class="s2">} </span><span class="s3">don't match &quot;</span>
                                 <span class="s3">f&quot;available levels </span><span class="s2">{</span><span class="s1">self.levels</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s1">self.labelLevelList = levels</span>
        <span class="s1">self.labelIndiceList = indices</span>

        <span class="s1">self._label_font_props = font_manager.FontProperties(size=fontsize)</span>

        <span class="s2">if </span><span class="s1">colors </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.labelMappable = self</span>
            <span class="s1">self.labelCValueList = np.take(self.cvalues</span><span class="s2">, </span><span class="s1">self.labelIndiceList)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">cmap = mcolors.ListedColormap(colors</span><span class="s2">, </span><span class="s1">N=len(self.labelLevelList))</span>
            <span class="s1">self.labelCValueList = list(range(len(self.labelLevelList)))</span>
            <span class="s1">self.labelMappable = cm.ScalarMappable(cmap=cmap</span><span class="s2">,</span>
                                                   <span class="s1">norm=mcolors.NoNorm())</span>

        <span class="s1">self.labelXYs = []</span>

        <span class="s2">if </span><span class="s1">np.iterable(manual):</span>
            <span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">in </span><span class="s1">manual:</span>
                <span class="s1">self.add_label_near(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">inline</span><span class="s2">, </span><span class="s1">inline_spacing)</span>
        <span class="s2">elif </span><span class="s1">manual:</span>
            <span class="s1">print(</span><span class="s3">'Select label locations manually using first mouse button.'</span><span class="s1">)</span>
            <span class="s1">print(</span><span class="s3">'End manual selection with second mouse button.'</span><span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">inline:</span>
                <span class="s1">print(</span><span class="s3">'Remove last label by clicking third mouse button.'</span><span class="s1">)</span>
            <span class="s1">mpl._blocking_input.blocking_input_loop(</span>
                <span class="s1">self.axes.figure</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;button_press_event&quot;</span><span class="s2">, </span><span class="s3">&quot;key_press_event&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">timeout=-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">handler=functools.partial(</span>
                    <span class="s1">_contour_labeler_event_handler</span><span class="s2">,</span>
                    <span class="s1">self</span><span class="s2">, </span><span class="s1">inline</span><span class="s2">, </span><span class="s1">inline_spacing))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.labels(inline</span><span class="s2">, </span><span class="s1">inline_spacing)</span>

        <span class="s2">return </span><span class="s1">cbook.silent_list(</span><span class="s3">'text.Text'</span><span class="s2">, </span><span class="s1">self.labelTexts)</span>

    <span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.7&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">&quot;cs.labelTexts[0].get_font()&quot;</span><span class="s1">)</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">labelFontProps(self):</span>
        <span class="s2">return </span><span class="s1">self._label_font_props</span>

    <span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.7&quot;</span><span class="s2">, </span><span class="s1">alternative=(</span>
        <span class="s3">&quot;[cs.labelTexts[0].get_font().get_size()] * len(cs.labelLevelList)&quot;</span><span class="s1">))</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">labelFontSizeList(self):</span>
        <span class="s2">return </span><span class="s1">[self._label_font_props.get_size()] * len(self.labelLevelList)</span>

    <span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.7&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">&quot;cs.labelTexts&quot;</span><span class="s1">)</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">labelTextsList(self):</span>
        <span class="s2">return </span><span class="s1">cbook.silent_list(</span><span class="s3">'text.Text'</span><span class="s2">, </span><span class="s1">self.labelTexts)</span>

    <span class="s2">def </span><span class="s1">print_label(self</span><span class="s2">, </span><span class="s1">linecontour</span><span class="s2">, </span><span class="s1">labelwidth):</span>
        <span class="s0">&quot;&quot;&quot;Return whether a contour is long enough to hold a label.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">(len(linecontour) &gt; </span><span class="s5">10 </span><span class="s1">* labelwidth</span>
                <span class="s2">or </span><span class="s1">(len(linecontour)</span>
                    <span class="s2">and </span><span class="s1">(np.ptp(linecontour</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">) &gt; </span><span class="s5">1.2 </span><span class="s1">* labelwidth).any()))</span>

    <span class="s2">def </span><span class="s1">too_close(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">lw):</span>
        <span class="s0">&quot;&quot;&quot;Return whether a label is already near this location.&quot;&quot;&quot;</span>
        <span class="s1">thresh = (</span><span class="s5">1.2 </span><span class="s1">* lw) ** </span><span class="s5">2</span>
        <span class="s2">return </span><span class="s1">any((x - loc[</span><span class="s5">0</span><span class="s1">]) ** </span><span class="s5">2 </span><span class="s1">+ (y - loc[</span><span class="s5">1</span><span class="s1">]) ** </span><span class="s5">2 </span><span class="s1">&lt; thresh</span>
                   <span class="s2">for </span><span class="s1">loc </span><span class="s2">in </span><span class="s1">self.labelXYs)</span>

    <span class="s2">def </span><span class="s1">_get_nth_label_width(self</span><span class="s2">, </span><span class="s1">nth):</span>
        <span class="s0">&quot;&quot;&quot;Return the width of the *nth* label, in pixels.&quot;&quot;&quot;</span>
        <span class="s1">fig = self.axes.figure</span>
        <span class="s1">renderer = fig._get_renderer()</span>
        <span class="s2">return </span><span class="s1">(Text(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">,</span>
                     <span class="s1">self.get_text(self.labelLevelList[nth]</span><span class="s2">, </span><span class="s1">self.labelFmt)</span><span class="s2">,</span>
                     <span class="s1">figure=fig</span><span class="s2">, </span><span class="s1">fontproperties=self._label_font_props)</span>
                <span class="s1">.get_window_extent(renderer).width)</span>

    <span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.7&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">&quot;Artist.set&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">set_label_props(self</span><span class="s2">, </span><span class="s1">label</span><span class="s2">, </span><span class="s1">text</span><span class="s2">, </span><span class="s1">color):</span>
        <span class="s0">&quot;&quot;&quot;Set the label properties - color, fontsize, text.&quot;&quot;&quot;</span>
        <span class="s1">label.set_text(text)</span>
        <span class="s1">label.set_color(color)</span>
        <span class="s1">label.set_fontproperties(self._label_font_props)</span>
        <span class="s1">label.set_clip_box(self.axes.bbox)</span>

    <span class="s2">def </span><span class="s1">get_text(self</span><span class="s2">, </span><span class="s1">lev</span><span class="s2">, </span><span class="s1">fmt):</span>
        <span class="s0">&quot;&quot;&quot;Get the text of the label.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(lev</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">return </span><span class="s1">lev</span>
        <span class="s2">elif </span><span class="s1">isinstance(fmt</span><span class="s2">, </span><span class="s1">dict):</span>
            <span class="s2">return </span><span class="s1">fmt.get(lev</span><span class="s2">, </span><span class="s3">'%1.3f'</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">callable(getattr(fmt</span><span class="s2">, </span><span class="s3">&quot;format_ticks&quot;</span><span class="s2">, None</span><span class="s1">)):</span>
            <span class="s2">return </span><span class="s1">fmt.format_ticks([*self.labelLevelList</span><span class="s2">, </span><span class="s1">lev])[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">elif </span><span class="s1">callable(fmt):</span>
            <span class="s2">return </span><span class="s1">fmt(lev)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">fmt % lev</span>

    <span class="s2">def </span><span class="s1">locate_label(self</span><span class="s2">, </span><span class="s1">linecontour</span><span class="s2">, </span><span class="s1">labelwidth):</span>
        <span class="s0">&quot;&quot;&quot; 
        Find good place to draw a label (relatively flat part of the contour). 
        &quot;&quot;&quot;</span>
        <span class="s1">ctr_size = len(linecontour)</span>
        <span class="s1">n_blocks = int(np.ceil(ctr_size / labelwidth)) </span><span class="s2">if </span><span class="s1">labelwidth &gt; </span><span class="s5">1 </span><span class="s2">else </span><span class="s5">1</span>
        <span class="s1">block_size = ctr_size </span><span class="s2">if </span><span class="s1">n_blocks == </span><span class="s5">1 </span><span class="s2">else </span><span class="s1">int(labelwidth)</span>
        <span class="s4"># Split contour into blocks of length ``block_size``, filling the last</span>
        <span class="s4"># block by cycling the contour start (per `np.resize` semantics).  (Due</span>
        <span class="s4"># to cycling, the index returned is taken modulo ctr_size.)</span>
        <span class="s1">xx = np.resize(linecontour[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">(n_blocks</span><span class="s2">, </span><span class="s1">block_size))</span>
        <span class="s1">yy = np.resize(linecontour[:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">(n_blocks</span><span class="s2">, </span><span class="s1">block_size))</span>
        <span class="s1">yfirst = yy[:</span><span class="s2">, </span><span class="s1">:</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">ylast = yy[:</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s1">xfirst = xx[:</span><span class="s2">, </span><span class="s1">:</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">xlast = xx[:</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s1">s = (yfirst - yy) * (xlast - xfirst) - (xfirst - xx) * (ylast - yfirst)</span>
        <span class="s1">l = np.hypot(xlast - xfirst</span><span class="s2">, </span><span class="s1">ylast - yfirst)</span>
        <span class="s4"># Ignore warning that divide by zero throws, as this is a valid option</span>
        <span class="s2">with </span><span class="s1">np.errstate(divide=</span><span class="s3">'ignore'</span><span class="s2">, </span><span class="s1">invalid=</span><span class="s3">'ignore'</span><span class="s1">):</span>
            <span class="s1">distances = (abs(s) / l).sum(axis=-</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s4"># Labels are drawn in the middle of the block (``hbsize``) where the</span>
        <span class="s4"># contour is the closest (per ``distances``) to a straight line, but</span>
        <span class="s4"># not `too_close()` to a preexisting label.</span>
        <span class="s1">hbsize = block_size // </span><span class="s5">2</span>
        <span class="s1">adist = np.argsort(distances)</span>
        <span class="s4"># If all candidates are `too_close()`, go back to the straightest part</span>
        <span class="s4"># (``adist[0]``).</span>
        <span class="s2">for </span><span class="s1">idx </span><span class="s2">in </span><span class="s1">np.append(adist</span><span class="s2">, </span><span class="s1">adist[</span><span class="s5">0</span><span class="s1">]):</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">y = xx[idx</span><span class="s2">, </span><span class="s1">hbsize]</span><span class="s2">, </span><span class="s1">yy[idx</span><span class="s2">, </span><span class="s1">hbsize]</span>
            <span class="s2">if not </span><span class="s1">self.too_close(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">labelwidth):</span>
                <span class="s2">break</span>
        <span class="s2">return </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">(idx * block_size + hbsize) % ctr_size</span>

    <span class="s2">def </span><span class="s1">_split_path_and_get_label_rotation(self</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">screen_pos</span><span class="s2">, </span><span class="s1">lw</span><span class="s2">, </span><span class="s1">spacing=</span><span class="s5">5</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Prepare for insertion of a label at index *idx* of *path*. 
 
        Parameters 
        ---------- 
        path : Path 
            The path where the label will be inserted, in data space. 
        idx : int 
            The vertex index after which the label will be inserted. 
        screen_pos : (float, float) 
            The position where the label will be inserted, in screen space. 
        lw : float 
            The label width, in screen space. 
        spacing : float 
            Extra spacing around the label, in screen space. 
 
        Returns 
        ------- 
        path : Path 
            The path, broken so that the label can be drawn over it. 
        angle : float 
            The rotation of the label. 
 
        Notes 
        ----- 
        Both tasks are done together to avoid calculating path lengths multiple times, 
        which is relatively costly. 
 
        The method used here involves computing the path length along the contour in 
        pixel coordinates and then looking (label width / 2) away from central point to 
        determine rotation and then to break contour if desired.  The extra spacing is 
        taken into account when breaking the path, but not when computing the angle. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s3">&quot;_old_style_split_collections&quot;</span><span class="s1">):</span>
            <span class="s1">vis = </span><span class="s2">False</span>
            <span class="s2">for </span><span class="s1">coll </span><span class="s2">in </span><span class="s1">self._old_style_split_collections:</span>
                <span class="s1">vis |= coll.get_visible()</span>
                <span class="s1">coll.remove()</span>
            <span class="s1">self.set_visible(vis)</span>
            <span class="s2">del </span><span class="s1">self._old_style_split_collections  </span><span class="s4"># Invalidate them.</span>

        <span class="s1">xys = path.vertices</span>
        <span class="s1">codes = path.codes</span>

        <span class="s4"># Insert a vertex at idx/pos (converting back to data space), if there isn't yet</span>
        <span class="s4"># a vertex there.  With infinite precision one could also always insert the</span>
        <span class="s4"># extra vertex (it will get masked out by the label below anyways), but floating</span>
        <span class="s4"># point inaccuracies (the point can have undergone a data-&gt;screen-&gt;data</span>
        <span class="s4"># transform loop) can slightly shift the point and e.g. shift the angle computed</span>
        <span class="s4"># below from exactly zero to nonzero.</span>
        <span class="s1">pos = self.get_transform().inverted().transform(screen_pos)</span>
        <span class="s2">if not </span><span class="s1">np.allclose(pos</span><span class="s2">, </span><span class="s1">xys[idx]):</span>
            <span class="s1">xys = np.insert(xys</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>
            <span class="s1">codes = np.insert(codes</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">Path.LINETO)</span>

        <span class="s4"># Find the connected component where the label will be inserted.  Note that a</span>
        <span class="s4"># path always starts with a MOVETO, and we consider there's an implicit</span>
        <span class="s4"># MOVETO (closing the last path) at the end.</span>
        <span class="s1">movetos = (codes == Path.MOVETO).nonzero()[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">start = movetos[movetos &lt;= idx][-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">stop = movetos[movetos &gt; idx][</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">except </span><span class="s1">IndexError:</span>
            <span class="s1">stop = len(codes)</span>

        <span class="s4"># Restrict ourselves to the connected component.</span>
        <span class="s1">cc_xys = xys[start:stop]</span>
        <span class="s1">idx -= start</span>

        <span class="s4"># If the path is closed, rotate it s.t. it starts at the label.</span>
        <span class="s1">is_closed_path = codes[stop - </span><span class="s5">1</span><span class="s1">] == Path.CLOSEPOLY</span>
        <span class="s2">if </span><span class="s1">is_closed_path:</span>
            <span class="s1">cc_xys = np.concatenate([cc_xys[idx:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">cc_xys[:idx+</span><span class="s5">1</span><span class="s1">]])</span>
            <span class="s1">idx = </span><span class="s5">0</span>

        <span class="s4"># Like np.interp, but additionally vectorized over fp.</span>
        <span class="s2">def </span><span class="s1">interp_vec(x</span><span class="s2">, </span><span class="s1">xp</span><span class="s2">, </span><span class="s1">fp): </span><span class="s2">return </span><span class="s1">[np.interp(x</span><span class="s2">, </span><span class="s1">xp</span><span class="s2">, </span><span class="s1">col) </span><span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">fp.T]</span>

        <span class="s4"># Use cumulative path lengths (&quot;cpl&quot;) as curvilinear coordinate along contour.</span>
        <span class="s1">screen_xys = self.get_transform().transform(cc_xys)</span>
        <span class="s1">path_cpls = np.insert(</span>
            <span class="s1">np.cumsum(np.hypot(*np.diff(screen_xys</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">).T))</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">path_cpls -= path_cpls[idx]</span>

        <span class="s4"># Use linear interpolation to get end coordinates of label.</span>
        <span class="s1">target_cpls = np.array([-lw/</span><span class="s5">2</span><span class="s2">, </span><span class="s1">lw/</span><span class="s5">2</span><span class="s1">])</span>
        <span class="s2">if </span><span class="s1">is_closed_path:  </span><span class="s4"># For closed paths, target from the other end.</span>
            <span class="s1">target_cpls[</span><span class="s5">0</span><span class="s1">] += (path_cpls[-</span><span class="s5">1</span><span class="s1">] - path_cpls[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s1">(sx0</span><span class="s2">, </span><span class="s1">sx1)</span><span class="s2">, </span><span class="s1">(sy0</span><span class="s2">, </span><span class="s1">sy1) = interp_vec(target_cpls</span><span class="s2">, </span><span class="s1">path_cpls</span><span class="s2">, </span><span class="s1">screen_xys)</span>
        <span class="s1">angle = np.rad2deg(np.arctan2(sy1 - sy0</span><span class="s2">, </span><span class="s1">sx1 - sx0))  </span><span class="s4"># Screen space.</span>
        <span class="s2">if </span><span class="s1">self.rightside_up:  </span><span class="s4"># Fix angle so text is never upside-down</span>
            <span class="s1">angle = (angle + </span><span class="s5">90</span><span class="s1">) % </span><span class="s5">180 </span><span class="s1">- </span><span class="s5">90</span>

        <span class="s1">target_cpls += [-spacing</span><span class="s2">, </span><span class="s1">+spacing]  </span><span class="s4"># Expand range by spacing.</span>

        <span class="s4"># Get indices near points of interest; use -1 as out of bounds marker.</span>
        <span class="s1">i0</span><span class="s2">, </span><span class="s1">i1 = np.interp(target_cpls</span><span class="s2">, </span><span class="s1">path_cpls</span><span class="s2">, </span><span class="s1">range(len(path_cpls))</span><span class="s2">,</span>
                           <span class="s1">left=-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">right=-</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">i0 = math.floor(i0)</span>
        <span class="s1">i1 = math.ceil(i1)</span>
        <span class="s1">(x0</span><span class="s2">, </span><span class="s1">x1)</span><span class="s2">, </span><span class="s1">(y0</span><span class="s2">, </span><span class="s1">y1) = interp_vec(target_cpls</span><span class="s2">, </span><span class="s1">path_cpls</span><span class="s2">, </span><span class="s1">cc_xys)</span>

        <span class="s4"># Actually break contours (dropping zero-len parts).</span>
        <span class="s1">new_xy_blocks = []</span>
        <span class="s1">new_code_blocks = []</span>
        <span class="s2">if </span><span class="s1">is_closed_path:</span>
            <span class="s2">if </span><span class="s1">i0 != -</span><span class="s5">1 </span><span class="s2">and </span><span class="s1">i1 != -</span><span class="s5">1</span><span class="s1">:</span>
                <span class="s4"># This is probably wrong in the case that the entire contour would</span>
                <span class="s4"># be discarded, but ensures that a valid path is returned and is</span>
                <span class="s4"># consistent with behavior of mpl &lt;3.8</span>
                <span class="s1">points = cc_xys[i1:i0+</span><span class="s5">1</span><span class="s1">]</span>
                <span class="s1">new_xy_blocks.extend([[(x1</span><span class="s2">, </span><span class="s1">y1)]</span><span class="s2">, </span><span class="s1">points</span><span class="s2">, </span><span class="s1">[(x0</span><span class="s2">, </span><span class="s1">y0)]])</span>
                <span class="s1">nlines = len(points) + </span><span class="s5">1</span>
                <span class="s1">new_code_blocks.extend([[Path.MOVETO]</span><span class="s2">, </span><span class="s1">[Path.LINETO] * nlines])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">i0 != -</span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">new_xy_blocks.extend([cc_xys[:i0 + </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[(x0</span><span class="s2">, </span><span class="s1">y0)]])</span>
                <span class="s1">new_code_blocks.extend([[Path.MOVETO]</span><span class="s2">, </span><span class="s1">[Path.LINETO] * (i0 + </span><span class="s5">1</span><span class="s1">)])</span>
            <span class="s2">if </span><span class="s1">i1 != -</span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">new_xy_blocks.extend([[(x1</span><span class="s2">, </span><span class="s1">y1)]</span><span class="s2">, </span><span class="s1">cc_xys[i1:]])</span>
                <span class="s1">new_code_blocks.extend([</span>
                    <span class="s1">[Path.MOVETO]</span><span class="s2">, </span><span class="s1">[Path.LINETO] * (len(cc_xys) - i1)])</span>

        <span class="s4"># Back to the full path.</span>
        <span class="s1">xys = np.concatenate([xys[:start]</span><span class="s2">, </span><span class="s1">*new_xy_blocks</span><span class="s2">, </span><span class="s1">xys[stop:]])</span>
        <span class="s1">codes = np.concatenate([codes[:start]</span><span class="s2">, </span><span class="s1">*new_code_blocks</span><span class="s2">, </span><span class="s1">codes[stop:]])</span>

        <span class="s2">return </span><span class="s1">angle</span><span class="s2">, </span><span class="s1">Path(xys</span><span class="s2">, </span><span class="s1">codes)</span>

    <span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.8&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">calc_label_rot_and_inline(self</span><span class="s2">, </span><span class="s1">slc</span><span class="s2">, </span><span class="s1">ind</span><span class="s2">, </span><span class="s1">lw</span><span class="s2">, </span><span class="s1">lc=</span><span class="s2">None, </span><span class="s1">spacing=</span><span class="s5">5</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Calculate the appropriate label rotation given the linecontour 
        coordinates in screen units, the index of the label location and the 
        label width. 
 
        If *lc* is not None or empty, also break contours and compute 
        inlining. 
 
        *spacing* is the empty space to leave around the label, in pixels. 
 
        Both tasks are done together to avoid calculating path lengths 
        multiple times, which is relatively costly. 
 
        The method used here involves computing the path length along the 
        contour in pixel coordinates and then looking approximately (label 
        width / 2) away from central point to determine rotation and then to 
        break contour if desired. 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">lc </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">lc = []</span>
        <span class="s4"># Half the label width</span>
        <span class="s1">hlw = lw / </span><span class="s5">2.0</span>

        <span class="s4"># Check if closed and, if so, rotate contour so label is at edge</span>
        <span class="s1">closed = _is_closed_polygon(slc)</span>
        <span class="s2">if </span><span class="s1">closed:</span>
            <span class="s1">slc = np.concatenate([slc[ind:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">slc[:ind + </span><span class="s5">1</span><span class="s1">]])</span>
            <span class="s2">if </span><span class="s1">len(lc):  </span><span class="s4"># Rotate lc also if not empty</span>
                <span class="s1">lc = np.concatenate([lc[ind:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">lc[:ind + </span><span class="s5">1</span><span class="s1">]])</span>
            <span class="s1">ind = </span><span class="s5">0</span>

        <span class="s4"># Calculate path lengths</span>
        <span class="s1">pl = np.zeros(slc.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=float)</span>
        <span class="s1">dx = np.diff(slc</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">pl[</span><span class="s5">1</span><span class="s1">:] = np.cumsum(np.hypot(dx[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dx[:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]))</span>
        <span class="s1">pl = pl - pl[ind]</span>

        <span class="s4"># Use linear interpolation to get points around label</span>
        <span class="s1">xi = np.array([-hlw</span><span class="s2">, </span><span class="s1">hlw])</span>
        <span class="s2">if </span><span class="s1">closed:  </span><span class="s4"># Look at end also for closed contours</span>
            <span class="s1">dp = np.array([pl[-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s5">0</span><span class="s1">])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">dp = np.zeros_like(xi)</span>

        <span class="s4"># Get angle of vector between the two ends of the label - must be</span>
        <span class="s4"># calculated in pixel space for text rotation to work correctly.</span>
        <span class="s1">(dx</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(dy</span><span class="s2">,</span><span class="s1">) = (np.diff(np.interp(dp + xi</span><span class="s2">, </span><span class="s1">pl</span><span class="s2">, </span><span class="s1">slc_col))</span>
                        <span class="s2">for </span><span class="s1">slc_col </span><span class="s2">in </span><span class="s1">slc.T)</span>
        <span class="s1">rotation = np.rad2deg(np.arctan2(dy</span><span class="s2">, </span><span class="s1">dx))</span>

        <span class="s2">if </span><span class="s1">self.rightside_up:</span>
            <span class="s4"># Fix angle so text is never upside-down</span>
            <span class="s1">rotation = (rotation + </span><span class="s5">90</span><span class="s1">) % </span><span class="s5">180 </span><span class="s1">- </span><span class="s5">90</span>

        <span class="s4"># Break contour if desired</span>
        <span class="s1">nlc = []</span>
        <span class="s2">if </span><span class="s1">len(lc):</span>
            <span class="s4"># Expand range by spacing</span>
            <span class="s1">xi = dp + xi + np.array([-spacing</span><span class="s2">, </span><span class="s1">spacing])</span>

            <span class="s4"># Get (integer) indices near points of interest; use -1 as marker</span>
            <span class="s4"># for out of bounds.</span>
            <span class="s1">I = np.interp(xi</span><span class="s2">, </span><span class="s1">pl</span><span class="s2">, </span><span class="s1">np.arange(len(pl))</span><span class="s2">, </span><span class="s1">left=-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">right=-</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">I = [np.floor(I[</span><span class="s5">0</span><span class="s1">]).astype(int)</span><span class="s2">, </span><span class="s1">np.ceil(I[</span><span class="s5">1</span><span class="s1">]).astype(int)]</span>
            <span class="s2">if </span><span class="s1">I[</span><span class="s5">0</span><span class="s1">] != -</span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">xy1 = [np.interp(xi[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pl</span><span class="s2">, </span><span class="s1">lc_col) </span><span class="s2">for </span><span class="s1">lc_col </span><span class="s2">in </span><span class="s1">lc.T]</span>
            <span class="s2">if </span><span class="s1">I[</span><span class="s5">1</span><span class="s1">] != -</span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">xy2 = [np.interp(xi[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pl</span><span class="s2">, </span><span class="s1">lc_col) </span><span class="s2">for </span><span class="s1">lc_col </span><span class="s2">in </span><span class="s1">lc.T]</span>

            <span class="s4"># Actually break contours</span>
            <span class="s2">if </span><span class="s1">closed:</span>
                <span class="s4"># This will remove contour if shorter than label</span>
                <span class="s2">if </span><span class="s1">all(i != -</span><span class="s5">1 </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">I):</span>
                    <span class="s1">nlc.append(np.vstack([xy2</span><span class="s2">, </span><span class="s1">lc[I[</span><span class="s5">1</span><span class="s1">]:I[</span><span class="s5">0</span><span class="s1">]+</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">xy1]))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s4"># These will remove pieces of contour if they have length zero</span>
                <span class="s2">if </span><span class="s1">I[</span><span class="s5">0</span><span class="s1">] != -</span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">nlc.append(np.vstack([lc[:I[</span><span class="s5">0</span><span class="s1">]+</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">xy1]))</span>
                <span class="s2">if </span><span class="s1">I[</span><span class="s5">1</span><span class="s1">] != -</span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">nlc.append(np.vstack([xy2</span><span class="s2">, </span><span class="s1">lc[I[</span><span class="s5">1</span><span class="s1">]:]]))</span>

            <span class="s4"># The current implementation removes contours completely</span>
            <span class="s4"># covered by labels.  Uncomment line below to keep</span>
            <span class="s4"># original contour if this is the preferred behavior.</span>
            <span class="s4"># if not len(nlc): nlc = [lc]</span>

        <span class="s2">return </span><span class="s1">rotation</span><span class="s2">, </span><span class="s1">nlc</span>

    <span class="s2">def </span><span class="s1">add_label(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">rotation</span><span class="s2">, </span><span class="s1">lev</span><span class="s2">, </span><span class="s1">cvalue):</span>
        <span class="s0">&quot;&quot;&quot;Add contour label without `.Text.set_transform_rotates_text`.&quot;&quot;&quot;</span>
        <span class="s1">data_x</span><span class="s2">, </span><span class="s1">data_y = self.axes.transData.inverted().transform((x</span><span class="s2">, </span><span class="s1">y))</span>
        <span class="s1">t = Text(</span>
            <span class="s1">data_x</span><span class="s2">, </span><span class="s1">data_y</span><span class="s2">,</span>
            <span class="s1">text=self.get_text(lev</span><span class="s2">, </span><span class="s1">self.labelFmt)</span><span class="s2">,</span>
            <span class="s1">rotation=rotation</span><span class="s2">,</span>
            <span class="s1">horizontalalignment=</span><span class="s3">'center'</span><span class="s2">, </span><span class="s1">verticalalignment=</span><span class="s3">'center'</span><span class="s2">,</span>
            <span class="s1">zorder=self._clabel_zorder</span><span class="s2">,</span>
            <span class="s1">color=self.labelMappable.to_rgba(cvalue</span><span class="s2">, </span><span class="s1">alpha=self.get_alpha())</span><span class="s2">,</span>
            <span class="s1">fontproperties=self._label_font_props</span><span class="s2">,</span>
            <span class="s1">clip_box=self.axes.bbox)</span>
        <span class="s1">self.labelTexts.append(t)</span>
        <span class="s1">self.labelCValues.append(cvalue)</span>
        <span class="s1">self.labelXYs.append((x</span><span class="s2">, </span><span class="s1">y))</span>
        <span class="s4"># Add label to plot here - useful for manual mode label selection</span>
        <span class="s1">self.axes.add_artist(t)</span>

    <span class="s2">def </span><span class="s1">add_label_clabeltext(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">rotation</span><span class="s2">, </span><span class="s1">lev</span><span class="s2">, </span><span class="s1">cvalue):</span>
        <span class="s0">&quot;&quot;&quot;Add contour label with `.Text.set_transform_rotates_text`.&quot;&quot;&quot;</span>
        <span class="s1">self.add_label(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">rotation</span><span class="s2">, </span><span class="s1">lev</span><span class="s2">, </span><span class="s1">cvalue)</span>
        <span class="s4"># Grab the last added text, and reconfigure its rotation.</span>
        <span class="s1">t = self.labelTexts[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">data_rotation</span><span class="s2">, </span><span class="s1">= self.axes.transData.inverted().transform_angles(</span>
            <span class="s1">[rotation]</span><span class="s2">, </span><span class="s1">[[x</span><span class="s2">, </span><span class="s1">y]])</span>
        <span class="s1">t.set(rotation=data_rotation</span><span class="s2">, </span><span class="s1">transform_rotates_text=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">add_label_near(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">inline=</span><span class="s2">True, </span><span class="s1">inline_spacing=</span><span class="s5">5</span><span class="s2">,</span>
                       <span class="s1">transform=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add a label near the point ``(x, y)``. 
 
        Parameters 
        ---------- 
        x, y : float 
            The approximate location of the label. 
        inline : bool, default: True 
            If *True* remove the segment of the contour beneath the label. 
        inline_spacing : int, default: 5 
            Space in pixels to leave on each side of label when placing 
            inline. This spacing will be exact for labels at locations where 
            the contour is straight, less so for labels on curved contours. 
        transform : `.Transform` or `False`, default: ``self.axes.transData`` 
            A transform applied to ``(x, y)`` before labeling.  The default 
            causes ``(x, y)`` to be interpreted as data coordinates.  `False` 
            is a synonym for `.IdentityTransform`; i.e. ``(x, y)`` should be 
            interpreted as display coordinates. 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">transform </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">transform = self.axes.transData</span>
        <span class="s2">if </span><span class="s1">transform:</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">y = transform.transform((x</span><span class="s2">, </span><span class="s1">y))</span>

        <span class="s1">idx_level_min</span><span class="s2">, </span><span class="s1">idx_vtx_min</span><span class="s2">, </span><span class="s1">proj = self._find_nearest_contour(</span>
            <span class="s1">(x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">, </span><span class="s1">self.labelIndiceList)</span>
        <span class="s1">path = self._paths[idx_level_min]</span>
        <span class="s1">level = self.labelIndiceList.index(idx_level_min)</span>
        <span class="s1">label_width = self._get_nth_label_width(level)</span>
        <span class="s1">rotation</span><span class="s2">, </span><span class="s1">path = self._split_path_and_get_label_rotation(</span>
            <span class="s1">path</span><span class="s2">, </span><span class="s1">idx_vtx_min</span><span class="s2">, </span><span class="s1">proj</span><span class="s2">, </span><span class="s1">label_width</span><span class="s2">, </span><span class="s1">inline_spacing)</span>
        <span class="s1">self.add_label(*proj</span><span class="s2">, </span><span class="s1">rotation</span><span class="s2">, </span><span class="s1">self.labelLevelList[idx_level_min]</span><span class="s2">,</span>
                       <span class="s1">self.labelCValueList[idx_level_min])</span>

        <span class="s2">if </span><span class="s1">inline:</span>
            <span class="s1">self._paths[idx_level_min] = path</span>

    <span class="s2">def </span><span class="s1">pop_label(self</span><span class="s2">, </span><span class="s1">index=-</span><span class="s5">1</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Defaults to removing last label, but any index can be supplied&quot;&quot;&quot;</span>
        <span class="s1">self.labelCValues.pop(index)</span>
        <span class="s1">t = self.labelTexts.pop(index)</span>
        <span class="s1">t.remove()</span>

    <span class="s2">def </span><span class="s1">labels(self</span><span class="s2">, </span><span class="s1">inline</span><span class="s2">, </span><span class="s1">inline_spacing):</span>

        <span class="s2">if </span><span class="s1">self._use_clabeltext:</span>
            <span class="s1">add_label = self.add_label_clabeltext</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">add_label = self.add_label</span>

        <span class="s2">for </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">(icon</span><span class="s2">, </span><span class="s1">lev</span><span class="s2">, </span><span class="s1">cvalue) </span><span class="s2">in </span><span class="s1">enumerate(zip(</span>
                <span class="s1">self.labelIndiceList</span><span class="s2">,</span>
                <span class="s1">self.labelLevelList</span><span class="s2">,</span>
                <span class="s1">self.labelCValueList</span><span class="s2">,</span>
        <span class="s1">)):</span>
            <span class="s1">trans = self.get_transform()</span>
            <span class="s1">label_width = self._get_nth_label_width(idx)</span>
            <span class="s1">additions = []</span>
            <span class="s2">for </span><span class="s1">subpath </span><span class="s2">in </span><span class="s1">self._paths[icon]._iter_connected_components():</span>
                <span class="s1">screen_xys = trans.transform(subpath.vertices)</span>
                <span class="s4"># Check if long enough for a label</span>
                <span class="s2">if </span><span class="s1">self.print_label(screen_xys</span><span class="s2">, </span><span class="s1">label_width):</span>
                    <span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">idx = self.locate_label(screen_xys</span><span class="s2">, </span><span class="s1">label_width)</span>
                    <span class="s1">rotation</span><span class="s2">, </span><span class="s1">path = self._split_path_and_get_label_rotation(</span>
                        <span class="s1">subpath</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">(x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">,</span>
                        <span class="s1">label_width</span><span class="s2">, </span><span class="s1">inline_spacing)</span>
                    <span class="s1">add_label(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">rotation</span><span class="s2">, </span><span class="s1">lev</span><span class="s2">, </span><span class="s1">cvalue)  </span><span class="s4"># Really add label.</span>
                    <span class="s2">if </span><span class="s1">inline:  </span><span class="s4"># If inline, add new contours</span>
                        <span class="s1">additions.append(path)</span>
                <span class="s2">else</span><span class="s1">:  </span><span class="s4"># If not adding label, keep old path</span>
                    <span class="s1">additions.append(subpath)</span>
            <span class="s4"># After looping over all segments on a contour, replace old path by new one</span>
            <span class="s4"># if inlining.</span>
            <span class="s2">if </span><span class="s1">inline:</span>
                <span class="s1">self._paths[icon] = Path.make_compound_path(*additions)</span>

    <span class="s2">def </span><span class="s1">remove(self):</span>
        <span class="s1">super().remove()</span>
        <span class="s2">for </span><span class="s1">text </span><span class="s2">in </span><span class="s1">self.labelTexts:</span>
            <span class="s1">text.remove()</span>


<span class="s2">def </span><span class="s1">_is_closed_polygon(X):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return whether first and last object in a sequence are the same. These are 
    presumably coordinates on a polygonal curve, in which case this function 
    tests if that curve is closed. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">np.allclose(X[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">X[-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-10</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-13</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_find_closest_point_on_path(xys</span><span class="s2">, </span><span class="s1">p):</span>
    <span class="s0">&quot;&quot;&quot; 
    Parameters 
    ---------- 
    xys : (N, 2) array-like 
        Coordinates of vertices. 
    p : (float, float) 
        Coordinates of point. 
 
    Returns 
    ------- 
    d2min : float 
        Minimum square distance of *p* to *xys*. 
    proj : (float, float) 
        Projection of *p* onto *xys*. 
    imin : (int, int) 
        Consecutive indices of vertices of segment in *xys* where *proj* is. 
        Segments are considered as including their end-points; i.e. if the 
        closest point on the path is a node in *xys* with index *i*, this 
        returns ``(i-1, i)``.  For the special case where *xys* is a single 
        point, this returns ``(0, 0)``. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">len(xys) == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">(((p - xys[</span><span class="s5">0</span><span class="s1">]) ** </span><span class="s5">2</span><span class="s1">).sum()</span><span class="s2">, </span><span class="s1">xys[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span>
    <span class="s1">dxys = xys[</span><span class="s5">1</span><span class="s1">:] - xys[:-</span><span class="s5">1</span><span class="s1">]  </span><span class="s4"># Individual segment vectors.</span>
    <span class="s1">norms = (dxys ** </span><span class="s5">2</span><span class="s1">).sum(axis=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">norms[norms == </span><span class="s5">0</span><span class="s1">] = </span><span class="s5">1  </span><span class="s4"># For zero-length segment, replace 0/0 by 0/1.</span>
    <span class="s1">rel_projs = np.clip(  </span><span class="s4"># Project onto each segment in relative 0-1 coords.</span>
        <span class="s1">((p - xys[:-</span><span class="s5">1</span><span class="s1">]) * dxys).sum(axis=</span><span class="s5">1</span><span class="s1">) / norms</span><span class="s2">,</span>
        <span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)[:</span><span class="s2">, None</span><span class="s1">]</span>
    <span class="s1">projs = xys[:-</span><span class="s5">1</span><span class="s1">] + rel_projs * dxys  </span><span class="s4"># Projs. onto each segment, in (x, y).</span>
    <span class="s1">d2s = ((projs - p) ** </span><span class="s5">2</span><span class="s1">).sum(axis=</span><span class="s5">1</span><span class="s1">)  </span><span class="s4"># Squared distances.</span>
    <span class="s1">imin = np.argmin(d2s)</span>
    <span class="s2">return </span><span class="s1">(d2s[imin]</span><span class="s2">, </span><span class="s1">projs[imin]</span><span class="s2">, </span><span class="s1">(imin</span><span class="s2">, </span><span class="s1">imin+</span><span class="s5">1</span><span class="s1">))</span>


<span class="s1">_docstring.interpd.update(contour_set_attributes=</span><span class="s3">r&quot;&quot;&quot; 
Attributes 
---------- 
ax : `~matplotlib.axes.Axes` 
    The Axes object in which the contours are drawn. 
 
collections : `.silent_list` of `.PathCollection`\s 
    The `.Artist`\s representing the contour. This is a list of 
    `.PathCollection`\s for both line and filled contours. 
 
levels : array 
    The values of the contour levels. 
 
layers : array 
    Same as levels for line contours; half-way between 
    levels for filled contours.  See ``ContourSet._process_colors``. 
&quot;&quot;&quot;</span><span class="s1">)</span>


<span class="s1">@_docstring.dedent_interpd</span>
<span class="s2">class </span><span class="s1">ContourSet(ContourLabeler</span><span class="s2">, </span><span class="s1">mcoll.Collection):</span>
    <span class="s0">&quot;&quot;&quot; 
    Store a set of contour lines or filled regions. 
 
    User-callable method: `~.Axes.clabel` 
 
    Parameters 
    ---------- 
    ax : `~matplotlib.axes.Axes` 
 
    levels : [level0, level1, ..., leveln] 
        A list of floating point numbers indicating the contour levels. 
 
    allsegs : [level0segs, level1segs, ...] 
        List of all the polygon segments for all the *levels*. 
        For contour lines ``len(allsegs) == len(levels)``, and for 
        filled contour regions ``len(allsegs) = len(levels)-1``. The lists 
        should look like :: 
 
            level0segs = [polygon0, polygon1, ...] 
            polygon0 = [[x0, y0], [x1, y1], ...] 
 
    allkinds : ``None`` or [level0kinds, level1kinds, ...] 
        Optional list of all the polygon vertex kinds (code types), as 
        described and used in Path. This is used to allow multiply- 
        connected paths such as holes within filled polygons. 
        If not ``None``, ``len(allkinds) == len(allsegs)``. The lists 
        should look like :: 
 
            level0kinds = [polygon0kinds, ...] 
            polygon0kinds = [vertexcode0, vertexcode1, ...] 
 
        If *allkinds* is not ``None``, usually all polygons for a 
        particular contour level are grouped together so that 
        ``level0segs = [polygon0]`` and ``level0kinds = [polygon0kinds]``. 
 
    **kwargs 
        Keyword arguments are as described in the docstring of 
        `~.Axes.contour`. 
 
    %(contour_set_attributes)s 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">,</span>
                 <span class="s1">levels=</span><span class="s2">None, </span><span class="s1">filled=</span><span class="s2">False, </span><span class="s1">linewidths=</span><span class="s2">None, </span><span class="s1">linestyles=</span><span class="s2">None,</span>
                 <span class="s1">hatches=(</span><span class="s2">None,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s2">None, </span><span class="s1">origin=</span><span class="s2">None, </span><span class="s1">extent=</span><span class="s2">None,</span>
                 <span class="s1">cmap=</span><span class="s2">None, </span><span class="s1">colors=</span><span class="s2">None, </span><span class="s1">norm=</span><span class="s2">None, </span><span class="s1">vmin=</span><span class="s2">None, </span><span class="s1">vmax=</span><span class="s2">None,</span>
                 <span class="s1">extend=</span><span class="s3">'neither'</span><span class="s2">, </span><span class="s1">antialiased=</span><span class="s2">None, </span><span class="s1">nchunk=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">locator=</span><span class="s2">None,</span>
                 <span class="s1">transform=</span><span class="s2">None, </span><span class="s1">negative_linestyles=</span><span class="s2">None, </span><span class="s1">clip_path=</span><span class="s2">None,</span>
                 <span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Draw contour lines or filled regions, depending on 
        whether keyword arg *filled* is ``False`` (default) or ``True``. 
 
        Call signature:: 
 
            ContourSet(ax, levels, allsegs, [allkinds], **kwargs) 
 
        Parameters 
        ---------- 
        ax : `~matplotlib.axes.Axes` 
            The `~.axes.Axes` object to draw on. 
 
        levels : [level0, level1, ..., leveln] 
            A list of floating point numbers indicating the contour 
            levels. 
 
        allsegs : [level0segs, level1segs, ...] 
            List of all the polygon segments for all the *levels*. 
            For contour lines ``len(allsegs) == len(levels)``, and for 
            filled contour regions ``len(allsegs) = len(levels)-1``. The lists 
            should look like :: 
 
                level0segs = [polygon0, polygon1, ...] 
                polygon0 = [[x0, y0], [x1, y1], ...] 
 
        allkinds : [level0kinds, level1kinds, ...], optional 
            Optional list of all the polygon vertex kinds (code types), as 
            described and used in Path. This is used to allow multiply- 
            connected paths such as holes within filled polygons. 
            If not ``None``, ``len(allkinds) == len(allsegs)``. The lists 
            should look like :: 
 
                level0kinds = [polygon0kinds, ...] 
                polygon0kinds = [vertexcode0, vertexcode1, ...] 
 
            If *allkinds* is not ``None``, usually all polygons for a 
            particular contour level are grouped together so that 
            ``level0segs = [polygon0]`` and ``level0kinds = [polygon0kinds]``. 
 
        **kwargs 
            Keyword arguments are as described in the docstring of 
            `~.Axes.contour`. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">antialiased </span><span class="s2">is None and </span><span class="s1">filled:</span>
            <span class="s4"># Eliminate artifacts; we are not stroking the boundaries.</span>
            <span class="s1">antialiased = </span><span class="s2">False</span>
            <span class="s4"># The default for line contours will be taken from the</span>
            <span class="s4"># LineCollection default, which uses :rc:`lines.antialiased`.</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">antialiaseds=antialiased</span><span class="s2">,</span>
            <span class="s1">alpha=alpha</span><span class="s2">,</span>
            <span class="s1">clip_path=clip_path</span><span class="s2">,</span>
            <span class="s1">transform=transform</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">self.axes = ax</span>
        <span class="s1">self.levels = levels</span>
        <span class="s1">self.filled = filled</span>
        <span class="s1">self.hatches = hatches</span>
        <span class="s1">self.origin = origin</span>
        <span class="s1">self.extent = extent</span>
        <span class="s1">self.colors = colors</span>
        <span class="s1">self.extend = extend</span>

        <span class="s1">self.nchunk = nchunk</span>
        <span class="s1">self.locator = locator</span>
        <span class="s2">if </span><span class="s1">(isinstance(norm</span><span class="s2">, </span><span class="s1">mcolors.LogNorm)</span>
                <span class="s2">or </span><span class="s1">isinstance(self.locator</span><span class="s2">, </span><span class="s1">ticker.LogLocator)):</span>
            <span class="s1">self.logscale = </span><span class="s2">True</span>
            <span class="s2">if </span><span class="s1">norm </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">norm = mcolors.LogNorm()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.logscale = </span><span class="s2">False</span>

        <span class="s1">_api.check_in_list([</span><span class="s2">None, </span><span class="s3">'lower'</span><span class="s2">, </span><span class="s3">'upper'</span><span class="s2">, </span><span class="s3">'image'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">origin=origin)</span>
        <span class="s2">if </span><span class="s1">self.extent </span><span class="s2">is not None and </span><span class="s1">len(self.extent) != </span><span class="s5">4</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;If given, 'extent' must be None or (x0, x1, y0, y1)&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.colors </span><span class="s2">is not None and </span><span class="s1">cmap </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'Either colors or cmap must be None'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.origin == </span><span class="s3">'image'</span><span class="s1">:</span>
            <span class="s1">self.origin = mpl.rcParams[</span><span class="s3">'image.origin'</span><span class="s1">]</span>

        <span class="s1">self._orig_linestyles = linestyles  </span><span class="s4"># Only kept for user access.</span>
        <span class="s1">self.negative_linestyles = negative_linestyles</span>
        <span class="s4"># If negative_linestyles was not defined as a keyword argument, define</span>
        <span class="s4"># negative_linestyles with rcParams</span>
        <span class="s2">if </span><span class="s1">self.negative_linestyles </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.negative_linestyles = \</span>
                <span class="s1">mpl.rcParams[</span><span class="s3">'contour.negative_linestyle'</span><span class="s1">]</span>

        <span class="s1">kwargs = self._process_args(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self._process_levels()</span>

        <span class="s1">self._extend_min = self.extend </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'min'</span><span class="s2">, </span><span class="s3">'both'</span><span class="s1">]</span>
        <span class="s1">self._extend_max = self.extend </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'max'</span><span class="s2">, </span><span class="s3">'both'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self.colors </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">ncolors = len(self.levels)</span>
            <span class="s2">if </span><span class="s1">self.filled:</span>
                <span class="s1">ncolors -= </span><span class="s5">1</span>
            <span class="s1">i0 = </span><span class="s5">0</span>

            <span class="s4"># Handle the case where colors are given for the extended</span>
            <span class="s4"># parts of the contour.</span>

            <span class="s1">use_set_under_over = </span><span class="s2">False</span>
            <span class="s4"># if we are extending the lower end, and we've been given enough</span>
            <span class="s4"># colors then skip the first color in the resulting cmap. For the</span>
            <span class="s4"># extend_max case we don't need to worry about passing more colors</span>
            <span class="s4"># than ncolors as ListedColormap will clip.</span>
            <span class="s1">total_levels = (ncolors +</span>
                            <span class="s1">int(self._extend_min) +</span>
                            <span class="s1">int(self._extend_max))</span>
            <span class="s2">if </span><span class="s1">(len(self.colors) == total_levels </span><span class="s2">and</span>
                    <span class="s1">(self._extend_min </span><span class="s2">or </span><span class="s1">self._extend_max)):</span>
                <span class="s1">use_set_under_over = </span><span class="s2">True</span>
                <span class="s2">if </span><span class="s1">self._extend_min:</span>
                    <span class="s1">i0 = </span><span class="s5">1</span>

            <span class="s1">cmap = mcolors.ListedColormap(self.colors[i0:</span><span class="s2">None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">N=ncolors)</span>

            <span class="s2">if </span><span class="s1">use_set_under_over:</span>
                <span class="s2">if </span><span class="s1">self._extend_min:</span>
                    <span class="s1">cmap.set_under(self.colors[</span><span class="s5">0</span><span class="s1">])</span>
                <span class="s2">if </span><span class="s1">self._extend_max:</span>
                    <span class="s1">cmap.set_over(self.colors[-</span><span class="s5">1</span><span class="s1">])</span>

        <span class="s4"># label lists must be initialized here</span>
        <span class="s1">self.labelTexts = []</span>
        <span class="s1">self.labelCValues = []</span>

        <span class="s1">self.set_cmap(cmap)</span>
        <span class="s2">if </span><span class="s1">norm </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.set_norm(norm)</span>
        <span class="s2">with </span><span class="s1">self.norm.callbacks.blocked(signal=</span><span class="s3">&quot;changed&quot;</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">vmin </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">self.norm.vmin = vmin</span>
            <span class="s2">if </span><span class="s1">vmax </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">self.norm.vmax = vmax</span>
        <span class="s1">self.norm._changed()</span>
        <span class="s1">self._process_colors()</span>

        <span class="s2">if </span><span class="s1">self._paths </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._paths = self._make_paths_from_contour_generator()</span>

        <span class="s2">if </span><span class="s1">self.filled:</span>
            <span class="s2">if </span><span class="s1">linewidths </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">_api.warn_external(</span><span class="s3">'linewidths is ignored by contourf'</span><span class="s1">)</span>
            <span class="s4"># Lower and upper contour levels.</span>
            <span class="s1">lowers</span><span class="s2">, </span><span class="s1">uppers = self._get_lowers_and_uppers()</span>
            <span class="s1">self.set(</span>
                <span class="s1">edgecolor=</span><span class="s3">&quot;none&quot;</span><span class="s2">,</span>
                <span class="s4"># Default zorder taken from Collection</span>
                <span class="s1">zorder=kwargs.pop(</span><span class="s3">&quot;zorder&quot;</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.set(</span>
                <span class="s1">facecolor=</span><span class="s3">&quot;none&quot;</span><span class="s2">,</span>
                <span class="s1">linewidths=self._process_linewidths(linewidths)</span><span class="s2">,</span>
                <span class="s1">linestyle=self._process_linestyles(linestyles)</span><span class="s2">,</span>
                <span class="s4"># Default zorder taken from LineCollection, which is higher</span>
                <span class="s4"># than for filled contours so that lines are displayed on top.</span>
                <span class="s1">zorder=kwargs.pop(</span><span class="s3">&quot;zorder&quot;</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">label=</span><span class="s3">&quot;_nolegend_&quot;</span><span class="s2">,</span>
            <span class="s1">)</span>

        <span class="s1">self.axes.add_collection(self</span><span class="s2">, </span><span class="s1">autolim=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">self.sticky_edges.x[:] = [self._mins[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self._maxs[</span><span class="s5">0</span><span class="s1">]]</span>
        <span class="s1">self.sticky_edges.y[:] = [self._mins[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self._maxs[</span><span class="s5">1</span><span class="s1">]]</span>
        <span class="s1">self.axes.update_datalim([self._mins</span><span class="s2">, </span><span class="s1">self._maxs])</span>
        <span class="s1">self.axes.autoscale_view(tight=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s1">self.changed()  </span><span class="s4"># set the colors</span>

        <span class="s2">if </span><span class="s1">kwargs:</span>
            <span class="s1">_api.warn_external(</span>
                <span class="s3">'The following kwargs were not used by contour: ' </span><span class="s1">+</span>
                <span class="s3">&quot;, &quot;</span><span class="s1">.join(map(repr</span><span class="s2">, </span><span class="s1">kwargs))</span>
            <span class="s1">)</span>

    <span class="s1">allsegs = property(</span><span class="s2">lambda </span><span class="s1">self: [</span>
        <span class="s1">[subp.vertices </span><span class="s2">for </span><span class="s1">subp </span><span class="s2">in </span><span class="s1">p._iter_connected_components()]</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self.get_paths()])</span>
    <span class="s1">allkinds = property(</span><span class="s2">lambda </span><span class="s1">self: [</span>
        <span class="s1">[subp.codes </span><span class="s2">for </span><span class="s1">subp </span><span class="s2">in </span><span class="s1">p._iter_connected_components()]</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self.get_paths()])</span>
    <span class="s1">tcolors = _api.deprecated(</span><span class="s3">&quot;3.8&quot;</span><span class="s1">)(property(</span><span class="s2">lambda </span><span class="s1">self: [</span>
        <span class="s1">(tuple(rgba)</span><span class="s2">,</span><span class="s1">) </span><span class="s2">for </span><span class="s1">rgba </span><span class="s2">in </span><span class="s1">self.to_rgba(self.cvalues</span><span class="s2">, </span><span class="s1">self.alpha)]))</span>
    <span class="s1">tlinewidths = _api.deprecated(</span><span class="s3">&quot;3.8&quot;</span><span class="s1">)(property(</span><span class="s2">lambda </span><span class="s1">self: [</span>
        <span class="s1">(w</span><span class="s2">,</span><span class="s1">) </span><span class="s2">for </span><span class="s1">w </span><span class="s2">in </span><span class="s1">self.get_linewidths()]))</span>
    <span class="s1">alpha = property(</span><span class="s2">lambda </span><span class="s1">self: self.get_alpha())</span>
    <span class="s1">linestyles = property(</span><span class="s2">lambda </span><span class="s1">self: self._orig_linestyles)</span>

    <span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.8&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">&quot;set_antialiased or get_antialiased&quot;</span><span class="s2">,</span>
                     <span class="s1">addendum=</span><span class="s3">&quot;Note that get_antialiased returns an array.&quot;</span><span class="s1">)</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">antialiased(self):</span>
        <span class="s2">return </span><span class="s1">all(self.get_antialiased())</span>

    <span class="s1">@antialiased.setter</span>
    <span class="s2">def </span><span class="s1">antialiased(self</span><span class="s2">, </span><span class="s1">aa):</span>
        <span class="s1">self.set_antialiased(aa)</span>

    <span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.8&quot;</span><span class="s1">)</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">collections(self):</span>
        <span class="s4"># On access, make oneself invisible and instead add the old-style collections</span>
        <span class="s4"># (one PathCollection per level).  We do not try to further split contours into</span>
        <span class="s4"># connected components as we already lost track of what pairs of contours need</span>
        <span class="s4"># to be considered as single units to draw filled regions with holes.</span>
        <span class="s2">if not </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s3">&quot;_old_style_split_collections&quot;</span><span class="s1">):</span>
            <span class="s1">self.set_visible(</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s1">fcs = self.get_facecolor()</span>
            <span class="s1">ecs = self.get_edgecolor()</span>
            <span class="s1">lws = self.get_linewidth()</span>
            <span class="s1">lss = self.get_linestyle()</span>
            <span class="s1">self._old_style_split_collections = []</span>
            <span class="s2">for </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">path </span><span class="s2">in </span><span class="s1">enumerate(self._paths):</span>
                <span class="s1">pc = mcoll.PathCollection(</span>
                    <span class="s1">[path] </span><span class="s2">if </span><span class="s1">len(path.vertices) </span><span class="s2">else </span><span class="s1">[]</span><span class="s2">,</span>
                    <span class="s1">alpha=self.get_alpha()</span><span class="s2">,</span>
                    <span class="s1">antialiaseds=self._antialiaseds[idx % len(self._antialiaseds)]</span><span class="s2">,</span>
                    <span class="s1">transform=self.get_transform()</span><span class="s2">,</span>
                    <span class="s1">zorder=self.get_zorder()</span><span class="s2">,</span>
                    <span class="s1">label=</span><span class="s3">&quot;_nolegend_&quot;</span><span class="s2">,</span>
                    <span class="s1">facecolor=fcs[idx] </span><span class="s2">if </span><span class="s1">len(fcs) </span><span class="s2">else </span><span class="s3">&quot;none&quot;</span><span class="s2">,</span>
                    <span class="s1">edgecolor=ecs[idx] </span><span class="s2">if </span><span class="s1">len(ecs) </span><span class="s2">else </span><span class="s3">&quot;none&quot;</span><span class="s2">,</span>
                    <span class="s1">linewidths=[lws[idx % len(lws)]]</span><span class="s2">,</span>
                    <span class="s1">linestyles=[lss[idx % len(lss)]]</span><span class="s2">,</span>
                <span class="s1">)</span>
                <span class="s2">if </span><span class="s1">self.filled:</span>
                    <span class="s1">pc.set(hatch=self.hatches[idx % len(self.hatches)])</span>
                <span class="s1">self._old_style_split_collections.append(pc)</span>
            <span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">self._old_style_split_collections:</span>
                <span class="s1">self.axes.add_collection(col)</span>
        <span class="s2">return </span><span class="s1">self._old_style_split_collections</span>

    <span class="s2">def </span><span class="s1">get_transform(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the `.Transform` instance used by this ContourSet.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._transform </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._transform = self.axes.transData</span>
        <span class="s2">elif </span><span class="s1">(</span><span class="s2">not </span><span class="s1">isinstance(self._transform</span><span class="s2">, </span><span class="s1">mtransforms.Transform)</span>
              <span class="s2">and </span><span class="s1">hasattr(self._transform</span><span class="s2">, </span><span class="s3">'_as_mpl_transform'</span><span class="s1">)):</span>
            <span class="s1">self._transform = self._transform._as_mpl_transform(self.axes)</span>
        <span class="s2">return </span><span class="s1">self._transform</span>

    <span class="s2">def </span><span class="s1">__getstate__(self):</span>
        <span class="s1">state = self.__dict__.copy()</span>
        <span class="s4"># the C object _contour_generator cannot currently be pickled. This</span>
        <span class="s4"># isn't a big issue as it is not actually used once the contour has</span>
        <span class="s4"># been calculated.</span>
        <span class="s1">state[</span><span class="s3">'_contour_generator'</span><span class="s1">] = </span><span class="s2">None</span>
        <span class="s2">return </span><span class="s1">state</span>

    <span class="s2">def </span><span class="s1">legend_elements(self</span><span class="s2">, </span><span class="s1">variable_name=</span><span class="s3">'x'</span><span class="s2">, </span><span class="s1">str_format=str):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a list of artists and labels suitable for passing through 
        to `~.Axes.legend` which represent this ContourSet. 
 
        The labels have the form &quot;0 &lt; x &lt;= 1&quot; stating the data ranges which 
        the artists represent. 
 
        Parameters 
        ---------- 
        variable_name : str 
            The string used inside the inequality used on the labels. 
        str_format : function: float -&gt; str 
            Function used to format the numbers in the labels. 
 
        Returns 
        ------- 
        artists : list[`.Artist`] 
            A list of the artists. 
        labels : list[str] 
            A list of the labels. 
        &quot;&quot;&quot;</span>
        <span class="s1">artists = []</span>
        <span class="s1">labels = []</span>

        <span class="s2">if </span><span class="s1">self.filled:</span>
            <span class="s1">lowers</span><span class="s2">, </span><span class="s1">uppers = self._get_lowers_and_uppers()</span>
            <span class="s1">n_levels = len(self._paths)</span>
            <span class="s2">for </span><span class="s1">idx </span><span class="s2">in </span><span class="s1">range(n_levels):</span>
                <span class="s1">artists.append(mpatches.Rectangle(</span>
                    <span class="s1">(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">,</span>
                    <span class="s1">facecolor=self.get_facecolor()[idx]</span><span class="s2">,</span>
                    <span class="s1">hatch=self.hatches[idx % len(self.hatches)]</span><span class="s2">,</span>
                <span class="s1">))</span>
                <span class="s1">lower = str_format(lowers[idx])</span>
                <span class="s1">upper = str_format(uppers[idx])</span>
                <span class="s2">if </span><span class="s1">idx == </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">self.extend </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'min'</span><span class="s2">, </span><span class="s3">'both'</span><span class="s1">):</span>
                    <span class="s1">labels.append(</span><span class="s3">fr'$</span><span class="s2">{</span><span class="s1">variable_name</span><span class="s2">} </span><span class="s3">\leq </span><span class="s2">{</span><span class="s1">lower</span><span class="s2">}</span><span class="s3">s$'</span><span class="s1">)</span>
                <span class="s2">elif </span><span class="s1">idx == n_levels - </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">self.extend </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'max'</span><span class="s2">, </span><span class="s3">'both'</span><span class="s1">):</span>
                    <span class="s1">labels.append(</span><span class="s3">fr'$</span><span class="s2">{</span><span class="s1">variable_name</span><span class="s2">} </span><span class="s3">&gt; </span><span class="s2">{</span><span class="s1">upper</span><span class="s2">}</span><span class="s3">s$'</span><span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">labels.append(</span><span class="s3">fr'$</span><span class="s2">{</span><span class="s1">lower</span><span class="s2">} </span><span class="s3">&lt; </span><span class="s2">{</span><span class="s1">variable_name</span><span class="s2">} </span><span class="s3">\leq </span><span class="s2">{</span><span class="s1">upper</span><span class="s2">}</span><span class="s3">$'</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">level </span><span class="s2">in </span><span class="s1">enumerate(self.levels):</span>
                <span class="s1">artists.append(Line2D(</span>
                    <span class="s1">[]</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">,</span>
                    <span class="s1">color=self.get_edgecolor()[idx]</span><span class="s2">,</span>
                    <span class="s1">linewidth=self.get_linewidths()[idx]</span><span class="s2">,</span>
                    <span class="s1">linestyle=self.get_linestyles()[idx]</span><span class="s2">,</span>
                <span class="s1">))</span>
                <span class="s1">labels.append(</span><span class="s3">fr'$</span><span class="s2">{</span><span class="s1">variable_name</span><span class="s2">} </span><span class="s3">= </span><span class="s2">{</span><span class="s1">str_format(level)</span><span class="s2">}</span><span class="s3">$'</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">artists</span><span class="s2">, </span><span class="s1">labels</span>

    <span class="s2">def </span><span class="s1">_process_args(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Process *args* and *kwargs*; override in derived classes. 
 
        Must set self.levels, self.zmin and self.zmax, and update axes limits. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.levels = args[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">allsegs = args[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">allkinds = args[</span><span class="s5">2</span><span class="s1">] </span><span class="s2">if </span><span class="s1">len(args) &gt; </span><span class="s5">2 </span><span class="s2">else None</span>
        <span class="s1">self.zmax = np.max(self.levels)</span>
        <span class="s1">self.zmin = np.min(self.levels)</span>

        <span class="s2">if </span><span class="s1">allkinds </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">allkinds = [[</span><span class="s2">None</span><span class="s1">] * len(segs) </span><span class="s2">for </span><span class="s1">segs </span><span class="s2">in </span><span class="s1">allsegs]</span>

        <span class="s4"># Check lengths of levels and allsegs.</span>
        <span class="s2">if </span><span class="s1">self.filled:</span>
            <span class="s2">if </span><span class="s1">len(allsegs) != len(self.levels) - </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'must be one less number of segments as '</span>
                                 <span class="s3">'levels'</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">len(allsegs) != len(self.levels):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'must be same number of segments as levels'</span><span class="s1">)</span>

        <span class="s4"># Check length of allkinds.</span>
        <span class="s2">if </span><span class="s1">len(allkinds) != len(allsegs):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'allkinds has different length to allsegs'</span><span class="s1">)</span>

        <span class="s4"># Determine x, y bounds and update axes data limits.</span>
        <span class="s1">flatseglist = [s </span><span class="s2">for </span><span class="s1">seg </span><span class="s2">in </span><span class="s1">allsegs </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">seg]</span>
        <span class="s1">points = np.concatenate(flatseglist</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">self._mins = points.min(axis=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">self._maxs = points.max(axis=</span><span class="s5">0</span><span class="s1">)</span>

        <span class="s4"># Each entry in (allsegs, allkinds) is a list of (segs, kinds): segs is a list</span>
        <span class="s4"># of (N, 2) arrays of xy coordinates, kinds is a list of arrays of corresponding</span>
        <span class="s4"># pathcodes.  However, kinds can also be None; in which case all paths in that</span>
        <span class="s4"># list are codeless (this case is normalized above).  These lists are used to</span>
        <span class="s4"># construct paths, which then get concatenated.</span>
        <span class="s1">self._paths = [Path.make_compound_path(*map(Path</span><span class="s2">, </span><span class="s1">segs</span><span class="s2">, </span><span class="s1">kinds))</span>
                       <span class="s2">for </span><span class="s1">segs</span><span class="s2">, </span><span class="s1">kinds </span><span class="s2">in </span><span class="s1">zip(allsegs</span><span class="s2">, </span><span class="s1">allkinds)]</span>

        <span class="s2">return </span><span class="s1">kwargs</span>

    <span class="s2">def </span><span class="s1">_make_paths_from_contour_generator(self):</span>
        <span class="s0">&quot;&quot;&quot;Compute ``paths`` using C extension.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._paths </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._paths</span>
        <span class="s1">paths = []</span>
        <span class="s1">empty_path = Path(np.empty((</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)))</span>
        <span class="s2">if </span><span class="s1">self.filled:</span>
            <span class="s1">lowers</span><span class="s2">, </span><span class="s1">uppers = self._get_lowers_and_uppers()</span>
            <span class="s2">for </span><span class="s1">level</span><span class="s2">, </span><span class="s1">level_upper </span><span class="s2">in </span><span class="s1">zip(lowers</span><span class="s2">, </span><span class="s1">uppers):</span>
                <span class="s1">vertices</span><span class="s2">, </span><span class="s1">kinds = \</span>
                    <span class="s1">self._contour_generator.create_filled_contour(</span>
                        <span class="s1">level</span><span class="s2">, </span><span class="s1">level_upper)</span>
                <span class="s1">paths.append(Path(np.concatenate(vertices)</span><span class="s2">, </span><span class="s1">np.concatenate(kinds))</span>
                             <span class="s2">if </span><span class="s1">len(vertices) </span><span class="s2">else </span><span class="s1">empty_path)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">level </span><span class="s2">in </span><span class="s1">self.levels:</span>
                <span class="s1">vertices</span><span class="s2">, </span><span class="s1">kinds = self._contour_generator.create_contour(level)</span>
                <span class="s1">paths.append(Path(np.concatenate(vertices)</span><span class="s2">, </span><span class="s1">np.concatenate(kinds))</span>
                             <span class="s2">if </span><span class="s1">len(vertices) </span><span class="s2">else </span><span class="s1">empty_path)</span>
        <span class="s2">return </span><span class="s1">paths</span>

    <span class="s2">def </span><span class="s1">_get_lowers_and_uppers(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return ``(lowers, uppers)`` for filled contours. 
        &quot;&quot;&quot;</span>
        <span class="s1">lowers = self._levels[:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self.zmin == lowers[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s4"># Include minimum values in lowest interval</span>
            <span class="s1">lowers = lowers.copy()  </span><span class="s4"># so we don't change self._levels</span>
            <span class="s2">if </span><span class="s1">self.logscale:</span>
                <span class="s1">lowers[</span><span class="s5">0</span><span class="s1">] = </span><span class="s5">0.99 </span><span class="s1">* self.zmin</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">lowers[</span><span class="s5">0</span><span class="s1">] -= </span><span class="s5">1</span>
        <span class="s1">uppers = self._levels[</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s2">return </span><span class="s1">(lowers</span><span class="s2">, </span><span class="s1">uppers)</span>

    <span class="s2">def </span><span class="s1">changed(self):</span>
        <span class="s2">if not </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s3">&quot;cvalues&quot;</span><span class="s1">):</span>
            <span class="s1">self._process_colors()  </span><span class="s4"># Sets cvalues.</span>
        <span class="s4"># Force an autoscale immediately because self.to_rgba() calls</span>
        <span class="s4"># autoscale_None() internally with the data passed to it,</span>
        <span class="s4"># so if vmin/vmax are not set yet, this would override them with</span>
        <span class="s4"># content from *cvalues* rather than levels like we want</span>
        <span class="s1">self.norm.autoscale_None(self.levels)</span>
        <span class="s1">self.set_array(self.cvalues)</span>
        <span class="s1">self.update_scalarmappable()</span>
        <span class="s1">alphas = np.broadcast_to(self.get_alpha()</span><span class="s2">, </span><span class="s1">len(self.cvalues))</span>
        <span class="s2">for </span><span class="s1">label</span><span class="s2">, </span><span class="s1">cv</span><span class="s2">, </span><span class="s1">alpha </span><span class="s2">in </span><span class="s1">zip(self.labelTexts</span><span class="s2">, </span><span class="s1">self.labelCValues</span><span class="s2">, </span><span class="s1">alphas):</span>
            <span class="s1">label.set_alpha(alpha)</span>
            <span class="s1">label.set_color(self.labelMappable.to_rgba(cv))</span>
        <span class="s1">super().changed()</span>

    <span class="s2">def </span><span class="s1">_autolev(self</span><span class="s2">, </span><span class="s1">N):</span>
        <span class="s0">&quot;&quot;&quot; 
        Select contour levels to span the data. 
 
        The target number of levels, *N*, is used only when the 
        scale is not log and default locator is used. 
 
        We need two more levels for filled contours than for 
        line contours, because for the latter we need to specify 
        the lower and upper boundary of each range. For example, 
        a single contour boundary, say at z = 0, requires only 
        one contour line, but two filled regions, and therefore 
        three levels to provide boundaries for both regions. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.locator </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.logscale:</span>
                <span class="s1">self.locator = ticker.LogLocator()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.locator = ticker.MaxNLocator(N + </span><span class="s5">1</span><span class="s2">, </span><span class="s1">min_n_ticks=</span><span class="s5">1</span><span class="s1">)</span>

        <span class="s1">lev = self.locator.tick_values(self.zmin</span><span class="s2">, </span><span class="s1">self.zmax)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.locator._symmetric:</span>
                <span class="s2">return </span><span class="s1">lev</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s2">pass</span>

        <span class="s4"># Trim excess levels the locator may have supplied.</span>
        <span class="s1">under = np.nonzero(lev &lt; self.zmin)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">i0 = under[-</span><span class="s5">1</span><span class="s1">] </span><span class="s2">if </span><span class="s1">len(under) </span><span class="s2">else </span><span class="s5">0</span>
        <span class="s1">over = np.nonzero(lev &gt; self.zmax)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">i1 = over[</span><span class="s5">0</span><span class="s1">] + </span><span class="s5">1 </span><span class="s2">if </span><span class="s1">len(over) </span><span class="s2">else </span><span class="s1">len(lev)</span>
        <span class="s2">if </span><span class="s1">self.extend </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'min'</span><span class="s2">, </span><span class="s3">'both'</span><span class="s1">):</span>
            <span class="s1">i0 += </span><span class="s5">1</span>
        <span class="s2">if </span><span class="s1">self.extend </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'max'</span><span class="s2">, </span><span class="s3">'both'</span><span class="s1">):</span>
            <span class="s1">i1 -= </span><span class="s5">1</span>

        <span class="s2">if </span><span class="s1">i1 - i0 &lt; </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s1">i0</span><span class="s2">, </span><span class="s1">i1 = </span><span class="s5">0</span><span class="s2">, </span><span class="s1">len(lev)</span>

        <span class="s2">return </span><span class="s1">lev[i0:i1]</span>

    <span class="s2">def </span><span class="s1">_process_contour_level_args(self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">z_dtype):</span>
        <span class="s0">&quot;&quot;&quot; 
        Determine the contour levels and store in self.levels. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.levels </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">args:</span>
                <span class="s1">levels_arg = args[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s2">elif </span><span class="s1">np.issubdtype(z_dtype</span><span class="s2">, </span><span class="s1">bool):</span>
                <span class="s2">if </span><span class="s1">self.filled:</span>
                    <span class="s1">levels_arg = [</span><span class="s5">0</span><span class="s2">, </span><span class="s5">.5</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">levels_arg = [</span><span class="s5">.5</span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">levels_arg = </span><span class="s5">7  </span><span class="s4"># Default, hard-wired.</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">levels_arg = self.levels</span>
        <span class="s2">if </span><span class="s1">isinstance(levels_arg</span><span class="s2">, </span><span class="s1">Integral):</span>
            <span class="s1">self.levels = self._autolev(levels_arg)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.levels = np.asarray(levels_arg</span><span class="s2">, </span><span class="s1">np.float64)</span>
        <span class="s2">if </span><span class="s1">self.filled </span><span class="s2">and </span><span class="s1">len(self.levels) &lt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Filled contours require at least 2 levels.&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">len(self.levels) &gt; </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">np.min(np.diff(self.levels)) &lt;= </span><span class="s5">0.0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Contour levels must be increasing&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_process_levels(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Assign values to :attr:`layers` based on :attr:`levels`, 
        adding extended layers as needed if contours are filled. 
 
        For line contours, layers simply coincide with levels; 
        a line is a thin layer.  No extended levels are needed 
        with line contours. 
        &quot;&quot;&quot;</span>
        <span class="s4"># Make a private _levels to include extended regions; we</span>
        <span class="s4"># want to leave the original levels attribute unchanged.</span>
        <span class="s4"># (Colorbar needs this even for line contours.)</span>
        <span class="s1">self._levels = list(self.levels)</span>

        <span class="s2">if </span><span class="s1">self.logscale:</span>
            <span class="s1">lower</span><span class="s2">, </span><span class="s1">upper = </span><span class="s5">1e-250</span><span class="s2">, </span><span class="s5">1e250</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">lower</span><span class="s2">, </span><span class="s1">upper = -</span><span class="s5">1e250</span><span class="s2">, </span><span class="s5">1e250</span>

        <span class="s2">if </span><span class="s1">self.extend </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'both'</span><span class="s2">, </span><span class="s3">'min'</span><span class="s1">):</span>
            <span class="s1">self._levels.insert(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">lower)</span>
        <span class="s2">if </span><span class="s1">self.extend </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'both'</span><span class="s2">, </span><span class="s3">'max'</span><span class="s1">):</span>
            <span class="s1">self._levels.append(upper)</span>
        <span class="s1">self._levels = np.asarray(self._levels)</span>

        <span class="s2">if not </span><span class="s1">self.filled:</span>
            <span class="s1">self.layers = self.levels</span>
            <span class="s2">return</span>

        <span class="s4"># Layer values are mid-way between levels in screen space.</span>
        <span class="s2">if </span><span class="s1">self.logscale:</span>
            <span class="s4"># Avoid overflow by taking sqrt before multiplying.</span>
            <span class="s1">self.layers = (np.sqrt(self._levels[:-</span><span class="s5">1</span><span class="s1">])</span>
                           <span class="s1">* np.sqrt(self._levels[</span><span class="s5">1</span><span class="s1">:]))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.layers = </span><span class="s5">0.5 </span><span class="s1">* (self._levels[:-</span><span class="s5">1</span><span class="s1">] + self._levels[</span><span class="s5">1</span><span class="s1">:])</span>

    <span class="s2">def </span><span class="s1">_process_colors(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Color argument processing for contouring. 
 
        Note that we base the colormapping on the contour levels 
        and layers, not on the actual range of the Z values.  This 
        means we don't have to worry about bad values in Z, and we 
        always have the full dynamic range available for the selected 
        levels. 
 
        The color is based on the midpoint of the layer, except for 
        extended end layers.  By default, the norm vmin and vmax 
        are the extreme values of the non-extended levels.  Hence, 
        the layer color extremes are not the extreme values of 
        the colormap itself, but approach those values as the number 
        of levels increases.  An advantage of this scheme is that 
        line contours, when added to filled contours, take on 
        colors that are consistent with those of the filled regions; 
        for example, a contour line on the boundary between two 
        regions will have a color intermediate between those 
        of the regions. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.monochrome = self.cmap.monochrome</span>
        <span class="s2">if </span><span class="s1">self.colors </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s4"># Generate integers for direct indexing.</span>
            <span class="s1">i0</span><span class="s2">, </span><span class="s1">i1 = </span><span class="s5">0</span><span class="s2">, </span><span class="s1">len(self.levels)</span>
            <span class="s2">if </span><span class="s1">self.filled:</span>
                <span class="s1">i1 -= </span><span class="s5">1</span>
                <span class="s4"># Out of range indices for over and under:</span>
                <span class="s2">if </span><span class="s1">self.extend </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'both'</span><span class="s2">, </span><span class="s3">'min'</span><span class="s1">):</span>
                    <span class="s1">i0 -= </span><span class="s5">1</span>
                <span class="s2">if </span><span class="s1">self.extend </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'both'</span><span class="s2">, </span><span class="s3">'max'</span><span class="s1">):</span>
                    <span class="s1">i1 += </span><span class="s5">1</span>
            <span class="s1">self.cvalues = list(range(i0</span><span class="s2">, </span><span class="s1">i1))</span>
            <span class="s1">self.set_norm(mcolors.NoNorm())</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.cvalues = self.layers</span>
        <span class="s1">self.norm.autoscale_None(self.levels)</span>
        <span class="s1">self.set_array(self.cvalues)</span>
        <span class="s1">self.update_scalarmappable()</span>
        <span class="s2">if </span><span class="s1">self.extend </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'both'</span><span class="s2">, </span><span class="s3">'max'</span><span class="s2">, </span><span class="s3">'min'</span><span class="s1">):</span>
            <span class="s1">self.norm.clip = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">_process_linewidths(self</span><span class="s2">, </span><span class="s1">linewidths):</span>
        <span class="s1">Nlev = len(self.levels)</span>
        <span class="s2">if </span><span class="s1">linewidths </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">default_linewidth = mpl.rcParams[</span><span class="s3">'contour.linewidth'</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">default_linewidth </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">default_linewidth = mpl.rcParams[</span><span class="s3">'lines.linewidth'</span><span class="s1">]</span>
            <span class="s2">return </span><span class="s1">[default_linewidth] * Nlev</span>
        <span class="s2">elif not </span><span class="s1">np.iterable(linewidths):</span>
            <span class="s2">return </span><span class="s1">[linewidths] * Nlev</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">linewidths = list(linewidths)</span>
            <span class="s2">return </span><span class="s1">(linewidths * math.ceil(Nlev / len(linewidths)))[:Nlev]</span>

    <span class="s2">def </span><span class="s1">_process_linestyles(self</span><span class="s2">, </span><span class="s1">linestyles):</span>
        <span class="s1">Nlev = len(self.levels)</span>
        <span class="s2">if </span><span class="s1">linestyles </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">tlinestyles = [</span><span class="s3">'solid'</span><span class="s1">] * Nlev</span>
            <span class="s2">if </span><span class="s1">self.monochrome:</span>
                <span class="s1">eps = - (self.zmax - self.zmin) * </span><span class="s5">1e-15</span>
                <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">lev </span><span class="s2">in </span><span class="s1">enumerate(self.levels):</span>
                    <span class="s2">if </span><span class="s1">lev &lt; eps:</span>
                        <span class="s1">tlinestyles[i] = self.negative_linestyles</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">isinstance(linestyles</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s1">tlinestyles = [linestyles] * Nlev</span>
            <span class="s2">elif </span><span class="s1">np.iterable(linestyles):</span>
                <span class="s1">tlinestyles = list(linestyles)</span>
                <span class="s2">if </span><span class="s1">len(tlinestyles) &lt; Nlev:</span>
                    <span class="s1">nreps = int(np.ceil(Nlev / len(linestyles)))</span>
                    <span class="s1">tlinestyles = tlinestyles * nreps</span>
                <span class="s2">if </span><span class="s1">len(tlinestyles) &gt; Nlev:</span>
                    <span class="s1">tlinestyles = tlinestyles[:Nlev]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Unrecognized type for linestyles kwarg&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">tlinestyles</span>

    <span class="s2">def </span><span class="s1">_find_nearest_contour(self</span><span class="s2">, </span><span class="s1">xy</span><span class="s2">, </span><span class="s1">indices=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Find the point in the unfilled contour plot that is closest (in screen 
        space) to point *xy*. 
 
        Parameters 
        ---------- 
        xy : tuple[float, float] 
            The reference point (in screen space). 
        indices : list of int or None, default: None 
            Indices of contour levels to consider.  If None (the default), all levels 
            are considered. 
 
        Returns 
        ------- 
        idx_level_min : int 
            The index of the contour level closest to *xy*. 
        idx_vtx_min : int 
            The index of the `.Path` segment closest to *xy* (at that level). 
        proj : (float, float) 
            The point in the contour plot closest to *xy*. 
        &quot;&quot;&quot;</span>

        <span class="s4"># Convert each contour segment to pixel coordinates and then compare the given</span>
        <span class="s4"># point to those coordinates for each contour. This is fast enough in normal</span>
        <span class="s4"># cases, but speedups may be possible.</span>

        <span class="s2">if </span><span class="s1">self.filled:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Method does not support filled contours&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">indices </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">indices = range(len(self._paths))</span>

        <span class="s1">d2min = np.inf</span>
        <span class="s1">idx_level_min = idx_vtx_min = proj_min = </span><span class="s2">None</span>

        <span class="s2">for </span><span class="s1">idx_level </span><span class="s2">in </span><span class="s1">indices:</span>
            <span class="s1">path = self._paths[idx_level]</span>
            <span class="s2">if not </span><span class="s1">len(path.vertices):</span>
                <span class="s2">continue</span>
            <span class="s1">lc = self.get_transform().transform(path.vertices)</span>
            <span class="s1">d2</span><span class="s2">, </span><span class="s1">proj</span><span class="s2">, </span><span class="s1">leg = _find_closest_point_on_path(lc</span><span class="s2">, </span><span class="s1">xy)</span>
            <span class="s2">if </span><span class="s1">d2 &lt; d2min:</span>
                <span class="s1">d2min = d2</span>
                <span class="s1">idx_level_min = idx_level</span>
                <span class="s1">idx_vtx_min = leg[</span><span class="s5">1</span><span class="s1">]</span>
                <span class="s1">proj_min = proj</span>

        <span class="s2">return </span><span class="s1">idx_level_min</span><span class="s2">, </span><span class="s1">idx_vtx_min</span><span class="s2">, </span><span class="s1">proj_min</span>

    <span class="s2">def </span><span class="s1">find_nearest_contour(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">indices=</span><span class="s2">None, </span><span class="s1">pixel=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Find the point in the contour plot that is closest to ``(x, y)``. 
 
        This method does not support filled contours. 
 
        Parameters 
        ---------- 
        x, y : float 
            The reference point. 
        indices : list of int or None, default: None 
            Indices of contour levels to consider.  If None (the default), all 
            levels are considered. 
        pixel : bool, default: True 
            If *True*, measure distance in pixel (screen) space, which is 
            useful for manual contour labeling; else, measure distance in axes 
            space. 
 
        Returns 
        ------- 
        path : int 
            The index of the path that is closest to ``(x, y)``.  Each path corresponds 
            to one contour level. 
        subpath : int 
            The index within that closest path of the subpath that is closest to 
            ``(x, y)``.  Each subpath corresponds to one unbroken contour line. 
        index : int 
            The index of the vertices within that subpath that are closest to 
            ``(x, y)``. 
        xmin, ymin : float 
            The point in the contour plot that is closest to ``(x, y)``. 
        d2 : float 
            The squared distance from ``(xmin, ymin)`` to ``(x, y)``. 
        &quot;&quot;&quot;</span>
        <span class="s1">segment = index = d2 = </span><span class="s2">None</span>

        <span class="s2">with </span><span class="s1">ExitStack() </span><span class="s2">as </span><span class="s1">stack:</span>
            <span class="s2">if not </span><span class="s1">pixel:</span>
                <span class="s4"># _find_nearest_contour works in pixel space. We want axes space, so</span>
                <span class="s4"># effectively disable the transformation here by setting to identity.</span>
                <span class="s1">stack.enter_context(self._cm_set(</span>
                    <span class="s1">transform=mtransforms.IdentityTransform()))</span>

            <span class="s1">i_level</span><span class="s2">, </span><span class="s1">i_vtx</span><span class="s2">, </span><span class="s1">(xmin</span><span class="s2">, </span><span class="s1">ymin) = self._find_nearest_contour((x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">, </span><span class="s1">indices)</span>

        <span class="s2">if </span><span class="s1">i_level </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">cc_cumlens = np.cumsum(</span>
                <span class="s1">[*map(len</span><span class="s2">, </span><span class="s1">self._paths[i_level]._iter_connected_components())])</span>
            <span class="s1">segment = cc_cumlens.searchsorted(i_vtx</span><span class="s2">, </span><span class="s3">&quot;right&quot;</span><span class="s1">)</span>
            <span class="s1">index = i_vtx </span><span class="s2">if </span><span class="s1">segment == </span><span class="s5">0 </span><span class="s2">else </span><span class="s1">i_vtx - cc_cumlens[segment - </span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">d2 = (xmin-x)**</span><span class="s5">2 </span><span class="s1">+ (ymin-y)**</span><span class="s5">2</span>

        <span class="s2">return </span><span class="s1">(i_level</span><span class="s2">, </span><span class="s1">segment</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">xmin</span><span class="s2">, </span><span class="s1">ymin</span><span class="s2">, </span><span class="s1">d2)</span>

    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s1">paths = self._paths</span>
        <span class="s1">n_paths = len(paths)</span>
        <span class="s2">if not </span><span class="s1">self.filled </span><span class="s2">or </span><span class="s1">all(hatch </span><span class="s2">is None for </span><span class="s1">hatch </span><span class="s2">in </span><span class="s1">self.hatches):</span>
            <span class="s1">super().draw(renderer)</span>
            <span class="s2">return</span>
        <span class="s4"># In presence of hatching, draw contours one at a time.</span>
        <span class="s2">for </span><span class="s1">idx </span><span class="s2">in </span><span class="s1">range(n_paths):</span>
            <span class="s2">with </span><span class="s1">cbook._setattr_cm(self</span><span class="s2">, </span><span class="s1">_paths=[paths[idx]])</span><span class="s2">, </span><span class="s1">self._cm_set(</span>
                <span class="s1">hatch=self.hatches[idx % len(self.hatches)]</span><span class="s2">,</span>
                <span class="s1">array=[self.get_array()[idx]]</span><span class="s2">,</span>
                <span class="s1">linewidths=[self.get_linewidths()[idx % len(self.get_linewidths())]]</span><span class="s2">,</span>
                <span class="s1">linestyles=[self.get_linestyles()[idx % len(self.get_linestyles())]]</span><span class="s2">,</span>
            <span class="s1">):</span>
                <span class="s1">super().draw(renderer)</span>


<span class="s1">@_docstring.dedent_interpd</span>
<span class="s2">class </span><span class="s1">QuadContourSet(ContourSet):</span>
    <span class="s0">&quot;&quot;&quot; 
    Create and store a set of contour lines or filled regions. 
 
    This class is typically not instantiated directly by the user but by 
    `~.Axes.contour` and `~.Axes.contourf`. 
 
    %(contour_set_attributes)s 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_process_args(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">corner_mask=</span><span class="s2">None, </span><span class="s1">algorithm=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Process args and kwargs. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">args </span><span class="s2">and </span><span class="s1">isinstance(args[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">QuadContourSet):</span>
            <span class="s2">if </span><span class="s1">self.levels </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">self.levels = args[</span><span class="s5">0</span><span class="s1">].levels</span>
            <span class="s1">self.zmin = args[</span><span class="s5">0</span><span class="s1">].zmin</span>
            <span class="s1">self.zmax = args[</span><span class="s5">0</span><span class="s1">].zmax</span>
            <span class="s1">self._corner_mask = args[</span><span class="s5">0</span><span class="s1">]._corner_mask</span>
            <span class="s1">contour_generator = args[</span><span class="s5">0</span><span class="s1">]._contour_generator</span>
            <span class="s1">self._mins = args[</span><span class="s5">0</span><span class="s1">]._mins</span>
            <span class="s1">self._maxs = args[</span><span class="s5">0</span><span class="s1">]._maxs</span>
            <span class="s1">self._algorithm = args[</span><span class="s5">0</span><span class="s1">]._algorithm</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">import </span><span class="s1">contourpy</span>

            <span class="s2">if </span><span class="s1">algorithm </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">algorithm = mpl.rcParams[</span><span class="s3">'contour.algorithm'</span><span class="s1">]</span>
            <span class="s1">mpl.rcParams.validate[</span><span class="s3">&quot;contour.algorithm&quot;</span><span class="s1">](algorithm)</span>
            <span class="s1">self._algorithm = algorithm</span>

            <span class="s2">if </span><span class="s1">corner_mask </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">self._algorithm == </span><span class="s3">&quot;mpl2005&quot;</span><span class="s1">:</span>
                    <span class="s4"># mpl2005 does not support corner_mask=True so if not</span>
                    <span class="s4"># specifically requested then disable it.</span>
                    <span class="s1">corner_mask = </span><span class="s2">False</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">corner_mask = mpl.rcParams[</span><span class="s3">'contour.corner_mask'</span><span class="s1">]</span>
            <span class="s1">self._corner_mask = corner_mask</span>

            <span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z = self._contour_args(args</span><span class="s2">, </span><span class="s1">kwargs)</span>

            <span class="s1">contour_generator = contourpy.contour_generator(</span>
                <span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">name=self._algorithm</span><span class="s2">, </span><span class="s1">corner_mask=self._corner_mask</span><span class="s2">,</span>
                <span class="s1">line_type=contourpy.LineType.SeparateCode</span><span class="s2">,</span>
                <span class="s1">fill_type=contourpy.FillType.OuterCode</span><span class="s2">,</span>
                <span class="s1">chunk_size=self.nchunk)</span>

            <span class="s1">t = self.get_transform()</span>

            <span class="s4"># if the transform is not trans data, and some part of it</span>
            <span class="s4"># contains transData, transform the xs and ys to data coordinates</span>
            <span class="s2">if </span><span class="s1">(t != self.axes.transData </span><span class="s2">and</span>
                    <span class="s1">any(t.contains_branch_seperately(self.axes.transData))):</span>
                <span class="s1">trans_to_data = t - self.axes.transData</span>
                <span class="s1">pts = np.vstack([x.flat</span><span class="s2">, </span><span class="s1">y.flat]).T</span>
                <span class="s1">transformed_pts = trans_to_data.transform(pts)</span>
                <span class="s1">x = transformed_pts[...</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span>
                <span class="s1">y = transformed_pts[...</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span>

            <span class="s1">self._mins = [ma.min(x)</span><span class="s2">, </span><span class="s1">ma.min(y)]</span>
            <span class="s1">self._maxs = [ma.max(x)</span><span class="s2">, </span><span class="s1">ma.max(y)]</span>

        <span class="s1">self._contour_generator = contour_generator</span>

        <span class="s2">return </span><span class="s1">kwargs</span>

    <span class="s2">def </span><span class="s1">_contour_args(self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs):</span>
        <span class="s2">if </span><span class="s1">self.filled:</span>
            <span class="s1">fn = </span><span class="s3">'contourf'</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">fn = </span><span class="s3">'contour'</span>
        <span class="s1">nargs = len(args)</span>

        <span class="s2">if </span><span class="s5">0 </span><span class="s1">&lt; nargs &lt;= </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">z</span><span class="s2">, </span><span class="s1">*args = args</span>
            <span class="s1">z = ma.asarray(z)</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">y = self._initialize_x_y(z)</span>
        <span class="s2">elif </span><span class="s5">2 </span><span class="s1">&lt; nargs &lt;= </span><span class="s5">4</span><span class="s1">:</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z_orig</span><span class="s2">, </span><span class="s1">*args = args</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z = self._check_xyz(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z_orig</span><span class="s2">, </span><span class="s1">kwargs)</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">_api.nargs_error(fn</span><span class="s2">, </span><span class="s1">takes=</span><span class="s3">&quot;from 1 to 4&quot;</span><span class="s2">, </span><span class="s1">given=nargs)</span>
        <span class="s1">z = ma.masked_invalid(z</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">self.zmax = z.max().astype(float)</span>
        <span class="s1">self.zmin = z.min().astype(float)</span>
        <span class="s2">if </span><span class="s1">self.logscale </span><span class="s2">and </span><span class="s1">self.zmin &lt;= </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">z = ma.masked_where(z &lt;= </span><span class="s5">0</span><span class="s2">, </span><span class="s1">z)</span>
            <span class="s1">_api.warn_external(</span><span class="s3">'Log scale: values of z &lt;= 0 have been masked'</span><span class="s1">)</span>
            <span class="s1">self.zmin = z.min().astype(float)</span>
        <span class="s1">self._process_contour_level_args(args</span><span class="s2">, </span><span class="s1">z.dtype)</span>
        <span class="s2">return </span><span class="s1">(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z)</span>

    <span class="s2">def </span><span class="s1">_check_xyz(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Check that the shapes of the input arrays match; if x and y are 1D, 
        convert them to 2D using meshgrid. 
        &quot;&quot;&quot;</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">y = self.axes._process_unit_info([(</span><span class="s3">&quot;x&quot;</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;y&quot;</span><span class="s2">, </span><span class="s1">y)]</span><span class="s2">, </span><span class="s1">kwargs)</span>

        <span class="s1">x = np.asarray(x</span><span class="s2">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">y = np.asarray(y</span><span class="s2">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">z = ma.asarray(z)</span>

        <span class="s2">if </span><span class="s1">z.ndim != </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;Input z must be 2D, not </span><span class="s2">{</span><span class="s1">z.ndim</span><span class="s2">}</span><span class="s3">D&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">z.shape[</span><span class="s5">0</span><span class="s1">] &lt; </span><span class="s5">2 </span><span class="s2">or </span><span class="s1">z.shape[</span><span class="s5">1</span><span class="s1">] &lt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;Input z must be at least a (2, 2) shaped array, &quot;</span>
                            <span class="s3">f&quot;but has shape </span><span class="s2">{</span><span class="s1">z.shape</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s1">Ny</span><span class="s2">, </span><span class="s1">Nx = z.shape</span>

        <span class="s2">if </span><span class="s1">x.ndim != y.ndim:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;Number of dimensions of x (</span><span class="s2">{</span><span class="s1">x.ndim</span><span class="s2">}</span><span class="s3">) and y &quot;</span>
                            <span class="s3">f&quot;(</span><span class="s2">{</span><span class="s1">y.ndim</span><span class="s2">}</span><span class="s3">) do not match&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">x.ndim == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">nx</span><span class="s2">, </span><span class="s1">= x.shape</span>
            <span class="s1">ny</span><span class="s2">, </span><span class="s1">= y.shape</span>
            <span class="s2">if </span><span class="s1">nx != Nx:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;Length of x (</span><span class="s2">{</span><span class="s1">nx</span><span class="s2">}</span><span class="s3">) must match number of &quot;</span>
                                <span class="s3">f&quot;columns in z (</span><span class="s2">{</span><span class="s1">Nx</span><span class="s2">}</span><span class="s3">)&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">ny != Ny:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;Length of y (</span><span class="s2">{</span><span class="s1">ny</span><span class="s2">}</span><span class="s3">) must match number of &quot;</span>
                                <span class="s3">f&quot;rows in z (</span><span class="s2">{</span><span class="s1">Ny</span><span class="s2">}</span><span class="s3">)&quot;</span><span class="s1">)</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">y = np.meshgrid(x</span><span class="s2">, </span><span class="s1">y)</span>
        <span class="s2">elif </span><span class="s1">x.ndim == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">x.shape != z.shape:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span>
                    <span class="s3">f&quot;Shapes of x </span><span class="s2">{</span><span class="s1">x.shape</span><span class="s2">} </span><span class="s3">and z </span><span class="s2">{</span><span class="s1">z.shape</span><span class="s2">} </span><span class="s3">do not match&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">y.shape != z.shape:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span>
                    <span class="s3">f&quot;Shapes of y </span><span class="s2">{</span><span class="s1">y.shape</span><span class="s2">} </span><span class="s3">and z </span><span class="s2">{</span><span class="s1">z.shape</span><span class="s2">} </span><span class="s3">do not match&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;Inputs x and y must be 1D or 2D, not </span><span class="s2">{</span><span class="s1">x.ndim</span><span class="s2">}</span><span class="s3">D&quot;</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z</span>

    <span class="s2">def </span><span class="s1">_initialize_x_y(self</span><span class="s2">, </span><span class="s1">z):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return X, Y arrays such that contour(Z) will match imshow(Z) 
        if origin is not None. 
        The center of pixel Z[i, j] depends on origin: 
        if origin is None, x = j, y = i; 
        if origin is 'lower', x = j + 0.5, y = i + 0.5; 
        if origin is 'upper', x = j + 0.5, y = Nrows - i - 0.5 
        If extent is not None, x and y will be scaled to match, 
        as in imshow. 
        If origin is None and extent is not None, then extent 
        will give the minimum and maximum values of x and y. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">z.ndim != </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;Input z must be 2D, not </span><span class="s2">{</span><span class="s1">z.ndim</span><span class="s2">}</span><span class="s3">D&quot;</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">z.shape[</span><span class="s5">0</span><span class="s1">] &lt; </span><span class="s5">2 </span><span class="s2">or </span><span class="s1">z.shape[</span><span class="s5">1</span><span class="s1">] &lt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;Input z must be at least a (2, 2) shaped array, &quot;</span>
                            <span class="s3">f&quot;but has shape </span><span class="s2">{</span><span class="s1">z.shape</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">Ny</span><span class="s2">, </span><span class="s1">Nx = z.shape</span>
        <span class="s2">if </span><span class="s1">self.origin </span><span class="s2">is None</span><span class="s1">:  </span><span class="s4"># Not for image-matching.</span>
            <span class="s2">if </span><span class="s1">self.extent </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">np.meshgrid(np.arange(Nx)</span><span class="s2">, </span><span class="s1">np.arange(Ny))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">x0</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">y1 = self.extent</span>
                <span class="s1">x = np.linspace(x0</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">Nx)</span>
                <span class="s1">y = np.linspace(y0</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">Ny)</span>
                <span class="s2">return </span><span class="s1">np.meshgrid(x</span><span class="s2">, </span><span class="s1">y)</span>
        <span class="s4"># Match image behavior:</span>
        <span class="s2">if </span><span class="s1">self.extent </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">x0</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">y1 = (</span><span class="s5">0</span><span class="s2">, </span><span class="s1">Nx</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">Ny)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">x0</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">y1 = self.extent</span>
        <span class="s1">dx = (x1 - x0) / Nx</span>
        <span class="s1">dy = (y1 - y0) / Ny</span>
        <span class="s1">x = x0 + (np.arange(Nx) + </span><span class="s5">0.5</span><span class="s1">) * dx</span>
        <span class="s1">y = y0 + (np.arange(Ny) + </span><span class="s5">0.5</span><span class="s1">) * dy</span>
        <span class="s2">if </span><span class="s1">self.origin == </span><span class="s3">'upper'</span><span class="s1">:</span>
            <span class="s1">y = y[::-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">np.meshgrid(x</span><span class="s2">, </span><span class="s1">y)</span>


<span class="s1">_docstring.interpd.update(contour_doc=</span><span class="s3">&quot;&quot;&quot; 
`.contour` and `.contourf` draw contour lines and filled contours, 
respectively.  Except as noted, function signatures and return values 
are the same for both versions. 
 
Parameters 
---------- 
X, Y : array-like, optional 
    The coordinates of the values in *Z*. 
 
    *X* and *Y* must both be 2D with the same shape as *Z* (e.g. 
    created via `numpy.meshgrid`), or they must both be 1-D such 
    that ``len(X) == N`` is the number of columns in *Z* and 
    ``len(Y) == M`` is the number of rows in *Z*. 
 
    *X* and *Y* must both be ordered monotonically. 
 
    If not given, they are assumed to be integer indices, i.e. 
    ``X = range(N)``, ``Y = range(M)``. 
 
Z : (M, N) array-like 
    The height values over which the contour is drawn.  Color-mapping is 
    controlled by *cmap*, *norm*, *vmin*, and *vmax*. 
 
levels : int or array-like, optional 
    Determines the number and positions of the contour lines / regions. 
 
    If an int *n*, use `~matplotlib.ticker.MaxNLocator`, which tries 
    to automatically choose no more than *n+1* &quot;nice&quot; contour levels 
    between minimum and maximum numeric values of *Z*. 
 
    If array-like, draw contour lines at the specified levels. 
    The values must be in increasing order. 
 
Returns 
------- 
`~.contour.QuadContourSet` 
 
Other Parameters 
---------------- 
corner_mask : bool, default: :rc:`contour.corner_mask` 
    Enable/disable corner masking, which only has an effect if *Z* is 
    a masked array.  If ``False``, any quad touching a masked point is 
    masked out.  If ``True``, only the triangular corners of quads 
    nearest those points are always masked out, other triangular 
    corners comprising three unmasked points are contoured as usual. 
 
colors : color string or sequence of colors, optional 
    The colors of the levels, i.e. the lines for `.contour` and the 
    areas for `.contourf`. 
 
    The sequence is cycled for the levels in ascending order. If the 
    sequence is shorter than the number of levels, it's repeated. 
 
    As a shortcut, single color strings may be used in place of 
    one-element lists, i.e. ``'red'`` instead of ``['red']`` to color 
    all levels with the same color. This shortcut does only work for 
    color strings, not for other ways of specifying colors. 
 
    By default (value *None*), the colormap specified by *cmap* 
    will be used. 
 
alpha : float, default: 1 
    The alpha blending value, between 0 (transparent) and 1 (opaque). 
 
%(cmap_doc)s 
 
    This parameter is ignored if *colors* is set. 
 
%(norm_doc)s 
 
    This parameter is ignored if *colors* is set. 
 
%(vmin_vmax_doc)s 
 
    If *vmin* or *vmax* are not given, the default color scaling is based on 
    *levels*. 
 
    This parameter is ignored if *colors* is set. 
 
origin : {*None*, 'upper', 'lower', 'image'}, default: None 
    Determines the orientation and exact position of *Z* by specifying 
    the position of ``Z[0, 0]``.  This is only relevant, if *X*, *Y* 
    are not given. 
 
    - *None*: ``Z[0, 0]`` is at X=0, Y=0 in the lower left corner. 
    - 'lower': ``Z[0, 0]`` is at X=0.5, Y=0.5 in the lower left corner. 
    - 'upper': ``Z[0, 0]`` is at X=N+0.5, Y=0.5 in the upper left 
      corner. 
    - 'image': Use the value from :rc:`image.origin`. 
 
extent : (x0, x1, y0, y1), optional 
    If *origin* is not *None*, then *extent* is interpreted as in 
    `.imshow`: it gives the outer pixel boundaries. In this case, the 
    position of Z[0, 0] is the center of the pixel, not a corner. If 
    *origin* is *None*, then (*x0*, *y0*) is the position of Z[0, 0], 
    and (*x1*, *y1*) is the position of Z[-1, -1]. 
 
    This argument is ignored if *X* and *Y* are specified in the call 
    to contour. 
 
locator : ticker.Locator subclass, optional 
    The locator is used to determine the contour levels if they 
    are not given explicitly via *levels*. 
    Defaults to `~.ticker.MaxNLocator`. 
 
extend : {'neither', 'both', 'min', 'max'}, default: 'neither' 
    Determines the ``contourf``-coloring of values that are outside the 
    *levels* range. 
 
    If 'neither', values outside the *levels* range are not colored. 
    If 'min', 'max' or 'both', color the values below, above or below 
    and above the *levels* range. 
 
    Values below ``min(levels)`` and above ``max(levels)`` are mapped 
    to the under/over values of the `.Colormap`. Note that most 
    colormaps do not have dedicated colors for these by default, so 
    that the over and under values are the edge values of the colormap. 
    You may want to set these values explicitly using 
    `.Colormap.set_under` and `.Colormap.set_over`. 
 
    .. note:: 
 
        An existing `.QuadContourSet` does not get notified if 
        properties of its colormap are changed. Therefore, an explicit 
        call `.QuadContourSet.changed()` is needed after modifying the 
        colormap. The explicit call can be left out, if a colorbar is 
        assigned to the `.QuadContourSet` because it internally calls 
        `.QuadContourSet.changed()`. 
 
    Example:: 
 
        x = np.arange(1, 10) 
        y = x.reshape(-1, 1) 
        h = x * y 
 
        cs = plt.contourf(h, levels=[10, 30, 50], 
            colors=['#808080', '#A0A0A0', '#C0C0C0'], extend='both') 
        cs.cmap.set_over('red') 
        cs.cmap.set_under('blue') 
        cs.changed() 
 
xunits, yunits : registered units, optional 
    Override axis units by specifying an instance of a 
    :class:`matplotlib.units.ConversionInterface`. 
 
antialiased : bool, optional 
    Enable antialiasing, overriding the defaults.  For 
    filled contours, the default is *False*.  For line contours, 
    it is taken from :rc:`lines.antialiased`. 
 
nchunk : int &gt;= 0, optional 
    If 0, no subdivision of the domain.  Specify a positive integer to 
    divide the domain into subdomains of *nchunk* by *nchunk* quads. 
    Chunking reduces the maximum length of polygons generated by the 
    contouring algorithm which reduces the rendering workload passed 
    on to the backend and also requires slightly less RAM.  It can 
    however introduce rendering artifacts at chunk boundaries depending 
    on the backend, the *antialiased* flag and value of *alpha*. 
 
linewidths : float or array-like, default: :rc:`contour.linewidth` 
    *Only applies to* `.contour`. 
 
    The line width of the contour lines. 
 
    If a number, all levels will be plotted with this linewidth. 
 
    If a sequence, the levels in ascending order will be plotted with 
    the linewidths in the order specified. 
 
    If None, this falls back to :rc:`lines.linewidth`. 
 
linestyles : {*None*, 'solid', 'dashed', 'dashdot', 'dotted'}, optional 
    *Only applies to* `.contour`. 
 
    If *linestyles* is *None*, the default is 'solid' unless the lines are 
    monochrome. In that case, negative contours will instead take their 
    linestyle from the *negative_linestyles* argument. 
 
    *linestyles* can also be an iterable of the above strings specifying a set 
    of linestyles to be used. If this iterable is shorter than the number of 
    contour levels it will be repeated as necessary. 
 
negative_linestyles : {*None*, 'solid', 'dashed', 'dashdot', 'dotted'}, </span><span class="s2">\ 
                       </span><span class="s3">optional 
    *Only applies to* `.contour`. 
 
    If *linestyles* is *None* and the lines are monochrome, this argument 
    specifies the line style for negative contours. 
 
    If *negative_linestyles* is *None*, the default is taken from 
    :rc:`contour.negative_linestyles`. 
 
    *negative_linestyles* can also be an iterable of the above strings 
    specifying a set of linestyles to be used. If this iterable is shorter than 
    the number of contour levels it will be repeated as necessary. 
 
hatches : list[str], optional 
    *Only applies to* `.contourf`. 
 
    A list of cross hatch patterns to use on the filled areas. 
    If None, no hatching will be added to the contour. 
    Hatching is supported in the PostScript, PDF, SVG and Agg 
    backends only. 
 
algorithm : {'mpl2005', 'mpl2014', 'serial', 'threaded'}, optional 
    Which contouring algorithm to use to calculate the contour lines and 
    polygons. The algorithms are implemented in 
    `ContourPy &lt;https://github.com/contourpy/contourpy&gt;`_, consult the 
    `ContourPy documentation &lt;https://contourpy.readthedocs.io&gt;`_ for 
    further information. 
 
    The default is taken from :rc:`contour.algorithm`. 
 
clip_path : `~matplotlib.patches.Patch` or `.Path` or `.TransformedPath` 
    Set the clip path.  See `~matplotlib.artist.Artist.set_clip_path`. 
 
    .. versionadded:: 3.8 
 
data : indexable object, optional 
    DATA_PARAMETER_PLACEHOLDER 
 
Notes 
----- 
1. `.contourf` differs from the MATLAB version in that it does not draw 
   the polygon edges. To draw edges, add line contours with calls to 
   `.contour`. 
 
2. `.contourf` fills intervals that are closed at the top; that is, for 
   boundaries *z1* and *z2*, the filled region is:: 
 
      z1 &lt; Z &lt;= z2 
 
   except for the lowest interval, which is closed on both sides (i.e. 
   it includes the lowest value). 
 
3. `.contour` and `.contourf` use a `marching squares 
   &lt;https://en.wikipedia.org/wiki/Marching_squares&gt;`_ algorithm to 
   compute contour locations.  More information can be found in 
   `ContourPy documentation &lt;https://contourpy.readthedocs.io&gt;`_. 
&quot;&quot;&quot; </span><span class="s1">% _docstring.interpd.params)</span>
</pre>
</body>
</html>