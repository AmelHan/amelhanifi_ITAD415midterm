<html>
<head>
<title>norms.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
norms.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s2"># TODO: add plots to weighting functions for online docs.</span>


<span class="s0">def </span><span class="s1">_cabs(x):</span>
    <span class="s3">&quot;&quot;&quot;absolute value function that changes complex sign based on real sign 
 
    This could be useful for complex step derivatives of functions that 
    need abs. Not yet used. 
    &quot;&quot;&quot;</span>
    <span class="s1">sign = (x.real &gt;= </span><span class="s4">0</span><span class="s1">) * </span><span class="s4">2 </span><span class="s1">- </span><span class="s4">1</span>
    <span class="s0">return </span><span class="s1">sign * x</span>


<span class="s0">class </span><span class="s1">RobustNorm:</span>
    <span class="s3">&quot;&quot;&quot; 
    The parent class for the norms used for robust regression. 
 
    Lays out the methods expected of the robust norms to be used 
    by statsmodels.RLM. 
 
    See Also 
    -------- 
    statsmodels.rlm 
 
    Notes 
    ----- 
    Currently only M-estimators are available. 
 
    References 
    ---------- 
    PJ Huber.  'Robust Statistics' John Wiley and Sons, Inc., New York, 1981. 
 
    DC Montgomery, EA Peck. 'Introduction to Linear Regression Analysis', 
        John Wiley and Sons, Inc., New York, 2001. 
 
    R Venables, B Ripley. 'Modern Applied Statistics in S' 
        Springer, New York, 2002. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">rho(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">&quot;&quot;&quot; 
        The robust criterion estimator function. 
 
        Abstract method: 
 
        -2 loglike used in M-estimator 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span>

    <span class="s0">def </span><span class="s1">psi(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">&quot;&quot;&quot; 
        Derivative of rho.  Sometimes referred to as the influence function. 
 
        Abstract method: 
 
        psi = rho' 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span>

    <span class="s0">def </span><span class="s1">weights(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">&quot;&quot;&quot; 
        Returns the value of psi(z) / z 
 
        Abstract method: 
 
        psi(z) / z 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span>

    <span class="s0">def </span><span class="s1">psi_deriv(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">&quot;&quot;&quot; 
        Derivative of psi.  Used to obtain robust covariance matrix. 
 
        See statsmodels.rlm for more information. 
 
        Abstract method: 
 
        psi_derive = psi' 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">&quot;&quot;&quot; 
        Returns the value of estimator rho applied to an input 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.rho(z)</span>


<span class="s0">class </span><span class="s1">LeastSquares(RobustNorm):</span>
    <span class="s3">&quot;&quot;&quot; 
    Least squares rho for M-estimation and its derived functions. 
 
    See Also 
    -------- 
    statsmodels.robust.norms.RobustNorm 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">rho(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">&quot;&quot;&quot; 
        The least squares estimator rho function 
 
        Parameters 
        ---------- 
        z : ndarray 
            1d array 
 
        Returns 
        ------- 
        rho : ndarray 
            rho(z) = (1/2.)*z**2 
        &quot;&quot;&quot;</span>

        <span class="s0">return </span><span class="s1">z**</span><span class="s4">2 </span><span class="s1">* </span><span class="s4">0.5</span>

    <span class="s0">def </span><span class="s1">psi(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">&quot;&quot;&quot; 
        The psi function for the least squares estimator 
 
        The analytic derivative of rho 
 
        Parameters 
        ---------- 
        z : array_like 
            1d array 
 
        Returns 
        ------- 
        psi : ndarray 
            psi(z) = z 
        &quot;&quot;&quot;</span>

        <span class="s0">return </span><span class="s1">np.asarray(z)</span>

    <span class="s0">def </span><span class="s1">weights(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">&quot;&quot;&quot; 
        The least squares estimator weighting function for the IRLS algorithm. 
 
        The psi function scaled by the input z 
 
        Parameters 
        ---------- 
        z : array_like 
            1d array 
 
        Returns 
        ------- 
        weights : ndarray 
            weights(z) = np.ones(z.shape) 
        &quot;&quot;&quot;</span>

        <span class="s1">z = np.asarray(z)</span>
        <span class="s0">return </span><span class="s1">np.ones(z.shape</span><span class="s0">, </span><span class="s1">np.float64)</span>

    <span class="s0">def </span><span class="s1">psi_deriv(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">&quot;&quot;&quot; 
        The derivative of the least squares psi function. 
 
        Returns 
        ------- 
        psi_deriv : ndarray 
            ones(z.shape) 
 
        Notes 
        ----- 
        Used to estimate the robust covariance matrix. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">np.ones(z.shape</span><span class="s0">, </span><span class="s1">np.float64)</span>


<span class="s0">class </span><span class="s1">HuberT(RobustNorm):</span>
    <span class="s3">&quot;&quot;&quot; 
    Huber's T for M estimation. 
 
    Parameters 
    ---------- 
    t : float, optional 
        The tuning constant for Huber's t function. The default value is 
        1.345. 
 
    See Also 
    -------- 
    statsmodels.robust.norms.RobustNorm 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">t=</span><span class="s4">1.345</span><span class="s1">):</span>
        <span class="s1">self.t = t</span>

    <span class="s0">def </span><span class="s1">_subset(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">&quot;&quot;&quot; 
        Huber's T is defined piecewise over the range for z 
        &quot;&quot;&quot;</span>
        <span class="s1">z = np.asarray(z)</span>
        <span class="s0">return </span><span class="s1">np.less_equal(np.abs(z)</span><span class="s0">, </span><span class="s1">self.t)</span>

    <span class="s0">def </span><span class="s1">rho(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">r&quot;&quot;&quot; 
        The robust criterion function for Huber's t. 
 
        Parameters 
        ---------- 
        z : array_like 
            1d array 
 
        Returns 
        ------- 
        rho : ndarray 
            rho(z) = .5*z**2            for \|z\| &lt;= t 
 
            rho(z) = \|z\|*t - .5*t**2    for \|z\| &gt; t 
        &quot;&quot;&quot;</span>
        <span class="s1">z = np.asarray(z)</span>
        <span class="s1">test = self._subset(z)</span>
        <span class="s0">return </span><span class="s1">(test * </span><span class="s4">0.5 </span><span class="s1">* z**</span><span class="s4">2 </span><span class="s1">+</span>
                <span class="s1">(</span><span class="s4">1 </span><span class="s1">- test) * (np.abs(z) * self.t - </span><span class="s4">0.5 </span><span class="s1">* self.t**</span><span class="s4">2</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">psi(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">r&quot;&quot;&quot; 
        The psi function for Huber's t estimator 
 
        The analytic derivative of rho 
 
        Parameters 
        ---------- 
        z : array_like 
            1d array 
 
        Returns 
        ------- 
        psi : ndarray 
            psi(z) = z      for \|z\| &lt;= t 
 
            psi(z) = sign(z)*t for \|z\| &gt; t 
        &quot;&quot;&quot;</span>
        <span class="s1">z = np.asarray(z)</span>
        <span class="s1">test = self._subset(z)</span>
        <span class="s0">return </span><span class="s1">test * z + (</span><span class="s4">1 </span><span class="s1">- test) * self.t * np.sign(z)</span>

    <span class="s0">def </span><span class="s1">weights(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">r&quot;&quot;&quot; 
        Huber's t weighting function for the IRLS algorithm 
 
        The psi function scaled by z 
 
        Parameters 
        ---------- 
        z : array_like 
            1d array 
 
        Returns 
        ------- 
        weights : ndarray 
            weights(z) = 1          for \|z\| &lt;= t 
 
            weights(z) = t/\|z\|      for \|z\| &gt; t 
        &quot;&quot;&quot;</span>
        <span class="s1">z_isscalar = np.isscalar(z)</span>
        <span class="s1">z = np.atleast_1d(z)</span>

        <span class="s1">test = self._subset(z)</span>
        <span class="s1">absz = np.abs(z)</span>
        <span class="s1">absz[test] = </span><span class="s4">1.0</span>
        <span class="s1">v = test + (</span><span class="s4">1 </span><span class="s1">- test) * self.t / absz</span>

        <span class="s0">if </span><span class="s1">z_isscalar:</span>
            <span class="s1">v = v[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s0">return </span><span class="s1">v</span>

    <span class="s0">def </span><span class="s1">psi_deriv(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">&quot;&quot;&quot; 
        The derivative of Huber's t psi function 
 
        Notes 
        ----- 
        Used to estimate the robust covariance matrix. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">np.less_equal(np.abs(z)</span><span class="s0">, </span><span class="s1">self.t).astype(float)</span>


<span class="s2"># TODO: untested, but looks right.  RamsayE not available in R or SAS?</span>
<span class="s0">class </span><span class="s1">RamsayE(RobustNorm):</span>
    <span class="s3">&quot;&quot;&quot; 
    Ramsay's Ea for M estimation. 
 
    Parameters 
    ---------- 
    a : float, optional 
        The tuning constant for Ramsay's Ea function.  The default value is 
        0.3. 
 
    See Also 
    -------- 
    statsmodels.robust.norms.RobustNorm 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">a=</span><span class="s4">.3</span><span class="s1">):</span>
        <span class="s1">self.a = a</span>

    <span class="s0">def </span><span class="s1">rho(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">r&quot;&quot;&quot; 
        The robust criterion function for Ramsay's Ea. 
 
        Parameters 
        ---------- 
        z : array_like 
            1d array 
 
        Returns 
        ------- 
        rho : ndarray 
            rho(z) = a**-2 * (1 - exp(-a*\|z\|)*(1 + a*\|z\|)) 
        &quot;&quot;&quot;</span>
        <span class="s1">z = np.asarray(z)</span>
        <span class="s0">return </span><span class="s1">(</span><span class="s4">1 </span><span class="s1">- np.exp(-self.a * np.abs(z)) *</span>
                <span class="s1">(</span><span class="s4">1 </span><span class="s1">+ self.a * np.abs(z))) / self.a**</span><span class="s4">2</span>

    <span class="s0">def </span><span class="s1">psi(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">r&quot;&quot;&quot; 
        The psi function for Ramsay's Ea estimator 
 
        The analytic derivative of rho 
 
        Parameters 
        ---------- 
        z : array_like 
            1d array 
 
        Returns 
        ------- 
        psi : ndarray 
            psi(z) = z*exp(-a*\|z\|) 
        &quot;&quot;&quot;</span>
        <span class="s1">z = np.asarray(z)</span>
        <span class="s0">return </span><span class="s1">z * np.exp(-self.a * np.abs(z))</span>

    <span class="s0">def </span><span class="s1">weights(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">r&quot;&quot;&quot; 
        Ramsay's Ea weighting function for the IRLS algorithm 
 
        The psi function scaled by z 
 
        Parameters 
        ---------- 
        z : array_like 
            1d array 
 
        Returns 
        ------- 
        weights : ndarray 
            weights(z) = exp(-a*\|z\|) 
        &quot;&quot;&quot;</span>

        <span class="s1">z = np.asarray(z)</span>
        <span class="s0">return </span><span class="s1">np.exp(-self.a * np.abs(z))</span>

    <span class="s0">def </span><span class="s1">psi_deriv(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">&quot;&quot;&quot; 
        The derivative of Ramsay's Ea psi function. 
 
        Notes 
        ----- 
        Used to estimate the robust covariance matrix. 
        &quot;&quot;&quot;</span>
        <span class="s1">a = self.a</span>
        <span class="s1">x = np.exp(-a * np.abs(z))</span>
        <span class="s1">dx = -a * x * np.sign(z)</span>
        <span class="s1">y = z</span>
        <span class="s1">dy = </span><span class="s4">1</span>
        <span class="s0">return </span><span class="s1">x * dy + y * dx</span>


<span class="s0">class </span><span class="s1">AndrewWave(RobustNorm):</span>
    <span class="s3">&quot;&quot;&quot; 
    Andrew's wave for M estimation. 
 
    Parameters 
    ---------- 
    a : float, optional 
        The tuning constant for Andrew's Wave function.  The default value is 
        1.339. 
 
    See Also 
    -------- 
    statsmodels.robust.norms.RobustNorm 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">a=</span><span class="s4">1.339</span><span class="s1">):</span>
        <span class="s1">self.a = a</span>

    <span class="s0">def </span><span class="s1">_subset(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">&quot;&quot;&quot; 
        Andrew's wave is defined piecewise over the range of z. 
        &quot;&quot;&quot;</span>
        <span class="s1">z = np.asarray(z)</span>
        <span class="s0">return </span><span class="s1">np.less_equal(np.abs(z)</span><span class="s0">, </span><span class="s1">self.a * np.pi)</span>

    <span class="s0">def </span><span class="s1">rho(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">r&quot;&quot;&quot; 
        The robust criterion function for Andrew's wave. 
 
        Parameters 
        ---------- 
        z : array_like 
            1d array 
 
        Returns 
        ------- 
        rho : ndarray 
            The elements of rho are defined as: 
 
            .. math:: 
 
                rho(z) &amp; = a^2 *(1-cos(z/a)), |z| \leq a\pi \\ 
                rho(z) &amp; = 2a, |z|&gt;q\pi 
        &quot;&quot;&quot;</span>

        <span class="s1">a = self.a</span>
        <span class="s1">z = np.asarray(z)</span>
        <span class="s1">test = self._subset(z)</span>
        <span class="s0">return </span><span class="s1">(test * a**</span><span class="s4">2 </span><span class="s1">* (</span><span class="s4">1 </span><span class="s1">- np.cos(z / a)) +</span>
                <span class="s1">(</span><span class="s4">1 </span><span class="s1">- test) * a**</span><span class="s4">2 </span><span class="s1">* </span><span class="s4">2</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">psi(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">r&quot;&quot;&quot; 
        The psi function for Andrew's wave 
 
        The analytic derivative of rho 
 
        Parameters 
        ---------- 
        z : array_like 
            1d array 
 
        Returns 
        ------- 
        psi : ndarray 
            psi(z) = a * sin(z/a)   for \|z\| &lt;= a*pi 
 
            psi(z) = 0              for \|z\| &gt; a*pi 
        &quot;&quot;&quot;</span>

        <span class="s1">a = self.a</span>
        <span class="s1">z = np.asarray(z)</span>
        <span class="s1">test = self._subset(z)</span>
        <span class="s0">return </span><span class="s1">test * a * np.sin(z / a)</span>

    <span class="s0">def </span><span class="s1">weights(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">r&quot;&quot;&quot; 
        Andrew's wave weighting function for the IRLS algorithm 
 
        The psi function scaled by z 
 
        Parameters 
        ---------- 
        z : array_like 
            1d array 
 
        Returns 
        ------- 
        weights : ndarray 
            weights(z) = sin(z/a) / (z/a)     for \|z\| &lt;= a*pi 
 
            weights(z) = 0                    for \|z\| &gt; a*pi 
        &quot;&quot;&quot;</span>
        <span class="s1">a = self.a</span>
        <span class="s1">z = np.asarray(z)</span>
        <span class="s1">test = self._subset(z)</span>
        <span class="s1">ratio = z / a</span>
        <span class="s1">small = np.abs(ratio) &lt; np.finfo(np.double).eps</span>
        <span class="s0">if </span><span class="s1">np.any(small):</span>
            <span class="s1">weights = np.ones_like(ratio)</span>
            <span class="s1">large = ~small</span>
            <span class="s1">ratio = ratio[large]</span>
            <span class="s1">weights[large] = test[large] * np.sin(ratio) / ratio</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">weights = test * np.sin(ratio) / ratio</span>
        <span class="s0">return </span><span class="s1">weights</span>

    <span class="s0">def </span><span class="s1">psi_deriv(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">&quot;&quot;&quot; 
        The derivative of Andrew's wave psi function 
 
        Notes 
        ----- 
        Used to estimate the robust covariance matrix. 
        &quot;&quot;&quot;</span>

        <span class="s1">test = self._subset(z)</span>
        <span class="s0">return </span><span class="s1">test * np.cos(z / self.a)</span>


<span class="s2"># TODO: this is untested</span>
<span class="s0">class </span><span class="s1">TrimmedMean(RobustNorm):</span>
    <span class="s3">&quot;&quot;&quot; 
    Trimmed mean function for M-estimation. 
 
    Parameters 
    ---------- 
    c : float, optional 
        The tuning constant for Ramsay's Ea function.  The default value is 
        2.0. 
 
    See Also 
    -------- 
    statsmodels.robust.norms.RobustNorm 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">c=</span><span class="s4">2.</span><span class="s1">):</span>
        <span class="s1">self.c = c</span>

    <span class="s0">def </span><span class="s1">_subset(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">&quot;&quot;&quot; 
        Least trimmed mean is defined piecewise over the range of z. 
        &quot;&quot;&quot;</span>

        <span class="s1">z = np.asarray(z)</span>
        <span class="s0">return </span><span class="s1">np.less_equal(np.abs(z)</span><span class="s0">, </span><span class="s1">self.c)</span>

    <span class="s0">def </span><span class="s1">rho(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">r&quot;&quot;&quot; 
        The robust criterion function for least trimmed mean. 
 
        Parameters 
        ---------- 
        z : array_like 
            1d array 
 
        Returns 
        ------- 
        rho : ndarray 
            rho(z) = (1/2.)*z**2    for \|z\| &lt;= c 
 
            rho(z) = (1/2.)*c**2              for \|z\| &gt; c 
        &quot;&quot;&quot;</span>

        <span class="s1">z = np.asarray(z)</span>
        <span class="s1">test = self._subset(z)</span>
        <span class="s0">return </span><span class="s1">test * z**</span><span class="s4">2 </span><span class="s1">* </span><span class="s4">0.5 </span><span class="s1">+ (</span><span class="s4">1 </span><span class="s1">- test) * self.c**</span><span class="s4">2 </span><span class="s1">* </span><span class="s4">0.5</span>

    <span class="s0">def </span><span class="s1">psi(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">r&quot;&quot;&quot; 
        The psi function for least trimmed mean 
 
        The analytic derivative of rho 
 
        Parameters 
        ---------- 
        z : array_like 
            1d array 
 
        Returns 
        ------- 
        psi : ndarray 
            psi(z) = z              for \|z\| &lt;= c 
 
            psi(z) = 0              for \|z\| &gt; c 
        &quot;&quot;&quot;</span>
        <span class="s1">z = np.asarray(z)</span>
        <span class="s1">test = self._subset(z)</span>
        <span class="s0">return </span><span class="s1">test * z</span>

    <span class="s0">def </span><span class="s1">weights(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">r&quot;&quot;&quot; 
        Least trimmed mean weighting function for the IRLS algorithm 
 
        The psi function scaled by z 
 
        Parameters 
        ---------- 
        z : array_like 
            1d array 
 
        Returns 
        ------- 
        weights : ndarray 
            weights(z) = 1             for \|z\| &lt;= c 
 
            weights(z) = 0             for \|z\| &gt; c 
        &quot;&quot;&quot;</span>
        <span class="s1">z = np.asarray(z)</span>
        <span class="s1">test = self._subset(z)</span>
        <span class="s0">return </span><span class="s1">test</span>

    <span class="s0">def </span><span class="s1">psi_deriv(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">&quot;&quot;&quot; 
        The derivative of least trimmed mean psi function 
 
        Notes 
        ----- 
        Used to estimate the robust covariance matrix. 
        &quot;&quot;&quot;</span>
        <span class="s1">test = self._subset(z)</span>
        <span class="s0">return </span><span class="s1">test</span>


<span class="s0">class </span><span class="s1">Hampel(RobustNorm):</span>
    <span class="s3">&quot;&quot;&quot; 
 
    Hampel function for M-estimation. 
 
    Parameters 
    ---------- 
    a : float, optional 
    b : float, optional 
    c : float, optional 
        The tuning constants for Hampel's function.  The default values are 
        a,b,c = 2, 4, 8. 
 
    See Also 
    -------- 
    statsmodels.robust.norms.RobustNorm 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">a=</span><span class="s4">2.</span><span class="s0">, </span><span class="s1">b=</span><span class="s4">4.</span><span class="s0">, </span><span class="s1">c=</span><span class="s4">8.</span><span class="s1">):</span>
        <span class="s1">self.a = a</span>
        <span class="s1">self.b = b</span>
        <span class="s1">self.c = c</span>

    <span class="s0">def </span><span class="s1">_subset(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">&quot;&quot;&quot; 
        Hampel's function is defined piecewise over the range of z 
        &quot;&quot;&quot;</span>
        <span class="s1">z = np.abs(np.asarray(z))</span>
        <span class="s1">t1 = np.less_equal(z</span><span class="s0">, </span><span class="s1">self.a)</span>
        <span class="s1">t2 = np.less_equal(z</span><span class="s0">, </span><span class="s1">self.b) * np.greater(z</span><span class="s0">, </span><span class="s1">self.a)</span>
        <span class="s1">t3 = np.less_equal(z</span><span class="s0">, </span><span class="s1">self.c) * np.greater(z</span><span class="s0">, </span><span class="s1">self.b)</span>
        <span class="s0">return </span><span class="s1">t1</span><span class="s0">, </span><span class="s1">t2</span><span class="s0">, </span><span class="s1">t3</span>

    <span class="s0">def </span><span class="s1">rho(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">r&quot;&quot;&quot; 
        The robust criterion function for Hampel's estimator 
 
        Parameters 
        ---------- 
        z : array_like 
            1d array 
 
        Returns 
        ------- 
        rho : ndarray 
            rho(z) = z**2 / 2                     for \|z\| &lt;= a 
 
            rho(z) = a*\|z\| - 1/2.*a**2               for a &lt; \|z\| &lt;= b 
 
            rho(z) = a*(c - \|z\|)**2 / (c - b) / 2    for b &lt; \|z\| &lt;= c 
 
            rho(z) = a*(b + c - a) / 2                 for \|z\| &gt; c 
        &quot;&quot;&quot;</span>
        <span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">c = self.a</span><span class="s0">, </span><span class="s1">self.b</span><span class="s0">, </span><span class="s1">self.c</span>

        <span class="s1">z_isscalar = np.isscalar(z)</span>
        <span class="s1">z = np.atleast_1d(z)</span>

        <span class="s1">t1</span><span class="s0">, </span><span class="s1">t2</span><span class="s0">, </span><span class="s1">t3 = self._subset(z)</span>
        <span class="s1">t34 = ~(t1 | t2)</span>
        <span class="s1">dt = np.promote_types(z.dtype</span><span class="s0">, </span><span class="s5">&quot;float&quot;</span><span class="s1">)</span>
        <span class="s1">v = np.zeros(z.shape</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
        <span class="s1">z = np.abs(z)</span>
        <span class="s1">v[t1] = z[t1]**</span><span class="s4">2 </span><span class="s1">* </span><span class="s4">0.5</span>
        <span class="s2"># v[t2] = (a * (z[t2] - a) + a**2 * 0.5)</span>
        <span class="s1">v[t2] = (a * z[t2] - a**</span><span class="s4">2 </span><span class="s1">* </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">v[t3] = a * (c - z[t3])**</span><span class="s4">2 </span><span class="s1">/ (c - b) * (-</span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">v[t34] += a * (b + c - a) * </span><span class="s4">0.5</span>

        <span class="s0">if </span><span class="s1">z_isscalar:</span>
            <span class="s1">v = v[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s0">return </span><span class="s1">v</span>

    <span class="s0">def </span><span class="s1">psi(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">r&quot;&quot;&quot; 
        The psi function for Hampel's estimator 
 
        The analytic derivative of rho 
 
        Parameters 
        ---------- 
        z : array_like 
            1d array 
 
        Returns 
        ------- 
        psi : ndarray 
            psi(z) = z                            for \|z\| &lt;= a 
 
            psi(z) = a*sign(z)                    for a &lt; \|z\| &lt;= b 
 
            psi(z) = a*sign(z)*(c - \|z\|)/(c-b)    for b &lt; \|z\| &lt;= c 
 
            psi(z) = 0                            for \|z\| &gt; c 
        &quot;&quot;&quot;</span>
        <span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">c = self.a</span><span class="s0">, </span><span class="s1">self.b</span><span class="s0">, </span><span class="s1">self.c</span>

        <span class="s1">z_isscalar = np.isscalar(z)</span>
        <span class="s1">z = np.atleast_1d(z)</span>

        <span class="s1">t1</span><span class="s0">, </span><span class="s1">t2</span><span class="s0">, </span><span class="s1">t3 = self._subset(z)</span>
        <span class="s1">dt = np.promote_types(z.dtype</span><span class="s0">, </span><span class="s5">&quot;float&quot;</span><span class="s1">)</span>
        <span class="s1">v = np.zeros(z.shape</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
        <span class="s1">s = np.sign(z)</span>
        <span class="s1">za = np.abs(z)</span>

        <span class="s1">v[t1] = z[t1]</span>
        <span class="s1">v[t2] = a * s[t2]</span>
        <span class="s1">v[t3] = a * s[t3] * (c - za[t3]) / (c - b)</span>

        <span class="s0">if </span><span class="s1">z_isscalar:</span>
            <span class="s1">v = v[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s0">return </span><span class="s1">v</span>

    <span class="s0">def </span><span class="s1">weights(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">r&quot;&quot;&quot; 
        Hampel weighting function for the IRLS algorithm 
 
        The psi function scaled by z 
 
        Parameters 
        ---------- 
        z : array_like 
            1d array 
 
        Returns 
        ------- 
        weights : ndarray 
            weights(z) = 1                                for \|z\| &lt;= a 
 
            weights(z) = a/\|z\|                          for a &lt; \|z\| &lt;= b 
 
            weights(z) = a*(c - \|z\|)/(\|z\|*(c-b))      for b &lt; \|z\| &lt;= c 
 
            weights(z) = 0                                for \|z\| &gt; c 
        &quot;&quot;&quot;</span>
        <span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">c = self.a</span><span class="s0">, </span><span class="s1">self.b</span><span class="s0">, </span><span class="s1">self.c</span>

        <span class="s1">z_isscalar = np.isscalar(z)</span>
        <span class="s1">z = np.atleast_1d(z)</span>

        <span class="s1">t1</span><span class="s0">, </span><span class="s1">t2</span><span class="s0">, </span><span class="s1">t3 = self._subset(z)</span>

        <span class="s1">dt = np.promote_types(z.dtype</span><span class="s0">, </span><span class="s5">&quot;float&quot;</span><span class="s1">)</span>
        <span class="s1">v = np.zeros(z.shape</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
        <span class="s1">v[t1] = </span><span class="s4">1.0</span>
        <span class="s1">abs_z = np.abs(z)</span>
        <span class="s1">v[t2] = a / abs_z[t2]</span>
        <span class="s1">abs_zt3 = abs_z[t3]</span>
        <span class="s1">v[t3] = a * (c - abs_zt3) / (abs_zt3 * (c - b))</span>

        <span class="s0">if </span><span class="s1">z_isscalar:</span>
            <span class="s1">v = v[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s0">return </span><span class="s1">v</span>

    <span class="s0">def </span><span class="s1">psi_deriv(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">&quot;&quot;&quot;Derivative of psi function, second derivative of rho function. 
        &quot;&quot;&quot;</span>
        <span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">c = self.a</span><span class="s0">, </span><span class="s1">self.b</span><span class="s0">, </span><span class="s1">self.c</span>

        <span class="s1">z_isscalar = np.isscalar(z)</span>
        <span class="s1">z = np.atleast_1d(z)</span>

        <span class="s1">t1</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">t3 = self._subset(z)</span>

        <span class="s1">dt = np.promote_types(z.dtype</span><span class="s0">, </span><span class="s5">&quot;float&quot;</span><span class="s1">)</span>
        <span class="s1">d = np.zeros(z.shape</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
        <span class="s1">d[t1] = </span><span class="s4">1.0</span>
        <span class="s1">zt3 = z[t3]</span>
        <span class="s1">d[t3] = -(a * np.sign(zt3) * zt3) / (np.abs(zt3) * (c - b))</span>

        <span class="s0">if </span><span class="s1">z_isscalar:</span>
            <span class="s1">d = d[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s0">return </span><span class="s1">d</span>


<span class="s0">class </span><span class="s1">TukeyBiweight(RobustNorm):</span>
    <span class="s3">&quot;&quot;&quot; 
 
    Tukey's biweight function for M-estimation. 
 
    Parameters 
    ---------- 
    c : float, optional 
        The tuning constant for Tukey's Biweight.  The default value is 
        c = 4.685. 
 
    Notes 
    ----- 
    Tukey's biweight is sometime's called bisquare. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">c=</span><span class="s4">4.685</span><span class="s1">):</span>
        <span class="s1">self.c = c</span>

    <span class="s0">def </span><span class="s1">_subset(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">&quot;&quot;&quot; 
        Tukey's biweight is defined piecewise over the range of z 
        &quot;&quot;&quot;</span>
        <span class="s1">z = np.abs(np.asarray(z))</span>
        <span class="s0">return </span><span class="s1">np.less_equal(z</span><span class="s0">, </span><span class="s1">self.c)</span>

    <span class="s0">def </span><span class="s1">rho(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">r&quot;&quot;&quot; 
        The robust criterion function for Tukey's biweight estimator 
 
        Parameters 
        ---------- 
        z : array_like 
            1d array 
 
        Returns 
        ------- 
        rho : ndarray 
            rho(z) = -(1 - (z/c)**2)**3 * c**2/6.   for \|z\| &lt;= R 
 
            rho(z) = 0                              for \|z\| &gt; R 
        &quot;&quot;&quot;</span>
        <span class="s1">subset = self._subset(z)</span>
        <span class="s1">factor = self.c**</span><span class="s4">2 </span><span class="s1">/ </span><span class="s4">6.</span>
        <span class="s0">return </span><span class="s1">-(</span><span class="s4">1 </span><span class="s1">- (z / self.c)**</span><span class="s4">2</span><span class="s1">)**</span><span class="s4">3 </span><span class="s1">* subset * factor + factor</span>

    <span class="s0">def </span><span class="s1">psi(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">r&quot;&quot;&quot; 
        The psi function for Tukey's biweight estimator 
 
        The analytic derivative of rho 
 
        Parameters 
        ---------- 
        z : array_like 
            1d array 
 
        Returns 
        ------- 
        psi : ndarray 
            psi(z) = z*(1 - (z/c)**2)**2        for \|z\| &lt;= R 
 
            psi(z) = 0                           for \|z\| &gt; R 
        &quot;&quot;&quot;</span>

        <span class="s1">z = np.asarray(z)</span>
        <span class="s1">subset = self._subset(z)</span>
        <span class="s0">return </span><span class="s1">z * (</span><span class="s4">1 </span><span class="s1">- (z / self.c)**</span><span class="s4">2</span><span class="s1">)**</span><span class="s4">2 </span><span class="s1">* subset</span>

    <span class="s0">def </span><span class="s1">weights(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">r&quot;&quot;&quot; 
        Tukey's biweight weighting function for the IRLS algorithm 
 
        The psi function scaled by z 
 
        Parameters 
        ---------- 
        z : array_like 
            1d array 
 
        Returns 
        ------- 
        weights : ndarray 
            psi(z) = (1 - (z/c)**2)**2          for \|z\| &lt;= R 
 
            psi(z) = 0                          for \|z\| &gt; R 
        &quot;&quot;&quot;</span>

        <span class="s1">subset = self._subset(z)</span>
        <span class="s0">return </span><span class="s1">(</span><span class="s4">1 </span><span class="s1">- (z / self.c)**</span><span class="s4">2</span><span class="s1">)**</span><span class="s4">2 </span><span class="s1">* subset</span>

    <span class="s0">def </span><span class="s1">psi_deriv(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">&quot;&quot;&quot; 
        The derivative of Tukey's biweight psi function 
 
        Notes 
        ----- 
        Used to estimate the robust covariance matrix. 
        &quot;&quot;&quot;</span>
        <span class="s1">subset = self._subset(z)</span>
        <span class="s0">return </span><span class="s1">subset * ((</span><span class="s4">1 </span><span class="s1">- (z/self.c)**</span><span class="s4">2</span><span class="s1">)**</span><span class="s4">2</span>
                         <span class="s1">- (</span><span class="s4">4</span><span class="s1">*z**</span><span class="s4">2</span><span class="s1">/self.c**</span><span class="s4">2</span><span class="s1">) * (</span><span class="s4">1</span><span class="s1">-(z/self.c)**</span><span class="s4">2</span><span class="s1">))</span>


<span class="s0">class </span><span class="s1">MQuantileNorm(RobustNorm):</span>
    <span class="s3">&quot;&quot;&quot;M-quantiles objective function based on a base norm 
 
    This norm has the same asymmetric structure as the objective function 
    in QuantileRegression but replaces the L1 absolute value by a chosen 
    base norm. 
 
        rho_q(u) = abs(q - I(q &lt; 0)) * rho_base(u) 
 
    or, equivalently, 
 
        rho_q(u) = q * rho_base(u)  if u &gt;= 0 
        rho_q(u) = (1 - q) * rho_base(u)  if u &lt; 0 
 
 
    Parameters 
    ---------- 
    q : float 
        M-quantile, must be between 0 and 1 
    base_norm : RobustNorm instance 
        basic norm that is transformed into an asymmetric M-quantile norm 
 
    Notes 
    ----- 
    This is mainly for base norms that are not redescending, like HuberT or 
    LeastSquares. (See Jones for the relationship of M-quantiles to quantiles 
    in the case of non-redescending Norms.) 
 
    Expectiles are M-quantiles with the LeastSquares as base norm. 
 
    References 
    ---------- 
 
    .. [*] Bianchi, Annamaria, and Nicola Salvati. 2015. “Asymptotic Properties 
       and Variance Estimators of the M-Quantile Regression Coefficients 
       Estimators.” Communications in Statistics - Theory and Methods 44 (11): 
       2416–29. doi:10.1080/03610926.2013.791375. 
 
    .. [*] Breckling, Jens, and Ray Chambers. 1988. “M-Quantiles.” 
       Biometrika 75 (4): 761–71. doi:10.2307/2336317. 
 
    .. [*] Jones, M. C. 1994. “Expectiles and M-Quantiles Are Quantiles.” 
       Statistics &amp; Probability Letters 20 (2): 149–53. 
       doi:10.1016/0167-7152(94)90031-0. 
 
    .. [*] Newey, Whitney K., and James L. Powell. 1987. “Asymmetric Least 
       Squares Estimation and Testing.” Econometrica 55 (4): 819–47. 
       doi:10.2307/1911031. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">q</span><span class="s0">, </span><span class="s1">base_norm):</span>
        <span class="s1">self.q = q</span>
        <span class="s1">self.base_norm = base_norm</span>

    <span class="s0">def </span><span class="s1">_get_q(self</span><span class="s0">, </span><span class="s1">z):</span>

        <span class="s1">nobs = len(z)</span>
        <span class="s1">mask_neg = (z &lt; </span><span class="s4">0</span><span class="s1">)  </span><span class="s2"># if self.q &lt; 0.5 else (z &lt;= 0)  # maybe symmetric</span>
        <span class="s1">qq = np.empty(nobs)</span>
        <span class="s1">qq[mask_neg] = </span><span class="s4">1 </span><span class="s1">- self.q</span>
        <span class="s1">qq[~mask_neg] = self.q</span>
        <span class="s0">return </span><span class="s1">qq</span>

    <span class="s0">def </span><span class="s1">rho(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">&quot;&quot;&quot; 
        The robust criterion function for MQuantileNorm. 
 
        Parameters 
        ---------- 
        z : array_like 
            1d array 
 
        Returns 
        ------- 
        rho : ndarray 
        &quot;&quot;&quot;</span>
        <span class="s1">qq = self._get_q(z)</span>
        <span class="s0">return </span><span class="s1">qq * self.base_norm.rho(z)</span>

    <span class="s0">def </span><span class="s1">psi(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">&quot;&quot;&quot; 
        The psi function for MQuantileNorm estimator. 
 
        The analytic derivative of rho 
 
        Parameters 
        ---------- 
        z : array_like 
            1d array 
 
        Returns 
        ------- 
        psi : ndarray 
        &quot;&quot;&quot;</span>
        <span class="s1">qq = self._get_q(z)</span>
        <span class="s0">return </span><span class="s1">qq * self.base_norm.psi(z)</span>

    <span class="s0">def </span><span class="s1">weights(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">&quot;&quot;&quot; 
        MQuantileNorm weighting function for the IRLS algorithm 
 
        The psi function scaled by z, psi(z) / z 
 
        Parameters 
        ---------- 
        z : array_like 
            1d array 
 
        Returns 
        ------- 
        weights : ndarray 
        &quot;&quot;&quot;</span>
        <span class="s1">qq = self._get_q(z)</span>
        <span class="s0">return </span><span class="s1">qq * self.base_norm.weights(z)</span>

    <span class="s0">def </span><span class="s1">psi_deriv(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">''' 
        The derivative of MQuantileNorm function 
 
        Parameters 
        ---------- 
        z : array_like 
            1d array 
 
        Returns 
        ------- 
        psi_deriv : ndarray 
 
        Notes 
        ----- 
        Used to estimate the robust covariance matrix. 
        '''</span>
        <span class="s1">qq = self._get_q(z)</span>
        <span class="s0">return </span><span class="s1">qq * self.base_norm.psi_deriv(z)</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s3">&quot;&quot;&quot; 
        Returns the value of estimator rho applied to an input 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.rho(z)</span>


<span class="s0">def </span><span class="s1">estimate_location(a</span><span class="s0">, </span><span class="s1">scale</span><span class="s0">, </span><span class="s1">norm=</span><span class="s0">None, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">initial=</span><span class="s0">None,</span>
                      <span class="s1">maxiter=</span><span class="s4">30</span><span class="s0">, </span><span class="s1">tol=</span><span class="s4">1.0e-06</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    M-estimator of location using self.norm and a current 
    estimator of scale. 
 
    This iteratively finds a solution to 
 
    norm.psi((a-mu)/scale).sum() == 0 
 
    Parameters 
    ---------- 
    a : ndarray 
        Array over which the location parameter is to be estimated 
    scale : ndarray 
        Scale parameter to be used in M-estimator 
    norm : RobustNorm, optional 
        Robust norm used in the M-estimator.  The default is HuberT(). 
    axis : int, optional 
        Axis along which to estimate the location parameter.  The default is 0. 
    initial : ndarray, optional 
        Initial condition for the location parameter.  Default is None, which 
        uses the median of a. 
    niter : int, optional 
        Maximum number of iterations.  The default is 30. 
    tol : float, optional 
        Toleration for convergence.  The default is 1e-06. 
 
    Returns 
    ------- 
    mu : ndarray 
        Estimate of location 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">norm </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">norm = HuberT()</span>

    <span class="s0">if </span><span class="s1">initial </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">mu = np.median(a</span><span class="s0">, </span><span class="s1">axis)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">mu = initial</span>

    <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(maxiter):</span>
        <span class="s1">W = norm.weights((a-mu)/scale)</span>
        <span class="s1">nmu = np.sum(W*a</span><span class="s0">, </span><span class="s1">axis) / np.sum(W</span><span class="s0">, </span><span class="s1">axis)</span>
        <span class="s0">if </span><span class="s1">np.all(np.less(np.abs(mu - nmu)</span><span class="s0">, </span><span class="s1">scale * tol)):</span>
            <span class="s0">return </span><span class="s1">nmu</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">mu = nmu</span>
    <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;location estimator failed to converge in %d iterations&quot;</span>
                     <span class="s1">% maxiter)</span>
</pre>
</body>
</html>