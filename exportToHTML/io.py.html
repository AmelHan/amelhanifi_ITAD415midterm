<html>
<head>
<title>io.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
io.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Input/Output tools for working with binary data. 
 
The Stata input tools were originally written by Joe Presbrey as part of PyDTA. 
 
You can find more information here http://presbrey.mit.edu/PyDTA 
 
See also 
--------- 
numpy.lib.io 
&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">struct </span><span class="s2">import </span><span class="s1">unpack</span><span class="s2">, </span><span class="s1">calcsize</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>


<span class="s3">### Helper classes for StataReader ###</span>

<span class="s2">class </span><span class="s1">_StataMissingValue(object):</span>
    <span class="s0">&quot;&quot;&quot; 
    An observation's missing value. 
 
    Parameters 
    ----------- 
    offset  
    value 
 
    Attributes 
    ---------- 
    string 
    value 
     
    Notes 
    ----- 
    More information: &lt;http://www.stata.com/help.cgi?missing&gt; 
    &quot;&quot;&quot; </span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s1">self._value = value</span>
        <span class="s2">if </span><span class="s1">type(value) </span><span class="s2">is </span><span class="s1">int </span><span class="s2">or </span><span class="s1">type(value) </span><span class="s2">is </span><span class="s1">long:</span>
            <span class="s1">self._str = value-offset </span><span class="s2">is </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">\</span>
                    <span class="s5">'.' </span><span class="s2">or </span><span class="s1">(</span><span class="s5">'.' </span><span class="s1">+ chr(value-offset+</span><span class="s4">96</span><span class="s1">))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._str = </span><span class="s5">'.'</span>
    <span class="s1">string = property(</span><span class="s2">lambda </span><span class="s1">self: self._str</span><span class="s2">, </span><span class="s1">doc=</span><span class="s5">&quot;The Stata representation of </span><span class="s2">\ 
</span><span class="s5">the missing value: '.', '.a'..'.z'&quot;</span><span class="s1">)</span>
    <span class="s1">value = property(</span><span class="s2">lambda </span><span class="s1">self: self._value</span><span class="s2">, </span><span class="s1">doc=</span><span class="s5">'The binary representation </span><span class="s2">\ 
</span><span class="s5">of the missing value.'</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__str__(self): </span><span class="s2">return </span><span class="s1">self._str</span>
    <span class="s1">__str__.__doc__ = string.__doc__</span>

<span class="s2">class </span><span class="s1">_StataVariable(object):</span>
    <span class="s0">&quot;&quot;&quot; 
    A dataset variable.  Not intended for public use. 
 
    Parameters 
    ---------- 
    variable_data 
 
    Attributes 
    ----------- 
    format : str 
        Stata variable format.  See notes for more information. 
    index : int 
        Zero-index column index of variable. 
    label : str 
        Data Label 
    name : str 
        Variable name 
    type : str 
        Stata data type.  See notes for more information. 
    value_format : str 
        Value format. 
 
    Notes 
    ----- 
    More information: http://www.stata.com/help.cgi?format 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">variable_data): </span>
        <span class="s1">self._data = variable_data</span>

    <span class="s2">def </span><span class="s1">__int__(self): </span>
        <span class="s2">return </span><span class="s1">self.index</span>

    <span class="s2">def </span><span class="s1">__str__(self): </span>
        <span class="s2">return </span><span class="s1">self.name</span>
    <span class="s1">index = property(</span><span class="s2">lambda </span><span class="s1">self: self._data[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">doc=</span><span class="s5">'the variable</span><span class="s2">\'</span><span class="s5">s index </span><span class="s2">\ 
</span><span class="s5">within an observation'</span><span class="s1">)</span>
    <span class="s1">type = property(</span><span class="s2">lambda </span><span class="s1">self: self._data[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">doc=</span><span class="s5">'the data type of </span><span class="s2">\ 
</span><span class="s5">variable</span><span class="s2">\n\n</span><span class="s5">Possible types are:</span><span class="s2">\n</span><span class="s5">{1..244:string, b:byte, h:int, l:long, </span><span class="s2">\ 
</span><span class="s5">f:float, d:double)'</span><span class="s1">)</span>
    <span class="s1">name = property(</span><span class="s2">lambda </span><span class="s1">self: self._data[</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">doc=</span><span class="s5">'the name of the variable'</span><span class="s1">)</span>
    <span class="s1">format = property(</span><span class="s2">lambda </span><span class="s1">self: self._data[</span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">doc=</span><span class="s5">'the variable</span><span class="s2">\'</span><span class="s5">s Stata </span><span class="s2">\ 
</span><span class="s5">format'</span><span class="s1">)</span>
    <span class="s1">value_format = property(</span><span class="s2">lambda </span><span class="s1">self: self._data[</span><span class="s4">5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">doc=</span><span class="s5">'the variable</span><span class="s2">\'</span><span class="s5">s </span><span class="s2">\ 
</span><span class="s5">value format'</span><span class="s1">)</span>
    <span class="s1">label = property(</span><span class="s2">lambda </span><span class="s1">self: self._data[</span><span class="s4">6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">doc=</span><span class="s5">'the variable</span><span class="s2">\'</span><span class="s5">s label'</span><span class="s1">)</span>
    <span class="s1">__int__.__doc__ = index.__doc__</span>
    <span class="s1">__str__.__doc__ = name.__doc__</span>

<span class="s2">class </span><span class="s1">StataReader(object):</span>
    <span class="s0">&quot;&quot;&quot; 
    Stata .dta file reader. 
 
    Provides methods to return the metadata of a Stata .dta file and 
    a generator for the data itself. 
     
    Parameters 
    ---------- 
    file : file-like 
        A file-like object representing a Stata .dta file. 
     
    missing_values : bool 
        If missing_values is True, parse missing_values and return a  
        Missing Values object instead of None. 
     
    See also 
    -------- 
    scikits.statsmodels.lib.io.genfromdta 
 
    Notes 
    ----- 
    This is known only to work on file formats 113 (Stata 8/9) and 114  
    (Stata 10/11).  Needs to be tested on older versions.   
    Known not to work on format 104, 108. 
 
    For more information about the .dta format see 
    http://www.stata.com/help.cgi?dta 
    http://www.stata.com/help.cgi?dta_113 
    &quot;&quot;&quot;</span>

    <span class="s1">_header = {}</span>
    <span class="s1">_data_location = </span><span class="s4">0</span>
    <span class="s1">_col_sizes = ()</span>
    <span class="s1">_has_string_data = </span><span class="s2">False</span>
    <span class="s1">_missing_values = </span><span class="s2">False</span>
    <span class="s1">TYPE_MAP = range(</span><span class="s4">251</span><span class="s1">)+list(</span><span class="s5">'bhlfd'</span><span class="s1">)</span>
    <span class="s1">MISSING_VALUES = { </span><span class="s5">'b'</span><span class="s1">: (-</span><span class="s4">127</span><span class="s2">,</span><span class="s4">100</span><span class="s1">)</span><span class="s2">, </span><span class="s5">'h'</span><span class="s1">: (-</span><span class="s4">32767</span><span class="s2">, </span><span class="s4">32740</span><span class="s1">)</span><span class="s2">, </span><span class="s5">'l'</span><span class="s1">: </span>
            <span class="s1">(-</span><span class="s4">2147483647</span><span class="s2">, </span><span class="s4">2147483620</span><span class="s1">)</span><span class="s2">, </span><span class="s5">'f'</span><span class="s1">: (-</span><span class="s4">1.701e+38</span><span class="s2">, </span><span class="s1">+</span><span class="s4">1.701e+38</span><span class="s1">)</span><span class="s2">, </span><span class="s5">'d'</span><span class="s1">: </span>
            <span class="s1">(-</span><span class="s4">1.798e+308</span><span class="s2">, </span><span class="s1">+</span><span class="s4">8.988e+307</span><span class="s1">) }</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">fname</span><span class="s2">, </span><span class="s1">missing_values=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">self._missing_values = missing_values</span>
        <span class="s1">self._parse_header(fname)</span>

    <span class="s2">def </span><span class="s1">file_headers(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns all .dta file headers. 
 
        out: dict 
            Has keys typlist, data_label, lbllist, varlist, nvar, filetype, 
            ds_format, nobs, fmtlist, vlblist, time_stamp, srtlist, byteorder 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._header</span>

    <span class="s2">def </span><span class="s1">file_format(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns the file format. 
         
        Returns 
        ------- 
        out : int 
 
        Notes 
        ----- 
        Format 113: Stata 8/9 
        Format 114: Stata 10/11 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._header[</span><span class="s5">'ds_format'</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">file_label(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns the dataset's label. 
 
        Returns 
        ------ 
        out: string 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._header[</span><span class="s5">'data_label'</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">file_timestamp(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns the date and time Stata recorded on last file save. 
 
        Returns 
        ------- 
        out : str 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._header[</span><span class="s5">'time_stamp'</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">variables(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns a list of the dataset's StataVariables objects. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">map(_StataVariable</span><span class="s2">, </span><span class="s1">zip(range(self._header[</span><span class="s5">'nvar'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">self._header[</span><span class="s5">'typlist'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self._header[</span><span class="s5">'varlist'</span><span class="s1">]</span><span class="s2">, </span>
            <span class="s1">self._header[</span><span class="s5">'srtlist'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">self._header[</span><span class="s5">'fmtlist'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self._header[</span><span class="s5">'lbllist'</span><span class="s1">]</span><span class="s2">, </span>
            <span class="s1">self._header[</span><span class="s5">'vlblist'</span><span class="s1">]))</span>

    <span class="s2">def </span><span class="s1">dataset(self</span><span class="s2">, </span><span class="s1">as_dict=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns a Python generator object for iterating over the dataset. 
         
 
        Parameters 
        ---------- 
        as_dict : bool, optional 
            If as_dict is True, yield each row of observations as a dict. 
            If False, yields each row of observations as a list. 
 
        Returns 
        ------- 
        Generator object for iterating over the dataset.  Yields each row of 
        observations as a list by default. 
 
        Notes 
        ----- 
        If missing_values is True during instantiation of StataReader then  
        observations with _StataMissingValue(s) are not filtered and should  
        be handled by your applcation. 
        &quot;&quot;&quot;</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self._file.seek(self._data_location)</span>
        <span class="s2">except </span><span class="s1">Exception:</span>
            <span class="s2">pass</span>

        <span class="s2">if </span><span class="s1">as_dict:</span>
            <span class="s1">vars = map(str</span><span class="s2">, </span><span class="s1">self.variables())</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(self)):</span>
                <span class="s2">yield </span><span class="s1">dict(zip(vars</span><span class="s2">, </span><span class="s1">self._next()))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self._header[</span><span class="s5">'nobs'</span><span class="s1">]):</span>
                <span class="s2">yield </span><span class="s1">self._next()</span>

    <span class="s3">### Python special methods</span>

    <span class="s2">def </span><span class="s1">__len__(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the number of observations in the dataset. 
 
        This value is taken directly from the header and includes observations 
        with missing values. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._header[</span><span class="s5">'nobs'</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">__getitem__(self</span><span class="s2">, </span><span class="s1">k):</span>
        <span class="s0">&quot;&quot;&quot; 
        Seek to an observation indexed k in the file and return it, ordered 
        by Stata's output to the .dta file. 
 
        k is zero-indexed.  Prefer using R.data() for performance. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">(type(k) </span><span class="s2">is </span><span class="s1">int </span><span class="s2">or </span><span class="s1">type(k) </span><span class="s2">is </span><span class="s1">long) </span><span class="s2">or </span><span class="s1">k &lt; </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">k &gt; len(self)-</span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">IndexError(k)</span>
        <span class="s1">loc = self._data_location + sum(self._col_size()) * k</span>
        <span class="s2">if </span><span class="s1">self._file.tell() != loc:</span>
            <span class="s1">self._file.seek(loc)</span>
        <span class="s2">return </span><span class="s1">self._next()</span>

    <span class="s3">### Private methods</span>

    <span class="s2">def </span><span class="s1">_null_terminate(self</span><span class="s2">, </span><span class="s1">s):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">s.lstrip(</span><span class="s5">'</span><span class="s2">\x00</span><span class="s5">'</span><span class="s1">)[:s.index(</span><span class="s5">'</span><span class="s2">\x00</span><span class="s5">'</span><span class="s1">)]</span>
        <span class="s2">except </span><span class="s1">Exception:</span>
            <span class="s2">return </span><span class="s1">s</span>

    <span class="s2">def </span><span class="s1">_parse_header(self</span><span class="s2">, </span><span class="s1">file_object):</span>
        <span class="s1">self._file = file_object</span>

        <span class="s3"># parse headers</span>
        <span class="s1">self._header[</span><span class="s5">'ds_format'</span><span class="s1">] = unpack(</span><span class="s5">'b'</span><span class="s2">, </span><span class="s1">self._file.read(</span><span class="s4">1</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">self._header[</span><span class="s5">'ds_format'</span><span class="s1">] </span><span class="s2">not in </span><span class="s1">[</span><span class="s4">113</span><span class="s2">,</span><span class="s4">114</span><span class="s1">]:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s2">, </span><span class="s5">&quot;Only file formats 113 and 114 (Stata 9, 10, 11)</span><span class="s2">\ 
 </span><span class="s5">are supported.  Got format %s.  Please report if you think this error is </span><span class="s2">\ 
</span><span class="s5">incorrect.&quot; </span><span class="s1">% self._header[</span><span class="s5">'ds_format'</span><span class="s1">]</span>
        <span class="s1">byteorder = self._header[</span><span class="s5">'byteorder'</span><span class="s1">] = unpack(</span><span class="s5">'b'</span><span class="s2">, </span>
                <span class="s1">self._file.read(</span><span class="s4">1</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">]==</span><span class="s4">0x1 </span><span class="s2">and </span><span class="s5">'&gt;' </span><span class="s2">or </span><span class="s5">'&lt;'</span>
        <span class="s1">self._header[</span><span class="s5">'filetype'</span><span class="s1">] = unpack(</span><span class="s5">'b'</span><span class="s2">, </span><span class="s1">self._file.read(</span><span class="s4">1</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">self._file.read(</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">nvar = self._header[</span><span class="s5">'nvar'</span><span class="s1">] = unpack(byteorder+</span><span class="s5">'h'</span><span class="s2">, </span>
                <span class="s1">self._file.read(</span><span class="s4">2</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self._header[</span><span class="s5">'ds_format'</span><span class="s1">] &lt; </span><span class="s4">114</span><span class="s1">:</span>
            <span class="s1">self._header[</span><span class="s5">'nobs'</span><span class="s1">] = unpack(byteorder+</span><span class="s5">'i'</span><span class="s2">, </span><span class="s1">self._file.read(</span><span class="s4">4</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._header[</span><span class="s5">'nobs'</span><span class="s1">] = unpack(byteorder+</span><span class="s5">'i'</span><span class="s2">, </span><span class="s1">self._file.read(</span><span class="s4">4</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">self._header[</span><span class="s5">'data_label'</span><span class="s1">] = self._null_terminate(self._file.read(</span><span class="s4">81</span><span class="s1">))</span>
        <span class="s1">self._header[</span><span class="s5">'time_stamp'</span><span class="s1">] = self._null_terminate(self._file.read(</span><span class="s4">18</span><span class="s1">))</span>

        <span class="s3"># parse descriptors</span>
        <span class="s1">self._header[</span><span class="s5">'typlist'</span><span class="s1">] = [self.TYPE_MAP[ord(self._file.read(</span><span class="s4">1</span><span class="s1">))] \</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(nvar)]</span>
        <span class="s1">self._header[</span><span class="s5">'varlist'</span><span class="s1">] = [self._null_terminate(self._file.read(</span><span class="s4">33</span><span class="s1">)) \</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(nvar)]</span>
        <span class="s1">self._header[</span><span class="s5">'srtlist'</span><span class="s1">] = unpack(byteorder+(</span><span class="s5">'h'</span><span class="s1">*(nvar+</span><span class="s4">1</span><span class="s1">))</span><span class="s2">, </span>
                <span class="s1">self._file.read(</span><span class="s4">2</span><span class="s1">*(nvar+</span><span class="s4">1</span><span class="s1">)))[:-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self._header[</span><span class="s5">'ds_format'</span><span class="s1">] &lt;= </span><span class="s4">113</span><span class="s1">:</span>
            <span class="s1">self._header[</span><span class="s5">'fmtlist'</span><span class="s1">] = \</span>
                    <span class="s1">[self._null_terminate(self._file.read(</span><span class="s4">12</span><span class="s1">)) \</span>
                    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(nvar)]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._header[</span><span class="s5">'fmtlist'</span><span class="s1">] = \</span>
                    <span class="s1">[self._null_terminate(self._file.read(</span><span class="s4">49</span><span class="s1">)) \</span>
                    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(nvar)]</span>
        <span class="s1">self._header[</span><span class="s5">'lbllist'</span><span class="s1">] = [self._null_terminate(self._file.read(</span><span class="s4">33</span><span class="s1">)) \</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(nvar)]</span>
        <span class="s1">self._header[</span><span class="s5">'vlblist'</span><span class="s1">] = [self._null_terminate(self._file.read(</span><span class="s4">81</span><span class="s1">)) \</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(nvar)]</span>

        <span class="s3"># ignore expansion fields</span>
<span class="s3"># When reading, read five bytes; the last four bytes now tell you the size of</span>
<span class="s3"># the next read, which you discard.  You then continue like this until you</span>
<span class="s3"># read 5 bytes of zeros. </span>
<span class="s3"># TODO: The way I read this is that they both should be zero, but that's </span>
<span class="s3"># not what we get.</span>

        <span class="s2">while True</span><span class="s1">:</span>
            <span class="s1">data_type = unpack(byteorder+</span><span class="s5">'b'</span><span class="s2">, </span><span class="s1">self._file.read(</span><span class="s4">1</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">data_len = unpack(byteorder+</span><span class="s5">'i'</span><span class="s2">, </span><span class="s1">self._file.read(</span><span class="s4">4</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">data_type == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s2">break</span>
            <span class="s1">self._file.read(data_len)</span>
        
        <span class="s3"># other state vars</span>
        <span class="s1">self._data_location = self._file.tell()</span>
        <span class="s1">self._has_string_data = len(filter(</span><span class="s2">lambda </span><span class="s1">x: type(x) </span><span class="s2">is </span><span class="s1">int</span><span class="s2">, </span>
            <span class="s1">self._header[</span><span class="s5">'typlist'</span><span class="s1">])) &gt; </span><span class="s4">0</span>
        <span class="s1">self._col_size()</span>

    <span class="s2">def </span><span class="s1">_calcsize(self</span><span class="s2">, </span><span class="s1">fmt):</span>
        <span class="s2">return </span><span class="s1">type(fmt) </span><span class="s2">is </span><span class="s1">int </span><span class="s2">and </span><span class="s1">fmt </span><span class="s2">or </span><span class="s1">\</span>
                <span class="s1">calcsize(self._header[</span><span class="s5">'byteorder'</span><span class="s1">]+fmt)</span>

    <span class="s2">def </span><span class="s1">_col_size(self</span><span class="s2">, </span><span class="s1">k = </span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Calculate size of a data record.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len(self._col_sizes) == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">self._col_sizes = map(</span><span class="s2">lambda </span><span class="s1">x: self._calcsize(x)</span><span class="s2">, </span>
                    <span class="s1">self._header[</span><span class="s5">'typlist'</span><span class="s1">])</span>
        <span class="s2">if </span><span class="s1">k == </span><span class="s2">None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._col_sizes</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._col_sizes[k]</span>

    <span class="s2">def </span><span class="s1">_unpack(self</span><span class="s2">, </span><span class="s1">fmt</span><span class="s2">, </span><span class="s1">byt):</span>
        <span class="s1">d = unpack(self._header[</span><span class="s5">'byteorder'</span><span class="s1">]+fmt</span><span class="s2">, </span><span class="s1">byt)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">fmt[-</span><span class="s4">1</span><span class="s1">] </span><span class="s2">in </span><span class="s1">self.MISSING_VALUES:</span>
            <span class="s1">nmin</span><span class="s2">, </span><span class="s1">nmax = self.MISSING_VALUES[fmt[-</span><span class="s4">1</span><span class="s1">]]</span>
            <span class="s2">if </span><span class="s1">d &lt; nmin </span><span class="s2">or </span><span class="s1">d &gt; nmax:</span>
                <span class="s2">if </span><span class="s1">self._missing_values:</span>
                    <span class="s2">return </span><span class="s1">_StataMissingValue(nmax</span><span class="s2">, </span><span class="s1">d)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">return None</span>
        <span class="s2">return </span><span class="s1">d</span>

    <span class="s2">def </span><span class="s1">_next(self):</span>
        <span class="s1">typlist = self._header[</span><span class="s5">'typlist'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self._has_string_data:</span>
            <span class="s1">data = [</span><span class="s2">None</span><span class="s1">]*self._header[</span><span class="s5">'nvar'</span><span class="s1">]</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(data)):</span>
                <span class="s2">if </span><span class="s1">type(typlist[i]) </span><span class="s2">is </span><span class="s1">int:</span>
                    <span class="s1">data[i] = self._null_terminate(self._file.read(typlist[i]))</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">data[i] = self._unpack(typlist[i]</span><span class="s2">, </span>
                            <span class="s1">self._file.read(self._col_size(i)))</span>
            <span class="s2">return </span><span class="s1">data</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">map(</span><span class="s2">lambda </span><span class="s1">i: self._unpack(typlist[i]</span><span class="s2">, </span>
                <span class="s1">self._file.read(self._col_size(i)))</span><span class="s2">, </span>
                <span class="s1">range(self._header[</span><span class="s5">'nvar'</span><span class="s1">]))</span>

<span class="s2">def </span><span class="s1">genfromdta(fname</span><span class="s2">, </span><span class="s1">excludelist=</span><span class="s2">None, </span><span class="s1">missing_flt=-</span><span class="s4">999.</span><span class="s2">, </span><span class="s1">missing_str=</span><span class="s5">&quot;&quot;</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns an ndarray from a Stata .dta file. 
 
    Parameters 
    ---------- 
    fname 
    missing_values 
    excludelist 
    missing_flt 
    missing_str 
 
    Notes 
    ------ 
    If the parser encounters a format that it doesn't understand, then it will 
    convert to string.  This may be the case with date formats. 
    &quot;&quot;&quot;</span>
<span class="s3">#TODO: extend to get data from online</span>
    <span class="s2">if </span><span class="s1">isinstance(fname</span><span class="s2">, </span><span class="s1">basestring):</span>
        <span class="s1">fhd = StataReader(open(fname</span><span class="s2">, </span><span class="s5">'r'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">missing_values=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s2">elif not </span><span class="s1">hasattr(fname</span><span class="s2">, </span><span class="s5">'read'</span><span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s5">&quot;The input should be a string or a filehandle. &quot;</span><span class="s1">\</span>
                <span class="s5">&quot;(got %s instead)&quot; </span><span class="s1">% type(fname))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">fhd = StataReader(fname</span><span class="s2">, </span><span class="s1">missing_values=</span><span class="s2">False</span><span class="s1">)</span>
<span class="s3">#    validate_names = np.lib._iotools.NameValidator(excludelist=excludelist,</span>
<span class="s3">#                                    deletechars=deletechars,</span>
<span class="s3">#                                    case_sensitive=case_sensitive)</span>
    

<span class="s3">#TODO: does this need to handle the byteorder?</span>
    <span class="s1">header = fhd.file_headers()</span>
<span class="s3">#    types = header['typlist'] # typemap in StataReader?</span>
    <span class="s1">nobs = header[</span><span class="s5">'nobs'</span><span class="s1">]</span>
    <span class="s1">numvars = header[</span><span class="s5">'nvar'</span><span class="s1">]</span>
    <span class="s1">varnames = header[</span><span class="s5">'varlist'</span><span class="s1">]</span>
    <span class="s1">dataname = header[</span><span class="s5">'data_label'</span><span class="s1">]</span>
    <span class="s1">labels = header[</span><span class="s5">'vlblist'</span><span class="s1">] </span><span class="s3"># labels are thrown away unless DataArray</span>
                               <span class="s3"># type is used</span>
    <span class="s1">data = np.zeros((nobs</span><span class="s2">,</span><span class="s1">numvars))</span>
    <span class="s1">stata_dta = fhd.dataset()</span>

    <span class="s3"># build dtype from stata formats</span>
    <span class="s3"># see http://www.stata.com/help.cgi?format</span>
    <span class="s3"># This converts all of these to float64 </span>
    <span class="s3"># all time and strings are converted to strings</span>
    <span class="s3">#TODO: put these notes in the docstring</span>
    <span class="s3">#TODO: need to write a time parser</span>
    <span class="s1">to_flt = [</span><span class="s5">'g'</span><span class="s2">,</span><span class="s5">'e'</span><span class="s2">,</span><span class="s5">'f'</span><span class="s2">,</span><span class="s5">'h'</span><span class="s2">,</span><span class="s5">'gc'</span><span class="s2">,</span><span class="s5">'fc'</span><span class="s2">, </span><span class="s5">'x'</span><span class="s2">, </span><span class="s5">'l'</span><span class="s1">] </span><span class="s3"># how to deal with x</span>
                                                   <span class="s3"># and double-precision</span>
    <span class="s1">to_str = [</span><span class="s5">'s'</span><span class="s1">]</span>
    <span class="s2">if </span><span class="s4">1</span><span class="s1">:</span><span class="s3">#    if not convert_time: #time parser not written</span>
        <span class="s1">to_str.append(</span><span class="s5">'t'</span><span class="s1">)</span>
    <span class="s1">flt_or_str = </span><span class="s2">lambda </span><span class="s1">x: ((x.lower()[-</span><span class="s4">1</span><span class="s1">] </span><span class="s2">in </span><span class="s1">to_str </span><span class="s2">and </span><span class="s5">'s'</span><span class="s1">) </span><span class="s2">or </span><span class="s1">\</span>
            <span class="s1">(x.lower()[-</span><span class="s4">1</span><span class="s1">] </span><span class="s2">in </span><span class="s1">to_flt </span><span class="s2">and </span><span class="s5">'f8'</span><span class="s1">)) </span><span class="s2">or </span><span class="s5">'s'</span>
    <span class="s3">#TODO: this is surely not the best way to handle data types</span>
    <span class="s1">convert_missing = {</span><span class="s5">'f8' </span><span class="s1">: missing_flt</span><span class="s2">, </span><span class="s5">'s' </span><span class="s1">: missing_str}</span>
    <span class="s3">#TODO: needs to be made more flexible when change types</span>
    <span class="s1">fmt = [_.split(</span><span class="s5">'.'</span><span class="s1">)[-</span><span class="s4">1</span><span class="s1">] </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">header[</span><span class="s5">'fmtlist'</span><span class="s1">]]</span>
    <span class="s1">remove_comma = [fmt.index(_) </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">fmt </span><span class="s2">if </span><span class="s5">'c' </span><span class="s2">in </span><span class="s1">_]</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(fmt)): </span><span class="s3"># remove commas and convert any time types to 't'</span>
        <span class="s2">if </span><span class="s5">'t' </span><span class="s2">in </span><span class="s1">fmt[i]:</span>
            <span class="s1">fmt[i] = </span><span class="s5">'t'</span>
        <span class="s2">if </span><span class="s1">i </span><span class="s2">in </span><span class="s1">remove_comma:</span>
            <span class="s1">fmt[i] = fmt[i][:-</span><span class="s4">1</span><span class="s1">] </span><span class="s3"># needs to be changed if time doesn't req.</span>
                                 <span class="s3"># loop</span>
    <span class="s1">formats = map(flt_or_str</span><span class="s2">, </span><span class="s1">fmt)</span>
<span class="s3"># have to go through the whole file first to find string lengths?</span>
<span class="s3">#TODO: this is going to be miserably slow</span>
<span class="s3"># have a closer look at numpy.genfromtxt and revisit this</span>
    <span class="s1">first_list = []</span>
    <span class="s2">for </span><span class="s1">rownum</span><span class="s2">,</span><span class="s1">line </span><span class="s2">in </span><span class="s1">enumerate(stata_dta):</span>
        <span class="s3"># doesn't handle missing value objects</span>
        <span class="s3"># Untested for commas and string missing</span>
        <span class="s3"># None will only work without missing value object.</span>
        <span class="s2">if None in </span><span class="s1">line </span><span class="s2">and not </span><span class="s1">remove_comma:</span>
            <span class="s2">for </span><span class="s1">val </span><span class="s2">in </span><span class="s1">line:</span>
                <span class="s2">if </span><span class="s1">val </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">line[line.index(val)] = convert_missing[\</span>
                            <span class="s1">formats[line.index(val)]]</span>
        <span class="s2">if None in </span><span class="s1">line </span><span class="s2">and </span><span class="s1">remove_comma:</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s2">,</span><span class="s1">val </span><span class="s2">in </span><span class="s1">enumerate(line):</span>
                <span class="s2">if </span><span class="s1">val </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">line[i] = convert_missing[formats[i]]</span>
                <span class="s2">elif </span><span class="s1">i </span><span class="s2">in </span><span class="s1">remove_comma:</span>
                    <span class="s1">line[i] = </span><span class="s5">''</span><span class="s1">.join(line[i].split(</span><span class="s5">','</span><span class="s1">))</span>
                    <span class="s2">if </span><span class="s1">formats[i] == </span><span class="s5">'f8'</span><span class="s1">:</span>
                        <span class="s1">line[i] = float(line[i])</span>
        <span class="s2">if </span><span class="s1">remove_comma </span><span class="s2">and not None in </span><span class="s1">line:</span>
            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">remove_comma:</span>
                <span class="s1">line[j] = </span><span class="s5">''</span><span class="s1">.join(line[j].split(</span><span class="s5">','</span><span class="s1">))</span>
                <span class="s2">if </span><span class="s1">formats[j] == </span><span class="s5">'f8'</span><span class="s1">: </span><span class="s3"># change when change f8</span>
                    <span class="s1">line[j] = float(line[j])</span>

        <span class="s1">first_list.append(line)</span>
<span class="s3">#TODO: add informative error message similar to genfromtxt</span>
<span class="s3"># Get string lengths</span>
    <span class="s1">strcolidx = []</span>
    <span class="s2">if </span><span class="s5">'s' </span><span class="s2">in </span><span class="s1">formats:</span>
        <span class="s2">for </span><span class="s1">col</span><span class="s2">,</span><span class="s1">type </span><span class="s2">in </span><span class="s1">enumerate(formats):</span>
            <span class="s2">if </span><span class="s1">type == </span><span class="s5">'s'</span><span class="s1">:</span>
                <span class="s1">strcolidx.append(col)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">strcolidx:</span>
            <span class="s1">formats[i] = </span><span class="s5">&quot;a%i&quot; </span><span class="s1">% max(len(str(row[i])) </span><span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">first_list)</span>
    <span class="s1">dt = zip(varnames</span><span class="s2">, </span><span class="s1">formats) </span><span class="s3"># make dtype again</span>
    <span class="s1">data = np.zeros((nobs)</span><span class="s2">, </span><span class="s1">dtype=dt) </span><span class="s3"># init final array</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s2">,</span><span class="s1">row </span><span class="s2">in </span><span class="s1">enumerate(first_list):</span>
        <span class="s1">data[i] = tuple(row)</span>

<span class="s3">#TODO: make it possible to return plain array if all 'f8' for example</span>
    <span class="s2">return </span><span class="s1">data</span>

<span class="s2">if </span><span class="s1">__name__==</span><span class="s5">&quot;__main__&quot;</span><span class="s1">:</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">data = genfromdta(</span><span class="s5">'./fullauto.dta'</span><span class="s1">)</span>
    <span class="s2">except</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ImportError</span><span class="s2">, </span><span class="s5">&quot;You don't have the Stata test file downloaded into</span><span class="s2">\ 
 </span><span class="s5">this directory.  It's not distributed but you can download it here </span><span class="s2">\ 
</span><span class="s5">http://www.stata-press.com/data/r11/fullauto.dta.&quot;</span>
</pre>
</body>
</html>