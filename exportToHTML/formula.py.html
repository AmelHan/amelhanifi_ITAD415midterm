<html>
<head>
<title>formula.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
formula.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Provides the basic classes needed to specify statistical models. 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">copy</span>
<span class="s2">import </span><span class="s1">types</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">try</span><span class="s1">:</span>
    <span class="s1">set</span>
<span class="s2">except </span><span class="s1">NameError:</span>
    <span class="s2">from </span><span class="s1">sets </span><span class="s2">import </span><span class="s1">Set </span><span class="s2">as </span><span class="s1">set</span>

<span class="s1">__docformat__ = </span><span class="s3">'restructuredtext'</span>

<span class="s1">default_namespace = {}</span>

<span class="s2">class </span><span class="s1">Term(object):</span>
    <span class="s0">&quot;&quot;&quot; 
    This class is very simple: it is just a named term in a model formula. 
 
    It is also callable: by default it namespace[self.name], where namespace 
    defaults to formula.default_namespace. 
    When called in an instance of formula, 
    the namespace used is that formula's namespace. 
 
    Inheritance of the namespace under +,*,- operations: 
    ---------------------------------------------------- 
 
    By default, the namespace is empty, which means it must be 
    specified before evaluating the design matrix.  
 
    When it is unambiguous, the namespaces of objects are derived from the 
    context.  
 
    Rules: 
    ------ 
 
    i) &quot;X * I&quot;, &quot;X + I&quot;, &quot;X**i&quot;: these inherit X's namespace 
    ii) &quot;F.main_effect()&quot;: this inherits the Factor F's namespace 
    iii) &quot;A-B&quot;: this inherits A's namespace 
    iv) if A.namespace == B.namespace, then A+B inherits this namespace 
    v) if A.namespace == B.namespace, then A*B inherits this namespace 
 
    Equality of namespaces: 
    ----------------------- 
 
    This is done by comparing the namespaces directly, if 
    an exception is raised in the check of equality, they are 
    assumed not to be equal. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__pow__(self</span><span class="s2">, </span><span class="s1">power):</span>
        <span class="s0">&quot;&quot;&quot; 
        Raise the quantitative term's values to an integer power, i.e. 
        polynomial. 
        &quot;&quot;&quot;</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">power = float(power)</span>
        <span class="s2">except</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s2">, </span><span class="s3">'expecting a float'</span>

        <span class="s2">if </span><span class="s1">power == int(power):</span>
            <span class="s1">name = </span><span class="s3">'%s^%d' </span><span class="s1">% (self.name</span><span class="s2">, </span><span class="s1">int(power))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">name = </span><span class="s3">'%s^%0.2f' </span><span class="s1">% (self.name</span><span class="s2">, </span><span class="s1">power)</span>

        <span class="s1">value = Quantitative(name</span><span class="s2">, </span><span class="s1">func=self</span><span class="s2">, </span><span class="s1">transform=</span><span class="s2">lambda </span><span class="s1">x: np.power(x</span><span class="s2">, </span><span class="s1">power))</span>
        <span class="s1">value.power = power</span>
        <span class="s1">value.namespace = self.namespace</span>
        <span class="s2">return </span><span class="s1">value</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">func=</span><span class="s2">None, </span><span class="s1">termname=</span><span class="s2">None</span><span class="s1">):</span>

        <span class="s1">self.name = name</span>
        <span class="s1">self.__namespace = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">termname </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.termname = name</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.termname = termname</span>

        <span class="s2">if </span><span class="s1">type(self.termname) </span><span class="s2">is not </span><span class="s1">types.StringType:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s2">, </span><span class="s3">'expecting a string for termname'</span>
        <span class="s2">if </span><span class="s1">func:</span>
            <span class="s1">self.func = func</span>

    <span class="s4"># Namespace in which self.name will be looked up in, if needed</span>

    <span class="s2">def </span><span class="s1">_get_namespace(self):</span>
        <span class="s2">if </span><span class="s1">isinstance(self.__namespace</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
            <span class="s2">return </span><span class="s1">self.__namespace</span>
        <span class="s2">else</span><span class="s1">: </span><span class="s2">return </span><span class="s1">self.__namespace </span><span class="s2">or </span><span class="s1">default_namespace</span>

    <span class="s2">def </span><span class="s1">_set_namespace(self</span><span class="s2">, </span><span class="s1">value):  self.__namespace = value</span>
    <span class="s2">def </span><span class="s1">_del_namespace(self): </span><span class="s2">del </span><span class="s1">self.__namespace</span>
    <span class="s1">namespace = property(_get_namespace</span><span class="s2">, </span><span class="s1">_set_namespace</span><span class="s2">, </span><span class="s1">_del_namespace)</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        '&lt;term: %s&gt;' % self.termname 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s3">'&lt;term: %s&gt;' </span><span class="s1">% self.termname</span>

    <span class="s2">def </span><span class="s1">__add__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Formula(self) + Formula(other) 
        &quot;&quot;&quot;</span>
        <span class="s1">fother = Formula(other</span><span class="s2">, </span><span class="s1">namespace=other.namespace)</span>
        <span class="s1">f = fother + self</span>
        <span class="s2">if </span><span class="s1">_namespace_equal(fother.namespace</span><span class="s2">, </span><span class="s1">self.namespace):</span>
            <span class="s1">f.namespace = self.namespace</span>
        <span class="s2">return </span><span class="s1">f</span>

    <span class="s2">def </span><span class="s1">__mul__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Formula(self) * Formula(other) 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">type(other) </span><span class="s2">is </span><span class="s1">Term </span><span class="s2">and </span><span class="s1">other.name </span><span class="s2">is </span><span class="s3">'intercept'</span><span class="s1">:</span>
            <span class="s1">f = Formula(self</span><span class="s2">, </span><span class="s1">namespace=self.namespace)</span>
        <span class="s2">elif </span><span class="s1">self.name </span><span class="s2">is </span><span class="s3">'intercept'</span><span class="s1">:</span>
            <span class="s1">f = Formula(other</span><span class="s2">, </span><span class="s1">namespace=other.namespace)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">other = Formula(other</span><span class="s2">, </span><span class="s1">namespace=other.namespace)</span>
            <span class="s1">f = other * self</span>
        <span class="s2">if </span><span class="s1">_namespace_equal(other.namespace</span><span class="s2">, </span><span class="s1">self.namespace):</span>
            <span class="s1">f.namespace = self.namespace</span>
        <span class="s2">return </span><span class="s1">f</span>

    <span class="s2">def </span><span class="s1">names(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the names of the columns in design associated to the terms, 
        i.e. len(self.names()) = self().shape[0]. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">type(self.name) </span><span class="s2">is </span><span class="s1">types.StringType:</span>
            <span class="s2">return </span><span class="s1">[self.name]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">list(self.name)</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kw):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the columns associated to self in a design matrix. 
        If the term has no 'func' attribute, it returns 
        ``self.namespace[self.termname]`` 
        else, it returns 
        ``self.func(*args, **kw)`` 
        &quot;&quot;&quot;</span>

        <span class="s2">if not </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s3">'func'</span><span class="s1">):</span>
            <span class="s1">val = self.namespace[self.termname]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">val = self.func</span>
        <span class="s2">if </span><span class="s1">callable(val):</span>
            <span class="s2">if </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">(Term</span><span class="s2">, </span><span class="s1">Formula)):</span>
                <span class="s1">val = copy.copy(val)</span>
                <span class="s1">val.namespace = self.namespace</span>
            <span class="s1">val = val(*args</span><span class="s2">, </span><span class="s1">**kw)</span>

        <span class="s1">val = np.asarray(val)</span>
        <span class="s2">return </span><span class="s1">np.squeeze(val)</span>

<span class="s2">class </span><span class="s1">Factor(Term):</span>
    <span class="s0">&quot;&quot;&quot;A categorical factor.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">termname</span><span class="s2">, </span><span class="s1">keys</span><span class="s2">, </span><span class="s1">ordinal=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Factor is initialized with keys, representing all valid 
        levels of the factor. 
 
        If ordinal is False, keys can have repeats: set(keys) is what is 
        used. 
 
        If ordinal is True, the order is taken from the keys, and 
        there should be no repeats. 
        &quot;&quot;&quot;</span>

        <span class="s2">if not </span><span class="s1">ordinal:</span>
            <span class="s1">self.keys = list(set(keys))</span>
            <span class="s1">self.keys.sort()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.keys = keys</span>
            <span class="s2">if </span><span class="s1">len(set(keys)) != len(list(keys)):</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s2">, </span><span class="s3">'keys for ordinal Factor should be unique, in increasing order'</span>
        <span class="s1">self._name = termname</span>
        <span class="s1">self.termname = termname</span>
        <span class="s1">self.ordinal = ordinal</span>

        <span class="s2">if </span><span class="s1">self.ordinal:</span>
            <span class="s1">name = self.termname</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">name = [</span><span class="s3">'(%s==%s)' </span><span class="s1">% (self.termname</span><span class="s2">, </span><span class="s1">str(key)) </span><span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">self.keys]</span>

        <span class="s1">Term.__init__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">termname=self.termname</span><span class="s2">, </span><span class="s1">func=self.get_columns)</span>

    <span class="s2">def </span><span class="s1">get_columns(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kw):</span>
        <span class="s0">&quot;&quot;&quot; 
        Calling function for factor instance. 
        &quot;&quot;&quot;</span>

        <span class="s1">v = self.namespace[self._name]</span>
        <span class="s2">while True</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">callable(v):</span>
                <span class="s2">if </span><span class="s1">isinstance(v</span><span class="s2">, </span><span class="s1">(Term</span><span class="s2">, </span><span class="s1">Formula)):</span>
                    <span class="s1">v = copy.copy(v)</span>
                    <span class="s1">v.namespace = self.namespace</span>
                <span class="s1">v = v(*args</span><span class="s2">, </span><span class="s1">**kw)</span>
            <span class="s2">else</span><span class="s1">: </span><span class="s2">break</span>

        <span class="s1">n = len(v)</span>

        <span class="s2">if </span><span class="s1">self.ordinal:</span>
            <span class="s1">col = [float(self.keys.index(v[i])) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(n)]</span>
            <span class="s2">return </span><span class="s1">np.array(col)</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">value = []</span>
            <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">self.keys:</span>
                <span class="s1">col = [float((v[i] == key)) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(n)]</span>
                <span class="s1">value.append(col)</span>
            <span class="s2">return </span><span class="s1">np.array(value)</span>

    <span class="s2">def </span><span class="s1">values(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kw):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the keys of the factor, rather than the columns of the design 
        matrix. 
        &quot;&quot;&quot;</span>

        <span class="s2">del</span><span class="s1">(self.func)</span>
        <span class="s1">val = self(*args</span><span class="s2">, </span><span class="s1">**kw)</span>
        <span class="s1">self.func = self.get_columns</span>
        <span class="s2">return </span><span class="s1">val</span>

    <span class="s2">def </span><span class="s1">verify(self</span><span class="s2">, </span><span class="s1">values):</span>
        <span class="s0">&quot;&quot;&quot; 
        Verify that all values correspond to valid keys in self. 
        &quot;&quot;&quot;</span>
        <span class="s1">s = set(values)</span>
        <span class="s2">if not </span><span class="s1">s.issubset(self.keys):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s2">, </span><span class="s3">'unknown keys in values'</span>

    <span class="s2">def </span><span class="s1">__add__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Formula(self) + Formula(other) 
 
        When adding \'intercept\' to a factor, this just returns 
 
        Formula(self, namespace=self.namespace) 
 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">type(other) </span><span class="s2">is </span><span class="s1">Term </span><span class="s2">and </span><span class="s1">other.name </span><span class="s2">is </span><span class="s3">'intercept'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">Formula(self</span><span class="s2">, </span><span class="s1">namespace=self.namespace)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">Term.__add__(self</span><span class="s2">, </span><span class="s1">other)</span>

    <span class="s2">def </span><span class="s1">main_effect(self</span><span class="s2">, </span><span class="s1">reference=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the 'main effect' columns of a factor, choosing 
        an optional reference key.  
 
    The reference key can be one of the keys of the Factor, 
        or an integer, representing which column to remove. 
        It defaults to 0. 
         
        &quot;&quot;&quot;</span>

        <span class="s1">names = self.names()</span>

        <span class="s2">if </span><span class="s1">reference </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">reference = </span><span class="s5">0</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">reference = self.keys.index(reference)</span>
            <span class="s2">except </span><span class="s1">ValueError:</span>
                <span class="s1">reference = int(reference)</span>

        <span class="s2">def </span><span class="s1">maineffect_func(value</span><span class="s2">, </span><span class="s1">reference=reference):</span>
            <span class="s1">rvalue = []</span>
            <span class="s1">keep = range(value.shape[</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s1">keep.pop(reference)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(keep)):</span>
                <span class="s1">rvalue.append(value[keep[i]] - value[reference])</span>
            <span class="s2">return </span><span class="s1">np.array(rvalue)</span>

        <span class="s1">keep = range(len(self.names()))</span>
        <span class="s1">keep.pop(reference)</span>
        <span class="s1">__names = self.names()</span>
        <span class="s1">_names = [</span><span class="s3">'%s-%s' </span><span class="s1">% (__names[keep[i]]</span><span class="s2">, </span><span class="s1">__names[reference]) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(keep))]</span>
        <span class="s1">value = Quantitative(_names</span><span class="s2">, </span><span class="s1">func=self</span><span class="s2">,</span>
                     <span class="s1">termname=</span><span class="s3">'%s:maineffect' </span><span class="s1">% self.termname</span><span class="s2">,</span>
                     <span class="s1">transform=maineffect_func)</span>
        <span class="s1">value.namespace = self.namespace</span>
        <span class="s2">return </span><span class="s1">value</span>

    <span class="s2">def </span><span class="s1">__getitem__(self</span><span class="s2">, </span><span class="s1">key):</span>
        <span class="s0">&quot;&quot;&quot; 
        Retrieve the column corresponding to key in a Formula. 
         
        :Parameters: 
            key : one of the Factor's keys 
         
        :Returns: ndarray corresponding to key, when evaluated in 
                  current namespace 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self.ordinal:</span>
            <span class="s1">i = self.names().index(</span><span class="s3">'(%s==%s)' </span><span class="s1">% (self.termname</span><span class="s2">, </span><span class="s1">str(key)))</span>
            <span class="s2">return </span><span class="s1">self()[i]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">v = self.namespace[self._name]</span>
            <span class="s2">return </span><span class="s1">np.array([(vv == key) </span><span class="s2">for </span><span class="s1">vv </span><span class="s2">in </span><span class="s1">v]).astype(np.float)</span>


<span class="s2">class </span><span class="s1">Quantitative(Term):</span>
    <span class="s0">&quot;&quot;&quot; 
    A subclass of term that can be used to apply point transformations 
    of another term, i.e. to take powers: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from nipy.fixes.scipy.stats.models import formula 
    &gt;&gt;&gt; X = np.linspace(0,10,101) 
    &gt;&gt;&gt; x = formula.Term('X') 
    &gt;&gt;&gt; x.namespace={'X':X} 
    &gt;&gt;&gt; x2 = x**2 
    &gt;&gt;&gt; print np.allclose(x()**2, x2()) 
    True 
    &gt;&gt;&gt; x3 = formula.Quantitative('x2', func=x, transform=lambda x: x**2) 
    &gt;&gt;&gt; x3.namespace = x.namespace 
    &gt;&gt;&gt; print np.allclose(x()**2, x3()) 
    True 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">func=</span><span class="s2">None, </span><span class="s1">termname=</span><span class="s2">None, </span><span class="s1">transform=</span><span class="s2">lambda </span><span class="s1">x: x):</span>
        <span class="s1">self.transform = transform</span>
        <span class="s1">Term.__init__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">func=func</span><span class="s2">, </span><span class="s1">termname=termname)</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kw):</span>
        <span class="s0">&quot;&quot;&quot; 
        A quantitative is just like term, except there is an additional 
        transformation: self.transform. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.transform(Term.__call__(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kw))</span>

<span class="s2">class </span><span class="s1">Formula(object):</span>
    <span class="s0">&quot;&quot;&quot; 
    A formula object for manipulating design matrices in regression models, 
    essentially consisting of a list of term instances. 
 
    The object supports addition and multiplication which correspond 
    to concatenation and pairwise multiplication, respectively, 
    of the columns of the two formulas. 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_get_namespace(self):</span>
        <span class="s2">if </span><span class="s1">isinstance(self.__namespace</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
            <span class="s2">return </span><span class="s1">self.__namespace</span>
        <span class="s2">else</span><span class="s1">: </span><span class="s2">return </span><span class="s1">self.__namespace </span><span class="s2">or </span><span class="s1">default_namespace</span>

    <span class="s2">def </span><span class="s1">_set_namespace(self</span><span class="s2">, </span><span class="s1">value):  self.__namespace = value</span>
    <span class="s2">def </span><span class="s1">_del_namespace(self): </span><span class="s2">del </span><span class="s1">self.__namespace</span>
    <span class="s1">namespace = property(_get_namespace</span><span class="s2">, </span><span class="s1">_set_namespace</span><span class="s2">, </span><span class="s1">_del_namespace)</span>

    <span class="s2">def </span><span class="s1">_terms_changed(self):</span>
        <span class="s1">self._names = self.names()</span>
        <span class="s1">self._termnames = self.termnames()</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">termlist</span><span class="s2">, </span><span class="s1">namespace=default_namespace):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a formula from either: 
         i. a `formula` object 
         ii. a sequence of `term` instances 
         iii. one `term` 
        &quot;&quot;&quot;</span>


        <span class="s1">self.__namespace = namespace</span>
        <span class="s2">if </span><span class="s1">isinstance(termlist</span><span class="s2">, </span><span class="s1">Formula):</span>
            <span class="s1">self.terms = copy.copy(list(termlist.terms))</span>
        <span class="s2">elif </span><span class="s1">type(termlist) </span><span class="s2">is </span><span class="s1">types.ListType:</span>
            <span class="s1">self.terms = termlist</span>
        <span class="s2">elif </span><span class="s1">isinstance(termlist</span><span class="s2">, </span><span class="s1">Term):</span>
            <span class="s1">self.terms = [termlist]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span>

        <span class="s1">self._terms_changed()</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        String representation of list of termnames of a formula. 
        &quot;&quot;&quot;</span>
        <span class="s1">value = []</span>
        <span class="s2">for </span><span class="s1">term </span><span class="s2">in </span><span class="s1">self.terms:</span>
            <span class="s1">value += [term.termname]</span>
        <span class="s2">return </span><span class="s3">'&lt;formula: %s&gt;' </span><span class="s1">% </span><span class="s3">' + '</span><span class="s1">.join(value)</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kw):</span>

        <span class="s0">&quot;&quot;&quot; 
        Create (transpose) of the design matrix of the formula within 
        namespace. Extra arguments are passed to each term instance. If 
        the formula just contains an intercept, then the keyword 
        argument 'nrow' indicates the number of rows (observations). 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s3">'namespace' </span><span class="s2">in </span><span class="s1">kw:</span>
            <span class="s1">namespace = kw[</span><span class="s3">'namespace'</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">namespace = self.namespace</span>


        <span class="s1">allvals = []</span>
        <span class="s1">intercept = </span><span class="s2">False</span>
        <span class="s1">iindex = </span><span class="s5">0</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">self.terms:</span>
            <span class="s1">t = copy.copy(t)</span>
            <span class="s1">t.namespace = namespace</span>
            <span class="s1">val = t(*args</span><span class="s2">, </span><span class="s1">**kw)</span>

            <span class="s1">isintercept = </span><span class="s2">False</span>
            <span class="s2">if </span><span class="s1">hasattr(t</span><span class="s2">, </span><span class="s3">&quot;termname&quot;</span><span class="s1">):</span>
                <span class="s2">if </span><span class="s1">t.termname == </span><span class="s3">'intercept'</span><span class="s1">:</span>
                    <span class="s1">intercept = </span><span class="s2">True</span>
                    <span class="s1">isintercept = </span><span class="s2">True</span>
                    <span class="s1">interceptindex = iindex</span>
                    <span class="s1">allvals.append(</span><span class="s2">None</span><span class="s1">)</span>

            <span class="s2">if </span><span class="s1">val.ndim == </span><span class="s5">1 </span><span class="s2">and not </span><span class="s1">isintercept:</span>
                <span class="s1">val.shape = (</span><span class="s5">1</span><span class="s2">, </span><span class="s1">val.shape[</span><span class="s5">0</span><span class="s1">])</span>
                <span class="s1">allvals.append(val)</span>
            <span class="s2">elif not </span><span class="s1">isintercept:</span>
                <span class="s1">allvals.append(val)</span>
            <span class="s1">iindex += </span><span class="s5">1</span>

        <span class="s2">if not </span><span class="s1">intercept:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">allvals = np.concatenate(allvals)</span>
            <span class="s2">except</span><span class="s1">:</span>
                <span class="s2">pass</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">nrow = kw.get(</span><span class="s3">'nrow'</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">allvals != []:</span>
                <span class="s2">if </span><span class="s1">interceptindex &gt; </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s1">n = allvals[</span><span class="s5">0</span><span class="s1">].shape[</span><span class="s5">1</span><span class="s1">]</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">n = allvals[</span><span class="s5">1</span><span class="s1">].shape[</span><span class="s5">1</span><span class="s1">]</span>
                <span class="s1">allvals[interceptindex] = np.ones((</span><span class="s5">1</span><span class="s2">,</span><span class="s1">n)</span><span class="s2">, </span><span class="s1">np.float64)</span>
                <span class="s1">allvals = np.concatenate(allvals)</span>
            <span class="s2">elif </span><span class="s1">nrow &lt;= </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s2">, </span><span class="s3">'with only intercept in formula, keyword </span><span class="s2">\'</span><span class="s3">nrow</span><span class="s2">\' </span><span class="s3">argument needed'</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">allvals = I(nrow=nrow)</span>
                <span class="s1">allvals.shape = (</span><span class="s5">1</span><span class="s2">,</span><span class="s1">) + allvals.shape</span>
        <span class="s2">return </span><span class="s1">np.squeeze(allvals)</span>

    <span class="s2">def </span><span class="s1">hasterm(self</span><span class="s2">, </span><span class="s1">query_term):</span>
        <span class="s0">&quot;&quot;&quot; 
        Determine whether a given term is in a formula. 
        &quot;&quot;&quot;</span>

        <span class="s2">if not </span><span class="s1">isinstance(query_term</span><span class="s2">, </span><span class="s1">Formula):</span>
            <span class="s2">if </span><span class="s1">type(query_term) == type(</span><span class="s3">&quot;name&quot;</span><span class="s1">):</span>
                <span class="s2">try</span><span class="s1">: query = self[query_term]</span>
                <span class="s2">except</span><span class="s1">: </span><span class="s2">return False</span>
            <span class="s2">elif </span><span class="s1">isinstance(query_term</span><span class="s2">, </span><span class="s1">Term):</span>
                <span class="s2">return </span><span class="s1">query_term.termname </span><span class="s2">in </span><span class="s1">self.termnames()</span>
        <span class="s2">elif </span><span class="s1">len(query_term.terms) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">query_term = query_term.terms[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s2">return </span><span class="s1">query_term.termname </span><span class="s2">in </span><span class="s1">self.termnames()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s2">, </span><span class="s3">'more than one term passed to hasterm'</span>

    <span class="s2">def </span><span class="s1">__getitem__(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s1">t = self.termnames()</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">t:</span>
            <span class="s2">return </span><span class="s1">self.terms[t.index(name)]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">KeyError</span><span class="s2">, </span><span class="s3">'formula has no such term: %s' </span><span class="s1">% repr(name)</span>

    <span class="s2">def </span><span class="s1">termcolumns(self</span><span class="s2">, </span><span class="s1">query_term</span><span class="s2">, </span><span class="s1">dict=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a list of the indices of all columns associated 
        to a given term. 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">self.hasterm(query_term):</span>
            <span class="s1">names = query_term.names()</span>
            <span class="s1">value = {}</span>
            <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">names:</span>
                <span class="s1">value[name] = self._names.index(name)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s2">, </span><span class="s3">'term not in formula'</span>
        <span class="s2">if </span><span class="s1">dict:</span>
            <span class="s2">return </span><span class="s1">value</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">value.values()</span>

    <span class="s2">def </span><span class="s1">names(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a list of the names in the formula. The order of the 
        names corresponds to the order of the columns when self 
        is evaluated. 
        &quot;&quot;&quot;</span>

        <span class="s1">allnames = []</span>
        <span class="s2">for </span><span class="s1">term </span><span class="s2">in </span><span class="s1">self.terms:</span>
            <span class="s1">allnames += term.names()</span>
        <span class="s2">return </span><span class="s1">allnames</span>

    <span class="s2">def </span><span class="s1">termnames(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a list of the term names in the formula. These 
        are the names of each term instance in self. 
        &quot;&quot;&quot;</span>

        <span class="s1">names = []</span>
        <span class="s2">for </span><span class="s1">term </span><span class="s2">in </span><span class="s1">self.terms:</span>
            <span class="s1">names += [term.termname]</span>
        <span class="s2">return </span><span class="s1">names</span>

    <span class="s2">def </span><span class="s1">design(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kw):</span>
        <span class="s0">&quot;&quot;&quot; 
        ``transpose(self(*args, **kw))`` 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self(*args</span><span class="s2">, </span><span class="s1">**kw).T</span>

    <span class="s2">def </span><span class="s1">__mul__(self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">nested=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        This returns a formula whose columns are the pairwise 
        product of the columns of self and other. 
 
        TO DO: check for nesting relationship. Should not be too difficult. 
        &quot;&quot;&quot;</span>

        <span class="s1">other = Formula(other)</span>

        <span class="s1">selftermnames = self.termnames()</span>
        <span class="s1">othertermnames = other.termnames()</span>

        <span class="s1">I = len(selftermnames)</span>
        <span class="s1">J = len(othertermnames)</span>

        <span class="s1">terms = []</span>
        <span class="s1">termnames = []</span>

        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(I):</span>
            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(J):</span>
                <span class="s1">termname = </span><span class="s3">'%s*%s' </span><span class="s1">% (str(selftermnames[i])</span><span class="s2">, </span><span class="s1">str(othertermnames[j]))</span>
                <span class="s1">pieces = termname.split(</span><span class="s3">'*'</span><span class="s1">)</span>
                <span class="s1">pieces.sort()</span>
                <span class="s1">termname = </span><span class="s3">'*'</span><span class="s1">.join(pieces)</span>
                <span class="s1">termnames.append(termname)</span>

                <span class="s1">selfnames = self.terms[i].names()</span>
                <span class="s1">othernames = other.terms[j].names()</span>

                <span class="s2">if </span><span class="s1">self.terms[i].name </span><span class="s2">is </span><span class="s3">'intercept'</span><span class="s1">:</span>
                    <span class="s1">_term = other.terms[j]</span>
                    <span class="s1">_term.namespace = other.namespace</span>
                <span class="s2">elif </span><span class="s1">other.terms[j].name </span><span class="s2">is </span><span class="s3">'intercept'</span><span class="s1">:</span>
                    <span class="s1">_term = self.terms[i]</span>
                    <span class="s1">_term.namespace = self.namespace</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">names = []</span>

                    <span class="s1">d1 = len(selfnames)</span>
                    <span class="s1">d2 = len(othernames)</span>

                    <span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">range(d1):</span>
                        <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">range(d2):</span>
                            <span class="s1">name = </span><span class="s3">'%s*%s' </span><span class="s1">% (str(selfnames[r])</span><span class="s2">, </span><span class="s1">str(othernames[s]))</span>
                            <span class="s1">pieces = name.split(</span><span class="s3">'*'</span><span class="s1">)</span>
                            <span class="s1">pieces.sort()</span>
                            <span class="s1">name = </span><span class="s3">'*'</span><span class="s1">.join(pieces)</span>
                            <span class="s1">names.append(name)</span>

                    <span class="s2">def </span><span class="s1">product_func(value</span><span class="s2">, </span><span class="s1">d1=d1</span><span class="s2">, </span><span class="s1">d2=d2):</span>

                        <span class="s1">out = []</span>
                        <span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">range(d1):</span>
                            <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">range(d2):</span>
                                <span class="s1">out.append(value[r] * value[d1+s])</span>
                        <span class="s2">return </span><span class="s1">np.array(out)</span>

                    <span class="s1">cself = copy.copy(self.terms[i])</span>
                    <span class="s1">cother = copy.copy(other.terms[j])</span>
                    <span class="s1">sumterms = cself + cother</span>
                    <span class="s1">sumterms.terms = [cself</span><span class="s2">, </span><span class="s1">cother] </span><span class="s4"># enforce the order we want</span>

                    <span class="s1">_term = Quantitative(names</span><span class="s2">, </span><span class="s1">func=sumterms</span><span class="s2">,</span>
                                         <span class="s1">termname=termname</span><span class="s2">,</span>
                                         <span class="s1">transform=product_func)</span>

                    <span class="s2">if </span><span class="s1">_namespace_equal(self.namespace</span><span class="s2">, </span><span class="s1">other.namespace):</span>
                        <span class="s1">_term.namespace = self.namespace</span>

                <span class="s1">terms.append(_term)</span>

        <span class="s2">return </span><span class="s1">Formula(terms)</span>

    <span class="s2">def </span><span class="s1">__add__(self</span><span class="s2">, </span><span class="s1">other):</span>

        <span class="s0">&quot;&quot;&quot; 
        Return a formula whose columns are the 
        concatenation of the columns of self and other. 
 
        terms in the formula are sorted alphabetically. 
        &quot;&quot;&quot;</span>

        <span class="s1">other = Formula(other)</span>
        <span class="s1">terms = self.terms + other.terms</span>
        <span class="s1">pieces = [(term.name</span><span class="s2">, </span><span class="s1">term) </span><span class="s2">for </span><span class="s1">term </span><span class="s2">in </span><span class="s1">terms]</span>
        <span class="s1">pieces.sort()</span>
        <span class="s1">terms = [piece[</span><span class="s5">1</span><span class="s1">] </span><span class="s2">for </span><span class="s1">piece </span><span class="s2">in </span><span class="s1">pieces]</span>
        <span class="s1">f = Formula(terms)</span>
        <span class="s2">if </span><span class="s1">_namespace_equal(self.namespace</span><span class="s2">, </span><span class="s1">other.namespace):</span>
            <span class="s1">f.namespace = self.namespace</span>
        <span class="s2">return </span><span class="s1">f</span>

    <span class="s2">def </span><span class="s1">__sub__(self</span><span class="s2">, </span><span class="s1">other):</span>

        <span class="s0">&quot;&quot;&quot; 
        Return a formula with all terms in other removed from self. 
        If other contains term instances not in formula, this 
        function does not raise an exception. 
        &quot;&quot;&quot;</span>

        <span class="s1">other = Formula(other)</span>
        <span class="s1">terms = copy.copy(self.terms)</span>

        <span class="s2">for </span><span class="s1">term </span><span class="s2">in </span><span class="s1">other.terms:</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(terms)):</span>
                <span class="s2">if </span><span class="s1">terms[i].termname == term.termname:</span>
                    <span class="s1">terms.pop(i)</span>
                    <span class="s2">break</span>
        <span class="s1">f = Formula(terms)</span>
        <span class="s1">f.namespace = self.namespace</span>
        <span class="s2">return </span><span class="s1">f</span>

<span class="s2">def </span><span class="s1">isnested(A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">namespace=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Is factor B nested within factor A or vice versa: a very crude test 
    which depends on the namespace. 
 
    If they are nested, returns (True, F) where F is the finest 
    level of the relationship. Otherwise, returns (False, None) 
 
    &quot;&quot;&quot;</span>

    <span class="s2">if </span><span class="s1">namespace </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">A = copy.copy(A); A.namespace = namespace</span>
        <span class="s1">B = copy.copy(B); B.namespace = namespace</span>

    <span class="s1">a = A(values=</span><span class="s2">True</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">b = B(values=</span><span class="s2">True</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s2">if </span><span class="s1">len(a) != len(b):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s2">, </span><span class="s3">'A() and B() should be sequences of the same length'</span>

    <span class="s1">nA = len(set(a))</span>
    <span class="s1">nB = len(set(b))</span>
    <span class="s1">n = max(nA</span><span class="s2">, </span><span class="s1">nB)</span>

    <span class="s1">AB = [(a[i]</span><span class="s2">,</span><span class="s1">b[i]) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(a))]</span>
    <span class="s1">nAB = len(set(AB))</span>

    <span class="s2">if </span><span class="s1">nAB == n:</span>
        <span class="s2">if </span><span class="s1">nA &gt; nB:</span>
            <span class="s1">F = A</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">F = B</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s2">True, </span><span class="s1">F)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s2">False, None</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">_intercept_fn(nrow=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">**extra):</span>
    <span class="s2">return </span><span class="s1">np.ones((</span><span class="s5">1</span><span class="s2">,</span><span class="s1">nrow))</span>

<span class="s1">I = Term(</span><span class="s3">'intercept'</span><span class="s2">, </span><span class="s1">func=_intercept_fn)</span>
<span class="s1">I.__doc__ = </span><span class="s3">&quot;&quot;&quot; 
Intercept term in a formula. If intercept is the 
only term in the formula, then a keyword argument 
</span><span class="s2">\'</span><span class="s3">nrow</span><span class="s2">\' </span><span class="s3">is needed. 
 
&gt;&gt;&gt; from nipy.fixes.scipy.stats.models.formula import Formula, I 
&gt;&gt;&gt; I() 
array(1.0) 
&gt;&gt;&gt; I(nrow=5) 
array([ 1.,  1.,  1.,  1.,  1.]) 
&gt;&gt;&gt; f=Formula(I) 
&gt;&gt;&gt; f(nrow=5) 
array([1, 1, 1, 1, 1]) 
 
&quot;&quot;&quot;</span>

<span class="s2">def </span><span class="s1">interactions(terms</span><span class="s2">, </span><span class="s1">order=[</span><span class="s5">1</span><span class="s2">,</span><span class="s5">2</span><span class="s1">]):</span>
    <span class="s0">&quot;&quot;&quot; 
    Output all pairwise interactions of given order of a 
    sequence of terms. 
 
    The argument order is a sequence specifying which order 
    of interactions should be generated -- the default 
    creates main effects and two-way interactions. If order 
    is an integer, it is changed to range(1,order+1), so 
    order=3 is equivalent to order=[1,2,3], generating 
    all one, two and three-way interactions. 
     
    If any entry of order is greater than len(terms), it is 
    effectively treated as len(terms). 
 
    &gt;&gt;&gt; print interactions([Term(l) for l in ['a', 'b', 'c']]) 
    &lt;formula: a*b + a*c + b*c + a + b + c&gt; 
    &gt;&gt;&gt; 
    &gt;&gt;&gt; print interactions([Term(l) for l in ['a', 'b', 'c']], order=range(5)) 
    &lt;formula: a*b + a*b*c + a*c + b*c + a + b + c&gt; 
    &gt;&gt;&gt; 
 
    &quot;&quot;&quot;</span>
    <span class="s1">l = len(terms)</span>

    <span class="s1">values = {}</span>

    <span class="s2">if </span><span class="s1">np.asarray(order).shape == ():</span>
        <span class="s1">order = range(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">int(order)+</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s4"># First order</span>

    <span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">order:</span>
        <span class="s1">I = np.indices((l</span><span class="s2">,</span><span class="s1">)*(o))</span>
        <span class="s1">I.shape = (I.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.product(I.shape[</span><span class="s5">1</span><span class="s1">:]))</span>
        <span class="s2">for </span><span class="s1">m </span><span class="s2">in </span><span class="s1">range(I.shape[</span><span class="s5">1</span><span class="s1">]):</span>

            <span class="s4"># only keep combinations that have unique entries</span>
            
            <span class="s2">if </span><span class="s1">(np.unique(I[:</span><span class="s2">,</span><span class="s1">m]).shape == I[:</span><span class="s2">,</span><span class="s1">m].shape </span><span class="s2">and</span>
                <span class="s1">np.alltrue(np.equal(np.sort(I[:</span><span class="s2">,</span><span class="s1">m])</span><span class="s2">, </span><span class="s1">I[:</span><span class="s2">,</span><span class="s1">m]))):</span>
                <span class="s1">ll = [terms[j] </span><span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">I[:</span><span class="s2">,</span><span class="s1">m]]</span>
                <span class="s1">v = ll[</span><span class="s5">0</span><span class="s1">]</span>
                <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">range(len(ll)-</span><span class="s5">1</span><span class="s1">):</span>
                    <span class="s1">v *= ll[ii+</span><span class="s5">1</span><span class="s1">]</span>
                <span class="s1">values[tuple(I[:</span><span class="s2">,</span><span class="s1">m])] = v</span>

    <span class="s1">key = values.keys()[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">value = values[key]; </span><span class="s2">del</span><span class="s1">(values[key])</span>
    
    <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">values.values():</span>
        <span class="s1">value += v</span>
    <span class="s2">return </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">_namespace_equal(space1</span><span class="s2">, </span><span class="s1">space2):</span>
    <span class="s2">return </span><span class="s1">space1 </span><span class="s2">is </span><span class="s1">space2</span>
</pre>
</body>
</html>