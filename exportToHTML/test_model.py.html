<html>
<head>
<title>test_model.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_model.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Tests for ARIMA model. 
 
Tests are primarily limited to checking that the model is constructed correctly 
and that it is calling the appropriate parameter estimators correctly. Tests of 
correctness of parameter estimation routines are left to the individual 
estimators' test functions. 
 
Author: Chad Fulton 
License: BSD-3 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">statsmodels.compat.platform </span><span class="s2">import </span><span class="s1">PLATFORM_WIN32</span>

<span class="s2">import </span><span class="s1">io</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">assert_equal</span><span class="s2">, </span><span class="s1">assert_allclose</span><span class="s2">, </span><span class="s1">assert_raises</span><span class="s2">, </span><span class="s1">assert_</span>

<span class="s2">from </span><span class="s1">statsmodels.datasets </span><span class="s2">import </span><span class="s1">macrodata</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.arima.model </span><span class="s2">import </span><span class="s1">ARIMA</span>

<span class="s2">from </span><span class="s1">statsmodels.tsa.arima.estimators.yule_walker </span><span class="s2">import </span><span class="s1">yule_walker</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.arima.estimators.burg </span><span class="s2">import </span><span class="s1">burg</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.arima.estimators.hannan_rissanen </span><span class="s2">import </span><span class="s1">hannan_rissanen</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.arima.estimators.innovations </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">innovations</span><span class="s2">, </span><span class="s1">innovations_mle)</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.arima.estimators.statespace </span><span class="s2">import </span><span class="s1">statespace</span>

<span class="s1">dta = macrodata.load_pandas().data</span>
<span class="s1">dta.index = pd.date_range(start=</span><span class="s3">'1959-01-01'</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2009-07-01'</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'QS'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_default_trend():</span>
    <span class="s4"># Test that we are setting the trend default correctly</span>
    <span class="s1">endog = dta[</span><span class="s3">'infl'</span><span class="s1">].iloc[:</span><span class="s5">50</span><span class="s1">]</span>

    <span class="s4"># Defaults when only endog is specified</span>
    <span class="s1">mod = ARIMA(endog)</span>
    <span class="s4"># with no integration, default trend a constant</span>
    <span class="s1">assert_equal(mod._spec_arima.trend_order</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">assert_allclose(mod.exog</span><span class="s2">, </span><span class="s1">np.ones((mod.nobs</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)))</span>

    <span class="s4"># Defaults with integrated model</span>
    <span class="s1">mod = ARIMA(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span>
    <span class="s4"># with no integration, default trend is none</span>
    <span class="s1">assert_equal(mod._spec_arima.trend_order</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s1">assert_equal(mod.exog</span><span class="s2">, None</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_invalid():</span>
    <span class="s4"># Tests that invalid options raise errors</span>
    <span class="s4"># (note that this is only invalid options specific to `ARIMA`, and not</span>
    <span class="s4"># invalid options that would raise errors in SARIMAXSpecification).</span>
    <span class="s1">endog = dta[</span><span class="s3">'infl'</span><span class="s1">].iloc[:</span><span class="s5">50</span><span class="s1">]</span>
    <span class="s1">mod = ARIMA(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span>

    <span class="s4"># Need valid method</span>
    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">mod.fit</span><span class="s2">, </span><span class="s1">method=</span><span class="s3">'not_a_method'</span><span class="s1">)</span>

    <span class="s4"># Can only use certain methods with fixed parameters</span>
    <span class="s4"># (e.g. 'statespace' and 'hannan-rissanen')</span>
    <span class="s2">with </span><span class="s1">mod.fix_params({</span><span class="s3">'ar.L1'</span><span class="s1">: </span><span class="s5">0.5</span><span class="s1">}):</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">mod.fit</span><span class="s2">, </span><span class="s1">method=</span><span class="s3">'yule_walker'</span><span class="s1">)</span>

    <span class="s4"># Cannot override model-level values in fit</span>
    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">mod.fit</span><span class="s2">, </span><span class="s1">method=</span><span class="s3">'statespace'</span><span class="s2">, </span><span class="s1">method_kwargs={</span>
        <span class="s3">'enforce_stationarity'</span><span class="s1">: </span><span class="s2">False</span><span class="s1">})</span>

    <span class="s4"># start_params only valid for MLE methods</span>
    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">mod.fit</span><span class="s2">, </span><span class="s1">method=</span><span class="s3">'yule_walker'</span><span class="s2">,</span>
                  <span class="s1">start_params=[</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">1.</span><span class="s1">])</span>

    <span class="s4"># has_exog and gls=False with non-statespace method</span>
    <span class="s1">mod2 = ARIMA(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'c'</span><span class="s1">)</span>
    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">mod2.fit</span><span class="s2">, </span><span class="s1">method=</span><span class="s3">'yule_walker'</span><span class="s2">, </span><span class="s1">gls=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s4"># non-stationary parameters</span>
    <span class="s1">mod3 = ARIMA(np.arange(</span><span class="s5">100</span><span class="s1">) * </span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'n'</span><span class="s1">)</span>
    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">mod3.fit</span><span class="s2">, </span><span class="s1">method=</span><span class="s3">'hannan_rissanen'</span><span class="s1">)</span>

    <span class="s4"># non-invertible parameters</span>
    <span class="s1">mod3 = ARIMA(np.arange(</span><span class="s5">20</span><span class="s1">) * </span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'n'</span><span class="s1">)</span>
    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">mod3.fit</span><span class="s2">, </span><span class="s1">method=</span><span class="s3">'hannan_rissanen'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_yule_walker():</span>
    <span class="s4"># Test for basic use of Yule-Walker estimation</span>
    <span class="s1">endog = dta[</span><span class="s3">'infl'</span><span class="s1">].iloc[:</span><span class="s5">50</span><span class="s1">]</span>

    <span class="s4"># AR(2), no trend (since trend would imply GLS estimation)</span>
    <span class="s1">desired_p</span><span class="s2">, </span><span class="s1">_ = yule_walker(endog</span><span class="s2">, </span><span class="s1">ar_order=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">demean=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">mod = ARIMA(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'n'</span><span class="s1">)</span>
    <span class="s1">res = mod.fit(method=</span><span class="s3">'yule_walker'</span><span class="s1">)</span>
    <span class="s1">assert_allclose(res.params</span><span class="s2">, </span><span class="s1">desired_p.params)</span>


<span class="s2">def </span><span class="s1">test_burg():</span>
    <span class="s4"># Test for basic use of Yule-Walker estimation</span>
    <span class="s1">endog = dta[</span><span class="s3">'infl'</span><span class="s1">].iloc[:</span><span class="s5">50</span><span class="s1">]</span>

    <span class="s4"># AR(2), no trend (since trend would imply GLS estimation)</span>
    <span class="s1">desired_p</span><span class="s2">, </span><span class="s1">_ = burg(endog</span><span class="s2">, </span><span class="s1">ar_order=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">demean=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">mod = ARIMA(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'n'</span><span class="s1">)</span>
    <span class="s1">res = mod.fit(method=</span><span class="s3">'burg'</span><span class="s1">)</span>
    <span class="s1">assert_allclose(res.params</span><span class="s2">, </span><span class="s1">desired_p.params)</span>


<span class="s2">def </span><span class="s1">test_hannan_rissanen():</span>
    <span class="s4"># Test for basic use of Hannan-Rissanen estimation</span>
    <span class="s1">endog = dta[</span><span class="s3">'infl'</span><span class="s1">].diff().iloc[</span><span class="s5">1</span><span class="s1">:</span><span class="s5">101</span><span class="s1">]</span>

    <span class="s4"># ARMA(1, 1), no trend (since trend would imply GLS estimation)</span>
    <span class="s1">desired_p</span><span class="s2">, </span><span class="s1">_ = hannan_rissanen(</span>
        <span class="s1">endog</span><span class="s2">, </span><span class="s1">ar_order=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">ma_order=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">demean=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">mod = ARIMA(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'n'</span><span class="s1">)</span>
    <span class="s1">res = mod.fit(method=</span><span class="s3">'hannan_rissanen'</span><span class="s1">)</span>
    <span class="s1">assert_allclose(res.params</span><span class="s2">, </span><span class="s1">desired_p.params)</span>


<span class="s2">def </span><span class="s1">test_innovations():</span>
    <span class="s4"># Test for basic use of Yule-Walker estimation</span>
    <span class="s1">endog = dta[</span><span class="s3">'infl'</span><span class="s1">].iloc[:</span><span class="s5">50</span><span class="s1">]</span>

    <span class="s4"># MA(2), no trend (since trend would imply GLS estimation)</span>
    <span class="s1">desired_p</span><span class="s2">, </span><span class="s1">_ = innovations(endog</span><span class="s2">, </span><span class="s1">ma_order=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">demean=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">mod = ARIMA(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'n'</span><span class="s1">)</span>
    <span class="s1">res = mod.fit(method=</span><span class="s3">'innovations'</span><span class="s1">)</span>
    <span class="s1">assert_allclose(res.params</span><span class="s2">, </span><span class="s1">desired_p[-</span><span class="s5">1</span><span class="s1">].params)</span>


<span class="s2">def </span><span class="s1">test_innovations_mle():</span>
    <span class="s4"># Test for basic use of Yule-Walker estimation</span>
    <span class="s1">endog = dta[</span><span class="s3">'infl'</span><span class="s1">].iloc[:</span><span class="s5">100</span><span class="s1">]</span>

    <span class="s4"># ARMA(1, 1), no trend (since trend would imply GLS estimation)</span>
    <span class="s1">desired_p</span><span class="s2">, </span><span class="s1">_ = innovations_mle(</span>
        <span class="s1">endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">demean=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">mod = ARIMA(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'n'</span><span class="s1">)</span>
    <span class="s1">res = mod.fit(method=</span><span class="s3">'innovations_mle'</span><span class="s1">)</span>
    <span class="s4"># Note: atol is required only due to precision issues on Windows</span>
    <span class="s1">assert_allclose(res.params</span><span class="s2">, </span><span class="s1">desired_p.params</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-5</span><span class="s1">)</span>

    <span class="s4"># SARMA(1, 0)x(1, 0)4, no trend (since trend would imply GLS estimation)</span>
    <span class="s1">desired_p</span><span class="s2">, </span><span class="s1">_ = innovations_mle(</span>
        <span class="s1">endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">seasonal_order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">demean=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">mod = ARIMA(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">seasonal_order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'n'</span><span class="s1">)</span>
    <span class="s1">res = mod.fit(method=</span><span class="s3">'innovations_mle'</span><span class="s1">)</span>
    <span class="s4"># Note: atol is required only due to precision issues on Windows</span>
    <span class="s1">assert_allclose(res.params</span><span class="s2">, </span><span class="s1">desired_p.params</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-5</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_statespace():</span>
    <span class="s4"># Test for basic use of Yule-Walker estimation</span>
    <span class="s1">endog = dta[</span><span class="s3">'infl'</span><span class="s1">].iloc[:</span><span class="s5">100</span><span class="s1">]</span>

    <span class="s4"># ARMA(1, 1), no trend</span>
    <span class="s1">desired_p</span><span class="s2">, </span><span class="s1">_ = statespace(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">include_constant=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">mod = ARIMA(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'n'</span><span class="s1">)</span>
    <span class="s1">res = mod.fit(method=</span><span class="s3">'statespace'</span><span class="s1">)</span>
    <span class="s4"># Note: tol changes required due to precision issues on Windows</span>
    <span class="s1">rtol = </span><span class="s5">1e-7 </span><span class="s2">if not </span><span class="s1">PLATFORM_WIN32 </span><span class="s2">else </span><span class="s5">1e-3</span>
    <span class="s1">assert_allclose(res.params</span><span class="s2">, </span><span class="s1">desired_p.params</span><span class="s2">, </span><span class="s1">rtol=rtol</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-4</span><span class="s1">)</span>

    <span class="s4"># ARMA(1, 2), with trend</span>
    <span class="s1">desired_p</span><span class="s2">, </span><span class="s1">_ = statespace(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">include_constant=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">mod = ARIMA(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'c'</span><span class="s1">)</span>
    <span class="s1">res = mod.fit(method=</span><span class="s3">'statespace'</span><span class="s1">)</span>
    <span class="s4"># Note: atol is required only due to precision issues on Windows</span>
    <span class="s1">assert_allclose(res.params</span><span class="s2">, </span><span class="s1">desired_p.params</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-4</span><span class="s1">)</span>

    <span class="s4"># SARMA(1, 0)x(1, 0)4, no trend</span>
    <span class="s1">desired_p</span><span class="s2">, </span><span class="s1">_spec = statespace(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">,</span>
                                  <span class="s1">seasonal_order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span><span class="s2">,</span>
                                  <span class="s1">include_constant=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">mod = ARIMA(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">seasonal_order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'n'</span><span class="s1">)</span>
    <span class="s1">res = mod.fit(method=</span><span class="s3">'statespace'</span><span class="s1">)</span>
    <span class="s4"># Note: atol is required only due to precision issues on Windows</span>
    <span class="s1">assert_allclose(res.params</span><span class="s2">, </span><span class="s1">desired_p.params</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-4</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_low_memory():</span>
    <span class="s4"># Basic test that the low_memory option is working</span>
    <span class="s1">endog = dta[</span><span class="s3">'infl'</span><span class="s1">].iloc[:</span><span class="s5">50</span><span class="s1">]</span>

    <span class="s1">mod = ARIMA(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">concentrate_scale=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">res1 = mod.fit()</span>
    <span class="s1">res2 = mod.fit(low_memory=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s4"># Check that the models produce the same results</span>
    <span class="s1">assert_allclose(res2.params</span><span class="s2">, </span><span class="s1">res1.params)</span>
    <span class="s1">assert_allclose(res2.llf</span><span class="s2">, </span><span class="s1">res1.llf)</span>

    <span class="s4"># Check that the model's basic memory conservation option was not changed</span>
    <span class="s1">assert_equal(mod.ssm.memory_conserve</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>

    <span class="s4"># Check that low memory was actually used (just check a couple)</span>
    <span class="s1">assert_(res2.llf_obs </span><span class="s2">is None</span><span class="s1">)</span>
    <span class="s1">assert_(res2.predicted_state </span><span class="s2">is None</span><span class="s1">)</span>
    <span class="s1">assert_(res2.filtered_state </span><span class="s2">is None</span><span class="s1">)</span>
    <span class="s1">assert_(res2.smoothed_state </span><span class="s2">is None</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">check_cloned(mod</span><span class="s2">, </span><span class="s1">endog</span><span class="s2">, </span><span class="s1">exog=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s1">mod_c = mod.clone(endog</span><span class="s2">, </span><span class="s1">exog=exog)</span>

    <span class="s1">assert_allclose(mod.nobs</span><span class="s2">, </span><span class="s1">mod_c.nobs)</span>
    <span class="s1">assert_(mod._index.equals(mod_c._index))</span>
    <span class="s1">assert_equal(mod.k_params</span><span class="s2">, </span><span class="s1">mod_c.k_params)</span>
    <span class="s1">assert_allclose(mod.start_params</span><span class="s2">, </span><span class="s1">mod_c.start_params)</span>
    <span class="s1">p = mod.start_params</span>
    <span class="s1">assert_allclose(mod.loglike(p)</span><span class="s2">, </span><span class="s1">mod_c.loglike(p))</span>
    <span class="s1">assert_allclose(mod.concentrate_scale</span><span class="s2">, </span><span class="s1">mod_c.concentrate_scale)</span>


<span class="s2">def </span><span class="s1">test_clone():</span>
    <span class="s1">endog = dta[</span><span class="s3">'infl'</span><span class="s1">].iloc[:</span><span class="s5">50</span><span class="s1">]</span>
    <span class="s1">exog = np.arange(endog.shape[</span><span class="s5">0</span><span class="s1">])</span>

    <span class="s4"># Basic model</span>
    <span class="s1">check_cloned(ARIMA(endog)</span><span class="s2">, </span><span class="s1">endog)</span>
    <span class="s1">check_cloned(ARIMA(endog.values)</span><span class="s2">, </span><span class="s1">endog.values)</span>
    <span class="s4"># With trends</span>
    <span class="s1">check_cloned(ARIMA(endog</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'c'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">endog)</span>
    <span class="s1">check_cloned(ARIMA(endog</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'t'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">endog)</span>
    <span class="s1">check_cloned(ARIMA(endog</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'ct'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">endog)</span>
    <span class="s4"># With exog</span>
    <span class="s1">check_cloned(ARIMA(endog</span><span class="s2">, </span><span class="s1">exog=exog)</span><span class="s2">, </span><span class="s1">endog</span><span class="s2">, </span><span class="s1">exog=exog)</span>
    <span class="s1">check_cloned(ARIMA(endog</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'c'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">endog</span><span class="s2">, </span><span class="s1">exog=exog)</span>
    <span class="s4"># Concentrated scale</span>
    <span class="s1">check_cloned(ARIMA(endog</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'c'</span><span class="s2">, </span><span class="s1">concentrate_scale=</span><span class="s2">True</span><span class="s1">)</span><span class="s2">,</span>
                 <span class="s1">endog</span><span class="s2">, </span><span class="s1">exog=exog)</span>

    <span class="s4"># Higher order (use a different dataset to avoid warnings about</span>
    <span class="s4"># non-invertible start params)</span>
    <span class="s1">endog = dta[</span><span class="s3">'realgdp'</span><span class="s1">].iloc[:</span><span class="s5">100</span><span class="s1">]</span>
    <span class="s1">exog = np.arange(endog.shape[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s1">check_cloned(ARIMA(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">seasonal_order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span><span class="s2">,</span>
                       <span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">trend=[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">concentrate_scale=</span><span class="s2">True</span><span class="s1">)</span><span class="s2">,</span>
                 <span class="s1">endog</span><span class="s2">, </span><span class="s1">exog=exog)</span>


<span class="s2">def </span><span class="s1">test_constant_integrated_model_error():</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;In models with integration&quot;</span><span class="s1">):</span>
        <span class="s1">ARIMA(np.ones(</span><span class="s5">100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'c'</span><span class="s1">)</span>

    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;In models with integration&quot;</span><span class="s1">):</span>
        <span class="s1">ARIMA(np.ones(</span><span class="s5">100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">seasonal_order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">6</span><span class="s1">)</span><span class="s2">,</span>
              <span class="s1">trend=</span><span class="s3">'c'</span><span class="s1">)</span>

    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;In models with integration&quot;</span><span class="s1">):</span>
        <span class="s1">ARIMA(np.ones(</span><span class="s5">100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'t'</span><span class="s1">)</span>

    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;In models with integration&quot;</span><span class="s1">):</span>
        <span class="s1">ARIMA(np.ones(</span><span class="s5">100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">seasonal_order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">6</span><span class="s1">)</span><span class="s2">,</span>
              <span class="s1">trend=</span><span class="s3">'t'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_forecast():</span>
    <span class="s4"># Numpy</span>
    <span class="s1">endog = dta[</span><span class="s3">'infl'</span><span class="s1">].iloc[:</span><span class="s5">100</span><span class="s1">].values</span>

    <span class="s1">mod = ARIMA(endog[:</span><span class="s5">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'t'</span><span class="s1">)</span>
    <span class="s1">res = mod.filter([</span><span class="s5">0.2</span><span class="s2">, </span><span class="s5">0.3</span><span class="s2">, </span><span class="s5">1.0</span><span class="s1">])</span>

    <span class="s1">endog2 = endog.copy()</span>
    <span class="s1">endog2[</span><span class="s5">50</span><span class="s1">:] = np.nan</span>
    <span class="s1">mod2 = mod.clone(endog2)</span>
    <span class="s1">res2 = mod2.filter(res.params)</span>

    <span class="s1">assert_allclose(res.forecast(</span><span class="s5">50</span><span class="s1">)</span><span class="s2">, </span><span class="s1">res2.fittedvalues[-</span><span class="s5">50</span><span class="s1">:])</span>


<span class="s2">def </span><span class="s1">test_forecast_with_exog():</span>
    <span class="s4"># Numpy</span>
    <span class="s1">endog = dta[</span><span class="s3">'infl'</span><span class="s1">].iloc[:</span><span class="s5">100</span><span class="s1">].values</span>
    <span class="s1">exog = np.arange(len(endog))**</span><span class="s5">2</span>

    <span class="s1">mod = ARIMA(endog[:</span><span class="s5">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">exog=exog[:</span><span class="s5">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'t'</span><span class="s1">)</span>
    <span class="s1">res = mod.filter([</span><span class="s5">0.2</span><span class="s2">, </span><span class="s5">0.05</span><span class="s2">, </span><span class="s5">0.3</span><span class="s2">, </span><span class="s5">1.0</span><span class="s1">])</span>

    <span class="s1">endog2 = endog.copy()</span>
    <span class="s1">endog2[</span><span class="s5">50</span><span class="s1">:] = np.nan</span>
    <span class="s1">mod2 = mod.clone(endog2</span><span class="s2">, </span><span class="s1">exog=exog)</span>
    <span class="s1">print(mod.param_names)</span>
    <span class="s1">print(mod2.param_names)</span>
    <span class="s1">res2 = mod2.filter(res.params)</span>

    <span class="s1">assert_allclose(res.forecast(</span><span class="s5">50</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s5">50</span><span class="s1">:])</span><span class="s2">, </span><span class="s1">res2.fittedvalues[-</span><span class="s5">50</span><span class="s1">:])</span>


<span class="s2">def </span><span class="s1">test_append():</span>
    <span class="s1">endog = dta[</span><span class="s3">'infl'</span><span class="s1">].iloc[:</span><span class="s5">100</span><span class="s1">].values</span>
    <span class="s1">mod = ARIMA(endog[:</span><span class="s5">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'c'</span><span class="s1">)</span>
    <span class="s1">res = mod.fit()</span>
    <span class="s1">res_e = res.append(endog[</span><span class="s5">50</span><span class="s1">:])</span>
    <span class="s1">mod2 = ARIMA(endog)</span>
    <span class="s1">res2 = mod2.filter(res_e.params)</span>

    <span class="s1">assert_allclose(res2.llf</span><span class="s2">, </span><span class="s1">res_e.llf)</span>


<span class="s2">def </span><span class="s1">test_append_with_exog():</span>
    <span class="s4"># Numpy</span>
    <span class="s1">endog = dta[</span><span class="s3">'infl'</span><span class="s1">].iloc[:</span><span class="s5">100</span><span class="s1">].values</span>
    <span class="s1">exog = np.arange(len(endog))</span>
    <span class="s1">mod = ARIMA(endog[:</span><span class="s5">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">exog=exog[:</span><span class="s5">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'c'</span><span class="s1">)</span>
    <span class="s1">res = mod.fit()</span>
    <span class="s1">res_e = res.append(endog[</span><span class="s5">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s5">50</span><span class="s1">:])</span>
    <span class="s1">mod2 = ARIMA(endog</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'c'</span><span class="s1">)</span>
    <span class="s1">res2 = mod2.filter(res_e.params)</span>

    <span class="s1">assert_allclose(res2.llf</span><span class="s2">, </span><span class="s1">res_e.llf)</span>


<span class="s2">def </span><span class="s1">test_append_with_exog_and_trend():</span>
    <span class="s4"># Numpy</span>
    <span class="s1">endog = dta[</span><span class="s3">'infl'</span><span class="s1">].iloc[:</span><span class="s5">100</span><span class="s1">].values</span>
    <span class="s1">exog = np.arange(len(endog))**</span><span class="s5">2</span>
    <span class="s1">mod = ARIMA(endog[:</span><span class="s5">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">exog=exog[:</span><span class="s5">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'ct'</span><span class="s1">)</span>
    <span class="s1">res = mod.fit()</span>
    <span class="s1">res_e = res.append(endog[</span><span class="s5">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s5">50</span><span class="s1">:])</span>
    <span class="s1">mod2 = ARIMA(endog</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'ct'</span><span class="s1">)</span>
    <span class="s1">res2 = mod2.filter(res_e.params)</span>

    <span class="s1">assert_allclose(res2.llf</span><span class="s2">, </span><span class="s1">res_e.llf)</span>


<span class="s2">def </span><span class="s1">test_append_with_exog_pandas():</span>
    <span class="s4"># Pandas</span>
    <span class="s1">endog = dta[</span><span class="s3">'infl'</span><span class="s1">].iloc[:</span><span class="s5">100</span><span class="s1">]</span>
    <span class="s1">exog = pd.Series(np.arange(len(endog))</span><span class="s2">, </span><span class="s1">index=endog.index)</span>
    <span class="s1">mod = ARIMA(endog.iloc[:</span><span class="s5">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">exog=exog.iloc[:</span><span class="s5">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'c'</span><span class="s1">)</span>
    <span class="s1">res = mod.fit()</span>
    <span class="s1">res_e = res.append(endog.iloc[</span><span class="s5">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">exog=exog.iloc[</span><span class="s5">50</span><span class="s1">:])</span>
    <span class="s1">mod2 = ARIMA(endog</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'c'</span><span class="s1">)</span>
    <span class="s1">res2 = mod2.filter(res_e.params)</span>

    <span class="s1">assert_allclose(res2.llf</span><span class="s2">, </span><span class="s1">res_e.llf)</span>


<span class="s2">def </span><span class="s1">test_cov_type_none():</span>
    <span class="s1">endog = dta[</span><span class="s3">'infl'</span><span class="s1">].iloc[:</span><span class="s5">100</span><span class="s1">].values</span>
    <span class="s1">mod = ARIMA(endog[:</span><span class="s5">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'c'</span><span class="s1">)</span>
    <span class="s1">res = mod.fit(cov_type=</span><span class="s3">'none'</span><span class="s1">)</span>
    <span class="s1">assert_allclose(res.cov_params()</span><span class="s2">, </span><span class="s1">np.nan)</span>


<span class="s2">def </span><span class="s1">test_nonstationary_gls_error():</span>
    <span class="s4"># GH-6540</span>
    <span class="s1">endog = pd.read_csv(</span>
        <span class="s1">io.StringIO(</span>
            <span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">data</span><span class="s2">\n</span>
<span class="s3">9.112</span><span class="s2">\n</span><span class="s3">9.102</span><span class="s2">\n</span><span class="s3">9.103</span><span class="s2">\n</span><span class="s3">9.099</span><span class="s2">\n</span><span class="s3">9.094</span><span class="s2">\n</span><span class="s3">9.090</span><span class="s2">\n</span><span class="s3">9.108</span><span class="s2">\n</span><span class="s3">9.088</span><span class="s2">\n</span><span class="s3">9.091</span><span class="s2">\n</span><span class="s3">9.083</span><span class="s2">\n</span><span class="s3">9.095</span><span class="s2">\n</span>
<span class="s3">9.090</span><span class="s2">\n</span><span class="s3">9.098</span><span class="s2">\n</span><span class="s3">9.093</span><span class="s2">\n</span><span class="s3">9.087</span><span class="s2">\n</span><span class="s3">9.088</span><span class="s2">\n</span><span class="s3">9.083</span><span class="s2">\n</span><span class="s3">9.095</span><span class="s2">\n</span><span class="s3">9.077</span><span class="s2">\n</span><span class="s3">9.082</span><span class="s2">\n</span><span class="s3">9.082</span><span class="s2">\n</span><span class="s3">9.081</span><span class="s2">\n</span>
<span class="s3">9.081</span><span class="s2">\n</span><span class="s3">9.079</span><span class="s2">\n</span><span class="s3">9.088</span><span class="s2">\n</span><span class="s3">9.096</span><span class="s2">\n</span><span class="s3">9.081</span><span class="s2">\n</span><span class="s3">9.098</span><span class="s2">\n</span><span class="s3">9.081</span><span class="s2">\n</span><span class="s3">9.094</span><span class="s2">\n</span><span class="s3">9.091</span><span class="s2">\n</span><span class="s3">9.095</span><span class="s2">\n</span><span class="s3">9.097</span><span class="s2">\n</span>
<span class="s3">9.108</span><span class="s2">\n</span><span class="s3">9.104</span><span class="s2">\n</span><span class="s3">9.098</span><span class="s2">\n</span><span class="s3">9.085</span><span class="s2">\n</span><span class="s3">9.093</span><span class="s2">\n</span><span class="s3">9.094</span><span class="s2">\n</span><span class="s3">9.092</span><span class="s2">\n</span><span class="s3">9.093</span><span class="s2">\n</span><span class="s3">9.106</span><span class="s2">\n</span><span class="s3">9.097</span><span class="s2">\n</span><span class="s3">9.108</span><span class="s2">\n</span>
<span class="s3">9.100</span><span class="s2">\n</span><span class="s3">9.106</span><span class="s2">\n</span><span class="s3">9.114</span><span class="s2">\n</span><span class="s3">9.111</span><span class="s2">\n</span><span class="s3">9.097</span><span class="s2">\n</span><span class="s3">9.099</span><span class="s2">\n</span><span class="s3">9.108</span><span class="s2">\n</span><span class="s3">9.108</span><span class="s2">\n</span><span class="s3">9.110</span><span class="s2">\n</span><span class="s3">9.101</span><span class="s2">\n</span><span class="s3">9.111</span><span class="s2">\n</span>
<span class="s3">9.114</span><span class="s2">\n</span><span class="s3">9.111</span><span class="s2">\n</span><span class="s3">9.126</span><span class="s2">\n</span><span class="s3">9.124</span><span class="s2">\n</span><span class="s3">9.112</span><span class="s2">\n</span><span class="s3">9.120</span><span class="s2">\n</span><span class="s3">9.142</span><span class="s2">\n</span><span class="s3">9.136</span><span class="s2">\n</span><span class="s3">9.131</span><span class="s2">\n</span><span class="s3">9.106</span><span class="s2">\n</span><span class="s3">9.112</span><span class="s2">\n</span>
<span class="s3">9.119</span><span class="s2">\n</span><span class="s3">9.125</span><span class="s2">\n</span><span class="s3">9.123</span><span class="s2">\n</span><span class="s3">9.138</span><span class="s2">\n</span><span class="s3">9.133</span><span class="s2">\n</span><span class="s3">9.133</span><span class="s2">\n</span><span class="s3">9.137</span><span class="s2">\n</span><span class="s3">9.133</span><span class="s2">\n</span><span class="s3">9.138</span><span class="s2">\n</span><span class="s3">9.136</span><span class="s2">\n</span><span class="s3">9.128</span><span class="s2">\n</span>
<span class="s3">9.127</span><span class="s2">\n</span><span class="s3">9.143</span><span class="s2">\n</span><span class="s3">9.128</span><span class="s2">\n</span><span class="s3">9.135</span><span class="s2">\n</span><span class="s3">9.133</span><span class="s2">\n</span><span class="s3">9.131</span><span class="s2">\n</span><span class="s3">9.136</span><span class="s2">\n</span><span class="s3">9.120</span><span class="s2">\n</span><span class="s3">9.127</span><span class="s2">\n</span><span class="s3">9.130</span><span class="s2">\n</span><span class="s3">9.116</span><span class="s2">\n</span>
<span class="s3">9.132</span><span class="s2">\n</span><span class="s3">9.128</span><span class="s2">\n</span><span class="s3">9.119</span><span class="s2">\n</span><span class="s3">9.119</span><span class="s2">\n</span><span class="s3">9.110</span><span class="s2">\n</span><span class="s3">9.132</span><span class="s2">\n</span><span class="s3">9.130</span><span class="s2">\n</span><span class="s3">9.124</span><span class="s2">\n</span><span class="s3">9.130</span><span class="s2">\n</span><span class="s3">9.135</span><span class="s2">\n</span><span class="s3">9.135</span><span class="s2">\n</span>
<span class="s3">9.119</span><span class="s2">\n</span><span class="s3">9.119</span><span class="s2">\n</span><span class="s3">9.136</span><span class="s2">\n</span><span class="s3">9.126</span><span class="s2">\n</span><span class="s3">9.122</span><span class="s2">\n</span><span class="s3">9.119</span><span class="s2">\n</span><span class="s3">9.123</span><span class="s2">\n</span><span class="s3">9.121</span><span class="s2">\n</span><span class="s3">9.130</span><span class="s2">\n</span><span class="s3">9.121</span><span class="s2">\n</span><span class="s3">9.119</span><span class="s2">\n</span>
<span class="s3">9.106</span><span class="s2">\n</span><span class="s3">9.118</span><span class="s2">\n</span><span class="s3">9.124</span><span class="s2">\n</span><span class="s3">9.121</span><span class="s2">\n</span><span class="s3">9.127</span><span class="s2">\n</span><span class="s3">9.113</span><span class="s2">\n</span><span class="s3">9.118</span><span class="s2">\n</span><span class="s3">9.103</span><span class="s2">\n</span><span class="s3">9.112</span><span class="s2">\n</span><span class="s3">9.110</span><span class="s2">\n</span><span class="s3">9.111</span><span class="s2">\n</span>
<span class="s3">9.108</span><span class="s2">\n</span><span class="s3">9.113</span><span class="s2">\n</span><span class="s3">9.117</span><span class="s2">\n</span><span class="s3">9.111</span><span class="s2">\n</span><span class="s3">9.100</span><span class="s2">\n</span><span class="s3">9.106</span><span class="s2">\n</span><span class="s3">9.109</span><span class="s2">\n</span><span class="s3">9.113</span><span class="s2">\n</span><span class="s3">9.110</span><span class="s2">\n</span><span class="s3">9.101</span><span class="s2">\n</span><span class="s3">9.113</span><span class="s2">\n</span>
<span class="s3">9.111</span><span class="s2">\n</span><span class="s3">9.101</span><span class="s2">\n</span><span class="s3">9.097</span><span class="s2">\n</span><span class="s3">9.102</span><span class="s2">\n</span><span class="s3">9.100</span><span class="s2">\n</span><span class="s3">9.110</span><span class="s2">\n</span><span class="s3">9.110</span><span class="s2">\n</span><span class="s3">9.096</span><span class="s2">\n</span><span class="s3">9.095</span><span class="s2">\n</span><span class="s3">9.090</span><span class="s2">\n</span><span class="s3">9.104</span><span class="s2">\n</span>
<span class="s3">9.097</span><span class="s2">\n</span><span class="s3">9.099</span><span class="s2">\n</span><span class="s3">9.095</span><span class="s2">\n</span><span class="s3">9.096</span><span class="s2">\n</span><span class="s3">9.085</span><span class="s2">\n</span><span class="s3">9.097</span><span class="s2">\n</span><span class="s3">9.098</span><span class="s2">\n</span><span class="s3">9.090</span><span class="s2">\n</span><span class="s3">9.080</span><span class="s2">\n</span><span class="s3">9.093</span><span class="s2">\n</span><span class="s3">9.085</span><span class="s2">\n</span>
<span class="s3">9.075</span><span class="s2">\n</span><span class="s3">9.067</span><span class="s2">\n</span><span class="s3">9.072</span><span class="s2">\n</span><span class="s3">9.062</span><span class="s2">\n</span><span class="s3">9.068</span><span class="s2">\n</span><span class="s3">9.053</span><span class="s2">\n</span><span class="s3">9.051</span><span class="s2">\n</span><span class="s3">9.049</span><span class="s2">\n</span><span class="s3">9.052</span><span class="s2">\n</span><span class="s3">9.059</span><span class="s2">\n</span><span class="s3">9.070</span><span class="s2">\n</span>
<span class="s3">9.058</span><span class="s2">\n</span><span class="s3">9.074</span><span class="s2">\n</span><span class="s3">9.063</span><span class="s2">\n</span><span class="s3">9.057</span><span class="s2">\n</span><span class="s3">9.062</span><span class="s2">\n</span><span class="s3">9.058</span><span class="s2">\n</span><span class="s3">9.049</span><span class="s2">\n</span><span class="s3">9.047</span><span class="s2">\n</span><span class="s3">9.062</span><span class="s2">\n</span><span class="s3">9.052</span><span class="s2">\n</span><span class="s3">9.052</span><span class="s2">\n</span>
<span class="s3">9.044</span><span class="s2">\n</span><span class="s3">9.060</span><span class="s2">\n</span><span class="s3">9.062</span><span class="s2">\n</span><span class="s3">9.055</span><span class="s2">\n</span><span class="s3">9.058</span><span class="s2">\n</span><span class="s3">9.054</span><span class="s2">\n</span><span class="s3">9.044</span><span class="s2">\n</span><span class="s3">9.047</span><span class="s2">\n</span><span class="s3">9.050</span><span class="s2">\n</span><span class="s3">9.048</span><span class="s2">\n</span><span class="s3">9.041</span><span class="s2">\n</span>
<span class="s3">9.055</span><span class="s2">\n</span><span class="s3">9.051</span><span class="s2">\n</span><span class="s3">9.028</span><span class="s2">\n</span><span class="s3">9.030</span><span class="s2">\n</span><span class="s3">9.029</span><span class="s2">\n</span><span class="s3">9.027</span><span class="s2">\n</span><span class="s3">9.016</span><span class="s2">\n</span><span class="s3">9.023</span><span class="s2">\n</span><span class="s3">9.031</span><span class="s2">\n</span><span class="s3">9.042</span><span class="s2">\n</span><span class="s3">9.035</span><span class="s2">\n</span>
<span class="s3">&quot;&quot;&quot;</span>
        <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">index_col=</span><span class="s2">None,</span>
    <span class="s1">)</span>
    <span class="s1">mod = ARIMA(</span>
        <span class="s1">endog</span><span class="s2">,</span>
        <span class="s1">order=(</span><span class="s5">18</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">39</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">enforce_stationarity=</span><span class="s2">False,</span>
        <span class="s1">enforce_invertibility=</span><span class="s2">False,</span>
    <span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Roots of the autoregressive&quot;</span><span class="s1">):</span>
        <span class="s1">mod.fit(method=</span><span class="s3">&quot;hannan_rissanen&quot;</span><span class="s2">, </span><span class="s1">low_memory=</span><span class="s2">True, </span><span class="s1">cov_type=</span><span class="s3">&quot;none&quot;</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;ar_order, ma_order, fixed_params&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">{})</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'ar.L1'</span><span class="s1">: </span><span class="s5">0</span><span class="s1">})</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'ar.L2'</span><span class="s1">: -</span><span class="s5">1</span><span class="s2">, </span><span class="s3">'ma.L1'</span><span class="s1">: </span><span class="s5">2</span><span class="s1">})</span><span class="s2">,</span>
        <span class="s1">([</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'ar.L2'</span><span class="s1">: </span><span class="s5">0</span><span class="s1">})</span><span class="s2">,</span>
        <span class="s1">([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'ar.L5'</span><span class="s1">: -</span><span class="s5">10</span><span class="s2">, </span><span class="s3">'ma.L3'</span><span class="s1">: </span><span class="s5">5</span><span class="s1">})</span><span class="s2">,</span>
    <span class="s1">]</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_hannan_rissanen_with_fixed_params(ar_order</span><span class="s2">, </span><span class="s1">ma_order</span><span class="s2">, </span><span class="s1">fixed_params):</span>
    <span class="s4"># Test for basic uses of Hannan-Rissanen estimation with fixed parameters</span>
    <span class="s1">endog = dta[</span><span class="s3">'infl'</span><span class="s1">].diff().iloc[</span><span class="s5">1</span><span class="s1">:</span><span class="s5">101</span><span class="s1">]</span>

    <span class="s1">desired_p</span><span class="s2">, </span><span class="s1">_ = hannan_rissanen(</span>
        <span class="s1">endog</span><span class="s2">, </span><span class="s1">ar_order=ar_order</span><span class="s2">, </span><span class="s1">ma_order=ma_order</span><span class="s2">,</span>
        <span class="s1">demean=</span><span class="s2">False, </span><span class="s1">fixed_params=fixed_params</span>
    <span class="s1">)</span>
    <span class="s4"># no constant or trend (since constant or trend would imply GLS estimation)</span>
    <span class="s1">mod = ARIMA(endog</span><span class="s2">, </span><span class="s1">order=(ar_order</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">ma_order)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'n'</span><span class="s2">,</span>
                <span class="s1">enforce_stationarity=</span><span class="s2">False, </span><span class="s1">enforce_invertibility=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">mod.fix_params(fixed_params):</span>
        <span class="s1">res = mod.fit(method=</span><span class="s3">'hannan_rissanen'</span><span class="s1">)</span>

    <span class="s1">assert_allclose(res.params</span><span class="s2">, </span><span class="s1">desired_p.params)</span>
</pre>
</body>
</html>