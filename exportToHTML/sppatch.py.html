<html>
<head>
<title>sppatch.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
sppatch.py</font>
</center></td></tr></table>
<pre><span class="s0">'''patching scipy to fit distributions and expect method 
 
This adds new methods to estimate continuous distribution parameters with some 
fixed/frozen parameters. It also contains functions that calculate the expected 
value of a function for any continuous or discrete distribution 
 
It temporarily also contains Bootstrap and Monte Carlo function for testing the 
distribution fit, but these are neither general nor verified. 
 
Author: josef-pktd 
License: Simplified BSD 
'''</span>
<span class="s2">from </span><span class="s1">statsmodels.compat.python </span><span class="s2">import </span><span class="s1">lmap</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">stats</span><span class="s2">, </span><span class="s1">optimize</span><span class="s2">, </span><span class="s1">integrate</span>


<span class="s3">########## patching scipy</span>

<span class="s3">#vonmises does not define finite bounds, because it is intended for circular</span>
<span class="s3">#support which does not define a proper pdf on the real line</span>

<span class="s1">stats.distributions.vonmises.a = -np.pi</span>
<span class="s1">stats.distributions.vonmises.b = np.pi</span>

<span class="s3">#the next 3 functions are for fit with some fixed parameters</span>
<span class="s3">#As they are written, they do not work as functions, only as methods</span>

<span class="s2">def </span><span class="s1">_fitstart(self</span><span class="s2">, </span><span class="s1">x):</span>
    <span class="s0">'''example method, method of moment estimator as starting values 
 
    Parameters 
    ---------- 
    x : ndarray 
        data for which the parameters are estimated 
 
    Returns 
    ------- 
    est : tuple 
        preliminary estimates used as starting value for fitting, not 
        necessarily a consistent estimator 
 
    Notes 
    ----- 
    This needs to be written and attached to each individual distribution 
 
    This example was written for the gamma distribution, but not verified 
    with literature 
 
    '''</span>
    <span class="s1">loc = np.min([x.min()</span><span class="s2">,</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">a = </span><span class="s4">4</span><span class="s1">/stats.skew(x)**</span><span class="s4">2</span>
    <span class="s1">scale = np.std(x) / np.sqrt(a)</span>
    <span class="s2">return </span><span class="s1">(a</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale)</span>

<span class="s2">def </span><span class="s1">_fitstart_beta(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">fixed=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">'''method of moment estimator as starting values for beta distribution 
 
    Parameters 
    ---------- 
    x : ndarray 
        data for which the parameters are estimated 
    fixed : None or array_like 
        sequence of numbers and np.nan to indicate fixed parameters and parameters 
        to estimate 
 
    Returns 
    ------- 
    est : tuple 
        preliminary estimates used as starting value for fitting, not 
        necessarily a consistent estimator 
 
    Notes 
    ----- 
    This needs to be written and attached to each individual distribution 
 
    References 
    ---------- 
    for method of moment estimator for known loc and scale 
    https://en.wikipedia.org/wiki/Beta_distribution#Parameter_estimation 
    http://www.itl.nist.gov/div898/handbook/eda/section3/eda366h.htm 
    NIST reference also includes reference to MLE in 
    Johnson, Kotz, and Balakrishan, Volume II, pages 221-235 
 
    '''</span>
    <span class="s3">#todo: separate out this part to be used for other compact support distributions</span>
    <span class="s3">#      e.g. rdist, vonmises, and truncnorm</span>
    <span class="s3">#      but this might not work because it might still be distribution specific</span>
    <span class="s1">a</span><span class="s2">, </span><span class="s1">b = x.min()</span><span class="s2">, </span><span class="s1">x.max()</span>
    <span class="s1">eps = (a-b)*</span><span class="s4">0.01</span>
    <span class="s2">if </span><span class="s1">fixed </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s3">#this part not checked with books</span>
        <span class="s1">loc = a - eps</span>
        <span class="s1">scale = (a - b) * (</span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">2</span><span class="s1">*eps)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">np.isnan(fixed[-</span><span class="s4">2</span><span class="s1">]):</span>
            <span class="s3">#estimate loc</span>
            <span class="s1">loc = a - eps</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">loc = fixed[-</span><span class="s4">2</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">np.isnan(fixed[-</span><span class="s4">1</span><span class="s1">]):</span>
            <span class="s3">#estimate scale</span>
            <span class="s1">scale = (b + eps) - loc</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">scale = fixed[-</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s3">#method of moment for known loc scale:</span>
    <span class="s1">scale = float(scale)</span>
    <span class="s1">xtrans = (x - loc)/scale</span>
    <span class="s1">xm = xtrans.mean()</span>
    <span class="s1">xv = xtrans.var()</span>
    <span class="s1">tmp = (xm*(</span><span class="s4">1</span><span class="s1">-xm)/xv - </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">p = xm * tmp</span>
    <span class="s1">q = (</span><span class="s4">1 </span><span class="s1">- xm) * tmp</span>

    <span class="s2">return </span><span class="s1">(p</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale)  </span><span class="s3">#check return type and should fixed be returned ?</span>

<span class="s2">def </span><span class="s1">_fitstart_poisson(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">fixed=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">'''maximum likelihood estimator as starting values for Poisson distribution 
 
    Parameters 
    ---------- 
    x : ndarray 
        data for which the parameters are estimated 
    fixed : None or array_like 
        sequence of numbers and np.nan to indicate fixed parameters and parameters 
        to estimate 
 
    Returns 
    ------- 
    est : tuple 
        preliminary estimates used as starting value for fitting, not 
        necessarily a consistent estimator 
 
    Notes 
    ----- 
    This needs to be written and attached to each individual distribution 
 
    References 
    ---------- 
    MLE : 
    https://en.wikipedia.org/wiki/Poisson_distribution#Maximum_likelihood 
 
    '''</span>
    <span class="s3">#todo: separate out this part to be used for other compact support distributions</span>
    <span class="s3">#      e.g. rdist, vonmises, and truncnorm</span>
    <span class="s3">#      but this might not work because it might still be distribution specific</span>
    <span class="s1">a = x.min()</span>
    <span class="s1">eps = </span><span class="s4">0 </span><span class="s3"># is this robust ?</span>
    <span class="s2">if </span><span class="s1">fixed </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s3">#this part not checked with books</span>
        <span class="s1">loc = a - eps</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">np.isnan(fixed[-</span><span class="s4">1</span><span class="s1">]):</span>
            <span class="s3">#estimate loc</span>
            <span class="s1">loc = a - eps</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">loc = fixed[-</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s3">#MLE for standard (unshifted, if loc=0) Poisson distribution</span>

    <span class="s1">xtrans = (x - loc)</span>
    <span class="s1">lambd = xtrans.mean()</span>
    <span class="s3">#second derivative d loglike/ dlambd Not used</span>
    <span class="s3">#dlldlambd = 1/lambd # check</span>

    <span class="s2">return </span><span class="s1">(lambd</span><span class="s2">, </span><span class="s1">loc)  </span><span class="s3">#check return type and should fixed be returned ?</span>


<span class="s2">def </span><span class="s1">nnlf_fr(self</span><span class="s2">, </span><span class="s1">thetash</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">frmask):</span>
    <span class="s3"># new frozen version</span>
    <span class="s3"># - sum (log pdf(x, theta),axis=0)</span>
    <span class="s3">#   where theta are the parameters (including loc and scale)</span>
    <span class="s3">#</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">frmask </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">theta = frmask.copy()</span>
            <span class="s1">theta[np.isnan(frmask)] = thetash</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">theta = thetash</span>
        <span class="s1">loc = theta[-</span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">scale = theta[-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">args = tuple(theta[:-</span><span class="s4">2</span><span class="s1">])</span>
    <span class="s2">except </span><span class="s1">IndexError:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Not enough input arguments.&quot;</span><span class="s1">)</span>
    <span class="s2">if not </span><span class="s1">self._argcheck(*args) </span><span class="s2">or </span><span class="s1">scale &lt;= </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">np.inf</span>
    <span class="s1">x = np.array((x-loc) / scale)</span>
    <span class="s1">cond0 = (x &lt;= self.a) | (x &gt;= self.b)</span>
    <span class="s2">if </span><span class="s1">(np.any(cond0)):</span>
        <span class="s2">return </span><span class="s1">np.inf</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">N = len(x)</span>
        <span class="s3">#raise ValueError</span>
        <span class="s2">return </span><span class="s1">self._nnlf(x</span><span class="s2">, </span><span class="s1">*args) + N*np.log(scale)</span>

<span class="s2">def </span><span class="s1">fit_fr(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
    <span class="s0">'''estimate distribution parameters by MLE taking some parameters as fixed 
 
    Parameters 
    ---------- 
    data : ndarray, 1d 
        data for which the distribution parameters are estimated, 
    args : list ? check 
        starting values for optimization 
    kwds : 
 
      - 'frozen' : array_like 
           values for frozen distribution parameters and, for elements with 
           np.nan, the corresponding parameter will be estimated 
 
    Returns 
    ------- 
    argest : ndarray 
        estimated parameters 
 
 
    Examples 
    -------- 
    generate random sample 
    &gt;&gt;&gt; np.random.seed(12345) 
    &gt;&gt;&gt; x = stats.gamma.rvs(2.5, loc=0, scale=1.2, size=200) 
 
    estimate all parameters 
    &gt;&gt;&gt; stats.gamma.fit(x) 
    array([ 2.0243194 ,  0.20395655,  1.44411371]) 
    &gt;&gt;&gt; stats.gamma.fit_fr(x, frozen=[np.nan, np.nan, np.nan]) 
    array([ 2.0243194 ,  0.20395655,  1.44411371]) 
 
    keep loc fixed, estimate shape and scale parameters 
    &gt;&gt;&gt; stats.gamma.fit_fr(x, frozen=[np.nan, 0.0, np.nan]) 
    array([ 2.45603985,  1.27333105]) 
 
    keep loc and scale fixed, estimate shape parameter 
    &gt;&gt;&gt; stats.gamma.fit_fr(x, frozen=[np.nan, 0.0, 1.0]) 
    array([ 3.00048828]) 
    &gt;&gt;&gt; stats.gamma.fit_fr(x, frozen=[np.nan, 0.0, 1.2]) 
    array([ 2.57792969]) 
 
    estimate only scale parameter for fixed shape and loc 
    &gt;&gt;&gt; stats.gamma.fit_fr(x, frozen=[2.5, 0.0, np.nan]) 
    array([ 1.25087891]) 
 
    Notes 
    ----- 
    self is an instance of a distribution class. This can be attached to 
    scipy.stats.distributions.rv_continuous 
 
    *Todo* 
 
    * check if docstring is correct 
    * more input checking, args is list ? might also apply to current fit method 
 
    '''</span>
    <span class="s1">loc0</span><span class="s2">, </span><span class="s1">scale0 = lmap(kwds.get</span><span class="s2">, </span><span class="s1">[</span><span class="s5">'loc'</span><span class="s2">, </span><span class="s5">'scale'</span><span class="s1">]</span><span class="s2">,</span><span class="s1">[</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">])</span>
    <span class="s1">Narg = len(args)</span>

    <span class="s2">if </span><span class="s1">Narg == </span><span class="s4">0 </span><span class="s2">and </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s5">'_fitstart'</span><span class="s1">):</span>
        <span class="s1">x0 = self._fitstart(data)</span>
    <span class="s2">elif </span><span class="s1">Narg &gt; self.numargs:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Too many input arguments.&quot;</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">args += (</span><span class="s4">1.0</span><span class="s2">,</span><span class="s1">)*(self.numargs-Narg)</span>
        <span class="s3"># location and scale are at the end</span>
        <span class="s1">x0 = args + (loc0</span><span class="s2">, </span><span class="s1">scale0)</span>

    <span class="s2">if </span><span class="s5">'frozen' </span><span class="s2">in </span><span class="s1">kwds:</span>
        <span class="s1">frmask = np.array(kwds[</span><span class="s5">'frozen'</span><span class="s1">])</span>
        <span class="s2">if </span><span class="s1">len(frmask) != self.numargs+</span><span class="s4">2</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Incorrect number of frozen arguments.&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># keep starting values for not frozen parameters</span>
            <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(len(frmask)):</span>
                <span class="s3"># Troubleshooting ex_generic_mle_tdist</span>
                <span class="s2">if </span><span class="s1">isinstance(frmask[n]</span><span class="s2">, </span><span class="s1">np.ndarray) </span><span class="s2">and </span><span class="s1">frmask[n].size == </span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s1">frmask[n] = frmask[n].item()</span>

            <span class="s3"># If there were array elements, then frmask will be object-dtype,</span>
            <span class="s3">#  in which case np.isnan will raise TypeError</span>
            <span class="s1">frmask = frmask.astype(np.float64)</span>
            <span class="s1">x0  = np.array(x0)[np.isnan(frmask)]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">frmask = </span><span class="s2">None</span>

    <span class="s3">#print(x0</span>
    <span class="s3">#print(frmask</span>
    <span class="s2">return </span><span class="s1">optimize.fmin(self.nnlf_fr</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">,</span>
                <span class="s1">args=(np.ravel(data)</span><span class="s2">, </span><span class="s1">frmask)</span><span class="s2">, </span><span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>


<span class="s3">#The next two functions/methods calculate expected value of an arbitrary</span>
<span class="s3">#function, however for the continuous functions intquad is use, which might</span>
<span class="s3">#require continuouity or smoothness in the function.</span>


<span class="s3">#TODO: add option for Monte Carlo integration</span>

<span class="s2">def </span><span class="s1">expect(self</span><span class="s2">, </span><span class="s1">fn=</span><span class="s2">None, </span><span class="s1">args=()</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">lb=</span><span class="s2">None, </span><span class="s1">ub=</span><span class="s2">None, </span><span class="s1">conditional=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">'''calculate expected value of a function with respect to the distribution 
 
    location and scale only tested on a few examples 
 
    Parameters 
    ---------- 
        all parameters are keyword parameters 
        fn : function (default: identity mapping) 
           Function for which integral is calculated. Takes only one argument. 
        args : tuple 
           argument (parameters) of the distribution 
        lb, ub : numbers 
           lower and upper bound for integration, default is set to the support 
           of the distribution 
        conditional : bool (False) 
           If true then the integral is corrected by the conditional probability 
           of the integration interval. The return value is the expectation 
           of the function, conditional on being in the given interval. 
 
    Returns 
    ------- 
        expected value : float 
 
    Notes 
    ----- 
    This function has not been checked for it's behavior when the integral is 
    not finite. The integration behavior is inherited from scipy.integrate.quad. 
 
    '''</span>
    <span class="s2">if </span><span class="s1">fn </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">def </span><span class="s1">fun(x</span><span class="s2">, </span><span class="s1">*args):</span>
            <span class="s2">return </span><span class="s1">x*self.pdf(x</span><span class="s2">, </span><span class="s1">loc=loc</span><span class="s2">, </span><span class="s1">scale=scale</span><span class="s2">, </span><span class="s1">*args)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">def </span><span class="s1">fun(x</span><span class="s2">, </span><span class="s1">*args):</span>
            <span class="s2">return </span><span class="s1">fn(x)*self.pdf(x</span><span class="s2">, </span><span class="s1">loc=loc</span><span class="s2">, </span><span class="s1">scale=scale</span><span class="s2">, </span><span class="s1">*args)</span>
    <span class="s2">if </span><span class="s1">lb </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">lb = loc + self.a * scale </span><span class="s3">#(self.a - loc)/(1.0*scale)</span>
    <span class="s2">if </span><span class="s1">ub </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">ub = loc + self.b * scale </span><span class="s3">#(self.b - loc)/(1.0*scale)</span>
    <span class="s2">if </span><span class="s1">conditional:</span>
        <span class="s1">invfac = (self.sf(lb</span><span class="s2">, </span><span class="s1">loc=loc</span><span class="s2">, </span><span class="s1">scale=scale</span><span class="s2">, </span><span class="s1">*args)</span>
                  <span class="s1">- self.sf(ub</span><span class="s2">, </span><span class="s1">loc=loc</span><span class="s2">, </span><span class="s1">scale=scale</span><span class="s2">, </span><span class="s1">*args))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">invfac = </span><span class="s4">1.0</span>
    <span class="s2">return </span><span class="s1">integrate.quad(fun</span><span class="s2">, </span><span class="s1">lb</span><span class="s2">, </span><span class="s1">ub</span><span class="s2">,</span>
                                <span class="s1">args=args)[</span><span class="s4">0</span><span class="s1">]/invfac</span>


<span class="s2">def </span><span class="s1">expect_v2(self</span><span class="s2">, </span><span class="s1">fn=</span><span class="s2">None, </span><span class="s1">args=()</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">lb=</span><span class="s2">None, </span><span class="s1">ub=</span><span class="s2">None, </span><span class="s1">conditional=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">'''calculate expected value of a function with respect to the distribution 
 
    location and scale only tested on a few examples 
 
    Parameters 
    ---------- 
        all parameters are keyword parameters 
        fn : function (default: identity mapping) 
           Function for which integral is calculated. Takes only one argument. 
        args : tuple 
           argument (parameters) of the distribution 
        lb, ub : numbers 
           lower and upper bound for integration, default is set using 
           quantiles of the distribution, see Notes 
        conditional : bool (False) 
           If true then the integral is corrected by the conditional probability 
           of the integration interval. The return value is the expectation 
           of the function, conditional on being in the given interval. 
 
    Returns 
    ------- 
        expected value : float 
 
    Notes 
    ----- 
    This function has not been checked for it's behavior when the integral is 
    not finite. The integration behavior is inherited from scipy.integrate.quad. 
 
    The default limits are lb = self.ppf(1e-9, *args), ub = self.ppf(1-1e-9, *args) 
 
    For some heavy tailed distributions, 'alpha', 'cauchy', 'halfcauchy', 
    'levy', 'levy_l', and for 'ncf', the default limits are not set correctly 
    even  when the expectation of the function is finite. In this case, the 
    integration limits, lb and ub, should be chosen by the user. For example, 
    for the ncf distribution, ub=1000 works in the examples. 
 
    There are also problems with numerical integration in some other cases, 
    for example if the distribution is very concentrated and the default limits 
    are too large. 
 
    '''</span>
    <span class="s3">#changes: 20100809</span>
    <span class="s3">#correction and refactoring how loc and scale are handled</span>
    <span class="s3">#uses now _pdf</span>
    <span class="s3">#needs more testing for distribution with bound support, e.g. genpareto</span>

    <span class="s2">if </span><span class="s1">fn </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">def </span><span class="s1">fun(x</span><span class="s2">, </span><span class="s1">*args):</span>
            <span class="s2">return </span><span class="s1">(loc + x*scale)*self._pdf(x</span><span class="s2">, </span><span class="s1">*args)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">def </span><span class="s1">fun(x</span><span class="s2">, </span><span class="s1">*args):</span>
            <span class="s2">return </span><span class="s1">fn(loc + x*scale)*self._pdf(x</span><span class="s2">, </span><span class="s1">*args)</span>
    <span class="s2">if </span><span class="s1">lb </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s3">#lb = self.a</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">lb = self.ppf(</span><span class="s4">1e-9</span><span class="s2">, </span><span class="s1">*args)  </span><span class="s3">#1e-14 quad fails for pareto</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s1">lb = self.a</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">lb = max(self.a</span><span class="s2">, </span><span class="s1">(lb - loc)/(</span><span class="s4">1.0</span><span class="s1">*scale)) </span><span class="s3">#transform to standardized</span>
    <span class="s2">if </span><span class="s1">ub </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s3">#ub = self.b</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">ub = self.ppf(</span><span class="s4">1</span><span class="s1">-</span><span class="s4">1e-9</span><span class="s2">, </span><span class="s1">*args)</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s1">ub = self.b</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">ub = min(self.b</span><span class="s2">, </span><span class="s1">(ub - loc)/(</span><span class="s4">1.0</span><span class="s1">*scale))</span>
    <span class="s2">if </span><span class="s1">conditional:</span>
        <span class="s1">invfac = self._sf(lb</span><span class="s2">,</span><span class="s1">*args) - self._sf(ub</span><span class="s2">,</span><span class="s1">*args)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">invfac = </span><span class="s4">1.0</span>
    <span class="s2">return </span><span class="s1">integrate.quad(fun</span><span class="s2">, </span><span class="s1">lb</span><span class="s2">, </span><span class="s1">ub</span><span class="s2">,</span>
                                <span class="s1">args=args</span><span class="s2">, </span><span class="s1">limit=</span><span class="s4">500</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]/invfac</span>

<span class="s3">### for discrete distributions</span>

<span class="s3">#TODO: check that for a distribution with finite support the calculations are</span>
<span class="s3">#      done with one array summation (np.dot)</span>

<span class="s3">#based on _drv2_moment(self, n, *args), but streamlined</span>
<span class="s2">def </span><span class="s1">expect_discrete(self</span><span class="s2">, </span><span class="s1">fn=</span><span class="s2">None, </span><span class="s1">args=()</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">lb=</span><span class="s2">None, </span><span class="s1">ub=</span><span class="s2">None,</span>
                    <span class="s1">conditional=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">'''calculate expected value of a function with respect to the distribution 
    for discrete distribution 
 
    Parameters 
    ---------- 
        (self : distribution instance as defined in scipy stats) 
        fn : function (default: identity mapping) 
           Function for which integral is calculated. Takes only one argument. 
        args : tuple 
           argument (parameters) of the distribution 
        optional keyword parameters 
        lb, ub : numbers 
           lower and upper bound for integration, default is set to the support 
           of the distribution, lb and ub are inclusive (ul&lt;=k&lt;=ub) 
        conditional : bool (False) 
           If true then the expectation is corrected by the conditional 
           probability of the integration interval. The return value is the 
           expectation of the function, conditional on being in the given 
           interval (k such that ul&lt;=k&lt;=ub). 
 
    Returns 
    ------- 
        expected value : float 
 
    Notes 
    ----- 
    * function is not vectorized 
    * accuracy: uses self.moment_tol as stopping criterium 
        for heavy tailed distribution e.g. zipf(4), accuracy for 
        mean, variance in example is only 1e-5, 
        increasing precision (moment_tol) makes zipf very slow 
    * suppnmin=100 internal parameter for minimum number of points to evaluate 
        could be added as keyword parameter, to evaluate functions with 
        non-monotonic shapes, points include integers in (-suppnmin, suppnmin) 
    * uses maxcount=1000 limits the number of points that are evaluated 
        to break loop for infinite sums 
        (a maximum of suppnmin+1000 positive plus suppnmin+1000 negative integers 
        are evaluated) 
 
 
    '''</span>

    <span class="s3">#moment_tol = 1e-12 # increase compared to self.moment_tol,</span>
    <span class="s3"># too slow for only small gain in precision for zipf</span>

    <span class="s3">#avoid endless loop with unbound integral, eg. var of zipf(2)</span>
    <span class="s1">maxcount = </span><span class="s4">1000</span>
    <span class="s1">suppnmin = </span><span class="s4">100  </span><span class="s3">#minimum number of points to evaluate (+ and -)</span>

    <span class="s2">if </span><span class="s1">fn </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">def </span><span class="s1">fun(x):</span>
            <span class="s3">#loc and args from outer scope</span>
            <span class="s2">return </span><span class="s1">(x+loc)*self._pmf(x</span><span class="s2">, </span><span class="s1">*args)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">def </span><span class="s1">fun(x):</span>
            <span class="s3">#loc and args from outer scope</span>
            <span class="s2">return </span><span class="s1">fn(x+loc)*self._pmf(x</span><span class="s2">, </span><span class="s1">*args)</span>
    <span class="s3"># used pmf because _pmf does not check support in randint</span>
    <span class="s3"># and there might be problems(?) with correct self.a, self.b at this stage</span>
    <span class="s3"># maybe not anymore, seems to work now with _pmf</span>

    <span class="s1">self._argcheck(*args) </span><span class="s3"># (re)generate scalar self.a and self.b</span>
    <span class="s2">if </span><span class="s1">lb </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">lb = (self.a)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">lb = lb - loc</span>

    <span class="s2">if </span><span class="s1">ub </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">ub = (self.b)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">ub = ub - loc</span>
    <span class="s2">if </span><span class="s1">conditional:</span>
        <span class="s1">invfac = self.sf(lb</span><span class="s2">,</span><span class="s1">*args) - self.sf(ub+</span><span class="s4">1</span><span class="s2">,</span><span class="s1">*args)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">invfac = </span><span class="s4">1.0</span>

    <span class="s1">tot = </span><span class="s4">0.0</span>
    <span class="s1">low</span><span class="s2">, </span><span class="s1">upp = self._ppf(</span><span class="s4">0.001</span><span class="s2">, </span><span class="s1">*args)</span><span class="s2">, </span><span class="s1">self._ppf(</span><span class="s4">0.999</span><span class="s2">, </span><span class="s1">*args)</span>
    <span class="s1">low = max(min(-suppnmin</span><span class="s2">, </span><span class="s1">low)</span><span class="s2">, </span><span class="s1">lb)</span>
    <span class="s1">upp = min(max(suppnmin</span><span class="s2">, </span><span class="s1">upp)</span><span class="s2">, </span><span class="s1">ub)</span>
    <span class="s1">supp = np.arange(low</span><span class="s2">, </span><span class="s1">upp+</span><span class="s4">1</span><span class="s2">, </span><span class="s1">self.inc) </span><span class="s3">#check limits</span>
    <span class="s3">#print('low, upp', low, upp</span>
    <span class="s1">tot = np.sum(fun(supp))</span>
    <span class="s1">diff = </span><span class="s4">1e100</span>
    <span class="s1">pos = upp + self.inc</span>
    <span class="s1">count = </span><span class="s4">0</span>

    <span class="s3">#handle cases with infinite support</span>

    <span class="s2">while </span><span class="s1">(pos &lt;= ub) </span><span class="s2">and </span><span class="s1">(diff &gt; self.moment_tol) </span><span class="s2">and </span><span class="s1">count &lt;= maxcount:</span>
        <span class="s1">diff = fun(pos)</span>
        <span class="s1">tot += diff</span>
        <span class="s1">pos += self.inc</span>
        <span class="s1">count += </span><span class="s4">1</span>

    <span class="s2">if </span><span class="s1">self.a &lt; </span><span class="s4">0</span><span class="s1">: </span><span class="s3">#handle case when self.a = -inf</span>
        <span class="s1">diff = </span><span class="s4">1e100</span>
        <span class="s1">pos = low - self.inc</span>
        <span class="s2">while </span><span class="s1">(pos &gt;= lb) </span><span class="s2">and </span><span class="s1">(diff &gt; self.moment_tol) </span><span class="s2">and </span><span class="s1">count &lt;= maxcount:</span>
            <span class="s1">diff = fun(pos)</span>
            <span class="s1">tot += diff</span>
            <span class="s1">pos -= self.inc</span>
            <span class="s1">count += </span><span class="s4">1</span>
    <span class="s2">if </span><span class="s1">count &gt; maxcount:</span>
        <span class="s3"># replace with proper warning</span>
        <span class="s1">print(</span><span class="s5">'sum did not converge'</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">tot/invfac</span>

<span class="s1">stats.distributions.rv_continuous.fit_fr = fit_fr</span>
<span class="s1">stats.distributions.rv_continuous.nnlf_fr = nnlf_fr</span>
<span class="s1">stats.distributions.rv_continuous.expect = expect</span>
<span class="s1">stats.distributions.rv_discrete.expect = expect_discrete</span>
<span class="s1">stats.distributions.beta_gen._fitstart = _fitstart_beta  </span><span class="s3">#not tried out yet</span>
<span class="s1">stats.distributions.poisson_gen._fitstart = _fitstart_poisson  </span><span class="s3">#not tried out yet</span>

<span class="s3">########## end patching scipy</span>


<span class="s2">def </span><span class="s1">distfitbootstrap(sample</span><span class="s2">, </span><span class="s1">distr</span><span class="s2">, </span><span class="s1">nrepl=</span><span class="s4">100</span><span class="s1">):</span>
    <span class="s0">'''run bootstrap for estimation of distribution parameters 
 
    hard coded: only one shape parameter is allowed and estimated, 
        loc=0 and scale=1 are fixed in the estimation 
 
    Parameters 
    ---------- 
    sample : ndarray 
        original sample data for bootstrap 
    distr : distribution instance with fit_fr method 
    nrepl : int 
        number of bootstrap replications 
 
    Returns 
    ------- 
    res : array (nrepl,) 
        parameter estimates for all bootstrap replications 
 
    '''</span>
    <span class="s1">nobs = len(sample)</span>
    <span class="s1">res = np.zeros(nrepl)</span>
    <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">range(nrepl):</span>
        <span class="s1">rvsind = np.random.randint(nobs</span><span class="s2">, </span><span class="s1">size=nobs)</span>
        <span class="s1">x = sample[rvsind]</span>
        <span class="s1">res[ii] = distr.fit_fr(x</span><span class="s2">, </span><span class="s1">frozen=[np.nan</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">])</span>
    <span class="s2">return </span><span class="s1">res</span>

<span class="s2">def </span><span class="s1">distfitmc(sample</span><span class="s2">, </span><span class="s1">distr</span><span class="s2">, </span><span class="s1">nrepl=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">distkwds={}):</span>
    <span class="s0">'''run Monte Carlo for estimation of distribution parameters 
 
    hard coded: only one shape parameter is allowed and estimated, 
        loc=0 and scale=1 are fixed in the estimation 
 
    Parameters 
    ---------- 
    sample : ndarray 
        original sample data, in Monte Carlo only used to get nobs, 
    distr : distribution instance with fit_fr method 
    nrepl : int 
        number of Monte Carlo replications 
 
    Returns 
    ------- 
    res : array (nrepl,) 
        parameter estimates for all Monte Carlo replications 
 
    '''</span>
    <span class="s1">arg = distkwds.pop(</span><span class="s5">'arg'</span><span class="s1">)</span>
    <span class="s1">nobs = len(sample)</span>
    <span class="s1">res = np.zeros(nrepl)</span>
    <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">range(nrepl):</span>
        <span class="s1">x = distr.rvs(arg</span><span class="s2">, </span><span class="s1">size=nobs</span><span class="s2">, </span><span class="s1">**distkwds)</span>
        <span class="s1">res[ii] = distr.fit_fr(x</span><span class="s2">, </span><span class="s1">frozen=[np.nan</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">])</span>
    <span class="s2">return </span><span class="s1">res</span>


<span class="s2">def </span><span class="s1">printresults(sample</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">bres</span><span class="s2">, </span><span class="s1">kind=</span><span class="s5">'bootstrap'</span><span class="s1">):</span>
    <span class="s0">'''calculate and print(Bootstrap or Monte Carlo result 
 
    Parameters 
    ---------- 
    sample : ndarray 
        original sample data 
    arg : float   (for general case will be array) 
    bres : ndarray 
        parameter estimates from Bootstrap or Monte Carlo run 
    kind : {'bootstrap', 'montecarlo'} 
        output is printed for Mootstrap (default) or Monte Carlo 
 
    Returns 
    ------- 
    None, currently only printing 
 
    Notes 
    ----- 
    still a bit a mess because it is used for both Bootstrap and Monte Carlo 
 
    made correction: 
        reference point for bootstrap is estimated parameter 
 
    not clear: 
        I'm not doing any ddof adjustment in estimation of variance, do we 
        need ddof&gt;0 ? 
 
    todo: return results and string instead of printing 
 
    '''</span>
    <span class="s1">print(</span><span class="s5">'true parameter value'</span><span class="s1">)</span>
    <span class="s1">print(arg)</span>
    <span class="s1">print(</span><span class="s5">'MLE estimate of parameters using sample (nobs=%d)'</span><span class="s1">% (nobs))</span>
    <span class="s1">argest = distr.fit_fr(sample</span><span class="s2">, </span><span class="s1">frozen=[np.nan</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">])</span>
    <span class="s1">print(argest)</span>
    <span class="s2">if </span><span class="s1">kind == </span><span class="s5">'bootstrap'</span><span class="s1">:</span>
        <span class="s3">#bootstrap compares to estimate from sample</span>
        <span class="s1">argorig = arg</span>
        <span class="s1">arg = argest</span>

    <span class="s1">print(</span><span class="s5">'%s distribution of parameter estimate (nrepl=%d)'</span><span class="s1">% (kind</span><span class="s2">, </span><span class="s1">nrepl))</span>
    <span class="s1">print(</span><span class="s5">'mean = %f, bias=%f' </span><span class="s1">% (bres.mean(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">bres.mean(</span><span class="s4">0</span><span class="s1">)-arg))</span>
    <span class="s1">print(</span><span class="s5">'median'</span><span class="s2">, </span><span class="s1">np.median(bres</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">))</span>
    <span class="s1">print(</span><span class="s5">'var and std'</span><span class="s2">, </span><span class="s1">bres.var(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.sqrt(bres.var(</span><span class="s4">0</span><span class="s1">)))</span>
    <span class="s1">bmse = ((bres - arg)**</span><span class="s4">2</span><span class="s1">).mean(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">print(</span><span class="s5">'mse, rmse'</span><span class="s2">, </span><span class="s1">bmse</span><span class="s2">, </span><span class="s1">np.sqrt(bmse))</span>
    <span class="s1">bressorted = np.sort(bres)</span>
    <span class="s1">print(</span><span class="s5">'%s confidence interval (90%% coverage)' </span><span class="s1">% kind)</span>
    <span class="s1">print(bressorted[np.floor(nrepl*</span><span class="s4">0.05</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">bressorted[np.floor(nrepl*</span><span class="s4">0.95</span><span class="s1">)])</span>
    <span class="s1">print(</span><span class="s5">'%s confidence interval (90%% coverage) normal approximation' </span><span class="s1">% kind)</span>
    <span class="s1">print(stats.norm.ppf(</span><span class="s4">0.05</span><span class="s2">, </span><span class="s1">loc=bres.mean()</span><span class="s2">, </span><span class="s1">scale=bres.std())</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s1">print(stats.norm.isf(</span><span class="s4">0.05</span><span class="s2">, </span><span class="s1">loc=bres.mean()</span><span class="s2">, </span><span class="s1">scale=bres.std()))</span>
    <span class="s1">print(</span><span class="s5">'Kolmogorov-Smirnov test for normality of %s distribution' </span><span class="s1">% kind)</span>
    <span class="s1">print(</span><span class="s5">' - estimated parameters, p-values not really correct'</span><span class="s1">)</span>
    <span class="s1">print(stats.kstest(bres</span><span class="s2">, </span><span class="s5">'norm'</span><span class="s2">, </span><span class="s1">(bres.mean()</span><span class="s2">, </span><span class="s1">bres.std())))</span>


<span class="s2">if </span><span class="s1">__name__ == </span><span class="s5">'__main__'</span><span class="s1">:</span>

    <span class="s1">examplecases = [</span><span class="s5">'largenumber'</span><span class="s2">, </span><span class="s5">'bootstrap'</span><span class="s2">, </span><span class="s5">'montecarlo'</span><span class="s1">][:]</span>

    <span class="s2">if </span><span class="s5">'largenumber' </span><span class="s2">in </span><span class="s1">examplecases:</span>

        <span class="s1">print(</span><span class="s5">'</span><span class="s2">\n</span><span class="s5">Distribution: vonmises'</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">nobs </span><span class="s2">in </span><span class="s1">[</span><span class="s4">200</span><span class="s1">]:</span><span class="s3">#[20000, 1000, 100]:</span>
            <span class="s1">x = stats.vonmises.rvs(</span><span class="s4">1.23</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">size=nobs)</span>
            <span class="s1">print(</span><span class="s5">'</span><span class="s2">\n</span><span class="s5">nobs:'</span><span class="s2">, </span><span class="s1">nobs)</span>
            <span class="s1">print(</span><span class="s5">'true parameter'</span><span class="s1">)</span>
            <span class="s1">print(</span><span class="s5">'1.23, loc=0, scale=1'</span><span class="s1">)</span>
            <span class="s1">print(</span><span class="s5">'unconstrained'</span><span class="s1">)</span>
            <span class="s1">print(stats.vonmises.fit(x))</span>
            <span class="s1">print(stats.vonmises.fit_fr(x</span><span class="s2">, </span><span class="s1">frozen=[np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan]))</span>
            <span class="s1">print(</span><span class="s5">'with fixed loc and scale'</span><span class="s1">)</span>
            <span class="s1">print(stats.vonmises.fit_fr(x</span><span class="s2">, </span><span class="s1">frozen=[np.nan</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">]))</span>

        <span class="s1">print(</span><span class="s5">'</span><span class="s2">\n</span><span class="s5">Distribution: gamma'</span><span class="s1">)</span>
        <span class="s1">distr = stats.gamma</span>
        <span class="s1">arg</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = </span><span class="s4">2.5</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">20.</span>

        <span class="s2">for </span><span class="s1">nobs </span><span class="s2">in </span><span class="s1">[</span><span class="s4">200</span><span class="s1">]:</span><span class="s3">#[20000, 1000, 100]:</span>
            <span class="s1">x = distr.rvs(arg</span><span class="s2">, </span><span class="s1">loc=loc</span><span class="s2">, </span><span class="s1">scale=scale</span><span class="s2">, </span><span class="s1">size=nobs)</span>
            <span class="s1">print(</span><span class="s5">'</span><span class="s2">\n</span><span class="s5">nobs:'</span><span class="s2">, </span><span class="s1">nobs)</span>
            <span class="s1">print(</span><span class="s5">'true parameter'</span><span class="s1">)</span>
            <span class="s1">print(</span><span class="s5">'%f, loc=%f, scale=%f' </span><span class="s1">% (arg</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale))</span>
            <span class="s1">print(</span><span class="s5">'unconstrained'</span><span class="s1">)</span>
            <span class="s1">print(distr.fit(x))</span>
            <span class="s1">print(distr.fit_fr(x</span><span class="s2">, </span><span class="s1">frozen=[np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan]))</span>
            <span class="s1">print(</span><span class="s5">'with fixed loc and scale'</span><span class="s1">)</span>
            <span class="s1">print(distr.fit_fr(x</span><span class="s2">, </span><span class="s1">frozen=[np.nan</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">]))</span>
            <span class="s1">print(</span><span class="s5">'with fixed loc'</span><span class="s1">)</span>
            <span class="s1">print(distr.fit_fr(x</span><span class="s2">, </span><span class="s1">frozen=[np.nan</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">np.nan]))</span>


    <span class="s1">ex = [</span><span class="s5">'gamma'</span><span class="s2">, </span><span class="s5">'vonmises'</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s2">if </span><span class="s1">ex == </span><span class="s5">'gamma'</span><span class="s1">:</span>
        <span class="s1">distr = stats.gamma</span>
        <span class="s1">arg</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = </span><span class="s4">2.5</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">1</span>
    <span class="s2">elif </span><span class="s1">ex == </span><span class="s5">'vonmises'</span><span class="s1">:</span>
        <span class="s1">distr = stats.vonmises</span>
        <span class="s1">arg</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">1</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'wrong example'</span><span class="s1">)</span>

    <span class="s1">nobs = </span><span class="s4">100</span>
    <span class="s1">nrepl = </span><span class="s4">1000</span>

    <span class="s1">sample = distr.rvs(arg</span><span class="s2">, </span><span class="s1">loc=loc</span><span class="s2">, </span><span class="s1">scale=scale</span><span class="s2">, </span><span class="s1">size=nobs)</span>

    <span class="s1">print(</span><span class="s5">'</span><span class="s2">\n</span><span class="s5">Distribution:'</span><span class="s2">, </span><span class="s1">distr)</span>
    <span class="s2">if </span><span class="s5">'bootstrap' </span><span class="s2">in </span><span class="s1">examplecases:</span>
        <span class="s1">print(</span><span class="s5">'</span><span class="s2">\n</span><span class="s5">Bootstrap'</span><span class="s1">)</span>
        <span class="s1">bres = distfitbootstrap(sample</span><span class="s2">, </span><span class="s1">distr</span><span class="s2">, </span><span class="s1">nrepl=nrepl )</span>
        <span class="s1">printresults(sample</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">bres)</span>

    <span class="s2">if </span><span class="s5">'montecarlo' </span><span class="s2">in </span><span class="s1">examplecases:</span>
        <span class="s1">print(</span><span class="s5">'</span><span class="s2">\n</span><span class="s5">MonteCarlo'</span><span class="s1">)</span>
        <span class="s1">mcres = distfitmc(sample</span><span class="s2">, </span><span class="s1">distr</span><span class="s2">, </span><span class="s1">nrepl=nrepl</span><span class="s2">,</span>
                          <span class="s1">distkwds=dict(arg=arg</span><span class="s2">, </span><span class="s1">loc=loc</span><span class="s2">, </span><span class="s1">scale=scale))</span>
        <span class="s1">printresults(sample</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">mcres</span><span class="s2">, </span><span class="s1">kind=</span><span class="s5">'montecarlo'</span><span class="s1">)</span>
</pre>
</body>
</html>