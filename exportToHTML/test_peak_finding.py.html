<html>
<head>
<title>test_peak_finding.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_peak_finding.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">copy</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">assert_</span><span class="s0">,</span>
    <span class="s1">assert_equal</span><span class="s0">,</span>
    <span class="s1">assert_allclose</span><span class="s0">,</span>
    <span class="s1">assert_array_equal</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">from </span><span class="s1">pytest </span><span class="s0">import </span><span class="s1">raises</span><span class="s0">, </span><span class="s1">warns</span>

<span class="s0">from </span><span class="s1">scipy.signal._peak_finding </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">argrelmax</span><span class="s0">,</span>
    <span class="s1">argrelmin</span><span class="s0">,</span>
    <span class="s1">peak_prominences</span><span class="s0">,</span>
    <span class="s1">peak_widths</span><span class="s0">,</span>
    <span class="s1">_unpack_condition_args</span><span class="s0">,</span>
    <span class="s1">find_peaks</span><span class="s0">,</span>
    <span class="s1">find_peaks_cwt</span><span class="s0">,</span>
    <span class="s1">_identify_ridge_lines</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">scipy.signal.windows </span><span class="s0">import </span><span class="s1">gaussian</span>
<span class="s0">from </span><span class="s1">scipy.signal._peak_finding_utils </span><span class="s0">import </span><span class="s1">_local_maxima_1d</span><span class="s0">, </span><span class="s1">PeakPropertyWarning</span>


<span class="s0">def </span><span class="s1">_gen_gaussians(center_locs</span><span class="s0">, </span><span class="s1">sigmas</span><span class="s0">, </span><span class="s1">total_length):</span>
    <span class="s1">xdata = np.arange(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">total_length).astype(float)</span>
    <span class="s1">out_data = np.zeros(total_length</span><span class="s0">, </span><span class="s1">dtype=float)</span>
    <span class="s0">for </span><span class="s1">ind</span><span class="s0">, </span><span class="s1">sigma </span><span class="s0">in </span><span class="s1">enumerate(sigmas):</span>
        <span class="s1">tmp = (xdata - center_locs[ind]) / sigma</span>
        <span class="s1">out_data += np.exp(-(tmp**</span><span class="s2">2</span><span class="s1">))</span>
    <span class="s0">return </span><span class="s1">out_data</span>


<span class="s0">def </span><span class="s1">_gen_gaussians_even(sigmas</span><span class="s0">, </span><span class="s1">total_length):</span>
    <span class="s1">num_peaks = len(sigmas)</span>
    <span class="s1">delta = total_length / (num_peaks + </span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">center_locs = np.linspace(delta</span><span class="s0">, </span><span class="s1">total_length - delta</span><span class="s0">, </span><span class="s1">num=num_peaks).astype(int)</span>
    <span class="s1">out_data = _gen_gaussians(center_locs</span><span class="s0">, </span><span class="s1">sigmas</span><span class="s0">, </span><span class="s1">total_length)</span>
    <span class="s0">return </span><span class="s1">out_data</span><span class="s0">, </span><span class="s1">center_locs</span>


<span class="s0">def </span><span class="s1">_gen_ridge_line(start_locs</span><span class="s0">, </span><span class="s1">max_locs</span><span class="s0">, </span><span class="s1">length</span><span class="s0">, </span><span class="s1">distances</span><span class="s0">, </span><span class="s1">gaps):</span>
    <span class="s3">&quot;&quot;&quot; 
    Generate coordinates for a ridge line. 
 
    Will be a series of coordinates, starting a start_loc (length 2). 
    The maximum distance between any adjacent columns will be 
    `max_distance`, the max distance between adjacent rows 
    will be `map_gap'. 
 
    `max_locs` should be the size of the intended matrix. The 
    ending coordinates are guaranteed to be less than `max_locs`, 
    although they may not approach `max_locs` at all. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">keep_bounds(num</span><span class="s0">, </span><span class="s1">max_val):</span>
        <span class="s1">out = max(num</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">out = min(out</span><span class="s0">, </span><span class="s1">max_val)</span>
        <span class="s0">return </span><span class="s1">out</span>

    <span class="s1">gaps = copy.deepcopy(gaps)</span>
    <span class="s1">distances = copy.deepcopy(distances)</span>

    <span class="s1">locs = np.zeros([length</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=int)</span>
    <span class="s1">locs[</span><span class="s2">0</span><span class="s0">, </span><span class="s1">:] = start_locs</span>
    <span class="s1">total_length = max_locs[</span><span class="s2">0</span><span class="s1">] - start_locs[</span><span class="s2">0</span><span class="s1">] - sum(gaps)</span>
    <span class="s0">if </span><span class="s1">total_length &lt; length:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">'Cannot generate ridge line according to constraints'</span><span class="s1">)</span>
    <span class="s1">dist_int = length / len(distances) - </span><span class="s2">1</span>
    <span class="s1">gap_int = length / len(gaps) - </span><span class="s2">1</span>
    <span class="s0">for </span><span class="s1">ind </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">length):</span>
        <span class="s1">nextcol = locs[ind - </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span>
        <span class="s1">nextrow = locs[ind - </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">] + </span><span class="s2">1</span>
        <span class="s0">if </span><span class="s1">(ind % dist_int == </span><span class="s2">0</span><span class="s1">) </span><span class="s0">and </span><span class="s1">(len(distances) &gt; </span><span class="s2">0</span><span class="s1">):</span>
            <span class="s1">nextcol += ((-</span><span class="s2">1</span><span class="s1">)**ind)*distances.pop()</span>
        <span class="s0">if </span><span class="s1">(ind % gap_int == </span><span class="s2">0</span><span class="s1">) </span><span class="s0">and </span><span class="s1">(len(gaps) &gt; </span><span class="s2">0</span><span class="s1">):</span>
            <span class="s1">nextrow += gaps.pop()</span>
        <span class="s1">nextrow = keep_bounds(nextrow</span><span class="s0">, </span><span class="s1">max_locs[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">nextcol = keep_bounds(nextcol</span><span class="s0">, </span><span class="s1">max_locs[</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">locs[ind</span><span class="s0">, </span><span class="s1">:] = [nextrow</span><span class="s0">, </span><span class="s1">nextcol]</span>

    <span class="s0">return </span><span class="s1">[locs[:</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">locs[:</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]]</span>


<span class="s0">class </span><span class="s1">TestLocalMaxima1d:</span>

    <span class="s0">def </span><span class="s1">test_empty(self):</span>
        <span class="s3">&quot;&quot;&quot;Test with empty signal.&quot;&quot;&quot;</span>
        <span class="s1">x = np.array([]</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s0">for </span><span class="s1">array </span><span class="s0">in </span><span class="s1">_local_maxima_1d(x):</span>
            <span class="s1">assert_equal(array</span><span class="s0">, </span><span class="s1">np.array([]))</span>
            <span class="s1">assert_(array.base </span><span class="s0">is None</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_linear(self):</span>
        <span class="s3">&quot;&quot;&quot;Test with linear signal.&quot;&quot;&quot;</span>
        <span class="s1">x = np.linspace(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">100</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">array </span><span class="s0">in </span><span class="s1">_local_maxima_1d(x):</span>
            <span class="s1">assert_equal(array</span><span class="s0">, </span><span class="s1">np.array([]))</span>
            <span class="s1">assert_(array.base </span><span class="s0">is None</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_simple(self):</span>
        <span class="s3">&quot;&quot;&quot;Test with simple signal.&quot;&quot;&quot;</span>
        <span class="s1">x = np.linspace(-</span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">50</span><span class="s1">)</span>
        <span class="s1">x[</span><span class="s2">2</span><span class="s1">::</span><span class="s2">3</span><span class="s1">] += </span><span class="s2">1</span>
        <span class="s1">expected = np.arange(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">array </span><span class="s0">in </span><span class="s1">_local_maxima_1d(x):</span>
            <span class="s5"># For plateaus of size 1, the edges are identical with the</span>
            <span class="s5"># midpoints</span>
            <span class="s1">assert_equal(array</span><span class="s0">, </span><span class="s1">expected)</span>
            <span class="s1">assert_(array.base </span><span class="s0">is None</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_flat_maxima(self):</span>
        <span class="s3">&quot;&quot;&quot;Test if flat maxima are detected correctly.&quot;&quot;&quot;</span>
        <span class="s1">x = np.array([-</span><span class="s2">1.3</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">2.99</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s1">-</span><span class="s2">10</span><span class="s0">,</span>
                      <span class="s1">-</span><span class="s2">5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">10</span><span class="s1">])</span>
        <span class="s1">midpoints</span><span class="s0">, </span><span class="s1">left_edges</span><span class="s0">, </span><span class="s1">right_edges = _local_maxima_1d(x)</span>
        <span class="s1">assert_equal(midpoints</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">12</span><span class="s0">, </span><span class="s2">18</span><span class="s1">]))</span>
        <span class="s1">assert_equal(left_edges</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s2">16</span><span class="s1">]))</span>
        <span class="s1">assert_equal(right_edges</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">2</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">9</span><span class="s0">, </span><span class="s2">14</span><span class="s0">, </span><span class="s2">20</span><span class="s1">]))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'x'</span><span class="s0">, </span><span class="s1">[</span>
        <span class="s1">np.array([</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">np.array([</span><span class="s2">3.</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">np.array([</span><span class="s2">5.</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">6</span><span class="s1">])</span><span class="s0">,</span>
    <span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_signal_edges(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s3">&quot;&quot;&quot;Test if behavior on signal edges is correct.&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">array </span><span class="s0">in </span><span class="s1">_local_maxima_1d(x):</span>
            <span class="s1">assert_equal(array</span><span class="s0">, </span><span class="s1">np.array([]))</span>
            <span class="s1">assert_(array.base </span><span class="s0">is None</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_exceptions(self):</span>
        <span class="s3">&quot;&quot;&quot;Test input validation and raised exceptions.&quot;&quot;&quot;</span>
        <span class="s0">with </span><span class="s1">raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;wrong number of dimensions&quot;</span><span class="s1">):</span>
            <span class="s1">_local_maxima_1d(np.ones((</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)))</span>
        <span class="s0">with </span><span class="s1">raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;expected 'const float64_t'&quot;</span><span class="s1">):</span>
            <span class="s1">_local_maxima_1d(np.ones(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">dtype=int))</span>
        <span class="s0">with </span><span class="s1">raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;list&quot;</span><span class="s1">):</span>
            <span class="s1">_local_maxima_1d([</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">2.</span><span class="s1">])</span>
        <span class="s0">with </span><span class="s1">raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;'x' must not be None&quot;</span><span class="s1">):</span>
            <span class="s1">_local_maxima_1d(</span><span class="s0">None</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestRidgeLines:</span>

    <span class="s0">def </span><span class="s1">test_empty(self):</span>
        <span class="s1">test_matr = np.zeros([</span><span class="s2">20</span><span class="s0">, </span><span class="s2">100</span><span class="s1">])</span>
        <span class="s1">lines = _identify_ridge_lines(test_matr</span><span class="s0">, </span><span class="s1">np.full(</span><span class="s2">20</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_(len(lines) == </span><span class="s2">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_minimal(self):</span>
        <span class="s1">test_matr = np.zeros([</span><span class="s2">20</span><span class="s0">, </span><span class="s2">100</span><span class="s1">])</span>
        <span class="s1">test_matr[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">10</span><span class="s1">] = </span><span class="s2">1</span>
        <span class="s1">lines = _identify_ridge_lines(test_matr</span><span class="s0">, </span><span class="s1">np.full(</span><span class="s2">20</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_(len(lines) == </span><span class="s2">1</span><span class="s1">)</span>

        <span class="s1">test_matr = np.zeros([</span><span class="s2">20</span><span class="s0">, </span><span class="s2">100</span><span class="s1">])</span>
        <span class="s1">test_matr[</span><span class="s2">0</span><span class="s1">:</span><span class="s2">2</span><span class="s0">, </span><span class="s2">10</span><span class="s1">] = </span><span class="s2">1</span>
        <span class="s1">lines = _identify_ridge_lines(test_matr</span><span class="s0">, </span><span class="s1">np.full(</span><span class="s2">20</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_(len(lines) == </span><span class="s2">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_single_pass(self):</span>
        <span class="s1">distances = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span>
        <span class="s1">gaps = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span>
        <span class="s1">test_matr = np.zeros([</span><span class="s2">20</span><span class="s0">, </span><span class="s2">50</span><span class="s1">]) + </span><span class="s2">1e-12</span>
        <span class="s1">length = </span><span class="s2">12</span>
        <span class="s1">line = _gen_ridge_line([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">25</span><span class="s1">]</span><span class="s0">, </span><span class="s1">test_matr.shape</span><span class="s0">, </span><span class="s1">length</span><span class="s0">, </span><span class="s1">distances</span><span class="s0">, </span><span class="s1">gaps)</span>
        <span class="s1">test_matr[line[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">line[</span><span class="s2">1</span><span class="s1">]] = </span><span class="s2">1</span>
        <span class="s1">max_distances = np.full(</span><span class="s2">20</span><span class="s0">, </span><span class="s1">max(distances))</span>
        <span class="s1">identified_lines = _identify_ridge_lines(test_matr</span><span class="s0">, </span><span class="s1">max_distances</span><span class="s0">, </span><span class="s1">max(gaps) + </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(identified_lines</span><span class="s0">, </span><span class="s1">[line])</span>

    <span class="s0">def </span><span class="s1">test_single_bigdist(self):</span>
        <span class="s1">distances = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span>
        <span class="s1">gaps = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span>
        <span class="s1">test_matr = np.zeros([</span><span class="s2">20</span><span class="s0">, </span><span class="s2">50</span><span class="s1">])</span>
        <span class="s1">length = </span><span class="s2">12</span>
        <span class="s1">line = _gen_ridge_line([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">25</span><span class="s1">]</span><span class="s0">, </span><span class="s1">test_matr.shape</span><span class="s0">, </span><span class="s1">length</span><span class="s0">, </span><span class="s1">distances</span><span class="s0">, </span><span class="s1">gaps)</span>
        <span class="s1">test_matr[line[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">line[</span><span class="s2">1</span><span class="s1">]] = </span><span class="s2">1</span>
        <span class="s1">max_dist = </span><span class="s2">3</span>
        <span class="s1">max_distances = np.full(</span><span class="s2">20</span><span class="s0">, </span><span class="s1">max_dist)</span>
        <span class="s5">#This should get 2 lines, since the distance is too large</span>
        <span class="s1">identified_lines = _identify_ridge_lines(test_matr</span><span class="s0">, </span><span class="s1">max_distances</span><span class="s0">, </span><span class="s1">max(gaps) + </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_(len(identified_lines) == </span><span class="s2">2</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">iline </span><span class="s0">in </span><span class="s1">identified_lines:</span>
            <span class="s1">adists = np.diff(iline[</span><span class="s2">1</span><span class="s1">])</span>
            <span class="s1">np.testing.assert_array_less(np.abs(adists)</span><span class="s0">, </span><span class="s1">max_dist)</span>

            <span class="s1">agaps = np.diff(iline[</span><span class="s2">0</span><span class="s1">])</span>
            <span class="s1">np.testing.assert_array_less(np.abs(agaps)</span><span class="s0">, </span><span class="s1">max(gaps) + </span><span class="s2">0.1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_single_biggap(self):</span>
        <span class="s1">distances = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span>
        <span class="s1">max_gap = </span><span class="s2">3</span>
        <span class="s1">gaps = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span>
        <span class="s1">test_matr = np.zeros([</span><span class="s2">20</span><span class="s0">, </span><span class="s2">50</span><span class="s1">])</span>
        <span class="s1">length = </span><span class="s2">12</span>
        <span class="s1">line = _gen_ridge_line([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">25</span><span class="s1">]</span><span class="s0">, </span><span class="s1">test_matr.shape</span><span class="s0">, </span><span class="s1">length</span><span class="s0">, </span><span class="s1">distances</span><span class="s0">, </span><span class="s1">gaps)</span>
        <span class="s1">test_matr[line[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">line[</span><span class="s2">1</span><span class="s1">]] = </span><span class="s2">1</span>
        <span class="s1">max_dist = </span><span class="s2">6</span>
        <span class="s1">max_distances = np.full(</span><span class="s2">20</span><span class="s0">, </span><span class="s1">max_dist)</span>
        <span class="s5">#This should get 2 lines, since the gap is too large</span>
        <span class="s1">identified_lines = _identify_ridge_lines(test_matr</span><span class="s0">, </span><span class="s1">max_distances</span><span class="s0">, </span><span class="s1">max_gap)</span>
        <span class="s1">assert_(len(identified_lines) == </span><span class="s2">2</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">iline </span><span class="s0">in </span><span class="s1">identified_lines:</span>
            <span class="s1">adists = np.diff(iline[</span><span class="s2">1</span><span class="s1">])</span>
            <span class="s1">np.testing.assert_array_less(np.abs(adists)</span><span class="s0">, </span><span class="s1">max_dist)</span>

            <span class="s1">agaps = np.diff(iline[</span><span class="s2">0</span><span class="s1">])</span>
            <span class="s1">np.testing.assert_array_less(np.abs(agaps)</span><span class="s0">, </span><span class="s1">max(gaps) + </span><span class="s2">0.1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_single_biggaps(self):</span>
        <span class="s1">distances = [</span><span class="s2">0</span><span class="s1">]</span>
        <span class="s1">max_gap = </span><span class="s2">1</span>
        <span class="s1">gaps = [</span><span class="s2">3</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span>
        <span class="s1">test_matr = np.zeros([</span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s1">])</span>
        <span class="s1">length = </span><span class="s2">30</span>
        <span class="s1">line = _gen_ridge_line([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">25</span><span class="s1">]</span><span class="s0">, </span><span class="s1">test_matr.shape</span><span class="s0">, </span><span class="s1">length</span><span class="s0">, </span><span class="s1">distances</span><span class="s0">, </span><span class="s1">gaps)</span>
        <span class="s1">test_matr[line[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">line[</span><span class="s2">1</span><span class="s1">]] = </span><span class="s2">1</span>
        <span class="s1">max_dist = </span><span class="s2">1</span>
        <span class="s1">max_distances = np.full(</span><span class="s2">50</span><span class="s0">, </span><span class="s1">max_dist)</span>
        <span class="s5">#This should get 3 lines, since the gaps are too large</span>
        <span class="s1">identified_lines = _identify_ridge_lines(test_matr</span><span class="s0">, </span><span class="s1">max_distances</span><span class="s0">, </span><span class="s1">max_gap)</span>
        <span class="s1">assert_(len(identified_lines) == </span><span class="s2">3</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">iline </span><span class="s0">in </span><span class="s1">identified_lines:</span>
            <span class="s1">adists = np.diff(iline[</span><span class="s2">1</span><span class="s1">])</span>
            <span class="s1">np.testing.assert_array_less(np.abs(adists)</span><span class="s0">, </span><span class="s1">max_dist)</span>

            <span class="s1">agaps = np.diff(iline[</span><span class="s2">0</span><span class="s1">])</span>
            <span class="s1">np.testing.assert_array_less(np.abs(agaps)</span><span class="s0">, </span><span class="s1">max(gaps) + </span><span class="s2">0.1</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestArgrel:</span>

    <span class="s0">def </span><span class="s1">test_empty(self):</span>
        <span class="s5"># Regression test for gh-2832.</span>
        <span class="s5"># When there are no relative extrema, make sure that</span>
        <span class="s5"># the number of empty arrays returned matches the</span>
        <span class="s5"># dimension of the input.</span>

        <span class="s1">empty_array = np.array([]</span><span class="s0">, </span><span class="s1">dtype=int)</span>

        <span class="s1">z1 = np.zeros(</span><span class="s2">5</span><span class="s1">)</span>

        <span class="s1">i = argrelmin(z1)</span>
        <span class="s1">assert_equal(len(i)</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(i[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">empty_array)</span>

        <span class="s1">z2 = np.zeros((</span><span class="s2">3</span><span class="s0">,</span><span class="s2">5</span><span class="s1">))</span>

        <span class="s1">row</span><span class="s0">, </span><span class="s1">col = argrelmin(z2</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(row</span><span class="s0">, </span><span class="s1">empty_array)</span>
        <span class="s1">assert_array_equal(col</span><span class="s0">, </span><span class="s1">empty_array)</span>

        <span class="s1">row</span><span class="s0">, </span><span class="s1">col = argrelmin(z2</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(row</span><span class="s0">, </span><span class="s1">empty_array)</span>
        <span class="s1">assert_array_equal(col</span><span class="s0">, </span><span class="s1">empty_array)</span>

    <span class="s0">def </span><span class="s1">test_basic(self):</span>
        <span class="s5"># Note: the docstrings for the argrel{min,max,extrema} functions</span>
        <span class="s5"># do not give a guarantee of the order of the indices, so we'll</span>
        <span class="s5"># sort them before testing.</span>

        <span class="s1">x = np.array([[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]])</span>

        <span class="s1">row</span><span class="s0">, </span><span class="s1">col = argrelmax(x</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">order = np.argsort(row)</span>
        <span class="s1">assert_equal(row[order]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">assert_equal(col[order]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>

        <span class="s1">row</span><span class="s0">, </span><span class="s1">col = argrelmax(x</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">order = np.argsort(row)</span>
        <span class="s1">assert_equal(row[order]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">])</span>
        <span class="s1">assert_equal(col[order]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>

        <span class="s1">row</span><span class="s0">, </span><span class="s1">col = argrelmin(x</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">order = np.argsort(row)</span>
        <span class="s1">assert_equal(row[order]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">assert_equal(col[order]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>

        <span class="s1">row</span><span class="s0">, </span><span class="s1">col = argrelmin(x</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">order = np.argsort(row)</span>
        <span class="s1">assert_equal(row[order]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">assert_equal(col[order]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_highorder(self):</span>
        <span class="s1">order = </span><span class="s2">2</span>
        <span class="s1">sigmas = [</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">10.0</span><span class="s0">, </span><span class="s2">5.0</span><span class="s0">, </span><span class="s2">15.0</span><span class="s1">]</span>
        <span class="s1">test_data</span><span class="s0">, </span><span class="s1">act_locs = _gen_gaussians_even(sigmas</span><span class="s0">, </span><span class="s2">500</span><span class="s1">)</span>
        <span class="s1">test_data[act_locs + order] = test_data[act_locs]*</span><span class="s2">0.99999</span>
        <span class="s1">test_data[act_locs - order] = test_data[act_locs]*</span><span class="s2">0.99999</span>
        <span class="s1">rel_max_locs = argrelmax(test_data</span><span class="s0">, </span><span class="s1">order=order</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">'clip'</span><span class="s1">)[</span><span class="s2">0</span><span class="s1">]</span>

        <span class="s1">assert_(len(rel_max_locs) == len(act_locs))</span>
        <span class="s1">assert_((rel_max_locs == act_locs).all())</span>

    <span class="s0">def </span><span class="s1">test_2d_gaussians(self):</span>
        <span class="s1">sigmas = [</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">10.0</span><span class="s1">]</span>
        <span class="s1">test_data</span><span class="s0">, </span><span class="s1">act_locs = _gen_gaussians_even(sigmas</span><span class="s0">, </span><span class="s2">100</span><span class="s1">)</span>
        <span class="s1">rot_factor = </span><span class="s2">20</span>
        <span class="s1">rot_range = np.arange(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">len(test_data)) - rot_factor</span>
        <span class="s1">test_data_2 = np.vstack([test_data</span><span class="s0">, </span><span class="s1">test_data[rot_range]])</span>
        <span class="s1">rel_max_rows</span><span class="s0">, </span><span class="s1">rel_max_cols = argrelmax(test_data_2</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">order=</span><span class="s2">1</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">rw </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">test_data_2.shape[</span><span class="s2">0</span><span class="s1">]):</span>
            <span class="s1">inds = (rel_max_rows == rw)</span>

            <span class="s1">assert_(len(rel_max_cols[inds]) == len(act_locs))</span>
            <span class="s1">assert_((act_locs == (rel_max_cols[inds] - rot_factor*rw)).all())</span>


<span class="s0">class </span><span class="s1">TestPeakProminences:</span>

    <span class="s0">def </span><span class="s1">test_empty(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test if an empty array is returned if no peaks are provided. 
        &quot;&quot;&quot;</span>
        <span class="s1">out = peak_prominences([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s0">for </span><span class="s1">arr</span><span class="s0">, </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">zip(out</span><span class="s0">, </span><span class="s1">[np.float64</span><span class="s0">, </span><span class="s1">np.intp</span><span class="s0">, </span><span class="s1">np.intp]):</span>
            <span class="s1">assert_(arr.size == </span><span class="s2">0</span><span class="s1">)</span>
            <span class="s1">assert_(arr.dtype == dtype)</span>

        <span class="s1">out = peak_prominences([]</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s0">for </span><span class="s1">arr</span><span class="s0">, </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">zip(out</span><span class="s0">, </span><span class="s1">[np.float64</span><span class="s0">, </span><span class="s1">np.intp</span><span class="s0">, </span><span class="s1">np.intp]):</span>
            <span class="s1">assert_(arr.size == </span><span class="s2">0</span><span class="s1">)</span>
            <span class="s1">assert_(arr.dtype == dtype)</span>

    <span class="s0">def </span><span class="s1">test_basic(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test if height of prominences is correctly calculated in signal with 
        rising baseline (peak widths are 1 sample). 
        &quot;&quot;&quot;</span>
        <span class="s5"># Prepare basic signal</span>
        <span class="s1">x = np.array([-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1.2</span><span class="s0">, </span><span class="s2">1.2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">3.2</span><span class="s0">, </span><span class="s2">1.3</span><span class="s0">, </span><span class="s2">2.88</span><span class="s0">, </span><span class="s2">2.1</span><span class="s1">])</span>
        <span class="s1">peaks = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">6</span><span class="s1">])</span>
        <span class="s1">lbases = np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">5</span><span class="s1">])</span>
        <span class="s1">rbases = np.array([</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">7</span><span class="s1">])</span>
        <span class="s1">proms = x[peaks] - np.max([x[lbases]</span><span class="s0">, </span><span class="s1">x[rbases]]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">)</span>
        <span class="s5"># Test if calculation matches handcrafted result</span>
        <span class="s1">out = peak_prominences(x</span><span class="s0">, </span><span class="s1">peaks)</span>
        <span class="s1">assert_equal(out[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">proms)</span>
        <span class="s1">assert_equal(out[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">lbases)</span>
        <span class="s1">assert_equal(out[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rbases)</span>

    <span class="s0">def </span><span class="s1">test_edge_cases(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test edge cases. 
        &quot;&quot;&quot;</span>
        <span class="s5"># Peaks have same height, prominence and bases</span>
        <span class="s1">x = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span>
        <span class="s1">peaks = [</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span>
        <span class="s1">proms</span><span class="s0">, </span><span class="s1">lbases</span><span class="s0">, </span><span class="s1">rbases = peak_prominences(x</span><span class="s0">, </span><span class="s1">peaks)</span>
        <span class="s1">assert_equal(proms</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">assert_equal(lbases</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_equal(rbases</span><span class="s0">, </span><span class="s1">[</span><span class="s2">6</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">6</span><span class="s1">])</span>

        <span class="s5"># Peaks have same height &amp; prominence but different bases</span>
        <span class="s1">x = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span>
        <span class="s1">peaks = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">5</span><span class="s1">])</span>
        <span class="s1">proms</span><span class="s0">, </span><span class="s1">lbases</span><span class="s0">, </span><span class="s1">rbases = peak_prominences(x</span><span class="s0">, </span><span class="s1">peaks)</span>
        <span class="s1">assert_equal(proms</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(lbases</span><span class="s0">, </span><span class="s1">peaks - </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(rbases</span><span class="s0">, </span><span class="s1">peaks + </span><span class="s2">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_non_contiguous(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test with non-C-contiguous input arrays. 
        &quot;&quot;&quot;</span>
        <span class="s1">x = np.repeat([-</span><span class="s2">9</span><span class="s0">, </span><span class="s2">9</span><span class="s0">, </span><span class="s2">9</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">peaks = np.repeat([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">proms</span><span class="s0">, </span><span class="s1">lbases</span><span class="s0">, </span><span class="s1">rbases = peak_prominences(x[::</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">peaks[::</span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">assert_equal(proms</span><span class="s0">, </span><span class="s1">[</span><span class="s2">9</span><span class="s0">, </span><span class="s2">9</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">assert_equal(lbases</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">assert_equal(rbases</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">5</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_wlen(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test if wlen actually shrinks the evaluation range correctly. 
        &quot;&quot;&quot;</span>
        <span class="s1">x = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span>
        <span class="s1">peak = [</span><span class="s2">3</span><span class="s1">]</span>
        <span class="s5"># Test rounding behavior of wlen</span>
        <span class="s1">assert_equal(peak_prominences(x</span><span class="s0">, </span><span class="s1">peak)</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3.</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">6</span><span class="s1">])</span>
        <span class="s0">for </span><span class="s1">wlen</span><span class="s0">, </span><span class="s1">i </span><span class="s0">in </span><span class="s1">[(</span><span class="s2">8</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">7</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">6</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">3.2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1.1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)]:</span>
            <span class="s1">assert_equal(peak_prominences(x</span><span class="s0">, </span><span class="s1">peak</span><span class="s0">, </span><span class="s1">wlen)</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3. </span><span class="s1">- i</span><span class="s0">, </span><span class="s2">0 </span><span class="s1">+ i</span><span class="s0">, </span><span class="s2">6 </span><span class="s1">- i])</span>

    <span class="s0">def </span><span class="s1">test_exceptions(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Verify that exceptions and warnings are raised. 
        &quot;&quot;&quot;</span>
        <span class="s5"># x with dimension &gt; 1</span>
        <span class="s0">with </span><span class="s1">raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'1-D array'</span><span class="s1">):</span>
            <span class="s1">peak_prominences([[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
        <span class="s5"># peaks with dimension &gt; 1</span>
        <span class="s0">with </span><span class="s1">raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'1-D array'</span><span class="s1">):</span>
            <span class="s1">peak_prominences([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]])</span>
        <span class="s5"># x with dimension &lt; 1</span>
        <span class="s0">with </span><span class="s1">raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'1-D array'</span><span class="s1">):</span>
            <span class="s1">peak_prominences(</span><span class="s2">3</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">,</span><span class="s1">])</span>

        <span class="s5"># empty x with supplied</span>
        <span class="s0">with </span><span class="s1">raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'not a valid index'</span><span class="s1">):</span>
            <span class="s1">peak_prominences([]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s5"># invalid indices with non-empty x</span>
        <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">[-</span><span class="s2">100</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">1000</span><span class="s1">]:</span>
            <span class="s0">with </span><span class="s1">raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'not a valid index'</span><span class="s1">):</span>
                <span class="s1">peak_prominences([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[p])</span>

        <span class="s5"># peaks is not cast-able to np.intp</span>
        <span class="s0">with </span><span class="s1">raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'cannot safely cast'</span><span class="s1">):</span>
            <span class="s1">peak_prominences([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.1</span><span class="s0">, </span><span class="s2">2.3</span><span class="s1">])</span>

        <span class="s5"># wlen &lt; 3</span>
        <span class="s0">with </span><span class="s1">raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'wlen'</span><span class="s1">):</span>
            <span class="s1">peak_prominences(np.arange(</span><span class="s2">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">wlen=</span><span class="s2">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_warnings(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Verify that appropriate warnings are raised. 
        &quot;&quot;&quot;</span>
        <span class="s1">msg = </span><span class="s4">&quot;some peaks have a prominence of 0&quot;</span>
        <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]:</span>
            <span class="s0">with </span><span class="s1">warns(PeakPropertyWarning</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">peak_prominences([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[p</span><span class="s0">,</span><span class="s1">])</span>
        <span class="s0">with </span><span class="s1">warns(PeakPropertyWarning</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">peak_prominences([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">wlen=</span><span class="s2">2</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestPeakWidths:</span>

    <span class="s0">def </span><span class="s1">test_empty(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test if an empty array is returned if no peaks are provided. 
        &quot;&quot;&quot;</span>
        <span class="s1">widths = peak_widths([]</span><span class="s0">, </span><span class="s1">[])[</span><span class="s2">0</span><span class="s1">]</span>
        <span class="s1">assert_(isinstance(widths</span><span class="s0">, </span><span class="s1">np.ndarray))</span>
        <span class="s1">assert_equal(widths.size</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">widths = peak_widths([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[])[</span><span class="s2">0</span><span class="s1">]</span>
        <span class="s1">assert_(isinstance(widths</span><span class="s0">, </span><span class="s1">np.ndarray))</span>
        <span class="s1">assert_equal(widths.size</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">out = peak_widths([]</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s0">for </span><span class="s1">arr </span><span class="s0">in </span><span class="s1">out:</span>
            <span class="s1">assert_(isinstance(arr</span><span class="s0">, </span><span class="s1">np.ndarray))</span>
            <span class="s1">assert_equal(arr.size</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.filterwarnings(</span><span class="s4">&quot;ignore:some peaks have a width of 0&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_basic(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test a simple use case with easy to verify results at different relative 
        heights. 
        &quot;&quot;&quot;</span>
        <span class="s1">x = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">prominence = </span><span class="s2">2</span>
        <span class="s0">for </span><span class="s1">rel_height</span><span class="s0">, </span><span class="s1">width_true</span><span class="s0">, </span><span class="s1">lip_true</span><span class="s0">, </span><span class="s1">rip_true </span><span class="s0">in </span><span class="s1">[</span>
            <span class="s1">(</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s2">3.</span><span class="s0">, </span><span class="s2">3.</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># raises warning</span>
            <span class="s1">(</span><span class="s2">0.25</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s2">2.5</span><span class="s0">, </span><span class="s2">3.5</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">2.</span><span class="s0">, </span><span class="s2">2.</span><span class="s0">, </span><span class="s2">4.</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">0.75</span><span class="s0">, </span><span class="s2">3.</span><span class="s0">, </span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">4.5</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">4.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s2">5.</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">2.</span><span class="s0">, </span><span class="s2">5.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s2">6.</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">3.</span><span class="s0">, </span><span class="s2">5.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s2">6.</span><span class="s1">)</span>
        <span class="s1">]:</span>
            <span class="s1">width_calc</span><span class="s0">, </span><span class="s1">height</span><span class="s0">, </span><span class="s1">lip_calc</span><span class="s0">, </span><span class="s1">rip_calc = peak_widths(</span>
                <span class="s1">x</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rel_height)</span>
            <span class="s1">assert_allclose(width_calc</span><span class="s0">, </span><span class="s1">width_true)</span>
            <span class="s1">assert_allclose(height</span><span class="s0">, </span><span class="s2">2 </span><span class="s1">- rel_height * prominence)</span>
            <span class="s1">assert_allclose(lip_calc</span><span class="s0">, </span><span class="s1">lip_true)</span>
            <span class="s1">assert_allclose(rip_calc</span><span class="s0">, </span><span class="s1">rip_true)</span>

    <span class="s0">def </span><span class="s1">test_non_contiguous(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test with non-C-contiguous input arrays. 
        &quot;&quot;&quot;</span>
        <span class="s1">x = np.repeat([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">100</span><span class="s0">, </span><span class="s2">50</span><span class="s1">]</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span>
        <span class="s1">peaks = np.repeat([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span>
        <span class="s1">result = peak_widths(x[::</span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">peaks[::</span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">assert_equal(result</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.75</span><span class="s0">, </span><span class="s2">75</span><span class="s0">, </span><span class="s2">0.75</span><span class="s0">, </span><span class="s2">1.5</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_exceptions(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Verify that argument validation works as intended. 
        &quot;&quot;&quot;</span>
        <span class="s0">with </span><span class="s1">raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'1-D array'</span><span class="s1">):</span>
            <span class="s5"># x with dimension &gt; 1</span>
            <span class="s1">peak_widths(np.zeros((</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">))</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s2">3</span><span class="s1">))</span>
        <span class="s0">with </span><span class="s1">raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'1-D array'</span><span class="s1">):</span>
            <span class="s5"># x with dimension &lt; 1</span>
            <span class="s1">peak_widths(</span><span class="s2">3</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s0">with </span><span class="s1">raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'1-D array'</span><span class="s1">):</span>
            <span class="s5"># peaks with dimension &gt; 1</span>
            <span class="s1">peak_widths(np.arange(</span><span class="s2">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.ones((</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=np.intp))</span>
        <span class="s0">with </span><span class="s1">raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'1-D array'</span><span class="s1">):</span>
            <span class="s5"># peaks with dimension &lt; 1</span>
            <span class="s1">peak_widths(np.arange(</span><span class="s2">10</span><span class="s1">)</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'not a valid index'</span><span class="s1">):</span>
            <span class="s5"># peak pos exceeds x.size</span>
            <span class="s1">peak_widths(np.arange(</span><span class="s2">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s2">8</span><span class="s0">, </span><span class="s2">11</span><span class="s1">])</span>
        <span class="s0">with </span><span class="s1">raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'not a valid index'</span><span class="s1">):</span>
            <span class="s5"># empty x with peaks supplied</span>
            <span class="s1">peak_widths([]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
        <span class="s0">with </span><span class="s1">raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'cannot safely cast'</span><span class="s1">):</span>
            <span class="s5"># peak cannot be safely casted to intp</span>
            <span class="s1">peak_widths(np.arange(</span><span class="s2">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.1</span><span class="s0">, </span><span class="s2">2.3</span><span class="s1">])</span>
        <span class="s0">with </span><span class="s1">raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'rel_height'</span><span class="s1">):</span>
            <span class="s5"># rel_height is &lt; 0</span>
            <span class="s1">peak_widths([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rel_height=-</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'None'</span><span class="s1">):</span>
            <span class="s5"># prominence data contains None</span>
            <span class="s1">peak_widths([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">prominence_data=(</span><span class="s0">None, None, None</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_warnings(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Verify that appropriate warnings are raised. 
        &quot;&quot;&quot;</span>
        <span class="s1">msg = </span><span class="s4">&quot;some peaks have a width of 0&quot;</span>
        <span class="s0">with </span><span class="s1">warns(PeakPropertyWarning</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s5"># Case: rel_height is 0</span>
            <span class="s1">peak_widths([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rel_height=</span><span class="s2">0</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">warns(PeakPropertyWarning</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s5"># Case: prominence is 0 and bases are identical</span>
            <span class="s1">peak_widths(</span>
                <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">prominence_data=(np.array([</span><span class="s2">0.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.float64)</span><span class="s0">,</span>
                                 <span class="s1">np.array([</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.intp)</span><span class="s0">,</span>
                                 <span class="s1">np.array([</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.intp))</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_mismatching_prominence_data(self):</span>
        <span class="s3">&quot;&quot;&quot;Test with mismatching peak and / or prominence data.&quot;&quot;&quot;</span>
        <span class="s1">x = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span>
        <span class="s1">peak = [</span><span class="s2">1</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">(prominences</span><span class="s0">, </span><span class="s1">left_bases</span><span class="s0">, </span><span class="s1">right_bases) </span><span class="s0">in </span><span class="s1">enumerate([</span>
            <span class="s1">((</span><span class="s2">1.</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s2">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">,</span><span class="s1">))</span><span class="s0">,  </span><span class="s5"># left base not in x</span>
            <span class="s1">((</span><span class="s2">1.</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">3</span><span class="s0">,</span><span class="s1">))</span><span class="s0">,  </span><span class="s5"># right base not in x</span>
            <span class="s1">((</span><span class="s2">1.</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">,</span><span class="s1">))</span><span class="s0">,  </span><span class="s5"># swapped bases same as peak</span>
            <span class="s1">((</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">1.</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">))</span><span class="s0">,  </span><span class="s5"># array shapes don't match peaks</span>
            <span class="s1">((</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">1.</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">,</span><span class="s1">))</span><span class="s0">,  </span><span class="s5"># arrays with different shapes</span>
            <span class="s1">((</span><span class="s2">1.</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">,</span><span class="s1">))</span><span class="s0">,  </span><span class="s5"># arrays with different shapes</span>
            <span class="s1">((</span><span class="s2">1.</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">))  </span><span class="s5"># arrays with different shapes</span>
        <span class="s1">]):</span>
            <span class="s5"># Make sure input is matches output of signal.peak_prominences</span>
            <span class="s1">prominence_data = (np.array(prominences</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span><span class="s0">,</span>
                               <span class="s1">np.array(left_bases</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span><span class="s0">,</span>
                               <span class="s1">np.array(right_bases</span><span class="s0">, </span><span class="s1">dtype=np.intp))</span>
            <span class="s5"># Test for correct exception</span>
            <span class="s0">if </span><span class="s1">i &lt; </span><span class="s2">3</span><span class="s1">:</span>
                <span class="s1">match = </span><span class="s4">&quot;prominence data is invalid for peak&quot;</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">match = </span><span class="s4">&quot;arrays in `prominence_data` must have the same shape&quot;</span>
            <span class="s0">with </span><span class="s1">raises(ValueError</span><span class="s0">, </span><span class="s1">match=match):</span>
                <span class="s1">peak_widths(x</span><span class="s0">, </span><span class="s1">peak</span><span class="s0">, </span><span class="s1">prominence_data=prominence_data)</span>

    <span class="s1">@pytest.mark.filterwarnings(</span><span class="s4">&quot;ignore:some peaks have a width of 0&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_intersection_rules(self):</span>
        <span class="s3">&quot;&quot;&quot;Test if x == eval_height counts as an intersection.&quot;&quot;&quot;</span>
        <span class="s5"># Flatt peak with two possible intersection points if evaluated at 1</span>
        <span class="s1">x = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span>
        <span class="s5"># relative height is 0 -&gt; width is 0 as well, raises warning</span>
        <span class="s1">assert_allclose(peak_widths(x</span><span class="s0">, </span><span class="s1">peaks=[</span><span class="s2">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rel_height=</span><span class="s2">0</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">[(</span><span class="s2">0.</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">3.</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">5.</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">5.</span><span class="s0">,</span><span class="s1">)])</span>
        <span class="s5"># width_height == x counts as intersection -&gt; nearest 1 is chosen</span>
        <span class="s1">assert_allclose(peak_widths(x</span><span class="s0">, </span><span class="s1">peaks=[</span><span class="s2">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rel_height=</span><span class="s2">2</span><span class="s1">/</span><span class="s2">3</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">[(</span><span class="s2">4.</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1.</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">3.</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">7.</span><span class="s0">,</span><span class="s1">)])</span>


<span class="s0">def </span><span class="s1">test_unpack_condition_args():</span>
    <span class="s3">&quot;&quot;&quot; 
    Verify parsing of condition arguments for `scipy.signal.find_peaks` function. 
    &quot;&quot;&quot;</span>
    <span class="s1">x = np.arange(</span><span class="s2">10</span><span class="s1">)</span>
    <span class="s1">amin_true = x</span>
    <span class="s1">amax_true = amin_true + </span><span class="s2">10</span>
    <span class="s1">peaks = amin_true[</span><span class="s2">1</span><span class="s1">::</span><span class="s2">2</span><span class="s1">]</span>

    <span class="s5"># Test unpacking with None or interval</span>
    <span class="s1">assert_((</span><span class="s0">None, None</span><span class="s1">) == _unpack_condition_args((</span><span class="s0">None, None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">peaks))</span>
    <span class="s1">assert_((</span><span class="s2">1</span><span class="s0">, None</span><span class="s1">) == _unpack_condition_args(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">peaks))</span>
    <span class="s1">assert_((</span><span class="s2">1</span><span class="s0">, None</span><span class="s1">) == _unpack_condition_args((</span><span class="s2">1</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">peaks))</span>
    <span class="s1">assert_((</span><span class="s0">None, </span><span class="s2">2</span><span class="s1">) == _unpack_condition_args((</span><span class="s0">None, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">peaks))</span>
    <span class="s1">assert_((</span><span class="s2">3.</span><span class="s0">, </span><span class="s2">4.5</span><span class="s1">) == _unpack_condition_args((</span><span class="s2">3.</span><span class="s0">, </span><span class="s2">4.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">peaks))</span>

    <span class="s5"># Test if borders are correctly reduced with `peaks`</span>
    <span class="s1">amin_calc</span><span class="s0">, </span><span class="s1">amax_calc = _unpack_condition_args((amin_true</span><span class="s0">, </span><span class="s1">amax_true)</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">peaks)</span>
    <span class="s1">assert_equal(amin_calc</span><span class="s0">, </span><span class="s1">amin_true[peaks])</span>
    <span class="s1">assert_equal(amax_calc</span><span class="s0">, </span><span class="s1">amax_true[peaks])</span>

    <span class="s5"># Test raises if array borders don't match x</span>
    <span class="s0">with </span><span class="s1">raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;array size of lower&quot;</span><span class="s1">):</span>
        <span class="s1">_unpack_condition_args(amin_true</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s2">11</span><span class="s1">)</span><span class="s0">, </span><span class="s1">peaks)</span>
    <span class="s0">with </span><span class="s1">raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;array size of upper&quot;</span><span class="s1">):</span>
        <span class="s1">_unpack_condition_args((</span><span class="s0">None, </span><span class="s1">amin_true)</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s2">11</span><span class="s1">)</span><span class="s0">, </span><span class="s1">peaks)</span>


<span class="s0">class </span><span class="s1">TestFindPeaks:</span>

    <span class="s5"># Keys of optionally returned properties</span>
    <span class="s1">property_keys = {</span><span class="s4">'peak_heights'</span><span class="s0">, </span><span class="s4">'left_thresholds'</span><span class="s0">, </span><span class="s4">'right_thresholds'</span><span class="s0">,</span>
                     <span class="s4">'prominences'</span><span class="s0">, </span><span class="s4">'left_bases'</span><span class="s0">, </span><span class="s4">'right_bases'</span><span class="s0">, </span><span class="s4">'widths'</span><span class="s0">,</span>
                     <span class="s4">'width_heights'</span><span class="s0">, </span><span class="s4">'left_ips'</span><span class="s0">, </span><span class="s4">'right_ips'</span><span class="s1">}</span>

    <span class="s0">def </span><span class="s1">test_constant(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test behavior for signal without local maxima. 
        &quot;&quot;&quot;</span>
        <span class="s1">open_interval = (</span><span class="s0">None, None</span><span class="s1">)</span>
        <span class="s1">peaks</span><span class="s0">, </span><span class="s1">props = find_peaks(np.ones(</span><span class="s2">10</span><span class="s1">)</span><span class="s0">,</span>
                                  <span class="s1">height=open_interval</span><span class="s0">, </span><span class="s1">threshold=open_interval</span><span class="s0">,</span>
                                  <span class="s1">prominence=open_interval</span><span class="s0">, </span><span class="s1">width=open_interval)</span>
        <span class="s1">assert_(peaks.size == </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">self.property_keys:</span>
            <span class="s1">assert_(props[key].size == </span><span class="s2">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_plateau_size(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test plateau size condition for peaks. 
        &quot;&quot;&quot;</span>
        <span class="s5"># Prepare signal with peaks with peak_height == plateau_size</span>
        <span class="s1">plateau_sizes = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">20</span><span class="s0">, </span><span class="s2">111</span><span class="s1">])</span>
        <span class="s1">x = np.zeros(plateau_sizes.size * </span><span class="s2">2 </span><span class="s1">+ </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">x[</span><span class="s2">1</span><span class="s1">::</span><span class="s2">2</span><span class="s1">] = plateau_sizes</span>
        <span class="s1">repeats = np.ones(x.size</span><span class="s0">, </span><span class="s1">dtype=int)</span>
        <span class="s1">repeats[</span><span class="s2">1</span><span class="s1">::</span><span class="s2">2</span><span class="s1">] = x[</span><span class="s2">1</span><span class="s1">::</span><span class="s2">2</span><span class="s1">]</span>
        <span class="s1">x = np.repeat(x</span><span class="s0">, </span><span class="s1">repeats)</span>

        <span class="s5"># Test full output</span>
        <span class="s1">peaks</span><span class="s0">, </span><span class="s1">props = find_peaks(x</span><span class="s0">, </span><span class="s1">plateau_size=(</span><span class="s0">None, None</span><span class="s1">))</span>
        <span class="s1">assert_equal(peaks</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s2">18</span><span class="s0">, </span><span class="s2">33</span><span class="s0">, </span><span class="s2">100</span><span class="s1">])</span>
        <span class="s1">assert_equal(props[</span><span class="s4">&quot;plateau_sizes&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">plateau_sizes)</span>
        <span class="s1">assert_equal(props[</span><span class="s4">&quot;left_edges&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">peaks - (plateau_sizes - </span><span class="s2">1</span><span class="s1">) // </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">assert_equal(props[</span><span class="s4">&quot;right_edges&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">peaks + plateau_sizes // </span><span class="s2">2</span><span class="s1">)</span>

        <span class="s5"># Test conditions</span>
        <span class="s1">assert_equal(find_peaks(x</span><span class="s0">, </span><span class="s1">plateau_size=</span><span class="s2">4</span><span class="s1">)[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">11</span><span class="s0">, </span><span class="s2">18</span><span class="s0">, </span><span class="s2">33</span><span class="s0">, </span><span class="s2">100</span><span class="s1">])</span>
        <span class="s1">assert_equal(find_peaks(x</span><span class="s0">, </span><span class="s1">plateau_size=(</span><span class="s0">None, </span><span class="s2">3.5</span><span class="s1">))[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">7</span><span class="s1">])</span>
        <span class="s1">assert_equal(find_peaks(x</span><span class="s0">, </span><span class="s1">plateau_size=(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">50</span><span class="s1">))[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">18</span><span class="s0">, </span><span class="s2">33</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_height_condition(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test height condition for peaks. 
        &quot;&quot;&quot;</span>
        <span class="s1">x = (</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">1</span><span class="s1">/</span><span class="s2">3</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s2">2.5</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">4.</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">peaks</span><span class="s0">, </span><span class="s1">props = find_peaks(x</span><span class="s0">, </span><span class="s1">height=(</span><span class="s0">None, None</span><span class="s1">))</span>
        <span class="s1">assert_equal(peaks</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]))</span>
        <span class="s1">assert_equal(props[</span><span class="s4">'peak_heights'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">1</span><span class="s1">/</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2.5</span><span class="s0">, </span><span class="s2">4.</span><span class="s1">]))</span>
        <span class="s1">assert_equal(find_peaks(x</span><span class="s0">, </span><span class="s1">height=</span><span class="s2">0.5</span><span class="s1">)[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">3</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]))</span>
        <span class="s1">assert_equal(find_peaks(x</span><span class="s0">, </span><span class="s1">height=(</span><span class="s0">None, </span><span class="s2">3</span><span class="s1">))[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]))</span>
        <span class="s1">assert_equal(find_peaks(x</span><span class="s0">, </span><span class="s1">height=(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">))[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">3</span><span class="s1">]))</span>

    <span class="s0">def </span><span class="s1">test_threshold_condition(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test threshold condition for peaks. 
        &quot;&quot;&quot;</span>
        <span class="s1">x = (</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">peaks</span><span class="s0">, </span><span class="s1">props = find_peaks(x</span><span class="s0">, </span><span class="s1">threshold=(</span><span class="s0">None, None</span><span class="s1">))</span>
        <span class="s1">assert_equal(peaks</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]))</span>
        <span class="s1">assert_equal(props[</span><span class="s4">'left_thresholds'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]))</span>
        <span class="s1">assert_equal(props[</span><span class="s4">'right_thresholds'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]))</span>
        <span class="s1">assert_equal(find_peaks(x</span><span class="s0">, </span><span class="s1">threshold=</span><span class="s2">2</span><span class="s1">)[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">3</span><span class="s1">]))</span>
        <span class="s1">assert_equal(find_peaks(x</span><span class="s0">, </span><span class="s1">threshold=</span><span class="s2">3.5</span><span class="s1">)[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.array([]))</span>
        <span class="s1">assert_equal(find_peaks(x</span><span class="s0">, </span><span class="s1">threshold=(</span><span class="s0">None, </span><span class="s2">5</span><span class="s1">))[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]))</span>
        <span class="s1">assert_equal(find_peaks(x</span><span class="s0">, </span><span class="s1">threshold=(</span><span class="s0">None, </span><span class="s2">4</span><span class="s1">))[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">1</span><span class="s1">]))</span>
        <span class="s1">assert_equal(find_peaks(x</span><span class="s0">, </span><span class="s1">threshold=(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s1">))[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.array([]))</span>

    <span class="s0">def </span><span class="s1">test_distance_condition(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test distance condition for peaks. 
        &quot;&quot;&quot;</span>
        <span class="s5"># Peaks of different height with constant distance 3</span>
        <span class="s1">peaks_all = np.arange(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">21</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span>
        <span class="s1">x = np.zeros(</span><span class="s2">21</span><span class="s1">)</span>
        <span class="s1">x[peaks_all] += np.linspace(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">peaks_all.size)</span>

        <span class="s5"># Test if peaks with &quot;minimal&quot; distance are still selected (distance = 3)</span>
        <span class="s1">assert_equal(find_peaks(x</span><span class="s0">, </span><span class="s1">distance=</span><span class="s2">3</span><span class="s1">)[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">peaks_all)</span>

        <span class="s5"># Select every second peak (distance &gt; 3)</span>
        <span class="s1">peaks_subset = find_peaks(x</span><span class="s0">, </span><span class="s1">distance=</span><span class="s2">3.0001</span><span class="s1">)[</span><span class="s2">0</span><span class="s1">]</span>
        <span class="s5"># Test if peaks_subset is subset of peaks_all</span>
        <span class="s1">assert_(</span>
            <span class="s1">np.setdiff1d(peaks_subset</span><span class="s0">, </span><span class="s1">peaks_all</span><span class="s0">, </span><span class="s1">assume_unique=</span><span class="s0">True</span><span class="s1">).size == </span><span class="s2">0</span>
        <span class="s1">)</span>
        <span class="s5"># Test if every second peak was removed</span>
        <span class="s1">assert_equal(np.diff(peaks_subset)</span><span class="s0">, </span><span class="s2">6</span><span class="s1">)</span>

        <span class="s5"># Test priority of peak removal</span>
        <span class="s1">x = [-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3</span><span class="s1">]</span>
        <span class="s1">peaks_subset = find_peaks(x</span><span class="s0">, </span><span class="s1">distance=</span><span class="s2">10</span><span class="s1">)[</span><span class="s2">0</span><span class="s1">]  </span><span class="s5"># use distance &gt; x size</span>
        <span class="s1">assert_(peaks_subset.size == </span><span class="s2">1 </span><span class="s0">and </span><span class="s1">peaks_subset[</span><span class="s2">0</span><span class="s1">] == </span><span class="s2">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_prominence_condition(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test prominence condition for peaks. 
        &quot;&quot;&quot;</span>
        <span class="s1">x = np.linspace(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">100</span><span class="s1">)</span>
        <span class="s1">peaks_true = np.arange(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">99</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">offset = np.linspace(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s1">peaks_true.size)</span>
        <span class="s1">x[peaks_true] += offset</span>
        <span class="s1">prominences = x[peaks_true] - x[peaks_true + </span><span class="s2">1</span><span class="s1">]</span>
        <span class="s1">interval = (</span><span class="s2">3</span><span class="s0">, </span><span class="s2">9</span><span class="s1">)</span>
        <span class="s1">keep = np.nonzero(</span>
            <span class="s1">(interval[</span><span class="s2">0</span><span class="s1">] &lt;= prominences) &amp; (prominences &lt;= interval[</span><span class="s2">1</span><span class="s1">]))</span>

        <span class="s1">peaks_calc</span><span class="s0">, </span><span class="s1">properties = find_peaks(x</span><span class="s0">, </span><span class="s1">prominence=interval)</span>
        <span class="s1">assert_equal(peaks_calc</span><span class="s0">, </span><span class="s1">peaks_true[keep])</span>
        <span class="s1">assert_equal(properties[</span><span class="s4">'prominences'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">prominences[keep])</span>
        <span class="s1">assert_equal(properties[</span><span class="s4">'left_bases'</span><span class="s1">]</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(properties[</span><span class="s4">'right_bases'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">peaks_true[keep] + </span><span class="s2">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_width_condition(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test width condition for peaks. 
        &quot;&quot;&quot;</span>
        <span class="s1">x = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">peaks</span><span class="s0">, </span><span class="s1">props = find_peaks(x</span><span class="s0">, </span><span class="s1">width=(</span><span class="s0">None, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">rel_height=</span><span class="s2">0.75</span><span class="s1">)</span>
        <span class="s1">assert_equal(peaks.size</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(peaks</span><span class="s0">, </span><span class="s2">7</span><span class="s1">)</span>
        <span class="s1">assert_allclose(props[</span><span class="s4">'widths'</span><span class="s1">]</span><span class="s0">, </span><span class="s2">1.35</span><span class="s1">)</span>
        <span class="s1">assert_allclose(props[</span><span class="s4">'width_heights'</span><span class="s1">]</span><span class="s0">, </span><span class="s2">1.</span><span class="s1">)</span>
        <span class="s1">assert_allclose(props[</span><span class="s4">'left_ips'</span><span class="s1">]</span><span class="s0">, </span><span class="s2">6.4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(props[</span><span class="s4">'right_ips'</span><span class="s1">]</span><span class="s0">, </span><span class="s2">7.75</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_properties(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test returned properties. 
        &quot;&quot;&quot;</span>
        <span class="s1">open_interval = (</span><span class="s0">None, None</span><span class="s1">)</span>
        <span class="s1">x = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">9</span><span class="s1">]</span>
        <span class="s1">peaks</span><span class="s0">, </span><span class="s1">props = find_peaks(x</span><span class="s0">,</span>
                                  <span class="s1">height=open_interval</span><span class="s0">, </span><span class="s1">threshold=open_interval</span><span class="s0">,</span>
                                  <span class="s1">prominence=open_interval</span><span class="s0">, </span><span class="s1">width=open_interval)</span>
        <span class="s1">assert_(len(props) == len(self.property_keys))</span>
        <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">self.property_keys:</span>
            <span class="s1">assert_(peaks.size == props[key].size)</span>

    <span class="s0">def </span><span class="s1">test_raises(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test exceptions raised by function. 
        &quot;&quot;&quot;</span>
        <span class="s0">with </span><span class="s1">raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;1-D array&quot;</span><span class="s1">):</span>
            <span class="s1">find_peaks(np.array(</span><span class="s2">1</span><span class="s1">))</span>
        <span class="s0">with </span><span class="s1">raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;1-D array&quot;</span><span class="s1">):</span>
            <span class="s1">find_peaks(np.ones((</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)))</span>
        <span class="s0">with </span><span class="s1">raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;distance&quot;</span><span class="s1">):</span>
            <span class="s1">find_peaks(np.arange(</span><span class="s2">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">distance=-</span><span class="s2">1</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.filterwarnings(</span><span class="s4">&quot;ignore:some peaks have a prominence of 0&quot;</span><span class="s0">,</span>
                                <span class="s4">&quot;ignore:some peaks have a width of 0&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_wlen_smaller_plateau(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test behavior of prominence and width calculation if the given window 
        length is smaller than a peak's plateau size. 
 
        Regression test for gh-9110. 
        &quot;&quot;&quot;</span>
        <span class="s1">peaks</span><span class="s0">, </span><span class="s1">props = find_peaks([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">prominence=(</span><span class="s0">None, None</span><span class="s1">)</span><span class="s0">,</span>
                                  <span class="s1">width=(</span><span class="s0">None, None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">wlen=</span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">assert_equal(peaks</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">assert_equal(props[</span><span class="s4">&quot;prominences&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(props[</span><span class="s4">&quot;widths&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(props[</span><span class="s4">&quot;width_heights&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">(</span><span class="s4">&quot;left_bases&quot;</span><span class="s0">, </span><span class="s4">&quot;right_bases&quot;</span><span class="s0">, </span><span class="s4">&quot;left_ips&quot;</span><span class="s0">, </span><span class="s4">&quot;right_ips&quot;</span><span class="s1">):</span>
            <span class="s1">assert_equal(props[key]</span><span class="s0">, </span><span class="s1">peaks)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;kwargs&quot;</span><span class="s0">, </span><span class="s1">[</span>
        <span class="s1">{}</span><span class="s0">,</span>
        <span class="s1">{</span><span class="s4">&quot;distance&quot;</span><span class="s1">: </span><span class="s2">3.0</span><span class="s1">}</span><span class="s0">,</span>
        <span class="s1">{</span><span class="s4">&quot;prominence&quot;</span><span class="s1">: (</span><span class="s0">None, None</span><span class="s1">)}</span><span class="s0">,</span>
        <span class="s1">{</span><span class="s4">&quot;width&quot;</span><span class="s1">: (</span><span class="s0">None, </span><span class="s2">2</span><span class="s1">)}</span><span class="s0">,</span>

    <span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_readonly_array(self</span><span class="s0">, </span><span class="s1">kwargs):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test readonly arrays are accepted. 
        &quot;&quot;&quot;</span>
        <span class="s1">x = np.linspace(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">15</span><span class="s1">)</span>
        <span class="s1">x_readonly = x.copy()</span>
        <span class="s1">x_readonly.flags.writeable = </span><span class="s0">False</span>

        <span class="s1">peaks</span><span class="s0">, </span><span class="s1">_ = find_peaks(x)</span>
        <span class="s1">peaks_readonly</span><span class="s0">, </span><span class="s1">_ = find_peaks(x_readonly</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s1">assert_allclose(peaks</span><span class="s0">, </span><span class="s1">peaks_readonly)</span>


<span class="s0">class </span><span class="s1">TestFindPeaksCwt:</span>

    <span class="s0">def </span><span class="s1">test_find_peaks_exact(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Generate a series of gaussians and attempt to find the peak locations. 
        &quot;&quot;&quot;</span>
        <span class="s1">sigmas = [</span><span class="s2">5.0</span><span class="s0">, </span><span class="s2">3.0</span><span class="s0">, </span><span class="s2">10.0</span><span class="s0">, </span><span class="s2">20.0</span><span class="s0">, </span><span class="s2">10.0</span><span class="s0">, </span><span class="s2">50.0</span><span class="s1">]</span>
        <span class="s1">num_points = </span><span class="s2">500</span>
        <span class="s1">test_data</span><span class="s0">, </span><span class="s1">act_locs = _gen_gaussians_even(sigmas</span><span class="s0">, </span><span class="s1">num_points)</span>
        <span class="s1">widths = np.arange(</span><span class="s2">0.1</span><span class="s0">, </span><span class="s1">max(sigmas))</span>
        <span class="s1">found_locs = find_peaks_cwt(test_data</span><span class="s0">, </span><span class="s1">widths</span><span class="s0">, </span><span class="s1">gap_thresh=</span><span class="s2">2</span><span class="s0">, </span><span class="s1">min_snr=</span><span class="s2">0</span><span class="s0">,</span>
                                         <span class="s1">min_length=</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">np.testing.assert_array_equal(found_locs</span><span class="s0">, </span><span class="s1">act_locs</span><span class="s0">,</span>
                        <span class="s4">&quot;Found maximum locations did not equal those expected&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_find_peaks_withnoise(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Verify that peak locations are (approximately) found 
        for a series of gaussians with added noise. 
        &quot;&quot;&quot;</span>
        <span class="s1">sigmas = [</span><span class="s2">5.0</span><span class="s0">, </span><span class="s2">3.0</span><span class="s0">, </span><span class="s2">10.0</span><span class="s0">, </span><span class="s2">20.0</span><span class="s0">, </span><span class="s2">10.0</span><span class="s0">, </span><span class="s2">50.0</span><span class="s1">]</span>
        <span class="s1">num_points = </span><span class="s2">500</span>
        <span class="s1">test_data</span><span class="s0">, </span><span class="s1">act_locs = _gen_gaussians_even(sigmas</span><span class="s0">, </span><span class="s1">num_points)</span>
        <span class="s1">widths = np.arange(</span><span class="s2">0.1</span><span class="s0">, </span><span class="s1">max(sigmas))</span>
        <span class="s1">noise_amp = </span><span class="s2">0.07</span>
        <span class="s1">np.random.seed(</span><span class="s2">18181911</span><span class="s1">)</span>
        <span class="s1">test_data += (np.random.rand(num_points) - </span><span class="s2">0.5</span><span class="s1">)*(</span><span class="s2">2</span><span class="s1">*noise_amp)</span>
        <span class="s1">found_locs = find_peaks_cwt(test_data</span><span class="s0">, </span><span class="s1">widths</span><span class="s0">, </span><span class="s1">min_length=</span><span class="s2">15</span><span class="s0">,</span>
                                         <span class="s1">gap_thresh=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">min_snr=noise_amp / </span><span class="s2">5</span><span class="s1">)</span>

        <span class="s1">np.testing.assert_equal(len(found_locs)</span><span class="s0">, </span><span class="s1">len(act_locs)</span><span class="s0">, </span><span class="s4">'Different number' </span><span class="s1">+</span>
                                <span class="s4">'of peaks found than expected'</span><span class="s1">)</span>
        <span class="s1">diffs = np.abs(found_locs - act_locs)</span>
        <span class="s1">max_diffs = np.array(sigmas) / </span><span class="s2">5</span>
        <span class="s1">np.testing.assert_array_less(diffs</span><span class="s0">, </span><span class="s1">max_diffs</span><span class="s0">, </span><span class="s4">'Maximum location differed' </span><span class="s1">+</span>
                                     <span class="s4">'by more than %s' </span><span class="s1">% (max_diffs))</span>

    <span class="s0">def </span><span class="s1">test_find_peaks_nopeak(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Verify that no peak is found in 
        data that's just noise. 
        &quot;&quot;&quot;</span>
        <span class="s1">noise_amp = </span><span class="s2">1.0</span>
        <span class="s1">num_points = </span><span class="s2">100</span>
        <span class="s1">np.random.seed(</span><span class="s2">181819141</span><span class="s1">)</span>
        <span class="s1">test_data = (np.random.rand(num_points) - </span><span class="s2">0.5</span><span class="s1">)*(</span><span class="s2">2</span><span class="s1">*noise_amp)</span>
        <span class="s1">widths = np.arange(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">50</span><span class="s1">)</span>
        <span class="s1">found_locs = find_peaks_cwt(test_data</span><span class="s0">, </span><span class="s1">widths</span><span class="s0">, </span><span class="s1">min_snr=</span><span class="s2">5</span><span class="s0">, </span><span class="s1">noise_perc=</span><span class="s2">30</span><span class="s1">)</span>
        <span class="s1">np.testing.assert_equal(len(found_locs)</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_find_peaks_with_non_default_wavelets(self):</span>
        <span class="s1">x = gaussian(</span><span class="s2">200</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">widths = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">])</span>
        <span class="s1">a = find_peaks_cwt(x</span><span class="s0">, </span><span class="s1">widths</span><span class="s0">, </span><span class="s1">wavelet=gaussian)</span>

        <span class="s1">np.testing.assert_equal(np.array([</span><span class="s2">100</span><span class="s1">])</span><span class="s0">, </span><span class="s1">a)</span>

    <span class="s0">def </span><span class="s1">test_find_peaks_window_size(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Verify that window_size is passed correctly to private function and 
        affects the result. 
        &quot;&quot;&quot;</span>
        <span class="s1">sigmas = [</span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s1">]</span>
        <span class="s1">num_points = </span><span class="s2">1000</span>
        <span class="s1">test_data</span><span class="s0">, </span><span class="s1">act_locs = _gen_gaussians_even(sigmas</span><span class="s0">, </span><span class="s1">num_points)</span>
        <span class="s1">widths = np.arange(</span><span class="s2">0.1</span><span class="s0">, </span><span class="s1">max(sigmas)</span><span class="s0">, </span><span class="s2">0.2</span><span class="s1">)</span>
        <span class="s1">noise_amp = </span><span class="s2">0.05</span>
        <span class="s1">np.random.seed(</span><span class="s2">18181911</span><span class="s1">)</span>
        <span class="s1">test_data += (np.random.rand(num_points) - </span><span class="s2">0.5</span><span class="s1">)*(</span><span class="s2">2</span><span class="s1">*noise_amp)</span>

        <span class="s5"># Possibly contrived negative region to throw off peak finding</span>
        <span class="s5"># when window_size is too large</span>
        <span class="s1">test_data[</span><span class="s2">250</span><span class="s1">:</span><span class="s2">320</span><span class="s1">] -= </span><span class="s2">1</span>

        <span class="s1">found_locs = find_peaks_cwt(test_data</span><span class="s0">, </span><span class="s1">widths</span><span class="s0">, </span><span class="s1">gap_thresh=</span><span class="s2">2</span><span class="s0">, </span><span class="s1">min_snr=</span><span class="s2">3</span><span class="s0">,</span>
                                    <span class="s1">min_length=</span><span class="s0">None, </span><span class="s1">window_size=</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(AssertionError):</span>
            <span class="s0">assert </span><span class="s1">found_locs.size == act_locs.size</span>

        <span class="s1">found_locs = find_peaks_cwt(test_data</span><span class="s0">, </span><span class="s1">widths</span><span class="s0">, </span><span class="s1">gap_thresh=</span><span class="s2">2</span><span class="s0">, </span><span class="s1">min_snr=</span><span class="s2">3</span><span class="s0">,</span>
                                    <span class="s1">min_length=</span><span class="s0">None, </span><span class="s1">window_size=</span><span class="s2">20</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">found_locs.size == act_locs.size</span>

    <span class="s0">def </span><span class="s1">test_find_peaks_with_one_width(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Verify that the `width` argument 
        in `find_peaks_cwt` can be a float 
        &quot;&quot;&quot;</span>
        <span class="s1">xs = np.arange(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">np.pi</span><span class="s0">, </span><span class="s2">0.05</span><span class="s1">)</span>
        <span class="s1">test_data = np.sin(xs)</span>
        <span class="s1">widths = </span><span class="s2">1</span>
        <span class="s1">found_locs = find_peaks_cwt(test_data</span><span class="s0">, </span><span class="s1">widths)</span>

        <span class="s1">np.testing.assert_equal(found_locs</span><span class="s0">, </span><span class="s2">32</span><span class="s1">)</span>
</pre>
</body>
</html>