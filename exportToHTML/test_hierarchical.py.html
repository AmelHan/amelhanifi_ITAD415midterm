<html>
<head>
<title>test_hierarchical.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_hierarchical.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Several basic tests for hierarchical clustering procedures 
 
&quot;&quot;&quot;</span>
<span class="s2"># Authors: Vincent Michel, 2010, Gael Varoquaux 2012,</span>
<span class="s2">#          Matteo Visconti di Oleggio Castello 2014</span>
<span class="s2"># License: BSD 3 clause</span>
<span class="s3">import </span><span class="s1">itertools</span>
<span class="s3">import </span><span class="s1">shutil</span>
<span class="s3">from </span><span class="s1">functools </span><span class="s3">import </span><span class="s1">partial</span>
<span class="s3">from </span><span class="s1">tempfile </span><span class="s3">import </span><span class="s1">mkdtemp</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">import </span><span class="s1">pytest</span>
<span class="s3">from </span><span class="s1">scipy </span><span class="s3">import </span><span class="s1">sparse</span>
<span class="s3">from </span><span class="s1">scipy.cluster </span><span class="s3">import </span><span class="s1">hierarchy</span>
<span class="s3">from </span><span class="s1">scipy.sparse.csgraph </span><span class="s3">import </span><span class="s1">connected_components</span>

<span class="s3">from </span><span class="s1">sklearn.cluster </span><span class="s3">import </span><span class="s1">AgglomerativeClustering</span><span class="s3">, </span><span class="s1">FeatureAgglomeration</span><span class="s3">, </span><span class="s1">ward_tree</span>
<span class="s3">from </span><span class="s1">sklearn.cluster._agglomerative </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">_TREE_BUILDERS</span><span class="s3">,</span>
    <span class="s1">_fix_connectivity</span><span class="s3">,</span>
    <span class="s1">_hc_cut</span><span class="s3">,</span>
    <span class="s1">linkage_tree</span><span class="s3">,</span>
<span class="s1">)</span>
<span class="s3">from </span><span class="s1">sklearn.cluster._hierarchical_fast </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">average_merge</span><span class="s3">,</span>
    <span class="s1">max_merge</span><span class="s3">,</span>
    <span class="s1">mst_linkage_core</span><span class="s3">,</span>
<span class="s1">)</span>
<span class="s3">from </span><span class="s1">sklearn.datasets </span><span class="s3">import </span><span class="s1">make_circles</span><span class="s3">, </span><span class="s1">make_moons</span>
<span class="s3">from </span><span class="s1">sklearn.feature_extraction.image </span><span class="s3">import </span><span class="s1">grid_to_graph</span>
<span class="s3">from </span><span class="s1">sklearn.metrics </span><span class="s3">import </span><span class="s1">DistanceMetric</span>
<span class="s3">from </span><span class="s1">sklearn.metrics.cluster </span><span class="s3">import </span><span class="s1">adjusted_rand_score</span><span class="s3">, </span><span class="s1">normalized_mutual_info_score</span>
<span class="s3">from </span><span class="s1">sklearn.metrics.pairwise </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">PAIRED_DISTANCES</span><span class="s3">,</span>
    <span class="s1">cosine_distances</span><span class="s3">,</span>
    <span class="s1">manhattan_distances</span><span class="s3">,</span>
    <span class="s1">pairwise_distances</span><span class="s3">,</span>
<span class="s1">)</span>
<span class="s3">from </span><span class="s1">sklearn.metrics.tests.test_dist_metrics </span><span class="s3">import </span><span class="s1">METRICS_DEFAULT_PARAMS</span>
<span class="s3">from </span><span class="s1">sklearn.neighbors </span><span class="s3">import </span><span class="s1">kneighbors_graph</span>
<span class="s3">from </span><span class="s1">sklearn.utils._fast_dict </span><span class="s3">import </span><span class="s1">IntFloatDict</span>
<span class="s3">from </span><span class="s1">sklearn.utils._testing </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">assert_almost_equal</span><span class="s3">,</span>
    <span class="s1">assert_array_almost_equal</span><span class="s3">,</span>
    <span class="s1">assert_array_equal</span><span class="s3">,</span>
    <span class="s1">create_memmap_backed_data</span><span class="s3">,</span>
    <span class="s1">ignore_warnings</span><span class="s3">,</span>
<span class="s1">)</span>


<span class="s3">def </span><span class="s1">test_linkage_misc():</span>
    <span class="s2"># Misc tests on linkage</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s4">42</span><span class="s1">)</span>
    <span class="s1">X = rng.normal(size=(</span><span class="s4">5</span><span class="s3">, </span><span class="s4">5</span><span class="s1">))</span>

    <span class="s3">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">linkage_tree(X</span><span class="s3">, </span><span class="s1">linkage=</span><span class="s5">&quot;foo&quot;</span><span class="s1">)</span>

    <span class="s3">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">linkage_tree(X</span><span class="s3">, </span><span class="s1">connectivity=np.ones((</span><span class="s4">4</span><span class="s3">, </span><span class="s4">4</span><span class="s1">)))</span>

    <span class="s2"># Smoke test FeatureAgglomeration</span>
    <span class="s1">FeatureAgglomeration().fit(X)</span>

    <span class="s2"># test hierarchical clustering on a precomputed distances matrix</span>
    <span class="s1">dis = cosine_distances(X)</span>

    <span class="s1">res = linkage_tree(dis</span><span class="s3">, </span><span class="s1">affinity=</span><span class="s5">&quot;precomputed&quot;</span><span class="s1">)</span>
    <span class="s1">assert_array_equal(res[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">linkage_tree(X</span><span class="s3">, </span><span class="s1">affinity=</span><span class="s5">&quot;cosine&quot;</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">])</span>

    <span class="s2"># test hierarchical clustering on a precomputed distances matrix</span>
    <span class="s1">res = linkage_tree(X</span><span class="s3">, </span><span class="s1">affinity=manhattan_distances)</span>
    <span class="s1">assert_array_equal(res[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">linkage_tree(X</span><span class="s3">, </span><span class="s1">affinity=</span><span class="s5">&quot;manhattan&quot;</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">])</span>


<span class="s3">def </span><span class="s1">test_structured_linkage_tree():</span>
    <span class="s2"># Check that we obtain the correct solution for structured linkage trees.</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">mask = np.ones([</span><span class="s4">10</span><span class="s3">, </span><span class="s4">10</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=bool)</span>
    <span class="s2"># Avoiding a mask with only 'True' entries</span>
    <span class="s1">mask[</span><span class="s4">4</span><span class="s1">:</span><span class="s4">7</span><span class="s3">, </span><span class="s4">4</span><span class="s1">:</span><span class="s4">7</span><span class="s1">] = </span><span class="s4">0</span>
    <span class="s1">X = rng.randn(</span><span class="s4">50</span><span class="s3">, </span><span class="s4">100</span><span class="s1">)</span>
    <span class="s1">connectivity = grid_to_graph(*mask.shape)</span>
    <span class="s3">for </span><span class="s1">tree_builder </span><span class="s3">in </span><span class="s1">_TREE_BUILDERS.values():</span>
        <span class="s1">children</span><span class="s3">, </span><span class="s1">n_components</span><span class="s3">, </span><span class="s1">n_leaves</span><span class="s3">, </span><span class="s1">parent = tree_builder(</span>
            <span class="s1">X.T</span><span class="s3">, </span><span class="s1">connectivity=connectivity</span>
        <span class="s1">)</span>
        <span class="s1">n_nodes = </span><span class="s4">2 </span><span class="s1">* X.shape[</span><span class="s4">1</span><span class="s1">] - </span><span class="s4">1</span>
        <span class="s3">assert </span><span class="s1">len(children) + n_leaves == n_nodes</span>
        <span class="s2"># Check that ward_tree raises a ValueError with a connectivity matrix</span>
        <span class="s2"># of the wrong shape</span>
        <span class="s3">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">tree_builder(X.T</span><span class="s3">, </span><span class="s1">connectivity=np.ones((</span><span class="s4">4</span><span class="s3">, </span><span class="s4">4</span><span class="s1">)))</span>
        <span class="s2"># Check that fitting with no samples raises an error</span>
        <span class="s3">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">tree_builder(X.T[:</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">connectivity=connectivity)</span>


<span class="s3">def </span><span class="s1">test_unstructured_linkage_tree():</span>
    <span class="s2"># Check that we obtain the correct solution for unstructured linkage trees.</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">X = rng.randn(</span><span class="s4">50</span><span class="s3">, </span><span class="s4">100</span><span class="s1">)</span>
    <span class="s3">for </span><span class="s1">this_X </span><span class="s3">in </span><span class="s1">(X</span><span class="s3">, </span><span class="s1">X[</span><span class="s4">0</span><span class="s1">]):</span>
        <span class="s2"># With specified a number of clusters just for the sake of</span>
        <span class="s2"># raising a warning and testing the warning code</span>
        <span class="s3">with </span><span class="s1">ignore_warnings():</span>
            <span class="s3">with </span><span class="s1">pytest.warns(UserWarning):</span>
                <span class="s1">children</span><span class="s3">, </span><span class="s1">n_nodes</span><span class="s3">, </span><span class="s1">n_leaves</span><span class="s3">, </span><span class="s1">parent = ward_tree(this_X.T</span><span class="s3">, </span><span class="s1">n_clusters=</span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">n_nodes = </span><span class="s4">2 </span><span class="s1">* X.shape[</span><span class="s4">1</span><span class="s1">] - </span><span class="s4">1</span>
        <span class="s3">assert </span><span class="s1">len(children) + n_leaves == n_nodes</span>

    <span class="s3">for </span><span class="s1">tree_builder </span><span class="s3">in </span><span class="s1">_TREE_BUILDERS.values():</span>
        <span class="s3">for </span><span class="s1">this_X </span><span class="s3">in </span><span class="s1">(X</span><span class="s3">, </span><span class="s1">X[</span><span class="s4">0</span><span class="s1">]):</span>
            <span class="s3">with </span><span class="s1">ignore_warnings():</span>
                <span class="s3">with </span><span class="s1">pytest.warns(UserWarning):</span>
                    <span class="s1">children</span><span class="s3">, </span><span class="s1">n_nodes</span><span class="s3">, </span><span class="s1">n_leaves</span><span class="s3">, </span><span class="s1">parent = tree_builder(</span>
                        <span class="s1">this_X.T</span><span class="s3">, </span><span class="s1">n_clusters=</span><span class="s4">10</span>
                    <span class="s1">)</span>
            <span class="s1">n_nodes = </span><span class="s4">2 </span><span class="s1">* X.shape[</span><span class="s4">1</span><span class="s1">] - </span><span class="s4">1</span>
            <span class="s3">assert </span><span class="s1">len(children) + n_leaves == n_nodes</span>


<span class="s3">def </span><span class="s1">test_height_linkage_tree():</span>
    <span class="s2"># Check that the height of the results of linkage tree is sorted.</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">mask = np.ones([</span><span class="s4">10</span><span class="s3">, </span><span class="s4">10</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=bool)</span>
    <span class="s1">X = rng.randn(</span><span class="s4">50</span><span class="s3">, </span><span class="s4">100</span><span class="s1">)</span>
    <span class="s1">connectivity = grid_to_graph(*mask.shape)</span>
    <span class="s3">for </span><span class="s1">linkage_func </span><span class="s3">in </span><span class="s1">_TREE_BUILDERS.values():</span>
        <span class="s1">children</span><span class="s3">, </span><span class="s1">n_nodes</span><span class="s3">, </span><span class="s1">n_leaves</span><span class="s3">, </span><span class="s1">parent = linkage_func(</span>
            <span class="s1">X.T</span><span class="s3">, </span><span class="s1">connectivity=connectivity</span>
        <span class="s1">)</span>
        <span class="s1">n_nodes = </span><span class="s4">2 </span><span class="s1">* X.shape[</span><span class="s4">1</span><span class="s1">] - </span><span class="s4">1</span>
        <span class="s3">assert </span><span class="s1">len(children) + n_leaves == n_nodes</span>


<span class="s3">def </span><span class="s1">test_zero_cosine_linkage_tree():</span>
    <span class="s2"># Check that zero vectors in X produce an error when</span>
    <span class="s2"># 'cosine' affinity is used</span>
    <span class="s1">X = np.array([[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">]])</span>
    <span class="s1">msg = </span><span class="s5">&quot;Cosine affinity cannot be used when X contains zero vectors&quot;</span>
    <span class="s3">with </span><span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">match=msg):</span>
        <span class="s1">linkage_tree(X</span><span class="s3">, </span><span class="s1">affinity=</span><span class="s5">&quot;cosine&quot;</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;n_clusters, distance_threshold&quot;</span><span class="s3">, </span><span class="s1">[(</span><span class="s3">None, </span><span class="s4">0.5</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">10</span><span class="s3">, None</span><span class="s1">)])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;compute_distances&quot;</span><span class="s3">, </span><span class="s1">[</span><span class="s3">True, False</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;linkage&quot;</span><span class="s3">, </span><span class="s1">[</span><span class="s5">&quot;ward&quot;</span><span class="s3">, </span><span class="s5">&quot;complete&quot;</span><span class="s3">, </span><span class="s5">&quot;average&quot;</span><span class="s3">, </span><span class="s5">&quot;single&quot;</span><span class="s1">])</span>
<span class="s3">def </span><span class="s1">test_agglomerative_clustering_distances(</span>
    <span class="s1">n_clusters</span><span class="s3">, </span><span class="s1">compute_distances</span><span class="s3">, </span><span class="s1">distance_threshold</span><span class="s3">, </span><span class="s1">linkage</span>
<span class="s1">):</span>
    <span class="s2"># Check that when `compute_distances` is True or `distance_threshold` is</span>
    <span class="s2"># given, the fitted model has an attribute `distances_`.</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">mask = np.ones([</span><span class="s4">10</span><span class="s3">, </span><span class="s4">10</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=bool)</span>
    <span class="s1">n_samples = </span><span class="s4">100</span>
    <span class="s1">X = rng.randn(n_samples</span><span class="s3">, </span><span class="s4">50</span><span class="s1">)</span>
    <span class="s1">connectivity = grid_to_graph(*mask.shape)</span>

    <span class="s1">clustering = AgglomerativeClustering(</span>
        <span class="s1">n_clusters=n_clusters</span><span class="s3">,</span>
        <span class="s1">connectivity=connectivity</span><span class="s3">,</span>
        <span class="s1">linkage=linkage</span><span class="s3">,</span>
        <span class="s1">distance_threshold=distance_threshold</span><span class="s3">,</span>
        <span class="s1">compute_distances=compute_distances</span><span class="s3">,</span>
    <span class="s1">)</span>
    <span class="s1">clustering.fit(X)</span>
    <span class="s3">if </span><span class="s1">compute_distances </span><span class="s3">or </span><span class="s1">(distance_threshold </span><span class="s3">is not None</span><span class="s1">):</span>
        <span class="s3">assert </span><span class="s1">hasattr(clustering</span><span class="s3">, </span><span class="s5">&quot;distances_&quot;</span><span class="s1">)</span>
        <span class="s1">n_children = clustering.children_.shape[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">n_nodes = n_children + </span><span class="s4">1</span>
        <span class="s3">assert </span><span class="s1">clustering.distances_.shape == (n_nodes - </span><span class="s4">1</span><span class="s3">,</span><span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">assert not </span><span class="s1">hasattr(clustering</span><span class="s3">, </span><span class="s5">&quot;distances_&quot;</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">test_agglomerative_clustering(global_random_seed):</span>
    <span class="s2"># Check that we obtain the correct number of clusters with</span>
    <span class="s2"># agglomerative clustering.</span>
    <span class="s1">rng = np.random.RandomState(global_random_seed)</span>
    <span class="s1">mask = np.ones([</span><span class="s4">10</span><span class="s3">, </span><span class="s4">10</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=bool)</span>
    <span class="s1">n_samples = </span><span class="s4">100</span>
    <span class="s1">X = rng.randn(n_samples</span><span class="s3">, </span><span class="s4">50</span><span class="s1">)</span>
    <span class="s1">connectivity = grid_to_graph(*mask.shape)</span>
    <span class="s3">for </span><span class="s1">linkage </span><span class="s3">in </span><span class="s1">(</span><span class="s5">&quot;ward&quot;</span><span class="s3">, </span><span class="s5">&quot;complete&quot;</span><span class="s3">, </span><span class="s5">&quot;average&quot;</span><span class="s3">, </span><span class="s5">&quot;single&quot;</span><span class="s1">):</span>
        <span class="s1">clustering = AgglomerativeClustering(</span>
            <span class="s1">n_clusters=</span><span class="s4">10</span><span class="s3">, </span><span class="s1">connectivity=connectivity</span><span class="s3">, </span><span class="s1">linkage=linkage</span>
        <span class="s1">)</span>
        <span class="s1">clustering.fit(X)</span>
        <span class="s2"># test caching</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">tempdir = mkdtemp()</span>
            <span class="s1">clustering = AgglomerativeClustering(</span>
                <span class="s1">n_clusters=</span><span class="s4">10</span><span class="s3">,</span>
                <span class="s1">connectivity=connectivity</span><span class="s3">,</span>
                <span class="s1">memory=tempdir</span><span class="s3">,</span>
                <span class="s1">linkage=linkage</span><span class="s3">,</span>
            <span class="s1">)</span>
            <span class="s1">clustering.fit(X)</span>
            <span class="s1">labels = clustering.labels_</span>
            <span class="s3">assert </span><span class="s1">np.size(np.unique(labels)) == </span><span class="s4">10</span>
        <span class="s3">finally</span><span class="s1">:</span>
            <span class="s1">shutil.rmtree(tempdir)</span>
        <span class="s2"># Turn caching off now</span>
        <span class="s1">clustering = AgglomerativeClustering(</span>
            <span class="s1">n_clusters=</span><span class="s4">10</span><span class="s3">, </span><span class="s1">connectivity=connectivity</span><span class="s3">, </span><span class="s1">linkage=linkage</span>
        <span class="s1">)</span>
        <span class="s2"># Check that we obtain the same solution with early-stopping of the</span>
        <span class="s2"># tree building</span>
        <span class="s1">clustering.compute_full_tree = </span><span class="s3">False</span>
        <span class="s1">clustering.fit(X)</span>
        <span class="s1">assert_almost_equal(normalized_mutual_info_score(clustering.labels_</span><span class="s3">, </span><span class="s1">labels)</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">clustering.connectivity = </span><span class="s3">None</span>
        <span class="s1">clustering.fit(X)</span>
        <span class="s3">assert </span><span class="s1">np.size(np.unique(clustering.labels_)) == </span><span class="s4">10</span>
        <span class="s2"># Check that we raise a TypeError on dense matrices</span>
        <span class="s1">clustering = AgglomerativeClustering(</span>
            <span class="s1">n_clusters=</span><span class="s4">10</span><span class="s3">,</span>
            <span class="s1">connectivity=sparse.lil_matrix(connectivity.toarray()[:</span><span class="s4">10</span><span class="s3">, </span><span class="s1">:</span><span class="s4">10</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">linkage=linkage</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s3">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">clustering.fit(X)</span>

    <span class="s2"># Test that using ward with another metric than euclidean raises an</span>
    <span class="s2"># exception</span>
    <span class="s1">clustering = AgglomerativeClustering(</span>
        <span class="s1">n_clusters=</span><span class="s4">10</span><span class="s3">,</span>
        <span class="s1">connectivity=connectivity.toarray()</span><span class="s3">,</span>
        <span class="s1">metric=</span><span class="s5">&quot;manhattan&quot;</span><span class="s3">,</span>
        <span class="s1">linkage=</span><span class="s5">&quot;ward&quot;</span><span class="s3">,</span>
    <span class="s1">)</span>
    <span class="s3">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">clustering.fit(X)</span>

    <span class="s2"># Test using another metric than euclidean works with linkage complete</span>
    <span class="s3">for </span><span class="s1">metric </span><span class="s3">in </span><span class="s1">PAIRED_DISTANCES.keys():</span>
        <span class="s2"># Compare our (structured) implementation to scipy</span>
        <span class="s1">clustering = AgglomerativeClustering(</span>
            <span class="s1">n_clusters=</span><span class="s4">10</span><span class="s3">,</span>
            <span class="s1">connectivity=np.ones((n_samples</span><span class="s3">, </span><span class="s1">n_samples))</span><span class="s3">,</span>
            <span class="s1">metric=metric</span><span class="s3">,</span>
            <span class="s1">linkage=</span><span class="s5">&quot;complete&quot;</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s1">clustering.fit(X)</span>
        <span class="s1">clustering2 = AgglomerativeClustering(</span>
            <span class="s1">n_clusters=</span><span class="s4">10</span><span class="s3">, </span><span class="s1">connectivity=</span><span class="s3">None, </span><span class="s1">metric=metric</span><span class="s3">, </span><span class="s1">linkage=</span><span class="s5">&quot;complete&quot;</span>
        <span class="s1">)</span>
        <span class="s1">clustering2.fit(X)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">normalized_mutual_info_score(clustering2.labels_</span><span class="s3">, </span><span class="s1">clustering.labels_)</span><span class="s3">, </span><span class="s4">1</span>
        <span class="s1">)</span>

    <span class="s2"># Test that using a distance matrix (affinity = 'precomputed') has same</span>
    <span class="s2"># results (with connectivity constraints)</span>
    <span class="s1">clustering = AgglomerativeClustering(</span>
        <span class="s1">n_clusters=</span><span class="s4">10</span><span class="s3">, </span><span class="s1">connectivity=connectivity</span><span class="s3">, </span><span class="s1">linkage=</span><span class="s5">&quot;complete&quot;</span>
    <span class="s1">)</span>
    <span class="s1">clustering.fit(X)</span>
    <span class="s1">X_dist = pairwise_distances(X)</span>
    <span class="s1">clustering2 = AgglomerativeClustering(</span>
        <span class="s1">n_clusters=</span><span class="s4">10</span><span class="s3">,</span>
        <span class="s1">connectivity=connectivity</span><span class="s3">,</span>
        <span class="s1">metric=</span><span class="s5">&quot;precomputed&quot;</span><span class="s3">,</span>
        <span class="s1">linkage=</span><span class="s5">&quot;complete&quot;</span><span class="s3">,</span>
    <span class="s1">)</span>
    <span class="s1">clustering2.fit(X_dist)</span>
    <span class="s1">assert_array_equal(clustering.labels_</span><span class="s3">, </span><span class="s1">clustering2.labels_)</span>


<span class="s3">def </span><span class="s1">test_agglomerative_clustering_memory_mapped():</span>
    <span class="s0">&quot;&quot;&quot;AgglomerativeClustering must work on mem-mapped dataset. 
 
    Non-regression test for issue #19875. 
    &quot;&quot;&quot;</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">Xmm = create_memmap_backed_data(rng.randn(</span><span class="s4">50</span><span class="s3">, </span><span class="s4">100</span><span class="s1">))</span>
    <span class="s1">AgglomerativeClustering(metric=</span><span class="s5">&quot;euclidean&quot;</span><span class="s3">, </span><span class="s1">linkage=</span><span class="s5">&quot;single&quot;</span><span class="s1">).fit(Xmm)</span>


<span class="s3">def </span><span class="s1">test_ward_agglomeration(global_random_seed):</span>
    <span class="s2"># Check that we obtain the correct solution in a simplistic case</span>
    <span class="s1">rng = np.random.RandomState(global_random_seed)</span>
    <span class="s1">mask = np.ones([</span><span class="s4">10</span><span class="s3">, </span><span class="s4">10</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=bool)</span>
    <span class="s1">X = rng.randn(</span><span class="s4">50</span><span class="s3">, </span><span class="s4">100</span><span class="s1">)</span>
    <span class="s1">connectivity = grid_to_graph(*mask.shape)</span>
    <span class="s1">agglo = FeatureAgglomeration(n_clusters=</span><span class="s4">5</span><span class="s3">, </span><span class="s1">connectivity=connectivity)</span>
    <span class="s1">agglo.fit(X)</span>
    <span class="s3">assert </span><span class="s1">np.size(np.unique(agglo.labels_)) == </span><span class="s4">5</span>

    <span class="s1">X_red = agglo.transform(X)</span>
    <span class="s3">assert </span><span class="s1">X_red.shape[</span><span class="s4">1</span><span class="s1">] == </span><span class="s4">5</span>
    <span class="s1">X_full = agglo.inverse_transform(X_red)</span>
    <span class="s3">assert </span><span class="s1">np.unique(X_full[</span><span class="s4">0</span><span class="s1">]).size == </span><span class="s4">5</span>
    <span class="s1">assert_array_almost_equal(agglo.transform(X_full)</span><span class="s3">, </span><span class="s1">X_red)</span>

    <span class="s2"># Check that fitting with no samples raises a ValueError</span>
    <span class="s3">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">agglo.fit(X[:</span><span class="s4">0</span><span class="s1">])</span>


<span class="s3">def </span><span class="s1">test_single_linkage_clustering():</span>
    <span class="s2"># Check that we get the correct result in two emblematic cases</span>
    <span class="s1">moons</span><span class="s3">, </span><span class="s1">moon_labels = make_moons(noise=</span><span class="s4">0.05</span><span class="s3">, </span><span class="s1">random_state=</span><span class="s4">42</span><span class="s1">)</span>
    <span class="s1">clustering = AgglomerativeClustering(n_clusters=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">linkage=</span><span class="s5">&quot;single&quot;</span><span class="s1">)</span>
    <span class="s1">clustering.fit(moons)</span>
    <span class="s1">assert_almost_equal(</span>
        <span class="s1">normalized_mutual_info_score(clustering.labels_</span><span class="s3">, </span><span class="s1">moon_labels)</span><span class="s3">, </span><span class="s4">1</span>
    <span class="s1">)</span>

    <span class="s1">circles</span><span class="s3">, </span><span class="s1">circle_labels = make_circles(factor=</span><span class="s4">0.5</span><span class="s3">, </span><span class="s1">noise=</span><span class="s4">0.025</span><span class="s3">, </span><span class="s1">random_state=</span><span class="s4">42</span><span class="s1">)</span>
    <span class="s1">clustering = AgglomerativeClustering(n_clusters=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">linkage=</span><span class="s5">&quot;single&quot;</span><span class="s1">)</span>
    <span class="s1">clustering.fit(circles)</span>
    <span class="s1">assert_almost_equal(</span>
        <span class="s1">normalized_mutual_info_score(clustering.labels_</span><span class="s3">, </span><span class="s1">circle_labels)</span><span class="s3">, </span><span class="s4">1</span>
    <span class="s1">)</span>


<span class="s3">def </span><span class="s1">assess_same_labelling(cut1</span><span class="s3">, </span><span class="s1">cut2):</span>
    <span class="s0">&quot;&quot;&quot;Util for comparison with scipy&quot;&quot;&quot;</span>
    <span class="s1">co_clust = []</span>
    <span class="s3">for </span><span class="s1">cut </span><span class="s3">in </span><span class="s1">[cut1</span><span class="s3">, </span><span class="s1">cut2]:</span>
        <span class="s1">n = len(cut)</span>
        <span class="s1">k = cut.max() + </span><span class="s4">1</span>
        <span class="s1">ecut = np.zeros((n</span><span class="s3">, </span><span class="s1">k))</span>
        <span class="s1">ecut[np.arange(n)</span><span class="s3">, </span><span class="s1">cut] = </span><span class="s4">1</span>
        <span class="s1">co_clust.append(np.dot(ecut</span><span class="s3">, </span><span class="s1">ecut.T))</span>
    <span class="s3">assert </span><span class="s1">(co_clust[</span><span class="s4">0</span><span class="s1">] == co_clust[</span><span class="s4">1</span><span class="s1">]).all()</span>


<span class="s3">def </span><span class="s1">test_sparse_scikit_vs_scipy(global_random_seed):</span>
    <span class="s2"># Test scikit linkage with full connectivity (i.e. unstructured) vs scipy</span>
    <span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k = </span><span class="s4">10</span><span class="s3">, </span><span class="s4">5</span><span class="s3">, </span><span class="s4">3</span>
    <span class="s1">rng = np.random.RandomState(global_random_seed)</span>

    <span class="s2"># Not using a lil_matrix here, just to check that non sparse</span>
    <span class="s2"># matrices are well handled</span>
    <span class="s1">connectivity = np.ones((n</span><span class="s3">, </span><span class="s1">n))</span>
    <span class="s3">for </span><span class="s1">linkage </span><span class="s3">in </span><span class="s1">_TREE_BUILDERS.keys():</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(</span><span class="s4">5</span><span class="s1">):</span>
            <span class="s1">X = </span><span class="s4">0.1 </span><span class="s1">* rng.normal(size=(n</span><span class="s3">, </span><span class="s1">p))</span>
            <span class="s1">X -= </span><span class="s4">4.0 </span><span class="s1">* np.arange(n)[:</span><span class="s3">, </span><span class="s1">np.newaxis]</span>
            <span class="s1">X -= X.mean(axis=</span><span class="s4">1</span><span class="s1">)[:</span><span class="s3">, </span><span class="s1">np.newaxis]</span>

            <span class="s1">out = hierarchy.linkage(X</span><span class="s3">, </span><span class="s1">method=linkage)</span>

            <span class="s1">children_ = out[:</span><span class="s3">, </span><span class="s1">:</span><span class="s4">2</span><span class="s1">].astype(int</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">)</span>
            <span class="s1">children</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">n_leaves</span><span class="s3">, </span><span class="s1">_ = _TREE_BUILDERS[linkage](</span>
                <span class="s1">X</span><span class="s3">, </span><span class="s1">connectivity=connectivity</span>
            <span class="s1">)</span>

            <span class="s2"># Sort the order of child nodes per row for consistency</span>
            <span class="s1">children.sort(axis=</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">assert_array_equal(</span>
                <span class="s1">children</span><span class="s3">,</span>
                <span class="s1">children_</span><span class="s3">,</span>
                <span class="s5">&quot;linkage tree differs from scipy impl for linkage: &quot; </span><span class="s1">+ linkage</span><span class="s3">,</span>
            <span class="s1">)</span>

            <span class="s1">cut = _hc_cut(k</span><span class="s3">, </span><span class="s1">children</span><span class="s3">, </span><span class="s1">n_leaves)</span>
            <span class="s1">cut_ = _hc_cut(k</span><span class="s3">, </span><span class="s1">children_</span><span class="s3">, </span><span class="s1">n_leaves)</span>
            <span class="s1">assess_same_labelling(cut</span><span class="s3">, </span><span class="s1">cut_)</span>

    <span class="s2"># Test error management in _hc_cut</span>
    <span class="s3">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">_hc_cut(n_leaves + </span><span class="s4">1</span><span class="s3">, </span><span class="s1">children</span><span class="s3">, </span><span class="s1">n_leaves)</span>


<span class="s2"># Make sure our custom mst_linkage_core gives</span>
<span class="s2"># the same results as scipy's builtin</span>
<span class="s3">def </span><span class="s1">test_vector_scikit_single_vs_scipy_single(global_random_seed):</span>
    <span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_features</span><span class="s3">, </span><span class="s1">n_clusters = </span><span class="s4">10</span><span class="s3">, </span><span class="s4">5</span><span class="s3">, </span><span class="s4">3</span>
    <span class="s1">rng = np.random.RandomState(global_random_seed)</span>
    <span class="s1">X = </span><span class="s4">0.1 </span><span class="s1">* rng.normal(size=(n_samples</span><span class="s3">, </span><span class="s1">n_features))</span>
    <span class="s1">X -= </span><span class="s4">4.0 </span><span class="s1">* np.arange(n_samples)[:</span><span class="s3">, </span><span class="s1">np.newaxis]</span>
    <span class="s1">X -= X.mean(axis=</span><span class="s4">1</span><span class="s1">)[:</span><span class="s3">, </span><span class="s1">np.newaxis]</span>

    <span class="s1">out = hierarchy.linkage(X</span><span class="s3">, </span><span class="s1">method=</span><span class="s5">&quot;single&quot;</span><span class="s1">)</span>
    <span class="s1">children_scipy = out[:</span><span class="s3">, </span><span class="s1">:</span><span class="s4">2</span><span class="s1">].astype(int)</span>

    <span class="s1">children</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">n_leaves</span><span class="s3">, </span><span class="s1">_ = _TREE_BUILDERS[</span><span class="s5">&quot;single&quot;</span><span class="s1">](X)</span>

    <span class="s2"># Sort the order of child nodes per row for consistency</span>
    <span class="s1">children.sort(axis=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">assert_array_equal(</span>
        <span class="s1">children</span><span class="s3">,</span>
        <span class="s1">children_scipy</span><span class="s3">,</span>
        <span class="s5">&quot;linkage tree differs from scipy impl for single linkage.&quot;</span><span class="s3">,</span>
    <span class="s1">)</span>

    <span class="s1">cut = _hc_cut(n_clusters</span><span class="s3">, </span><span class="s1">children</span><span class="s3">, </span><span class="s1">n_leaves)</span>
    <span class="s1">cut_scipy = _hc_cut(n_clusters</span><span class="s3">, </span><span class="s1">children_scipy</span><span class="s3">, </span><span class="s1">n_leaves)</span>
    <span class="s1">assess_same_labelling(cut</span><span class="s3">, </span><span class="s1">cut_scipy)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;metric_param_grid&quot;</span><span class="s3">, </span><span class="s1">METRICS_DEFAULT_PARAMS)</span>
<span class="s3">def </span><span class="s1">test_mst_linkage_core_memory_mapped(metric_param_grid):</span>
    <span class="s0">&quot;&quot;&quot;The MST-LINKAGE-CORE algorithm must work on mem-mapped dataset. 
 
    Non-regression test for issue #19875. 
    &quot;&quot;&quot;</span>
    <span class="s1">rng = np.random.RandomState(seed=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">X = rng.normal(size=(</span><span class="s4">20</span><span class="s3">, </span><span class="s4">4</span><span class="s1">))</span>
    <span class="s1">Xmm = create_memmap_backed_data(X)</span>
    <span class="s1">metric</span><span class="s3">, </span><span class="s1">param_grid = metric_param_grid</span>
    <span class="s1">keys = param_grid.keys()</span>
    <span class="s3">for </span><span class="s1">vals </span><span class="s3">in </span><span class="s1">itertools.product(*param_grid.values()):</span>
        <span class="s1">kwargs = dict(zip(keys</span><span class="s3">, </span><span class="s1">vals))</span>
        <span class="s1">distance_metric = DistanceMetric.get_metric(metric</span><span class="s3">, </span><span class="s1">**kwargs)</span>
        <span class="s1">mst = mst_linkage_core(X</span><span class="s3">, </span><span class="s1">distance_metric)</span>
        <span class="s1">mst_mm = mst_linkage_core(Xmm</span><span class="s3">, </span><span class="s1">distance_metric)</span>
        <span class="s1">np.testing.assert_equal(mst</span><span class="s3">, </span><span class="s1">mst_mm)</span>


<span class="s3">def </span><span class="s1">test_identical_points():</span>
    <span class="s2"># Ensure identical points are handled correctly when using mst with</span>
    <span class="s2"># a sparse connectivity matrix</span>
    <span class="s1">X = np.array([[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s1">]])</span>
    <span class="s1">true_labels = np.array([</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s1">])</span>
    <span class="s1">connectivity = kneighbors_graph(X</span><span class="s3">, </span><span class="s1">n_neighbors=</span><span class="s4">3</span><span class="s3">, </span><span class="s1">include_self=</span><span class="s3">False</span><span class="s1">)</span>
    <span class="s1">connectivity = </span><span class="s4">0.5 </span><span class="s1">* (connectivity + connectivity.T)</span>
    <span class="s1">connectivity</span><span class="s3">, </span><span class="s1">n_components = _fix_connectivity(X</span><span class="s3">, </span><span class="s1">connectivity</span><span class="s3">, </span><span class="s5">&quot;euclidean&quot;</span><span class="s1">)</span>

    <span class="s3">for </span><span class="s1">linkage </span><span class="s3">in </span><span class="s1">(</span><span class="s5">&quot;single&quot;</span><span class="s3">, </span><span class="s5">&quot;average&quot;</span><span class="s3">, </span><span class="s5">&quot;average&quot;</span><span class="s3">, </span><span class="s5">&quot;ward&quot;</span><span class="s1">):</span>
        <span class="s1">clustering = AgglomerativeClustering(</span>
            <span class="s1">n_clusters=</span><span class="s4">3</span><span class="s3">, </span><span class="s1">linkage=linkage</span><span class="s3">, </span><span class="s1">connectivity=connectivity</span>
        <span class="s1">)</span>
        <span class="s1">clustering.fit(X)</span>

        <span class="s1">assert_almost_equal(</span>
            <span class="s1">normalized_mutual_info_score(clustering.labels_</span><span class="s3">, </span><span class="s1">true_labels)</span><span class="s3">, </span><span class="s4">1</span>
        <span class="s1">)</span>


<span class="s3">def </span><span class="s1">test_connectivity_propagation():</span>
    <span class="s2"># Check that connectivity in the ward tree is propagated correctly during</span>
    <span class="s2"># merging.</span>
    <span class="s1">X = np.array(</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s4">0.014</span><span class="s3">, </span><span class="s4">0.120</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">0.014</span><span class="s3">, </span><span class="s4">0.099</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">0.014</span><span class="s3">, </span><span class="s4">0.097</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">0.017</span><span class="s3">, </span><span class="s4">0.153</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">0.017</span><span class="s3">, </span><span class="s4">0.153</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">0.018</span><span class="s3">, </span><span class="s4">0.153</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">0.018</span><span class="s3">, </span><span class="s4">0.153</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">0.018</span><span class="s3">, </span><span class="s4">0.153</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">0.018</span><span class="s3">, </span><span class="s4">0.153</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">0.018</span><span class="s3">, </span><span class="s4">0.153</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">0.018</span><span class="s3">, </span><span class="s4">0.153</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">0.018</span><span class="s3">, </span><span class="s4">0.153</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">0.018</span><span class="s3">, </span><span class="s4">0.152</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">0.018</span><span class="s3">, </span><span class="s4">0.149</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">0.018</span><span class="s3">, </span><span class="s4">0.144</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">connectivity = kneighbors_graph(X</span><span class="s3">, </span><span class="s4">10</span><span class="s3">, </span><span class="s1">include_self=</span><span class="s3">False</span><span class="s1">)</span>
    <span class="s1">ward = AgglomerativeClustering(</span>
        <span class="s1">n_clusters=</span><span class="s4">4</span><span class="s3">, </span><span class="s1">connectivity=connectivity</span><span class="s3">, </span><span class="s1">linkage=</span><span class="s5">&quot;ward&quot;</span>
    <span class="s1">)</span>
    <span class="s2"># If changes are not propagated correctly, fit crashes with an</span>
    <span class="s2"># IndexError</span>
    <span class="s1">ward.fit(X)</span>


<span class="s3">def </span><span class="s1">test_ward_tree_children_order(global_random_seed):</span>
    <span class="s2"># Check that children are ordered in the same way for both structured and</span>
    <span class="s2"># unstructured versions of ward_tree.</span>

    <span class="s2"># test on five random datasets</span>
    <span class="s1">n</span><span class="s3">, </span><span class="s1">p = </span><span class="s4">10</span><span class="s3">, </span><span class="s4">5</span>
    <span class="s1">rng = np.random.RandomState(global_random_seed)</span>

    <span class="s1">connectivity = np.ones((n</span><span class="s3">, </span><span class="s1">n))</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(</span><span class="s4">5</span><span class="s1">):</span>
        <span class="s1">X = </span><span class="s4">0.1 </span><span class="s1">* rng.normal(size=(n</span><span class="s3">, </span><span class="s1">p))</span>
        <span class="s1">X -= </span><span class="s4">4.0 </span><span class="s1">* np.arange(n)[:</span><span class="s3">, </span><span class="s1">np.newaxis]</span>
        <span class="s1">X -= X.mean(axis=</span><span class="s4">1</span><span class="s1">)[:</span><span class="s3">, </span><span class="s1">np.newaxis]</span>

        <span class="s1">out_unstructured = ward_tree(X)</span>
        <span class="s1">out_structured = ward_tree(X</span><span class="s3">, </span><span class="s1">connectivity=connectivity)</span>

        <span class="s1">assert_array_equal(out_unstructured[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">out_structured[</span><span class="s4">0</span><span class="s1">])</span>


<span class="s3">def </span><span class="s1">test_ward_linkage_tree_return_distance(global_random_seed):</span>
    <span class="s2"># Test return_distance option on linkage and ward trees</span>

    <span class="s2"># test that return_distance when set true, gives same</span>
    <span class="s2"># output on both structured and unstructured clustering.</span>
    <span class="s1">n</span><span class="s3">, </span><span class="s1">p = </span><span class="s4">10</span><span class="s3">, </span><span class="s4">5</span>
    <span class="s1">rng = np.random.RandomState(global_random_seed)</span>

    <span class="s1">connectivity = np.ones((n</span><span class="s3">, </span><span class="s1">n))</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(</span><span class="s4">5</span><span class="s1">):</span>
        <span class="s1">X = </span><span class="s4">0.1 </span><span class="s1">* rng.normal(size=(n</span><span class="s3">, </span><span class="s1">p))</span>
        <span class="s1">X -= </span><span class="s4">4.0 </span><span class="s1">* np.arange(n)[:</span><span class="s3">, </span><span class="s1">np.newaxis]</span>
        <span class="s1">X -= X.mean(axis=</span><span class="s4">1</span><span class="s1">)[:</span><span class="s3">, </span><span class="s1">np.newaxis]</span>

        <span class="s1">out_unstructured = ward_tree(X</span><span class="s3">, </span><span class="s1">return_distance=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s1">out_structured = ward_tree(X</span><span class="s3">, </span><span class="s1">connectivity=connectivity</span><span class="s3">, </span><span class="s1">return_distance=</span><span class="s3">True</span><span class="s1">)</span>

        <span class="s2"># get children</span>
        <span class="s1">children_unstructured = out_unstructured[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">children_structured = out_structured[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s2"># check if we got the same clusters</span>
        <span class="s1">assert_array_equal(children_unstructured</span><span class="s3">, </span><span class="s1">children_structured)</span>

        <span class="s2"># check if the distances are the same</span>
        <span class="s1">dist_unstructured = out_unstructured[-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">dist_structured = out_structured[-</span><span class="s4">1</span><span class="s1">]</span>

        <span class="s1">assert_array_almost_equal(dist_unstructured</span><span class="s3">, </span><span class="s1">dist_structured)</span>

        <span class="s3">for </span><span class="s1">linkage </span><span class="s3">in </span><span class="s1">[</span><span class="s5">&quot;average&quot;</span><span class="s3">, </span><span class="s5">&quot;complete&quot;</span><span class="s3">, </span><span class="s5">&quot;single&quot;</span><span class="s1">]:</span>
            <span class="s1">structured_items = linkage_tree(</span>
                <span class="s1">X</span><span class="s3">, </span><span class="s1">connectivity=connectivity</span><span class="s3">, </span><span class="s1">linkage=linkage</span><span class="s3">, </span><span class="s1">return_distance=</span><span class="s3">True</span>
            <span class="s1">)[-</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">unstructured_items = linkage_tree(X</span><span class="s3">, </span><span class="s1">linkage=linkage</span><span class="s3">, </span><span class="s1">return_distance=</span><span class="s3">True</span><span class="s1">)[</span>
                <span class="s1">-</span><span class="s4">1</span>
            <span class="s1">]</span>
            <span class="s1">structured_dist = structured_items[-</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">unstructured_dist = unstructured_items[-</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">structured_children = structured_items[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">unstructured_children = unstructured_items[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">assert_array_almost_equal(structured_dist</span><span class="s3">, </span><span class="s1">unstructured_dist)</span>
            <span class="s1">assert_array_almost_equal(structured_children</span><span class="s3">, </span><span class="s1">unstructured_children)</span>

    <span class="s2"># test on the following dataset where we know the truth</span>
    <span class="s2"># taken from scipy/cluster/tests/hierarchy_test_data.py</span>
    <span class="s1">X = np.array(</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s4">1.43054825</span><span class="s3">, </span><span class="s1">-</span><span class="s4">7.5693489</span><span class="s1">]</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s4">6.95887839</span><span class="s3">, </span><span class="s4">6.82293382</span><span class="s1">]</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s4">2.87137846</span><span class="s3">, </span><span class="s1">-</span><span class="s4">9.68248579</span><span class="s1">]</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s4">7.87974764</span><span class="s3">, </span><span class="s1">-</span><span class="s4">6.05485803</span><span class="s1">]</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s4">8.24018364</span><span class="s3">, </span><span class="s1">-</span><span class="s4">6.09495602</span><span class="s1">]</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s4">7.39020262</span><span class="s3">, </span><span class="s4">8.54004355</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s2"># truth</span>
    <span class="s1">linkage_X_ward = np.array(</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s4">3.0</span><span class="s3">, </span><span class="s4">4.0</span><span class="s3">, </span><span class="s4">0.36265956</span><span class="s3">, </span><span class="s4">2.0</span><span class="s1">]</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s4">1.0</span><span class="s3">, </span><span class="s4">5.0</span><span class="s3">, </span><span class="s4">1.77045373</span><span class="s3">, </span><span class="s4">2.0</span><span class="s1">]</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s4">0.0</span><span class="s3">, </span><span class="s4">2.0</span><span class="s3">, </span><span class="s4">2.55760419</span><span class="s3">, </span><span class="s4">2.0</span><span class="s1">]</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s4">6.0</span><span class="s3">, </span><span class="s4">8.0</span><span class="s3">, </span><span class="s4">9.10208346</span><span class="s3">, </span><span class="s4">4.0</span><span class="s1">]</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s4">7.0</span><span class="s3">, </span><span class="s4">9.0</span><span class="s3">, </span><span class="s4">24.7784379</span><span class="s3">, </span><span class="s4">6.0</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>

    <span class="s1">linkage_X_complete = np.array(</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s4">3.0</span><span class="s3">, </span><span class="s4">4.0</span><span class="s3">, </span><span class="s4">0.36265956</span><span class="s3">, </span><span class="s4">2.0</span><span class="s1">]</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s4">1.0</span><span class="s3">, </span><span class="s4">5.0</span><span class="s3">, </span><span class="s4">1.77045373</span><span class="s3">, </span><span class="s4">2.0</span><span class="s1">]</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s4">0.0</span><span class="s3">, </span><span class="s4">2.0</span><span class="s3">, </span><span class="s4">2.55760419</span><span class="s3">, </span><span class="s4">2.0</span><span class="s1">]</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s4">6.0</span><span class="s3">, </span><span class="s4">8.0</span><span class="s3">, </span><span class="s4">6.96742194</span><span class="s3">, </span><span class="s4">4.0</span><span class="s1">]</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s4">7.0</span><span class="s3">, </span><span class="s4">9.0</span><span class="s3">, </span><span class="s4">18.77445997</span><span class="s3">, </span><span class="s4">6.0</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>

    <span class="s1">linkage_X_average = np.array(</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s4">3.0</span><span class="s3">, </span><span class="s4">4.0</span><span class="s3">, </span><span class="s4">0.36265956</span><span class="s3">, </span><span class="s4">2.0</span><span class="s1">]</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s4">1.0</span><span class="s3">, </span><span class="s4">5.0</span><span class="s3">, </span><span class="s4">1.77045373</span><span class="s3">, </span><span class="s4">2.0</span><span class="s1">]</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s4">0.0</span><span class="s3">, </span><span class="s4">2.0</span><span class="s3">, </span><span class="s4">2.55760419</span><span class="s3">, </span><span class="s4">2.0</span><span class="s1">]</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s4">6.0</span><span class="s3">, </span><span class="s4">8.0</span><span class="s3">, </span><span class="s4">6.55832839</span><span class="s3">, </span><span class="s4">4.0</span><span class="s1">]</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s4">7.0</span><span class="s3">, </span><span class="s4">9.0</span><span class="s3">, </span><span class="s4">15.44089605</span><span class="s3">, </span><span class="s4">6.0</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>

    <span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_features = np.shape(X)</span>
    <span class="s1">connectivity_X = np.ones((n_samples</span><span class="s3">, </span><span class="s1">n_samples))</span>

    <span class="s1">out_X_unstructured = ward_tree(X</span><span class="s3">, </span><span class="s1">return_distance=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s1">out_X_structured = ward_tree(X</span><span class="s3">, </span><span class="s1">connectivity=connectivity_X</span><span class="s3">, </span><span class="s1">return_distance=</span><span class="s3">True</span><span class="s1">)</span>

    <span class="s2"># check that the labels are the same</span>
    <span class="s1">assert_array_equal(linkage_X_ward[:</span><span class="s3">, </span><span class="s1">:</span><span class="s4">2</span><span class="s1">]</span><span class="s3">, </span><span class="s1">out_X_unstructured[</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(linkage_X_ward[:</span><span class="s3">, </span><span class="s1">:</span><span class="s4">2</span><span class="s1">]</span><span class="s3">, </span><span class="s1">out_X_structured[</span><span class="s4">0</span><span class="s1">])</span>

    <span class="s2"># check that the distances are correct</span>
    <span class="s1">assert_array_almost_equal(linkage_X_ward[:</span><span class="s3">, </span><span class="s4">2</span><span class="s1">]</span><span class="s3">, </span><span class="s1">out_X_unstructured[</span><span class="s4">4</span><span class="s1">])</span>
    <span class="s1">assert_array_almost_equal(linkage_X_ward[:</span><span class="s3">, </span><span class="s4">2</span><span class="s1">]</span><span class="s3">, </span><span class="s1">out_X_structured[</span><span class="s4">4</span><span class="s1">])</span>

    <span class="s1">linkage_options = [</span><span class="s5">&quot;complete&quot;</span><span class="s3">, </span><span class="s5">&quot;average&quot;</span><span class="s3">, </span><span class="s5">&quot;single&quot;</span><span class="s1">]</span>
    <span class="s1">X_linkage_truth = [linkage_X_complete</span><span class="s3">, </span><span class="s1">linkage_X_average]</span>
    <span class="s3">for </span><span class="s1">linkage</span><span class="s3">, </span><span class="s1">X_truth </span><span class="s3">in </span><span class="s1">zip(linkage_options</span><span class="s3">, </span><span class="s1">X_linkage_truth):</span>
        <span class="s1">out_X_unstructured = linkage_tree(X</span><span class="s3">, </span><span class="s1">return_distance=</span><span class="s3">True, </span><span class="s1">linkage=linkage)</span>
        <span class="s1">out_X_structured = linkage_tree(</span>
            <span class="s1">X</span><span class="s3">, </span><span class="s1">connectivity=connectivity_X</span><span class="s3">, </span><span class="s1">linkage=linkage</span><span class="s3">, </span><span class="s1">return_distance=</span><span class="s3">True</span>
        <span class="s1">)</span>

        <span class="s2"># check that the labels are the same</span>
        <span class="s1">assert_array_equal(X_truth[:</span><span class="s3">, </span><span class="s1">:</span><span class="s4">2</span><span class="s1">]</span><span class="s3">, </span><span class="s1">out_X_unstructured[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(X_truth[:</span><span class="s3">, </span><span class="s1">:</span><span class="s4">2</span><span class="s1">]</span><span class="s3">, </span><span class="s1">out_X_structured[</span><span class="s4">0</span><span class="s1">])</span>

        <span class="s2"># check that the distances are correct</span>
        <span class="s1">assert_array_almost_equal(X_truth[:</span><span class="s3">, </span><span class="s4">2</span><span class="s1">]</span><span class="s3">, </span><span class="s1">out_X_unstructured[</span><span class="s4">4</span><span class="s1">])</span>
        <span class="s1">assert_array_almost_equal(X_truth[:</span><span class="s3">, </span><span class="s4">2</span><span class="s1">]</span><span class="s3">, </span><span class="s1">out_X_structured[</span><span class="s4">4</span><span class="s1">])</span>


<span class="s3">def </span><span class="s1">test_connectivity_fixing_non_lil():</span>
    <span class="s2"># Check non regression of a bug if a non item assignable connectivity is</span>
    <span class="s2"># provided with more than one component.</span>
    <span class="s2"># create dummy data</span>
    <span class="s1">x = np.array([[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s1">]])</span>
    <span class="s2"># create a mask with several components to force connectivity fixing</span>
    <span class="s1">m = np.array([[</span><span class="s3">True, False</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s3">False, True</span><span class="s1">]])</span>
    <span class="s1">c = grid_to_graph(n_x=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">n_y=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">mask=m)</span>
    <span class="s1">w = AgglomerativeClustering(connectivity=c</span><span class="s3">, </span><span class="s1">linkage=</span><span class="s5">&quot;ward&quot;</span><span class="s1">)</span>
    <span class="s3">with </span><span class="s1">pytest.warns(UserWarning):</span>
        <span class="s1">w.fit(x)</span>


<span class="s3">def </span><span class="s1">test_int_float_dict():</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">keys = np.unique(rng.randint(</span><span class="s4">100</span><span class="s3">, </span><span class="s1">size=</span><span class="s4">10</span><span class="s1">).astype(np.intp</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">))</span>
    <span class="s1">values = rng.rand(len(keys))</span>

    <span class="s1">d = IntFloatDict(keys</span><span class="s3">, </span><span class="s1">values)</span>
    <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">zip(keys</span><span class="s3">, </span><span class="s1">values):</span>
        <span class="s3">assert </span><span class="s1">d[key] == value</span>

    <span class="s1">other_keys = np.arange(</span><span class="s4">50</span><span class="s3">, </span><span class="s1">dtype=np.intp)[::</span><span class="s4">2</span><span class="s1">]</span>
    <span class="s1">other_values = np.full(</span><span class="s4">50</span><span class="s3">, </span><span class="s4">0.5</span><span class="s1">)[::</span><span class="s4">2</span><span class="s1">]</span>
    <span class="s1">other = IntFloatDict(other_keys</span><span class="s3">, </span><span class="s1">other_values)</span>
    <span class="s2"># Complete smoke test</span>
    <span class="s1">max_merge(d</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">mask=np.ones(</span><span class="s4">100</span><span class="s3">, </span><span class="s1">dtype=np.intp)</span><span class="s3">, </span><span class="s1">n_a=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">n_b=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">average_merge(d</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">mask=np.ones(</span><span class="s4">100</span><span class="s3">, </span><span class="s1">dtype=np.intp)</span><span class="s3">, </span><span class="s1">n_a=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">n_b=</span><span class="s4">1</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">test_connectivity_callable():</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">X = rng.rand(</span><span class="s4">20</span><span class="s3">, </span><span class="s4">5</span><span class="s1">)</span>
    <span class="s1">connectivity = kneighbors_graph(X</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s1">include_self=</span><span class="s3">False</span><span class="s1">)</span>
    <span class="s1">aglc1 = AgglomerativeClustering(connectivity=connectivity)</span>
    <span class="s1">aglc2 = AgglomerativeClustering(</span>
        <span class="s1">connectivity=partial(kneighbors_graph</span><span class="s3">, </span><span class="s1">n_neighbors=</span><span class="s4">3</span><span class="s3">, </span><span class="s1">include_self=</span><span class="s3">False</span><span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">aglc1.fit(X)</span>
    <span class="s1">aglc2.fit(X)</span>
    <span class="s1">assert_array_equal(aglc1.labels_</span><span class="s3">, </span><span class="s1">aglc2.labels_)</span>


<span class="s3">def </span><span class="s1">test_connectivity_ignores_diagonal():</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">X = rng.rand(</span><span class="s4">20</span><span class="s3">, </span><span class="s4">5</span><span class="s1">)</span>
    <span class="s1">connectivity = kneighbors_graph(X</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s1">include_self=</span><span class="s3">False</span><span class="s1">)</span>
    <span class="s1">connectivity_include_self = kneighbors_graph(X</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s1">include_self=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s1">aglc1 = AgglomerativeClustering(connectivity=connectivity)</span>
    <span class="s1">aglc2 = AgglomerativeClustering(connectivity=connectivity_include_self)</span>
    <span class="s1">aglc1.fit(X)</span>
    <span class="s1">aglc2.fit(X)</span>
    <span class="s1">assert_array_equal(aglc1.labels_</span><span class="s3">, </span><span class="s1">aglc2.labels_)</span>


<span class="s3">def </span><span class="s1">test_compute_full_tree():</span>
    <span class="s2"># Test that the full tree is computed if n_clusters is small</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">X = rng.randn(</span><span class="s4">10</span><span class="s3">, </span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">connectivity = kneighbors_graph(X</span><span class="s3">, </span><span class="s4">5</span><span class="s3">, </span><span class="s1">include_self=</span><span class="s3">False</span><span class="s1">)</span>

    <span class="s2"># When n_clusters is less, the full tree should be built</span>
    <span class="s2"># that is the number of merges should be n_samples - 1</span>
    <span class="s1">agc = AgglomerativeClustering(n_clusters=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">connectivity=connectivity)</span>
    <span class="s1">agc.fit(X)</span>
    <span class="s1">n_samples = X.shape[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">n_nodes = agc.children_.shape[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s3">assert </span><span class="s1">n_nodes == n_samples - </span><span class="s4">1</span>

    <span class="s2"># When n_clusters is large, greater than max of 100 and 0.02 * n_samples.</span>
    <span class="s2"># we should stop when there are n_clusters.</span>
    <span class="s1">n_clusters = </span><span class="s4">101</span>
    <span class="s1">X = rng.randn(</span><span class="s4">200</span><span class="s3">, </span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">connectivity = kneighbors_graph(X</span><span class="s3">, </span><span class="s4">10</span><span class="s3">, </span><span class="s1">include_self=</span><span class="s3">False</span><span class="s1">)</span>
    <span class="s1">agc = AgglomerativeClustering(n_clusters=n_clusters</span><span class="s3">, </span><span class="s1">connectivity=connectivity)</span>
    <span class="s1">agc.fit(X)</span>
    <span class="s1">n_samples = X.shape[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">n_nodes = agc.children_.shape[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s3">assert </span><span class="s1">n_nodes == n_samples - n_clusters</span>


<span class="s3">def </span><span class="s1">test_n_components():</span>
    <span class="s2"># Test n_components returned by linkage, average and ward tree</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">X = rng.rand(</span><span class="s4">5</span><span class="s3">, </span><span class="s4">5</span><span class="s1">)</span>

    <span class="s2"># Connectivity matrix having five components.</span>
    <span class="s1">connectivity = np.eye(</span><span class="s4">5</span><span class="s1">)</span>

    <span class="s3">for </span><span class="s1">linkage_func </span><span class="s3">in </span><span class="s1">_TREE_BUILDERS.values():</span>
        <span class="s3">assert </span><span class="s1">ignore_warnings(linkage_func)(X</span><span class="s3">, </span><span class="s1">connectivity=connectivity)[</span><span class="s4">1</span><span class="s1">] == </span><span class="s4">5</span>


<span class="s3">def </span><span class="s1">test_affinity_passed_to_fix_connectivity():</span>
    <span class="s2"># Test that the affinity parameter is actually passed to the pairwise</span>
    <span class="s2"># function</span>

    <span class="s1">size = </span><span class="s4">2</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">X = rng.randn(size</span><span class="s3">, </span><span class="s1">size)</span>
    <span class="s1">mask = np.array([</span><span class="s3">True, False, False, True</span><span class="s1">])</span>

    <span class="s1">connectivity = grid_to_graph(n_x=size</span><span class="s3">, </span><span class="s1">n_y=size</span><span class="s3">, </span><span class="s1">mask=mask</span><span class="s3">, </span><span class="s1">return_as=np.ndarray)</span>

    <span class="s3">class </span><span class="s1">FakeAffinity:</span>
        <span class="s3">def </span><span class="s1">__init__(self):</span>
            <span class="s1">self.counter = </span><span class="s4">0</span>

        <span class="s3">def </span><span class="s1">increment(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
            <span class="s1">self.counter += </span><span class="s4">1</span>
            <span class="s3">return </span><span class="s1">self.counter</span>

    <span class="s1">fa = FakeAffinity()</span>

    <span class="s1">linkage_tree(X</span><span class="s3">, </span><span class="s1">connectivity=connectivity</span><span class="s3">, </span><span class="s1">affinity=fa.increment)</span>

    <span class="s3">assert </span><span class="s1">fa.counter == </span><span class="s4">3</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;linkage&quot;</span><span class="s3">, </span><span class="s1">[</span><span class="s5">&quot;ward&quot;</span><span class="s3">, </span><span class="s5">&quot;complete&quot;</span><span class="s3">, </span><span class="s5">&quot;average&quot;</span><span class="s1">])</span>
<span class="s3">def </span><span class="s1">test_agglomerative_clustering_with_distance_threshold(linkage</span><span class="s3">, </span><span class="s1">global_random_seed):</span>
    <span class="s2"># Check that we obtain the correct number of clusters with</span>
    <span class="s2"># agglomerative clustering with distance_threshold.</span>
    <span class="s1">rng = np.random.RandomState(global_random_seed)</span>
    <span class="s1">mask = np.ones([</span><span class="s4">10</span><span class="s3">, </span><span class="s4">10</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=bool)</span>
    <span class="s1">n_samples = </span><span class="s4">100</span>
    <span class="s1">X = rng.randn(n_samples</span><span class="s3">, </span><span class="s4">50</span><span class="s1">)</span>
    <span class="s1">connectivity = grid_to_graph(*mask.shape)</span>
    <span class="s2"># test when distance threshold is set to 10</span>
    <span class="s1">distance_threshold = </span><span class="s4">10</span>
    <span class="s3">for </span><span class="s1">conn </span><span class="s3">in </span><span class="s1">[</span><span class="s3">None, </span><span class="s1">connectivity]:</span>
        <span class="s1">clustering = AgglomerativeClustering(</span>
            <span class="s1">n_clusters=</span><span class="s3">None,</span>
            <span class="s1">distance_threshold=distance_threshold</span><span class="s3">,</span>
            <span class="s1">connectivity=conn</span><span class="s3">,</span>
            <span class="s1">linkage=linkage</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s1">clustering.fit(X)</span>
        <span class="s1">clusters_produced = clustering.labels_</span>
        <span class="s1">num_clusters_produced = len(np.unique(clustering.labels_))</span>
        <span class="s2"># test if the clusters produced match the point in the linkage tree</span>
        <span class="s2"># where the distance exceeds the threshold</span>
        <span class="s1">tree_builder = _TREE_BUILDERS[linkage]</span>
        <span class="s1">children</span><span class="s3">, </span><span class="s1">n_components</span><span class="s3">, </span><span class="s1">n_leaves</span><span class="s3">, </span><span class="s1">parent</span><span class="s3">, </span><span class="s1">distances = tree_builder(</span>
            <span class="s1">X</span><span class="s3">, </span><span class="s1">connectivity=conn</span><span class="s3">, </span><span class="s1">n_clusters=</span><span class="s3">None, </span><span class="s1">return_distance=</span><span class="s3">True</span>
        <span class="s1">)</span>
        <span class="s1">num_clusters_at_threshold = (</span>
            <span class="s1">np.count_nonzero(distances &gt;= distance_threshold) + </span><span class="s4">1</span>
        <span class="s1">)</span>
        <span class="s2"># test number of clusters produced</span>
        <span class="s3">assert </span><span class="s1">num_clusters_at_threshold == num_clusters_produced</span>
        <span class="s2"># test clusters produced</span>
        <span class="s1">clusters_at_threshold = _hc_cut(</span>
            <span class="s1">n_clusters=num_clusters_produced</span><span class="s3">, </span><span class="s1">children=children</span><span class="s3">, </span><span class="s1">n_leaves=n_leaves</span>
        <span class="s1">)</span>
        <span class="s3">assert </span><span class="s1">np.array_equiv(clusters_produced</span><span class="s3">, </span><span class="s1">clusters_at_threshold)</span>


<span class="s3">def </span><span class="s1">test_small_distance_threshold(global_random_seed):</span>
    <span class="s1">rng = np.random.RandomState(global_random_seed)</span>
    <span class="s1">n_samples = </span><span class="s4">10</span>
    <span class="s1">X = rng.randint(-</span><span class="s4">300</span><span class="s3">, </span><span class="s4">300</span><span class="s3">, </span><span class="s1">size=(n_samples</span><span class="s3">, </span><span class="s4">3</span><span class="s1">))</span>
    <span class="s2"># this should result in all data in their own clusters, given that</span>
    <span class="s2"># their pairwise distances are bigger than .1 (which may not be the case</span>
    <span class="s2"># with a different random seed).</span>
    <span class="s1">clustering = AgglomerativeClustering(</span>
        <span class="s1">n_clusters=</span><span class="s3">None, </span><span class="s1">distance_threshold=</span><span class="s4">1.0</span><span class="s3">, </span><span class="s1">linkage=</span><span class="s5">&quot;single&quot;</span>
    <span class="s1">).fit(X)</span>
    <span class="s2"># check that the pairwise distances are indeed all larger than .1</span>
    <span class="s1">all_distances = pairwise_distances(X</span><span class="s3">, </span><span class="s1">metric=</span><span class="s5">&quot;minkowski&quot;</span><span class="s3">, </span><span class="s1">p=</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">np.fill_diagonal(all_distances</span><span class="s3">, </span><span class="s1">np.inf)</span>
    <span class="s3">assert </span><span class="s1">np.all(all_distances &gt; </span><span class="s4">0.1</span><span class="s1">)</span>
    <span class="s3">assert </span><span class="s1">clustering.n_clusters_ == n_samples</span>


<span class="s3">def </span><span class="s1">test_cluster_distances_with_distance_threshold(global_random_seed):</span>
    <span class="s1">rng = np.random.RandomState(global_random_seed)</span>
    <span class="s1">n_samples = </span><span class="s4">100</span>
    <span class="s1">X = rng.randint(-</span><span class="s4">10</span><span class="s3">, </span><span class="s4">10</span><span class="s3">, </span><span class="s1">size=(n_samples</span><span class="s3">, </span><span class="s4">3</span><span class="s1">))</span>
    <span class="s2"># check the distances within the clusters and with other clusters</span>
    <span class="s1">distance_threshold = </span><span class="s4">4</span>
    <span class="s1">clustering = AgglomerativeClustering(</span>
        <span class="s1">n_clusters=</span><span class="s3">None, </span><span class="s1">distance_threshold=distance_threshold</span><span class="s3">, </span><span class="s1">linkage=</span><span class="s5">&quot;single&quot;</span>
    <span class="s1">).fit(X)</span>
    <span class="s1">labels = clustering.labels_</span>
    <span class="s1">D = pairwise_distances(X</span><span class="s3">, </span><span class="s1">metric=</span><span class="s5">&quot;minkowski&quot;</span><span class="s3">, </span><span class="s1">p=</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s2"># to avoid taking the 0 diagonal in min()</span>
    <span class="s1">np.fill_diagonal(D</span><span class="s3">, </span><span class="s1">np.inf)</span>
    <span class="s3">for </span><span class="s1">label </span><span class="s3">in </span><span class="s1">np.unique(labels):</span>
        <span class="s1">in_cluster_mask = labels == label</span>
        <span class="s1">max_in_cluster_distance = (</span>
            <span class="s1">D[in_cluster_mask][:</span><span class="s3">, </span><span class="s1">in_cluster_mask].min(axis=</span><span class="s4">0</span><span class="s1">).max()</span>
        <span class="s1">)</span>
        <span class="s1">min_out_cluster_distance = (</span>
            <span class="s1">D[in_cluster_mask][:</span><span class="s3">, </span><span class="s1">~in_cluster_mask].min(axis=</span><span class="s4">0</span><span class="s1">).min()</span>
        <span class="s1">)</span>
        <span class="s2"># single data point clusters only have that inf diagonal here</span>
        <span class="s3">if </span><span class="s1">in_cluster_mask.sum() &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s3">assert </span><span class="s1">max_in_cluster_distance &lt; distance_threshold</span>
        <span class="s3">assert </span><span class="s1">min_out_cluster_distance &gt;= distance_threshold</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;linkage&quot;</span><span class="s3">, </span><span class="s1">[</span><span class="s5">&quot;ward&quot;</span><span class="s3">, </span><span class="s5">&quot;complete&quot;</span><span class="s3">, </span><span class="s5">&quot;average&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s1">(</span><span class="s5">&quot;threshold&quot;</span><span class="s3">, </span><span class="s5">&quot;y_true&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[(</span><span class="s4">0.5</span><span class="s3">, </span><span class="s1">[</span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s1">])</span><span class="s3">, </span><span class="s1">(</span><span class="s4">1.0</span><span class="s3">, </span><span class="s1">[</span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s1">])</span><span class="s3">, </span><span class="s1">(</span><span class="s4">1.5</span><span class="s3">, </span><span class="s1">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">])]</span>
<span class="s1">)</span>
<span class="s3">def </span><span class="s1">test_agglomerative_clustering_with_distance_threshold_edge_case(</span>
    <span class="s1">linkage</span><span class="s3">, </span><span class="s1">threshold</span><span class="s3">, </span><span class="s1">y_true</span>
<span class="s1">):</span>
    <span class="s2"># test boundary case of distance_threshold matching the distance</span>
    <span class="s1">X = [[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">]]</span>
    <span class="s1">clusterer = AgglomerativeClustering(</span>
        <span class="s1">n_clusters=</span><span class="s3">None, </span><span class="s1">distance_threshold=threshold</span><span class="s3">, </span><span class="s1">linkage=linkage</span>
    <span class="s1">)</span>
    <span class="s1">y_pred = clusterer.fit_predict(X)</span>
    <span class="s3">assert </span><span class="s1">adjusted_rand_score(y_true</span><span class="s3">, </span><span class="s1">y_pred) == </span><span class="s4">1</span>


<span class="s3">def </span><span class="s1">test_dist_threshold_invalid_parameters():</span>
    <span class="s1">X = [[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">]]</span>
    <span class="s3">with </span><span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">match=</span><span class="s5">&quot;Exactly one of &quot;</span><span class="s1">):</span>
        <span class="s1">AgglomerativeClustering(n_clusters=</span><span class="s3">None, </span><span class="s1">distance_threshold=</span><span class="s3">None</span><span class="s1">).fit(X)</span>

    <span class="s3">with </span><span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">match=</span><span class="s5">&quot;Exactly one of &quot;</span><span class="s1">):</span>
        <span class="s1">AgglomerativeClustering(n_clusters=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">distance_threshold=</span><span class="s4">1</span><span class="s1">).fit(X)</span>

    <span class="s1">X = [[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">]]</span>
    <span class="s3">with </span><span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">match=</span><span class="s5">&quot;compute_full_tree must be True if&quot;</span><span class="s1">):</span>
        <span class="s1">AgglomerativeClustering(</span>
            <span class="s1">n_clusters=</span><span class="s3">None, </span><span class="s1">distance_threshold=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">compute_full_tree=</span><span class="s3">False</span>
        <span class="s1">).fit(X)</span>


<span class="s3">def </span><span class="s1">test_invalid_shape_precomputed_dist_matrix():</span>
    <span class="s2"># Check that an error is raised when affinity='precomputed'</span>
    <span class="s2"># and a non square matrix is passed (PR #16257).</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">X = rng.rand(</span><span class="s4">5</span><span class="s3">, </span><span class="s4">3</span><span class="s1">)</span>
    <span class="s3">with </span><span class="s1">pytest.raises(</span>
        <span class="s1">ValueError</span><span class="s3">,</span>
        <span class="s1">match=</span><span class="s5">r&quot;Distance matrix should be square, got matrix of shape \(5, 3\)&quot;</span><span class="s3">,</span>
    <span class="s1">):</span>
        <span class="s1">AgglomerativeClustering(metric=</span><span class="s5">&quot;precomputed&quot;</span><span class="s3">, </span><span class="s1">linkage=</span><span class="s5">&quot;complete&quot;</span><span class="s1">).fit(X)</span>


<span class="s3">def </span><span class="s1">test_precomputed_connectivity_affinity_with_2_connected_components():</span>
    <span class="s0">&quot;&quot;&quot;Check that connecting components works when connectivity and 
    affinity are both precomputed and the number of connected components is 
    greater than 1. Non-regression test for #16151. 
    &quot;&quot;&quot;</span>

    <span class="s1">connectivity_matrix = np.array(</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">]</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">]</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">]</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s1">]</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s2"># ensure that connectivity_matrix has two connected components</span>
    <span class="s3">assert </span><span class="s1">connected_components(connectivity_matrix)[</span><span class="s4">0</span><span class="s1">] == </span><span class="s4">2</span>

    <span class="s1">rng = np.random.RandomState(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">X = rng.randn(</span><span class="s4">5</span><span class="s3">, </span><span class="s4">10</span><span class="s1">)</span>

    <span class="s1">X_dist = pairwise_distances(X)</span>
    <span class="s1">clusterer_precomputed = AgglomerativeClustering(</span>
        <span class="s1">affinity=</span><span class="s5">&quot;precomputed&quot;</span><span class="s3">, </span><span class="s1">connectivity=connectivity_matrix</span><span class="s3">, </span><span class="s1">linkage=</span><span class="s5">&quot;complete&quot;</span>
    <span class="s1">)</span>
    <span class="s1">msg = </span><span class="s5">&quot;Completing it to avoid stopping the tree early&quot;</span>
    <span class="s3">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s3">, </span><span class="s1">match=msg):</span>
        <span class="s1">clusterer_precomputed.fit(X_dist)</span>

    <span class="s1">clusterer = AgglomerativeClustering(</span>
        <span class="s1">connectivity=connectivity_matrix</span><span class="s3">, </span><span class="s1">linkage=</span><span class="s5">&quot;complete&quot;</span>
    <span class="s1">)</span>
    <span class="s3">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s3">, </span><span class="s1">match=msg):</span>
        <span class="s1">clusterer.fit(X)</span>

    <span class="s1">assert_array_equal(clusterer.labels_</span><span class="s3">, </span><span class="s1">clusterer_precomputed.labels_)</span>
    <span class="s1">assert_array_equal(clusterer.children_</span><span class="s3">, </span><span class="s1">clusterer_precomputed.children_)</span>


<span class="s2"># TODO(1.4): Remove</span>
<span class="s3">def </span><span class="s1">test_deprecate_affinity():</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s4">42</span><span class="s1">)</span>
    <span class="s1">X = rng.randn(</span><span class="s4">50</span><span class="s3">, </span><span class="s4">10</span><span class="s1">)</span>

    <span class="s1">af = AgglomerativeClustering(affinity=</span><span class="s5">&quot;euclidean&quot;</span><span class="s1">)</span>
    <span class="s1">msg = (</span>
        <span class="s5">&quot;Attribute `affinity` was deprecated in version 1.2 and will be removed in 1.4.&quot;</span>
        <span class="s5">&quot; Use `metric` instead&quot;</span>
    <span class="s1">)</span>
    <span class="s3">with </span><span class="s1">pytest.warns(FutureWarning</span><span class="s3">, </span><span class="s1">match=msg):</span>
        <span class="s1">af.fit(X)</span>
    <span class="s3">with </span><span class="s1">pytest.warns(FutureWarning</span><span class="s3">, </span><span class="s1">match=msg):</span>
        <span class="s1">af.fit_predict(X)</span>

    <span class="s1">af = AgglomerativeClustering(metric=</span><span class="s5">&quot;euclidean&quot;</span><span class="s3">, </span><span class="s1">affinity=</span><span class="s5">&quot;euclidean&quot;</span><span class="s1">)</span>
    <span class="s1">msg = </span><span class="s5">&quot;Both `affinity` and `metric` attributes were set. Attribute&quot;</span>
    <span class="s3">with </span><span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">match=msg):</span>
        <span class="s1">af.fit(X)</span>
    <span class="s3">with </span><span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">match=msg):</span>
        <span class="s1">af.fit_predict(X)</span>
</pre>
</body>
</html>