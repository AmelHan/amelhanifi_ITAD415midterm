<html>
<head>
<title>_ufuncs.pyx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_ufuncs.pyx</font>
</center></td></tr></table>
<pre><span class="s0"># This file is automatically generated by _generate_pyx.py.</span>
<span class="s0"># Do not edit manually!</span>

<span class="s0">from libc.math cimport NAN</span>

<span class="s0">include &quot;_ufuncs_extra_code_common.pxi&quot;</span>
<span class="s0">include &quot;_ufuncs_extra_code.pxi&quot;</span>
<span class="s0">__all__ = ['agm', 'airy', 'airye', 'bdtr', 'bdtrc', 'bdtri', 'bdtrik', 'bdtrin', 'bei', 'beip', 'ber', 'berp', 'besselpoly', 'beta', 'betainc', 'betaincinv', 'betaln', 'binom', 'boxcox', 'boxcox1p', 'btdtr', 'btdtri', 'btdtria', 'btdtrib', 'cbrt', 'chdtr', 'chdtrc', 'chdtri', 'chdtriv', 'chndtr', 'chndtridf', 'chndtrinc', 'chndtrix', 'cosdg', 'cosm1', 'cotdg', 'dawsn', 'ellipe', 'ellipeinc', 'ellipj', 'ellipk', 'ellipkinc', 'ellipkm1', 'elliprc', 'elliprd', 'elliprf', 'elliprg', 'elliprj', 'entr', 'erf', 'erfc', 'erfcinv', 'erfcx', 'erfi', 'erfinv', 'eval_chebyc', 'eval_chebys', 'eval_chebyt', 'eval_chebyu', 'eval_gegenbauer', 'eval_genlaguerre', 'eval_hermite', 'eval_hermitenorm', 'eval_jacobi', 'eval_laguerre', 'eval_legendre', 'eval_sh_chebyt', 'eval_sh_chebyu', 'eval_sh_jacobi', 'eval_sh_legendre', 'exp1', 'exp10', 'exp2', 'expi', 'expit', 'expm1', 'expn', 'exprel', 'fdtr', 'fdtrc', 'fdtri', 'fdtridfd', 'fresnel', 'gamma', 'gammainc', 'gammaincc', 'gammainccinv', 'gammaincinv', 'gammaln', 'gammasgn', 'gdtr', 'gdtrc', 'gdtria', 'gdtrib', 'gdtrix', 'hankel1', 'hankel1e', 'hankel2', 'hankel2e', 'huber', 'hyp0f1', 'hyp1f1', 'hyp2f1', 'hyperu', 'i0', 'i0e', 'i1', 'i1e', 'inv_boxcox', 'inv_boxcox1p', 'it2i0k0', 'it2j0y0', 'it2struve0', 'itairy', 'iti0k0', 'itj0y0', 'itmodstruve0', 'itstruve0', 'iv', 'ive', 'j0', 'j1', 'jv', 'jve', 'k0', 'k0e', 'k1', 'k1e', 'kei', 'keip', 'kelvin', 'ker', 'kerp', 'kl_div', 'kn', 'kolmogi', 'kolmogorov', 'kv', 'kve', 'log1p', 'log_expit', 'log_ndtr', 'loggamma', 'logit', 'lpmv', 'mathieu_a', 'mathieu_b', 'mathieu_cem', 'mathieu_modcem1', 'mathieu_modcem2', 'mathieu_modsem1', 'mathieu_modsem2', 'mathieu_sem', 'modfresnelm', 'modfresnelp', 'modstruve', 'nbdtr', 'nbdtrc', 'nbdtri', 'nbdtrik', 'nbdtrin', 'ncfdtr', 'ncfdtri', 'ncfdtridfd', 'ncfdtridfn', 'ncfdtrinc', 'nctdtr', 'nctdtridf', 'nctdtrinc', 'nctdtrit', 'ndtr', 'ndtri', 'ndtri_exp', 'nrdtrimn', 'nrdtrisd', 'obl_ang1', 'obl_ang1_cv', 'obl_cv', 'obl_rad1', 'obl_rad1_cv', 'obl_rad2', 'obl_rad2_cv', 'owens_t', 'pbdv', 'pbvv', 'pbwa', 'pdtr', 'pdtrc', 'pdtri', 'pdtrik', 'poch', 'powm1', 'pro_ang1', 'pro_ang1_cv', 'pro_cv', 'pro_rad1', 'pro_rad1_cv', 'pro_rad2', 'pro_rad2_cv', 'pseudo_huber', 'psi', 'radian', 'rel_entr', 'rgamma', 'round', 'shichi', 'sici', 'sindg', 'smirnov', 'smirnovi', 'spence', 'sph_harm', 'stdtr', 'stdtridf', 'stdtrit', 'struve', 'tandg', 'tklmbda', 'voigt_profile', 'wofz', 'wright_bessel', 'wrightomega', 'xlog1py', 'xlogy', 'y0', 'y1', 'yn', 'yv', 'yve', 'zetac', 'geterr', 'seterr', 'errstate', 'jn']</span>
<span class="s0">cdef void loop_D_DDDD__As_DDDD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *ip3 = args[3]</span>
    <span class="s0">cdef char *op0 = args[4]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double complex(*)(double complex, double complex, double complex, double complex) noexcept nogil&gt;func)(&lt;double complex&gt;(&lt;double complex*&gt;ip0)[0], &lt;double complex&gt;(&lt;double complex*&gt;ip1)[0], &lt;double complex&gt;(&lt;double complex*&gt;ip2)[0], &lt;double complex&gt;(&lt;double complex*&gt;ip3)[0])</span>
        <span class="s0">(&lt;double complex *&gt;op0)[0] = &lt;double complex&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">ip3 += steps[3]</span>
        <span class="s0">op0 += steps[4]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_D_DDDD__As_FFFF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *ip3 = args[3]</span>
    <span class="s0">cdef char *op0 = args[4]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double complex(*)(double complex, double complex, double complex, double complex) noexcept nogil&gt;func)(&lt;double complex&gt;(&lt;float complex*&gt;ip0)[0], &lt;double complex&gt;(&lt;float complex*&gt;ip1)[0], &lt;double complex&gt;(&lt;float complex*&gt;ip2)[0], &lt;double complex&gt;(&lt;float complex*&gt;ip3)[0])</span>
        <span class="s0">(&lt;float complex *&gt;op0)[0] = &lt;float complex&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">ip3 += steps[3]</span>
        <span class="s0">op0 += steps[4]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_D_DDD__As_DDD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *op0 = args[3]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double complex(*)(double complex, double complex, double complex) noexcept nogil&gt;func)(&lt;double complex&gt;(&lt;double complex*&gt;ip0)[0], &lt;double complex&gt;(&lt;double complex*&gt;ip1)[0], &lt;double complex&gt;(&lt;double complex*&gt;ip2)[0])</span>
        <span class="s0">(&lt;double complex *&gt;op0)[0] = &lt;double complex&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">op0 += steps[3]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_D_DDD__As_FFF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *op0 = args[3]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double complex(*)(double complex, double complex, double complex) noexcept nogil&gt;func)(&lt;double complex&gt;(&lt;float complex*&gt;ip0)[0], &lt;double complex&gt;(&lt;float complex*&gt;ip1)[0], &lt;double complex&gt;(&lt;float complex*&gt;ip2)[0])</span>
        <span class="s0">(&lt;float complex *&gt;op0)[0] = &lt;float complex&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">op0 += steps[3]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_D_DD__As_DD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *op0 = args[2]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double complex(*)(double complex, double complex) noexcept nogil&gt;func)(&lt;double complex&gt;(&lt;double complex*&gt;ip0)[0], &lt;double complex&gt;(&lt;double complex*&gt;ip1)[0])</span>
        <span class="s0">(&lt;double complex *&gt;op0)[0] = &lt;double complex&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">op0 += steps[2]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_D_DD__As_FF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *op0 = args[2]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double complex(*)(double complex, double complex) noexcept nogil&gt;func)(&lt;double complex&gt;(&lt;float complex*&gt;ip0)[0], &lt;double complex&gt;(&lt;float complex*&gt;ip1)[0])</span>
        <span class="s0">(&lt;float complex *&gt;op0)[0] = &lt;float complex&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">op0 += steps[2]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_D_D__As_D_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *op0 = args[1]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double complex(*)(double complex) noexcept nogil&gt;func)(&lt;double complex&gt;(&lt;double complex*&gt;ip0)[0])</span>
        <span class="s0">(&lt;double complex *&gt;op0)[0] = &lt;double complex&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">op0 += steps[1]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_D_D__As_F_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *op0 = args[1]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double complex(*)(double complex) noexcept nogil&gt;func)(&lt;double complex&gt;(&lt;float complex*&gt;ip0)[0])</span>
        <span class="s0">(&lt;float complex *&gt;op0)[0] = &lt;float complex&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">op0 += steps[1]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_D_Dld__As_Dld_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *op0 = args[3]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double complex(*)(double complex, long, double) noexcept nogil&gt;func)(&lt;double complex&gt;(&lt;double complex*&gt;ip0)[0], &lt;long&gt;(&lt;long*&gt;ip1)[0], &lt;double&gt;(&lt;double*&gt;ip2)[0])</span>
        <span class="s0">(&lt;double complex *&gt;op0)[0] = &lt;double complex&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">op0 += steps[3]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_D_dD__As_dD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *op0 = args[2]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double complex(*)(double, double complex) noexcept nogil&gt;func)(&lt;double&gt;(&lt;double*&gt;ip0)[0], &lt;double complex&gt;(&lt;double complex*&gt;ip1)[0])</span>
        <span class="s0">(&lt;double complex *&gt;op0)[0] = &lt;double complex&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">op0 += steps[2]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_D_dD__As_fF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *op0 = args[2]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double complex(*)(double, double complex) noexcept nogil&gt;func)(&lt;double&gt;(&lt;float*&gt;ip0)[0], &lt;double complex&gt;(&lt;float complex*&gt;ip1)[0])</span>
        <span class="s0">(&lt;float complex *&gt;op0)[0] = &lt;float complex&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">op0 += steps[2]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_D_ddD__As_ddD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *op0 = args[3]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double complex(*)(double, double, double complex) noexcept nogil&gt;func)(&lt;double&gt;(&lt;double*&gt;ip0)[0], &lt;double&gt;(&lt;double*&gt;ip1)[0], &lt;double complex&gt;(&lt;double complex*&gt;ip2)[0])</span>
        <span class="s0">(&lt;double complex *&gt;op0)[0] = &lt;double complex&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">op0 += steps[3]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_D_ddD__As_ffF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *op0 = args[3]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double complex(*)(double, double, double complex) noexcept nogil&gt;func)(&lt;double&gt;(&lt;float*&gt;ip0)[0], &lt;double&gt;(&lt;float*&gt;ip1)[0], &lt;double complex&gt;(&lt;float complex*&gt;ip2)[0])</span>
        <span class="s0">(&lt;float complex *&gt;op0)[0] = &lt;float complex&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">op0 += steps[3]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_D_dddD__As_dddD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *ip3 = args[3]</span>
    <span class="s0">cdef char *op0 = args[4]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double complex(*)(double, double, double, double complex) noexcept nogil&gt;func)(&lt;double&gt;(&lt;double*&gt;ip0)[0], &lt;double&gt;(&lt;double*&gt;ip1)[0], &lt;double&gt;(&lt;double*&gt;ip2)[0], &lt;double complex&gt;(&lt;double complex*&gt;ip3)[0])</span>
        <span class="s0">(&lt;double complex *&gt;op0)[0] = &lt;double complex&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">ip3 += steps[3]</span>
        <span class="s0">op0 += steps[4]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_D_dddD__As_fffF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *ip3 = args[3]</span>
    <span class="s0">cdef char *op0 = args[4]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double complex(*)(double, double, double, double complex) noexcept nogil&gt;func)(&lt;double&gt;(&lt;float*&gt;ip0)[0], &lt;double&gt;(&lt;float*&gt;ip1)[0], &lt;double&gt;(&lt;float*&gt;ip2)[0], &lt;double complex&gt;(&lt;float complex*&gt;ip3)[0])</span>
        <span class="s0">(&lt;float complex *&gt;op0)[0] = &lt;float complex&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">ip3 += steps[3]</span>
        <span class="s0">op0 += steps[4]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_D_dddd__As_dddd_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *ip3 = args[3]</span>
    <span class="s0">cdef char *op0 = args[4]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double complex(*)(double, double, double, double) noexcept nogil&gt;func)(&lt;double&gt;(&lt;double*&gt;ip0)[0], &lt;double&gt;(&lt;double*&gt;ip1)[0], &lt;double&gt;(&lt;double*&gt;ip2)[0], &lt;double&gt;(&lt;double*&gt;ip3)[0])</span>
        <span class="s0">(&lt;double complex *&gt;op0)[0] = &lt;double complex&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">ip3 += steps[3]</span>
        <span class="s0">op0 += steps[4]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_D_dddd__As_ffff_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *ip3 = args[3]</span>
    <span class="s0">cdef char *op0 = args[4]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double complex(*)(double, double, double, double) noexcept nogil&gt;func)(&lt;double&gt;(&lt;float*&gt;ip0)[0], &lt;double&gt;(&lt;float*&gt;ip1)[0], &lt;double&gt;(&lt;float*&gt;ip2)[0], &lt;double&gt;(&lt;float*&gt;ip3)[0])</span>
        <span class="s0">(&lt;float complex *&gt;op0)[0] = &lt;float complex&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">ip3 += steps[3]</span>
        <span class="s0">op0 += steps[4]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_D_iidd__As_lldd_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *ip3 = args[3]</span>
    <span class="s0">cdef char *op0 = args[4]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">if &lt;int&gt;(&lt;long*&gt;ip0)[0] == (&lt;long*&gt;ip0)[0] and &lt;int&gt;(&lt;long*&gt;ip1)[0] == (&lt;long*&gt;ip1)[0]:</span>
            <span class="s0">ov0 = (&lt;double complex(*)(int, int, double, double) noexcept nogil&gt;func)(&lt;int&gt;(&lt;long*&gt;ip0)[0], &lt;int&gt;(&lt;long*&gt;ip1)[0], &lt;double&gt;(&lt;double*&gt;ip2)[0], &lt;double&gt;(&lt;double*&gt;ip3)[0])</span>
        <span class="s0">else:</span>
            <span class="s0">sf_error.error(func_name, sf_error.DOMAIN, &quot;invalid input argument&quot;)</span>
            <span class="s0">ov0 = &lt;double complex&gt;NAN</span>
        <span class="s0">(&lt;double complex *&gt;op0)[0] = &lt;double complex&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">ip3 += steps[3]</span>
        <span class="s0">op0 += steps[4]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_D_lD__As_lD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *op0 = args[2]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double complex(*)(long, double complex) noexcept nogil&gt;func)(&lt;long&gt;(&lt;long*&gt;ip0)[0], &lt;double complex&gt;(&lt;double complex*&gt;ip1)[0])</span>
        <span class="s0">(&lt;double complex *&gt;op0)[0] = &lt;double complex&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">op0 += steps[2]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_d__As_d_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *op0 = args[1]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double(*)(double) noexcept nogil&gt;func)(&lt;double&gt;(&lt;double*&gt;ip0)[0])</span>
        <span class="s0">(&lt;double *&gt;op0)[0] = &lt;double&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">op0 += steps[1]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_d__As_f_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *op0 = args[1]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double(*)(double) noexcept nogil&gt;func)(&lt;double&gt;(&lt;float*&gt;ip0)[0])</span>
        <span class="s0">(&lt;float *&gt;op0)[0] = &lt;float&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">op0 += steps[1]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_dd__As_dd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *op0 = args[2]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double(*)(double, double) noexcept nogil&gt;func)(&lt;double&gt;(&lt;double*&gt;ip0)[0], &lt;double&gt;(&lt;double*&gt;ip1)[0])</span>
        <span class="s0">(&lt;double *&gt;op0)[0] = &lt;double&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">op0 += steps[2]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_dd__As_ff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *op0 = args[2]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double(*)(double, double) noexcept nogil&gt;func)(&lt;double&gt;(&lt;float*&gt;ip0)[0], &lt;double&gt;(&lt;float*&gt;ip1)[0])</span>
        <span class="s0">(&lt;float *&gt;op0)[0] = &lt;float&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">op0 += steps[2]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_ddd__As_ddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *op0 = args[3]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double(*)(double, double, double) noexcept nogil&gt;func)(&lt;double&gt;(&lt;double*&gt;ip0)[0], &lt;double&gt;(&lt;double*&gt;ip1)[0], &lt;double&gt;(&lt;double*&gt;ip2)[0])</span>
        <span class="s0">(&lt;double *&gt;op0)[0] = &lt;double&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">op0 += steps[3]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_ddd__As_fff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *op0 = args[3]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double(*)(double, double, double) noexcept nogil&gt;func)(&lt;double&gt;(&lt;float*&gt;ip0)[0], &lt;double&gt;(&lt;float*&gt;ip1)[0], &lt;double&gt;(&lt;float*&gt;ip2)[0])</span>
        <span class="s0">(&lt;float *&gt;op0)[0] = &lt;float&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">op0 += steps[3]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_dddd__As_dddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *ip3 = args[3]</span>
    <span class="s0">cdef char *op0 = args[4]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double(*)(double, double, double, double) noexcept nogil&gt;func)(&lt;double&gt;(&lt;double*&gt;ip0)[0], &lt;double&gt;(&lt;double*&gt;ip1)[0], &lt;double&gt;(&lt;double*&gt;ip2)[0], &lt;double&gt;(&lt;double*&gt;ip3)[0])</span>
        <span class="s0">(&lt;double *&gt;op0)[0] = &lt;double&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">ip3 += steps[3]</span>
        <span class="s0">op0 += steps[4]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_dddd__As_ffff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *ip3 = args[3]</span>
    <span class="s0">cdef char *op0 = args[4]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double(*)(double, double, double, double) noexcept nogil&gt;func)(&lt;double&gt;(&lt;float*&gt;ip0)[0], &lt;double&gt;(&lt;float*&gt;ip1)[0], &lt;double&gt;(&lt;float*&gt;ip2)[0], &lt;double&gt;(&lt;float*&gt;ip3)[0])</span>
        <span class="s0">(&lt;float *&gt;op0)[0] = &lt;float&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">ip3 += steps[3]</span>
        <span class="s0">op0 += steps[4]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_dddd_d_As_dddd_dd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *ip3 = args[3]</span>
    <span class="s0">cdef char *op0 = args[4]</span>
    <span class="s0">cdef char *op1 = args[5]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">cdef double ov1</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double(*)(double, double, double, double, double *) noexcept nogil&gt;func)(&lt;double&gt;(&lt;double*&gt;ip0)[0], &lt;double&gt;(&lt;double*&gt;ip1)[0], &lt;double&gt;(&lt;double*&gt;ip2)[0], &lt;double&gt;(&lt;double*&gt;ip3)[0], &amp;ov1)</span>
        <span class="s0">(&lt;double *&gt;op0)[0] = &lt;double&gt;ov0</span>
        <span class="s0">(&lt;double *&gt;op1)[0] = &lt;double&gt;ov1</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">ip3 += steps[3]</span>
        <span class="s0">op0 += steps[4]</span>
        <span class="s0">op1 += steps[5]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_dddd_d_As_ffff_ff(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *ip3 = args[3]</span>
    <span class="s0">cdef char *op0 = args[4]</span>
    <span class="s0">cdef char *op1 = args[5]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">cdef double ov1</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double(*)(double, double, double, double, double *) noexcept nogil&gt;func)(&lt;double&gt;(&lt;float*&gt;ip0)[0], &lt;double&gt;(&lt;float*&gt;ip1)[0], &lt;double&gt;(&lt;float*&gt;ip2)[0], &lt;double&gt;(&lt;float*&gt;ip3)[0], &amp;ov1)</span>
        <span class="s0">(&lt;float *&gt;op0)[0] = &lt;float&gt;ov0</span>
        <span class="s0">(&lt;float *&gt;op1)[0] = &lt;float&gt;ov1</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">ip3 += steps[3]</span>
        <span class="s0">op0 += steps[4]</span>
        <span class="s0">op1 += steps[5]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_ddddddd__As_ddddddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *ip3 = args[3]</span>
    <span class="s0">cdef char *ip4 = args[4]</span>
    <span class="s0">cdef char *ip5 = args[5]</span>
    <span class="s0">cdef char *ip6 = args[6]</span>
    <span class="s0">cdef char *op0 = args[7]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double(*)(double, double, double, double, double, double, double) noexcept nogil&gt;func)(&lt;double&gt;(&lt;double*&gt;ip0)[0], &lt;double&gt;(&lt;double*&gt;ip1)[0], &lt;double&gt;(&lt;double*&gt;ip2)[0], &lt;double&gt;(&lt;double*&gt;ip3)[0], &lt;double&gt;(&lt;double*&gt;ip4)[0], &lt;double&gt;(&lt;double*&gt;ip5)[0], &lt;double&gt;(&lt;double*&gt;ip6)[0])</span>
        <span class="s0">(&lt;double *&gt;op0)[0] = &lt;double&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">ip3 += steps[3]</span>
        <span class="s0">ip4 += steps[4]</span>
        <span class="s0">ip5 += steps[5]</span>
        <span class="s0">ip6 += steps[6]</span>
        <span class="s0">op0 += steps[7]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_ddddddd__As_fffffff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *ip3 = args[3]</span>
    <span class="s0">cdef char *ip4 = args[4]</span>
    <span class="s0">cdef char *ip5 = args[5]</span>
    <span class="s0">cdef char *ip6 = args[6]</span>
    <span class="s0">cdef char *op0 = args[7]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double(*)(double, double, double, double, double, double, double) noexcept nogil&gt;func)(&lt;double&gt;(&lt;float*&gt;ip0)[0], &lt;double&gt;(&lt;float*&gt;ip1)[0], &lt;double&gt;(&lt;float*&gt;ip2)[0], &lt;double&gt;(&lt;float*&gt;ip3)[0], &lt;double&gt;(&lt;float*&gt;ip4)[0], &lt;double&gt;(&lt;float*&gt;ip5)[0], &lt;double&gt;(&lt;float*&gt;ip6)[0])</span>
        <span class="s0">(&lt;float *&gt;op0)[0] = &lt;float&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">ip3 += steps[3]</span>
        <span class="s0">ip4 += steps[4]</span>
        <span class="s0">ip5 += steps[5]</span>
        <span class="s0">ip6 += steps[6]</span>
        <span class="s0">op0 += steps[7]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_ddi_d_As_ddl_dd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *op0 = args[3]</span>
    <span class="s0">cdef char *op1 = args[4]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">cdef double ov1</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">if &lt;int&gt;(&lt;long*&gt;ip2)[0] == (&lt;long*&gt;ip2)[0]:</span>
            <span class="s0">ov0 = (&lt;double(*)(double, double, int, double *) noexcept nogil&gt;func)(&lt;double&gt;(&lt;double*&gt;ip0)[0], &lt;double&gt;(&lt;double*&gt;ip1)[0], &lt;int&gt;(&lt;long*&gt;ip2)[0], &amp;ov1)</span>
        <span class="s0">else:</span>
            <span class="s0">sf_error.error(func_name, sf_error.DOMAIN, &quot;invalid input argument&quot;)</span>
            <span class="s0">ov0 = &lt;double&gt;NAN</span>
            <span class="s0">ov1 = &lt;double&gt;NAN</span>
        <span class="s0">(&lt;double *&gt;op0)[0] = &lt;double&gt;ov0</span>
        <span class="s0">(&lt;double *&gt;op1)[0] = &lt;double&gt;ov1</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">op0 += steps[3]</span>
        <span class="s0">op1 += steps[4]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_ddiiddd__As_ddllddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *ip3 = args[3]</span>
    <span class="s0">cdef char *ip4 = args[4]</span>
    <span class="s0">cdef char *ip5 = args[5]</span>
    <span class="s0">cdef char *ip6 = args[6]</span>
    <span class="s0">cdef char *op0 = args[7]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">if &lt;int&gt;(&lt;long*&gt;ip2)[0] == (&lt;long*&gt;ip2)[0] and &lt;int&gt;(&lt;long*&gt;ip3)[0] == (&lt;long*&gt;ip3)[0]:</span>
            <span class="s0">ov0 = (&lt;double(*)(double, double, int, int, double, double, double) noexcept nogil&gt;func)(&lt;double&gt;(&lt;double*&gt;ip0)[0], &lt;double&gt;(&lt;double*&gt;ip1)[0], &lt;int&gt;(&lt;long*&gt;ip2)[0], &lt;int&gt;(&lt;long*&gt;ip3)[0], &lt;double&gt;(&lt;double*&gt;ip4)[0], &lt;double&gt;(&lt;double*&gt;ip5)[0], &lt;double&gt;(&lt;double*&gt;ip6)[0])</span>
        <span class="s0">else:</span>
            <span class="s0">sf_error.error(func_name, sf_error.DOMAIN, &quot;invalid input argument&quot;)</span>
            <span class="s0">ov0 = &lt;double&gt;NAN</span>
        <span class="s0">(&lt;double *&gt;op0)[0] = &lt;double&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">ip3 += steps[3]</span>
        <span class="s0">ip4 += steps[4]</span>
        <span class="s0">ip5 += steps[5]</span>
        <span class="s0">ip6 += steps[6]</span>
        <span class="s0">op0 += steps[7]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_did__As_dld_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *op0 = args[3]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">if &lt;int&gt;(&lt;long*&gt;ip1)[0] == (&lt;long*&gt;ip1)[0]:</span>
            <span class="s0">ov0 = (&lt;double(*)(double, int, double) noexcept nogil&gt;func)(&lt;double&gt;(&lt;double*&gt;ip0)[0], &lt;int&gt;(&lt;long*&gt;ip1)[0], &lt;double&gt;(&lt;double*&gt;ip2)[0])</span>
        <span class="s0">else:</span>
            <span class="s0">sf_error.error(func_name, sf_error.DOMAIN, &quot;invalid input argument&quot;)</span>
            <span class="s0">ov0 = &lt;double&gt;NAN</span>
        <span class="s0">(&lt;double *&gt;op0)[0] = &lt;double&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">op0 += steps[3]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_id__As_ld_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *op0 = args[2]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">if &lt;int&gt;(&lt;long*&gt;ip0)[0] == (&lt;long*&gt;ip0)[0]:</span>
            <span class="s0">ov0 = (&lt;double(*)(int, double) noexcept nogil&gt;func)(&lt;int&gt;(&lt;long*&gt;ip0)[0], &lt;double&gt;(&lt;double*&gt;ip1)[0])</span>
        <span class="s0">else:</span>
            <span class="s0">sf_error.error(func_name, sf_error.DOMAIN, &quot;invalid input argument&quot;)</span>
            <span class="s0">ov0 = &lt;double&gt;NAN</span>
        <span class="s0">(&lt;double *&gt;op0)[0] = &lt;double&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">op0 += steps[2]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_iid__As_lld_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *op0 = args[3]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">if &lt;int&gt;(&lt;long*&gt;ip0)[0] == (&lt;long*&gt;ip0)[0] and &lt;int&gt;(&lt;long*&gt;ip1)[0] == (&lt;long*&gt;ip1)[0]:</span>
            <span class="s0">ov0 = (&lt;double(*)(int, int, double) noexcept nogil&gt;func)(&lt;int&gt;(&lt;long*&gt;ip0)[0], &lt;int&gt;(&lt;long*&gt;ip1)[0], &lt;double&gt;(&lt;double*&gt;ip2)[0])</span>
        <span class="s0">else:</span>
            <span class="s0">sf_error.error(func_name, sf_error.DOMAIN, &quot;invalid input argument&quot;)</span>
            <span class="s0">ov0 = &lt;double&gt;NAN</span>
        <span class="s0">(&lt;double *&gt;op0)[0] = &lt;double&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">op0 += steps[3]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_ld__As_ld_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *op0 = args[2]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double(*)(long, double) noexcept nogil&gt;func)(&lt;long&gt;(&lt;long*&gt;ip0)[0], &lt;double&gt;(&lt;double*&gt;ip1)[0])</span>
        <span class="s0">(&lt;double *&gt;op0)[0] = &lt;double&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">op0 += steps[2]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_ldd__As_ldd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *op0 = args[3]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double(*)(long, double, double) noexcept nogil&gt;func)(&lt;long&gt;(&lt;long*&gt;ip0)[0], &lt;double&gt;(&lt;double*&gt;ip1)[0], &lt;double&gt;(&lt;double*&gt;ip2)[0])</span>
        <span class="s0">(&lt;double *&gt;op0)[0] = &lt;double&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">op0 += steps[3]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_d_lddd__As_lddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *ip3 = args[3]</span>
    <span class="s0">cdef char *op0 = args[4]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;double(*)(long, double, double, double) noexcept nogil&gt;func)(&lt;long&gt;(&lt;long*&gt;ip0)[0], &lt;double&gt;(&lt;double*&gt;ip1)[0], &lt;double&gt;(&lt;double*&gt;ip2)[0], &lt;double&gt;(&lt;double*&gt;ip3)[0])</span>
        <span class="s0">(&lt;double *&gt;op0)[0] = &lt;double&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">ip3 += steps[3]</span>
        <span class="s0">op0 += steps[4]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_f_f__As_f_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *op0 = args[1]</span>
    <span class="s0">cdef float ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;float(*)(float) noexcept nogil&gt;func)(&lt;float&gt;(&lt;float*&gt;ip0)[0])</span>
        <span class="s0">(&lt;float *&gt;op0)[0] = &lt;float&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">op0 += steps[1]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_f_ff__As_ff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *op0 = args[2]</span>
    <span class="s0">cdef float ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;float(*)(float, float) noexcept nogil&gt;func)(&lt;float&gt;(&lt;float*&gt;ip0)[0], &lt;float&gt;(&lt;float*&gt;ip1)[0])</span>
        <span class="s0">(&lt;float *&gt;op0)[0] = &lt;float&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">op0 += steps[2]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_g_g__As_g_g(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *op0 = args[1]</span>
    <span class="s0">cdef long double ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">ov0 = (&lt;long double(*)(long double) noexcept nogil&gt;func)(&lt;long double&gt;(&lt;long double*&gt;ip0)[0])</span>
        <span class="s0">(&lt;long double *&gt;op0)[0] = &lt;long double&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">op0 += steps[1]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_i_D_DDDD_As_D_DDDD(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *op0 = args[1]</span>
    <span class="s0">cdef char *op1 = args[2]</span>
    <span class="s0">cdef char *op2 = args[3]</span>
    <span class="s0">cdef char *op3 = args[4]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">cdef double complex ov1</span>
    <span class="s0">cdef double complex ov2</span>
    <span class="s0">cdef double complex ov3</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">(&lt;int(*)(double complex, double complex *, double complex *, double complex *, double complex *) noexcept nogil&gt;func)(&lt;double complex&gt;(&lt;double complex*&gt;ip0)[0], &amp;ov0, &amp;ov1, &amp;ov2, &amp;ov3)</span>
        <span class="s0">(&lt;double complex *&gt;op0)[0] = &lt;double complex&gt;ov0</span>
        <span class="s0">(&lt;double complex *&gt;op1)[0] = &lt;double complex&gt;ov1</span>
        <span class="s0">(&lt;double complex *&gt;op2)[0] = &lt;double complex&gt;ov2</span>
        <span class="s0">(&lt;double complex *&gt;op3)[0] = &lt;double complex&gt;ov3</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">op0 += steps[1]</span>
        <span class="s0">op1 += steps[2]</span>
        <span class="s0">op2 += steps[3]</span>
        <span class="s0">op3 += steps[4]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_i_D_DDDD_As_F_FFFF(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *op0 = args[1]</span>
    <span class="s0">cdef char *op1 = args[2]</span>
    <span class="s0">cdef char *op2 = args[3]</span>
    <span class="s0">cdef char *op3 = args[4]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">cdef double complex ov1</span>
    <span class="s0">cdef double complex ov2</span>
    <span class="s0">cdef double complex ov3</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">(&lt;int(*)(double complex, double complex *, double complex *, double complex *, double complex *) noexcept nogil&gt;func)(&lt;double complex&gt;(&lt;float complex*&gt;ip0)[0], &amp;ov0, &amp;ov1, &amp;ov2, &amp;ov3)</span>
        <span class="s0">(&lt;float complex *&gt;op0)[0] = &lt;float complex&gt;ov0</span>
        <span class="s0">(&lt;float complex *&gt;op1)[0] = &lt;float complex&gt;ov1</span>
        <span class="s0">(&lt;float complex *&gt;op2)[0] = &lt;float complex&gt;ov2</span>
        <span class="s0">(&lt;float complex *&gt;op3)[0] = &lt;float complex&gt;ov3</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">op0 += steps[1]</span>
        <span class="s0">op1 += steps[2]</span>
        <span class="s0">op2 += steps[3]</span>
        <span class="s0">op3 += steps[4]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_i_D_DD_As_D_DD(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *op0 = args[1]</span>
    <span class="s0">cdef char *op1 = args[2]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">cdef double complex ov1</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">(&lt;int(*)(double complex, double complex *, double complex *) noexcept nogil&gt;func)(&lt;double complex&gt;(&lt;double complex*&gt;ip0)[0], &amp;ov0, &amp;ov1)</span>
        <span class="s0">(&lt;double complex *&gt;op0)[0] = &lt;double complex&gt;ov0</span>
        <span class="s0">(&lt;double complex *&gt;op1)[0] = &lt;double complex&gt;ov1</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">op0 += steps[1]</span>
        <span class="s0">op1 += steps[2]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_i_D_DD_As_F_FF(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *op0 = args[1]</span>
    <span class="s0">cdef char *op1 = args[2]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">cdef double complex ov1</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">(&lt;int(*)(double complex, double complex *, double complex *) noexcept nogil&gt;func)(&lt;double complex&gt;(&lt;float complex*&gt;ip0)[0], &amp;ov0, &amp;ov1)</span>
        <span class="s0">(&lt;float complex *&gt;op0)[0] = &lt;float complex&gt;ov0</span>
        <span class="s0">(&lt;float complex *&gt;op1)[0] = &lt;float complex&gt;ov1</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">op0 += steps[1]</span>
        <span class="s0">op1 += steps[2]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_i_d_DDDD_As_d_DDDD(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *op0 = args[1]</span>
    <span class="s0">cdef char *op1 = args[2]</span>
    <span class="s0">cdef char *op2 = args[3]</span>
    <span class="s0">cdef char *op3 = args[4]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">cdef double complex ov1</span>
    <span class="s0">cdef double complex ov2</span>
    <span class="s0">cdef double complex ov3</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">(&lt;int(*)(double, double complex *, double complex *, double complex *, double complex *) noexcept nogil&gt;func)(&lt;double&gt;(&lt;double*&gt;ip0)[0], &amp;ov0, &amp;ov1, &amp;ov2, &amp;ov3)</span>
        <span class="s0">(&lt;double complex *&gt;op0)[0] = &lt;double complex&gt;ov0</span>
        <span class="s0">(&lt;double complex *&gt;op1)[0] = &lt;double complex&gt;ov1</span>
        <span class="s0">(&lt;double complex *&gt;op2)[0] = &lt;double complex&gt;ov2</span>
        <span class="s0">(&lt;double complex *&gt;op3)[0] = &lt;double complex&gt;ov3</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">op0 += steps[1]</span>
        <span class="s0">op1 += steps[2]</span>
        <span class="s0">op2 += steps[3]</span>
        <span class="s0">op3 += steps[4]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_i_d_DDDD_As_f_FFFF(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *op0 = args[1]</span>
    <span class="s0">cdef char *op1 = args[2]</span>
    <span class="s0">cdef char *op2 = args[3]</span>
    <span class="s0">cdef char *op3 = args[4]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">cdef double complex ov1</span>
    <span class="s0">cdef double complex ov2</span>
    <span class="s0">cdef double complex ov3</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">(&lt;int(*)(double, double complex *, double complex *, double complex *, double complex *) noexcept nogil&gt;func)(&lt;double&gt;(&lt;float*&gt;ip0)[0], &amp;ov0, &amp;ov1, &amp;ov2, &amp;ov3)</span>
        <span class="s0">(&lt;float complex *&gt;op0)[0] = &lt;float complex&gt;ov0</span>
        <span class="s0">(&lt;float complex *&gt;op1)[0] = &lt;float complex&gt;ov1</span>
        <span class="s0">(&lt;float complex *&gt;op2)[0] = &lt;float complex&gt;ov2</span>
        <span class="s0">(&lt;float complex *&gt;op3)[0] = &lt;float complex&gt;ov3</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">op0 += steps[1]</span>
        <span class="s0">op1 += steps[2]</span>
        <span class="s0">op2 += steps[3]</span>
        <span class="s0">op3 += steps[4]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_i_d_DD_As_d_DD(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *op0 = args[1]</span>
    <span class="s0">cdef char *op1 = args[2]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">cdef double complex ov1</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">(&lt;int(*)(double, double complex *, double complex *) noexcept nogil&gt;func)(&lt;double&gt;(&lt;double*&gt;ip0)[0], &amp;ov0, &amp;ov1)</span>
        <span class="s0">(&lt;double complex *&gt;op0)[0] = &lt;double complex&gt;ov0</span>
        <span class="s0">(&lt;double complex *&gt;op1)[0] = &lt;double complex&gt;ov1</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">op0 += steps[1]</span>
        <span class="s0">op1 += steps[2]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_i_d_DD_As_f_FF(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *op0 = args[1]</span>
    <span class="s0">cdef char *op1 = args[2]</span>
    <span class="s0">cdef double complex ov0</span>
    <span class="s0">cdef double complex ov1</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">(&lt;int(*)(double, double complex *, double complex *) noexcept nogil&gt;func)(&lt;double&gt;(&lt;float*&gt;ip0)[0], &amp;ov0, &amp;ov1)</span>
        <span class="s0">(&lt;float complex *&gt;op0)[0] = &lt;float complex&gt;ov0</span>
        <span class="s0">(&lt;float complex *&gt;op1)[0] = &lt;float complex&gt;ov1</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">op0 += steps[1]</span>
        <span class="s0">op1 += steps[2]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_i_d_dd_As_d_dd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *op0 = args[1]</span>
    <span class="s0">cdef char *op1 = args[2]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">cdef double ov1</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">(&lt;int(*)(double, double *, double *) noexcept nogil&gt;func)(&lt;double&gt;(&lt;double*&gt;ip0)[0], &amp;ov0, &amp;ov1)</span>
        <span class="s0">(&lt;double *&gt;op0)[0] = &lt;double&gt;ov0</span>
        <span class="s0">(&lt;double *&gt;op1)[0] = &lt;double&gt;ov1</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">op0 += steps[1]</span>
        <span class="s0">op1 += steps[2]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_i_d_dd_As_f_ff(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *op0 = args[1]</span>
    <span class="s0">cdef char *op1 = args[2]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">cdef double ov1</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">(&lt;int(*)(double, double *, double *) noexcept nogil&gt;func)(&lt;double&gt;(&lt;float*&gt;ip0)[0], &amp;ov0, &amp;ov1)</span>
        <span class="s0">(&lt;float *&gt;op0)[0] = &lt;float&gt;ov0</span>
        <span class="s0">(&lt;float *&gt;op1)[0] = &lt;float&gt;ov1</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">op0 += steps[1]</span>
        <span class="s0">op1 += steps[2]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_i_d_dddd_As_d_dddd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *op0 = args[1]</span>
    <span class="s0">cdef char *op1 = args[2]</span>
    <span class="s0">cdef char *op2 = args[3]</span>
    <span class="s0">cdef char *op3 = args[4]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">cdef double ov1</span>
    <span class="s0">cdef double ov2</span>
    <span class="s0">cdef double ov3</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">(&lt;int(*)(double, double *, double *, double *, double *) noexcept nogil&gt;func)(&lt;double&gt;(&lt;double*&gt;ip0)[0], &amp;ov0, &amp;ov1, &amp;ov2, &amp;ov3)</span>
        <span class="s0">(&lt;double *&gt;op0)[0] = &lt;double&gt;ov0</span>
        <span class="s0">(&lt;double *&gt;op1)[0] = &lt;double&gt;ov1</span>
        <span class="s0">(&lt;double *&gt;op2)[0] = &lt;double&gt;ov2</span>
        <span class="s0">(&lt;double *&gt;op3)[0] = &lt;double&gt;ov3</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">op0 += steps[1]</span>
        <span class="s0">op1 += steps[2]</span>
        <span class="s0">op2 += steps[3]</span>
        <span class="s0">op3 += steps[4]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_i_d_dddd_As_f_ffff(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *op0 = args[1]</span>
    <span class="s0">cdef char *op1 = args[2]</span>
    <span class="s0">cdef char *op2 = args[3]</span>
    <span class="s0">cdef char *op3 = args[4]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">cdef double ov1</span>
    <span class="s0">cdef double ov2</span>
    <span class="s0">cdef double ov3</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">(&lt;int(*)(double, double *, double *, double *, double *) noexcept nogil&gt;func)(&lt;double&gt;(&lt;float*&gt;ip0)[0], &amp;ov0, &amp;ov1, &amp;ov2, &amp;ov3)</span>
        <span class="s0">(&lt;float *&gt;op0)[0] = &lt;float&gt;ov0</span>
        <span class="s0">(&lt;float *&gt;op1)[0] = &lt;float&gt;ov1</span>
        <span class="s0">(&lt;float *&gt;op2)[0] = &lt;float&gt;ov2</span>
        <span class="s0">(&lt;float *&gt;op3)[0] = &lt;float&gt;ov3</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">op0 += steps[1]</span>
        <span class="s0">op1 += steps[2]</span>
        <span class="s0">op2 += steps[3]</span>
        <span class="s0">op3 += steps[4]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_i_dd_dd_As_dd_dd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *op0 = args[2]</span>
    <span class="s0">cdef char *op1 = args[3]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">cdef double ov1</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">(&lt;int(*)(double, double, double *, double *) noexcept nogil&gt;func)(&lt;double&gt;(&lt;double*&gt;ip0)[0], &lt;double&gt;(&lt;double*&gt;ip1)[0], &amp;ov0, &amp;ov1)</span>
        <span class="s0">(&lt;double *&gt;op0)[0] = &lt;double&gt;ov0</span>
        <span class="s0">(&lt;double *&gt;op1)[0] = &lt;double&gt;ov1</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">op0 += steps[2]</span>
        <span class="s0">op1 += steps[3]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_i_dd_dd_As_ff_ff(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *op0 = args[2]</span>
    <span class="s0">cdef char *op1 = args[3]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">cdef double ov1</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">(&lt;int(*)(double, double, double *, double *) noexcept nogil&gt;func)(&lt;double&gt;(&lt;float*&gt;ip0)[0], &lt;double&gt;(&lt;float*&gt;ip1)[0], &amp;ov0, &amp;ov1)</span>
        <span class="s0">(&lt;float *&gt;op0)[0] = &lt;float&gt;ov0</span>
        <span class="s0">(&lt;float *&gt;op1)[0] = &lt;float&gt;ov1</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">op0 += steps[2]</span>
        <span class="s0">op1 += steps[3]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_i_dd_dddd_As_dd_dddd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *op0 = args[2]</span>
    <span class="s0">cdef char *op1 = args[3]</span>
    <span class="s0">cdef char *op2 = args[4]</span>
    <span class="s0">cdef char *op3 = args[5]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">cdef double ov1</span>
    <span class="s0">cdef double ov2</span>
    <span class="s0">cdef double ov3</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">(&lt;int(*)(double, double, double *, double *, double *, double *) noexcept nogil&gt;func)(&lt;double&gt;(&lt;double*&gt;ip0)[0], &lt;double&gt;(&lt;double*&gt;ip1)[0], &amp;ov0, &amp;ov1, &amp;ov2, &amp;ov3)</span>
        <span class="s0">(&lt;double *&gt;op0)[0] = &lt;double&gt;ov0</span>
        <span class="s0">(&lt;double *&gt;op1)[0] = &lt;double&gt;ov1</span>
        <span class="s0">(&lt;double *&gt;op2)[0] = &lt;double&gt;ov2</span>
        <span class="s0">(&lt;double *&gt;op3)[0] = &lt;double&gt;ov3</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">op0 += steps[2]</span>
        <span class="s0">op1 += steps[3]</span>
        <span class="s0">op2 += steps[4]</span>
        <span class="s0">op3 += steps[5]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_i_dd_dddd_As_ff_ffff(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *op0 = args[2]</span>
    <span class="s0">cdef char *op1 = args[3]</span>
    <span class="s0">cdef char *op2 = args[4]</span>
    <span class="s0">cdef char *op3 = args[5]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">cdef double ov1</span>
    <span class="s0">cdef double ov2</span>
    <span class="s0">cdef double ov3</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">(&lt;int(*)(double, double, double *, double *, double *, double *) noexcept nogil&gt;func)(&lt;double&gt;(&lt;float*&gt;ip0)[0], &lt;double&gt;(&lt;float*&gt;ip1)[0], &amp;ov0, &amp;ov1, &amp;ov2, &amp;ov3)</span>
        <span class="s0">(&lt;float *&gt;op0)[0] = &lt;float&gt;ov0</span>
        <span class="s0">(&lt;float *&gt;op1)[0] = &lt;float&gt;ov1</span>
        <span class="s0">(&lt;float *&gt;op2)[0] = &lt;float&gt;ov2</span>
        <span class="s0">(&lt;float *&gt;op3)[0] = &lt;float&gt;ov3</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">op0 += steps[2]</span>
        <span class="s0">op1 += steps[3]</span>
        <span class="s0">op2 += steps[4]</span>
        <span class="s0">op3 += steps[5]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_i_ddd_dd_As_ddd_dd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *op0 = args[3]</span>
    <span class="s0">cdef char *op1 = args[4]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">cdef double ov1</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">(&lt;int(*)(double, double, double, double *, double *) noexcept nogil&gt;func)(&lt;double&gt;(&lt;double*&gt;ip0)[0], &lt;double&gt;(&lt;double*&gt;ip1)[0], &lt;double&gt;(&lt;double*&gt;ip2)[0], &amp;ov0, &amp;ov1)</span>
        <span class="s0">(&lt;double *&gt;op0)[0] = &lt;double&gt;ov0</span>
        <span class="s0">(&lt;double *&gt;op1)[0] = &lt;double&gt;ov1</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">op0 += steps[3]</span>
        <span class="s0">op1 += steps[4]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_i_ddd_dd_As_fff_ff(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *op0 = args[3]</span>
    <span class="s0">cdef char *op1 = args[4]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">cdef double ov1</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">(&lt;int(*)(double, double, double, double *, double *) noexcept nogil&gt;func)(&lt;double&gt;(&lt;float*&gt;ip0)[0], &lt;double&gt;(&lt;float*&gt;ip1)[0], &lt;double&gt;(&lt;float*&gt;ip2)[0], &amp;ov0, &amp;ov1)</span>
        <span class="s0">(&lt;float *&gt;op0)[0] = &lt;float&gt;ov0</span>
        <span class="s0">(&lt;float *&gt;op1)[0] = &lt;float&gt;ov1</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">op0 += steps[3]</span>
        <span class="s0">op1 += steps[4]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_i_ddddd_dd_As_ddddd_dd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *ip3 = args[3]</span>
    <span class="s0">cdef char *ip4 = args[4]</span>
    <span class="s0">cdef char *op0 = args[5]</span>
    <span class="s0">cdef char *op1 = args[6]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">cdef double ov1</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">(&lt;int(*)(double, double, double, double, double, double *, double *) noexcept nogil&gt;func)(&lt;double&gt;(&lt;double*&gt;ip0)[0], &lt;double&gt;(&lt;double*&gt;ip1)[0], &lt;double&gt;(&lt;double*&gt;ip2)[0], &lt;double&gt;(&lt;double*&gt;ip3)[0], &lt;double&gt;(&lt;double*&gt;ip4)[0], &amp;ov0, &amp;ov1)</span>
        <span class="s0">(&lt;double *&gt;op0)[0] = &lt;double&gt;ov0</span>
        <span class="s0">(&lt;double *&gt;op1)[0] = &lt;double&gt;ov1</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">ip3 += steps[3]</span>
        <span class="s0">ip4 += steps[4]</span>
        <span class="s0">op0 += steps[5]</span>
        <span class="s0">op1 += steps[6]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_i_ddddd_dd_As_fffff_ff(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *ip1 = args[1]</span>
    <span class="s0">cdef char *ip2 = args[2]</span>
    <span class="s0">cdef char *ip3 = args[3]</span>
    <span class="s0">cdef char *ip4 = args[4]</span>
    <span class="s0">cdef char *op0 = args[5]</span>
    <span class="s0">cdef char *op1 = args[6]</span>
    <span class="s0">cdef double ov0</span>
    <span class="s0">cdef double ov1</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">(&lt;int(*)(double, double, double, double, double, double *, double *) noexcept nogil&gt;func)(&lt;double&gt;(&lt;float*&gt;ip0)[0], &lt;double&gt;(&lt;float*&gt;ip1)[0], &lt;double&gt;(&lt;float*&gt;ip2)[0], &lt;double&gt;(&lt;float*&gt;ip3)[0], &lt;double&gt;(&lt;float*&gt;ip4)[0], &amp;ov0, &amp;ov1)</span>
        <span class="s0">(&lt;float *&gt;op0)[0] = &lt;float&gt;ov0</span>
        <span class="s0">(&lt;float *&gt;op1)[0] = &lt;float&gt;ov1</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">ip1 += steps[1]</span>
        <span class="s0">ip2 += steps[2]</span>
        <span class="s0">ip3 += steps[3]</span>
        <span class="s0">ip4 += steps[4]</span>
        <span class="s0">op0 += steps[5]</span>
        <span class="s0">op1 += steps[6]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef void loop_i_i__As_l_l(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:</span>
    <span class="s0">cdef np.npy_intp i, n = dims[0]</span>
    <span class="s0">cdef void *func = (&lt;void**&gt;data)[0]</span>
    <span class="s0">cdef char *func_name = &lt;char*&gt;(&lt;void**&gt;data)[1]</span>
    <span class="s0">cdef char *ip0 = args[0]</span>
    <span class="s0">cdef char *op0 = args[1]</span>
    <span class="s0">cdef int ov0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">if &lt;int&gt;(&lt;long*&gt;ip0)[0] == (&lt;long*&gt;ip0)[0]:</span>
            <span class="s0">ov0 = (&lt;int(*)(int) noexcept nogil&gt;func)(&lt;int&gt;(&lt;long*&gt;ip0)[0])</span>
        <span class="s0">else:</span>
            <span class="s0">sf_error.error(func_name, sf_error.DOMAIN, &quot;invalid input argument&quot;)</span>
            <span class="s0">ov0 = &lt;int&gt;0xbad0bad0</span>
        <span class="s0">(&lt;long *&gt;op0)[0] = &lt;long&gt;ov0</span>
        <span class="s0">ip0 += steps[0]</span>
        <span class="s0">op0 += steps[1]</span>
    <span class="s0">sf_error.check_fpe(func_name)</span>

<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cosine_cdf &quot;cosine_cdf&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cosine_invcdf &quot;cosine_invcdf&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cospi &quot;cospi&quot;(double) noexcept nogil</span>
<span class="s0">from ._trig cimport ccospi as _func_ccospi</span>
<span class="s0">ctypedef double complex _proto_ccospi_t(double complex) noexcept nogil</span>
<span class="s0">cdef _proto_ccospi_t *_proto_ccospi_t_var = &amp;_func_ccospi</span>
<span class="s0">from ._ellip_harm cimport ellip_harmonic as _func_ellip_harmonic</span>
<span class="s0">ctypedef double _proto_ellip_harmonic_t(double, double, int, int, double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_ellip_harmonic_t *_proto_ellip_harmonic_t_var = &amp;_func_ellip_harmonic</span>
<span class="s0">from ._legacy cimport ellip_harmonic_unsafe as _func_ellip_harmonic_unsafe</span>
<span class="s0">ctypedef double _proto_ellip_harmonic_unsafe_t(double, double, double, double, double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_ellip_harmonic_unsafe_t *_proto_ellip_harmonic_unsafe_t_var = &amp;_func_ellip_harmonic_unsafe</span>
<span class="s0">from ._factorial cimport _factorial as _func__factorial</span>
<span class="s0">ctypedef double _proto__factorial_t(double) noexcept nogil</span>
<span class="s0">cdef _proto__factorial_t *_proto__factorial_t_var = &amp;_func__factorial</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_igam_fac &quot;igam_fac&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_kolmogc &quot;kolmogc&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_kolmogci &quot;kolmogci&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_kolmogp &quot;kolmogp&quot;(double) noexcept nogil</span>
<span class="s0">from ._lambertw cimport lambertw_scalar as _func_lambertw_scalar</span>
<span class="s0">ctypedef double complex _proto_lambertw_scalar_t(double complex, long, double) noexcept nogil</span>
<span class="s0">cdef _proto_lambertw_scalar_t *_proto_lambertw_scalar_t_var = &amp;_func_lambertw_scalar</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_lanczos_sum_expg_scaled &quot;lanczos_sum_expg_scaled&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_lgam1p &quot;lgam1p&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_log1pmx &quot;log1pmx&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_riemann_zeta &quot;riemann_zeta&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_scaled_exp1 &quot;scaled_exp1&quot;(double) noexcept nogil</span>
<span class="s0">from .sf_error cimport _sf_error_test_function as _func__sf_error_test_function</span>
<span class="s0">ctypedef int _proto__sf_error_test_function_t(int) noexcept nogil</span>
<span class="s0">cdef _proto__sf_error_test_function_t *_proto__sf_error_test_function_t_var = &amp;_func__sf_error_test_function</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_sinpi &quot;sinpi&quot;(double) noexcept nogil</span>
<span class="s0">from ._trig cimport csinpi as _func_csinpi</span>
<span class="s0">ctypedef double complex _proto_csinpi_t(double complex) noexcept nogil</span>
<span class="s0">cdef _proto_csinpi_t *_proto_csinpi_t_var = &amp;_func_csinpi</span>
<span class="s0">from ._legacy cimport smirnovc_unsafe as _func_smirnovc_unsafe</span>
<span class="s0">ctypedef double _proto_smirnovc_unsafe_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_smirnovc_unsafe_t *_proto_smirnovc_unsafe_t_var = &amp;_func_smirnovc_unsafe</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_smirnovc &quot;smirnovc&quot;(int, double) noexcept nogil</span>
<span class="s0">from ._legacy cimport smirnovci_unsafe as _func_smirnovci_unsafe</span>
<span class="s0">ctypedef double _proto_smirnovci_unsafe_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_smirnovci_unsafe_t *_proto_smirnovci_unsafe_t_var = &amp;_func_smirnovci_unsafe</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_smirnovci &quot;smirnovci&quot;(int, double) noexcept nogil</span>
<span class="s0">from ._legacy cimport smirnovp_unsafe as _func_smirnovp_unsafe</span>
<span class="s0">ctypedef double _proto_smirnovp_unsafe_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_smirnovp_unsafe_t *_proto_smirnovp_unsafe_t_var = &amp;_func_smirnovp_unsafe</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_smirnovp &quot;smirnovp&quot;(int, double) noexcept nogil</span>
<span class="s0">from ._spherical_bessel cimport spherical_in_complex as _func_spherical_in_complex</span>
<span class="s0">ctypedef double complex _proto_spherical_in_complex_t(long, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_spherical_in_complex_t *_proto_spherical_in_complex_t_var = &amp;_func_spherical_in_complex</span>
<span class="s0">from ._spherical_bessel cimport spherical_in_real as _func_spherical_in_real</span>
<span class="s0">ctypedef double _proto_spherical_in_real_t(long, double) noexcept nogil</span>
<span class="s0">cdef _proto_spherical_in_real_t *_proto_spherical_in_real_t_var = &amp;_func_spherical_in_real</span>
<span class="s0">from ._spherical_bessel cimport spherical_in_d_complex as _func_spherical_in_d_complex</span>
<span class="s0">ctypedef double complex _proto_spherical_in_d_complex_t(long, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_spherical_in_d_complex_t *_proto_spherical_in_d_complex_t_var = &amp;_func_spherical_in_d_complex</span>
<span class="s0">from ._spherical_bessel cimport spherical_in_d_real as _func_spherical_in_d_real</span>
<span class="s0">ctypedef double _proto_spherical_in_d_real_t(long, double) noexcept nogil</span>
<span class="s0">cdef _proto_spherical_in_d_real_t *_proto_spherical_in_d_real_t_var = &amp;_func_spherical_in_d_real</span>
<span class="s0">from ._spherical_bessel cimport spherical_jn_complex as _func_spherical_jn_complex</span>
<span class="s0">ctypedef double complex _proto_spherical_jn_complex_t(long, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_spherical_jn_complex_t *_proto_spherical_jn_complex_t_var = &amp;_func_spherical_jn_complex</span>
<span class="s0">from ._spherical_bessel cimport spherical_jn_real as _func_spherical_jn_real</span>
<span class="s0">ctypedef double _proto_spherical_jn_real_t(long, double) noexcept nogil</span>
<span class="s0">cdef _proto_spherical_jn_real_t *_proto_spherical_jn_real_t_var = &amp;_func_spherical_jn_real</span>
<span class="s0">from ._spherical_bessel cimport spherical_jn_d_complex as _func_spherical_jn_d_complex</span>
<span class="s0">ctypedef double complex _proto_spherical_jn_d_complex_t(long, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_spherical_jn_d_complex_t *_proto_spherical_jn_d_complex_t_var = &amp;_func_spherical_jn_d_complex</span>
<span class="s0">from ._spherical_bessel cimport spherical_jn_d_real as _func_spherical_jn_d_real</span>
<span class="s0">ctypedef double _proto_spherical_jn_d_real_t(long, double) noexcept nogil</span>
<span class="s0">cdef _proto_spherical_jn_d_real_t *_proto_spherical_jn_d_real_t_var = &amp;_func_spherical_jn_d_real</span>
<span class="s0">from ._spherical_bessel cimport spherical_kn_complex as _func_spherical_kn_complex</span>
<span class="s0">ctypedef double complex _proto_spherical_kn_complex_t(long, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_spherical_kn_complex_t *_proto_spherical_kn_complex_t_var = &amp;_func_spherical_kn_complex</span>
<span class="s0">from ._spherical_bessel cimport spherical_kn_real as _func_spherical_kn_real</span>
<span class="s0">ctypedef double _proto_spherical_kn_real_t(long, double) noexcept nogil</span>
<span class="s0">cdef _proto_spherical_kn_real_t *_proto_spherical_kn_real_t_var = &amp;_func_spherical_kn_real</span>
<span class="s0">from ._spherical_bessel cimport spherical_kn_d_complex as _func_spherical_kn_d_complex</span>
<span class="s0">ctypedef double complex _proto_spherical_kn_d_complex_t(long, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_spherical_kn_d_complex_t *_proto_spherical_kn_d_complex_t_var = &amp;_func_spherical_kn_d_complex</span>
<span class="s0">from ._spherical_bessel cimport spherical_kn_d_real as _func_spherical_kn_d_real</span>
<span class="s0">ctypedef double _proto_spherical_kn_d_real_t(long, double) noexcept nogil</span>
<span class="s0">cdef _proto_spherical_kn_d_real_t *_proto_spherical_kn_d_real_t_var = &amp;_func_spherical_kn_d_real</span>
<span class="s0">from ._spherical_bessel cimport spherical_yn_complex as _func_spherical_yn_complex</span>
<span class="s0">ctypedef double complex _proto_spherical_yn_complex_t(long, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_spherical_yn_complex_t *_proto_spherical_yn_complex_t_var = &amp;_func_spherical_yn_complex</span>
<span class="s0">from ._spherical_bessel cimport spherical_yn_real as _func_spherical_yn_real</span>
<span class="s0">ctypedef double _proto_spherical_yn_real_t(long, double) noexcept nogil</span>
<span class="s0">cdef _proto_spherical_yn_real_t *_proto_spherical_yn_real_t_var = &amp;_func_spherical_yn_real</span>
<span class="s0">from ._spherical_bessel cimport spherical_yn_d_complex as _func_spherical_yn_d_complex</span>
<span class="s0">ctypedef double complex _proto_spherical_yn_d_complex_t(long, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_spherical_yn_d_complex_t *_proto_spherical_yn_d_complex_t_var = &amp;_func_spherical_yn_d_complex</span>
<span class="s0">from ._spherical_bessel cimport spherical_yn_d_real as _func_spherical_yn_d_real</span>
<span class="s0">ctypedef double _proto_spherical_yn_d_real_t(long, double) noexcept nogil</span>
<span class="s0">cdef _proto_spherical_yn_d_real_t *_proto_spherical_yn_d_real_t_var = &amp;_func_spherical_yn_d_real</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_struve_asymp_large_z &quot;struve_asymp_large_z&quot;(double, double, int, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_struve_bessel_series &quot;struve_bessel_series&quot;(double, double, int, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_struve_power_series &quot;struve_power_series&quot;(double, double, int, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_zeta &quot;zeta&quot;(double, double) noexcept nogil</span>
<span class="s0">from ._agm cimport agm as _func_agm</span>
<span class="s0">ctypedef double _proto_agm_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_agm_t *_proto_agm_t_var = &amp;_func_agm</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_airy_wrap &quot;airy_wrap&quot;(double, double *, double *, double *, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_cairy_wrap &quot;cairy_wrap&quot;(double complex, double complex *, double complex *, double complex *, double complex *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_cairy_wrap_e &quot;cairy_wrap_e&quot;(double complex, double complex *, double complex *, double complex *, double complex *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_cairy_wrap_e_real &quot;cairy_wrap_e_real&quot;(double, double *, double *, double *, double *) noexcept nogil</span>
<span class="s0">from ._legacy cimport bdtr_unsafe as _func_bdtr_unsafe</span>
<span class="s0">ctypedef double _proto_bdtr_unsafe_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_bdtr_unsafe_t *_proto_bdtr_unsafe_t_var = &amp;_func_bdtr_unsafe</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_bdtr &quot;bdtr&quot;(double, int, double) noexcept nogil</span>
<span class="s0">from ._legacy cimport bdtrc_unsafe as _func_bdtrc_unsafe</span>
<span class="s0">ctypedef double _proto_bdtrc_unsafe_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_bdtrc_unsafe_t *_proto_bdtrc_unsafe_t_var = &amp;_func_bdtrc_unsafe</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_bdtrc &quot;bdtrc&quot;(double, int, double) noexcept nogil</span>
<span class="s0">from ._legacy cimport bdtri_unsafe as _func_bdtri_unsafe</span>
<span class="s0">ctypedef double _proto_bdtri_unsafe_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_bdtri_unsafe_t *_proto_bdtri_unsafe_t_var = &amp;_func_bdtri_unsafe</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_bdtri &quot;bdtri&quot;(double, int, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cdfbin2_wrap &quot;cdfbin2_wrap&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cdfbin3_wrap &quot;cdfbin3_wrap&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_bei_wrap &quot;bei_wrap&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_beip_wrap &quot;beip_wrap&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_ber_wrap &quot;ber_wrap&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_berp_wrap &quot;berp_wrap&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_besselpoly &quot;besselpoly&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_beta &quot;beta&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_incbet &quot;incbet&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_incbi &quot;incbi&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_lbeta &quot;lbeta&quot;(double, double) noexcept nogil</span>
<span class="s0">from .orthogonal_eval cimport binom as _func_binom</span>
<span class="s0">ctypedef double _proto_binom_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_binom_t *_proto_binom_t_var = &amp;_func_binom</span>
<span class="s0">from ._boxcox cimport boxcox as _func_boxcox</span>
<span class="s0">ctypedef double _proto_boxcox_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_boxcox_t *_proto_boxcox_t_var = &amp;_func_boxcox</span>
<span class="s0">from ._boxcox cimport boxcox1p as _func_boxcox1p</span>
<span class="s0">ctypedef double _proto_boxcox1p_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_boxcox1p_t *_proto_boxcox1p_t_var = &amp;_func_boxcox1p</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_btdtr &quot;btdtr&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_incbi &quot;incbi&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cdfbet3_wrap &quot;cdfbet3_wrap&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cdfbet4_wrap &quot;cdfbet4_wrap&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cbrt &quot;cbrt&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_chdtr &quot;chdtr&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_chdtrc &quot;chdtrc&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_chdtri &quot;chdtri&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cdfchi3_wrap &quot;cdfchi3_wrap&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cdfchn1_wrap &quot;cdfchn1_wrap&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cdfchn3_wrap &quot;cdfchn3_wrap&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cdfchn4_wrap &quot;cdfchn4_wrap&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cdfchn2_wrap &quot;cdfchn2_wrap&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cosdg &quot;cosdg&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cosm1 &quot;cosm1&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cotdg &quot;cotdg&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_ellpe &quot;ellpe&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_ellie &quot;ellie&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_ellpj &quot;ellpj&quot;(double, double, double *, double *, double *, double *) noexcept nogil</span>
<span class="s0">from ._ellipk cimport ellipk as _func_ellipk</span>
<span class="s0">ctypedef double _proto_ellipk_t(double) noexcept nogil</span>
<span class="s0">cdef _proto_ellipk_t *_proto_ellipk_t_var = &amp;_func_ellipk</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_ellik &quot;ellik&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_ellpk &quot;ellpk&quot;(double) noexcept nogil</span>
<span class="s0">from ._convex_analysis cimport entr as _func_entr</span>
<span class="s0">ctypedef double _proto_entr_t(double) noexcept nogil</span>
<span class="s0">cdef _proto_entr_t *_proto_entr_t_var = &amp;_func_entr</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_erf &quot;erf&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_erfc &quot;erfc&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_erfcinv &quot;erfcinv&quot;(double) noexcept nogil</span>
<span class="s0">from .orthogonal_eval cimport eval_chebyc as _func_eval_chebyc</span>
<span class="s0">ctypedef double complex _proto_eval_chebyc_double_complex__t(double, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_eval_chebyc_double_complex__t *_proto_eval_chebyc_double_complex__t_var = &amp;_func_eval_chebyc[double_complex]</span>
<span class="s0">from .orthogonal_eval cimport eval_chebyc as _func_eval_chebyc</span>
<span class="s0">ctypedef double _proto_eval_chebyc_double__t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_chebyc_double__t *_proto_eval_chebyc_double__t_var = &amp;_func_eval_chebyc[double]</span>
<span class="s0">from .orthogonal_eval cimport eval_chebyc_l as _func_eval_chebyc_l</span>
<span class="s0">ctypedef double _proto_eval_chebyc_l_t(long, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_chebyc_l_t *_proto_eval_chebyc_l_t_var = &amp;_func_eval_chebyc_l</span>
<span class="s0">from .orthogonal_eval cimport eval_chebys as _func_eval_chebys</span>
<span class="s0">ctypedef double complex _proto_eval_chebys_double_complex__t(double, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_eval_chebys_double_complex__t *_proto_eval_chebys_double_complex__t_var = &amp;_func_eval_chebys[double_complex]</span>
<span class="s0">from .orthogonal_eval cimport eval_chebys as _func_eval_chebys</span>
<span class="s0">ctypedef double _proto_eval_chebys_double__t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_chebys_double__t *_proto_eval_chebys_double__t_var = &amp;_func_eval_chebys[double]</span>
<span class="s0">from .orthogonal_eval cimport eval_chebys_l as _func_eval_chebys_l</span>
<span class="s0">ctypedef double _proto_eval_chebys_l_t(long, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_chebys_l_t *_proto_eval_chebys_l_t_var = &amp;_func_eval_chebys_l</span>
<span class="s0">from .orthogonal_eval cimport eval_chebyt as _func_eval_chebyt</span>
<span class="s0">ctypedef double complex _proto_eval_chebyt_double_complex__t(double, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_eval_chebyt_double_complex__t *_proto_eval_chebyt_double_complex__t_var = &amp;_func_eval_chebyt[double_complex]</span>
<span class="s0">from .orthogonal_eval cimport eval_chebyt as _func_eval_chebyt</span>
<span class="s0">ctypedef double _proto_eval_chebyt_double__t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_chebyt_double__t *_proto_eval_chebyt_double__t_var = &amp;_func_eval_chebyt[double]</span>
<span class="s0">from .orthogonal_eval cimport eval_chebyt_l as _func_eval_chebyt_l</span>
<span class="s0">ctypedef double _proto_eval_chebyt_l_t(long, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_chebyt_l_t *_proto_eval_chebyt_l_t_var = &amp;_func_eval_chebyt_l</span>
<span class="s0">from .orthogonal_eval cimport eval_chebyu as _func_eval_chebyu</span>
<span class="s0">ctypedef double complex _proto_eval_chebyu_double_complex__t(double, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_eval_chebyu_double_complex__t *_proto_eval_chebyu_double_complex__t_var = &amp;_func_eval_chebyu[double_complex]</span>
<span class="s0">from .orthogonal_eval cimport eval_chebyu as _func_eval_chebyu</span>
<span class="s0">ctypedef double _proto_eval_chebyu_double__t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_chebyu_double__t *_proto_eval_chebyu_double__t_var = &amp;_func_eval_chebyu[double]</span>
<span class="s0">from .orthogonal_eval cimport eval_chebyu_l as _func_eval_chebyu_l</span>
<span class="s0">ctypedef double _proto_eval_chebyu_l_t(long, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_chebyu_l_t *_proto_eval_chebyu_l_t_var = &amp;_func_eval_chebyu_l</span>
<span class="s0">from .orthogonal_eval cimport eval_gegenbauer as _func_eval_gegenbauer</span>
<span class="s0">ctypedef double complex _proto_eval_gegenbauer_double_complex__t(double, double, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_eval_gegenbauer_double_complex__t *_proto_eval_gegenbauer_double_complex__t_var = &amp;_func_eval_gegenbauer[double_complex]</span>
<span class="s0">from .orthogonal_eval cimport eval_gegenbauer as _func_eval_gegenbauer</span>
<span class="s0">ctypedef double _proto_eval_gegenbauer_double__t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_gegenbauer_double__t *_proto_eval_gegenbauer_double__t_var = &amp;_func_eval_gegenbauer[double]</span>
<span class="s0">from .orthogonal_eval cimport eval_gegenbauer_l as _func_eval_gegenbauer_l</span>
<span class="s0">ctypedef double _proto_eval_gegenbauer_l_t(long, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_gegenbauer_l_t *_proto_eval_gegenbauer_l_t_var = &amp;_func_eval_gegenbauer_l</span>
<span class="s0">from .orthogonal_eval cimport eval_genlaguerre as _func_eval_genlaguerre</span>
<span class="s0">ctypedef double complex _proto_eval_genlaguerre_double_complex__t(double, double, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_eval_genlaguerre_double_complex__t *_proto_eval_genlaguerre_double_complex__t_var = &amp;_func_eval_genlaguerre[double_complex]</span>
<span class="s0">from .orthogonal_eval cimport eval_genlaguerre as _func_eval_genlaguerre</span>
<span class="s0">ctypedef double _proto_eval_genlaguerre_double__t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_genlaguerre_double__t *_proto_eval_genlaguerre_double__t_var = &amp;_func_eval_genlaguerre[double]</span>
<span class="s0">from .orthogonal_eval cimport eval_genlaguerre_l as _func_eval_genlaguerre_l</span>
<span class="s0">ctypedef double _proto_eval_genlaguerre_l_t(long, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_genlaguerre_l_t *_proto_eval_genlaguerre_l_t_var = &amp;_func_eval_genlaguerre_l</span>
<span class="s0">from .orthogonal_eval cimport eval_hermite as _func_eval_hermite</span>
<span class="s0">ctypedef double _proto_eval_hermite_t(long, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_hermite_t *_proto_eval_hermite_t_var = &amp;_func_eval_hermite</span>
<span class="s0">from .orthogonal_eval cimport eval_hermitenorm as _func_eval_hermitenorm</span>
<span class="s0">ctypedef double _proto_eval_hermitenorm_t(long, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_hermitenorm_t *_proto_eval_hermitenorm_t_var = &amp;_func_eval_hermitenorm</span>
<span class="s0">from .orthogonal_eval cimport eval_jacobi as _func_eval_jacobi</span>
<span class="s0">ctypedef double complex _proto_eval_jacobi_double_complex__t(double, double, double, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_eval_jacobi_double_complex__t *_proto_eval_jacobi_double_complex__t_var = &amp;_func_eval_jacobi[double_complex]</span>
<span class="s0">from .orthogonal_eval cimport eval_jacobi as _func_eval_jacobi</span>
<span class="s0">ctypedef double _proto_eval_jacobi_double__t(double, double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_jacobi_double__t *_proto_eval_jacobi_double__t_var = &amp;_func_eval_jacobi[double]</span>
<span class="s0">from .orthogonal_eval cimport eval_jacobi_l as _func_eval_jacobi_l</span>
<span class="s0">ctypedef double _proto_eval_jacobi_l_t(long, double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_jacobi_l_t *_proto_eval_jacobi_l_t_var = &amp;_func_eval_jacobi_l</span>
<span class="s0">from .orthogonal_eval cimport eval_laguerre as _func_eval_laguerre</span>
<span class="s0">ctypedef double complex _proto_eval_laguerre_double_complex__t(double, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_eval_laguerre_double_complex__t *_proto_eval_laguerre_double_complex__t_var = &amp;_func_eval_laguerre[double_complex]</span>
<span class="s0">from .orthogonal_eval cimport eval_laguerre as _func_eval_laguerre</span>
<span class="s0">ctypedef double _proto_eval_laguerre_double__t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_laguerre_double__t *_proto_eval_laguerre_double__t_var = &amp;_func_eval_laguerre[double]</span>
<span class="s0">from .orthogonal_eval cimport eval_laguerre_l as _func_eval_laguerre_l</span>
<span class="s0">ctypedef double _proto_eval_laguerre_l_t(long, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_laguerre_l_t *_proto_eval_laguerre_l_t_var = &amp;_func_eval_laguerre_l</span>
<span class="s0">from .orthogonal_eval cimport eval_legendre as _func_eval_legendre</span>
<span class="s0">ctypedef double complex _proto_eval_legendre_double_complex__t(double, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_eval_legendre_double_complex__t *_proto_eval_legendre_double_complex__t_var = &amp;_func_eval_legendre[double_complex]</span>
<span class="s0">from .orthogonal_eval cimport eval_legendre as _func_eval_legendre</span>
<span class="s0">ctypedef double _proto_eval_legendre_double__t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_legendre_double__t *_proto_eval_legendre_double__t_var = &amp;_func_eval_legendre[double]</span>
<span class="s0">from .orthogonal_eval cimport eval_legendre_l as _func_eval_legendre_l</span>
<span class="s0">ctypedef double _proto_eval_legendre_l_t(long, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_legendre_l_t *_proto_eval_legendre_l_t_var = &amp;_func_eval_legendre_l</span>
<span class="s0">from .orthogonal_eval cimport eval_sh_chebyt as _func_eval_sh_chebyt</span>
<span class="s0">ctypedef double complex _proto_eval_sh_chebyt_double_complex__t(double, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_eval_sh_chebyt_double_complex__t *_proto_eval_sh_chebyt_double_complex__t_var = &amp;_func_eval_sh_chebyt[double_complex]</span>
<span class="s0">from .orthogonal_eval cimport eval_sh_chebyt as _func_eval_sh_chebyt</span>
<span class="s0">ctypedef double _proto_eval_sh_chebyt_double__t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_sh_chebyt_double__t *_proto_eval_sh_chebyt_double__t_var = &amp;_func_eval_sh_chebyt[double]</span>
<span class="s0">from .orthogonal_eval cimport eval_sh_chebyt_l as _func_eval_sh_chebyt_l</span>
<span class="s0">ctypedef double _proto_eval_sh_chebyt_l_t(long, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_sh_chebyt_l_t *_proto_eval_sh_chebyt_l_t_var = &amp;_func_eval_sh_chebyt_l</span>
<span class="s0">from .orthogonal_eval cimport eval_sh_chebyu as _func_eval_sh_chebyu</span>
<span class="s0">ctypedef double complex _proto_eval_sh_chebyu_double_complex__t(double, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_eval_sh_chebyu_double_complex__t *_proto_eval_sh_chebyu_double_complex__t_var = &amp;_func_eval_sh_chebyu[double_complex]</span>
<span class="s0">from .orthogonal_eval cimport eval_sh_chebyu as _func_eval_sh_chebyu</span>
<span class="s0">ctypedef double _proto_eval_sh_chebyu_double__t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_sh_chebyu_double__t *_proto_eval_sh_chebyu_double__t_var = &amp;_func_eval_sh_chebyu[double]</span>
<span class="s0">from .orthogonal_eval cimport eval_sh_chebyu_l as _func_eval_sh_chebyu_l</span>
<span class="s0">ctypedef double _proto_eval_sh_chebyu_l_t(long, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_sh_chebyu_l_t *_proto_eval_sh_chebyu_l_t_var = &amp;_func_eval_sh_chebyu_l</span>
<span class="s0">from .orthogonal_eval cimport eval_sh_jacobi as _func_eval_sh_jacobi</span>
<span class="s0">ctypedef double complex _proto_eval_sh_jacobi_double_complex__t(double, double, double, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_eval_sh_jacobi_double_complex__t *_proto_eval_sh_jacobi_double_complex__t_var = &amp;_func_eval_sh_jacobi[double_complex]</span>
<span class="s0">from .orthogonal_eval cimport eval_sh_jacobi as _func_eval_sh_jacobi</span>
<span class="s0">ctypedef double _proto_eval_sh_jacobi_double__t(double, double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_sh_jacobi_double__t *_proto_eval_sh_jacobi_double__t_var = &amp;_func_eval_sh_jacobi[double]</span>
<span class="s0">from .orthogonal_eval cimport eval_sh_jacobi_l as _func_eval_sh_jacobi_l</span>
<span class="s0">ctypedef double _proto_eval_sh_jacobi_l_t(long, double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_sh_jacobi_l_t *_proto_eval_sh_jacobi_l_t_var = &amp;_func_eval_sh_jacobi_l</span>
<span class="s0">from .orthogonal_eval cimport eval_sh_legendre as _func_eval_sh_legendre</span>
<span class="s0">ctypedef double complex _proto_eval_sh_legendre_double_complex__t(double, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_eval_sh_legendre_double_complex__t *_proto_eval_sh_legendre_double_complex__t_var = &amp;_func_eval_sh_legendre[double_complex]</span>
<span class="s0">from .orthogonal_eval cimport eval_sh_legendre as _func_eval_sh_legendre</span>
<span class="s0">ctypedef double _proto_eval_sh_legendre_double__t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_sh_legendre_double__t *_proto_eval_sh_legendre_double__t_var = &amp;_func_eval_sh_legendre[double]</span>
<span class="s0">from .orthogonal_eval cimport eval_sh_legendre_l as _func_eval_sh_legendre_l</span>
<span class="s0">ctypedef double _proto_eval_sh_legendre_l_t(long, double) noexcept nogil</span>
<span class="s0">cdef _proto_eval_sh_legendre_l_t *_proto_eval_sh_legendre_l_t_var = &amp;_func_eval_sh_legendre_l</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double complex _func_cexp1_wrap &quot;cexp1_wrap&quot;(double complex) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_exp1_wrap &quot;exp1_wrap&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_exp10 &quot;exp10&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_exp2 &quot;exp2&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double complex _func_cexpi_wrap &quot;cexpi_wrap&quot;(double complex) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_expi_wrap &quot;expi_wrap&quot;(double) noexcept nogil</span>
<span class="s0">from ._cunity cimport cexpm1 as _func_cexpm1</span>
<span class="s0">ctypedef double complex _proto_cexpm1_t(double complex) noexcept nogil</span>
<span class="s0">cdef _proto_cexpm1_t *_proto_cexpm1_t_var = &amp;_func_cexpm1</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_expm1 &quot;expm1&quot;(double) noexcept nogil</span>
<span class="s0">from ._legacy cimport expn_unsafe as _func_expn_unsafe</span>
<span class="s0">ctypedef double _proto_expn_unsafe_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_expn_unsafe_t *_proto_expn_unsafe_t_var = &amp;_func_expn_unsafe</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_expn &quot;expn&quot;(int, double) noexcept nogil</span>
<span class="s0">from ._exprel cimport exprel as _func_exprel</span>
<span class="s0">ctypedef double _proto_exprel_t(double) noexcept nogil</span>
<span class="s0">cdef _proto_exprel_t *_proto_exprel_t_var = &amp;_func_exprel</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_fdtr &quot;fdtr&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_fdtrc &quot;fdtrc&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_fdtri &quot;fdtri&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cdff4_wrap &quot;cdff4_wrap&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_fresnl &quot;fresnl&quot;(double, double *, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_cfresnl_wrap &quot;cfresnl_wrap&quot;(double complex, double complex *, double complex *) noexcept nogil</span>
<span class="s0">from ._loggamma cimport cgamma as _func_cgamma</span>
<span class="s0">ctypedef double complex _proto_cgamma_t(double complex) noexcept nogil</span>
<span class="s0">cdef _proto_cgamma_t *_proto_cgamma_t_var = &amp;_func_cgamma</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_Gamma &quot;Gamma&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_igam &quot;igam&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_igamc &quot;igamc&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_igamci &quot;igamci&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_igami &quot;igami&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_lgam &quot;lgam&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_gammasgn &quot;gammasgn&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_gdtr &quot;gdtr&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_gdtrc &quot;gdtrc&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cdfgam4_wrap &quot;cdfgam4_wrap&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cdfgam3_wrap &quot;cdfgam3_wrap&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cdfgam2_wrap &quot;cdfgam2_wrap&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double complex _func_cbesh_wrap1 &quot;cbesh_wrap1&quot;(double, double complex) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double complex _func_cbesh_wrap1_e &quot;cbesh_wrap1_e&quot;(double, double complex) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double complex _func_cbesh_wrap2 &quot;cbesh_wrap2&quot;(double, double complex) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double complex _func_cbesh_wrap2_e &quot;cbesh_wrap2_e&quot;(double, double complex) noexcept nogil</span>
<span class="s0">from ._convex_analysis cimport huber as _func_huber</span>
<span class="s0">ctypedef double _proto_huber_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_huber_t *_proto_huber_t_var = &amp;_func_huber</span>
<span class="s0">from ._hyp0f1 cimport _hyp0f1_cmplx as _func__hyp0f1_cmplx</span>
<span class="s0">ctypedef double complex _proto__hyp0f1_cmplx_t(double, double complex) noexcept nogil</span>
<span class="s0">cdef _proto__hyp0f1_cmplx_t *_proto__hyp0f1_cmplx_t_var = &amp;_func__hyp0f1_cmplx</span>
<span class="s0">from ._hyp0f1 cimport _hyp0f1_real as _func__hyp0f1_real</span>
<span class="s0">ctypedef double _proto__hyp0f1_real_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto__hyp0f1_real_t *_proto__hyp0f1_real_t_var = &amp;_func__hyp0f1_real</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double complex _func_chyp1f1_wrap &quot;chyp1f1_wrap&quot;(double, double, double complex) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_hyp2f1 &quot;hyp2f1&quot;(double, double, double, double) noexcept nogil</span>
<span class="s0">from ._hyp2f1 cimport hyp2f1_complex as _func_hyp2f1_complex</span>
<span class="s0">ctypedef double complex _proto_hyp2f1_complex_t(double, double, double, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_hyp2f1_complex_t *_proto_hyp2f1_complex_t_var = &amp;_func_hyp2f1_complex</span>
<span class="s0">from ._hypergeometric cimport hyperu as _func_hyperu</span>
<span class="s0">ctypedef double _proto_hyperu_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_hyperu_t *_proto_hyperu_t_var = &amp;_func_hyperu</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_i0 &quot;i0&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_i0e &quot;i0e&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_i1 &quot;i1&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_i1e &quot;i1e&quot;(double) noexcept nogil</span>
<span class="s0">from ._boxcox cimport inv_boxcox as _func_inv_boxcox</span>
<span class="s0">ctypedef double _proto_inv_boxcox_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_inv_boxcox_t *_proto_inv_boxcox_t_var = &amp;_func_inv_boxcox</span>
<span class="s0">from ._boxcox cimport inv_boxcox1p as _func_inv_boxcox1p</span>
<span class="s0">ctypedef double _proto_inv_boxcox1p_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_inv_boxcox1p_t *_proto_inv_boxcox1p_t_var = &amp;_func_inv_boxcox1p</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_it2i0k0_wrap &quot;it2i0k0_wrap&quot;(double, double *, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_it2j0y0_wrap &quot;it2j0y0_wrap&quot;(double, double *, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_it2struve0_wrap &quot;it2struve0_wrap&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_itairy_wrap &quot;itairy_wrap&quot;(double, double *, double *, double *, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_it1i0k0_wrap &quot;it1i0k0_wrap&quot;(double, double *, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_it1j0y0_wrap &quot;it1j0y0_wrap&quot;(double, double *, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_itmodstruve0_wrap &quot;itmodstruve0_wrap&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_itstruve0_wrap &quot;itstruve0_wrap&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double complex _func_cbesi_wrap &quot;cbesi_wrap&quot;(double, double complex) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_iv &quot;iv&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double complex _func_cbesi_wrap_e &quot;cbesi_wrap_e&quot;(double, double complex) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cbesi_wrap_e_real &quot;cbesi_wrap_e_real&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_j0 &quot;j0&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_j1 &quot;j1&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double complex _func_cbesj_wrap &quot;cbesj_wrap&quot;(double, double complex) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cbesj_wrap_real &quot;cbesj_wrap_real&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double complex _func_cbesj_wrap_e &quot;cbesj_wrap_e&quot;(double, double complex) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cbesj_wrap_e_real &quot;cbesj_wrap_e_real&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_k0 &quot;k0&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_k0e &quot;k0e&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_k1 &quot;k1&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_k1e &quot;k1e&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_kei_wrap &quot;kei_wrap&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_keip_wrap &quot;keip_wrap&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_kelvin_wrap &quot;kelvin_wrap&quot;(double, double complex *, double complex *, double complex *, double complex *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_ker_wrap &quot;ker_wrap&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_kerp_wrap &quot;kerp_wrap&quot;(double) noexcept nogil</span>
<span class="s0">from ._convex_analysis cimport kl_div as _func_kl_div</span>
<span class="s0">ctypedef double _proto_kl_div_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_kl_div_t *_proto_kl_div_t_var = &amp;_func_kl_div</span>
<span class="s0">from ._legacy cimport kn_unsafe as _func_kn_unsafe</span>
<span class="s0">ctypedef double _proto_kn_unsafe_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_kn_unsafe_t *_proto_kn_unsafe_t_var = &amp;_func_kn_unsafe</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cbesk_wrap_real_int &quot;cbesk_wrap_real_int&quot;(int, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_kolmogi &quot;kolmogi&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_kolmogorov &quot;kolmogorov&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double complex _func_cbesk_wrap &quot;cbesk_wrap&quot;(double, double complex) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cbesk_wrap_real &quot;cbesk_wrap_real&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double complex _func_cbesk_wrap_e &quot;cbesk_wrap_e&quot;(double, double complex) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cbesk_wrap_e_real &quot;cbesk_wrap_e_real&quot;(double, double) noexcept nogil</span>
<span class="s0">from ._cunity cimport clog1p as _func_clog1p</span>
<span class="s0">ctypedef double complex _proto_clog1p_t(double complex) noexcept nogil</span>
<span class="s0">cdef _proto_clog1p_t *_proto_clog1p_t_var = &amp;_func_clog1p</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_log1p &quot;log1p&quot;(double) noexcept nogil</span>
<span class="s0">from ._loggamma cimport loggamma_real as _func_loggamma_real</span>
<span class="s0">ctypedef double _proto_loggamma_real_t(double) noexcept nogil</span>
<span class="s0">cdef _proto_loggamma_real_t *_proto_loggamma_real_t_var = &amp;_func_loggamma_real</span>
<span class="s0">from ._loggamma cimport loggamma as _func_loggamma</span>
<span class="s0">ctypedef double complex _proto_loggamma_t(double complex) noexcept nogil</span>
<span class="s0">cdef _proto_loggamma_t *_proto_loggamma_t_var = &amp;_func_loggamma</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_pmv_wrap &quot;pmv_wrap&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cem_cva_wrap &quot;cem_cva_wrap&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_sem_cva_wrap &quot;sem_cva_wrap&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_cem_wrap &quot;cem_wrap&quot;(double, double, double, double *, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_mcm1_wrap &quot;mcm1_wrap&quot;(double, double, double, double *, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_mcm2_wrap &quot;mcm2_wrap&quot;(double, double, double, double *, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_msm1_wrap &quot;msm1_wrap&quot;(double, double, double, double *, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_msm2_wrap &quot;msm2_wrap&quot;(double, double, double, double *, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_sem_wrap &quot;sem_wrap&quot;(double, double, double, double *, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_modified_fresnel_minus_wrap &quot;modified_fresnel_minus_wrap&quot;(double, double complex *, double complex *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_modified_fresnel_plus_wrap &quot;modified_fresnel_plus_wrap&quot;(double, double complex *, double complex *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_struve_l &quot;struve_l&quot;(double, double) noexcept nogil</span>
<span class="s0">from ._legacy cimport nbdtr_unsafe as _func_nbdtr_unsafe</span>
<span class="s0">ctypedef double _proto_nbdtr_unsafe_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_nbdtr_unsafe_t *_proto_nbdtr_unsafe_t_var = &amp;_func_nbdtr_unsafe</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_nbdtr &quot;nbdtr&quot;(int, int, double) noexcept nogil</span>
<span class="s0">from ._legacy cimport nbdtrc_unsafe as _func_nbdtrc_unsafe</span>
<span class="s0">ctypedef double _proto_nbdtrc_unsafe_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_nbdtrc_unsafe_t *_proto_nbdtrc_unsafe_t_var = &amp;_func_nbdtrc_unsafe</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_nbdtrc &quot;nbdtrc&quot;(int, int, double) noexcept nogil</span>
<span class="s0">from ._legacy cimport nbdtri_unsafe as _func_nbdtri_unsafe</span>
<span class="s0">ctypedef double _proto_nbdtri_unsafe_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_nbdtri_unsafe_t *_proto_nbdtri_unsafe_t_var = &amp;_func_nbdtri_unsafe</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_nbdtri &quot;nbdtri&quot;(int, int, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cdfnbn2_wrap &quot;cdfnbn2_wrap&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cdfnbn3_wrap &quot;cdfnbn3_wrap&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cdffnc1_wrap &quot;cdffnc1_wrap&quot;(double, double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cdffnc2_wrap &quot;cdffnc2_wrap&quot;(double, double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cdffnc4_wrap &quot;cdffnc4_wrap&quot;(double, double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cdffnc3_wrap &quot;cdffnc3_wrap&quot;(double, double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cdffnc5_wrap &quot;cdffnc5_wrap&quot;(double, double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cdftnc1_wrap &quot;cdftnc1_wrap&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cdftnc3_wrap &quot;cdftnc3_wrap&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cdftnc4_wrap &quot;cdftnc4_wrap&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cdftnc2_wrap &quot;cdftnc2_wrap&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_ndtr &quot;ndtr&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_ndtri &quot;ndtri&quot;(double) noexcept nogil</span>
<span class="s0">from ._ndtri_exp cimport ndtri_exp as _func_ndtri_exp</span>
<span class="s0">ctypedef double _proto_ndtri_exp_t(double) noexcept nogil</span>
<span class="s0">cdef _proto_ndtri_exp_t *_proto_ndtri_exp_t_var = &amp;_func_ndtri_exp</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cdfnor3_wrap &quot;cdfnor3_wrap&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cdfnor4_wrap &quot;cdfnor4_wrap&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_oblate_aswfa_nocv_wrap &quot;oblate_aswfa_nocv_wrap&quot;(double, double, double, double, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_oblate_aswfa_wrap &quot;oblate_aswfa_wrap&quot;(double, double, double, double, double, double *, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_oblate_segv_wrap &quot;oblate_segv_wrap&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_oblate_radial1_nocv_wrap &quot;oblate_radial1_nocv_wrap&quot;(double, double, double, double, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_oblate_radial1_wrap &quot;oblate_radial1_wrap&quot;(double, double, double, double, double, double *, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_oblate_radial2_nocv_wrap &quot;oblate_radial2_nocv_wrap&quot;(double, double, double, double, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_oblate_radial2_wrap &quot;oblate_radial2_wrap&quot;(double, double, double, double, double, double *, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_owens_t &quot;owens_t&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_pbdv_wrap &quot;pbdv_wrap&quot;(double, double, double *, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_pbvv_wrap &quot;pbvv_wrap&quot;(double, double, double *, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_pbwa_wrap &quot;pbwa_wrap&quot;(double, double, double *, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_pdtr &quot;pdtr&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_pdtrc &quot;pdtrc&quot;(double, double) noexcept nogil</span>
<span class="s0">from ._legacy cimport pdtri_unsafe as _func_pdtri_unsafe</span>
<span class="s0">ctypedef double _proto_pdtri_unsafe_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_pdtri_unsafe_t *_proto_pdtri_unsafe_t_var = &amp;_func_pdtri_unsafe</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_pdtri &quot;pdtri&quot;(int, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cdfpoi2_wrap &quot;cdfpoi2_wrap&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_poch &quot;poch&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_prolate_aswfa_nocv_wrap &quot;prolate_aswfa_nocv_wrap&quot;(double, double, double, double, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_prolate_aswfa_wrap &quot;prolate_aswfa_wrap&quot;(double, double, double, double, double, double *, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_prolate_segv_wrap &quot;prolate_segv_wrap&quot;(double, double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_prolate_radial1_nocv_wrap &quot;prolate_radial1_nocv_wrap&quot;(double, double, double, double, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_prolate_radial1_wrap &quot;prolate_radial1_wrap&quot;(double, double, double, double, double, double *, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_prolate_radial2_nocv_wrap &quot;prolate_radial2_nocv_wrap&quot;(double, double, double, double, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_prolate_radial2_wrap &quot;prolate_radial2_wrap&quot;(double, double, double, double, double, double *, double *) noexcept nogil</span>
<span class="s0">from ._convex_analysis cimport pseudo_huber as _func_pseudo_huber</span>
<span class="s0">ctypedef double _proto_pseudo_huber_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_pseudo_huber_t *_proto_pseudo_huber_t_var = &amp;_func_pseudo_huber</span>
<span class="s0">from ._digamma cimport cdigamma as _func_cdigamma</span>
<span class="s0">ctypedef double complex _proto_cdigamma_t(double complex) noexcept nogil</span>
<span class="s0">cdef _proto_cdigamma_t *_proto_cdigamma_t_var = &amp;_func_cdigamma</span>
<span class="s0">from ._digamma cimport digamma as _func_digamma</span>
<span class="s0">ctypedef double _proto_digamma_t(double) noexcept nogil</span>
<span class="s0">cdef _proto_digamma_t *_proto_digamma_t_var = &amp;_func_digamma</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_radian &quot;radian&quot;(double, double, double) noexcept nogil</span>
<span class="s0">from ._convex_analysis cimport rel_entr as _func_rel_entr</span>
<span class="s0">ctypedef double _proto_rel_entr_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_rel_entr_t *_proto_rel_entr_t_var = &amp;_func_rel_entr</span>
<span class="s0">from ._loggamma cimport crgamma as _func_crgamma</span>
<span class="s0">ctypedef double complex _proto_crgamma_t(double complex) noexcept nogil</span>
<span class="s0">cdef _proto_crgamma_t *_proto_crgamma_t_var = &amp;_func_crgamma</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_rgamma &quot;rgamma&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_round &quot;round&quot;(double) noexcept nogil</span>
<span class="s0">from ._sici cimport cshichi as _func_cshichi</span>
<span class="s0">ctypedef int _proto_cshichi_t(double complex, double complex *, double complex *) noexcept nogil</span>
<span class="s0">cdef _proto_cshichi_t *_proto_cshichi_t_var = &amp;_func_cshichi</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_shichi &quot;shichi&quot;(double, double *, double *) noexcept nogil</span>
<span class="s0">from ._sici cimport csici as _func_csici</span>
<span class="s0">ctypedef int _proto_csici_t(double complex, double complex *, double complex *) noexcept nogil</span>
<span class="s0">cdef _proto_csici_t *_proto_csici_t_var = &amp;_func_csici</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef int _func_sici &quot;sici&quot;(double, double *, double *) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_sindg &quot;sindg&quot;(double) noexcept nogil</span>
<span class="s0">from ._legacy cimport smirnov_unsafe as _func_smirnov_unsafe</span>
<span class="s0">ctypedef double _proto_smirnov_unsafe_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_smirnov_unsafe_t *_proto_smirnov_unsafe_t_var = &amp;_func_smirnov_unsafe</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_smirnov &quot;smirnov&quot;(int, double) noexcept nogil</span>
<span class="s0">from ._legacy cimport smirnovi_unsafe as _func_smirnovi_unsafe</span>
<span class="s0">ctypedef double _proto_smirnovi_unsafe_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_smirnovi_unsafe_t *_proto_smirnovi_unsafe_t_var = &amp;_func_smirnovi_unsafe</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_smirnovi &quot;smirnovi&quot;(int, double) noexcept nogil</span>
<span class="s0">from ._spence cimport cspence as _func_cspence</span>
<span class="s0">ctypedef double complex _proto_cspence_t(double complex) noexcept nogil</span>
<span class="s0">cdef _proto_cspence_t *_proto_cspence_t_var = &amp;_func_cspence</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_spence &quot;spence&quot;(double) noexcept nogil</span>
<span class="s0">from ._legacy cimport sph_harmonic_unsafe as _func_sph_harmonic_unsafe</span>
<span class="s0">ctypedef double complex _proto_sph_harmonic_unsafe_t(double, double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_sph_harmonic_unsafe_t *_proto_sph_harmonic_unsafe_t_var = &amp;_func_sph_harmonic_unsafe</span>
<span class="s0">from .sph_harm cimport sph_harmonic as _func_sph_harmonic</span>
<span class="s0">ctypedef double complex _proto_sph_harmonic_t(int, int, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_sph_harmonic_t *_proto_sph_harmonic_t_var = &amp;_func_sph_harmonic</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cdft1_wrap &quot;cdft1_wrap&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cdft3_wrap &quot;cdft3_wrap&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cdft2_wrap &quot;cdft2_wrap&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_struve_h &quot;struve_h&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_tandg &quot;tandg&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_tukeylambdacdf &quot;tukeylambdacdf&quot;(double, double) noexcept nogil</span>
<span class="s0">from ._wright_bessel cimport wright_bessel_scalar as _func_wright_bessel_scalar</span>
<span class="s0">ctypedef double _proto_wright_bessel_scalar_t(double, double, double) noexcept nogil</span>
<span class="s0">cdef _proto_wright_bessel_scalar_t *_proto_wright_bessel_scalar_t_var = &amp;_func_wright_bessel_scalar</span>
<span class="s0">from ._xlogy cimport xlog1py as _func_xlog1py</span>
<span class="s0">ctypedef double _proto_xlog1py_double__t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_xlog1py_double__t *_proto_xlog1py_double__t_var = &amp;_func_xlog1py[double]</span>
<span class="s0">from ._xlogy cimport xlog1py as _func_xlog1py</span>
<span class="s0">ctypedef double complex _proto_xlog1py_double_complex__t(double complex, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_xlog1py_double_complex__t *_proto_xlog1py_double_complex__t_var = &amp;_func_xlog1py[double_complex]</span>
<span class="s0">from ._xlogy cimport xlogy as _func_xlogy</span>
<span class="s0">ctypedef double _proto_xlogy_double__t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_xlogy_double__t *_proto_xlogy_double__t_var = &amp;_func_xlogy[double]</span>
<span class="s0">from ._xlogy cimport xlogy as _func_xlogy</span>
<span class="s0">ctypedef double complex _proto_xlogy_double_complex__t(double complex, double complex) noexcept nogil</span>
<span class="s0">cdef _proto_xlogy_double_complex__t *_proto_xlogy_double_complex__t_var = &amp;_func_xlogy[double_complex]</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_y0 &quot;y0&quot;(double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_y1 &quot;y1&quot;(double) noexcept nogil</span>
<span class="s0">from ._legacy cimport yn_unsafe as _func_yn_unsafe</span>
<span class="s0">ctypedef double _proto_yn_unsafe_t(double, double) noexcept nogil</span>
<span class="s0">cdef _proto_yn_unsafe_t *_proto_yn_unsafe_t_var = &amp;_func_yn_unsafe</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_yn &quot;yn&quot;(int, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double complex _func_cbesy_wrap &quot;cbesy_wrap&quot;(double, double complex) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cbesy_wrap_real &quot;cbesy_wrap_real&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double complex _func_cbesy_wrap_e &quot;cbesy_wrap_e&quot;(double, double complex) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_cbesy_wrap_e_real &quot;cbesy_wrap_e_real&quot;(double, double) noexcept nogil</span>
<span class="s0">cdef extern from r&quot;_ufuncs_defs.h&quot;:</span>
    <span class="s0">cdef double _func_zetac &quot;zetac&quot;(double) noexcept nogil</span>
<span class="s0">cdef np.PyUFuncGenericFunction ufunc__cosine_cdf_loops[2]</span>
<span class="s0">cdef void *ufunc__cosine_cdf_ptr[4]</span>
<span class="s0">cdef void *ufunc__cosine_cdf_data[2]</span>
<span class="s0">cdef char ufunc__cosine_cdf_types[4]</span>
<span class="s0">cdef char *ufunc__cosine_cdf_doc = (</span>
    <span class="s0">&quot;_cosine_cdf(x)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Cumulative distribution function (CDF) of the cosine distribution::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;             {             0,              x &lt; -pi\n&quot;</span>
    <span class="s0">&quot;    cdf(x) = { (pi + x + sin(x))/(2*pi),   -pi &lt;= x &lt;= pi\n&quot;</span>
    <span class="s0">&quot;             {             1,              x &gt; pi\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    `x` must contain real numbers.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The cosine distribution CDF evaluated at `x`.&quot;)</span>
<span class="s0">ufunc__cosine_cdf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc__cosine_cdf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc__cosine_cdf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__cosine_cdf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__cosine_cdf_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__cosine_cdf_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__cosine_cdf_ptr[2*0] = &lt;void*&gt;_func_cosine_cdf</span>
<span class="s0">ufunc__cosine_cdf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_cosine_cdf&quot;)</span>
<span class="s0">ufunc__cosine_cdf_ptr[2*1] = &lt;void*&gt;_func_cosine_cdf</span>
<span class="s0">ufunc__cosine_cdf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_cosine_cdf&quot;)</span>
<span class="s0">ufunc__cosine_cdf_data[0] = &amp;ufunc__cosine_cdf_ptr[2*0]</span>
<span class="s0">ufunc__cosine_cdf_data[1] = &amp;ufunc__cosine_cdf_ptr[2*1]</span>
<span class="s0">_cosine_cdf = np.PyUFunc_FromFuncAndData(ufunc__cosine_cdf_loops, ufunc__cosine_cdf_data, ufunc__cosine_cdf_types, 2, 1, 1, 0, &quot;_cosine_cdf&quot;, ufunc__cosine_cdf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__cosine_invcdf_loops[2]</span>
<span class="s0">cdef void *ufunc__cosine_invcdf_ptr[4]</span>
<span class="s0">cdef void *ufunc__cosine_invcdf_data[2]</span>
<span class="s0">cdef char ufunc__cosine_invcdf_types[4]</span>
<span class="s0">cdef char *ufunc__cosine_invcdf_doc = (</span>
    <span class="s0">&quot;_cosine_invcdf(p)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse of the cumulative distribution function (CDF) of the cosine\n&quot;</span>
    <span class="s0">&quot;distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The CDF of the cosine distribution is::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    cdf(x) = (pi + x + sin(x))/(2*pi)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function computes the inverse of cdf(x).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    `p` must contain real numbers in the interval ``0 &lt;= p &lt;= 1``.\n&quot;</span>
    <span class="s0">&quot;    `nan` is returned for values of `p` outside the interval [0, 1].\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The inverse of the cosine distribution CDF evaluated at `p`.&quot;)</span>
<span class="s0">ufunc__cosine_invcdf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc__cosine_invcdf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc__cosine_invcdf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__cosine_invcdf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__cosine_invcdf_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__cosine_invcdf_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__cosine_invcdf_ptr[2*0] = &lt;void*&gt;_func_cosine_invcdf</span>
<span class="s0">ufunc__cosine_invcdf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_cosine_invcdf&quot;)</span>
<span class="s0">ufunc__cosine_invcdf_ptr[2*1] = &lt;void*&gt;_func_cosine_invcdf</span>
<span class="s0">ufunc__cosine_invcdf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_cosine_invcdf&quot;)</span>
<span class="s0">ufunc__cosine_invcdf_data[0] = &amp;ufunc__cosine_invcdf_ptr[2*0]</span>
<span class="s0">ufunc__cosine_invcdf_data[1] = &amp;ufunc__cosine_invcdf_ptr[2*1]</span>
<span class="s0">_cosine_invcdf = np.PyUFunc_FromFuncAndData(ufunc__cosine_invcdf_loops, ufunc__cosine_invcdf_data, ufunc__cosine_invcdf_types, 2, 1, 1, 0, &quot;_cosine_invcdf&quot;, ufunc__cosine_invcdf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__cospi_loops[4]</span>
<span class="s0">cdef void *ufunc__cospi_ptr[8]</span>
<span class="s0">cdef void *ufunc__cospi_data[4]</span>
<span class="s0">cdef char ufunc__cospi_types[8]</span>
<span class="s0">cdef char *ufunc__cospi_doc = (</span>
    <span class="s0">&quot;Internal function, do not use.&quot;)</span>
<span class="s0">ufunc__cospi_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc__cospi_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc__cospi_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_F_F</span>
<span class="s0">ufunc__cospi_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_D_D</span>
<span class="s0">ufunc__cospi_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__cospi_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__cospi_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__cospi_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__cospi_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc__cospi_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc__cospi_types[6] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc__cospi_types[7] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc__cospi_ptr[2*0] = &lt;void*&gt;_func_cospi</span>
<span class="s0">ufunc__cospi_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_cospi&quot;)</span>
<span class="s0">ufunc__cospi_ptr[2*1] = &lt;void*&gt;_func_cospi</span>
<span class="s0">ufunc__cospi_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_cospi&quot;)</span>
<span class="s0">ufunc__cospi_ptr[2*2] = &lt;void*&gt;_func_ccospi</span>
<span class="s0">ufunc__cospi_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_cospi&quot;)</span>
<span class="s0">ufunc__cospi_ptr[2*3] = &lt;void*&gt;_func_ccospi</span>
<span class="s0">ufunc__cospi_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_cospi&quot;)</span>
<span class="s0">ufunc__cospi_data[0] = &amp;ufunc__cospi_ptr[2*0]</span>
<span class="s0">ufunc__cospi_data[1] = &amp;ufunc__cospi_ptr[2*1]</span>
<span class="s0">ufunc__cospi_data[2] = &amp;ufunc__cospi_ptr[2*2]</span>
<span class="s0">ufunc__cospi_data[3] = &amp;ufunc__cospi_ptr[2*3]</span>
<span class="s0">_cospi = np.PyUFunc_FromFuncAndData(ufunc__cospi_loops, ufunc__cospi_data, ufunc__cospi_types, 4, 1, 1, 0, &quot;_cospi&quot;, ufunc__cospi_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__ellip_harm_loops[3]</span>
<span class="s0">cdef void *ufunc__ellip_harm_ptr[6]</span>
<span class="s0">cdef void *ufunc__ellip_harm_data[3]</span>
<span class="s0">cdef char ufunc__ellip_harm_types[24]</span>
<span class="s0">cdef char *ufunc__ellip_harm_doc = (</span>
    <span class="s0">&quot;Internal function, use `ellip_harm` instead.&quot;)</span>
<span class="s0">ufunc__ellip_harm_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddddddd__As_fffffff_f</span>
<span class="s0">ufunc__ellip_harm_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddiiddd__As_ddllddd_d</span>
<span class="s0">ufunc__ellip_harm_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddddddd__As_ddddddd_d</span>
<span class="s0">ufunc__ellip_harm_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ellip_harm_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ellip_harm_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ellip_harm_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ellip_harm_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ellip_harm_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ellip_harm_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ellip_harm_types[7] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__ellip_harm_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ellip_harm_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ellip_harm_types[10] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc__ellip_harm_types[11] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc__ellip_harm_types[12] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ellip_harm_types[13] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ellip_harm_types[14] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ellip_harm_types[15] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ellip_harm_types[16] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ellip_harm_types[17] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ellip_harm_types[18] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ellip_harm_types[19] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ellip_harm_types[20] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ellip_harm_types[21] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ellip_harm_types[22] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ellip_harm_types[23] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__ellip_harm_ptr[2*0] = &lt;void*&gt;_func_ellip_harmonic_unsafe</span>
<span class="s0">ufunc__ellip_harm_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_ellip_harm&quot;)</span>
<span class="s0">ufunc__ellip_harm_ptr[2*1] = &lt;void*&gt;_func_ellip_harmonic</span>
<span class="s0">ufunc__ellip_harm_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_ellip_harm&quot;)</span>
<span class="s0">ufunc__ellip_harm_ptr[2*2] = &lt;void*&gt;_func_ellip_harmonic_unsafe</span>
<span class="s0">ufunc__ellip_harm_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_ellip_harm&quot;)</span>
<span class="s0">ufunc__ellip_harm_data[0] = &amp;ufunc__ellip_harm_ptr[2*0]</span>
<span class="s0">ufunc__ellip_harm_data[1] = &amp;ufunc__ellip_harm_ptr[2*1]</span>
<span class="s0">ufunc__ellip_harm_data[2] = &amp;ufunc__ellip_harm_ptr[2*2]</span>
<span class="s0">_ellip_harm = np.PyUFunc_FromFuncAndData(ufunc__ellip_harm_loops, ufunc__ellip_harm_data, ufunc__ellip_harm_types, 3, 7, 1, 0, &quot;_ellip_harm&quot;, ufunc__ellip_harm_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__factorial_loops[2]</span>
<span class="s0">cdef void *ufunc__factorial_ptr[4]</span>
<span class="s0">cdef void *ufunc__factorial_data[2]</span>
<span class="s0">cdef char ufunc__factorial_types[4]</span>
<span class="s0">cdef char *ufunc__factorial_doc = (</span>
    <span class="s0">&quot;Internal function, do not use.&quot;)</span>
<span class="s0">ufunc__factorial_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc__factorial_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc__factorial_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__factorial_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__factorial_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__factorial_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__factorial_ptr[2*0] = &lt;void*&gt;_func__factorial</span>
<span class="s0">ufunc__factorial_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_factorial&quot;)</span>
<span class="s0">ufunc__factorial_ptr[2*1] = &lt;void*&gt;_func__factorial</span>
<span class="s0">ufunc__factorial_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_factorial&quot;)</span>
<span class="s0">ufunc__factorial_data[0] = &amp;ufunc__factorial_ptr[2*0]</span>
<span class="s0">ufunc__factorial_data[1] = &amp;ufunc__factorial_ptr[2*1]</span>
<span class="s0">_factorial = np.PyUFunc_FromFuncAndData(ufunc__factorial_loops, ufunc__factorial_data, ufunc__factorial_types, 2, 1, 1, 0, &quot;_factorial&quot;, ufunc__factorial_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__igam_fac_loops[2]</span>
<span class="s0">cdef void *ufunc__igam_fac_ptr[4]</span>
<span class="s0">cdef void *ufunc__igam_fac_data[2]</span>
<span class="s0">cdef char ufunc__igam_fac_types[6]</span>
<span class="s0">cdef char *ufunc__igam_fac_doc = (</span>
    <span class="s0">&quot;Internal function, do not use.&quot;)</span>
<span class="s0">ufunc__igam_fac_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc__igam_fac_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc__igam_fac_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__igam_fac_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__igam_fac_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__igam_fac_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__igam_fac_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__igam_fac_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__igam_fac_ptr[2*0] = &lt;void*&gt;_func_igam_fac</span>
<span class="s0">ufunc__igam_fac_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_igam_fac&quot;)</span>
<span class="s0">ufunc__igam_fac_ptr[2*1] = &lt;void*&gt;_func_igam_fac</span>
<span class="s0">ufunc__igam_fac_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_igam_fac&quot;)</span>
<span class="s0">ufunc__igam_fac_data[0] = &amp;ufunc__igam_fac_ptr[2*0]</span>
<span class="s0">ufunc__igam_fac_data[1] = &amp;ufunc__igam_fac_ptr[2*1]</span>
<span class="s0">_igam_fac = np.PyUFunc_FromFuncAndData(ufunc__igam_fac_loops, ufunc__igam_fac_data, ufunc__igam_fac_types, 2, 2, 1, 0, &quot;_igam_fac&quot;, ufunc__igam_fac_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__kolmogc_loops[2]</span>
<span class="s0">cdef void *ufunc__kolmogc_ptr[4]</span>
<span class="s0">cdef void *ufunc__kolmogc_data[2]</span>
<span class="s0">cdef char ufunc__kolmogc_types[4]</span>
<span class="s0">cdef char *ufunc__kolmogc_doc = (</span>
    <span class="s0">&quot;Internal function, do not use.&quot;)</span>
<span class="s0">ufunc__kolmogc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc__kolmogc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc__kolmogc_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__kolmogc_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__kolmogc_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__kolmogc_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__kolmogc_ptr[2*0] = &lt;void*&gt;_func_kolmogc</span>
<span class="s0">ufunc__kolmogc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_kolmogc&quot;)</span>
<span class="s0">ufunc__kolmogc_ptr[2*1] = &lt;void*&gt;_func_kolmogc</span>
<span class="s0">ufunc__kolmogc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_kolmogc&quot;)</span>
<span class="s0">ufunc__kolmogc_data[0] = &amp;ufunc__kolmogc_ptr[2*0]</span>
<span class="s0">ufunc__kolmogc_data[1] = &amp;ufunc__kolmogc_ptr[2*1]</span>
<span class="s0">_kolmogc = np.PyUFunc_FromFuncAndData(ufunc__kolmogc_loops, ufunc__kolmogc_data, ufunc__kolmogc_types, 2, 1, 1, 0, &quot;_kolmogc&quot;, ufunc__kolmogc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__kolmogci_loops[2]</span>
<span class="s0">cdef void *ufunc__kolmogci_ptr[4]</span>
<span class="s0">cdef void *ufunc__kolmogci_data[2]</span>
<span class="s0">cdef char ufunc__kolmogci_types[4]</span>
<span class="s0">cdef char *ufunc__kolmogci_doc = (</span>
    <span class="s0">&quot;Internal function, do not use.&quot;)</span>
<span class="s0">ufunc__kolmogci_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc__kolmogci_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc__kolmogci_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__kolmogci_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__kolmogci_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__kolmogci_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__kolmogci_ptr[2*0] = &lt;void*&gt;_func_kolmogci</span>
<span class="s0">ufunc__kolmogci_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_kolmogci&quot;)</span>
<span class="s0">ufunc__kolmogci_ptr[2*1] = &lt;void*&gt;_func_kolmogci</span>
<span class="s0">ufunc__kolmogci_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_kolmogci&quot;)</span>
<span class="s0">ufunc__kolmogci_data[0] = &amp;ufunc__kolmogci_ptr[2*0]</span>
<span class="s0">ufunc__kolmogci_data[1] = &amp;ufunc__kolmogci_ptr[2*1]</span>
<span class="s0">_kolmogci = np.PyUFunc_FromFuncAndData(ufunc__kolmogci_loops, ufunc__kolmogci_data, ufunc__kolmogci_types, 2, 1, 1, 0, &quot;_kolmogci&quot;, ufunc__kolmogci_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__kolmogp_loops[2]</span>
<span class="s0">cdef void *ufunc__kolmogp_ptr[4]</span>
<span class="s0">cdef void *ufunc__kolmogp_data[2]</span>
<span class="s0">cdef char ufunc__kolmogp_types[4]</span>
<span class="s0">cdef char *ufunc__kolmogp_doc = (</span>
    <span class="s0">&quot;Internal function, do not use.&quot;)</span>
<span class="s0">ufunc__kolmogp_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc__kolmogp_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc__kolmogp_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__kolmogp_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__kolmogp_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__kolmogp_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__kolmogp_ptr[2*0] = &lt;void*&gt;_func_kolmogp</span>
<span class="s0">ufunc__kolmogp_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_kolmogp&quot;)</span>
<span class="s0">ufunc__kolmogp_ptr[2*1] = &lt;void*&gt;_func_kolmogp</span>
<span class="s0">ufunc__kolmogp_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_kolmogp&quot;)</span>
<span class="s0">ufunc__kolmogp_data[0] = &amp;ufunc__kolmogp_ptr[2*0]</span>
<span class="s0">ufunc__kolmogp_data[1] = &amp;ufunc__kolmogp_ptr[2*1]</span>
<span class="s0">_kolmogp = np.PyUFunc_FromFuncAndData(ufunc__kolmogp_loops, ufunc__kolmogp_data, ufunc__kolmogp_types, 2, 1, 1, 0, &quot;_kolmogp&quot;, ufunc__kolmogp_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__lambertw_loops[1]</span>
<span class="s0">cdef void *ufunc__lambertw_ptr[2]</span>
<span class="s0">cdef void *ufunc__lambertw_data[1]</span>
<span class="s0">cdef char ufunc__lambertw_types[4]</span>
<span class="s0">cdef char *ufunc__lambertw_doc = (</span>
    <span class="s0">&quot;Internal function, use `lambertw` instead.&quot;)</span>
<span class="s0">ufunc__lambertw_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_D_Dld__As_Dld_D</span>
<span class="s0">ufunc__lambertw_types[0] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc__lambertw_types[1] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc__lambertw_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__lambertw_types[3] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc__lambertw_ptr[2*0] = &lt;void*&gt;_func_lambertw_scalar</span>
<span class="s0">ufunc__lambertw_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_lambertw&quot;)</span>
<span class="s0">ufunc__lambertw_data[0] = &amp;ufunc__lambertw_ptr[2*0]</span>
<span class="s0">_lambertw = np.PyUFunc_FromFuncAndData(ufunc__lambertw_loops, ufunc__lambertw_data, ufunc__lambertw_types, 1, 3, 1, 0, &quot;_lambertw&quot;, ufunc__lambertw_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__lanczos_sum_expg_scaled_loops[2]</span>
<span class="s0">cdef void *ufunc__lanczos_sum_expg_scaled_ptr[4]</span>
<span class="s0">cdef void *ufunc__lanczos_sum_expg_scaled_data[2]</span>
<span class="s0">cdef char ufunc__lanczos_sum_expg_scaled_types[4]</span>
<span class="s0">cdef char *ufunc__lanczos_sum_expg_scaled_doc = (</span>
    <span class="s0">&quot;Internal function, do not use.&quot;)</span>
<span class="s0">ufunc__lanczos_sum_expg_scaled_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc__lanczos_sum_expg_scaled_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc__lanczos_sum_expg_scaled_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__lanczos_sum_expg_scaled_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__lanczos_sum_expg_scaled_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__lanczos_sum_expg_scaled_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__lanczos_sum_expg_scaled_ptr[2*0] = &lt;void*&gt;_func_lanczos_sum_expg_scaled</span>
<span class="s0">ufunc__lanczos_sum_expg_scaled_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_lanczos_sum_expg_scaled&quot;)</span>
<span class="s0">ufunc__lanczos_sum_expg_scaled_ptr[2*1] = &lt;void*&gt;_func_lanczos_sum_expg_scaled</span>
<span class="s0">ufunc__lanczos_sum_expg_scaled_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_lanczos_sum_expg_scaled&quot;)</span>
<span class="s0">ufunc__lanczos_sum_expg_scaled_data[0] = &amp;ufunc__lanczos_sum_expg_scaled_ptr[2*0]</span>
<span class="s0">ufunc__lanczos_sum_expg_scaled_data[1] = &amp;ufunc__lanczos_sum_expg_scaled_ptr[2*1]</span>
<span class="s0">_lanczos_sum_expg_scaled = np.PyUFunc_FromFuncAndData(ufunc__lanczos_sum_expg_scaled_loops, ufunc__lanczos_sum_expg_scaled_data, ufunc__lanczos_sum_expg_scaled_types, 2, 1, 1, 0, &quot;_lanczos_sum_expg_scaled&quot;, ufunc__lanczos_sum_expg_scaled_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__lgam1p_loops[2]</span>
<span class="s0">cdef void *ufunc__lgam1p_ptr[4]</span>
<span class="s0">cdef void *ufunc__lgam1p_data[2]</span>
<span class="s0">cdef char ufunc__lgam1p_types[4]</span>
<span class="s0">cdef char *ufunc__lgam1p_doc = (</span>
    <span class="s0">&quot;Internal function, do not use.&quot;)</span>
<span class="s0">ufunc__lgam1p_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc__lgam1p_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc__lgam1p_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__lgam1p_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__lgam1p_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__lgam1p_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__lgam1p_ptr[2*0] = &lt;void*&gt;_func_lgam1p</span>
<span class="s0">ufunc__lgam1p_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_lgam1p&quot;)</span>
<span class="s0">ufunc__lgam1p_ptr[2*1] = &lt;void*&gt;_func_lgam1p</span>
<span class="s0">ufunc__lgam1p_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_lgam1p&quot;)</span>
<span class="s0">ufunc__lgam1p_data[0] = &amp;ufunc__lgam1p_ptr[2*0]</span>
<span class="s0">ufunc__lgam1p_data[1] = &amp;ufunc__lgam1p_ptr[2*1]</span>
<span class="s0">_lgam1p = np.PyUFunc_FromFuncAndData(ufunc__lgam1p_loops, ufunc__lgam1p_data, ufunc__lgam1p_types, 2, 1, 1, 0, &quot;_lgam1p&quot;, ufunc__lgam1p_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__log1pmx_loops[2]</span>
<span class="s0">cdef void *ufunc__log1pmx_ptr[4]</span>
<span class="s0">cdef void *ufunc__log1pmx_data[2]</span>
<span class="s0">cdef char ufunc__log1pmx_types[4]</span>
<span class="s0">cdef char *ufunc__log1pmx_doc = (</span>
    <span class="s0">&quot;Internal function, do not use.&quot;)</span>
<span class="s0">ufunc__log1pmx_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc__log1pmx_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc__log1pmx_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__log1pmx_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__log1pmx_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__log1pmx_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__log1pmx_ptr[2*0] = &lt;void*&gt;_func_log1pmx</span>
<span class="s0">ufunc__log1pmx_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_log1pmx&quot;)</span>
<span class="s0">ufunc__log1pmx_ptr[2*1] = &lt;void*&gt;_func_log1pmx</span>
<span class="s0">ufunc__log1pmx_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_log1pmx&quot;)</span>
<span class="s0">ufunc__log1pmx_data[0] = &amp;ufunc__log1pmx_ptr[2*0]</span>
<span class="s0">ufunc__log1pmx_data[1] = &amp;ufunc__log1pmx_ptr[2*1]</span>
<span class="s0">_log1pmx = np.PyUFunc_FromFuncAndData(ufunc__log1pmx_loops, ufunc__log1pmx_data, ufunc__log1pmx_types, 2, 1, 1, 0, &quot;_log1pmx&quot;, ufunc__log1pmx_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__riemann_zeta_loops[2]</span>
<span class="s0">cdef void *ufunc__riemann_zeta_ptr[4]</span>
<span class="s0">cdef void *ufunc__riemann_zeta_data[2]</span>
<span class="s0">cdef char ufunc__riemann_zeta_types[4]</span>
<span class="s0">cdef char *ufunc__riemann_zeta_doc = (</span>
    <span class="s0">&quot;Internal function, use `zeta` instead.&quot;)</span>
<span class="s0">ufunc__riemann_zeta_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc__riemann_zeta_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc__riemann_zeta_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__riemann_zeta_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__riemann_zeta_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__riemann_zeta_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__riemann_zeta_ptr[2*0] = &lt;void*&gt;_func_riemann_zeta</span>
<span class="s0">ufunc__riemann_zeta_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_riemann_zeta&quot;)</span>
<span class="s0">ufunc__riemann_zeta_ptr[2*1] = &lt;void*&gt;_func_riemann_zeta</span>
<span class="s0">ufunc__riemann_zeta_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_riemann_zeta&quot;)</span>
<span class="s0">ufunc__riemann_zeta_data[0] = &amp;ufunc__riemann_zeta_ptr[2*0]</span>
<span class="s0">ufunc__riemann_zeta_data[1] = &amp;ufunc__riemann_zeta_ptr[2*1]</span>
<span class="s0">_riemann_zeta = np.PyUFunc_FromFuncAndData(ufunc__riemann_zeta_loops, ufunc__riemann_zeta_data, ufunc__riemann_zeta_types, 2, 1, 1, 0, &quot;_riemann_zeta&quot;, ufunc__riemann_zeta_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__scaled_exp1_loops[2]</span>
<span class="s0">cdef void *ufunc__scaled_exp1_ptr[4]</span>
<span class="s0">cdef void *ufunc__scaled_exp1_data[2]</span>
<span class="s0">cdef char ufunc__scaled_exp1_types[4]</span>
<span class="s0">cdef char *ufunc__scaled_exp1_doc = (</span>
    <span class="s0">&quot;_scaled_exp1(x, out=None):\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the scaled exponential integral.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This is a private function, subject to change or removal with no\n&quot;</span>
    <span class="s0">&quot;deprecation.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function computes F(x), where F is the factor remaining in E_1(x)\n&quot;</span>
    <span class="s0">&quot;when exp(-x)/x is factored out.  That is,::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    E_1(x) = exp(-x)/x * F(x)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;or\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    F(x) = x * exp(x) * E_1(x)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function is defined for real x &gt;= 0.  For x &lt; 0, nan is returned.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;F has the properties:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;* F(0) = 0\n&quot;</span>
    <span class="s0">&quot;* F(x) is increasing on [0, inf).\n&quot;</span>
    <span class="s0">&quot;* The limit as x goes to infinity of F(x) is 1.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x: array_like\n&quot;</span>
    <span class="s0">&quot;    The input values. Must be real.  The implementation is limited to\n&quot;</span>
    <span class="s0">&quot;    double precision floating point, so other types will be cast to\n&quot;</span>
    <span class="s0">&quot;    to double precision.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the scaled exponential integral.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;exp1 : exponential integral E_1\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import _scaled_exp1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; _scaled_exp1([0, 0.1, 1, 10, 100])&quot;)</span>
<span class="s0">ufunc__scaled_exp1_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc__scaled_exp1_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc__scaled_exp1_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__scaled_exp1_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__scaled_exp1_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__scaled_exp1_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__scaled_exp1_ptr[2*0] = &lt;void*&gt;_func_scaled_exp1</span>
<span class="s0">ufunc__scaled_exp1_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_scaled_exp1&quot;)</span>
<span class="s0">ufunc__scaled_exp1_ptr[2*1] = &lt;void*&gt;_func_scaled_exp1</span>
<span class="s0">ufunc__scaled_exp1_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_scaled_exp1&quot;)</span>
<span class="s0">ufunc__scaled_exp1_data[0] = &amp;ufunc__scaled_exp1_ptr[2*0]</span>
<span class="s0">ufunc__scaled_exp1_data[1] = &amp;ufunc__scaled_exp1_ptr[2*1]</span>
<span class="s0">_scaled_exp1 = np.PyUFunc_FromFuncAndData(ufunc__scaled_exp1_loops, ufunc__scaled_exp1_data, ufunc__scaled_exp1_types, 2, 1, 1, 0, &quot;_scaled_exp1&quot;, ufunc__scaled_exp1_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__sf_error_test_function_loops[1]</span>
<span class="s0">cdef void *ufunc__sf_error_test_function_ptr[2]</span>
<span class="s0">cdef void *ufunc__sf_error_test_function_data[1]</span>
<span class="s0">cdef char ufunc__sf_error_test_function_types[2]</span>
<span class="s0">cdef char *ufunc__sf_error_test_function_doc = (</span>
    <span class="s0">&quot;Private function; do not use.&quot;)</span>
<span class="s0">ufunc__sf_error_test_function_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_i__As_l_l</span>
<span class="s0">ufunc__sf_error_test_function_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc__sf_error_test_function_types[1] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc__sf_error_test_function_ptr[2*0] = &lt;void*&gt;_func__sf_error_test_function</span>
<span class="s0">ufunc__sf_error_test_function_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_sf_error_test_function&quot;)</span>
<span class="s0">ufunc__sf_error_test_function_data[0] = &amp;ufunc__sf_error_test_function_ptr[2*0]</span>
<span class="s0">_sf_error_test_function = np.PyUFunc_FromFuncAndData(ufunc__sf_error_test_function_loops, ufunc__sf_error_test_function_data, ufunc__sf_error_test_function_types, 1, 1, 1, 0, &quot;_sf_error_test_function&quot;, ufunc__sf_error_test_function_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__sinpi_loops[4]</span>
<span class="s0">cdef void *ufunc__sinpi_ptr[8]</span>
<span class="s0">cdef void *ufunc__sinpi_data[4]</span>
<span class="s0">cdef char ufunc__sinpi_types[8]</span>
<span class="s0">cdef char *ufunc__sinpi_doc = (</span>
    <span class="s0">&quot;Internal function, do not use.&quot;)</span>
<span class="s0">ufunc__sinpi_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc__sinpi_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc__sinpi_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_F_F</span>
<span class="s0">ufunc__sinpi_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_D_D</span>
<span class="s0">ufunc__sinpi_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__sinpi_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__sinpi_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__sinpi_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__sinpi_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc__sinpi_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc__sinpi_types[6] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc__sinpi_types[7] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc__sinpi_ptr[2*0] = &lt;void*&gt;_func_sinpi</span>
<span class="s0">ufunc__sinpi_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_sinpi&quot;)</span>
<span class="s0">ufunc__sinpi_ptr[2*1] = &lt;void*&gt;_func_sinpi</span>
<span class="s0">ufunc__sinpi_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_sinpi&quot;)</span>
<span class="s0">ufunc__sinpi_ptr[2*2] = &lt;void*&gt;_func_csinpi</span>
<span class="s0">ufunc__sinpi_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_sinpi&quot;)</span>
<span class="s0">ufunc__sinpi_ptr[2*3] = &lt;void*&gt;_func_csinpi</span>
<span class="s0">ufunc__sinpi_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_sinpi&quot;)</span>
<span class="s0">ufunc__sinpi_data[0] = &amp;ufunc__sinpi_ptr[2*0]</span>
<span class="s0">ufunc__sinpi_data[1] = &amp;ufunc__sinpi_ptr[2*1]</span>
<span class="s0">ufunc__sinpi_data[2] = &amp;ufunc__sinpi_ptr[2*2]</span>
<span class="s0">ufunc__sinpi_data[3] = &amp;ufunc__sinpi_ptr[2*3]</span>
<span class="s0">_sinpi = np.PyUFunc_FromFuncAndData(ufunc__sinpi_loops, ufunc__sinpi_data, ufunc__sinpi_types, 4, 1, 1, 0, &quot;_sinpi&quot;, ufunc__sinpi_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__smirnovc_loops[3]</span>
<span class="s0">cdef void *ufunc__smirnovc_ptr[6]</span>
<span class="s0">cdef void *ufunc__smirnovc_data[3]</span>
<span class="s0">cdef char ufunc__smirnovc_types[9]</span>
<span class="s0">cdef char *ufunc__smirnovc_doc = (</span>
    <span class="s0">&quot;_smirnovc(n, d)\n&quot;</span>
    <span class="s0">&quot; Internal function, do not use.&quot;)</span>
<span class="s0">ufunc__smirnovc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_id__As_ld_d</span>
<span class="s0">ufunc__smirnovc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc__smirnovc_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc__smirnovc_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc__smirnovc_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__smirnovc_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__smirnovc_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__smirnovc_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__smirnovc_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__smirnovc_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__smirnovc_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__smirnovc_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__smirnovc_ptr[2*0] = &lt;void*&gt;_func_smirnovc</span>
<span class="s0">ufunc__smirnovc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_smirnovc&quot;)</span>
<span class="s0">ufunc__smirnovc_ptr[2*1] = &lt;void*&gt;_func_smirnovc_unsafe</span>
<span class="s0">ufunc__smirnovc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_smirnovc&quot;)</span>
<span class="s0">ufunc__smirnovc_ptr[2*2] = &lt;void*&gt;_func_smirnovc_unsafe</span>
<span class="s0">ufunc__smirnovc_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_smirnovc&quot;)</span>
<span class="s0">ufunc__smirnovc_data[0] = &amp;ufunc__smirnovc_ptr[2*0]</span>
<span class="s0">ufunc__smirnovc_data[1] = &amp;ufunc__smirnovc_ptr[2*1]</span>
<span class="s0">ufunc__smirnovc_data[2] = &amp;ufunc__smirnovc_ptr[2*2]</span>
<span class="s0">_smirnovc = np.PyUFunc_FromFuncAndData(ufunc__smirnovc_loops, ufunc__smirnovc_data, ufunc__smirnovc_types, 3, 2, 1, 0, &quot;_smirnovc&quot;, ufunc__smirnovc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__smirnovci_loops[3]</span>
<span class="s0">cdef void *ufunc__smirnovci_ptr[6]</span>
<span class="s0">cdef void *ufunc__smirnovci_data[3]</span>
<span class="s0">cdef char ufunc__smirnovci_types[9]</span>
<span class="s0">cdef char *ufunc__smirnovci_doc = (</span>
    <span class="s0">&quot;Internal function, do not use.&quot;)</span>
<span class="s0">ufunc__smirnovci_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_id__As_ld_d</span>
<span class="s0">ufunc__smirnovci_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc__smirnovci_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc__smirnovci_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc__smirnovci_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__smirnovci_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__smirnovci_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__smirnovci_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__smirnovci_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__smirnovci_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__smirnovci_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__smirnovci_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__smirnovci_ptr[2*0] = &lt;void*&gt;_func_smirnovci</span>
<span class="s0">ufunc__smirnovci_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_smirnovci&quot;)</span>
<span class="s0">ufunc__smirnovci_ptr[2*1] = &lt;void*&gt;_func_smirnovci_unsafe</span>
<span class="s0">ufunc__smirnovci_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_smirnovci&quot;)</span>
<span class="s0">ufunc__smirnovci_ptr[2*2] = &lt;void*&gt;_func_smirnovci_unsafe</span>
<span class="s0">ufunc__smirnovci_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_smirnovci&quot;)</span>
<span class="s0">ufunc__smirnovci_data[0] = &amp;ufunc__smirnovci_ptr[2*0]</span>
<span class="s0">ufunc__smirnovci_data[1] = &amp;ufunc__smirnovci_ptr[2*1]</span>
<span class="s0">ufunc__smirnovci_data[2] = &amp;ufunc__smirnovci_ptr[2*2]</span>
<span class="s0">_smirnovci = np.PyUFunc_FromFuncAndData(ufunc__smirnovci_loops, ufunc__smirnovci_data, ufunc__smirnovci_types, 3, 2, 1, 0, &quot;_smirnovci&quot;, ufunc__smirnovci_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__smirnovp_loops[3]</span>
<span class="s0">cdef void *ufunc__smirnovp_ptr[6]</span>
<span class="s0">cdef void *ufunc__smirnovp_data[3]</span>
<span class="s0">cdef char ufunc__smirnovp_types[9]</span>
<span class="s0">cdef char *ufunc__smirnovp_doc = (</span>
    <span class="s0">&quot;_smirnovp(n, p)\n&quot;</span>
    <span class="s0">&quot; Internal function, do not use.&quot;)</span>
<span class="s0">ufunc__smirnovp_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_id__As_ld_d</span>
<span class="s0">ufunc__smirnovp_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc__smirnovp_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc__smirnovp_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc__smirnovp_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__smirnovp_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__smirnovp_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__smirnovp_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__smirnovp_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__smirnovp_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__smirnovp_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__smirnovp_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__smirnovp_ptr[2*0] = &lt;void*&gt;_func_smirnovp</span>
<span class="s0">ufunc__smirnovp_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_smirnovp&quot;)</span>
<span class="s0">ufunc__smirnovp_ptr[2*1] = &lt;void*&gt;_func_smirnovp_unsafe</span>
<span class="s0">ufunc__smirnovp_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_smirnovp&quot;)</span>
<span class="s0">ufunc__smirnovp_ptr[2*2] = &lt;void*&gt;_func_smirnovp_unsafe</span>
<span class="s0">ufunc__smirnovp_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_smirnovp&quot;)</span>
<span class="s0">ufunc__smirnovp_data[0] = &amp;ufunc__smirnovp_ptr[2*0]</span>
<span class="s0">ufunc__smirnovp_data[1] = &amp;ufunc__smirnovp_ptr[2*1]</span>
<span class="s0">ufunc__smirnovp_data[2] = &amp;ufunc__smirnovp_ptr[2*2]</span>
<span class="s0">_smirnovp = np.PyUFunc_FromFuncAndData(ufunc__smirnovp_loops, ufunc__smirnovp_data, ufunc__smirnovp_types, 3, 2, 1, 0, &quot;_smirnovp&quot;, ufunc__smirnovp_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__spherical_in_loops[2]</span>
<span class="s0">cdef void *ufunc__spherical_in_ptr[4]</span>
<span class="s0">cdef void *ufunc__spherical_in_data[2]</span>
<span class="s0">cdef char ufunc__spherical_in_types[6]</span>
<span class="s0">cdef char *ufunc__spherical_in_doc = (</span>
    <span class="s0">&quot;Internal function, use `spherical_in` instead.&quot;)</span>
<span class="s0">ufunc__spherical_in_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ld__As_ld_d</span>
<span class="s0">ufunc__spherical_in_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_D_lD__As_lD_D</span>
<span class="s0">ufunc__spherical_in_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc__spherical_in_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__spherical_in_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__spherical_in_types[3] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc__spherical_in_types[4] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc__spherical_in_types[5] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc__spherical_in_ptr[2*0] = &lt;void*&gt;_func_spherical_in_real</span>
<span class="s0">ufunc__spherical_in_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_spherical_in&quot;)</span>
<span class="s0">ufunc__spherical_in_ptr[2*1] = &lt;void*&gt;_func_spherical_in_complex</span>
<span class="s0">ufunc__spherical_in_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_spherical_in&quot;)</span>
<span class="s0">ufunc__spherical_in_data[0] = &amp;ufunc__spherical_in_ptr[2*0]</span>
<span class="s0">ufunc__spherical_in_data[1] = &amp;ufunc__spherical_in_ptr[2*1]</span>
<span class="s0">_spherical_in = np.PyUFunc_FromFuncAndData(ufunc__spherical_in_loops, ufunc__spherical_in_data, ufunc__spherical_in_types, 2, 2, 1, 0, &quot;_spherical_in&quot;, ufunc__spherical_in_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__spherical_in_d_loops[2]</span>
<span class="s0">cdef void *ufunc__spherical_in_d_ptr[4]</span>
<span class="s0">cdef void *ufunc__spherical_in_d_data[2]</span>
<span class="s0">cdef char ufunc__spherical_in_d_types[6]</span>
<span class="s0">cdef char *ufunc__spherical_in_d_doc = (</span>
    <span class="s0">&quot;Internal function, use `spherical_in` instead.&quot;)</span>
<span class="s0">ufunc__spherical_in_d_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ld__As_ld_d</span>
<span class="s0">ufunc__spherical_in_d_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_D_lD__As_lD_D</span>
<span class="s0">ufunc__spherical_in_d_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc__spherical_in_d_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__spherical_in_d_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__spherical_in_d_types[3] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc__spherical_in_d_types[4] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc__spherical_in_d_types[5] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc__spherical_in_d_ptr[2*0] = &lt;void*&gt;_func_spherical_in_d_real</span>
<span class="s0">ufunc__spherical_in_d_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_spherical_in_d&quot;)</span>
<span class="s0">ufunc__spherical_in_d_ptr[2*1] = &lt;void*&gt;_func_spherical_in_d_complex</span>
<span class="s0">ufunc__spherical_in_d_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_spherical_in_d&quot;)</span>
<span class="s0">ufunc__spherical_in_d_data[0] = &amp;ufunc__spherical_in_d_ptr[2*0]</span>
<span class="s0">ufunc__spherical_in_d_data[1] = &amp;ufunc__spherical_in_d_ptr[2*1]</span>
<span class="s0">_spherical_in_d = np.PyUFunc_FromFuncAndData(ufunc__spherical_in_d_loops, ufunc__spherical_in_d_data, ufunc__spherical_in_d_types, 2, 2, 1, 0, &quot;_spherical_in_d&quot;, ufunc__spherical_in_d_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__spherical_jn_loops[2]</span>
<span class="s0">cdef void *ufunc__spherical_jn_ptr[4]</span>
<span class="s0">cdef void *ufunc__spherical_jn_data[2]</span>
<span class="s0">cdef char ufunc__spherical_jn_types[6]</span>
<span class="s0">cdef char *ufunc__spherical_jn_doc = (</span>
    <span class="s0">&quot;Internal function, use `spherical_jn` instead.&quot;)</span>
<span class="s0">ufunc__spherical_jn_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ld__As_ld_d</span>
<span class="s0">ufunc__spherical_jn_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_D_lD__As_lD_D</span>
<span class="s0">ufunc__spherical_jn_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc__spherical_jn_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__spherical_jn_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__spherical_jn_types[3] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc__spherical_jn_types[4] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc__spherical_jn_types[5] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc__spherical_jn_ptr[2*0] = &lt;void*&gt;_func_spherical_jn_real</span>
<span class="s0">ufunc__spherical_jn_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_spherical_jn&quot;)</span>
<span class="s0">ufunc__spherical_jn_ptr[2*1] = &lt;void*&gt;_func_spherical_jn_complex</span>
<span class="s0">ufunc__spherical_jn_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_spherical_jn&quot;)</span>
<span class="s0">ufunc__spherical_jn_data[0] = &amp;ufunc__spherical_jn_ptr[2*0]</span>
<span class="s0">ufunc__spherical_jn_data[1] = &amp;ufunc__spherical_jn_ptr[2*1]</span>
<span class="s0">_spherical_jn = np.PyUFunc_FromFuncAndData(ufunc__spherical_jn_loops, ufunc__spherical_jn_data, ufunc__spherical_jn_types, 2, 2, 1, 0, &quot;_spherical_jn&quot;, ufunc__spherical_jn_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__spherical_jn_d_loops[2]</span>
<span class="s0">cdef void *ufunc__spherical_jn_d_ptr[4]</span>
<span class="s0">cdef void *ufunc__spherical_jn_d_data[2]</span>
<span class="s0">cdef char ufunc__spherical_jn_d_types[6]</span>
<span class="s0">cdef char *ufunc__spherical_jn_d_doc = (</span>
    <span class="s0">&quot;Internal function, use `spherical_jn` instead.&quot;)</span>
<span class="s0">ufunc__spherical_jn_d_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ld__As_ld_d</span>
<span class="s0">ufunc__spherical_jn_d_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_D_lD__As_lD_D</span>
<span class="s0">ufunc__spherical_jn_d_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc__spherical_jn_d_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__spherical_jn_d_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__spherical_jn_d_types[3] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc__spherical_jn_d_types[4] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc__spherical_jn_d_types[5] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc__spherical_jn_d_ptr[2*0] = &lt;void*&gt;_func_spherical_jn_d_real</span>
<span class="s0">ufunc__spherical_jn_d_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_spherical_jn_d&quot;)</span>
<span class="s0">ufunc__spherical_jn_d_ptr[2*1] = &lt;void*&gt;_func_spherical_jn_d_complex</span>
<span class="s0">ufunc__spherical_jn_d_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_spherical_jn_d&quot;)</span>
<span class="s0">ufunc__spherical_jn_d_data[0] = &amp;ufunc__spherical_jn_d_ptr[2*0]</span>
<span class="s0">ufunc__spherical_jn_d_data[1] = &amp;ufunc__spherical_jn_d_ptr[2*1]</span>
<span class="s0">_spherical_jn_d = np.PyUFunc_FromFuncAndData(ufunc__spherical_jn_d_loops, ufunc__spherical_jn_d_data, ufunc__spherical_jn_d_types, 2, 2, 1, 0, &quot;_spherical_jn_d&quot;, ufunc__spherical_jn_d_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__spherical_kn_loops[2]</span>
<span class="s0">cdef void *ufunc__spherical_kn_ptr[4]</span>
<span class="s0">cdef void *ufunc__spherical_kn_data[2]</span>
<span class="s0">cdef char ufunc__spherical_kn_types[6]</span>
<span class="s0">cdef char *ufunc__spherical_kn_doc = (</span>
    <span class="s0">&quot;Internal function, use `spherical_kn` instead.&quot;)</span>
<span class="s0">ufunc__spherical_kn_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ld__As_ld_d</span>
<span class="s0">ufunc__spherical_kn_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_D_lD__As_lD_D</span>
<span class="s0">ufunc__spherical_kn_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc__spherical_kn_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__spherical_kn_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__spherical_kn_types[3] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc__spherical_kn_types[4] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc__spherical_kn_types[5] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc__spherical_kn_ptr[2*0] = &lt;void*&gt;_func_spherical_kn_real</span>
<span class="s0">ufunc__spherical_kn_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_spherical_kn&quot;)</span>
<span class="s0">ufunc__spherical_kn_ptr[2*1] = &lt;void*&gt;_func_spherical_kn_complex</span>
<span class="s0">ufunc__spherical_kn_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_spherical_kn&quot;)</span>
<span class="s0">ufunc__spherical_kn_data[0] = &amp;ufunc__spherical_kn_ptr[2*0]</span>
<span class="s0">ufunc__spherical_kn_data[1] = &amp;ufunc__spherical_kn_ptr[2*1]</span>
<span class="s0">_spherical_kn = np.PyUFunc_FromFuncAndData(ufunc__spherical_kn_loops, ufunc__spherical_kn_data, ufunc__spherical_kn_types, 2, 2, 1, 0, &quot;_spherical_kn&quot;, ufunc__spherical_kn_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__spherical_kn_d_loops[2]</span>
<span class="s0">cdef void *ufunc__spherical_kn_d_ptr[4]</span>
<span class="s0">cdef void *ufunc__spherical_kn_d_data[2]</span>
<span class="s0">cdef char ufunc__spherical_kn_d_types[6]</span>
<span class="s0">cdef char *ufunc__spherical_kn_d_doc = (</span>
    <span class="s0">&quot;Internal function, use `spherical_kn` instead.&quot;)</span>
<span class="s0">ufunc__spherical_kn_d_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ld__As_ld_d</span>
<span class="s0">ufunc__spherical_kn_d_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_D_lD__As_lD_D</span>
<span class="s0">ufunc__spherical_kn_d_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc__spherical_kn_d_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__spherical_kn_d_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__spherical_kn_d_types[3] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc__spherical_kn_d_types[4] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc__spherical_kn_d_types[5] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc__spherical_kn_d_ptr[2*0] = &lt;void*&gt;_func_spherical_kn_d_real</span>
<span class="s0">ufunc__spherical_kn_d_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_spherical_kn_d&quot;)</span>
<span class="s0">ufunc__spherical_kn_d_ptr[2*1] = &lt;void*&gt;_func_spherical_kn_d_complex</span>
<span class="s0">ufunc__spherical_kn_d_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_spherical_kn_d&quot;)</span>
<span class="s0">ufunc__spherical_kn_d_data[0] = &amp;ufunc__spherical_kn_d_ptr[2*0]</span>
<span class="s0">ufunc__spherical_kn_d_data[1] = &amp;ufunc__spherical_kn_d_ptr[2*1]</span>
<span class="s0">_spherical_kn_d = np.PyUFunc_FromFuncAndData(ufunc__spherical_kn_d_loops, ufunc__spherical_kn_d_data, ufunc__spherical_kn_d_types, 2, 2, 1, 0, &quot;_spherical_kn_d&quot;, ufunc__spherical_kn_d_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__spherical_yn_loops[2]</span>
<span class="s0">cdef void *ufunc__spherical_yn_ptr[4]</span>
<span class="s0">cdef void *ufunc__spherical_yn_data[2]</span>
<span class="s0">cdef char ufunc__spherical_yn_types[6]</span>
<span class="s0">cdef char *ufunc__spherical_yn_doc = (</span>
    <span class="s0">&quot;Internal function, use `spherical_yn` instead.&quot;)</span>
<span class="s0">ufunc__spherical_yn_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ld__As_ld_d</span>
<span class="s0">ufunc__spherical_yn_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_D_lD__As_lD_D</span>
<span class="s0">ufunc__spherical_yn_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc__spherical_yn_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__spherical_yn_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__spherical_yn_types[3] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc__spherical_yn_types[4] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc__spherical_yn_types[5] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc__spherical_yn_ptr[2*0] = &lt;void*&gt;_func_spherical_yn_real</span>
<span class="s0">ufunc__spherical_yn_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_spherical_yn&quot;)</span>
<span class="s0">ufunc__spherical_yn_ptr[2*1] = &lt;void*&gt;_func_spherical_yn_complex</span>
<span class="s0">ufunc__spherical_yn_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_spherical_yn&quot;)</span>
<span class="s0">ufunc__spherical_yn_data[0] = &amp;ufunc__spherical_yn_ptr[2*0]</span>
<span class="s0">ufunc__spherical_yn_data[1] = &amp;ufunc__spherical_yn_ptr[2*1]</span>
<span class="s0">_spherical_yn = np.PyUFunc_FromFuncAndData(ufunc__spherical_yn_loops, ufunc__spherical_yn_data, ufunc__spherical_yn_types, 2, 2, 1, 0, &quot;_spherical_yn&quot;, ufunc__spherical_yn_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__spherical_yn_d_loops[2]</span>
<span class="s0">cdef void *ufunc__spherical_yn_d_ptr[4]</span>
<span class="s0">cdef void *ufunc__spherical_yn_d_data[2]</span>
<span class="s0">cdef char ufunc__spherical_yn_d_types[6]</span>
<span class="s0">cdef char *ufunc__spherical_yn_d_doc = (</span>
    <span class="s0">&quot;Internal function, use `spherical_yn` instead.&quot;)</span>
<span class="s0">ufunc__spherical_yn_d_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ld__As_ld_d</span>
<span class="s0">ufunc__spherical_yn_d_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_D_lD__As_lD_D</span>
<span class="s0">ufunc__spherical_yn_d_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc__spherical_yn_d_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__spherical_yn_d_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__spherical_yn_d_types[3] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc__spherical_yn_d_types[4] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc__spherical_yn_d_types[5] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc__spherical_yn_d_ptr[2*0] = &lt;void*&gt;_func_spherical_yn_d_real</span>
<span class="s0">ufunc__spherical_yn_d_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_spherical_yn_d&quot;)</span>
<span class="s0">ufunc__spherical_yn_d_ptr[2*1] = &lt;void*&gt;_func_spherical_yn_d_complex</span>
<span class="s0">ufunc__spherical_yn_d_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_spherical_yn_d&quot;)</span>
<span class="s0">ufunc__spherical_yn_d_data[0] = &amp;ufunc__spherical_yn_d_ptr[2*0]</span>
<span class="s0">ufunc__spherical_yn_d_data[1] = &amp;ufunc__spherical_yn_d_ptr[2*1]</span>
<span class="s0">_spherical_yn_d = np.PyUFunc_FromFuncAndData(ufunc__spherical_yn_d_loops, ufunc__spherical_yn_d_data, ufunc__spherical_yn_d_types, 2, 2, 1, 0, &quot;_spherical_yn_d&quot;, ufunc__spherical_yn_d_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__struve_asymp_large_z_loops[1]</span>
<span class="s0">cdef void *ufunc__struve_asymp_large_z_ptr[2]</span>
<span class="s0">cdef void *ufunc__struve_asymp_large_z_data[1]</span>
<span class="s0">cdef char ufunc__struve_asymp_large_z_types[5]</span>
<span class="s0">cdef char *ufunc__struve_asymp_large_z_doc = (</span>
    <span class="s0">&quot;_struve_asymp_large_z(v, z, is_h)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Internal function for testing `struve` &amp; `modstruve`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluates using asymptotic expansion\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;v, err&quot;)</span>
<span class="s0">ufunc__struve_asymp_large_z_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddi_d_As_ddl_dd</span>
<span class="s0">ufunc__struve_asymp_large_z_types[0] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__struve_asymp_large_z_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__struve_asymp_large_z_types[2] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc__struve_asymp_large_z_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__struve_asymp_large_z_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__struve_asymp_large_z_ptr[2*0] = &lt;void*&gt;_func_struve_asymp_large_z</span>
<span class="s0">ufunc__struve_asymp_large_z_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_struve_asymp_large_z&quot;)</span>
<span class="s0">ufunc__struve_asymp_large_z_data[0] = &amp;ufunc__struve_asymp_large_z_ptr[2*0]</span>
<span class="s0">_struve_asymp_large_z = np.PyUFunc_FromFuncAndData(ufunc__struve_asymp_large_z_loops, ufunc__struve_asymp_large_z_data, ufunc__struve_asymp_large_z_types, 1, 3, 2, 0, &quot;_struve_asymp_large_z&quot;, ufunc__struve_asymp_large_z_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__struve_bessel_series_loops[1]</span>
<span class="s0">cdef void *ufunc__struve_bessel_series_ptr[2]</span>
<span class="s0">cdef void *ufunc__struve_bessel_series_data[1]</span>
<span class="s0">cdef char ufunc__struve_bessel_series_types[5]</span>
<span class="s0">cdef char *ufunc__struve_bessel_series_doc = (</span>
    <span class="s0">&quot;_struve_bessel_series(v, z, is_h)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Internal function for testing `struve` &amp; `modstruve`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluates using Bessel function series\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;v, err&quot;)</span>
<span class="s0">ufunc__struve_bessel_series_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddi_d_As_ddl_dd</span>
<span class="s0">ufunc__struve_bessel_series_types[0] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__struve_bessel_series_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__struve_bessel_series_types[2] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc__struve_bessel_series_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__struve_bessel_series_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__struve_bessel_series_ptr[2*0] = &lt;void*&gt;_func_struve_bessel_series</span>
<span class="s0">ufunc__struve_bessel_series_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_struve_bessel_series&quot;)</span>
<span class="s0">ufunc__struve_bessel_series_data[0] = &amp;ufunc__struve_bessel_series_ptr[2*0]</span>
<span class="s0">_struve_bessel_series = np.PyUFunc_FromFuncAndData(ufunc__struve_bessel_series_loops, ufunc__struve_bessel_series_data, ufunc__struve_bessel_series_types, 1, 3, 2, 0, &quot;_struve_bessel_series&quot;, ufunc__struve_bessel_series_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__struve_power_series_loops[1]</span>
<span class="s0">cdef void *ufunc__struve_power_series_ptr[2]</span>
<span class="s0">cdef void *ufunc__struve_power_series_data[1]</span>
<span class="s0">cdef char ufunc__struve_power_series_types[5]</span>
<span class="s0">cdef char *ufunc__struve_power_series_doc = (</span>
    <span class="s0">&quot;_struve_power_series(v, z, is_h)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Internal function for testing `struve` &amp; `modstruve`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluates using power series\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;v, err&quot;)</span>
<span class="s0">ufunc__struve_power_series_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddi_d_As_ddl_dd</span>
<span class="s0">ufunc__struve_power_series_types[0] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__struve_power_series_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__struve_power_series_types[2] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc__struve_power_series_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__struve_power_series_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__struve_power_series_ptr[2*0] = &lt;void*&gt;_func_struve_power_series</span>
<span class="s0">ufunc__struve_power_series_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_struve_power_series&quot;)</span>
<span class="s0">ufunc__struve_power_series_data[0] = &amp;ufunc__struve_power_series_ptr[2*0]</span>
<span class="s0">_struve_power_series = np.PyUFunc_FromFuncAndData(ufunc__struve_power_series_loops, ufunc__struve_power_series_data, ufunc__struve_power_series_types, 1, 3, 2, 0, &quot;_struve_power_series&quot;, ufunc__struve_power_series_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc__zeta_loops[2]</span>
<span class="s0">cdef void *ufunc__zeta_ptr[4]</span>
<span class="s0">cdef void *ufunc__zeta_data[2]</span>
<span class="s0">cdef char ufunc__zeta_types[6]</span>
<span class="s0">cdef char *ufunc__zeta_doc = (</span>
    <span class="s0">&quot;_zeta(x, q)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Internal function, Hurwitz zeta.&quot;)</span>
<span class="s0">ufunc__zeta_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc__zeta_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc__zeta_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__zeta_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__zeta_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc__zeta_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__zeta_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__zeta_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc__zeta_ptr[2*0] = &lt;void*&gt;_func_zeta</span>
<span class="s0">ufunc__zeta_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_zeta&quot;)</span>
<span class="s0">ufunc__zeta_ptr[2*1] = &lt;void*&gt;_func_zeta</span>
<span class="s0">ufunc__zeta_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;_zeta&quot;)</span>
<span class="s0">ufunc__zeta_data[0] = &amp;ufunc__zeta_ptr[2*0]</span>
<span class="s0">ufunc__zeta_data[1] = &amp;ufunc__zeta_ptr[2*1]</span>
<span class="s0">_zeta = np.PyUFunc_FromFuncAndData(ufunc__zeta_loops, ufunc__zeta_data, ufunc__zeta_types, 2, 2, 1, 0, &quot;_zeta&quot;, ufunc__zeta_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_agm_loops[2]</span>
<span class="s0">cdef void *ufunc_agm_ptr[4]</span>
<span class="s0">cdef void *ufunc_agm_data[2]</span>
<span class="s0">cdef char ufunc_agm_types[6]</span>
<span class="s0">cdef char *ufunc_agm_doc = (</span>
    <span class="s0">&quot;agm(a, b, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the arithmetic-geometric mean of `a` and `b`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Start with a_0 = a and b_0 = b and iteratively compute::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    a_{n+1} = (a_n + b_n)/2\n&quot;</span>
    <span class="s0">&quot;    b_{n+1} = sqrt(a_n*b_n)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;a_n and b_n converge to the same limit as n increases; their common\n&quot;</span>
    <span class="s0">&quot;limit is agm(a, b).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a, b : array_like\n&quot;</span>
    <span class="s0">&quot;    Real values only. If the values are both negative, the result\n&quot;</span>
    <span class="s0">&quot;    is negative. If one value is negative and the other is positive,\n&quot;</span>
    <span class="s0">&quot;    `nan` is returned.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The arithmetic-geometric mean of `a` and `b`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import agm\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a, b = 24.0, 6.0\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; agm(a, b)\n&quot;</span>
    <span class="s0">&quot;13.458171481725614\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compare that result to the iteration:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; while a != b:\n&quot;</span>
    <span class="s0">&quot;...     a, b = (a + b)/2, np.sqrt(a*b)\n&quot;</span>
    <span class="s0">&quot;...     print(\&quot;a = %19.16f  b=%19.16f\&quot; % (a, b))\n&quot;</span>
    <span class="s0">&quot;...\n&quot;</span>
    <span class="s0">&quot;a = 15.0000000000000000  b=12.0000000000000000\n&quot;</span>
    <span class="s0">&quot;a = 13.5000000000000000  b=13.4164078649987388\n&quot;</span>
    <span class="s0">&quot;a = 13.4582039324993694  b=13.4581390309909850\n&quot;</span>
    <span class="s0">&quot;a = 13.4581714817451772  b=13.4581714817060547\n&quot;</span>
    <span class="s0">&quot;a = 13.4581714817256159  b=13.4581714817256159\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;When array-like arguments are given, broadcasting applies:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a = np.array([[1.5], [3], [6]])  # a has shape (3, 1).\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; b = np.array([6, 12, 24, 48])    # b has shape (4,).\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; agm(a, b)\n&quot;</span>
    <span class="s0">&quot;array([[  3.36454287,   5.42363427,   9.05798751,  15.53650756],\n&quot;</span>
    <span class="s0">&quot;       [  4.37037309,   6.72908574,  10.84726853,  18.11597502],\n&quot;</span>
    <span class="s0">&quot;       [  6.        ,   8.74074619,  13.45817148,  21.69453707]])&quot;)</span>
<span class="s0">ufunc_agm_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_agm_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_agm_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_agm_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_agm_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_agm_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_agm_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_agm_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_agm_ptr[2*0] = &lt;void*&gt;_func_agm</span>
<span class="s0">ufunc_agm_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;agm&quot;)</span>
<span class="s0">ufunc_agm_ptr[2*1] = &lt;void*&gt;_func_agm</span>
<span class="s0">ufunc_agm_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;agm&quot;)</span>
<span class="s0">ufunc_agm_data[0] = &amp;ufunc_agm_ptr[2*0]</span>
<span class="s0">ufunc_agm_data[1] = &amp;ufunc_agm_ptr[2*1]</span>
<span class="s0">agm = np.PyUFunc_FromFuncAndData(ufunc_agm_loops, ufunc_agm_data, ufunc_agm_types, 2, 2, 1, 0, &quot;agm&quot;, ufunc_agm_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_airy_loops[4]</span>
<span class="s0">cdef void *ufunc_airy_ptr[8]</span>
<span class="s0">cdef void *ufunc_airy_data[4]</span>
<span class="s0">cdef char ufunc_airy_types[20]</span>
<span class="s0">cdef char *ufunc_airy_doc = (</span>
    <span class="s0">&quot;airy(z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Airy functions and their derivatives.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;z : array_like\n&quot;</span>
    <span class="s0">&quot;    Real or complex argument.\n&quot;</span>
    <span class="s0">&quot;out : tuple of ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output arrays for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;Ai, Aip, Bi, Bip : 4-tuple of scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Airy functions Ai and Bi, and their derivatives Aip and Bip.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The Airy functions Ai and Bi are two independent solutions of\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: y''(x) = x y(x).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For real `z` in [-10, 10], the computation is carried out by calling\n&quot;</span>
    <span class="s0">&quot;the Cephes [1]_ `airy` routine, which uses power series summation\n&quot;</span>
    <span class="s0">&quot;for small `z` and rational minimax approximations for large `z`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Outside this range, the AMOS [2]_ `zairy` and `zbiry` routines are\n&quot;</span>
    <span class="s0">&quot;employed.  They are computed using power series for :math:`|z| &lt; 1` and\n&quot;</span>
    <span class="s0">&quot;the following relations to modified Bessel functions for larger `z`\n&quot;</span>
    <span class="s0">&quot;(where :math:`t \\equiv 2 z^{3/2}/3`):\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    Ai(z) = \\frac{1}{\\pi \\sqrt{3}} K_{1/3}(t)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    Ai'(z) = -\\frac{z}{\\pi \\sqrt{3}} K_{2/3}(t)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    Bi(z) = \\sqrt{\\frac{z}{3}} \\left(I_{-1/3}(t) + I_{1/3}(t) \\right)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    Bi'(z) = \\frac{z}{\\sqrt{3}} \\left(I_{-2/3}(t) + I_{2/3}(t)\\right)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;airye : exponentially scaled Airy functions.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;.. [2] Donald E. Amos, \&quot;AMOS, A Portable Package for Bessel Functions\n&quot;</span>
    <span class="s0">&quot;       of a Complex Argument and Nonnegative Order\&quot;,\n&quot;</span>
    <span class="s0">&quot;       http://netlib.org/amos/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Compute the Airy functions on the interval [-15, 5].\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy import special\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-15, 5, 201)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ai, aip, bi, bip = special.airy(x)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot Ai(x) and Bi(x).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.plot(x, ai, 'r', label='Ai(x)')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.plot(x, bi, 'b--', label='Bi(x)')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.ylim(-0.5, 1.0)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.grid()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.legend(loc='upper left')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_airy_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_d_dddd_As_f_ffff</span>
<span class="s0">ufunc_airy_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_i_d_dddd_As_d_dddd</span>
<span class="s0">ufunc_airy_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_i_D_DDDD_As_F_FFFF</span>
<span class="s0">ufunc_airy_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_i_D_DDDD_As_D_DDDD</span>
<span class="s0">ufunc_airy_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_airy_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_airy_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_airy_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_airy_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_airy_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_airy_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_airy_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_airy_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_airy_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_airy_types[10] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_airy_types[11] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_airy_types[12] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_airy_types[13] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_airy_types[14] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_airy_types[15] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_airy_types[16] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_airy_types[17] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_airy_types[18] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_airy_types[19] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_airy_ptr[2*0] = &lt;void*&gt;_func_airy_wrap</span>
<span class="s0">ufunc_airy_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;airy&quot;)</span>
<span class="s0">ufunc_airy_ptr[2*1] = &lt;void*&gt;_func_airy_wrap</span>
<span class="s0">ufunc_airy_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;airy&quot;)</span>
<span class="s0">ufunc_airy_ptr[2*2] = &lt;void*&gt;_func_cairy_wrap</span>
<span class="s0">ufunc_airy_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;airy&quot;)</span>
<span class="s0">ufunc_airy_ptr[2*3] = &lt;void*&gt;_func_cairy_wrap</span>
<span class="s0">ufunc_airy_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;airy&quot;)</span>
<span class="s0">ufunc_airy_data[0] = &amp;ufunc_airy_ptr[2*0]</span>
<span class="s0">ufunc_airy_data[1] = &amp;ufunc_airy_ptr[2*1]</span>
<span class="s0">ufunc_airy_data[2] = &amp;ufunc_airy_ptr[2*2]</span>
<span class="s0">ufunc_airy_data[3] = &amp;ufunc_airy_ptr[2*3]</span>
<span class="s0">airy = np.PyUFunc_FromFuncAndData(ufunc_airy_loops, ufunc_airy_data, ufunc_airy_types, 4, 1, 4, 0, &quot;airy&quot;, ufunc_airy_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_airye_loops[4]</span>
<span class="s0">cdef void *ufunc_airye_ptr[8]</span>
<span class="s0">cdef void *ufunc_airye_data[4]</span>
<span class="s0">cdef char ufunc_airye_types[20]</span>
<span class="s0">cdef char *ufunc_airye_doc = (</span>
    <span class="s0">&quot;airye(z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Exponentially scaled Airy functions and their derivatives.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Scaling::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    eAi  = Ai  * exp(2.0/3.0*z*sqrt(z))\n&quot;</span>
    <span class="s0">&quot;    eAip = Aip * exp(2.0/3.0*z*sqrt(z))\n&quot;</span>
    <span class="s0">&quot;    eBi  = Bi  * exp(-abs(2.0/3.0*(z*sqrt(z)).real))\n&quot;</span>
    <span class="s0">&quot;    eBip = Bip * exp(-abs(2.0/3.0*(z*sqrt(z)).real))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;z : array_like\n&quot;</span>
    <span class="s0">&quot;    Real or complex argument.\n&quot;</span>
    <span class="s0">&quot;out : tuple of ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output arrays for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;eAi, eAip, eBi, eBip : 4-tuple of scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Exponentially scaled Airy functions eAi and eBi, and their derivatives\n&quot;</span>
    <span class="s0">&quot;    eAip and eBip\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for the AMOS [1]_ routines `zairy` and `zbiry`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;airy\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Donald E. Amos, \&quot;AMOS, A Portable Package for Bessel Functions\n&quot;</span>
    <span class="s0">&quot;       of a Complex Argument and Nonnegative Order\&quot;,\n&quot;</span>
    <span class="s0">&quot;       http://netlib.org/amos/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;We can compute exponentially scaled Airy functions and their derivatives:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import airye\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z = np.linspace(0, 50, 500)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; eAi, eAip, eBi, eBip = airye(z)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; f, ax = plt.subplots(2, 1, sharex=True)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for ind, data in enumerate([[eAi, eAip, [\&quot;eAi\&quot;, \&quot;eAip\&quot;]],\n&quot;</span>
    <span class="s0">&quot;...                             [eBi, eBip, [\&quot;eBi\&quot;, \&quot;eBip\&quot;]]]):\n&quot;</span>
    <span class="s0">&quot;...     ax[ind].plot(z, data[0], \&quot;-r\&quot;, z, data[1], \&quot;-b\&quot;)\n&quot;</span>
    <span class="s0">&quot;...     ax[ind].legend(data[2])\n&quot;</span>
    <span class="s0">&quot;...     ax[ind].grid(True)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;We can compute these using usual non-scaled Airy functions by:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import airy\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; Ai, Aip, Bi, Bip = airy(z)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.allclose(eAi, Ai * np.exp(2.0 / 3.0 * z * np.sqrt(z)))\n&quot;</span>
    <span class="s0">&quot;True\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.allclose(eAip, Aip * np.exp(2.0 / 3.0 * z * np.sqrt(z)))\n&quot;</span>
    <span class="s0">&quot;True\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.allclose(eBi, Bi * np.exp(-abs(np.real(2.0 / 3.0 * z * np.sqrt(z)))))\n&quot;</span>
    <span class="s0">&quot;True\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.allclose(eBip, Bip * np.exp(-abs(np.real(2.0 / 3.0 * z * np.sqrt(z)))))\n&quot;</span>
    <span class="s0">&quot;True\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Comparing non-scaled and exponentially scaled ones, the usual non-scaled\n&quot;</span>
    <span class="s0">&quot;function quickly underflows for large values, whereas the exponentially\n&quot;</span>
    <span class="s0">&quot;scaled function does not.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; airy(200)\n&quot;</span>
    <span class="s0">&quot;(0.0, 0.0, nan, nan)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; airye(200)\n&quot;</span>
    <span class="s0">&quot;(0.07501041684381093, -1.0609012305109042, 0.15003188417418148, 2.1215836725571093)&quot;)</span>
<span class="s0">ufunc_airye_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_d_dddd_As_f_ffff</span>
<span class="s0">ufunc_airye_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_i_d_dddd_As_d_dddd</span>
<span class="s0">ufunc_airye_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_i_D_DDDD_As_F_FFFF</span>
<span class="s0">ufunc_airye_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_i_D_DDDD_As_D_DDDD</span>
<span class="s0">ufunc_airye_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_airye_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_airye_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_airye_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_airye_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_airye_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_airye_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_airye_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_airye_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_airye_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_airye_types[10] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_airye_types[11] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_airye_types[12] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_airye_types[13] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_airye_types[14] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_airye_types[15] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_airye_types[16] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_airye_types[17] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_airye_types[18] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_airye_types[19] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_airye_ptr[2*0] = &lt;void*&gt;_func_cairy_wrap_e_real</span>
<span class="s0">ufunc_airye_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;airye&quot;)</span>
<span class="s0">ufunc_airye_ptr[2*1] = &lt;void*&gt;_func_cairy_wrap_e_real</span>
<span class="s0">ufunc_airye_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;airye&quot;)</span>
<span class="s0">ufunc_airye_ptr[2*2] = &lt;void*&gt;_func_cairy_wrap_e</span>
<span class="s0">ufunc_airye_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;airye&quot;)</span>
<span class="s0">ufunc_airye_ptr[2*3] = &lt;void*&gt;_func_cairy_wrap_e</span>
<span class="s0">ufunc_airye_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;airye&quot;)</span>
<span class="s0">ufunc_airye_data[0] = &amp;ufunc_airye_ptr[2*0]</span>
<span class="s0">ufunc_airye_data[1] = &amp;ufunc_airye_ptr[2*1]</span>
<span class="s0">ufunc_airye_data[2] = &amp;ufunc_airye_ptr[2*2]</span>
<span class="s0">ufunc_airye_data[3] = &amp;ufunc_airye_ptr[2*3]</span>
<span class="s0">airye = np.PyUFunc_FromFuncAndData(ufunc_airye_loops, ufunc_airye_data, ufunc_airye_types, 4, 1, 4, 0, &quot;airye&quot;, ufunc_airye_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_bdtr_loops[3]</span>
<span class="s0">cdef void *ufunc_bdtr_ptr[6]</span>
<span class="s0">cdef void *ufunc_bdtr_data[3]</span>
<span class="s0">cdef char ufunc_bdtr_types[12]</span>
<span class="s0">cdef char *ufunc_bdtr_doc = (</span>
    <span class="s0">&quot;bdtr(k, n, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Binomial distribution cumulative distribution function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Sum of the terms 0 through `floor(k)` of the Binomial probability density.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    \\mathrm{bdtr}(k, n, p) = \\sum_{j=0}^{\\lfloor k \\rfloor} {{n}\\choose{j}} p^j (1-p)^{n-j}\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;k : array_like\n&quot;</span>
    <span class="s0">&quot;    Number of successes (double), rounded down to the nearest integer.\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Number of events (int).\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability of success in a single event (float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;y : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Probability of `floor(k)` or fewer successes in `n` independent events with\n&quot;</span>
    <span class="s0">&quot;    success probabilities of `p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The terms are not summed directly; instead the regularized incomplete beta\n&quot;</span>
    <span class="s0">&quot;function is employed, according to the formula,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    \\mathrm{bdtr}(k, n, p) = I_{1 - p}(n - \\lfloor k \\rfloor, \\lfloor k \\rfloor + 1).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `bdtr`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/&quot;)</span>
<span class="s0">ufunc_bdtr_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_bdtr_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_did__As_dld_d</span>
<span class="s0">ufunc_bdtr_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_bdtr_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtr_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtr_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtr_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtr_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtr_types[5] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc_bdtr_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtr_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtr_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtr_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtr_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtr_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtr_ptr[2*0] = &lt;void*&gt;_func_bdtr_unsafe</span>
<span class="s0">ufunc_bdtr_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;bdtr&quot;)</span>
<span class="s0">ufunc_bdtr_ptr[2*1] = &lt;void*&gt;_func_bdtr</span>
<span class="s0">ufunc_bdtr_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;bdtr&quot;)</span>
<span class="s0">ufunc_bdtr_ptr[2*2] = &lt;void*&gt;_func_bdtr_unsafe</span>
<span class="s0">ufunc_bdtr_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;bdtr&quot;)</span>
<span class="s0">ufunc_bdtr_data[0] = &amp;ufunc_bdtr_ptr[2*0]</span>
<span class="s0">ufunc_bdtr_data[1] = &amp;ufunc_bdtr_ptr[2*1]</span>
<span class="s0">ufunc_bdtr_data[2] = &amp;ufunc_bdtr_ptr[2*2]</span>
<span class="s0">bdtr = np.PyUFunc_FromFuncAndData(ufunc_bdtr_loops, ufunc_bdtr_data, ufunc_bdtr_types, 3, 3, 1, 0, &quot;bdtr&quot;, ufunc_bdtr_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_bdtrc_loops[3]</span>
<span class="s0">cdef void *ufunc_bdtrc_ptr[6]</span>
<span class="s0">cdef void *ufunc_bdtrc_data[3]</span>
<span class="s0">cdef char ufunc_bdtrc_types[12]</span>
<span class="s0">cdef char *ufunc_bdtrc_doc = (</span>
    <span class="s0">&quot;bdtrc(k, n, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Binomial distribution survival function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Sum of the terms `floor(k) + 1` through `n` of the binomial probability\n&quot;</span>
    <span class="s0">&quot;density,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    \\mathrm{bdtrc}(k, n, p) = \\sum_{j=\\lfloor k \\rfloor +1}^n {{n}\\choose{j}} p^j (1-p)^{n-j}\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;k : array_like\n&quot;</span>
    <span class="s0">&quot;    Number of successes (double), rounded down to nearest integer.\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Number of events (int)\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability of success in a single event.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;y : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Probability of `floor(k) + 1` or more successes in `n` independent\n&quot;</span>
    <span class="s0">&quot;    events with success probabilities of `p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;bdtr\n&quot;</span>
    <span class="s0">&quot;betainc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The terms are not summed directly; instead the regularized incomplete beta\n&quot;</span>
    <span class="s0">&quot;function is employed, according to the formula,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    \\mathrm{bdtrc}(k, n, p) = I_{p}(\\lfloor k \\rfloor + 1, n - \\lfloor k \\rfloor).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `bdtrc`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/&quot;)</span>
<span class="s0">ufunc_bdtrc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_bdtrc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_did__As_dld_d</span>
<span class="s0">ufunc_bdtrc_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_bdtrc_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtrc_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtrc_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtrc_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtrc_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtrc_types[5] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc_bdtrc_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtrc_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtrc_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtrc_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtrc_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtrc_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtrc_ptr[2*0] = &lt;void*&gt;_func_bdtrc_unsafe</span>
<span class="s0">ufunc_bdtrc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;bdtrc&quot;)</span>
<span class="s0">ufunc_bdtrc_ptr[2*1] = &lt;void*&gt;_func_bdtrc</span>
<span class="s0">ufunc_bdtrc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;bdtrc&quot;)</span>
<span class="s0">ufunc_bdtrc_ptr[2*2] = &lt;void*&gt;_func_bdtrc_unsafe</span>
<span class="s0">ufunc_bdtrc_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;bdtrc&quot;)</span>
<span class="s0">ufunc_bdtrc_data[0] = &amp;ufunc_bdtrc_ptr[2*0]</span>
<span class="s0">ufunc_bdtrc_data[1] = &amp;ufunc_bdtrc_ptr[2*1]</span>
<span class="s0">ufunc_bdtrc_data[2] = &amp;ufunc_bdtrc_ptr[2*2]</span>
<span class="s0">bdtrc = np.PyUFunc_FromFuncAndData(ufunc_bdtrc_loops, ufunc_bdtrc_data, ufunc_bdtrc_types, 3, 3, 1, 0, &quot;bdtrc&quot;, ufunc_bdtrc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_bdtri_loops[3]</span>
<span class="s0">cdef void *ufunc_bdtri_ptr[6]</span>
<span class="s0">cdef void *ufunc_bdtri_data[3]</span>
<span class="s0">cdef char ufunc_bdtri_types[12]</span>
<span class="s0">cdef char *ufunc_bdtri_doc = (</span>
    <span class="s0">&quot;bdtri(k, n, y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse function to `bdtr` with respect to `p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Finds the event probability `p` such that the sum of the terms 0 through\n&quot;</span>
    <span class="s0">&quot;`k` of the binomial probability density is equal to the given cumulative\n&quot;</span>
    <span class="s0">&quot;probability `y`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;k : array_like\n&quot;</span>
    <span class="s0">&quot;    Number of successes (float), rounded down to the nearest integer.\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Number of events (float)\n&quot;</span>
    <span class="s0">&quot;y : array_like\n&quot;</span>
    <span class="s0">&quot;    Cumulative probability (probability of `k` or fewer successes in `n`\n&quot;</span>
    <span class="s0">&quot;    events).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;p : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The event probability such that `bdtr(\\lfloor k \\rfloor, n, p) = y`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;bdtr\n&quot;</span>
    <span class="s0">&quot;betaincinv\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The computation is carried out using the inverse beta integral function\n&quot;</span>
    <span class="s0">&quot;and the relation,::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    1 - p = betaincinv(n - k, k + 1, y).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `bdtri`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/&quot;)</span>
<span class="s0">ufunc_bdtri_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_bdtri_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_did__As_dld_d</span>
<span class="s0">ufunc_bdtri_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_bdtri_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtri_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtri_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtri_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtri_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtri_types[5] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc_bdtri_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtri_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtri_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtri_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtri_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtri_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtri_ptr[2*0] = &lt;void*&gt;_func_bdtri_unsafe</span>
<span class="s0">ufunc_bdtri_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;bdtri&quot;)</span>
<span class="s0">ufunc_bdtri_ptr[2*1] = &lt;void*&gt;_func_bdtri</span>
<span class="s0">ufunc_bdtri_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;bdtri&quot;)</span>
<span class="s0">ufunc_bdtri_ptr[2*2] = &lt;void*&gt;_func_bdtri_unsafe</span>
<span class="s0">ufunc_bdtri_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;bdtri&quot;)</span>
<span class="s0">ufunc_bdtri_data[0] = &amp;ufunc_bdtri_ptr[2*0]</span>
<span class="s0">ufunc_bdtri_data[1] = &amp;ufunc_bdtri_ptr[2*1]</span>
<span class="s0">ufunc_bdtri_data[2] = &amp;ufunc_bdtri_ptr[2*2]</span>
<span class="s0">bdtri = np.PyUFunc_FromFuncAndData(ufunc_bdtri_loops, ufunc_bdtri_data, ufunc_bdtri_types, 3, 3, 1, 0, &quot;bdtri&quot;, ufunc_bdtri_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_bdtrik_loops[2]</span>
<span class="s0">cdef void *ufunc_bdtrik_ptr[4]</span>
<span class="s0">cdef void *ufunc_bdtrik_data[2]</span>
<span class="s0">cdef char ufunc_bdtrik_types[8]</span>
<span class="s0">cdef char *ufunc_bdtrik_doc = (</span>
    <span class="s0">&quot;bdtrik(y, n, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse function to `bdtr` with respect to `k`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Finds the number of successes `k` such that the sum of the terms 0 through\n&quot;</span>
    <span class="s0">&quot;`k` of the Binomial probability density for `n` events with probability\n&quot;</span>
    <span class="s0">&quot;`p` is equal to the given cumulative probability `y`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;y : array_like\n&quot;</span>
    <span class="s0">&quot;    Cumulative probability (probability of `k` or fewer successes in `n`\n&quot;</span>
    <span class="s0">&quot;    events).\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Number of events (float).\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Success probability (float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;k : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The number of successes `k` such that `bdtr(k, n, p) = y`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;bdtr\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Formula 26.5.24 of [1]_ is used to reduce the binomial distribution to the\n&quot;</span>
    <span class="s0">&quot;cumulative incomplete beta distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computation of `k` involves a search for a value that produces the desired\n&quot;</span>
    <span class="s0">&quot;value of `y`. The search relies on the monotonicity of `y` with `k`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Wrapper for the CDFLIB [2]_ Fortran routine `cdfbin`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;       Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;       Graphs, and Mathematical Tables. New York: Dover, 1972.\n&quot;</span>
    <span class="s0">&quot;.. [2] Barry Brown, James Lovato, and Kathy Russell,\n&quot;</span>
    <span class="s0">&quot;       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n&quot;</span>
    <span class="s0">&quot;       Functions, Inverses, and Other Parameters.&quot;)</span>
<span class="s0">ufunc_bdtrik_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_bdtrik_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_bdtrik_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtrik_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtrik_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtrik_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtrik_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtrik_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtrik_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtrik_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtrik_ptr[2*0] = &lt;void*&gt;_func_cdfbin2_wrap</span>
<span class="s0">ufunc_bdtrik_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;bdtrik&quot;)</span>
<span class="s0">ufunc_bdtrik_ptr[2*1] = &lt;void*&gt;_func_cdfbin2_wrap</span>
<span class="s0">ufunc_bdtrik_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;bdtrik&quot;)</span>
<span class="s0">ufunc_bdtrik_data[0] = &amp;ufunc_bdtrik_ptr[2*0]</span>
<span class="s0">ufunc_bdtrik_data[1] = &amp;ufunc_bdtrik_ptr[2*1]</span>
<span class="s0">bdtrik = np.PyUFunc_FromFuncAndData(ufunc_bdtrik_loops, ufunc_bdtrik_data, ufunc_bdtrik_types, 2, 3, 1, 0, &quot;bdtrik&quot;, ufunc_bdtrik_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_bdtrin_loops[2]</span>
<span class="s0">cdef void *ufunc_bdtrin_ptr[4]</span>
<span class="s0">cdef void *ufunc_bdtrin_data[2]</span>
<span class="s0">cdef char ufunc_bdtrin_types[8]</span>
<span class="s0">cdef char *ufunc_bdtrin_doc = (</span>
    <span class="s0">&quot;bdtrin(k, y, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse function to `bdtr` with respect to `n`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Finds the number of events `n` such that the sum of the terms 0 through\n&quot;</span>
    <span class="s0">&quot;`k` of the Binomial probability density for events with probability `p` is\n&quot;</span>
    <span class="s0">&quot;equal to the given cumulative probability `y`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;k : array_like\n&quot;</span>
    <span class="s0">&quot;    Number of successes (float).\n&quot;</span>
    <span class="s0">&quot;y : array_like\n&quot;</span>
    <span class="s0">&quot;    Cumulative probability (probability of `k` or fewer successes in `n`\n&quot;</span>
    <span class="s0">&quot;    events).\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Success probability (float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;n : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The number of events `n` such that `bdtr(k, n, p) = y`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;bdtr\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Formula 26.5.24 of [1]_ is used to reduce the binomial distribution to the\n&quot;</span>
    <span class="s0">&quot;cumulative incomplete beta distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computation of `n` involves a search for a value that produces the desired\n&quot;</span>
    <span class="s0">&quot;value of `y`. The search relies on the monotonicity of `y` with `n`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Wrapper for the CDFLIB [2]_ Fortran routine `cdfbin`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;       Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;       Graphs, and Mathematical Tables. New York: Dover, 1972.\n&quot;</span>
    <span class="s0">&quot;.. [2] Barry Brown, James Lovato, and Kathy Russell,\n&quot;</span>
    <span class="s0">&quot;       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n&quot;</span>
    <span class="s0">&quot;       Functions, Inverses, and Other Parameters.&quot;)</span>
<span class="s0">ufunc_bdtrin_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_bdtrin_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_bdtrin_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtrin_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtrin_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtrin_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bdtrin_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtrin_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtrin_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtrin_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bdtrin_ptr[2*0] = &lt;void*&gt;_func_cdfbin3_wrap</span>
<span class="s0">ufunc_bdtrin_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;bdtrin&quot;)</span>
<span class="s0">ufunc_bdtrin_ptr[2*1] = &lt;void*&gt;_func_cdfbin3_wrap</span>
<span class="s0">ufunc_bdtrin_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;bdtrin&quot;)</span>
<span class="s0">ufunc_bdtrin_data[0] = &amp;ufunc_bdtrin_ptr[2*0]</span>
<span class="s0">ufunc_bdtrin_data[1] = &amp;ufunc_bdtrin_ptr[2*1]</span>
<span class="s0">bdtrin = np.PyUFunc_FromFuncAndData(ufunc_bdtrin_loops, ufunc_bdtrin_data, ufunc_bdtrin_types, 2, 3, 1, 0, &quot;bdtrin&quot;, ufunc_bdtrin_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_bei_loops[2]</span>
<span class="s0">cdef void *ufunc_bei_ptr[4]</span>
<span class="s0">cdef void *ufunc_bei_data[2]</span>
<span class="s0">cdef char ufunc_bei_types[4]</span>
<span class="s0">cdef char *ufunc_bei_doc = (</span>
    <span class="s0">&quot;bei(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Kelvin function bei.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    \\mathrm{bei}(x) = \\Im[J_0(x e^{3 \\pi i / 4})]\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`J_0` is the Bessel function of the first kind of\n&quot;</span>
    <span class="s0">&quot;order zero (see `jv`). See [dlmf]_ for more details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real argument.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Kelvin function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;ber : the corresponding real part\n&quot;</span>
    <span class="s0">&quot;beip : the derivative of bei\n&quot;</span>
    <span class="s0">&quot;jv : Bessel function of the first kind\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [dlmf] NIST, Digital Library of Mathematical Functions,\n&quot;</span>
    <span class="s0">&quot;    https://dlmf.nist.gov/10.61\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;It can be expressed using Bessel functions.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.array([1.0, 2.0, 3.0, 4.0])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.jv(0, x * np.exp(3 * np.pi * 1j / 4)).imag\n&quot;</span>
    <span class="s0">&quot;array([0.24956604, 0.97229163, 1.93758679, 2.29269032])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.bei(x)\n&quot;</span>
    <span class="s0">&quot;array([0.24956604, 0.97229163, 1.93758679, 2.29269032])&quot;)</span>
<span class="s0">ufunc_bei_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_bei_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_bei_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bei_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_bei_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bei_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_bei_ptr[2*0] = &lt;void*&gt;_func_bei_wrap</span>
<span class="s0">ufunc_bei_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;bei&quot;)</span>
<span class="s0">ufunc_bei_ptr[2*1] = &lt;void*&gt;_func_bei_wrap</span>
<span class="s0">ufunc_bei_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;bei&quot;)</span>
<span class="s0">ufunc_bei_data[0] = &amp;ufunc_bei_ptr[2*0]</span>
<span class="s0">ufunc_bei_data[1] = &amp;ufunc_bei_ptr[2*1]</span>
<span class="s0">bei = np.PyUFunc_FromFuncAndData(ufunc_bei_loops, ufunc_bei_data, ufunc_bei_types, 2, 1, 1, 0, &quot;bei&quot;, ufunc_bei_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_beip_loops[2]</span>
<span class="s0">cdef void *ufunc_beip_ptr[4]</span>
<span class="s0">cdef void *ufunc_beip_data[2]</span>
<span class="s0">cdef char ufunc_beip_types[4]</span>
<span class="s0">cdef char *ufunc_beip_doc = (</span>
    <span class="s0">&quot;beip(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Derivative of the Kelvin function bei.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real argument.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The values of the derivative of bei.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;bei\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [dlmf] NIST, Digital Library of Mathematical Functions,\n&quot;</span>
    <span class="s0">&quot;    https://dlmf.nist.gov/10#PT5&quot;)</span>
<span class="s0">ufunc_beip_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_beip_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_beip_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_beip_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_beip_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_beip_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_beip_ptr[2*0] = &lt;void*&gt;_func_beip_wrap</span>
<span class="s0">ufunc_beip_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;beip&quot;)</span>
<span class="s0">ufunc_beip_ptr[2*1] = &lt;void*&gt;_func_beip_wrap</span>
<span class="s0">ufunc_beip_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;beip&quot;)</span>
<span class="s0">ufunc_beip_data[0] = &amp;ufunc_beip_ptr[2*0]</span>
<span class="s0">ufunc_beip_data[1] = &amp;ufunc_beip_ptr[2*1]</span>
<span class="s0">beip = np.PyUFunc_FromFuncAndData(ufunc_beip_loops, ufunc_beip_data, ufunc_beip_types, 2, 1, 1, 0, &quot;beip&quot;, ufunc_beip_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_ber_loops[2]</span>
<span class="s0">cdef void *ufunc_ber_ptr[4]</span>
<span class="s0">cdef void *ufunc_ber_data[2]</span>
<span class="s0">cdef char ufunc_ber_types[4]</span>
<span class="s0">cdef char *ufunc_ber_doc = (</span>
    <span class="s0">&quot;ber(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Kelvin function ber.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    \\mathrm{ber}(x) = \\Re[J_0(x e^{3 \\pi i / 4})]\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`J_0` is the Bessel function of the first kind of\n&quot;</span>
    <span class="s0">&quot;order zero (see `jv`). See [dlmf]_ for more details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real argument.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Kelvin function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;bei : the corresponding real part\n&quot;</span>
    <span class="s0">&quot;berp : the derivative of bei\n&quot;</span>
    <span class="s0">&quot;jv : Bessel function of the first kind\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [dlmf] NIST, Digital Library of Mathematical Functions,\n&quot;</span>
    <span class="s0">&quot;    https://dlmf.nist.gov/10.61\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;It can be expressed using Bessel functions.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.array([1.0, 2.0, 3.0, 4.0])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.jv(0, x * np.exp(3 * np.pi * 1j / 4)).real\n&quot;</span>
    <span class="s0">&quot;array([ 0.98438178,  0.75173418, -0.22138025, -2.56341656])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.ber(x)\n&quot;</span>
    <span class="s0">&quot;array([ 0.98438178,  0.75173418, -0.22138025, -2.56341656])&quot;)</span>
<span class="s0">ufunc_ber_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_ber_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_ber_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ber_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ber_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ber_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ber_ptr[2*0] = &lt;void*&gt;_func_ber_wrap</span>
<span class="s0">ufunc_ber_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ber&quot;)</span>
<span class="s0">ufunc_ber_ptr[2*1] = &lt;void*&gt;_func_ber_wrap</span>
<span class="s0">ufunc_ber_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ber&quot;)</span>
<span class="s0">ufunc_ber_data[0] = &amp;ufunc_ber_ptr[2*0]</span>
<span class="s0">ufunc_ber_data[1] = &amp;ufunc_ber_ptr[2*1]</span>
<span class="s0">ber = np.PyUFunc_FromFuncAndData(ufunc_ber_loops, ufunc_ber_data, ufunc_ber_types, 2, 1, 1, 0, &quot;ber&quot;, ufunc_ber_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_berp_loops[2]</span>
<span class="s0">cdef void *ufunc_berp_ptr[4]</span>
<span class="s0">cdef void *ufunc_berp_data[2]</span>
<span class="s0">cdef char ufunc_berp_types[4]</span>
<span class="s0">cdef char *ufunc_berp_doc = (</span>
    <span class="s0">&quot;berp(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Derivative of the Kelvin function ber.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real argument.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The values of the derivative of ber.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;ber\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [dlmf] NIST, Digital Library of Mathematical Functions,\n&quot;</span>
    <span class="s0">&quot;    https://dlmf.nist.gov/10#PT5&quot;)</span>
<span class="s0">ufunc_berp_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_berp_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_berp_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_berp_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_berp_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_berp_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_berp_ptr[2*0] = &lt;void*&gt;_func_berp_wrap</span>
<span class="s0">ufunc_berp_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;berp&quot;)</span>
<span class="s0">ufunc_berp_ptr[2*1] = &lt;void*&gt;_func_berp_wrap</span>
<span class="s0">ufunc_berp_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;berp&quot;)</span>
<span class="s0">ufunc_berp_data[0] = &amp;ufunc_berp_ptr[2*0]</span>
<span class="s0">ufunc_berp_data[1] = &amp;ufunc_berp_ptr[2*1]</span>
<span class="s0">berp = np.PyUFunc_FromFuncAndData(ufunc_berp_loops, ufunc_berp_data, ufunc_berp_types, 2, 1, 1, 0, &quot;berp&quot;, ufunc_berp_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_besselpoly_loops[2]</span>
<span class="s0">cdef void *ufunc_besselpoly_ptr[4]</span>
<span class="s0">cdef void *ufunc_besselpoly_data[2]</span>
<span class="s0">cdef char ufunc_besselpoly_types[8]</span>
<span class="s0">cdef char *ufunc_besselpoly_doc = (</span>
    <span class="s0">&quot;besselpoly(a, lmb, nu, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Weighted integral of the Bessel function of the first kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;   \\int_0^1 x^\\lambda J_\\nu(2 a x) \\, dx\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`J_\\nu` is a Bessel function and :math:`\\lambda=lmb`,\n&quot;</span>
    <span class="s0">&quot;:math:`\\nu=nu`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a : array_like\n&quot;</span>
    <span class="s0">&quot;    Scale factor inside the Bessel function.\n&quot;</span>
    <span class="s0">&quot;lmb : array_like\n&quot;</span>
    <span class="s0">&quot;    Power of `x`\n&quot;</span>
    <span class="s0">&quot;nu : array_like\n&quot;</span>
    <span class="s0">&quot;    Order of the Bessel function.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the integral.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Evaluate the function for one parameter set.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import besselpoly\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; besselpoly(1, 1, 1)\n&quot;</span>
    <span class="s0">&quot;0.24449718372863877\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate the function for different scale factors.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; factors = np.array([0., 3., 6.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; besselpoly(factors, 1, 1)\n&quot;</span>
    <span class="s0">&quot;array([ 0.        , -0.00549029,  0.00140174])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function for varying powers, orders and scales.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; powers = np.linspace(0, 10, 100)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; orders = [1, 2, 3]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; scales = [1, 2]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; all_combinations = [(order, scale) for order in orders\n&quot;</span>
    <span class="s0">&quot;...                     for scale in scales]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for order, scale in all_combinations:\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(powers, besselpoly(scale, powers, order),\n&quot;</span>
    <span class="s0">&quot;...             label=rf\&quot;$\\nu={order}, a={scale}$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel(r\&quot;$\\lambda$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_ylabel(r\&quot;$\\int_0^1 x^{\\lambda} J_{\\nu}(2ax)\\,dx$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_besselpoly_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_besselpoly_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_besselpoly_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_besselpoly_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_besselpoly_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_besselpoly_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_besselpoly_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_besselpoly_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_besselpoly_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_besselpoly_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_besselpoly_ptr[2*0] = &lt;void*&gt;_func_besselpoly</span>
<span class="s0">ufunc_besselpoly_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;besselpoly&quot;)</span>
<span class="s0">ufunc_besselpoly_ptr[2*1] = &lt;void*&gt;_func_besselpoly</span>
<span class="s0">ufunc_besselpoly_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;besselpoly&quot;)</span>
<span class="s0">ufunc_besselpoly_data[0] = &amp;ufunc_besselpoly_ptr[2*0]</span>
<span class="s0">ufunc_besselpoly_data[1] = &amp;ufunc_besselpoly_ptr[2*1]</span>
<span class="s0">besselpoly = np.PyUFunc_FromFuncAndData(ufunc_besselpoly_loops, ufunc_besselpoly_data, ufunc_besselpoly_types, 2, 3, 1, 0, &quot;besselpoly&quot;, ufunc_besselpoly_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_beta_loops[2]</span>
<span class="s0">cdef void *ufunc_beta_ptr[4]</span>
<span class="s0">cdef void *ufunc_beta_data[2]</span>
<span class="s0">cdef char ufunc_beta_types[6]</span>
<span class="s0">cdef char *ufunc_beta_doc = (</span>
    <span class="s0">&quot;beta(a, b, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Beta function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is defined in [1]_ as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    B(a, b) = \\int_0^1 t^{a-1}(1-t)^{b-1}dt\n&quot;</span>
    <span class="s0">&quot;            = \\frac{\\Gamma(a)\\Gamma(b)}{\\Gamma(a+b)},\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`\\Gamma` is the gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a, b : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued arguments\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function result\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the beta function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;gamma : the gamma function\n&quot;</span>
    <span class="s0">&quot;betainc :  the regularized incomplete beta function\n&quot;</span>
    <span class="s0">&quot;betaln : the natural logarithm of the absolute\n&quot;</span>
    <span class="s0">&quot;         value of the beta function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] NIST Digital Library of Mathematical Functions,\n&quot;</span>
    <span class="s0">&quot;       Eq. 5.12.1. https://dlmf.nist.gov/5.12\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The beta function relates to the gamma function by the\n&quot;</span>
    <span class="s0">&quot;definition given above:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.beta(2, 3)\n&quot;</span>
    <span class="s0">&quot;0.08333333333333333\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gamma(2)*sc.gamma(3)/sc.gamma(2 + 3)\n&quot;</span>
    <span class="s0">&quot;0.08333333333333333\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;As this relationship demonstrates, the beta function\n&quot;</span>
    <span class="s0">&quot;is symmetric:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.beta(1.7, 2.4)\n&quot;</span>
    <span class="s0">&quot;0.16567527689031739\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.beta(2.4, 1.7)\n&quot;</span>
    <span class="s0">&quot;0.16567527689031739\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function satisfies :math:`B(1, b) = 1/b`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.beta(1, 4)\n&quot;</span>
    <span class="s0">&quot;0.25&quot;)</span>
<span class="s0">ufunc_beta_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_beta_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_beta_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_beta_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_beta_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_beta_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_beta_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_beta_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_beta_ptr[2*0] = &lt;void*&gt;_func_beta</span>
<span class="s0">ufunc_beta_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;beta&quot;)</span>
<span class="s0">ufunc_beta_ptr[2*1] = &lt;void*&gt;_func_beta</span>
<span class="s0">ufunc_beta_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;beta&quot;)</span>
<span class="s0">ufunc_beta_data[0] = &amp;ufunc_beta_ptr[2*0]</span>
<span class="s0">ufunc_beta_data[1] = &amp;ufunc_beta_ptr[2*1]</span>
<span class="s0">beta = np.PyUFunc_FromFuncAndData(ufunc_beta_loops, ufunc_beta_data, ufunc_beta_types, 2, 2, 1, 0, &quot;beta&quot;, ufunc_beta_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_betainc_loops[2]</span>
<span class="s0">cdef void *ufunc_betainc_ptr[4]</span>
<span class="s0">cdef void *ufunc_betainc_data[2]</span>
<span class="s0">cdef char ufunc_betainc_types[8]</span>
<span class="s0">cdef char *ufunc_betainc_doc = (</span>
    <span class="s0">&quot;betainc(a, b, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Regularized incomplete beta function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes the regularized incomplete beta function, defined as [1]_:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    I_x(a, b) = \\frac{\\Gamma(a+b)}{\\Gamma(a)\\Gamma(b)} \\int_0^x\n&quot;</span>
    <span class="s0">&quot;    t^{a-1}(1-t)^{b-1}dt,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;for :math:`0 \\leq x \\leq 1`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a, b : array_like\n&quot;</span>
    <span class="s0">&quot;       Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued such that :math:`0 \\leq x \\leq 1`,\n&quot;</span>
    <span class="s0">&quot;    the upper limit of integration\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the regularized incomplete beta function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;beta : beta function\n&quot;</span>
    <span class="s0">&quot;betaincinv : inverse of the regularized incomplete beta function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The term *regularized* in the name of this function refers to the\n&quot;</span>
    <span class="s0">&quot;scaling of the function by the gamma function terms shown in the\n&quot;</span>
    <span class="s0">&quot;formula.  When not qualified as *regularized*, the name *incomplete\n&quot;</span>
    <span class="s0">&quot;beta function* often refers to just the integral expression,\n&quot;</span>
    <span class="s0">&quot;without the gamma terms.  One can use the function `beta` from\n&quot;</span>
    <span class="s0">&quot;`scipy.special` to get this \&quot;nonregularized\&quot; incomplete beta\n&quot;</span>
    <span class="s0">&quot;function by multiplying the result of ``betainc(a, b, x)`` by\n&quot;</span>
    <span class="s0">&quot;``beta(a, b)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] NIST Digital Library of Mathematical Functions\n&quot;</span>
    <span class="s0">&quot;       https://dlmf.nist.gov/8.17\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Let :math:`B(a, b)` be the `beta` function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The coefficient in terms of `gamma` is equal to\n&quot;</span>
    <span class="s0">&quot;:math:`1/B(a, b)`. Also, when :math:`x=1`\n&quot;</span>
    <span class="s0">&quot;the integral is equal to :math:`B(a, b)`.\n&quot;</span>
    <span class="s0">&quot;Therefore, :math:`I_{x=1}(a, b) = 1` for any :math:`a, b`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.betainc(0.2, 3.5, 1.0)\n&quot;</span>
    <span class="s0">&quot;1.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It satisfies\n&quot;</span>
    <span class="s0">&quot;:math:`I_x(a, b) = x^a F(a, 1-b, a+1, x)/ (aB(a, b))`,\n&quot;</span>
    <span class="s0">&quot;where :math:`F` is the hypergeometric function `hyp2f1`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a, b, x = 1.4, 3.1, 0.5\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x**a * sc.hyp2f1(a, 1 - b, a + 1, x)/(a * sc.beta(a, b))\n&quot;</span>
    <span class="s0">&quot;0.8148904036225295\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.betainc(a, b, x)\n&quot;</span>
    <span class="s0">&quot;0.8148904036225296\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This functions satisfies the relationship\n&quot;</span>
    <span class="s0">&quot;:math:`I_x(a, b) = 1 - I_{1-x}(b, a)`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.betainc(2.2, 3.1, 0.4)\n&quot;</span>
    <span class="s0">&quot;0.49339638807619446\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; 1 - sc.betainc(3.1, 2.2, 1 - 0.4)\n&quot;</span>
    <span class="s0">&quot;0.49339638807619446&quot;)</span>
<span class="s0">ufunc_betainc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_betainc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_betainc_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_betainc_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_betainc_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_betainc_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_betainc_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_betainc_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_betainc_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_betainc_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_betainc_ptr[2*0] = &lt;void*&gt;_func_incbet</span>
<span class="s0">ufunc_betainc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;betainc&quot;)</span>
<span class="s0">ufunc_betainc_ptr[2*1] = &lt;void*&gt;_func_incbet</span>
<span class="s0">ufunc_betainc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;betainc&quot;)</span>
<span class="s0">ufunc_betainc_data[0] = &amp;ufunc_betainc_ptr[2*0]</span>
<span class="s0">ufunc_betainc_data[1] = &amp;ufunc_betainc_ptr[2*1]</span>
<span class="s0">betainc = np.PyUFunc_FromFuncAndData(ufunc_betainc_loops, ufunc_betainc_data, ufunc_betainc_types, 2, 3, 1, 0, &quot;betainc&quot;, ufunc_betainc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_betaincinv_loops[2]</span>
<span class="s0">cdef void *ufunc_betaincinv_ptr[4]</span>
<span class="s0">cdef void *ufunc_betaincinv_data[2]</span>
<span class="s0">cdef char ufunc_betaincinv_types[8]</span>
<span class="s0">cdef char *ufunc_betaincinv_doc = (</span>
    <span class="s0">&quot;betaincinv(a, b, y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse of the regularized incomplete beta function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes :math:`x` such that:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    y = I_x(a, b) = \\frac{\\Gamma(a+b)}{\\Gamma(a)\\Gamma(b)}\n&quot;</span>
    <span class="s0">&quot;    \\int_0^x t^{a-1}(1-t)^{b-1}dt,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`I_x` is the normalized incomplete beta\n&quot;</span>
    <span class="s0">&quot;function `betainc` and\n&quot;</span>
    <span class="s0">&quot;:math:`\\Gamma` is the `gamma` function [1]_.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a, b : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;y : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued input\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the inverse of the regularized incomplete beta function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;betainc : regularized incomplete beta function\n&quot;</span>
    <span class="s0">&quot;gamma : gamma function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] NIST Digital Library of Mathematical Functions\n&quot;</span>
    <span class="s0">&quot;       https://dlmf.nist.gov/8.17\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is the inverse of `betainc` for fixed\n&quot;</span>
    <span class="s0">&quot;values of :math:`a` and :math:`b`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a, b = 1.2, 3.1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = sc.betainc(a, b, 0.2)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.betaincinv(a, b, y)\n&quot;</span>
    <span class="s0">&quot;0.2\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a, b = 7.5, 0.4\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = sc.betaincinv(a, b, 0.5)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.betainc(a, b, x)\n&quot;</span>
    <span class="s0">&quot;0.5&quot;)</span>
<span class="s0">ufunc_betaincinv_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_betaincinv_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_betaincinv_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_betaincinv_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_betaincinv_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_betaincinv_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_betaincinv_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_betaincinv_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_betaincinv_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_betaincinv_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_betaincinv_ptr[2*0] = &lt;void*&gt;_func_incbi</span>
<span class="s0">ufunc_betaincinv_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;betaincinv&quot;)</span>
<span class="s0">ufunc_betaincinv_ptr[2*1] = &lt;void*&gt;_func_incbi</span>
<span class="s0">ufunc_betaincinv_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;betaincinv&quot;)</span>
<span class="s0">ufunc_betaincinv_data[0] = &amp;ufunc_betaincinv_ptr[2*0]</span>
<span class="s0">ufunc_betaincinv_data[1] = &amp;ufunc_betaincinv_ptr[2*1]</span>
<span class="s0">betaincinv = np.PyUFunc_FromFuncAndData(ufunc_betaincinv_loops, ufunc_betaincinv_data, ufunc_betaincinv_types, 2, 3, 1, 0, &quot;betaincinv&quot;, ufunc_betaincinv_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_betaln_loops[2]</span>
<span class="s0">cdef void *ufunc_betaln_ptr[4]</span>
<span class="s0">cdef void *ufunc_betaln_data[2]</span>
<span class="s0">cdef char ufunc_betaln_types[6]</span>
<span class="s0">cdef char *ufunc_betaln_doc = (</span>
    <span class="s0">&quot;betaln(a, b, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Natural logarithm of absolute value of beta function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes ``ln(abs(beta(a, b)))``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a, b : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive, real-valued parameters\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the betaln function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;gamma : the gamma function\n&quot;</span>
    <span class="s0">&quot;betainc :  the regularized incomplete beta function\n&quot;</span>
    <span class="s0">&quot;beta : the beta function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import betaln, beta\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Verify that, for moderate values of ``a`` and ``b``, ``betaln(a, b)``\n&quot;</span>
    <span class="s0">&quot;is the same as ``log(beta(a, b))``:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; betaln(3, 4)\n&quot;</span>
    <span class="s0">&quot;-4.0943445622221\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.log(beta(3, 4))\n&quot;</span>
    <span class="s0">&quot;-4.0943445622221\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;In the following ``beta(a, b)`` underflows to 0, so we can't compute\n&quot;</span>
    <span class="s0">&quot;the logarithm of the actual value.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a = 400\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; b = 900\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; beta(a, b)\n&quot;</span>
    <span class="s0">&quot;0.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;We can compute the logarithm of ``beta(a, b)`` by using `betaln`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; betaln(a, b)\n&quot;</span>
    <span class="s0">&quot;-804.3069951764146&quot;)</span>
<span class="s0">ufunc_betaln_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_betaln_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_betaln_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_betaln_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_betaln_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_betaln_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_betaln_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_betaln_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_betaln_ptr[2*0] = &lt;void*&gt;_func_lbeta</span>
<span class="s0">ufunc_betaln_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;betaln&quot;)</span>
<span class="s0">ufunc_betaln_ptr[2*1] = &lt;void*&gt;_func_lbeta</span>
<span class="s0">ufunc_betaln_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;betaln&quot;)</span>
<span class="s0">ufunc_betaln_data[0] = &amp;ufunc_betaln_ptr[2*0]</span>
<span class="s0">ufunc_betaln_data[1] = &amp;ufunc_betaln_ptr[2*1]</span>
<span class="s0">betaln = np.PyUFunc_FromFuncAndData(ufunc_betaln_loops, ufunc_betaln_data, ufunc_betaln_types, 2, 2, 1, 0, &quot;betaln&quot;, ufunc_betaln_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_binom_loops[2]</span>
<span class="s0">cdef void *ufunc_binom_ptr[4]</span>
<span class="s0">cdef void *ufunc_binom_data[2]</span>
<span class="s0">cdef char ufunc_binom_types[6]</span>
<span class="s0">cdef char *ufunc_binom_doc = (</span>
    <span class="s0">&quot;binom(x, y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Binomial coefficient considered as a function of two real variables.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For real arguments, the binomial coefficient is defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    \\binom{x}{y} = \\frac{\\Gamma(x + 1)}{\\Gamma(y + 1)\\Gamma(x - y + 1)} =\n&quot;</span>
    <span class="s0">&quot;        \\frac{1}{(x + 1)\\mathrm{B}(x - y + 1, y + 1)}\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Where :math:`\\Gamma` is the Gamma function (`gamma`) and :math:`\\mathrm{B}`\n&quot;</span>
    <span class="s0">&quot;is the Beta function (`beta`) [1]_.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x, y: array_like\n&quot;</span>
    <span class="s0">&quot;   Real arguments to :math:`\\binom{x}{y}`.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of binomial coefficient.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;comb : The number of combinations of N things taken k at a time.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The Gamma function has poles at non-positive integers and tends to either\n&quot;</span>
    <span class="s0">&quot;positive or negative infinity depending on the direction on the real line\n&quot;</span>
    <span class="s0">&quot;from which a pole is approached. When considered as a function of two real\n&quot;</span>
    <span class="s0">&quot;variables, :math:`\\binom{x}{y}` is thus undefined when `x` is a negative\n&quot;</span>
    <span class="s0">&quot;integer.  `binom` returns ``nan`` when ``x`` is a negative integer. This\n&quot;</span>
    <span class="s0">&quot;is the case even when ``x`` is a negative integer and ``y`` an integer,\n&quot;</span>
    <span class="s0">&quot;contrary to the usual convention for defining :math:`\\binom{n}{k}` when it\n&quot;</span>
    <span class="s0">&quot;is considered as a function of two integer variables.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] https://en.wikipedia.org/wiki/Binomial_coefficient\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;The following examples illustrate the ways in which `binom` differs from\n&quot;</span>
    <span class="s0">&quot;the function `comb`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import binom, comb\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;When ``exact=False`` and ``x`` and ``y`` are both positive, `comb` calls\n&quot;</span>
    <span class="s0">&quot;`binom` internally.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x, y = 3, 2\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; (binom(x, y), comb(x, y), comb(x, y, exact=True))\n&quot;</span>
    <span class="s0">&quot;(3.0, 3.0, 3)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For larger values, `comb` with ``exact=True`` no longer agrees\n&quot;</span>
    <span class="s0">&quot;with `binom`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x, y = 43, 23\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; (binom(x, y), comb(x, y), comb(x, y, exact=True))\n&quot;</span>
    <span class="s0">&quot;(960566918219.9999, 960566918219.9999, 960566918220)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;`binom` returns ``nan`` when ``x`` is a negative integer, but is otherwise\n&quot;</span>
    <span class="s0">&quot;defined for negative arguments. `comb` returns 0 whenever one of ``x`` or\n&quot;</span>
    <span class="s0">&quot;``y`` is negative or ``x`` is less than ``y``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x, y = -3, 2\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; (binom(x, y), comb(x, y), comb(x, y, exact=True))\n&quot;</span>
    <span class="s0">&quot;(nan, 0.0, 0)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x, y = -3.1, 2.2\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; (binom(x, y), comb(x, y), comb(x, y, exact=True))\n&quot;</span>
    <span class="s0">&quot;(18.714147876804432, 0.0, 0)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x, y = 2.2, 3.1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; (binom(x, y), comb(x, y), comb(x, y, exact=True))\n&quot;</span>
    <span class="s0">&quot;(0.037399983365134115, 0.0, 0)&quot;)</span>
<span class="s0">ufunc_binom_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_binom_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_binom_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_binom_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_binom_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_binom_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_binom_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_binom_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_binom_ptr[2*0] = &lt;void*&gt;_func_binom</span>
<span class="s0">ufunc_binom_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;binom&quot;)</span>
<span class="s0">ufunc_binom_ptr[2*1] = &lt;void*&gt;_func_binom</span>
<span class="s0">ufunc_binom_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;binom&quot;)</span>
<span class="s0">ufunc_binom_data[0] = &amp;ufunc_binom_ptr[2*0]</span>
<span class="s0">ufunc_binom_data[1] = &amp;ufunc_binom_ptr[2*1]</span>
<span class="s0">binom = np.PyUFunc_FromFuncAndData(ufunc_binom_loops, ufunc_binom_data, ufunc_binom_types, 2, 2, 1, 0, &quot;binom&quot;, ufunc_binom_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_boxcox_loops[2]</span>
<span class="s0">cdef void *ufunc_boxcox_ptr[4]</span>
<span class="s0">cdef void *ufunc_boxcox_data[2]</span>
<span class="s0">cdef char ufunc_boxcox_types[6]</span>
<span class="s0">cdef char *ufunc_boxcox_doc = (</span>
    <span class="s0">&quot;boxcox(x, lmbda, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the Box-Cox transformation.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The Box-Cox transformation is::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    y = (x**lmbda - 1) / lmbda  if lmbda != 0\n&quot;</span>
    <span class="s0">&quot;        log(x)                  if lmbda == 0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns `nan` if ``x &lt; 0``.\n&quot;</span>
    <span class="s0">&quot;Returns `-inf` if ``x == 0`` and ``lmbda &lt; 0``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Data to be transformed.\n&quot;</span>
    <span class="s0">&quot;lmbda : array_like\n&quot;</span>
    <span class="s0">&quot;    Power parameter of the Box-Cox transform.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;y : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Transformed data.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 0.14.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import boxcox\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; boxcox([1, 4, 10], 2.5)\n&quot;</span>
    <span class="s0">&quot;array([   0.        ,   12.4       ,  126.09110641])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; boxcox(2, [0, 1, 2])\n&quot;</span>
    <span class="s0">&quot;array([ 0.69314718,  1.        ,  1.5       ])&quot;)</span>
<span class="s0">ufunc_boxcox_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_boxcox_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_boxcox_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_boxcox_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_boxcox_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_boxcox_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_boxcox_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_boxcox_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_boxcox_ptr[2*0] = &lt;void*&gt;_func_boxcox</span>
<span class="s0">ufunc_boxcox_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;boxcox&quot;)</span>
<span class="s0">ufunc_boxcox_ptr[2*1] = &lt;void*&gt;_func_boxcox</span>
<span class="s0">ufunc_boxcox_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;boxcox&quot;)</span>
<span class="s0">ufunc_boxcox_data[0] = &amp;ufunc_boxcox_ptr[2*0]</span>
<span class="s0">ufunc_boxcox_data[1] = &amp;ufunc_boxcox_ptr[2*1]</span>
<span class="s0">boxcox = np.PyUFunc_FromFuncAndData(ufunc_boxcox_loops, ufunc_boxcox_data, ufunc_boxcox_types, 2, 2, 1, 0, &quot;boxcox&quot;, ufunc_boxcox_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_boxcox1p_loops[2]</span>
<span class="s0">cdef void *ufunc_boxcox1p_ptr[4]</span>
<span class="s0">cdef void *ufunc_boxcox1p_data[2]</span>
<span class="s0">cdef char ufunc_boxcox1p_types[6]</span>
<span class="s0">cdef char *ufunc_boxcox1p_doc = (</span>
    <span class="s0">&quot;boxcox1p(x, lmbda, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the Box-Cox transformation of 1 + `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The Box-Cox transformation computed by `boxcox1p` is::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    y = ((1+x)**lmbda - 1) / lmbda  if lmbda != 0\n&quot;</span>
    <span class="s0">&quot;        log(1+x)                    if lmbda == 0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns `nan` if ``x &lt; -1``.\n&quot;</span>
    <span class="s0">&quot;Returns `-inf` if ``x == -1`` and ``lmbda &lt; 0``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Data to be transformed.\n&quot;</span>
    <span class="s0">&quot;lmbda : array_like\n&quot;</span>
    <span class="s0">&quot;    Power parameter of the Box-Cox transform.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;y : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Transformed data.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 0.14.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import boxcox1p\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; boxcox1p(1e-4, [0, 0.5, 1])\n&quot;</span>
    <span class="s0">&quot;array([  9.99950003e-05,   9.99975001e-05,   1.00000000e-04])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; boxcox1p([0.01, 0.1], 0.25)\n&quot;</span>
    <span class="s0">&quot;array([ 0.00996272,  0.09645476])&quot;)</span>
<span class="s0">ufunc_boxcox1p_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_boxcox1p_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_boxcox1p_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_boxcox1p_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_boxcox1p_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_boxcox1p_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_boxcox1p_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_boxcox1p_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_boxcox1p_ptr[2*0] = &lt;void*&gt;_func_boxcox1p</span>
<span class="s0">ufunc_boxcox1p_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;boxcox1p&quot;)</span>
<span class="s0">ufunc_boxcox1p_ptr[2*1] = &lt;void*&gt;_func_boxcox1p</span>
<span class="s0">ufunc_boxcox1p_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;boxcox1p&quot;)</span>
<span class="s0">ufunc_boxcox1p_data[0] = &amp;ufunc_boxcox1p_ptr[2*0]</span>
<span class="s0">ufunc_boxcox1p_data[1] = &amp;ufunc_boxcox1p_ptr[2*1]</span>
<span class="s0">boxcox1p = np.PyUFunc_FromFuncAndData(ufunc_boxcox1p_loops, ufunc_boxcox1p_data, ufunc_boxcox1p_types, 2, 2, 1, 0, &quot;boxcox1p&quot;, ufunc_boxcox1p_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_btdtr_loops[2]</span>
<span class="s0">cdef void *ufunc_btdtr_ptr[4]</span>
<span class="s0">cdef void *ufunc_btdtr_data[2]</span>
<span class="s0">cdef char ufunc_btdtr_types[8]</span>
<span class="s0">cdef char *ufunc_btdtr_doc = (</span>
    <span class="s0">&quot;btdtr(a, b, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Cumulative distribution function of the beta distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the integral from zero to `x` of the beta probability density\n&quot;</span>
    <span class="s0">&quot;function,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    I = \\int_0^x \\frac{\\Gamma(a + b)}{\\Gamma(a)\\Gamma(b)} t^{a-1} (1-t)^{b-1}\\,dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`\\Gamma` is the gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a : array_like\n&quot;</span>
    <span class="s0">&quot;    Shape parameter (a &gt; 0).\n&quot;</span>
    <span class="s0">&quot;b : array_like\n&quot;</span>
    <span class="s0">&quot;    Shape parameter (b &gt; 0).\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Upper limit of integration, in [0, 1].\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;I : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Cumulative distribution function of the beta distribution with\n&quot;</span>
    <span class="s0">&quot;    parameters `a` and `b` at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;betainc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;This function is identical to the incomplete beta integral function\n&quot;</span>
    <span class="s0">&quot;`betainc`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `btdtr`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/&quot;)</span>
<span class="s0">ufunc_btdtr_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_btdtr_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_btdtr_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_btdtr_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_btdtr_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_btdtr_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_btdtr_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_btdtr_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_btdtr_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_btdtr_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_btdtr_ptr[2*0] = &lt;void*&gt;_func_btdtr</span>
<span class="s0">ufunc_btdtr_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;btdtr&quot;)</span>
<span class="s0">ufunc_btdtr_ptr[2*1] = &lt;void*&gt;_func_btdtr</span>
<span class="s0">ufunc_btdtr_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;btdtr&quot;)</span>
<span class="s0">ufunc_btdtr_data[0] = &amp;ufunc_btdtr_ptr[2*0]</span>
<span class="s0">ufunc_btdtr_data[1] = &amp;ufunc_btdtr_ptr[2*1]</span>
<span class="s0">btdtr = np.PyUFunc_FromFuncAndData(ufunc_btdtr_loops, ufunc_btdtr_data, ufunc_btdtr_types, 2, 3, 1, 0, &quot;btdtr&quot;, ufunc_btdtr_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_btdtri_loops[2]</span>
<span class="s0">cdef void *ufunc_btdtri_ptr[4]</span>
<span class="s0">cdef void *ufunc_btdtri_data[2]</span>
<span class="s0">cdef char ufunc_btdtri_types[8]</span>
<span class="s0">cdef char *ufunc_btdtri_doc = (</span>
    <span class="s0">&quot;btdtri(a, b, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The `p`-th quantile of the beta distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is the inverse of the beta cumulative distribution function,\n&quot;</span>
    <span class="s0">&quot;`btdtr`, returning the value of `x` for which `btdtr(a, b, x) = p`, or\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    p = \\int_0^x \\frac{\\Gamma(a + b)}{\\Gamma(a)\\Gamma(b)} t^{a-1} (1-t)^{b-1}\\,dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a : array_like\n&quot;</span>
    <span class="s0">&quot;    Shape parameter (`a` &gt; 0).\n&quot;</span>
    <span class="s0">&quot;b : array_like\n&quot;</span>
    <span class="s0">&quot;    Shape parameter (`b` &gt; 0).\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Cumulative probability, in [0, 1].\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;x : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The quantile corresponding to `p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;betaincinv\n&quot;</span>
    <span class="s0">&quot;btdtr\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The value of `x` is found by interval halving or Newton iterations.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `incbi`, which solves the equivalent\n&quot;</span>
    <span class="s0">&quot;problem of finding the inverse of the incomplete beta integral.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/&quot;)</span>
<span class="s0">ufunc_btdtri_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_btdtri_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_btdtri_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_btdtri_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_btdtri_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_btdtri_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_btdtri_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_btdtri_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_btdtri_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_btdtri_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_btdtri_ptr[2*0] = &lt;void*&gt;_func_incbi</span>
<span class="s0">ufunc_btdtri_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;btdtri&quot;)</span>
<span class="s0">ufunc_btdtri_ptr[2*1] = &lt;void*&gt;_func_incbi</span>
<span class="s0">ufunc_btdtri_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;btdtri&quot;)</span>
<span class="s0">ufunc_btdtri_data[0] = &amp;ufunc_btdtri_ptr[2*0]</span>
<span class="s0">ufunc_btdtri_data[1] = &amp;ufunc_btdtri_ptr[2*1]</span>
<span class="s0">btdtri = np.PyUFunc_FromFuncAndData(ufunc_btdtri_loops, ufunc_btdtri_data, ufunc_btdtri_types, 2, 3, 1, 0, &quot;btdtri&quot;, ufunc_btdtri_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_btdtria_loops[2]</span>
<span class="s0">cdef void *ufunc_btdtria_ptr[4]</span>
<span class="s0">cdef void *ufunc_btdtria_data[2]</span>
<span class="s0">cdef char ufunc_btdtria_types[8]</span>
<span class="s0">cdef char *ufunc_btdtria_doc = (</span>
    <span class="s0">&quot;btdtria(p, b, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse of `btdtr` with respect to `a`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This is the inverse of the beta cumulative distribution function, `btdtr`,\n&quot;</span>
    <span class="s0">&quot;considered as a function of `a`, returning the value of `a` for which\n&quot;</span>
    <span class="s0">&quot;`btdtr(a, b, x) = p`, or\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    p = \\int_0^x \\frac{\\Gamma(a + b)}{\\Gamma(a)\\Gamma(b)} t^{a-1} (1-t)^{b-1}\\,dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Cumulative probability, in [0, 1].\n&quot;</span>
    <span class="s0">&quot;b : array_like\n&quot;</span>
    <span class="s0">&quot;    Shape parameter (`b` &gt; 0).\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    The quantile, in [0, 1].\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;a : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The value of the shape parameter `a` such that `btdtr(a, b, x) = p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;btdtr : Cumulative distribution function of the beta distribution.\n&quot;</span>
    <span class="s0">&quot;btdtri : Inverse with respect to `x`.\n&quot;</span>
    <span class="s0">&quot;btdtrib : Inverse with respect to `b`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for the CDFLIB [1]_ Fortran routine `cdfbet`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The cumulative distribution function `p` is computed using a routine by\n&quot;</span>
    <span class="s0">&quot;DiDinato and Morris [2]_. Computation of `a` involves a search for a value\n&quot;</span>
    <span class="s0">&quot;that produces the desired value of `p`. The search relies on the\n&quot;</span>
    <span class="s0">&quot;monotonicity of `p` with `a`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Barry Brown, James Lovato, and Kathy Russell,\n&quot;</span>
    <span class="s0">&quot;       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n&quot;</span>
    <span class="s0">&quot;       Functions, Inverses, and Other Parameters.\n&quot;</span>
    <span class="s0">&quot;.. [2] DiDinato, A. R. and Morris, A. H.,\n&quot;</span>
    <span class="s0">&quot;       Algorithm 708: Significant Digit Computation of the Incomplete Beta\n&quot;</span>
    <span class="s0">&quot;       Function Ratios. ACM Trans. Math. Softw. 18 (1993), 360-373.&quot;)</span>
<span class="s0">ufunc_btdtria_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_btdtria_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_btdtria_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_btdtria_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_btdtria_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_btdtria_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_btdtria_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_btdtria_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_btdtria_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_btdtria_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_btdtria_ptr[2*0] = &lt;void*&gt;_func_cdfbet3_wrap</span>
<span class="s0">ufunc_btdtria_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;btdtria&quot;)</span>
<span class="s0">ufunc_btdtria_ptr[2*1] = &lt;void*&gt;_func_cdfbet3_wrap</span>
<span class="s0">ufunc_btdtria_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;btdtria&quot;)</span>
<span class="s0">ufunc_btdtria_data[0] = &amp;ufunc_btdtria_ptr[2*0]</span>
<span class="s0">ufunc_btdtria_data[1] = &amp;ufunc_btdtria_ptr[2*1]</span>
<span class="s0">btdtria = np.PyUFunc_FromFuncAndData(ufunc_btdtria_loops, ufunc_btdtria_data, ufunc_btdtria_types, 2, 3, 1, 0, &quot;btdtria&quot;, ufunc_btdtria_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_btdtrib_loops[2]</span>
<span class="s0">cdef void *ufunc_btdtrib_ptr[4]</span>
<span class="s0">cdef void *ufunc_btdtrib_data[2]</span>
<span class="s0">cdef char ufunc_btdtrib_types[8]</span>
<span class="s0">cdef char *ufunc_btdtrib_doc = (</span>
    <span class="s0">&quot;btdtria(a, p, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse of `btdtr` with respect to `b`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This is the inverse of the beta cumulative distribution function, `btdtr`,\n&quot;</span>
    <span class="s0">&quot;considered as a function of `b`, returning the value of `b` for which\n&quot;</span>
    <span class="s0">&quot;`btdtr(a, b, x) = p`, or\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    p = \\int_0^x \\frac{\\Gamma(a + b)}{\\Gamma(a)\\Gamma(b)} t^{a-1} (1-t)^{b-1}\\,dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a : array_like\n&quot;</span>
    <span class="s0">&quot;    Shape parameter (`a` &gt; 0).\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Cumulative probability, in [0, 1].\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    The quantile, in [0, 1].\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;b : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The value of the shape parameter `b` such that `btdtr(a, b, x) = p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;btdtr : Cumulative distribution function of the beta distribution.\n&quot;</span>
    <span class="s0">&quot;btdtri : Inverse with respect to `x`.\n&quot;</span>
    <span class="s0">&quot;btdtria : Inverse with respect to `a`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for the CDFLIB [1]_ Fortran routine `cdfbet`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The cumulative distribution function `p` is computed using a routine by\n&quot;</span>
    <span class="s0">&quot;DiDinato and Morris [2]_. Computation of `b` involves a search for a value\n&quot;</span>
    <span class="s0">&quot;that produces the desired value of `p`. The search relies on the\n&quot;</span>
    <span class="s0">&quot;monotonicity of `p` with `b`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Barry Brown, James Lovato, and Kathy Russell,\n&quot;</span>
    <span class="s0">&quot;       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n&quot;</span>
    <span class="s0">&quot;       Functions, Inverses, and Other Parameters.\n&quot;</span>
    <span class="s0">&quot;.. [2] DiDinato, A. R. and Morris, A. H.,\n&quot;</span>
    <span class="s0">&quot;       Algorithm 708: Significant Digit Computation of the Incomplete Beta\n&quot;</span>
    <span class="s0">&quot;       Function Ratios. ACM Trans. Math. Softw. 18 (1993), 360-373.&quot;)</span>
<span class="s0">ufunc_btdtrib_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_btdtrib_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_btdtrib_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_btdtrib_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_btdtrib_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_btdtrib_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_btdtrib_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_btdtrib_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_btdtrib_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_btdtrib_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_btdtrib_ptr[2*0] = &lt;void*&gt;_func_cdfbet4_wrap</span>
<span class="s0">ufunc_btdtrib_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;btdtrib&quot;)</span>
<span class="s0">ufunc_btdtrib_ptr[2*1] = &lt;void*&gt;_func_cdfbet4_wrap</span>
<span class="s0">ufunc_btdtrib_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;btdtrib&quot;)</span>
<span class="s0">ufunc_btdtrib_data[0] = &amp;ufunc_btdtrib_ptr[2*0]</span>
<span class="s0">ufunc_btdtrib_data[1] = &amp;ufunc_btdtrib_ptr[2*1]</span>
<span class="s0">btdtrib = np.PyUFunc_FromFuncAndData(ufunc_btdtrib_loops, ufunc_btdtrib_data, ufunc_btdtrib_types, 2, 3, 1, 0, &quot;btdtrib&quot;, ufunc_btdtrib_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_cbrt_loops[2]</span>
<span class="s0">cdef void *ufunc_cbrt_ptr[4]</span>
<span class="s0">cdef void *ufunc_cbrt_data[2]</span>
<span class="s0">cdef char ufunc_cbrt_types[4]</span>
<span class="s0">cdef char *ufunc_cbrt_doc = (</span>
    <span class="s0">&quot;cbrt(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Element-wise cube root of `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    `x` must contain real numbers.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The cube root of each value in `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import cbrt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cbrt(8)\n&quot;</span>
    <span class="s0">&quot;2.0\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cbrt([-8, -3, 0.125, 1.331])\n&quot;</span>
    <span class="s0">&quot;array([-2.        , -1.44224957,  0.5       ,  1.1       ])&quot;)</span>
<span class="s0">ufunc_cbrt_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_cbrt_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_cbrt_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_cbrt_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_cbrt_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_cbrt_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_cbrt_ptr[2*0] = &lt;void*&gt;_func_cbrt</span>
<span class="s0">ufunc_cbrt_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;cbrt&quot;)</span>
<span class="s0">ufunc_cbrt_ptr[2*1] = &lt;void*&gt;_func_cbrt</span>
<span class="s0">ufunc_cbrt_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;cbrt&quot;)</span>
<span class="s0">ufunc_cbrt_data[0] = &amp;ufunc_cbrt_ptr[2*0]</span>
<span class="s0">ufunc_cbrt_data[1] = &amp;ufunc_cbrt_ptr[2*1]</span>
<span class="s0">cbrt = np.PyUFunc_FromFuncAndData(ufunc_cbrt_loops, ufunc_cbrt_data, ufunc_cbrt_types, 2, 1, 1, 0, &quot;cbrt&quot;, ufunc_cbrt_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_chdtr_loops[2]</span>
<span class="s0">cdef void *ufunc_chdtr_ptr[4]</span>
<span class="s0">cdef void *ufunc_chdtr_data[2]</span>
<span class="s0">cdef char ufunc_chdtr_types[6]</span>
<span class="s0">cdef char *ufunc_chdtr_doc = (</span>
    <span class="s0">&quot;chdtr(v, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Chi square cumulative distribution function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the area under the left tail (from 0 to `x`) of the Chi\n&quot;</span>
    <span class="s0">&quot;square probability density function with `v` degrees of freedom:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    \\frac{1}{2^{v/2} \\Gamma(v/2)} \\int_0^x t^{v/2 - 1} e^{-t/2} dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Here :math:`\\Gamma` is the Gamma function; see `gamma`. This\n&quot;</span>
    <span class="s0">&quot;integral can be expressed in terms of the regularized lower\n&quot;</span>
    <span class="s0">&quot;incomplete gamma function `gammainc` as\n&quot;</span>
    <span class="s0">&quot;``gammainc(v / 2, x / 2)``. [1]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;v : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom.\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Upper bound of the integral.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the cumulative distribution function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;chdtrc, chdtri, chdtriv, gammainc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Chi-Square distribution,\n&quot;</span>
    <span class="s0">&quot;    https://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It can be expressed in terms of the regularized lower incomplete\n&quot;</span>
    <span class="s0">&quot;gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; v = 1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.arange(4)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.chdtr(v, x)\n&quot;</span>
    <span class="s0">&quot;array([0.        , 0.68268949, 0.84270079, 0.91673548])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gammainc(v / 2, x / 2)\n&quot;</span>
    <span class="s0">&quot;array([0.        , 0.68268949, 0.84270079, 0.91673548])&quot;)</span>
<span class="s0">ufunc_chdtr_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_chdtr_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_chdtr_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chdtr_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chdtr_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chdtr_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chdtr_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chdtr_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chdtr_ptr[2*0] = &lt;void*&gt;_func_chdtr</span>
<span class="s0">ufunc_chdtr_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;chdtr&quot;)</span>
<span class="s0">ufunc_chdtr_ptr[2*1] = &lt;void*&gt;_func_chdtr</span>
<span class="s0">ufunc_chdtr_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;chdtr&quot;)</span>
<span class="s0">ufunc_chdtr_data[0] = &amp;ufunc_chdtr_ptr[2*0]</span>
<span class="s0">ufunc_chdtr_data[1] = &amp;ufunc_chdtr_ptr[2*1]</span>
<span class="s0">chdtr = np.PyUFunc_FromFuncAndData(ufunc_chdtr_loops, ufunc_chdtr_data, ufunc_chdtr_types, 2, 2, 1, 0, &quot;chdtr&quot;, ufunc_chdtr_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_chdtrc_loops[2]</span>
<span class="s0">cdef void *ufunc_chdtrc_ptr[4]</span>
<span class="s0">cdef void *ufunc_chdtrc_data[2]</span>
<span class="s0">cdef char ufunc_chdtrc_types[6]</span>
<span class="s0">cdef char *ufunc_chdtrc_doc = (</span>
    <span class="s0">&quot;chdtrc(v, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Chi square survival function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the area under the right hand tail (from `x` to infinity)\n&quot;</span>
    <span class="s0">&quot;of the Chi square probability density function with `v` degrees of\n&quot;</span>
    <span class="s0">&quot;freedom:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    \\frac{1}{2^{v/2} \\Gamma(v/2)} \\int_x^\\infty t^{v/2 - 1} e^{-t/2} dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Here :math:`\\Gamma` is the Gamma function; see `gamma`. This\n&quot;</span>
    <span class="s0">&quot;integral can be expressed in terms of the regularized upper\n&quot;</span>
    <span class="s0">&quot;incomplete gamma function `gammaincc` as\n&quot;</span>
    <span class="s0">&quot;``gammaincc(v / 2, x / 2)``. [1]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;v : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom.\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Lower bound of the integral.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the survival function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;chdtr, chdtri, chdtriv, gammaincc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Chi-Square distribution,\n&quot;</span>
    <span class="s0">&quot;    https://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It can be expressed in terms of the regularized upper incomplete\n&quot;</span>
    <span class="s0">&quot;gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; v = 1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.arange(4)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.chdtrc(v, x)\n&quot;</span>
    <span class="s0">&quot;array([1.        , 0.31731051, 0.15729921, 0.08326452])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gammaincc(v / 2, x / 2)\n&quot;</span>
    <span class="s0">&quot;array([1.        , 0.31731051, 0.15729921, 0.08326452])&quot;)</span>
<span class="s0">ufunc_chdtrc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_chdtrc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_chdtrc_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chdtrc_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chdtrc_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chdtrc_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chdtrc_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chdtrc_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chdtrc_ptr[2*0] = &lt;void*&gt;_func_chdtrc</span>
<span class="s0">ufunc_chdtrc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;chdtrc&quot;)</span>
<span class="s0">ufunc_chdtrc_ptr[2*1] = &lt;void*&gt;_func_chdtrc</span>
<span class="s0">ufunc_chdtrc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;chdtrc&quot;)</span>
<span class="s0">ufunc_chdtrc_data[0] = &amp;ufunc_chdtrc_ptr[2*0]</span>
<span class="s0">ufunc_chdtrc_data[1] = &amp;ufunc_chdtrc_ptr[2*1]</span>
<span class="s0">chdtrc = np.PyUFunc_FromFuncAndData(ufunc_chdtrc_loops, ufunc_chdtrc_data, ufunc_chdtrc_types, 2, 2, 1, 0, &quot;chdtrc&quot;, ufunc_chdtrc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_chdtri_loops[2]</span>
<span class="s0">cdef void *ufunc_chdtri_ptr[4]</span>
<span class="s0">cdef void *ufunc_chdtri_data[2]</span>
<span class="s0">cdef char ufunc_chdtri_types[6]</span>
<span class="s0">cdef char *ufunc_chdtri_doc = (</span>
    <span class="s0">&quot;chdtri(v, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse to `chdtrc` with respect to `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns `x` such that ``chdtrc(v, x) == p``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;v : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom.\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;x : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value so that the probability a Chi square random variable\n&quot;</span>
    <span class="s0">&quot;    with `v` degrees of freedom is greater than `x` equals `p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;chdtrc, chdtr, chdtriv\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Chi-Square distribution,\n&quot;</span>
    <span class="s0">&quot;    https://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It inverts `chdtrc`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; v, p = 1, 0.3\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.chdtrc(v, sc.chdtri(v, p))\n&quot;</span>
    <span class="s0">&quot;0.3\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.chdtri(v, sc.chdtrc(v, x))\n&quot;</span>
    <span class="s0">&quot;1.0&quot;)</span>
<span class="s0">ufunc_chdtri_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_chdtri_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_chdtri_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chdtri_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chdtri_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chdtri_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chdtri_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chdtri_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chdtri_ptr[2*0] = &lt;void*&gt;_func_chdtri</span>
<span class="s0">ufunc_chdtri_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;chdtri&quot;)</span>
<span class="s0">ufunc_chdtri_ptr[2*1] = &lt;void*&gt;_func_chdtri</span>
<span class="s0">ufunc_chdtri_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;chdtri&quot;)</span>
<span class="s0">ufunc_chdtri_data[0] = &amp;ufunc_chdtri_ptr[2*0]</span>
<span class="s0">ufunc_chdtri_data[1] = &amp;ufunc_chdtri_ptr[2*1]</span>
<span class="s0">chdtri = np.PyUFunc_FromFuncAndData(ufunc_chdtri_loops, ufunc_chdtri_data, ufunc_chdtri_types, 2, 2, 1, 0, &quot;chdtri&quot;, ufunc_chdtri_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_chdtriv_loops[2]</span>
<span class="s0">cdef void *ufunc_chdtriv_ptr[4]</span>
<span class="s0">cdef void *ufunc_chdtriv_data[2]</span>
<span class="s0">cdef char ufunc_chdtriv_types[6]</span>
<span class="s0">cdef char *ufunc_chdtriv_doc = (</span>
    <span class="s0">&quot;chdtriv(p, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse to `chdtr` with respect to `v`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns `v` such that ``chdtr(v, x) == p``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability that the Chi square random variable is less than\n&quot;</span>
    <span class="s0">&quot;    or equal to `x`.\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Nonnegative input.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;chdtr, chdtrc, chdtri\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Chi-Square distribution,\n&quot;</span>
    <span class="s0">&quot;    https://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It inverts `chdtr`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p, x = 0.5, 1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.chdtr(sc.chdtriv(p, x), x)\n&quot;</span>
    <span class="s0">&quot;0.5000000000202172\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; v = 1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.chdtriv(sc.chdtr(v, x), v)\n&quot;</span>
    <span class="s0">&quot;1.0000000000000013&quot;)</span>
<span class="s0">ufunc_chdtriv_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_chdtriv_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_chdtriv_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chdtriv_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chdtriv_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chdtriv_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chdtriv_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chdtriv_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chdtriv_ptr[2*0] = &lt;void*&gt;_func_cdfchi3_wrap</span>
<span class="s0">ufunc_chdtriv_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;chdtriv&quot;)</span>
<span class="s0">ufunc_chdtriv_ptr[2*1] = &lt;void*&gt;_func_cdfchi3_wrap</span>
<span class="s0">ufunc_chdtriv_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;chdtriv&quot;)</span>
<span class="s0">ufunc_chdtriv_data[0] = &amp;ufunc_chdtriv_ptr[2*0]</span>
<span class="s0">ufunc_chdtriv_data[1] = &amp;ufunc_chdtriv_ptr[2*1]</span>
<span class="s0">chdtriv = np.PyUFunc_FromFuncAndData(ufunc_chdtriv_loops, ufunc_chdtriv_data, ufunc_chdtriv_types, 2, 2, 1, 0, &quot;chdtriv&quot;, ufunc_chdtriv_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_chndtr_loops[2]</span>
<span class="s0">cdef void *ufunc_chndtr_ptr[4]</span>
<span class="s0">cdef void *ufunc_chndtr_data[2]</span>
<span class="s0">cdef char ufunc_chndtr_types[8]</span>
<span class="s0">cdef char *ufunc_chndtr_doc = (</span>
    <span class="s0">&quot;chndtr(x, df, nc, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Non-central chi square cumulative distribution function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The cumulative distribution function is given by:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    P(\\chi^{\\prime 2} \\vert \\nu, \\lambda) =\\sum_{j=0}^{\\infty}\n&quot;</span>
    <span class="s0">&quot;    e^{-\\lambda /2}\n&quot;</span>
    <span class="s0">&quot;    \\frac{(\\lambda /2)^j}{j!} P(\\chi^{\\prime 2} \\vert \\nu + 2j),\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`\\nu &gt; 0` is the degrees of freedom (``df``) and\n&quot;</span>
    <span class="s0">&quot;:math:`\\lambda \\geq 0` is the non-centrality parameter (``nc``).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Upper bound of the integral; must satisfy ``x &gt;= 0``\n&quot;</span>
    <span class="s0">&quot;df : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom; must satisfy ``df &gt; 0``\n&quot;</span>
    <span class="s0">&quot;nc : array_like\n&quot;</span>
    <span class="s0">&quot;    Non-centrality parameter; must satisfy ``nc &gt;= 0``\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;x : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the non-central chi square cumulative distribution function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;chndtrix, chndtridf, chndtrinc&quot;)</span>
<span class="s0">ufunc_chndtr_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_chndtr_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_chndtr_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chndtr_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chndtr_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chndtr_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chndtr_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chndtr_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chndtr_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chndtr_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chndtr_ptr[2*0] = &lt;void*&gt;_func_cdfchn1_wrap</span>
<span class="s0">ufunc_chndtr_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;chndtr&quot;)</span>
<span class="s0">ufunc_chndtr_ptr[2*1] = &lt;void*&gt;_func_cdfchn1_wrap</span>
<span class="s0">ufunc_chndtr_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;chndtr&quot;)</span>
<span class="s0">ufunc_chndtr_data[0] = &amp;ufunc_chndtr_ptr[2*0]</span>
<span class="s0">ufunc_chndtr_data[1] = &amp;ufunc_chndtr_ptr[2*1]</span>
<span class="s0">chndtr = np.PyUFunc_FromFuncAndData(ufunc_chndtr_loops, ufunc_chndtr_data, ufunc_chndtr_types, 2, 3, 1, 0, &quot;chndtr&quot;, ufunc_chndtr_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_chndtridf_loops[2]</span>
<span class="s0">cdef void *ufunc_chndtridf_ptr[4]</span>
<span class="s0">cdef void *ufunc_chndtridf_data[2]</span>
<span class="s0">cdef char ufunc_chndtridf_types[8]</span>
<span class="s0">cdef char *ufunc_chndtridf_doc = (</span>
    <span class="s0">&quot;chndtridf(x, p, nc, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse to `chndtr` vs `df`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculated using a search to find a value for `df` that produces the\n&quot;</span>
    <span class="s0">&quot;desired value of `p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Upper bound of the integral; must satisfy ``x &gt;= 0``\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability; must satisfy ``0 &lt;= p &lt; 1``\n&quot;</span>
    <span class="s0">&quot;nc : array_like\n&quot;</span>
    <span class="s0">&quot;    Non-centrality parameter; must satisfy ``nc &gt;= 0``\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;df : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;chndtr, chndtrix, chndtrinc&quot;)</span>
<span class="s0">ufunc_chndtridf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_chndtridf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_chndtridf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chndtridf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chndtridf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chndtridf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chndtridf_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chndtridf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chndtridf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chndtridf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chndtridf_ptr[2*0] = &lt;void*&gt;_func_cdfchn3_wrap</span>
<span class="s0">ufunc_chndtridf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;chndtridf&quot;)</span>
<span class="s0">ufunc_chndtridf_ptr[2*1] = &lt;void*&gt;_func_cdfchn3_wrap</span>
<span class="s0">ufunc_chndtridf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;chndtridf&quot;)</span>
<span class="s0">ufunc_chndtridf_data[0] = &amp;ufunc_chndtridf_ptr[2*0]</span>
<span class="s0">ufunc_chndtridf_data[1] = &amp;ufunc_chndtridf_ptr[2*1]</span>
<span class="s0">chndtridf = np.PyUFunc_FromFuncAndData(ufunc_chndtridf_loops, ufunc_chndtridf_data, ufunc_chndtridf_types, 2, 3, 1, 0, &quot;chndtridf&quot;, ufunc_chndtridf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_chndtrinc_loops[2]</span>
<span class="s0">cdef void *ufunc_chndtrinc_ptr[4]</span>
<span class="s0">cdef void *ufunc_chndtrinc_data[2]</span>
<span class="s0">cdef char ufunc_chndtrinc_types[8]</span>
<span class="s0">cdef char *ufunc_chndtrinc_doc = (</span>
    <span class="s0">&quot;chndtrinc(x, df, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse to `chndtr` vs `nc`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculated using a search to find a value for `df` that produces the\n&quot;</span>
    <span class="s0">&quot;desired value of `p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Upper bound of the integral; must satisfy ``x &gt;= 0``\n&quot;</span>
    <span class="s0">&quot;df : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom; must satisfy ``df &gt; 0``\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability; must satisfy ``0 &lt;= p &lt; 1``\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;nc : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Non-centrality\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;chndtr, chndtrix, chndtrinc&quot;)</span>
<span class="s0">ufunc_chndtrinc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_chndtrinc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_chndtrinc_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chndtrinc_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chndtrinc_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chndtrinc_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chndtrinc_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chndtrinc_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chndtrinc_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chndtrinc_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chndtrinc_ptr[2*0] = &lt;void*&gt;_func_cdfchn4_wrap</span>
<span class="s0">ufunc_chndtrinc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;chndtrinc&quot;)</span>
<span class="s0">ufunc_chndtrinc_ptr[2*1] = &lt;void*&gt;_func_cdfchn4_wrap</span>
<span class="s0">ufunc_chndtrinc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;chndtrinc&quot;)</span>
<span class="s0">ufunc_chndtrinc_data[0] = &amp;ufunc_chndtrinc_ptr[2*0]</span>
<span class="s0">ufunc_chndtrinc_data[1] = &amp;ufunc_chndtrinc_ptr[2*1]</span>
<span class="s0">chndtrinc = np.PyUFunc_FromFuncAndData(ufunc_chndtrinc_loops, ufunc_chndtrinc_data, ufunc_chndtrinc_types, 2, 3, 1, 0, &quot;chndtrinc&quot;, ufunc_chndtrinc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_chndtrix_loops[2]</span>
<span class="s0">cdef void *ufunc_chndtrix_ptr[4]</span>
<span class="s0">cdef void *ufunc_chndtrix_data[2]</span>
<span class="s0">cdef char ufunc_chndtrix_types[8]</span>
<span class="s0">cdef char *ufunc_chndtrix_doc = (</span>
    <span class="s0">&quot;chndtrix(p, df, nc, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse to `chndtr` vs `x`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculated using a search to find a value for `x` that produces the\n&quot;</span>
    <span class="s0">&quot;desired value of `p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability; must satisfy ``0 &lt;= p &lt; 1``\n&quot;</span>
    <span class="s0">&quot;df : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom; must satisfy ``df &gt; 0``\n&quot;</span>
    <span class="s0">&quot;nc : array_like\n&quot;</span>
    <span class="s0">&quot;    Non-centrality parameter; must satisfy ``nc &gt;= 0``\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;x : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value so that the probability a non-central Chi square random variable\n&quot;</span>
    <span class="s0">&quot;    with `df` degrees of freedom and non-centrality, `nc`, is greater than\n&quot;</span>
    <span class="s0">&quot;    `x` equals `p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;chndtr, chndtridf, chndtrinc&quot;)</span>
<span class="s0">ufunc_chndtrix_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_chndtrix_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_chndtrix_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chndtrix_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chndtrix_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chndtrix_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_chndtrix_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chndtrix_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chndtrix_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chndtrix_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_chndtrix_ptr[2*0] = &lt;void*&gt;_func_cdfchn2_wrap</span>
<span class="s0">ufunc_chndtrix_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;chndtrix&quot;)</span>
<span class="s0">ufunc_chndtrix_ptr[2*1] = &lt;void*&gt;_func_cdfchn2_wrap</span>
<span class="s0">ufunc_chndtrix_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;chndtrix&quot;)</span>
<span class="s0">ufunc_chndtrix_data[0] = &amp;ufunc_chndtrix_ptr[2*0]</span>
<span class="s0">ufunc_chndtrix_data[1] = &amp;ufunc_chndtrix_ptr[2*1]</span>
<span class="s0">chndtrix = np.PyUFunc_FromFuncAndData(ufunc_chndtrix_loops, ufunc_chndtrix_data, ufunc_chndtrix_types, 2, 3, 1, 0, &quot;chndtrix&quot;, ufunc_chndtrix_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_cosdg_loops[2]</span>
<span class="s0">cdef void *ufunc_cosdg_ptr[4]</span>
<span class="s0">cdef void *ufunc_cosdg_data[2]</span>
<span class="s0">cdef char ufunc_cosdg_types[4]</span>
<span class="s0">cdef char *ufunc_cosdg_doc = (</span>
    <span class="s0">&quot;cosdg(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Cosine of the angle `x` given in degrees.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Angle, given in degrees.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Cosine of the input.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;sindg, tandg, cotdg\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is more accurate than using cosine directly.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 90 + 180 * np.arange(3)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.cosdg(x)\n&quot;</span>
    <span class="s0">&quot;array([-0.,  0., -0.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.cos(x * np.pi / 180)\n&quot;</span>
    <span class="s0">&quot;array([ 6.1232340e-17, -1.8369702e-16,  3.0616170e-16])&quot;)</span>
<span class="s0">ufunc_cosdg_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_cosdg_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_cosdg_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_cosdg_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_cosdg_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_cosdg_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_cosdg_ptr[2*0] = &lt;void*&gt;_func_cosdg</span>
<span class="s0">ufunc_cosdg_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;cosdg&quot;)</span>
<span class="s0">ufunc_cosdg_ptr[2*1] = &lt;void*&gt;_func_cosdg</span>
<span class="s0">ufunc_cosdg_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;cosdg&quot;)</span>
<span class="s0">ufunc_cosdg_data[0] = &amp;ufunc_cosdg_ptr[2*0]</span>
<span class="s0">ufunc_cosdg_data[1] = &amp;ufunc_cosdg_ptr[2*1]</span>
<span class="s0">cosdg = np.PyUFunc_FromFuncAndData(ufunc_cosdg_loops, ufunc_cosdg_data, ufunc_cosdg_types, 2, 1, 1, 0, &quot;cosdg&quot;, ufunc_cosdg_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_cosm1_loops[2]</span>
<span class="s0">cdef void *ufunc_cosm1_ptr[4]</span>
<span class="s0">cdef void *ufunc_cosm1_data[2]</span>
<span class="s0">cdef char ufunc_cosm1_types[4]</span>
<span class="s0">cdef char *ufunc_cosm1_doc = (</span>
    <span class="s0">&quot;cosm1(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;cos(x) - 1 for use when `x` is near zero.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real valued argument.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of ``cos(x) - 1``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;expm1, log1p\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is more accurate than computing ``cos(x) - 1`` directly for\n&quot;</span>
    <span class="s0">&quot;``x`` around 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 1e-30\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.cos(x) - 1\n&quot;</span>
    <span class="s0">&quot;0.0\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.cosm1(x)\n&quot;</span>
    <span class="s0">&quot;-5.0000000000000005e-61&quot;)</span>
<span class="s0">ufunc_cosm1_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_cosm1_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_cosm1_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_cosm1_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_cosm1_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_cosm1_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_cosm1_ptr[2*0] = &lt;void*&gt;_func_cosm1</span>
<span class="s0">ufunc_cosm1_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;cosm1&quot;)</span>
<span class="s0">ufunc_cosm1_ptr[2*1] = &lt;void*&gt;_func_cosm1</span>
<span class="s0">ufunc_cosm1_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;cosm1&quot;)</span>
<span class="s0">ufunc_cosm1_data[0] = &amp;ufunc_cosm1_ptr[2*0]</span>
<span class="s0">ufunc_cosm1_data[1] = &amp;ufunc_cosm1_ptr[2*1]</span>
<span class="s0">cosm1 = np.PyUFunc_FromFuncAndData(ufunc_cosm1_loops, ufunc_cosm1_data, ufunc_cosm1_types, 2, 1, 1, 0, &quot;cosm1&quot;, ufunc_cosm1_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_cotdg_loops[2]</span>
<span class="s0">cdef void *ufunc_cotdg_ptr[4]</span>
<span class="s0">cdef void *ufunc_cotdg_data[2]</span>
<span class="s0">cdef char ufunc_cotdg_types[4]</span>
<span class="s0">cdef char *ufunc_cotdg_doc = (</span>
    <span class="s0">&quot;cotdg(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Cotangent of the angle `x` given in degrees.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Angle, given in degrees.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Cotangent at the input.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;sindg, cosdg, tandg\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is more accurate than using cotangent directly.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 90 + 180 * np.arange(3)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.cotdg(x)\n&quot;</span>
    <span class="s0">&quot;array([0., 0., 0.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; 1 / np.tan(x * np.pi / 180)\n&quot;</span>
    <span class="s0">&quot;array([6.1232340e-17, 1.8369702e-16, 3.0616170e-16])&quot;)</span>
<span class="s0">ufunc_cotdg_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_cotdg_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_cotdg_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_cotdg_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_cotdg_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_cotdg_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_cotdg_ptr[2*0] = &lt;void*&gt;_func_cotdg</span>
<span class="s0">ufunc_cotdg_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;cotdg&quot;)</span>
<span class="s0">ufunc_cotdg_ptr[2*1] = &lt;void*&gt;_func_cotdg</span>
<span class="s0">ufunc_cotdg_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;cotdg&quot;)</span>
<span class="s0">ufunc_cotdg_data[0] = &amp;ufunc_cotdg_ptr[2*0]</span>
<span class="s0">ufunc_cotdg_data[1] = &amp;ufunc_cotdg_ptr[2*1]</span>
<span class="s0">cotdg = np.PyUFunc_FromFuncAndData(ufunc_cotdg_loops, ufunc_cotdg_data, ufunc_cotdg_types, 2, 1, 1, 0, &quot;cotdg&quot;, ufunc_cotdg_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_dawsn_loops[4]</span>
<span class="s0">cdef void *ufunc_dawsn_ptr[8]</span>
<span class="s0">cdef void *ufunc_dawsn_data[4]</span>
<span class="s0">cdef char ufunc_dawsn_types[8]</span>
<span class="s0">cdef char *ufunc_dawsn_doc = (</span>
    <span class="s0">&quot;dawsn(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Dawson's integral.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    exp(-x**2) * integral(exp(t**2), t=0..x).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Function parameter.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;y : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the integral.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;wofz, erf, erfc, erfcx, erfi\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Steven G. Johnson, Faddeeva W function implementation.\n&quot;</span>
    <span class="s0">&quot;   http://ab-initio.mit.edu/Faddeeva\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy import special\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-15, 15, num=1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.plot(x, special.dawsn(x))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.xlabel('$x$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.ylabel('$dawsn(x)$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_dawsn_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_dawsn_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_dawsn_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_F_F</span>
<span class="s0">ufunc_dawsn_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_D_D</span>
<span class="s0">ufunc_dawsn_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_dawsn_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_dawsn_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_dawsn_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_dawsn_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_dawsn_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_dawsn_types[6] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_dawsn_types[7] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_dawsn_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_dawsn</span>
<span class="s0">ufunc_dawsn_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;dawsn&quot;)</span>
<span class="s0">ufunc_dawsn_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_dawsn</span>
<span class="s0">ufunc_dawsn_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;dawsn&quot;)</span>
<span class="s0">ufunc_dawsn_ptr[2*2] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_dawsn_complex</span>
<span class="s0">ufunc_dawsn_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;dawsn&quot;)</span>
<span class="s0">ufunc_dawsn_ptr[2*3] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_dawsn_complex</span>
<span class="s0">ufunc_dawsn_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;dawsn&quot;)</span>
<span class="s0">ufunc_dawsn_data[0] = &amp;ufunc_dawsn_ptr[2*0]</span>
<span class="s0">ufunc_dawsn_data[1] = &amp;ufunc_dawsn_ptr[2*1]</span>
<span class="s0">ufunc_dawsn_data[2] = &amp;ufunc_dawsn_ptr[2*2]</span>
<span class="s0">ufunc_dawsn_data[3] = &amp;ufunc_dawsn_ptr[2*3]</span>
<span class="s0">dawsn = np.PyUFunc_FromFuncAndData(ufunc_dawsn_loops, ufunc_dawsn_data, ufunc_dawsn_types, 4, 1, 1, 0, &quot;dawsn&quot;, ufunc_dawsn_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_ellipe_loops[2]</span>
<span class="s0">cdef void *ufunc_ellipe_ptr[4]</span>
<span class="s0">cdef void *ufunc_ellipe_data[2]</span>
<span class="s0">cdef char ufunc_ellipe_types[4]</span>
<span class="s0">cdef char *ufunc_ellipe_doc = (</span>
    <span class="s0">&quot;ellipe(m, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Complete elliptic integral of the second kind\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: E(m) = \\int_0^{\\pi/2} [1 - m \\sin(t)^2]^{1/2} dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Defines the parameter of the elliptic integral.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;E : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the elliptic integral.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `ellpe`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For `m &gt; 0` the computation uses the approximation,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: E(m) \\approx P(1-m) - (1-m) \\log(1-m) Q(1-m),\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`P` and :math:`Q` are tenth-order polynomials.  For\n&quot;</span>
    <span class="s0">&quot;`m &lt; 0`, the relation\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: E(m) = E(m/(m - 1)) \\sqrt(1-m)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;is used.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The parameterization in terms of :math:`m` follows that of section\n&quot;</span>
    <span class="s0">&quot;17.2 in [2]_. Other parameterizations in terms of the\n&quot;</span>
    <span class="s0">&quot;complementary parameter :math:`1 - m`, modular angle\n&quot;</span>
    <span class="s0">&quot;:math:`\\sin^2(\\alpha) = m`, or modulus :math:`k^2 = m` are also\n&quot;</span>
    <span class="s0">&quot;used, so be careful that you choose the correct parameter.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The Legendre E integral is related to Carlson's symmetric R_D or R_G\n&quot;</span>
    <span class="s0">&quot;functions in multiple ways [3]_. For example,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: E(m) = 2 R_G(0, 1-k^2, 1) .\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;ellipkm1 : Complete elliptic integral of the first kind, near `m` = 1\n&quot;</span>
    <span class="s0">&quot;ellipk : Complete elliptic integral of the first kind\n&quot;</span>
    <span class="s0">&quot;ellipkinc : Incomplete elliptic integral of the first kind\n&quot;</span>
    <span class="s0">&quot;ellipeinc : Incomplete elliptic integral of the second kind\n&quot;</span>
    <span class="s0">&quot;elliprd : Symmetric elliptic integral of the second kind.\n&quot;</span>
    <span class="s0">&quot;elliprg : Completely-symmetric elliptic integral of the second kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;.. [2] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;       Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;       Graphs, and Mathematical Tables. New York: Dover, 1972.\n&quot;</span>
    <span class="s0">&quot;.. [3] NIST Digital Library of Mathematical\n&quot;</span>
    <span class="s0">&quot;       Functions. http://dlmf.nist.gov/, Release 1.0.28 of\n&quot;</span>
    <span class="s0">&quot;       2020-09-15. See Sec. 19.25(i) https://dlmf.nist.gov/19.25#i\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;This function is used in finding the circumference of an\n&quot;</span>
    <span class="s0">&quot;ellipse with semi-major axis `a` and semi-minor axis `b`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy import special\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a = 3.5\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; b = 2.1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; e_sq = 1.0 - b**2/a**2  # eccentricity squared\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Then the circumference is found using the following:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; C = 4*a*special.ellipe(e_sq)  # circumference formula\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; C\n&quot;</span>
    <span class="s0">&quot;17.868899204378693\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;When `a` and `b` are the same (meaning eccentricity is 0),\n&quot;</span>
    <span class="s0">&quot;this reduces to the circumference of a circle.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; 4*a*special.ellipe(0.0)  # formula for ellipse with a = b\n&quot;</span>
    <span class="s0">&quot;21.991148575128552\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; 2*np.pi*a  # formula for circle of radius a\n&quot;</span>
    <span class="s0">&quot;21.991148575128552&quot;)</span>
<span class="s0">ufunc_ellipe_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_ellipe_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_ellipe_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipe_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipe_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipe_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipe_ptr[2*0] = &lt;void*&gt;_func_ellpe</span>
<span class="s0">ufunc_ellipe_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ellipe&quot;)</span>
<span class="s0">ufunc_ellipe_ptr[2*1] = &lt;void*&gt;_func_ellpe</span>
<span class="s0">ufunc_ellipe_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ellipe&quot;)</span>
<span class="s0">ufunc_ellipe_data[0] = &amp;ufunc_ellipe_ptr[2*0]</span>
<span class="s0">ufunc_ellipe_data[1] = &amp;ufunc_ellipe_ptr[2*1]</span>
<span class="s0">ellipe = np.PyUFunc_FromFuncAndData(ufunc_ellipe_loops, ufunc_ellipe_data, ufunc_ellipe_types, 2, 1, 1, 0, &quot;ellipe&quot;, ufunc_ellipe_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_ellipeinc_loops[2]</span>
<span class="s0">cdef void *ufunc_ellipeinc_ptr[4]</span>
<span class="s0">cdef void *ufunc_ellipeinc_data[2]</span>
<span class="s0">cdef char ufunc_ellipeinc_types[6]</span>
<span class="s0">cdef char *ufunc_ellipeinc_doc = (</span>
    <span class="s0">&quot;ellipeinc(phi, m, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Incomplete elliptic integral of the second kind\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: E(\\phi, m) = \\int_0^{\\phi} [1 - m \\sin(t)^2]^{1/2} dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;phi : array_like\n&quot;</span>
    <span class="s0">&quot;    amplitude of the elliptic integral.\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    parameter of the elliptic integral.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;E : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the elliptic integral.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `ellie`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computation uses arithmetic-geometric means algorithm.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The parameterization in terms of :math:`m` follows that of section\n&quot;</span>
    <span class="s0">&quot;17.2 in [2]_. Other parameterizations in terms of the\n&quot;</span>
    <span class="s0">&quot;complementary parameter :math:`1 - m`, modular angle\n&quot;</span>
    <span class="s0">&quot;:math:`\\sin^2(\\alpha) = m`, or modulus :math:`k^2 = m` are also\n&quot;</span>
    <span class="s0">&quot;used, so be careful that you choose the correct parameter.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The Legendre E incomplete integral can be related to combinations\n&quot;</span>
    <span class="s0">&quot;of Carlson's symmetric integrals R_D, R_F, and R_G in multiple\n&quot;</span>
    <span class="s0">&quot;ways [3]_. For example, with :math:`c = \\csc^2\\phi`,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;  E(\\phi, m) = R_F(c-1, c-k^2, c)\n&quot;</span>
    <span class="s0">&quot;    - \\frac{1}{3} k^2 R_D(c-1, c-k^2, c) .\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;ellipkm1 : Complete elliptic integral of the first kind, near `m` = 1\n&quot;</span>
    <span class="s0">&quot;ellipk : Complete elliptic integral of the first kind\n&quot;</span>
    <span class="s0">&quot;ellipkinc : Incomplete elliptic integral of the first kind\n&quot;</span>
    <span class="s0">&quot;ellipe : Complete elliptic integral of the second kind\n&quot;</span>
    <span class="s0">&quot;elliprd : Symmetric elliptic integral of the second kind.\n&quot;</span>
    <span class="s0">&quot;elliprf : Completely-symmetric elliptic integral of the first kind.\n&quot;</span>
    <span class="s0">&quot;elliprg : Completely-symmetric elliptic integral of the second kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;.. [2] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;       Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;       Graphs, and Mathematical Tables. New York: Dover, 1972.\n&quot;</span>
    <span class="s0">&quot;.. [3] NIST Digital Library of Mathematical\n&quot;</span>
    <span class="s0">&quot;       Functions. http://dlmf.nist.gov/, Release 1.0.28 of\n&quot;</span>
    <span class="s0">&quot;       2020-09-15. See Sec. 19.25(i) https://dlmf.nist.gov/19.25#i&quot;)</span>
<span class="s0">ufunc_ellipeinc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_ellipeinc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_ellipeinc_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipeinc_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipeinc_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipeinc_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipeinc_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipeinc_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipeinc_ptr[2*0] = &lt;void*&gt;_func_ellie</span>
<span class="s0">ufunc_ellipeinc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ellipeinc&quot;)</span>
<span class="s0">ufunc_ellipeinc_ptr[2*1] = &lt;void*&gt;_func_ellie</span>
<span class="s0">ufunc_ellipeinc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ellipeinc&quot;)</span>
<span class="s0">ufunc_ellipeinc_data[0] = &amp;ufunc_ellipeinc_ptr[2*0]</span>
<span class="s0">ufunc_ellipeinc_data[1] = &amp;ufunc_ellipeinc_ptr[2*1]</span>
<span class="s0">ellipeinc = np.PyUFunc_FromFuncAndData(ufunc_ellipeinc_loops, ufunc_ellipeinc_data, ufunc_ellipeinc_types, 2, 2, 1, 0, &quot;ellipeinc&quot;, ufunc_ellipeinc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_ellipj_loops[2]</span>
<span class="s0">cdef void *ufunc_ellipj_ptr[4]</span>
<span class="s0">cdef void *ufunc_ellipj_data[2]</span>
<span class="s0">cdef char ufunc_ellipj_types[12]</span>
<span class="s0">cdef char *ufunc_ellipj_doc = (</span>
    <span class="s0">&quot;ellipj(u, m, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Jacobian elliptic functions\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculates the Jacobian elliptic functions of parameter `m` between\n&quot;</span>
    <span class="s0">&quot;0 and 1, and real argument `u`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Parameter.\n&quot;</span>
    <span class="s0">&quot;u : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument.\n&quot;</span>
    <span class="s0">&quot;out : tuple of ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output arrays for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;sn, cn, dn, ph : 4-tuple of scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The returned functions::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;        sn(u|m), cn(u|m), dn(u|m)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    The value `ph` is such that if `u = ellipkinc(ph, m)`,\n&quot;</span>
    <span class="s0">&quot;    then `sn(u|m) = sin(ph)` and `cn(u|m) = cos(ph)`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `ellpj`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;These functions are periodic, with quarter-period on the real axis\n&quot;</span>
    <span class="s0">&quot;equal to the complete elliptic integral `ellipk(m)`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Relation to incomplete elliptic integral: If `u = ellipkinc(phi,m)`, then\n&quot;</span>
    <span class="s0">&quot;`sn(u|m) = sin(phi)`, and `cn(u|m) = cos(phi)`. The `phi` is called\n&quot;</span>
    <span class="s0">&quot;the amplitude of `u`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computation is by means of the arithmetic-geometric mean algorithm,\n&quot;</span>
    <span class="s0">&quot;except when `m` is within 1e-9 of 0 or 1. In the latter case with `m`\n&quot;</span>
    <span class="s0">&quot;close to 1, the approximation applies only for `phi &lt; pi/2`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;ellipk : Complete elliptic integral of the first kind\n&quot;</span>
    <span class="s0">&quot;ellipkinc : Incomplete elliptic integral of the first kind\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/&quot;)</span>
<span class="s0">ufunc_ellipj_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_dd_dddd_As_ff_ffff</span>
<span class="s0">ufunc_ellipj_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_i_dd_dddd_As_dd_dddd</span>
<span class="s0">ufunc_ellipj_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipj_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipj_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipj_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipj_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipj_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipj_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipj_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipj_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipj_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipj_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipj_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipj_ptr[2*0] = &lt;void*&gt;_func_ellpj</span>
<span class="s0">ufunc_ellipj_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ellipj&quot;)</span>
<span class="s0">ufunc_ellipj_ptr[2*1] = &lt;void*&gt;_func_ellpj</span>
<span class="s0">ufunc_ellipj_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ellipj&quot;)</span>
<span class="s0">ufunc_ellipj_data[0] = &amp;ufunc_ellipj_ptr[2*0]</span>
<span class="s0">ufunc_ellipj_data[1] = &amp;ufunc_ellipj_ptr[2*1]</span>
<span class="s0">ellipj = np.PyUFunc_FromFuncAndData(ufunc_ellipj_loops, ufunc_ellipj_data, ufunc_ellipj_types, 2, 2, 4, 0, &quot;ellipj&quot;, ufunc_ellipj_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_ellipk_loops[2]</span>
<span class="s0">cdef void *ufunc_ellipk_ptr[4]</span>
<span class="s0">cdef void *ufunc_ellipk_data[2]</span>
<span class="s0">cdef char ufunc_ellipk_types[4]</span>
<span class="s0">cdef char *ufunc_ellipk_doc = (</span>
    <span class="s0">&quot;ellipk(m, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Complete elliptic integral of the first kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: K(m) = \\int_0^{\\pi/2} [1 - m \\sin(t)^2]^{-1/2} dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    The parameter of the elliptic integral.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;K : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the elliptic integral.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;For more precision around point m = 1, use `ellipkm1`, which this\n&quot;</span>
    <span class="s0">&quot;function calls.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The parameterization in terms of :math:`m` follows that of section\n&quot;</span>
    <span class="s0">&quot;17.2 in [1]_. Other parameterizations in terms of the\n&quot;</span>
    <span class="s0">&quot;complementary parameter :math:`1 - m`, modular angle\n&quot;</span>
    <span class="s0">&quot;:math:`\\sin^2(\\alpha) = m`, or modulus :math:`k^2 = m` are also\n&quot;</span>
    <span class="s0">&quot;used, so be careful that you choose the correct parameter.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The Legendre K integral is related to Carlson's symmetric R_F\n&quot;</span>
    <span class="s0">&quot;function by [2]_:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: K(m) = R_F(0, 1-k^2, 1) .\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;ellipkm1 : Complete elliptic integral of the first kind around m = 1\n&quot;</span>
    <span class="s0">&quot;ellipkinc : Incomplete elliptic integral of the first kind\n&quot;</span>
    <span class="s0">&quot;ellipe : Complete elliptic integral of the second kind\n&quot;</span>
    <span class="s0">&quot;ellipeinc : Incomplete elliptic integral of the second kind\n&quot;</span>
    <span class="s0">&quot;elliprf : Completely-symmetric elliptic integral of the first kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;       Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;       Graphs, and Mathematical Tables. New York: Dover, 1972.\n&quot;</span>
    <span class="s0">&quot;.. [2] NIST Digital Library of Mathematical\n&quot;</span>
    <span class="s0">&quot;       Functions. http://dlmf.nist.gov/, Release 1.0.28 of\n&quot;</span>
    <span class="s0">&quot;       2020-09-15. See Sec. 19.25(i) https://dlmf.nist.gov/19.25#i&quot;)</span>
<span class="s0">ufunc_ellipk_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_ellipk_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_ellipk_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipk_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipk_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipk_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipk_ptr[2*0] = &lt;void*&gt;_func_ellipk</span>
<span class="s0">ufunc_ellipk_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ellipk&quot;)</span>
<span class="s0">ufunc_ellipk_ptr[2*1] = &lt;void*&gt;_func_ellipk</span>
<span class="s0">ufunc_ellipk_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ellipk&quot;)</span>
<span class="s0">ufunc_ellipk_data[0] = &amp;ufunc_ellipk_ptr[2*0]</span>
<span class="s0">ufunc_ellipk_data[1] = &amp;ufunc_ellipk_ptr[2*1]</span>
<span class="s0">ellipk = np.PyUFunc_FromFuncAndData(ufunc_ellipk_loops, ufunc_ellipk_data, ufunc_ellipk_types, 2, 1, 1, 0, &quot;ellipk&quot;, ufunc_ellipk_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_ellipkinc_loops[2]</span>
<span class="s0">cdef void *ufunc_ellipkinc_ptr[4]</span>
<span class="s0">cdef void *ufunc_ellipkinc_data[2]</span>
<span class="s0">cdef char ufunc_ellipkinc_types[6]</span>
<span class="s0">cdef char *ufunc_ellipkinc_doc = (</span>
    <span class="s0">&quot;ellipkinc(phi, m, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Incomplete elliptic integral of the first kind\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: K(\\phi, m) = \\int_0^{\\phi} [1 - m \\sin(t)^2]^{-1/2} dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is also called :math:`F(\\phi, m)`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;phi : array_like\n&quot;</span>
    <span class="s0">&quot;    amplitude of the elliptic integral\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    parameter of the elliptic integral\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;K : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the elliptic integral\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `ellik`.  The computation is\n&quot;</span>
    <span class="s0">&quot;carried out using the arithmetic-geometric mean algorithm.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The parameterization in terms of :math:`m` follows that of section\n&quot;</span>
    <span class="s0">&quot;17.2 in [2]_. Other parameterizations in terms of the\n&quot;</span>
    <span class="s0">&quot;complementary parameter :math:`1 - m`, modular angle\n&quot;</span>
    <span class="s0">&quot;:math:`\\sin^2(\\alpha) = m`, or modulus :math:`k^2 = m` are also\n&quot;</span>
    <span class="s0">&quot;used, so be careful that you choose the correct parameter.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The Legendre K incomplete integral (or F integral) is related to\n&quot;</span>
    <span class="s0">&quot;Carlson's symmetric R_F function [3]_.\n&quot;</span>
    <span class="s0">&quot;Setting :math:`c = \\csc^2\\phi`,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: F(\\phi, m) = R_F(c-1, c-k^2, c) .\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;ellipkm1 : Complete elliptic integral of the first kind, near `m` = 1\n&quot;</span>
    <span class="s0">&quot;ellipk : Complete elliptic integral of the first kind\n&quot;</span>
    <span class="s0">&quot;ellipe : Complete elliptic integral of the second kind\n&quot;</span>
    <span class="s0">&quot;ellipeinc : Incomplete elliptic integral of the second kind\n&quot;</span>
    <span class="s0">&quot;elliprf : Completely-symmetric elliptic integral of the first kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;.. [2] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;       Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;       Graphs, and Mathematical Tables. New York: Dover, 1972.\n&quot;</span>
    <span class="s0">&quot;.. [3] NIST Digital Library of Mathematical\n&quot;</span>
    <span class="s0">&quot;       Functions. http://dlmf.nist.gov/, Release 1.0.28 of\n&quot;</span>
    <span class="s0">&quot;       2020-09-15. See Sec. 19.25(i) https://dlmf.nist.gov/19.25#i&quot;)</span>
<span class="s0">ufunc_ellipkinc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_ellipkinc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_ellipkinc_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipkinc_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipkinc_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipkinc_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipkinc_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipkinc_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipkinc_ptr[2*0] = &lt;void*&gt;_func_ellik</span>
<span class="s0">ufunc_ellipkinc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ellipkinc&quot;)</span>
<span class="s0">ufunc_ellipkinc_ptr[2*1] = &lt;void*&gt;_func_ellik</span>
<span class="s0">ufunc_ellipkinc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ellipkinc&quot;)</span>
<span class="s0">ufunc_ellipkinc_data[0] = &amp;ufunc_ellipkinc_ptr[2*0]</span>
<span class="s0">ufunc_ellipkinc_data[1] = &amp;ufunc_ellipkinc_ptr[2*1]</span>
<span class="s0">ellipkinc = np.PyUFunc_FromFuncAndData(ufunc_ellipkinc_loops, ufunc_ellipkinc_data, ufunc_ellipkinc_types, 2, 2, 1, 0, &quot;ellipkinc&quot;, ufunc_ellipkinc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_ellipkm1_loops[2]</span>
<span class="s0">cdef void *ufunc_ellipkm1_ptr[4]</span>
<span class="s0">cdef void *ufunc_ellipkm1_data[2]</span>
<span class="s0">cdef char ufunc_ellipkm1_types[4]</span>
<span class="s0">cdef char *ufunc_ellipkm1_doc = (</span>
    <span class="s0">&quot;ellipkm1(p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Complete elliptic integral of the first kind around `m` = 1\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: K(p) = \\int_0^{\\pi/2} [1 - m \\sin(t)^2]^{-1/2} dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where `m = 1 - p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Defines the parameter of the elliptic integral as `m = 1 - p`.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;K : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the elliptic integral.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `ellpk`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For `p &lt;= 1`, computation uses the approximation,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: K(p) \\approx P(p) - \\log(p) Q(p),\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`P` and :math:`Q` are tenth-order polynomials.  The\n&quot;</span>
    <span class="s0">&quot;argument `p` is used internally rather than `m` so that the logarithmic\n&quot;</span>
    <span class="s0">&quot;singularity at `m = 1` will be shifted to the origin; this preserves\n&quot;</span>
    <span class="s0">&quot;maximum accuracy.  For `p &gt; 1`, the identity\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: K(p) = K(1/p)/\\sqrt(p)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;is used.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;ellipk : Complete elliptic integral of the first kind\n&quot;</span>
    <span class="s0">&quot;ellipkinc : Incomplete elliptic integral of the first kind\n&quot;</span>
    <span class="s0">&quot;ellipe : Complete elliptic integral of the second kind\n&quot;</span>
    <span class="s0">&quot;ellipeinc : Incomplete elliptic integral of the second kind\n&quot;</span>
    <span class="s0">&quot;elliprf : Completely-symmetric elliptic integral of the first kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/&quot;)</span>
<span class="s0">ufunc_ellipkm1_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_ellipkm1_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_ellipkm1_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipkm1_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ellipkm1_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipkm1_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ellipkm1_ptr[2*0] = &lt;void*&gt;_func_ellpk</span>
<span class="s0">ufunc_ellipkm1_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ellipkm1&quot;)</span>
<span class="s0">ufunc_ellipkm1_ptr[2*1] = &lt;void*&gt;_func_ellpk</span>
<span class="s0">ufunc_ellipkm1_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ellipkm1&quot;)</span>
<span class="s0">ufunc_ellipkm1_data[0] = &amp;ufunc_ellipkm1_ptr[2*0]</span>
<span class="s0">ufunc_ellipkm1_data[1] = &amp;ufunc_ellipkm1_ptr[2*1]</span>
<span class="s0">ellipkm1 = np.PyUFunc_FromFuncAndData(ufunc_ellipkm1_loops, ufunc_ellipkm1_data, ufunc_ellipkm1_types, 2, 1, 1, 0, &quot;ellipkm1&quot;, ufunc_ellipkm1_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_elliprc_loops[4]</span>
<span class="s0">cdef void *ufunc_elliprc_ptr[8]</span>
<span class="s0">cdef void *ufunc_elliprc_data[4]</span>
<span class="s0">cdef char ufunc_elliprc_types[12]</span>
<span class="s0">cdef char *ufunc_elliprc_doc = (</span>
    <span class="s0">&quot;elliprc(x, y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Degenerate symmetric elliptic integral.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function RC is defined as [1]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    R_{\\mathrm{C}}(x, y) =\n&quot;</span>
    <span class="s0">&quot;       \\frac{1}{2} \\int_0^{+\\infty} (t + x)^{-1/2} (t + y)^{-1} dt\n&quot;</span>
    <span class="s0">&quot;       = R_{\\mathrm{F}}(x, y, y)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x, y : array_like\n&quot;</span>
    <span class="s0">&quot;    Real or complex input parameters. `x` can be any number in the\n&quot;</span>
    <span class="s0">&quot;    complex plane cut along the negative real axis. `y` must be non-zero.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;R : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the integral. If `y` is real and negative, the Cauchy\n&quot;</span>
    <span class="s0">&quot;    principal value is returned. If both of `x` and `y` are real, the\n&quot;</span>
    <span class="s0">&quot;    return value is real. Otherwise, the return value is complex.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;RC is a degenerate case of the symmetric integral RF: ``elliprc(x, y) ==\n&quot;</span>
    <span class="s0">&quot;elliprf(x, y, y)``. It is an elementary function rather than an elliptic\n&quot;</span>
    <span class="s0">&quot;integral.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The code implements Carlson's algorithm based on the duplication theorems\n&quot;</span>
    <span class="s0">&quot;and series expansion up to the 7th order. [2]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 1.8.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;elliprf : Completely-symmetric elliptic integral of the first kind.\n&quot;</span>
    <span class="s0">&quot;elliprd : Symmetric elliptic integral of the second kind.\n&quot;</span>
    <span class="s0">&quot;elliprg : Completely-symmetric elliptic integral of the second kind.\n&quot;</span>
    <span class="s0">&quot;elliprj : Symmetric elliptic integral of the third kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] B. C. Carlson, ed., Chapter 19 in \&quot;Digital Library of Mathematical\n&quot;</span>
    <span class="s0">&quot;       Functions,\&quot; NIST, US Dept. of Commerce.\n&quot;</span>
    <span class="s0">&quot;       https://dlmf.nist.gov/19.16.E6\n&quot;</span>
    <span class="s0">&quot;.. [2] B. C. Carlson, \&quot;Numerical computation of real or complex elliptic\n&quot;</span>
    <span class="s0">&quot;       integrals,\&quot; Numer. Algorithm, vol. 10, no. 1, pp. 13-26, 1995.\n&quot;</span>
    <span class="s0">&quot;       https://arxiv.org/abs/math/9409227\n&quot;</span>
    <span class="s0">&quot;       https://doi.org/10.1007/BF02198293\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Basic homogeneity property:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import elliprc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 1.2 + 3.4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = 5.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; scale = 0.3 + 0.4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprc(scale*x, scale*y)\n&quot;</span>
    <span class="s0">&quot;(0.5484493976710874-0.4169557678995833j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprc(x, y)/np.sqrt(scale)\n&quot;</span>
    <span class="s0">&quot;(0.5484493976710874-0.41695576789958333j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;When the two arguments coincide, the integral is particularly\n&quot;</span>
    <span class="s0">&quot;simple:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 1.2 + 3.4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprc(x, x)\n&quot;</span>
    <span class="s0">&quot;(0.4299173120614631-0.3041729818745595j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; 1/np.sqrt(x)\n&quot;</span>
    <span class="s0">&quot;(0.4299173120614631-0.30417298187455954j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Another simple case: the first argument vanishes:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = 1.2 + 3.4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprc(0, y)\n&quot;</span>
    <span class="s0">&quot;(0.6753125346116815-0.47779380263880866j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.pi/2/np.sqrt(y)\n&quot;</span>
    <span class="s0">&quot;(0.6753125346116815-0.4777938026388088j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;When `x` and `y` are both positive, we can express\n&quot;</span>
    <span class="s0">&quot;:math:`R_C(x,y)` in terms of more elementary functions.  For the\n&quot;</span>
    <span class="s0">&quot;case :math:`0 \\le x &lt; y`,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 3.2\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = 6.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprc(x, y)\n&quot;</span>
    <span class="s0">&quot;0.44942991498453444\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.arctan(np.sqrt((y-x)/x))/np.sqrt(y-x)\n&quot;</span>
    <span class="s0">&quot;0.44942991498453433\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;And for the case :math:`0 \\le y &lt; x`,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 6.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = 3.2\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprc(x,y)\n&quot;</span>
    <span class="s0">&quot;0.4989837501576147\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.log((np.sqrt(x)+np.sqrt(x-y))/np.sqrt(y))/np.sqrt(x-y)\n&quot;</span>
    <span class="s0">&quot;0.49898375015761476&quot;)</span>
<span class="s0">ufunc_elliprc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_elliprc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_elliprc_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_DD__As_FF_F</span>
<span class="s0">ufunc_elliprc_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_DD__As_DD_D</span>
<span class="s0">ufunc_elliprc_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprc_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprc_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprc_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprc_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprc_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprc_types[6] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprc_types[7] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprc_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprc_types[9] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprc_types[10] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprc_types[11] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprc_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_fellint_RC</span>
<span class="s0">ufunc_elliprc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprc&quot;)</span>
<span class="s0">ufunc_elliprc_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_fellint_RC</span>
<span class="s0">ufunc_elliprc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprc&quot;)</span>
<span class="s0">ufunc_elliprc_ptr[2*2] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_cellint_RC</span>
<span class="s0">ufunc_elliprc_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprc&quot;)</span>
<span class="s0">ufunc_elliprc_ptr[2*3] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_cellint_RC</span>
<span class="s0">ufunc_elliprc_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprc&quot;)</span>
<span class="s0">ufunc_elliprc_data[0] = &amp;ufunc_elliprc_ptr[2*0]</span>
<span class="s0">ufunc_elliprc_data[1] = &amp;ufunc_elliprc_ptr[2*1]</span>
<span class="s0">ufunc_elliprc_data[2] = &amp;ufunc_elliprc_ptr[2*2]</span>
<span class="s0">ufunc_elliprc_data[3] = &amp;ufunc_elliprc_ptr[2*3]</span>
<span class="s0">elliprc = np.PyUFunc_FromFuncAndData(ufunc_elliprc_loops, ufunc_elliprc_data, ufunc_elliprc_types, 4, 2, 1, 0, &quot;elliprc&quot;, ufunc_elliprc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_elliprd_loops[4]</span>
<span class="s0">cdef void *ufunc_elliprd_ptr[8]</span>
<span class="s0">cdef void *ufunc_elliprd_data[4]</span>
<span class="s0">cdef char ufunc_elliprd_types[16]</span>
<span class="s0">cdef char *ufunc_elliprd_doc = (</span>
    <span class="s0">&quot;elliprd(x, y, z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Symmetric elliptic integral of the second kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function RD is defined as [1]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    R_{\\mathrm{D}}(x, y, z) =\n&quot;</span>
    <span class="s0">&quot;       \\frac{3}{2} \\int_0^{+\\infty} [(t + x) (t + y)]^{-1/2} (t + z)^{-3/2}\n&quot;</span>
    <span class="s0">&quot;       dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x, y, z : array_like\n&quot;</span>
    <span class="s0">&quot;    Real or complex input parameters. `x` or `y` can be any number in the\n&quot;</span>
    <span class="s0">&quot;    complex plane cut along the negative real axis, but at most one of them\n&quot;</span>
    <span class="s0">&quot;    can be zero, while `z` must be non-zero.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;R : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the integral. If all of `x`, `y`, and `z` are real, the\n&quot;</span>
    <span class="s0">&quot;    return value is real. Otherwise, the return value is complex.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;RD is a degenerate case of the elliptic integral RJ: ``elliprd(x, y, z) ==\n&quot;</span>
    <span class="s0">&quot;elliprj(x, y, z, z)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The code implements Carlson's algorithm based on the duplication theorems\n&quot;</span>
    <span class="s0">&quot;and series expansion up to the 7th order. [2]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 1.8.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;elliprc : Degenerate symmetric elliptic integral.\n&quot;</span>
    <span class="s0">&quot;elliprf : Completely-symmetric elliptic integral of the first kind.\n&quot;</span>
    <span class="s0">&quot;elliprg : Completely-symmetric elliptic integral of the second kind.\n&quot;</span>
    <span class="s0">&quot;elliprj : Symmetric elliptic integral of the third kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] B. C. Carlson, ed., Chapter 19 in \&quot;Digital Library of Mathematical\n&quot;</span>
    <span class="s0">&quot;       Functions,\&quot; NIST, US Dept. of Commerce.\n&quot;</span>
    <span class="s0">&quot;       https://dlmf.nist.gov/19.16.E5\n&quot;</span>
    <span class="s0">&quot;.. [2] B. C. Carlson, \&quot;Numerical computation of real or complex elliptic\n&quot;</span>
    <span class="s0">&quot;       integrals,\&quot; Numer. Algorithm, vol. 10, no. 1, pp. 13-26, 1995.\n&quot;</span>
    <span class="s0">&quot;       https://arxiv.org/abs/math/9409227\n&quot;</span>
    <span class="s0">&quot;       https://doi.org/10.1007/BF02198293\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Basic homogeneity property:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import elliprd\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 1.2 + 3.4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = 5.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z = 6.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; scale = 0.3 + 0.4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprd(scale*x, scale*y, scale*z)\n&quot;</span>
    <span class="s0">&quot;(-0.03703043835680379-0.24500934665683802j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprd(x, y, z)*np.power(scale, -1.5)\n&quot;</span>
    <span class="s0">&quot;(-0.0370304383568038-0.24500934665683805j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;All three arguments coincide:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 1.2 + 3.4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprd(x, x, x)\n&quot;</span>
    <span class="s0">&quot;(-0.03986825876151896-0.14051741840449586j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.power(x, -1.5)\n&quot;</span>
    <span class="s0">&quot;(-0.03986825876151894-0.14051741840449583j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The so-called \&quot;second lemniscate constant\&quot;:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprd(0, 2, 1)/3\n&quot;</span>
    <span class="s0">&quot;0.5990701173677961\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import gamma\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gamma(0.75)**2/np.sqrt(2*np.pi)\n&quot;</span>
    <span class="s0">&quot;0.5990701173677959&quot;)</span>
<span class="s0">ufunc_elliprd_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_elliprd_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_elliprd_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_DDD__As_FFF_F</span>
<span class="s0">ufunc_elliprd_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_DDD__As_DDD_D</span>
<span class="s0">ufunc_elliprd_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprd_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprd_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprd_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprd_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprd_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprd_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprd_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprd_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprd_types[9] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprd_types[10] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprd_types[11] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprd_types[12] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprd_types[13] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprd_types[14] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprd_types[15] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprd_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_fellint_RD</span>
<span class="s0">ufunc_elliprd_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprd&quot;)</span>
<span class="s0">ufunc_elliprd_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_fellint_RD</span>
<span class="s0">ufunc_elliprd_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprd&quot;)</span>
<span class="s0">ufunc_elliprd_ptr[2*2] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_cellint_RD</span>
<span class="s0">ufunc_elliprd_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprd&quot;)</span>
<span class="s0">ufunc_elliprd_ptr[2*3] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_cellint_RD</span>
<span class="s0">ufunc_elliprd_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprd&quot;)</span>
<span class="s0">ufunc_elliprd_data[0] = &amp;ufunc_elliprd_ptr[2*0]</span>
<span class="s0">ufunc_elliprd_data[1] = &amp;ufunc_elliprd_ptr[2*1]</span>
<span class="s0">ufunc_elliprd_data[2] = &amp;ufunc_elliprd_ptr[2*2]</span>
<span class="s0">ufunc_elliprd_data[3] = &amp;ufunc_elliprd_ptr[2*3]</span>
<span class="s0">elliprd = np.PyUFunc_FromFuncAndData(ufunc_elliprd_loops, ufunc_elliprd_data, ufunc_elliprd_types, 4, 3, 1, 0, &quot;elliprd&quot;, ufunc_elliprd_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_elliprf_loops[4]</span>
<span class="s0">cdef void *ufunc_elliprf_ptr[8]</span>
<span class="s0">cdef void *ufunc_elliprf_data[4]</span>
<span class="s0">cdef char ufunc_elliprf_types[16]</span>
<span class="s0">cdef char *ufunc_elliprf_doc = (</span>
    <span class="s0">&quot;elliprf(x, y, z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Completely-symmetric elliptic integral of the first kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function RF is defined as [1]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    R_{\\mathrm{F}}(x, y, z) =\n&quot;</span>
    <span class="s0">&quot;       \\frac{1}{2} \\int_0^{+\\infty} [(t + x) (t + y) (t + z)]^{-1/2} dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x, y, z : array_like\n&quot;</span>
    <span class="s0">&quot;    Real or complex input parameters. `x`, `y`, or `z` can be any number in\n&quot;</span>
    <span class="s0">&quot;    the complex plane cut along the negative real axis, but at most one of\n&quot;</span>
    <span class="s0">&quot;    them can be zero.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;R : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the integral. If all of `x`, `y`, and `z` are real, the return\n&quot;</span>
    <span class="s0">&quot;    value is real. Otherwise, the return value is complex.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The code implements Carlson's algorithm based on the duplication theorems\n&quot;</span>
    <span class="s0">&quot;and series expansion up to the 7th order (cf.:\n&quot;</span>
    <span class="s0">&quot;https://dlmf.nist.gov/19.36.i) and the AGM algorithm for the complete\n&quot;</span>
    <span class="s0">&quot;integral. [2]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 1.8.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;elliprc : Degenerate symmetric integral.\n&quot;</span>
    <span class="s0">&quot;elliprd : Symmetric elliptic integral of the second kind.\n&quot;</span>
    <span class="s0">&quot;elliprg : Completely-symmetric elliptic integral of the second kind.\n&quot;</span>
    <span class="s0">&quot;elliprj : Symmetric elliptic integral of the third kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] B. C. Carlson, ed., Chapter 19 in \&quot;Digital Library of Mathematical\n&quot;</span>
    <span class="s0">&quot;       Functions,\&quot; NIST, US Dept. of Commerce.\n&quot;</span>
    <span class="s0">&quot;       https://dlmf.nist.gov/19.16.E1\n&quot;</span>
    <span class="s0">&quot;.. [2] B. C. Carlson, \&quot;Numerical computation of real or complex elliptic\n&quot;</span>
    <span class="s0">&quot;       integrals,\&quot; Numer. Algorithm, vol. 10, no. 1, pp. 13-26, 1995.\n&quot;</span>
    <span class="s0">&quot;       https://arxiv.org/abs/math/9409227\n&quot;</span>
    <span class="s0">&quot;       https://doi.org/10.1007/BF02198293\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Basic homogeneity property:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import elliprf\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 1.2 + 3.4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = 5.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z = 6.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; scale = 0.3 + 0.4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprf(scale*x, scale*y, scale*z)\n&quot;</span>
    <span class="s0">&quot;(0.5328051227278146-0.4008623567957094j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprf(x, y, z)/np.sqrt(scale)\n&quot;</span>
    <span class="s0">&quot;(0.5328051227278147-0.4008623567957095j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;All three arguments coincide:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 1.2 + 3.4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprf(x, x, x)\n&quot;</span>
    <span class="s0">&quot;(0.42991731206146316-0.30417298187455954j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; 1/np.sqrt(x)\n&quot;</span>
    <span class="s0">&quot;(0.4299173120614631-0.30417298187455954j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The so-called \&quot;first lemniscate constant\&quot;:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprf(0, 1, 2)\n&quot;</span>
    <span class="s0">&quot;1.3110287771460598\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import gamma\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gamma(0.25)**2/(4*np.sqrt(2*np.pi))\n&quot;</span>
    <span class="s0">&quot;1.3110287771460598&quot;)</span>
<span class="s0">ufunc_elliprf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_elliprf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_elliprf_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_DDD__As_FFF_F</span>
<span class="s0">ufunc_elliprf_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_DDD__As_DDD_D</span>
<span class="s0">ufunc_elliprf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprf_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprf_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprf_types[9] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprf_types[10] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprf_types[11] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprf_types[12] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprf_types[13] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprf_types[14] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprf_types[15] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprf_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_fellint_RF</span>
<span class="s0">ufunc_elliprf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprf&quot;)</span>
<span class="s0">ufunc_elliprf_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_fellint_RF</span>
<span class="s0">ufunc_elliprf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprf&quot;)</span>
<span class="s0">ufunc_elliprf_ptr[2*2] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_cellint_RF</span>
<span class="s0">ufunc_elliprf_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprf&quot;)</span>
<span class="s0">ufunc_elliprf_ptr[2*3] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_cellint_RF</span>
<span class="s0">ufunc_elliprf_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprf&quot;)</span>
<span class="s0">ufunc_elliprf_data[0] = &amp;ufunc_elliprf_ptr[2*0]</span>
<span class="s0">ufunc_elliprf_data[1] = &amp;ufunc_elliprf_ptr[2*1]</span>
<span class="s0">ufunc_elliprf_data[2] = &amp;ufunc_elliprf_ptr[2*2]</span>
<span class="s0">ufunc_elliprf_data[3] = &amp;ufunc_elliprf_ptr[2*3]</span>
<span class="s0">elliprf = np.PyUFunc_FromFuncAndData(ufunc_elliprf_loops, ufunc_elliprf_data, ufunc_elliprf_types, 4, 3, 1, 0, &quot;elliprf&quot;, ufunc_elliprf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_elliprg_loops[4]</span>
<span class="s0">cdef void *ufunc_elliprg_ptr[8]</span>
<span class="s0">cdef void *ufunc_elliprg_data[4]</span>
<span class="s0">cdef char ufunc_elliprg_types[16]</span>
<span class="s0">cdef char *ufunc_elliprg_doc = (</span>
    <span class="s0">&quot;elliprg(x, y, z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Completely-symmetric elliptic integral of the second kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function RG is defined as [1]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    R_{\\mathrm{G}}(x, y, z) =\n&quot;</span>
    <span class="s0">&quot;       \\frac{1}{4} \\int_0^{+\\infty} [(t + x) (t + y) (t + z)]^{-1/2}\n&quot;</span>
    <span class="s0">&quot;       \\left(\\frac{x}{t + x} + \\frac{y}{t + y} + \\frac{z}{t + z}\\right) t\n&quot;</span>
    <span class="s0">&quot;       dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x, y, z : array_like\n&quot;</span>
    <span class="s0">&quot;    Real or complex input parameters. `x`, `y`, or `z` can be any number in\n&quot;</span>
    <span class="s0">&quot;    the complex plane cut along the negative real axis.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;R : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the integral. If all of `x`, `y`, and `z` are real, the return\n&quot;</span>
    <span class="s0">&quot;    value is real. Otherwise, the return value is complex.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The implementation uses the relation [1]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    2 R_{\\mathrm{G}}(x, y, z) =\n&quot;</span>
    <span class="s0">&quot;       z R_{\\mathrm{F}}(x, y, z) -\n&quot;</span>
    <span class="s0">&quot;       \\frac{1}{3} (x - z) (y - z) R_{\\mathrm{D}}(x, y, z) +\n&quot;</span>
    <span class="s0">&quot;       \\sqrt{\\frac{x y}{z}}\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;and the symmetry of `x`, `y`, `z` when at least one non-zero parameter can\n&quot;</span>
    <span class="s0">&quot;be chosen as the pivot. When one of the arguments is close to zero, the AGM\n&quot;</span>
    <span class="s0">&quot;method is applied instead. Other special cases are computed following Ref.\n&quot;</span>
    <span class="s0">&quot;[2]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 1.8.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;elliprc : Degenerate symmetric integral.\n&quot;</span>
    <span class="s0">&quot;elliprd : Symmetric elliptic integral of the second kind.\n&quot;</span>
    <span class="s0">&quot;elliprf : Completely-symmetric elliptic integral of the first kind.\n&quot;</span>
    <span class="s0">&quot;elliprj : Symmetric elliptic integral of the third kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] B. C. Carlson, \&quot;Numerical computation of real or complex elliptic\n&quot;</span>
    <span class="s0">&quot;       integrals,\&quot; Numer. Algorithm, vol. 10, no. 1, pp. 13-26, 1995.\n&quot;</span>
    <span class="s0">&quot;       https://arxiv.org/abs/math/9409227\n&quot;</span>
    <span class="s0">&quot;       https://doi.org/10.1007/BF02198293\n&quot;</span>
    <span class="s0">&quot;.. [2] B. C. Carlson, ed., Chapter 19 in \&quot;Digital Library of Mathematical\n&quot;</span>
    <span class="s0">&quot;       Functions,\&quot; NIST, US Dept. of Commerce.\n&quot;</span>
    <span class="s0">&quot;       https://dlmf.nist.gov/19.16.E1\n&quot;</span>
    <span class="s0">&quot;       https://dlmf.nist.gov/19.20.ii\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Basic homogeneity property:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import elliprg\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 1.2 + 3.4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = 5.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z = 6.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; scale = 0.3 + 0.4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprg(scale*x, scale*y, scale*z)\n&quot;</span>
    <span class="s0">&quot;(1.195936862005246+0.8470988320464167j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprg(x, y, z)*np.sqrt(scale)\n&quot;</span>
    <span class="s0">&quot;(1.195936862005246+0.8470988320464165j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Simplifications:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprg(0, y, y)\n&quot;</span>
    <span class="s0">&quot;1.756203682760182\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; 0.25*np.pi*np.sqrt(y)\n&quot;</span>
    <span class="s0">&quot;1.7562036827601817\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprg(0, 0, z)\n&quot;</span>
    <span class="s0">&quot;1.224744871391589\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; 0.5*np.sqrt(z)\n&quot;</span>
    <span class="s0">&quot;1.224744871391589\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The surface area of a triaxial ellipsoid with semiaxes ``a``, ``b``, and\n&quot;</span>
    <span class="s0">&quot;``c`` is given by\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    S = 4 \\pi a b c R_{\\mathrm{G}}(1 / a^2, 1 / b^2, 1 / c^2).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; def ellipsoid_area(a, b, c):\n&quot;</span>
    <span class="s0">&quot;...     r = 4.0 * np.pi * a * b * c\n&quot;</span>
    <span class="s0">&quot;...     return r * elliprg(1.0 / (a * a), 1.0 / (b * b), 1.0 / (c * c))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; print(ellipsoid_area(1, 3, 5))\n&quot;</span>
    <span class="s0">&quot;108.62688289491807&quot;)</span>
<span class="s0">ufunc_elliprg_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_elliprg_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_elliprg_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_DDD__As_FFF_F</span>
<span class="s0">ufunc_elliprg_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_DDD__As_DDD_D</span>
<span class="s0">ufunc_elliprg_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprg_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprg_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprg_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprg_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprg_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprg_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprg_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprg_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprg_types[9] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprg_types[10] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprg_types[11] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprg_types[12] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprg_types[13] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprg_types[14] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprg_types[15] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprg_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_fellint_RG</span>
<span class="s0">ufunc_elliprg_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprg&quot;)</span>
<span class="s0">ufunc_elliprg_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_fellint_RG</span>
<span class="s0">ufunc_elliprg_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprg&quot;)</span>
<span class="s0">ufunc_elliprg_ptr[2*2] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_cellint_RG</span>
<span class="s0">ufunc_elliprg_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprg&quot;)</span>
<span class="s0">ufunc_elliprg_ptr[2*3] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_cellint_RG</span>
<span class="s0">ufunc_elliprg_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprg&quot;)</span>
<span class="s0">ufunc_elliprg_data[0] = &amp;ufunc_elliprg_ptr[2*0]</span>
<span class="s0">ufunc_elliprg_data[1] = &amp;ufunc_elliprg_ptr[2*1]</span>
<span class="s0">ufunc_elliprg_data[2] = &amp;ufunc_elliprg_ptr[2*2]</span>
<span class="s0">ufunc_elliprg_data[3] = &amp;ufunc_elliprg_ptr[2*3]</span>
<span class="s0">elliprg = np.PyUFunc_FromFuncAndData(ufunc_elliprg_loops, ufunc_elliprg_data, ufunc_elliprg_types, 4, 3, 1, 0, &quot;elliprg&quot;, ufunc_elliprg_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_elliprj_loops[4]</span>
<span class="s0">cdef void *ufunc_elliprj_ptr[8]</span>
<span class="s0">cdef void *ufunc_elliprj_data[4]</span>
<span class="s0">cdef char ufunc_elliprj_types[20]</span>
<span class="s0">cdef char *ufunc_elliprj_doc = (</span>
    <span class="s0">&quot;elliprj(x, y, z, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Symmetric elliptic integral of the third kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function RJ is defined as [1]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    R_{\\mathrm{J}}(x, y, z, p) =\n&quot;</span>
    <span class="s0">&quot;       \\frac{3}{2} \\int_0^{+\\infty} [(t + x) (t + y) (t + z)]^{-1/2}\n&quot;</span>
    <span class="s0">&quot;       (t + p)^{-1} dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. warning::\n&quot;</span>
    <span class="s0">&quot;    This function should be considered experimental when the inputs are\n&quot;</span>
    <span class="s0">&quot;    unbalanced.  Check correctness with another independent implementation.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x, y, z, p : array_like\n&quot;</span>
    <span class="s0">&quot;    Real or complex input parameters. `x`, `y`, or `z` are numbers in\n&quot;</span>
    <span class="s0">&quot;    the complex plane cut along the negative real axis (subject to further\n&quot;</span>
    <span class="s0">&quot;    constraints, see Notes), and at most one of them can be zero. `p` must\n&quot;</span>
    <span class="s0">&quot;    be non-zero.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;R : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the integral. If all of `x`, `y`, `z`, and `p` are real, the\n&quot;</span>
    <span class="s0">&quot;    return value is real. Otherwise, the return value is complex.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    If `p` is real and negative, while `x`, `y`, and `z` are real,\n&quot;</span>
    <span class="s0">&quot;    non-negative, and at most one of them is zero, the Cauchy principal\n&quot;</span>
    <span class="s0">&quot;    value is returned. [1]_ [2]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The code implements Carlson's algorithm based on the duplication theorems\n&quot;</span>
    <span class="s0">&quot;and series expansion up to the 7th order. [3]_ The algorithm is slightly\n&quot;</span>
    <span class="s0">&quot;different from its earlier incarnation as it appears in [1]_, in that the\n&quot;</span>
    <span class="s0">&quot;call to `elliprc` (or ``atan``/``atanh``, see [4]_) is no longer needed in\n&quot;</span>
    <span class="s0">&quot;the inner loop. Asymptotic approximations are used where arguments differ\n&quot;</span>
    <span class="s0">&quot;widely in the order of magnitude. [5]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The input values are subject to certain sufficient but not necessary\n&quot;</span>
    <span class="s0">&quot;constaints when input arguments are complex. Notably, ``x``, ``y``, and\n&quot;</span>
    <span class="s0">&quot;``z`` must have non-negative real parts, unless two of them are\n&quot;</span>
    <span class="s0">&quot;non-negative and complex-conjugates to each other while the other is a real\n&quot;</span>
    <span class="s0">&quot;non-negative number. [1]_ If the inputs do not satisfy the sufficient\n&quot;</span>
    <span class="s0">&quot;condition described in Ref. [1]_ they are rejected outright with the output\n&quot;</span>
    <span class="s0">&quot;set to NaN.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;In the case where one of ``x``, ``y``, and ``z`` is equal to ``p``, the\n&quot;</span>
    <span class="s0">&quot;function ``elliprd`` should be preferred because of its less restrictive\n&quot;</span>
    <span class="s0">&quot;domain.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 1.8.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;elliprc : Degenerate symmetric integral.\n&quot;</span>
    <span class="s0">&quot;elliprd : Symmetric elliptic integral of the second kind.\n&quot;</span>
    <span class="s0">&quot;elliprf : Completely-symmetric elliptic integral of the first kind.\n&quot;</span>
    <span class="s0">&quot;elliprg : Completely-symmetric elliptic integral of the second kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] B. C. Carlson, \&quot;Numerical computation of real or complex elliptic\n&quot;</span>
    <span class="s0">&quot;       integrals,\&quot; Numer. Algorithm, vol. 10, no. 1, pp. 13-26, 1995.\n&quot;</span>
    <span class="s0">&quot;       https://arxiv.org/abs/math/9409227\n&quot;</span>
    <span class="s0">&quot;       https://doi.org/10.1007/BF02198293\n&quot;</span>
    <span class="s0">&quot;.. [2] B. C. Carlson, ed., Chapter 19 in \&quot;Digital Library of Mathematical\n&quot;</span>
    <span class="s0">&quot;       Functions,\&quot; NIST, US Dept. of Commerce.\n&quot;</span>
    <span class="s0">&quot;       https://dlmf.nist.gov/19.20.iii\n&quot;</span>
    <span class="s0">&quot;.. [3] B. C. Carlson, J. FitzSimmons, \&quot;Reduction Theorems for Elliptic\n&quot;</span>
    <span class="s0">&quot;       Integrands with the Square Root of Two Quadratic Factors,\&quot; J.\n&quot;</span>
    <span class="s0">&quot;       Comput. Appl. Math., vol. 118, nos. 1-2, pp. 71-85, 2000.\n&quot;</span>
    <span class="s0">&quot;       https://doi.org/10.1016/S0377-0427(00)00282-X\n&quot;</span>
    <span class="s0">&quot;.. [4] F. Johansson, \&quot;Numerical Evaluation of Elliptic Functions, Elliptic\n&quot;</span>
    <span class="s0">&quot;       Integrals and Modular Forms,\&quot; in J. Blumlein, C. Schneider, P.\n&quot;</span>
    <span class="s0">&quot;       Paule, eds., \&quot;Elliptic Integrals, Elliptic Functions and Modular\n&quot;</span>
    <span class="s0">&quot;       Forms in Quantum Field Theory,\&quot; pp. 269-293, 2019 (Cham,\n&quot;</span>
    <span class="s0">&quot;       Switzerland: Springer Nature Switzerland)\n&quot;</span>
    <span class="s0">&quot;       https://arxiv.org/abs/1806.06725\n&quot;</span>
    <span class="s0">&quot;       https://doi.org/10.1007/978-3-030-04480-0\n&quot;</span>
    <span class="s0">&quot;.. [5] B. C. Carlson, J. L. Gustafson, \&quot;Asymptotic Approximations for\n&quot;</span>
    <span class="s0">&quot;       Symmetric Elliptic Integrals,\&quot; SIAM J. Math. Anls., vol. 25, no. 2,\n&quot;</span>
    <span class="s0">&quot;       pp. 288-303, 1994.\n&quot;</span>
    <span class="s0">&quot;       https://arxiv.org/abs/math/9310223\n&quot;</span>
    <span class="s0">&quot;       https://doi.org/10.1137/S0036141092228477\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Basic homogeneity property:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import elliprj\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 1.2 + 3.4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = 5.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z = 6.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p = 7.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; scale = 0.3 - 0.4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprj(scale*x, scale*y, scale*z, scale*p)\n&quot;</span>
    <span class="s0">&quot;(0.10834905565679157+0.19694950747103812j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprj(x, y, z, p)*np.power(scale, -1.5)\n&quot;</span>
    <span class="s0">&quot;(0.10834905565679556+0.19694950747103854j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Reduction to simpler elliptic integral:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprj(x, y, z, z)\n&quot;</span>
    <span class="s0">&quot;(0.08288462362195129-0.028376809745123258j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import elliprd\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprd(x, y, z)\n&quot;</span>
    <span class="s0">&quot;(0.08288462362195136-0.028376809745123296j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;All arguments coincide:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; elliprj(x, x, x, x)\n&quot;</span>
    <span class="s0">&quot;(-0.03986825876151896-0.14051741840449586j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.power(x, -1.5)\n&quot;</span>
    <span class="s0">&quot;(-0.03986825876151894-0.14051741840449583j)&quot;)</span>
<span class="s0">ufunc_elliprj_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_ffff_f</span>
<span class="s0">ufunc_elliprj_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_dddd_d</span>
<span class="s0">ufunc_elliprj_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_DDDD__As_FFFF_F</span>
<span class="s0">ufunc_elliprj_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_DDDD__As_DDDD_D</span>
<span class="s0">ufunc_elliprj_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprj_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprj_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprj_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprj_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_elliprj_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprj_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprj_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprj_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprj_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_elliprj_types[10] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprj_types[11] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprj_types[12] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprj_types[13] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprj_types[14] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_elliprj_types[15] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprj_types[16] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprj_types[17] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprj_types[18] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprj_types[19] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_elliprj_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_fellint_RJ</span>
<span class="s0">ufunc_elliprj_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprj&quot;)</span>
<span class="s0">ufunc_elliprj_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_fellint_RJ</span>
<span class="s0">ufunc_elliprj_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprj&quot;)</span>
<span class="s0">ufunc_elliprj_ptr[2*2] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_cellint_RJ</span>
<span class="s0">ufunc_elliprj_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprj&quot;)</span>
<span class="s0">ufunc_elliprj_ptr[2*3] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_cellint_RJ</span>
<span class="s0">ufunc_elliprj_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;elliprj&quot;)</span>
<span class="s0">ufunc_elliprj_data[0] = &amp;ufunc_elliprj_ptr[2*0]</span>
<span class="s0">ufunc_elliprj_data[1] = &amp;ufunc_elliprj_ptr[2*1]</span>
<span class="s0">ufunc_elliprj_data[2] = &amp;ufunc_elliprj_ptr[2*2]</span>
<span class="s0">ufunc_elliprj_data[3] = &amp;ufunc_elliprj_ptr[2*3]</span>
<span class="s0">elliprj = np.PyUFunc_FromFuncAndData(ufunc_elliprj_loops, ufunc_elliprj_data, ufunc_elliprj_types, 4, 4, 1, 0, &quot;elliprj&quot;, ufunc_elliprj_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_entr_loops[2]</span>
<span class="s0">cdef void *ufunc_entr_ptr[4]</span>
<span class="s0">cdef void *ufunc_entr_data[2]</span>
<span class="s0">cdef char ufunc_entr_types[4]</span>
<span class="s0">cdef char *ufunc_entr_doc = (</span>
    <span class="s0">&quot;entr(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Elementwise function for computing entropy.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: \\text{entr}(x) = \\begin{cases} - x \\log(x) &amp; x &gt; 0  \\\\ 0 &amp; x = 0 \\\\ -\\infty &amp; \\text{otherwise} \\end{cases}\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : ndarray\n&quot;</span>
    <span class="s0">&quot;    Input array.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;res : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The value of the elementwise entropy function at the given points `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;kl_div, rel_entr, scipy.stats.entropy\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 0.15.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is concave.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The origin of this function is in convex programming; see [1]_.\n&quot;</span>
    <span class="s0">&quot;Given a probability distribution :math:`p_1, \\ldots, p_n`,\n&quot;</span>
    <span class="s0">&quot;the definition of entropy in the context of *information theory* is\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    \\sum_{i = 1}^n \\mathrm{entr}(p_i).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;To compute the latter quantity, use `scipy.stats.entropy`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Boyd, Stephen and Lieven Vandenberghe. *Convex optimization*.\n&quot;</span>
    <span class="s0">&quot;       Cambridge University Press, 2004.\n&quot;</span>
    <span class="s0">&quot;       :doi:`https://doi.org/10.1017/CBO9780511804441`&quot;)</span>
<span class="s0">ufunc_entr_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_entr_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_entr_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_entr_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_entr_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_entr_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_entr_ptr[2*0] = &lt;void*&gt;_func_entr</span>
<span class="s0">ufunc_entr_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;entr&quot;)</span>
<span class="s0">ufunc_entr_ptr[2*1] = &lt;void*&gt;_func_entr</span>
<span class="s0">ufunc_entr_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;entr&quot;)</span>
<span class="s0">ufunc_entr_data[0] = &amp;ufunc_entr_ptr[2*0]</span>
<span class="s0">ufunc_entr_data[1] = &amp;ufunc_entr_ptr[2*1]</span>
<span class="s0">entr = np.PyUFunc_FromFuncAndData(ufunc_entr_loops, ufunc_entr_data, ufunc_entr_types, 2, 1, 1, 0, &quot;entr&quot;, ufunc_entr_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_erf_loops[4]</span>
<span class="s0">cdef void *ufunc_erf_ptr[8]</span>
<span class="s0">cdef void *ufunc_erf_data[4]</span>
<span class="s0">cdef char ufunc_erf_types[8]</span>
<span class="s0">cdef char *ufunc_erf_doc = (</span>
    <span class="s0">&quot;erf(z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the error function of complex argument.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is defined as ``2/sqrt(pi)*integral(exp(-t**2), t=0..z)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : ndarray\n&quot;</span>
    <span class="s0">&quot;    Input array.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;res : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The values of the error function at the given points `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;erfc, erfinv, erfcinv, wofz, erfcx, erfi\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The cumulative of the unit normal distribution is given by\n&quot;</span>
    <span class="s0">&quot;``Phi(z) = 1/2[1 + erf(z/sqrt(2))]``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] https://en.wikipedia.org/wiki/Error_function\n&quot;</span>
    <span class="s0">&quot;.. [2] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;    Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;    Graphs, and Mathematical Tables. New York: Dover,\n&quot;</span>
    <span class="s0">&quot;    1972. http://www.math.sfu.ca/~cbm/aands/page_297.htm\n&quot;</span>
    <span class="s0">&quot;.. [3] Steven G. Johnson, Faddeeva W function implementation.\n&quot;</span>
    <span class="s0">&quot;   http://ab-initio.mit.edu/Faddeeva\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy import special\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-3, 3)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.plot(x, special.erf(x))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.xlabel('$x$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.ylabel('$erf(x)$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_erf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_erf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_erf_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_F_F</span>
<span class="s0">ufunc_erf_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_D_D</span>
<span class="s0">ufunc_erf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_erf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_erf_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_erf_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_erf_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_erf_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_erf_types[6] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_erf_types[7] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_erf_ptr[2*0] = &lt;void*&gt;_func_erf</span>
<span class="s0">ufunc_erf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erf&quot;)</span>
<span class="s0">ufunc_erf_ptr[2*1] = &lt;void*&gt;_func_erf</span>
<span class="s0">ufunc_erf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erf&quot;)</span>
<span class="s0">ufunc_erf_ptr[2*2] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_erf</span>
<span class="s0">ufunc_erf_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erf&quot;)</span>
<span class="s0">ufunc_erf_ptr[2*3] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_erf</span>
<span class="s0">ufunc_erf_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erf&quot;)</span>
<span class="s0">ufunc_erf_data[0] = &amp;ufunc_erf_ptr[2*0]</span>
<span class="s0">ufunc_erf_data[1] = &amp;ufunc_erf_ptr[2*1]</span>
<span class="s0">ufunc_erf_data[2] = &amp;ufunc_erf_ptr[2*2]</span>
<span class="s0">ufunc_erf_data[3] = &amp;ufunc_erf_ptr[2*3]</span>
<span class="s0">erf = np.PyUFunc_FromFuncAndData(ufunc_erf_loops, ufunc_erf_data, ufunc_erf_types, 4, 1, 1, 0, &quot;erf&quot;, ufunc_erf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_erfc_loops[4]</span>
<span class="s0">cdef void *ufunc_erfc_ptr[8]</span>
<span class="s0">cdef void *ufunc_erfc_data[4]</span>
<span class="s0">cdef char ufunc_erfc_types[8]</span>
<span class="s0">cdef char *ufunc_erfc_doc = (</span>
    <span class="s0">&quot;erfc(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Complementary error function, ``1 - erf(x)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real or complex valued argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the complementary error function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;erf, erfi, erfcx, dawsn, wofz\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Steven G. Johnson, Faddeeva W function implementation.\n&quot;</span>
    <span class="s0">&quot;   http://ab-initio.mit.edu/Faddeeva\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy import special\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-3, 3)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.plot(x, special.erfc(x))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.xlabel('$x$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.ylabel('$erfc(x)$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_erfc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_erfc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_erfc_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_F_F</span>
<span class="s0">ufunc_erfc_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_D_D</span>
<span class="s0">ufunc_erfc_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_erfc_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_erfc_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_erfc_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_erfc_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_erfc_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_erfc_types[6] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_erfc_types[7] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_erfc_ptr[2*0] = &lt;void*&gt;_func_erfc</span>
<span class="s0">ufunc_erfc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erfc&quot;)</span>
<span class="s0">ufunc_erfc_ptr[2*1] = &lt;void*&gt;_func_erfc</span>
<span class="s0">ufunc_erfc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erfc&quot;)</span>
<span class="s0">ufunc_erfc_ptr[2*2] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_erfc_complex</span>
<span class="s0">ufunc_erfc_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erfc&quot;)</span>
<span class="s0">ufunc_erfc_ptr[2*3] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_erfc_complex</span>
<span class="s0">ufunc_erfc_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erfc&quot;)</span>
<span class="s0">ufunc_erfc_data[0] = &amp;ufunc_erfc_ptr[2*0]</span>
<span class="s0">ufunc_erfc_data[1] = &amp;ufunc_erfc_ptr[2*1]</span>
<span class="s0">ufunc_erfc_data[2] = &amp;ufunc_erfc_ptr[2*2]</span>
<span class="s0">ufunc_erfc_data[3] = &amp;ufunc_erfc_ptr[2*3]</span>
<span class="s0">erfc = np.PyUFunc_FromFuncAndData(ufunc_erfc_loops, ufunc_erfc_data, ufunc_erfc_types, 4, 1, 1, 0, &quot;erfc&quot;, ufunc_erfc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_erfcinv_loops[2]</span>
<span class="s0">cdef void *ufunc_erfcinv_ptr[4]</span>
<span class="s0">cdef void *ufunc_erfcinv_data[2]</span>
<span class="s0">cdef char ufunc_erfcinv_types[4]</span>
<span class="s0">cdef char *ufunc_erfcinv_doc = (</span>
    <span class="s0">&quot;erfcinv(y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse of the complementary error function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes the inverse of the complementary error function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;In the complex domain, there is no unique complex number w satisfying\n&quot;</span>
    <span class="s0">&quot;erfc(w)=z. This indicates a true inverse function would be multivalued.\n&quot;</span>
    <span class="s0">&quot;When the domain restricts to the real, 0 &lt; x &lt; 2, there is a unique real\n&quot;</span>
    <span class="s0">&quot;number satisfying erfc(erfcinv(x)) = erfcinv(erfc(x)).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is related to inverse of the error function by erfcinv(1-x) = erfinv(x)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;y : ndarray\n&quot;</span>
    <span class="s0">&quot;    Argument at which to evaluate. Domain: [0, 2]\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;erfcinv : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The inverse of erfc of y, element-wise\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;erf : Error function of a complex argument\n&quot;</span>
    <span class="s0">&quot;erfc : Complementary error function, ``1 - erf(x)``\n&quot;</span>
    <span class="s0">&quot;erfinv : Inverse of the error function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import erfcinv\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; erfcinv(0.5)\n&quot;</span>
    <span class="s0">&quot;0.4769362762044699\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = np.linspace(0.0, 2.0, num=11)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; erfcinv(y)\n&quot;</span>
    <span class="s0">&quot;array([        inf,  0.9061938 ,  0.59511608,  0.37080716,  0.17914345,\n&quot;</span>
    <span class="s0">&quot;       -0.        , -0.17914345, -0.37080716, -0.59511608, -0.9061938 ,\n&quot;</span>
    <span class="s0">&quot;              -inf])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = np.linspace(0, 2, 200)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(y, erfcinv(y))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.grid(True)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel('y')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title('erfcinv(y)')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_erfcinv_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_erfcinv_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_erfcinv_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_erfcinv_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_erfcinv_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_erfcinv_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_erfcinv_ptr[2*0] = &lt;void*&gt;_func_erfcinv</span>
<span class="s0">ufunc_erfcinv_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erfcinv&quot;)</span>
<span class="s0">ufunc_erfcinv_ptr[2*1] = &lt;void*&gt;_func_erfcinv</span>
<span class="s0">ufunc_erfcinv_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erfcinv&quot;)</span>
<span class="s0">ufunc_erfcinv_data[0] = &amp;ufunc_erfcinv_ptr[2*0]</span>
<span class="s0">ufunc_erfcinv_data[1] = &amp;ufunc_erfcinv_ptr[2*1]</span>
<span class="s0">erfcinv = np.PyUFunc_FromFuncAndData(ufunc_erfcinv_loops, ufunc_erfcinv_data, ufunc_erfcinv_types, 2, 1, 1, 0, &quot;erfcinv&quot;, ufunc_erfcinv_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_erfcx_loops[4]</span>
<span class="s0">cdef void *ufunc_erfcx_ptr[8]</span>
<span class="s0">cdef void *ufunc_erfcx_data[4]</span>
<span class="s0">cdef char ufunc_erfcx_types[8]</span>
<span class="s0">cdef char *ufunc_erfcx_doc = (</span>
    <span class="s0">&quot;erfcx(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Scaled complementary error function, ``exp(x**2) * erfc(x)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real or complex valued argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the scaled complementary error function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;erf, erfc, erfi, dawsn, wofz\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 0.12.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Steven G. Johnson, Faddeeva W function implementation.\n&quot;</span>
    <span class="s0">&quot;   http://ab-initio.mit.edu/Faddeeva\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy import special\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-3, 3)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.plot(x, special.erfcx(x))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.xlabel('$x$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.ylabel('$erfcx(x)$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_erfcx_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_erfcx_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_erfcx_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_F_F</span>
<span class="s0">ufunc_erfcx_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_D_D</span>
<span class="s0">ufunc_erfcx_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_erfcx_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_erfcx_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_erfcx_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_erfcx_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_erfcx_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_erfcx_types[6] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_erfcx_types[7] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_erfcx_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_erfcx</span>
<span class="s0">ufunc_erfcx_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erfcx&quot;)</span>
<span class="s0">ufunc_erfcx_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_erfcx</span>
<span class="s0">ufunc_erfcx_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erfcx&quot;)</span>
<span class="s0">ufunc_erfcx_ptr[2*2] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_erfcx_complex</span>
<span class="s0">ufunc_erfcx_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erfcx&quot;)</span>
<span class="s0">ufunc_erfcx_ptr[2*3] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_erfcx_complex</span>
<span class="s0">ufunc_erfcx_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erfcx&quot;)</span>
<span class="s0">ufunc_erfcx_data[0] = &amp;ufunc_erfcx_ptr[2*0]</span>
<span class="s0">ufunc_erfcx_data[1] = &amp;ufunc_erfcx_ptr[2*1]</span>
<span class="s0">ufunc_erfcx_data[2] = &amp;ufunc_erfcx_ptr[2*2]</span>
<span class="s0">ufunc_erfcx_data[3] = &amp;ufunc_erfcx_ptr[2*3]</span>
<span class="s0">erfcx = np.PyUFunc_FromFuncAndData(ufunc_erfcx_loops, ufunc_erfcx_data, ufunc_erfcx_types, 4, 1, 1, 0, &quot;erfcx&quot;, ufunc_erfcx_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_erfi_loops[4]</span>
<span class="s0">cdef void *ufunc_erfi_ptr[8]</span>
<span class="s0">cdef void *ufunc_erfi_data[4]</span>
<span class="s0">cdef char ufunc_erfi_types[8]</span>
<span class="s0">cdef char *ufunc_erfi_doc = (</span>
    <span class="s0">&quot;erfi(z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Imaginary error function, ``-i erf(i z)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;z : array_like\n&quot;</span>
    <span class="s0">&quot;    Real or complex valued argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the imaginary error function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;erf, erfc, erfcx, dawsn, wofz\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 0.12.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Steven G. Johnson, Faddeeva W function implementation.\n&quot;</span>
    <span class="s0">&quot;   http://ab-initio.mit.edu/Faddeeva\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy import special\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-3, 3)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.plot(x, special.erfi(x))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.xlabel('$x$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.ylabel('$erfi(x)$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_erfi_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_erfi_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_erfi_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_F_F</span>
<span class="s0">ufunc_erfi_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_D_D</span>
<span class="s0">ufunc_erfi_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_erfi_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_erfi_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_erfi_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_erfi_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_erfi_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_erfi_types[6] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_erfi_types[7] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_erfi_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_erfi</span>
<span class="s0">ufunc_erfi_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erfi&quot;)</span>
<span class="s0">ufunc_erfi_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_erfi</span>
<span class="s0">ufunc_erfi_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erfi&quot;)</span>
<span class="s0">ufunc_erfi_ptr[2*2] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_erfi_complex</span>
<span class="s0">ufunc_erfi_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erfi&quot;)</span>
<span class="s0">ufunc_erfi_ptr[2*3] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_erfi_complex</span>
<span class="s0">ufunc_erfi_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erfi&quot;)</span>
<span class="s0">ufunc_erfi_data[0] = &amp;ufunc_erfi_ptr[2*0]</span>
<span class="s0">ufunc_erfi_data[1] = &amp;ufunc_erfi_ptr[2*1]</span>
<span class="s0">ufunc_erfi_data[2] = &amp;ufunc_erfi_ptr[2*2]</span>
<span class="s0">ufunc_erfi_data[3] = &amp;ufunc_erfi_ptr[2*3]</span>
<span class="s0">erfi = np.PyUFunc_FromFuncAndData(ufunc_erfi_loops, ufunc_erfi_data, ufunc_erfi_types, 4, 1, 1, 0, &quot;erfi&quot;, ufunc_erfi_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_erfinv_loops[2]</span>
<span class="s0">cdef void *ufunc_erfinv_ptr[4]</span>
<span class="s0">cdef void *ufunc_erfinv_data[2]</span>
<span class="s0">cdef char ufunc_erfinv_types[4]</span>
<span class="s0">cdef char *ufunc_erfinv_doc = (</span>
    <span class="s0">&quot;erfinv(y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse of the error function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes the inverse of the error function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;In the complex domain, there is no unique complex number w satisfying\n&quot;</span>
    <span class="s0">&quot;erf(w)=z. This indicates a true inverse function would be multivalued.\n&quot;</span>
    <span class="s0">&quot;When the domain restricts to the real, -1 &lt; x &lt; 1, there is a unique real\n&quot;</span>
    <span class="s0">&quot;number satisfying erf(erfinv(x)) = x.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;y : ndarray\n&quot;</span>
    <span class="s0">&quot;    Argument at which to evaluate. Domain: [-1, 1]\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;erfinv : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The inverse of erf of y, element-wise\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;erf : Error function of a complex argument\n&quot;</span>
    <span class="s0">&quot;erfc : Complementary error function, ``1 - erf(x)``\n&quot;</span>
    <span class="s0">&quot;erfcinv : Inverse of the complementary error function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import erfinv, erf\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; erfinv(0.5)\n&quot;</span>
    <span class="s0">&quot;0.4769362762044699\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = np.linspace(-1.0, 1.0, num=9)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = erfinv(y)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x\n&quot;</span>
    <span class="s0">&quot;array([       -inf, -0.81341985, -0.47693628, -0.22531206,  0.        ,\n&quot;</span>
    <span class="s0">&quot;        0.22531206,  0.47693628,  0.81341985,         inf])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Verify that ``erf(erfinv(y))`` is ``y``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; erf(x)\n&quot;</span>
    <span class="s0">&quot;array([-1.  , -0.75, -0.5 , -0.25,  0.  ,  0.25,  0.5 ,  0.75,  1.  ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = np.linspace(-1, 1, 200)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(y, erfinv(y))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.grid(True)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel('y')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title('erfinv(y)')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_erfinv_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_f__As_f_f</span>
<span class="s0">ufunc_erfinv_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_erfinv_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_erfinv_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_erfinv_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_erfinv_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_erfinv_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_erfinv_float</span>
<span class="s0">ufunc_erfinv_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erfinv&quot;)</span>
<span class="s0">ufunc_erfinv_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_erfinv_double</span>
<span class="s0">ufunc_erfinv_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;erfinv&quot;)</span>
<span class="s0">ufunc_erfinv_data[0] = &amp;ufunc_erfinv_ptr[2*0]</span>
<span class="s0">ufunc_erfinv_data[1] = &amp;ufunc_erfinv_ptr[2*1]</span>
<span class="s0">erfinv = np.PyUFunc_FromFuncAndData(ufunc_erfinv_loops, ufunc_erfinv_data, ufunc_erfinv_types, 2, 1, 1, 0, &quot;erfinv&quot;, ufunc_erfinv_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_eval_chebyc_loops[5]</span>
<span class="s0">cdef void *ufunc_eval_chebyc_ptr[10]</span>
<span class="s0">cdef void *ufunc_eval_chebyc_data[5]</span>
<span class="s0">cdef char ufunc_eval_chebyc_types[15]</span>
<span class="s0">cdef char *ufunc_eval_chebyc_doc = (</span>
    <span class="s0">&quot;eval_chebyc(n, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate Chebyshev polynomial of the first kind on [-2, 2] at a\n&quot;</span>
    <span class="s0">&quot;point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;These polynomials are defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    C_n(x) = 2 T_n(x/2)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`T_n` is a Chebyshev polynomial of the first kind. See\n&quot;</span>
    <span class="s0">&quot;22.5.11 in [AS]_ for details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Degree of the polynomial. If not an integer, the result is\n&quot;</span>
    <span class="s0">&quot;    determined via the relation to `eval_chebyt`.\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Points at which to evaluate the Chebyshev polynomial\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;C : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Chebyshev polynomial\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;roots_chebyc : roots and quadrature weights of Chebyshev\n&quot;</span>
    <span class="s0">&quot;               polynomials of the first kind on [-2, 2]\n&quot;</span>
    <span class="s0">&quot;chebyc : Chebyshev polynomial object\n&quot;</span>
    <span class="s0">&quot;numpy.polynomial.chebyshev.Chebyshev : Chebyshev series\n&quot;</span>
    <span class="s0">&quot;eval_chebyt : evaluate Chebycshev polynomials of the first kind\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;    Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;    Graphs, and Mathematical Tables. New York: Dover, 1972.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;They are a scaled version of the Chebyshev polynomials of the\n&quot;</span>
    <span class="s0">&quot;first kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-2, 2, 6)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.eval_chebyc(3, x)\n&quot;</span>
    <span class="s0">&quot;array([-2.   ,  1.872,  1.136, -1.136, -1.872,  2.   ])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; 2 * sc.eval_chebyt(3, x / 2)\n&quot;</span>
    <span class="s0">&quot;array([-2.   ,  1.872,  1.136, -1.136, -1.872,  2.   ])&quot;)</span>
<span class="s0">ufunc_eval_chebyc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ld__As_ld_d</span>
<span class="s0">ufunc_eval_chebyc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_eval_chebyc_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_fF_F</span>
<span class="s0">ufunc_eval_chebyc_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_eval_chebyc_loops[4] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_dD_D</span>
<span class="s0">ufunc_eval_chebyc_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc_eval_chebyc_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyc_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyc_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_chebyc_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_chebyc_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_chebyc_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_chebyc_types[7] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_chebyc_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_chebyc_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyc_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyc_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyc_types[12] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyc_types[13] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_chebyc_types[14] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_chebyc_ptr[2*0] = &lt;void*&gt;_func_eval_chebyc_l</span>
<span class="s0">ufunc_eval_chebyc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebyc&quot;)</span>
<span class="s0">ufunc_eval_chebyc_ptr[2*1] = &lt;void*&gt;_func_eval_chebyc[double]</span>
<span class="s0">ufunc_eval_chebyc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebyc&quot;)</span>
<span class="s0">ufunc_eval_chebyc_ptr[2*2] = &lt;void*&gt;_func_eval_chebyc[double_complex]</span>
<span class="s0">ufunc_eval_chebyc_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebyc&quot;)</span>
<span class="s0">ufunc_eval_chebyc_ptr[2*3] = &lt;void*&gt;_func_eval_chebyc[double]</span>
<span class="s0">ufunc_eval_chebyc_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebyc&quot;)</span>
<span class="s0">ufunc_eval_chebyc_ptr[2*4] = &lt;void*&gt;_func_eval_chebyc[double_complex]</span>
<span class="s0">ufunc_eval_chebyc_ptr[2*4+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebyc&quot;)</span>
<span class="s0">ufunc_eval_chebyc_data[0] = &amp;ufunc_eval_chebyc_ptr[2*0]</span>
<span class="s0">ufunc_eval_chebyc_data[1] = &amp;ufunc_eval_chebyc_ptr[2*1]</span>
<span class="s0">ufunc_eval_chebyc_data[2] = &amp;ufunc_eval_chebyc_ptr[2*2]</span>
<span class="s0">ufunc_eval_chebyc_data[3] = &amp;ufunc_eval_chebyc_ptr[2*3]</span>
<span class="s0">ufunc_eval_chebyc_data[4] = &amp;ufunc_eval_chebyc_ptr[2*4]</span>
<span class="s0">eval_chebyc = np.PyUFunc_FromFuncAndData(ufunc_eval_chebyc_loops, ufunc_eval_chebyc_data, ufunc_eval_chebyc_types, 5, 2, 1, 0, &quot;eval_chebyc&quot;, ufunc_eval_chebyc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_eval_chebys_loops[5]</span>
<span class="s0">cdef void *ufunc_eval_chebys_ptr[10]</span>
<span class="s0">cdef void *ufunc_eval_chebys_data[5]</span>
<span class="s0">cdef char ufunc_eval_chebys_types[15]</span>
<span class="s0">cdef char *ufunc_eval_chebys_doc = (</span>
    <span class="s0">&quot;eval_chebys(n, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate Chebyshev polynomial of the second kind on [-2, 2] at a\n&quot;</span>
    <span class="s0">&quot;point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;These polynomials are defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    S_n(x) = U_n(x/2)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`U_n` is a Chebyshev polynomial of the second\n&quot;</span>
    <span class="s0">&quot;kind. See 22.5.13 in [AS]_ for details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Degree of the polynomial. If not an integer, the result is\n&quot;</span>
    <span class="s0">&quot;    determined via the relation to `eval_chebyu`.\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Points at which to evaluate the Chebyshev polynomial\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;S : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Chebyshev polynomial\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;roots_chebys : roots and quadrature weights of Chebyshev\n&quot;</span>
    <span class="s0">&quot;               polynomials of the second kind on [-2, 2]\n&quot;</span>
    <span class="s0">&quot;chebys : Chebyshev polynomial object\n&quot;</span>
    <span class="s0">&quot;eval_chebyu : evaluate Chebyshev polynomials of the second kind\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;    Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;    Graphs, and Mathematical Tables. New York: Dover, 1972.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;They are a scaled version of the Chebyshev polynomials of the\n&quot;</span>
    <span class="s0">&quot;second kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-2, 2, 6)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.eval_chebys(3, x)\n&quot;</span>
    <span class="s0">&quot;array([-4.   ,  0.672,  0.736, -0.736, -0.672,  4.   ])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.eval_chebyu(3, x / 2)\n&quot;</span>
    <span class="s0">&quot;array([-4.   ,  0.672,  0.736, -0.736, -0.672,  4.   ])&quot;)</span>
<span class="s0">ufunc_eval_chebys_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ld__As_ld_d</span>
<span class="s0">ufunc_eval_chebys_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_eval_chebys_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_fF_F</span>
<span class="s0">ufunc_eval_chebys_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_eval_chebys_loops[4] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_dD_D</span>
<span class="s0">ufunc_eval_chebys_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc_eval_chebys_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebys_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebys_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_chebys_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_chebys_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_chebys_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_chebys_types[7] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_chebys_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_chebys_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebys_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebys_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebys_types[12] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebys_types[13] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_chebys_types[14] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_chebys_ptr[2*0] = &lt;void*&gt;_func_eval_chebys_l</span>
<span class="s0">ufunc_eval_chebys_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebys&quot;)</span>
<span class="s0">ufunc_eval_chebys_ptr[2*1] = &lt;void*&gt;_func_eval_chebys[double]</span>
<span class="s0">ufunc_eval_chebys_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebys&quot;)</span>
<span class="s0">ufunc_eval_chebys_ptr[2*2] = &lt;void*&gt;_func_eval_chebys[double_complex]</span>
<span class="s0">ufunc_eval_chebys_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebys&quot;)</span>
<span class="s0">ufunc_eval_chebys_ptr[2*3] = &lt;void*&gt;_func_eval_chebys[double]</span>
<span class="s0">ufunc_eval_chebys_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebys&quot;)</span>
<span class="s0">ufunc_eval_chebys_ptr[2*4] = &lt;void*&gt;_func_eval_chebys[double_complex]</span>
<span class="s0">ufunc_eval_chebys_ptr[2*4+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebys&quot;)</span>
<span class="s0">ufunc_eval_chebys_data[0] = &amp;ufunc_eval_chebys_ptr[2*0]</span>
<span class="s0">ufunc_eval_chebys_data[1] = &amp;ufunc_eval_chebys_ptr[2*1]</span>
<span class="s0">ufunc_eval_chebys_data[2] = &amp;ufunc_eval_chebys_ptr[2*2]</span>
<span class="s0">ufunc_eval_chebys_data[3] = &amp;ufunc_eval_chebys_ptr[2*3]</span>
<span class="s0">ufunc_eval_chebys_data[4] = &amp;ufunc_eval_chebys_ptr[2*4]</span>
<span class="s0">eval_chebys = np.PyUFunc_FromFuncAndData(ufunc_eval_chebys_loops, ufunc_eval_chebys_data, ufunc_eval_chebys_types, 5, 2, 1, 0, &quot;eval_chebys&quot;, ufunc_eval_chebys_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_eval_chebyt_loops[5]</span>
<span class="s0">cdef void *ufunc_eval_chebyt_ptr[10]</span>
<span class="s0">cdef void *ufunc_eval_chebyt_data[5]</span>
<span class="s0">cdef char ufunc_eval_chebyt_types[15]</span>
<span class="s0">cdef char *ufunc_eval_chebyt_doc = (</span>
    <span class="s0">&quot;eval_chebyt(n, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate Chebyshev polynomial of the first kind at a point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The Chebyshev polynomials of the first kind can be defined via the\n&quot;</span>
    <span class="s0">&quot;Gauss hypergeometric function :math:`{}_2F_1` as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    T_n(x) = {}_2F_1(n, -n; 1/2; (1 - x)/2).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;When :math:`n` is an integer the result is a polynomial of degree\n&quot;</span>
    <span class="s0">&quot;:math:`n`. See 22.5.47 in [AS]_ for details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Degree of the polynomial. If not an integer, the result is\n&quot;</span>
    <span class="s0">&quot;    determined via the relation to the Gauss hypergeometric\n&quot;</span>
    <span class="s0">&quot;    function.\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Points at which to evaluate the Chebyshev polynomial\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;T : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Chebyshev polynomial\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;roots_chebyt : roots and quadrature weights of Chebyshev\n&quot;</span>
    <span class="s0">&quot;               polynomials of the first kind\n&quot;</span>
    <span class="s0">&quot;chebyu : Chebychev polynomial object\n&quot;</span>
    <span class="s0">&quot;eval_chebyu : evaluate Chebyshev polynomials of the second kind\n&quot;</span>
    <span class="s0">&quot;hyp2f1 : Gauss hypergeometric function\n&quot;</span>
    <span class="s0">&quot;numpy.polynomial.chebyshev.Chebyshev : Chebyshev series\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;This routine is numerically stable for `x` in ``[-1, 1]`` at least\n&quot;</span>
    <span class="s0">&quot;up to order ``10000``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;    Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;    Graphs, and Mathematical Tables. New York: Dover, 1972.&quot;)</span>
<span class="s0">ufunc_eval_chebyt_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ld__As_ld_d</span>
<span class="s0">ufunc_eval_chebyt_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_eval_chebyt_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_fF_F</span>
<span class="s0">ufunc_eval_chebyt_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_eval_chebyt_loops[4] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_dD_D</span>
<span class="s0">ufunc_eval_chebyt_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc_eval_chebyt_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyt_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyt_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_chebyt_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_chebyt_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_chebyt_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_chebyt_types[7] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_chebyt_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_chebyt_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyt_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyt_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyt_types[12] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyt_types[13] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_chebyt_types[14] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_chebyt_ptr[2*0] = &lt;void*&gt;_func_eval_chebyt_l</span>
<span class="s0">ufunc_eval_chebyt_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebyt&quot;)</span>
<span class="s0">ufunc_eval_chebyt_ptr[2*1] = &lt;void*&gt;_func_eval_chebyt[double]</span>
<span class="s0">ufunc_eval_chebyt_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebyt&quot;)</span>
<span class="s0">ufunc_eval_chebyt_ptr[2*2] = &lt;void*&gt;_func_eval_chebyt[double_complex]</span>
<span class="s0">ufunc_eval_chebyt_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebyt&quot;)</span>
<span class="s0">ufunc_eval_chebyt_ptr[2*3] = &lt;void*&gt;_func_eval_chebyt[double]</span>
<span class="s0">ufunc_eval_chebyt_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebyt&quot;)</span>
<span class="s0">ufunc_eval_chebyt_ptr[2*4] = &lt;void*&gt;_func_eval_chebyt[double_complex]</span>
<span class="s0">ufunc_eval_chebyt_ptr[2*4+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebyt&quot;)</span>
<span class="s0">ufunc_eval_chebyt_data[0] = &amp;ufunc_eval_chebyt_ptr[2*0]</span>
<span class="s0">ufunc_eval_chebyt_data[1] = &amp;ufunc_eval_chebyt_ptr[2*1]</span>
<span class="s0">ufunc_eval_chebyt_data[2] = &amp;ufunc_eval_chebyt_ptr[2*2]</span>
<span class="s0">ufunc_eval_chebyt_data[3] = &amp;ufunc_eval_chebyt_ptr[2*3]</span>
<span class="s0">ufunc_eval_chebyt_data[4] = &amp;ufunc_eval_chebyt_ptr[2*4]</span>
<span class="s0">eval_chebyt = np.PyUFunc_FromFuncAndData(ufunc_eval_chebyt_loops, ufunc_eval_chebyt_data, ufunc_eval_chebyt_types, 5, 2, 1, 0, &quot;eval_chebyt&quot;, ufunc_eval_chebyt_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_eval_chebyu_loops[5]</span>
<span class="s0">cdef void *ufunc_eval_chebyu_ptr[10]</span>
<span class="s0">cdef void *ufunc_eval_chebyu_data[5]</span>
<span class="s0">cdef char ufunc_eval_chebyu_types[15]</span>
<span class="s0">cdef char *ufunc_eval_chebyu_doc = (</span>
    <span class="s0">&quot;eval_chebyu(n, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate Chebyshev polynomial of the second kind at a point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The Chebyshev polynomials of the second kind can be defined via\n&quot;</span>
    <span class="s0">&quot;the Gauss hypergeometric function :math:`{}_2F_1` as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    U_n(x) = (n + 1) {}_2F_1(-n, n + 2; 3/2; (1 - x)/2).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;When :math:`n` is an integer the result is a polynomial of degree\n&quot;</span>
    <span class="s0">&quot;:math:`n`. See 22.5.48 in [AS]_ for details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Degree of the polynomial. If not an integer, the result is\n&quot;</span>
    <span class="s0">&quot;    determined via the relation to the Gauss hypergeometric\n&quot;</span>
    <span class="s0">&quot;    function.\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Points at which to evaluate the Chebyshev polynomial\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;U : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Chebyshev polynomial\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;roots_chebyu : roots and quadrature weights of Chebyshev\n&quot;</span>
    <span class="s0">&quot;               polynomials of the second kind\n&quot;</span>
    <span class="s0">&quot;chebyu : Chebyshev polynomial object\n&quot;</span>
    <span class="s0">&quot;eval_chebyt : evaluate Chebyshev polynomials of the first kind\n&quot;</span>
    <span class="s0">&quot;hyp2f1 : Gauss hypergeometric function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;    Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;    Graphs, and Mathematical Tables. New York: Dover, 1972.&quot;)</span>
<span class="s0">ufunc_eval_chebyu_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ld__As_ld_d</span>
<span class="s0">ufunc_eval_chebyu_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_eval_chebyu_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_fF_F</span>
<span class="s0">ufunc_eval_chebyu_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_eval_chebyu_loops[4] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_dD_D</span>
<span class="s0">ufunc_eval_chebyu_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc_eval_chebyu_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyu_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyu_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_chebyu_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_chebyu_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_chebyu_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_chebyu_types[7] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_chebyu_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_chebyu_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyu_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyu_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyu_types[12] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_chebyu_types[13] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_chebyu_types[14] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_chebyu_ptr[2*0] = &lt;void*&gt;_func_eval_chebyu_l</span>
<span class="s0">ufunc_eval_chebyu_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebyu&quot;)</span>
<span class="s0">ufunc_eval_chebyu_ptr[2*1] = &lt;void*&gt;_func_eval_chebyu[double]</span>
<span class="s0">ufunc_eval_chebyu_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebyu&quot;)</span>
<span class="s0">ufunc_eval_chebyu_ptr[2*2] = &lt;void*&gt;_func_eval_chebyu[double_complex]</span>
<span class="s0">ufunc_eval_chebyu_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebyu&quot;)</span>
<span class="s0">ufunc_eval_chebyu_ptr[2*3] = &lt;void*&gt;_func_eval_chebyu[double]</span>
<span class="s0">ufunc_eval_chebyu_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebyu&quot;)</span>
<span class="s0">ufunc_eval_chebyu_ptr[2*4] = &lt;void*&gt;_func_eval_chebyu[double_complex]</span>
<span class="s0">ufunc_eval_chebyu_ptr[2*4+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_chebyu&quot;)</span>
<span class="s0">ufunc_eval_chebyu_data[0] = &amp;ufunc_eval_chebyu_ptr[2*0]</span>
<span class="s0">ufunc_eval_chebyu_data[1] = &amp;ufunc_eval_chebyu_ptr[2*1]</span>
<span class="s0">ufunc_eval_chebyu_data[2] = &amp;ufunc_eval_chebyu_ptr[2*2]</span>
<span class="s0">ufunc_eval_chebyu_data[3] = &amp;ufunc_eval_chebyu_ptr[2*3]</span>
<span class="s0">ufunc_eval_chebyu_data[4] = &amp;ufunc_eval_chebyu_ptr[2*4]</span>
<span class="s0">eval_chebyu = np.PyUFunc_FromFuncAndData(ufunc_eval_chebyu_loops, ufunc_eval_chebyu_data, ufunc_eval_chebyu_types, 5, 2, 1, 0, &quot;eval_chebyu&quot;, ufunc_eval_chebyu_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_eval_gegenbauer_loops[5]</span>
<span class="s0">cdef void *ufunc_eval_gegenbauer_ptr[10]</span>
<span class="s0">cdef void *ufunc_eval_gegenbauer_data[5]</span>
<span class="s0">cdef char ufunc_eval_gegenbauer_types[20]</span>
<span class="s0">cdef char *ufunc_eval_gegenbauer_doc = (</span>
    <span class="s0">&quot;eval_gegenbauer(n, alpha, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate Gegenbauer polynomial at a point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The Gegenbauer polynomials can be defined via the Gauss\n&quot;</span>
    <span class="s0">&quot;hypergeometric function :math:`{}_2F_1` as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    C_n^{(\\alpha)} = \\frac{(2\\alpha)_n}{\\Gamma(n + 1)}\n&quot;</span>
    <span class="s0">&quot;      {}_2F_1(-n, 2\\alpha + n; \\alpha + 1/2; (1 - z)/2).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;When :math:`n` is an integer the result is a polynomial of degree\n&quot;</span>
    <span class="s0">&quot;:math:`n`. See 22.5.46 in [AS]_ for details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Degree of the polynomial. If not an integer, the result is\n&quot;</span>
    <span class="s0">&quot;    determined via the relation to the Gauss hypergeometric\n&quot;</span>
    <span class="s0">&quot;    function.\n&quot;</span>
    <span class="s0">&quot;alpha : array_like\n&quot;</span>
    <span class="s0">&quot;    Parameter\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Points at which to evaluate the Gegenbauer polynomial\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;C : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Gegenbauer polynomial\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;roots_gegenbauer : roots and quadrature weights of Gegenbauer\n&quot;</span>
    <span class="s0">&quot;                   polynomials\n&quot;</span>
    <span class="s0">&quot;gegenbauer : Gegenbauer polynomial object\n&quot;</span>
    <span class="s0">&quot;hyp2f1 : Gauss hypergeometric function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;    Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;    Graphs, and Mathematical Tables. New York: Dover, 1972.&quot;)</span>
<span class="s0">ufunc_eval_gegenbauer_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ldd__As_ldd_d</span>
<span class="s0">ufunc_eval_gegenbauer_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_eval_gegenbauer_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_ddD__As_ffF_F</span>
<span class="s0">ufunc_eval_gegenbauer_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_eval_gegenbauer_loops[4] = &lt;np.PyUFuncGenericFunction&gt;loop_D_ddD__As_ddD_D</span>
<span class="s0">ufunc_eval_gegenbauer_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc_eval_gegenbauer_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_gegenbauer_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_gegenbauer_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_gegenbauer_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_gegenbauer_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_gegenbauer_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_gegenbauer_types[7] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_gegenbauer_types[8] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_gegenbauer_types[9] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_gegenbauer_types[10] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_gegenbauer_types[11] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_gegenbauer_types[12] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_gegenbauer_types[13] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_gegenbauer_types[14] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_gegenbauer_types[15] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_gegenbauer_types[16] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_gegenbauer_types[17] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_gegenbauer_types[18] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_gegenbauer_types[19] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_gegenbauer_ptr[2*0] = &lt;void*&gt;_func_eval_gegenbauer_l</span>
<span class="s0">ufunc_eval_gegenbauer_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_gegenbauer&quot;)</span>
<span class="s0">ufunc_eval_gegenbauer_ptr[2*1] = &lt;void*&gt;_func_eval_gegenbauer[double]</span>
<span class="s0">ufunc_eval_gegenbauer_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_gegenbauer&quot;)</span>
<span class="s0">ufunc_eval_gegenbauer_ptr[2*2] = &lt;void*&gt;_func_eval_gegenbauer[double_complex]</span>
<span class="s0">ufunc_eval_gegenbauer_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_gegenbauer&quot;)</span>
<span class="s0">ufunc_eval_gegenbauer_ptr[2*3] = &lt;void*&gt;_func_eval_gegenbauer[double]</span>
<span class="s0">ufunc_eval_gegenbauer_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_gegenbauer&quot;)</span>
<span class="s0">ufunc_eval_gegenbauer_ptr[2*4] = &lt;void*&gt;_func_eval_gegenbauer[double_complex]</span>
<span class="s0">ufunc_eval_gegenbauer_ptr[2*4+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_gegenbauer&quot;)</span>
<span class="s0">ufunc_eval_gegenbauer_data[0] = &amp;ufunc_eval_gegenbauer_ptr[2*0]</span>
<span class="s0">ufunc_eval_gegenbauer_data[1] = &amp;ufunc_eval_gegenbauer_ptr[2*1]</span>
<span class="s0">ufunc_eval_gegenbauer_data[2] = &amp;ufunc_eval_gegenbauer_ptr[2*2]</span>
<span class="s0">ufunc_eval_gegenbauer_data[3] = &amp;ufunc_eval_gegenbauer_ptr[2*3]</span>
<span class="s0">ufunc_eval_gegenbauer_data[4] = &amp;ufunc_eval_gegenbauer_ptr[2*4]</span>
<span class="s0">eval_gegenbauer = np.PyUFunc_FromFuncAndData(ufunc_eval_gegenbauer_loops, ufunc_eval_gegenbauer_data, ufunc_eval_gegenbauer_types, 5, 3, 1, 0, &quot;eval_gegenbauer&quot;, ufunc_eval_gegenbauer_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_eval_genlaguerre_loops[5]</span>
<span class="s0">cdef void *ufunc_eval_genlaguerre_ptr[10]</span>
<span class="s0">cdef void *ufunc_eval_genlaguerre_data[5]</span>
<span class="s0">cdef char ufunc_eval_genlaguerre_types[20]</span>
<span class="s0">cdef char *ufunc_eval_genlaguerre_doc = (</span>
    <span class="s0">&quot;eval_genlaguerre(n, alpha, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate generalized Laguerre polynomial at a point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The generalized Laguerre polynomials can be defined via the\n&quot;</span>
    <span class="s0">&quot;confluent hypergeometric function :math:`{}_1F_1` as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    L_n^{(\\alpha)}(x) = \\binom{n + \\alpha}{n}\n&quot;</span>
    <span class="s0">&quot;      {}_1F_1(-n, \\alpha + 1, x).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;When :math:`n` is an integer the result is a polynomial of degree\n&quot;</span>
    <span class="s0">&quot;:math:`n`. See 22.5.54 in [AS]_ for details. The Laguerre\n&quot;</span>
    <span class="s0">&quot;polynomials are the special case where :math:`\\alpha = 0`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Degree of the polynomial. If not an integer, the result is\n&quot;</span>
    <span class="s0">&quot;    determined via the relation to the confluent hypergeometric\n&quot;</span>
    <span class="s0">&quot;    function.\n&quot;</span>
    <span class="s0">&quot;alpha : array_like\n&quot;</span>
    <span class="s0">&quot;    Parameter; must have ``alpha &gt; -1``\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Points at which to evaluate the generalized Laguerre\n&quot;</span>
    <span class="s0">&quot;    polynomial\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;L : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the generalized Laguerre polynomial\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;roots_genlaguerre : roots and quadrature weights of generalized\n&quot;</span>
    <span class="s0">&quot;                    Laguerre polynomials\n&quot;</span>
    <span class="s0">&quot;genlaguerre : generalized Laguerre polynomial object\n&quot;</span>
    <span class="s0">&quot;hyp1f1 : confluent hypergeometric function\n&quot;</span>
    <span class="s0">&quot;eval_laguerre : evaluate Laguerre polynomials\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;    Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;    Graphs, and Mathematical Tables. New York: Dover, 1972.&quot;)</span>
<span class="s0">ufunc_eval_genlaguerre_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ldd__As_ldd_d</span>
<span class="s0">ufunc_eval_genlaguerre_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_eval_genlaguerre_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_ddD__As_ffF_F</span>
<span class="s0">ufunc_eval_genlaguerre_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_eval_genlaguerre_loops[4] = &lt;np.PyUFuncGenericFunction&gt;loop_D_ddD__As_ddD_D</span>
<span class="s0">ufunc_eval_genlaguerre_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc_eval_genlaguerre_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_genlaguerre_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_genlaguerre_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_genlaguerre_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_genlaguerre_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_genlaguerre_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_genlaguerre_types[7] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_genlaguerre_types[8] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_genlaguerre_types[9] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_genlaguerre_types[10] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_genlaguerre_types[11] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_genlaguerre_types[12] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_genlaguerre_types[13] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_genlaguerre_types[14] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_genlaguerre_types[15] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_genlaguerre_types[16] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_genlaguerre_types[17] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_genlaguerre_types[18] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_genlaguerre_types[19] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_genlaguerre_ptr[2*0] = &lt;void*&gt;_func_eval_genlaguerre_l</span>
<span class="s0">ufunc_eval_genlaguerre_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_genlaguerre&quot;)</span>
<span class="s0">ufunc_eval_genlaguerre_ptr[2*1] = &lt;void*&gt;_func_eval_genlaguerre[double]</span>
<span class="s0">ufunc_eval_genlaguerre_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_genlaguerre&quot;)</span>
<span class="s0">ufunc_eval_genlaguerre_ptr[2*2] = &lt;void*&gt;_func_eval_genlaguerre[double_complex]</span>
<span class="s0">ufunc_eval_genlaguerre_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_genlaguerre&quot;)</span>
<span class="s0">ufunc_eval_genlaguerre_ptr[2*3] = &lt;void*&gt;_func_eval_genlaguerre[double]</span>
<span class="s0">ufunc_eval_genlaguerre_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_genlaguerre&quot;)</span>
<span class="s0">ufunc_eval_genlaguerre_ptr[2*4] = &lt;void*&gt;_func_eval_genlaguerre[double_complex]</span>
<span class="s0">ufunc_eval_genlaguerre_ptr[2*4+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_genlaguerre&quot;)</span>
<span class="s0">ufunc_eval_genlaguerre_data[0] = &amp;ufunc_eval_genlaguerre_ptr[2*0]</span>
<span class="s0">ufunc_eval_genlaguerre_data[1] = &amp;ufunc_eval_genlaguerre_ptr[2*1]</span>
<span class="s0">ufunc_eval_genlaguerre_data[2] = &amp;ufunc_eval_genlaguerre_ptr[2*2]</span>
<span class="s0">ufunc_eval_genlaguerre_data[3] = &amp;ufunc_eval_genlaguerre_ptr[2*3]</span>
<span class="s0">ufunc_eval_genlaguerre_data[4] = &amp;ufunc_eval_genlaguerre_ptr[2*4]</span>
<span class="s0">eval_genlaguerre = np.PyUFunc_FromFuncAndData(ufunc_eval_genlaguerre_loops, ufunc_eval_genlaguerre_data, ufunc_eval_genlaguerre_types, 5, 3, 1, 0, &quot;eval_genlaguerre&quot;, ufunc_eval_genlaguerre_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_eval_hermite_loops[1]</span>
<span class="s0">cdef void *ufunc_eval_hermite_ptr[2]</span>
<span class="s0">cdef void *ufunc_eval_hermite_data[1]</span>
<span class="s0">cdef char ufunc_eval_hermite_types[3]</span>
<span class="s0">cdef char *ufunc_eval_hermite_doc = (</span>
    <span class="s0">&quot;eval_hermite(n, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate physicist's Hermite polynomial at a point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined by\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    H_n(x) = (-1)^n e^{x^2} \\frac{d^n}{dx^n} e^{-x^2};\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;:math:`H_n` is a polynomial of degree :math:`n`. See 22.11.7 in\n&quot;</span>
    <span class="s0">&quot;[AS]_ for details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Degree of the polynomial\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Points at which to evaluate the Hermite polynomial\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;H : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Hermite polynomial\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;roots_hermite : roots and quadrature weights of physicist's\n&quot;</span>
    <span class="s0">&quot;                Hermite polynomials\n&quot;</span>
    <span class="s0">&quot;hermite : physicist's Hermite polynomial object\n&quot;</span>
    <span class="s0">&quot;numpy.polynomial.hermite.Hermite : Physicist's Hermite series\n&quot;</span>
    <span class="s0">&quot;eval_hermitenorm : evaluate Probabilist's Hermite polynomials\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;    Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;    Graphs, and Mathematical Tables. New York: Dover, 1972.&quot;)</span>
<span class="s0">ufunc_eval_hermite_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ld__As_ld_d</span>
<span class="s0">ufunc_eval_hermite_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc_eval_hermite_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_hermite_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_hermite_ptr[2*0] = &lt;void*&gt;_func_eval_hermite</span>
<span class="s0">ufunc_eval_hermite_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_hermite&quot;)</span>
<span class="s0">ufunc_eval_hermite_data[0] = &amp;ufunc_eval_hermite_ptr[2*0]</span>
<span class="s0">eval_hermite = np.PyUFunc_FromFuncAndData(ufunc_eval_hermite_loops, ufunc_eval_hermite_data, ufunc_eval_hermite_types, 1, 2, 1, 0, &quot;eval_hermite&quot;, ufunc_eval_hermite_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_eval_hermitenorm_loops[1]</span>
<span class="s0">cdef void *ufunc_eval_hermitenorm_ptr[2]</span>
<span class="s0">cdef void *ufunc_eval_hermitenorm_data[1]</span>
<span class="s0">cdef char ufunc_eval_hermitenorm_types[3]</span>
<span class="s0">cdef char *ufunc_eval_hermitenorm_doc = (</span>
    <span class="s0">&quot;eval_hermitenorm(n, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate probabilist's (normalized) Hermite polynomial at a\n&quot;</span>
    <span class="s0">&quot;point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined by\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    He_n(x) = (-1)^n e^{x^2/2} \\frac{d^n}{dx^n} e^{-x^2/2};\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;:math:`He_n` is a polynomial of degree :math:`n`. See 22.11.8 in\n&quot;</span>
    <span class="s0">&quot;[AS]_ for details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Degree of the polynomial\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Points at which to evaluate the Hermite polynomial\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;He : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Hermite polynomial\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;roots_hermitenorm : roots and quadrature weights of probabilist's\n&quot;</span>
    <span class="s0">&quot;                    Hermite polynomials\n&quot;</span>
    <span class="s0">&quot;hermitenorm : probabilist's Hermite polynomial object\n&quot;</span>
    <span class="s0">&quot;numpy.polynomial.hermite_e.HermiteE : Probabilist's Hermite series\n&quot;</span>
    <span class="s0">&quot;eval_hermite : evaluate physicist's Hermite polynomials\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;    Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;    Graphs, and Mathematical Tables. New York: Dover, 1972.&quot;)</span>
<span class="s0">ufunc_eval_hermitenorm_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ld__As_ld_d</span>
<span class="s0">ufunc_eval_hermitenorm_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc_eval_hermitenorm_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_hermitenorm_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_hermitenorm_ptr[2*0] = &lt;void*&gt;_func_eval_hermitenorm</span>
<span class="s0">ufunc_eval_hermitenorm_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_hermitenorm&quot;)</span>
<span class="s0">ufunc_eval_hermitenorm_data[0] = &amp;ufunc_eval_hermitenorm_ptr[2*0]</span>
<span class="s0">eval_hermitenorm = np.PyUFunc_FromFuncAndData(ufunc_eval_hermitenorm_loops, ufunc_eval_hermitenorm_data, ufunc_eval_hermitenorm_types, 1, 2, 1, 0, &quot;eval_hermitenorm&quot;, ufunc_eval_hermitenorm_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_eval_jacobi_loops[5]</span>
<span class="s0">cdef void *ufunc_eval_jacobi_ptr[10]</span>
<span class="s0">cdef void *ufunc_eval_jacobi_data[5]</span>
<span class="s0">cdef char ufunc_eval_jacobi_types[25]</span>
<span class="s0">cdef char *ufunc_eval_jacobi_doc = (</span>
    <span class="s0">&quot;eval_jacobi(n, alpha, beta, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate Jacobi polynomial at a point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The Jacobi polynomials can be defined via the Gauss hypergeometric\n&quot;</span>
    <span class="s0">&quot;function :math:`{}_2F_1` as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    P_n^{(\\alpha, \\beta)}(x) = \\frac{(\\alpha + 1)_n}{\\Gamma(n + 1)}\n&quot;</span>
    <span class="s0">&quot;      {}_2F_1(-n, 1 + \\alpha + \\beta + n; \\alpha + 1; (1 - z)/2)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`(\\cdot)_n` is the Pochhammer symbol; see `poch`. When\n&quot;</span>
    <span class="s0">&quot;:math:`n` is an integer the result is a polynomial of degree\n&quot;</span>
    <span class="s0">&quot;:math:`n`. See 22.5.42 in [AS]_ for details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Degree of the polynomial. If not an integer the result is\n&quot;</span>
    <span class="s0">&quot;    determined via the relation to the Gauss hypergeometric\n&quot;</span>
    <span class="s0">&quot;    function.\n&quot;</span>
    <span class="s0">&quot;alpha : array_like\n&quot;</span>
    <span class="s0">&quot;    Parameter\n&quot;</span>
    <span class="s0">&quot;beta : array_like\n&quot;</span>
    <span class="s0">&quot;    Parameter\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Points at which to evaluate the polynomial\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;P : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Jacobi polynomial\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;roots_jacobi : roots and quadrature weights of Jacobi polynomials\n&quot;</span>
    <span class="s0">&quot;jacobi : Jacobi polynomial object\n&quot;</span>
    <span class="s0">&quot;hyp2f1 : Gauss hypergeometric function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;    Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;    Graphs, and Mathematical Tables. New York: Dover, 1972.&quot;)</span>
<span class="s0">ufunc_eval_jacobi_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_lddd__As_lddd_d</span>
<span class="s0">ufunc_eval_jacobi_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_ffff_f</span>
<span class="s0">ufunc_eval_jacobi_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dddD__As_fffF_F</span>
<span class="s0">ufunc_eval_jacobi_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_dddd_d</span>
<span class="s0">ufunc_eval_jacobi_loops[4] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dddD__As_dddD_D</span>
<span class="s0">ufunc_eval_jacobi_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc_eval_jacobi_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_jacobi_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_jacobi_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_jacobi_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_jacobi_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_jacobi_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_jacobi_types[7] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_jacobi_types[8] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_jacobi_types[9] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_jacobi_types[10] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_jacobi_types[11] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_jacobi_types[12] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_jacobi_types[13] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_jacobi_types[14] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_jacobi_types[15] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_jacobi_types[16] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_jacobi_types[17] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_jacobi_types[18] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_jacobi_types[19] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_jacobi_types[20] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_jacobi_types[21] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_jacobi_types[22] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_jacobi_types[23] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_jacobi_types[24] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_jacobi_ptr[2*0] = &lt;void*&gt;_func_eval_jacobi_l</span>
<span class="s0">ufunc_eval_jacobi_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_jacobi&quot;)</span>
<span class="s0">ufunc_eval_jacobi_ptr[2*1] = &lt;void*&gt;_func_eval_jacobi[double]</span>
<span class="s0">ufunc_eval_jacobi_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_jacobi&quot;)</span>
<span class="s0">ufunc_eval_jacobi_ptr[2*2] = &lt;void*&gt;_func_eval_jacobi[double_complex]</span>
<span class="s0">ufunc_eval_jacobi_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_jacobi&quot;)</span>
<span class="s0">ufunc_eval_jacobi_ptr[2*3] = &lt;void*&gt;_func_eval_jacobi[double]</span>
<span class="s0">ufunc_eval_jacobi_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_jacobi&quot;)</span>
<span class="s0">ufunc_eval_jacobi_ptr[2*4] = &lt;void*&gt;_func_eval_jacobi[double_complex]</span>
<span class="s0">ufunc_eval_jacobi_ptr[2*4+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_jacobi&quot;)</span>
<span class="s0">ufunc_eval_jacobi_data[0] = &amp;ufunc_eval_jacobi_ptr[2*0]</span>
<span class="s0">ufunc_eval_jacobi_data[1] = &amp;ufunc_eval_jacobi_ptr[2*1]</span>
<span class="s0">ufunc_eval_jacobi_data[2] = &amp;ufunc_eval_jacobi_ptr[2*2]</span>
<span class="s0">ufunc_eval_jacobi_data[3] = &amp;ufunc_eval_jacobi_ptr[2*3]</span>
<span class="s0">ufunc_eval_jacobi_data[4] = &amp;ufunc_eval_jacobi_ptr[2*4]</span>
<span class="s0">eval_jacobi = np.PyUFunc_FromFuncAndData(ufunc_eval_jacobi_loops, ufunc_eval_jacobi_data, ufunc_eval_jacobi_types, 5, 4, 1, 0, &quot;eval_jacobi&quot;, ufunc_eval_jacobi_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_eval_laguerre_loops[5]</span>
<span class="s0">cdef void *ufunc_eval_laguerre_ptr[10]</span>
<span class="s0">cdef void *ufunc_eval_laguerre_data[5]</span>
<span class="s0">cdef char ufunc_eval_laguerre_types[15]</span>
<span class="s0">cdef char *ufunc_eval_laguerre_doc = (</span>
    <span class="s0">&quot;eval_laguerre(n, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate Laguerre polynomial at a point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The Laguerre polynomials can be defined via the confluent\n&quot;</span>
    <span class="s0">&quot;hypergeometric function :math:`{}_1F_1` as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    L_n(x) = {}_1F_1(-n, 1, x).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See 22.5.16 and 22.5.54 in [AS]_ for details. When :math:`n` is an\n&quot;</span>
    <span class="s0">&quot;integer the result is a polynomial of degree :math:`n`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Degree of the polynomial. If not an integer the result is\n&quot;</span>
    <span class="s0">&quot;    determined via the relation to the confluent hypergeometric\n&quot;</span>
    <span class="s0">&quot;    function.\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Points at which to evaluate the Laguerre polynomial\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;L : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Laguerre polynomial\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;roots_laguerre : roots and quadrature weights of Laguerre\n&quot;</span>
    <span class="s0">&quot;                 polynomials\n&quot;</span>
    <span class="s0">&quot;laguerre : Laguerre polynomial object\n&quot;</span>
    <span class="s0">&quot;numpy.polynomial.laguerre.Laguerre : Laguerre series\n&quot;</span>
    <span class="s0">&quot;eval_genlaguerre : evaluate generalized Laguerre polynomials\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;    Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;    Graphs, and Mathematical Tables. New York: Dover, 1972.&quot;)</span>
<span class="s0">ufunc_eval_laguerre_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ld__As_ld_d</span>
<span class="s0">ufunc_eval_laguerre_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_eval_laguerre_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_fF_F</span>
<span class="s0">ufunc_eval_laguerre_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_eval_laguerre_loops[4] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_dD_D</span>
<span class="s0">ufunc_eval_laguerre_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc_eval_laguerre_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_laguerre_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_laguerre_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_laguerre_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_laguerre_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_laguerre_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_laguerre_types[7] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_laguerre_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_laguerre_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_laguerre_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_laguerre_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_laguerre_types[12] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_laguerre_types[13] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_laguerre_types[14] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_laguerre_ptr[2*0] = &lt;void*&gt;_func_eval_laguerre_l</span>
<span class="s0">ufunc_eval_laguerre_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_laguerre&quot;)</span>
<span class="s0">ufunc_eval_laguerre_ptr[2*1] = &lt;void*&gt;_func_eval_laguerre[double]</span>
<span class="s0">ufunc_eval_laguerre_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_laguerre&quot;)</span>
<span class="s0">ufunc_eval_laguerre_ptr[2*2] = &lt;void*&gt;_func_eval_laguerre[double_complex]</span>
<span class="s0">ufunc_eval_laguerre_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_laguerre&quot;)</span>
<span class="s0">ufunc_eval_laguerre_ptr[2*3] = &lt;void*&gt;_func_eval_laguerre[double]</span>
<span class="s0">ufunc_eval_laguerre_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_laguerre&quot;)</span>
<span class="s0">ufunc_eval_laguerre_ptr[2*4] = &lt;void*&gt;_func_eval_laguerre[double_complex]</span>
<span class="s0">ufunc_eval_laguerre_ptr[2*4+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_laguerre&quot;)</span>
<span class="s0">ufunc_eval_laguerre_data[0] = &amp;ufunc_eval_laguerre_ptr[2*0]</span>
<span class="s0">ufunc_eval_laguerre_data[1] = &amp;ufunc_eval_laguerre_ptr[2*1]</span>
<span class="s0">ufunc_eval_laguerre_data[2] = &amp;ufunc_eval_laguerre_ptr[2*2]</span>
<span class="s0">ufunc_eval_laguerre_data[3] = &amp;ufunc_eval_laguerre_ptr[2*3]</span>
<span class="s0">ufunc_eval_laguerre_data[4] = &amp;ufunc_eval_laguerre_ptr[2*4]</span>
<span class="s0">eval_laguerre = np.PyUFunc_FromFuncAndData(ufunc_eval_laguerre_loops, ufunc_eval_laguerre_data, ufunc_eval_laguerre_types, 5, 2, 1, 0, &quot;eval_laguerre&quot;, ufunc_eval_laguerre_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_eval_legendre_loops[5]</span>
<span class="s0">cdef void *ufunc_eval_legendre_ptr[10]</span>
<span class="s0">cdef void *ufunc_eval_legendre_data[5]</span>
<span class="s0">cdef char ufunc_eval_legendre_types[15]</span>
<span class="s0">cdef char *ufunc_eval_legendre_doc = (</span>
    <span class="s0">&quot;eval_legendre(n, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate Legendre polynomial at a point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The Legendre polynomials can be defined via the Gauss\n&quot;</span>
    <span class="s0">&quot;hypergeometric function :math:`{}_2F_1` as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    P_n(x) = {}_2F_1(-n, n + 1; 1; (1 - x)/2).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;When :math:`n` is an integer the result is a polynomial of degree\n&quot;</span>
    <span class="s0">&quot;:math:`n`. See 22.5.49 in [AS]_ for details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Degree of the polynomial. If not an integer, the result is\n&quot;</span>
    <span class="s0">&quot;    determined via the relation to the Gauss hypergeometric\n&quot;</span>
    <span class="s0">&quot;    function.\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Points at which to evaluate the Legendre polynomial\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;P : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Legendre polynomial\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;roots_legendre : roots and quadrature weights of Legendre\n&quot;</span>
    <span class="s0">&quot;                 polynomials\n&quot;</span>
    <span class="s0">&quot;legendre : Legendre polynomial object\n&quot;</span>
    <span class="s0">&quot;hyp2f1 : Gauss hypergeometric function\n&quot;</span>
    <span class="s0">&quot;numpy.polynomial.legendre.Legendre : Legendre series\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;    Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;    Graphs, and Mathematical Tables. New York: Dover, 1972.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import eval_legendre\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate the zero-order Legendre polynomial at x = 0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; eval_legendre(0, 0)\n&quot;</span>
    <span class="s0">&quot;1.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate the first-order Legendre polynomial between -1 and 1\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; X = np.linspace(-1, 1, 5)  # Domain of Legendre polynomials\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; eval_legendre(1, X)\n&quot;</span>
    <span class="s0">&quot;array([-1. , -0.5,  0. ,  0.5,  1. ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate Legendre polynomials of order 0 through 4 at x = 0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; N = range(0, 5)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; eval_legendre(N, 0)\n&quot;</span>
    <span class="s0">&quot;array([ 1.   ,  0.   , -0.5  ,  0.   ,  0.375])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot Legendre polynomials of order 0 through 4\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; X = np.linspace(-1, 1)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for n in range(0, 5):\n&quot;</span>
    <span class="s0">&quot;...     y = eval_legendre(n, X)\n&quot;</span>
    <span class="s0">&quot;...     plt.plot(X, y, label=r'$P_{}(x)$'.format(n))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.title(\&quot;Legendre Polynomials\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.xlabel(\&quot;x\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.ylabel(r'$P_n(x)$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.legend(loc='lower right')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_eval_legendre_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ld__As_ld_d</span>
<span class="s0">ufunc_eval_legendre_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_eval_legendre_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_fF_F</span>
<span class="s0">ufunc_eval_legendre_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_eval_legendre_loops[4] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_dD_D</span>
<span class="s0">ufunc_eval_legendre_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc_eval_legendre_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_legendre_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_legendre_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_legendre_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_legendre_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_legendre_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_legendre_types[7] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_legendre_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_legendre_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_legendre_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_legendre_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_legendre_types[12] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_legendre_types[13] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_legendre_types[14] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_legendre_ptr[2*0] = &lt;void*&gt;_func_eval_legendre_l</span>
<span class="s0">ufunc_eval_legendre_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_legendre&quot;)</span>
<span class="s0">ufunc_eval_legendre_ptr[2*1] = &lt;void*&gt;_func_eval_legendre[double]</span>
<span class="s0">ufunc_eval_legendre_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_legendre&quot;)</span>
<span class="s0">ufunc_eval_legendre_ptr[2*2] = &lt;void*&gt;_func_eval_legendre[double_complex]</span>
<span class="s0">ufunc_eval_legendre_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_legendre&quot;)</span>
<span class="s0">ufunc_eval_legendre_ptr[2*3] = &lt;void*&gt;_func_eval_legendre[double]</span>
<span class="s0">ufunc_eval_legendre_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_legendre&quot;)</span>
<span class="s0">ufunc_eval_legendre_ptr[2*4] = &lt;void*&gt;_func_eval_legendre[double_complex]</span>
<span class="s0">ufunc_eval_legendre_ptr[2*4+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_legendre&quot;)</span>
<span class="s0">ufunc_eval_legendre_data[0] = &amp;ufunc_eval_legendre_ptr[2*0]</span>
<span class="s0">ufunc_eval_legendre_data[1] = &amp;ufunc_eval_legendre_ptr[2*1]</span>
<span class="s0">ufunc_eval_legendre_data[2] = &amp;ufunc_eval_legendre_ptr[2*2]</span>
<span class="s0">ufunc_eval_legendre_data[3] = &amp;ufunc_eval_legendre_ptr[2*3]</span>
<span class="s0">ufunc_eval_legendre_data[4] = &amp;ufunc_eval_legendre_ptr[2*4]</span>
<span class="s0">eval_legendre = np.PyUFunc_FromFuncAndData(ufunc_eval_legendre_loops, ufunc_eval_legendre_data, ufunc_eval_legendre_types, 5, 2, 1, 0, &quot;eval_legendre&quot;, ufunc_eval_legendre_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_eval_sh_chebyt_loops[5]</span>
<span class="s0">cdef void *ufunc_eval_sh_chebyt_ptr[10]</span>
<span class="s0">cdef void *ufunc_eval_sh_chebyt_data[5]</span>
<span class="s0">cdef char ufunc_eval_sh_chebyt_types[15]</span>
<span class="s0">cdef char *ufunc_eval_sh_chebyt_doc = (</span>
    <span class="s0">&quot;eval_sh_chebyt(n, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate shifted Chebyshev polynomial of the first kind at a\n&quot;</span>
    <span class="s0">&quot;point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;These polynomials are defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    T_n^*(x) = T_n(2x - 1)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`T_n` is a Chebyshev polynomial of the first kind. See\n&quot;</span>
    <span class="s0">&quot;22.5.14 in [AS]_ for details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Degree of the polynomial. If not an integer, the result is\n&quot;</span>
    <span class="s0">&quot;    determined via the relation to `eval_chebyt`.\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Points at which to evaluate the shifted Chebyshev polynomial\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;T : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the shifted Chebyshev polynomial\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;roots_sh_chebyt : roots and quadrature weights of shifted\n&quot;</span>
    <span class="s0">&quot;                  Chebyshev polynomials of the first kind\n&quot;</span>
    <span class="s0">&quot;sh_chebyt : shifted Chebyshev polynomial object\n&quot;</span>
    <span class="s0">&quot;eval_chebyt : evaluate Chebyshev polynomials of the first kind\n&quot;</span>
    <span class="s0">&quot;numpy.polynomial.chebyshev.Chebyshev : Chebyshev series\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;    Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;    Graphs, and Mathematical Tables. New York: Dover, 1972.&quot;)</span>
<span class="s0">ufunc_eval_sh_chebyt_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ld__As_ld_d</span>
<span class="s0">ufunc_eval_sh_chebyt_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_eval_sh_chebyt_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_fF_F</span>
<span class="s0">ufunc_eval_sh_chebyt_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_eval_sh_chebyt_loops[4] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_dD_D</span>
<span class="s0">ufunc_eval_sh_chebyt_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc_eval_sh_chebyt_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_chebyt_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_chebyt_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_chebyt_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_chebyt_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_chebyt_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_chebyt_types[7] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_sh_chebyt_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_sh_chebyt_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_chebyt_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_chebyt_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_chebyt_types[12] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_chebyt_types[13] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_sh_chebyt_types[14] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_sh_chebyt_ptr[2*0] = &lt;void*&gt;_func_eval_sh_chebyt_l</span>
<span class="s0">ufunc_eval_sh_chebyt_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_chebyt&quot;)</span>
<span class="s0">ufunc_eval_sh_chebyt_ptr[2*1] = &lt;void*&gt;_func_eval_sh_chebyt[double]</span>
<span class="s0">ufunc_eval_sh_chebyt_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_chebyt&quot;)</span>
<span class="s0">ufunc_eval_sh_chebyt_ptr[2*2] = &lt;void*&gt;_func_eval_sh_chebyt[double_complex]</span>
<span class="s0">ufunc_eval_sh_chebyt_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_chebyt&quot;)</span>
<span class="s0">ufunc_eval_sh_chebyt_ptr[2*3] = &lt;void*&gt;_func_eval_sh_chebyt[double]</span>
<span class="s0">ufunc_eval_sh_chebyt_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_chebyt&quot;)</span>
<span class="s0">ufunc_eval_sh_chebyt_ptr[2*4] = &lt;void*&gt;_func_eval_sh_chebyt[double_complex]</span>
<span class="s0">ufunc_eval_sh_chebyt_ptr[2*4+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_chebyt&quot;)</span>
<span class="s0">ufunc_eval_sh_chebyt_data[0] = &amp;ufunc_eval_sh_chebyt_ptr[2*0]</span>
<span class="s0">ufunc_eval_sh_chebyt_data[1] = &amp;ufunc_eval_sh_chebyt_ptr[2*1]</span>
<span class="s0">ufunc_eval_sh_chebyt_data[2] = &amp;ufunc_eval_sh_chebyt_ptr[2*2]</span>
<span class="s0">ufunc_eval_sh_chebyt_data[3] = &amp;ufunc_eval_sh_chebyt_ptr[2*3]</span>
<span class="s0">ufunc_eval_sh_chebyt_data[4] = &amp;ufunc_eval_sh_chebyt_ptr[2*4]</span>
<span class="s0">eval_sh_chebyt = np.PyUFunc_FromFuncAndData(ufunc_eval_sh_chebyt_loops, ufunc_eval_sh_chebyt_data, ufunc_eval_sh_chebyt_types, 5, 2, 1, 0, &quot;eval_sh_chebyt&quot;, ufunc_eval_sh_chebyt_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_eval_sh_chebyu_loops[5]</span>
<span class="s0">cdef void *ufunc_eval_sh_chebyu_ptr[10]</span>
<span class="s0">cdef void *ufunc_eval_sh_chebyu_data[5]</span>
<span class="s0">cdef char ufunc_eval_sh_chebyu_types[15]</span>
<span class="s0">cdef char *ufunc_eval_sh_chebyu_doc = (</span>
    <span class="s0">&quot;eval_sh_chebyu(n, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate shifted Chebyshev polynomial of the second kind at a\n&quot;</span>
    <span class="s0">&quot;point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;These polynomials are defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    U_n^*(x) = U_n(2x - 1)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`U_n` is a Chebyshev polynomial of the first kind. See\n&quot;</span>
    <span class="s0">&quot;22.5.15 in [AS]_ for details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Degree of the polynomial. If not an integer, the result is\n&quot;</span>
    <span class="s0">&quot;    determined via the relation to `eval_chebyu`.\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Points at which to evaluate the shifted Chebyshev polynomial\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;U : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the shifted Chebyshev polynomial\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;roots_sh_chebyu : roots and quadrature weights of shifted\n&quot;</span>
    <span class="s0">&quot;                  Chebychev polynomials of the second kind\n&quot;</span>
    <span class="s0">&quot;sh_chebyu : shifted Chebyshev polynomial object\n&quot;</span>
    <span class="s0">&quot;eval_chebyu : evaluate Chebyshev polynomials of the second kind\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;    Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;    Graphs, and Mathematical Tables. New York: Dover, 1972.&quot;)</span>
<span class="s0">ufunc_eval_sh_chebyu_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ld__As_ld_d</span>
<span class="s0">ufunc_eval_sh_chebyu_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_eval_sh_chebyu_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_fF_F</span>
<span class="s0">ufunc_eval_sh_chebyu_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_eval_sh_chebyu_loops[4] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_dD_D</span>
<span class="s0">ufunc_eval_sh_chebyu_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc_eval_sh_chebyu_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_chebyu_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_chebyu_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_chebyu_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_chebyu_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_chebyu_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_chebyu_types[7] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_sh_chebyu_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_sh_chebyu_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_chebyu_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_chebyu_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_chebyu_types[12] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_chebyu_types[13] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_sh_chebyu_types[14] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_sh_chebyu_ptr[2*0] = &lt;void*&gt;_func_eval_sh_chebyu_l</span>
<span class="s0">ufunc_eval_sh_chebyu_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_chebyu&quot;)</span>
<span class="s0">ufunc_eval_sh_chebyu_ptr[2*1] = &lt;void*&gt;_func_eval_sh_chebyu[double]</span>
<span class="s0">ufunc_eval_sh_chebyu_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_chebyu&quot;)</span>
<span class="s0">ufunc_eval_sh_chebyu_ptr[2*2] = &lt;void*&gt;_func_eval_sh_chebyu[double_complex]</span>
<span class="s0">ufunc_eval_sh_chebyu_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_chebyu&quot;)</span>
<span class="s0">ufunc_eval_sh_chebyu_ptr[2*3] = &lt;void*&gt;_func_eval_sh_chebyu[double]</span>
<span class="s0">ufunc_eval_sh_chebyu_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_chebyu&quot;)</span>
<span class="s0">ufunc_eval_sh_chebyu_ptr[2*4] = &lt;void*&gt;_func_eval_sh_chebyu[double_complex]</span>
<span class="s0">ufunc_eval_sh_chebyu_ptr[2*4+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_chebyu&quot;)</span>
<span class="s0">ufunc_eval_sh_chebyu_data[0] = &amp;ufunc_eval_sh_chebyu_ptr[2*0]</span>
<span class="s0">ufunc_eval_sh_chebyu_data[1] = &amp;ufunc_eval_sh_chebyu_ptr[2*1]</span>
<span class="s0">ufunc_eval_sh_chebyu_data[2] = &amp;ufunc_eval_sh_chebyu_ptr[2*2]</span>
<span class="s0">ufunc_eval_sh_chebyu_data[3] = &amp;ufunc_eval_sh_chebyu_ptr[2*3]</span>
<span class="s0">ufunc_eval_sh_chebyu_data[4] = &amp;ufunc_eval_sh_chebyu_ptr[2*4]</span>
<span class="s0">eval_sh_chebyu = np.PyUFunc_FromFuncAndData(ufunc_eval_sh_chebyu_loops, ufunc_eval_sh_chebyu_data, ufunc_eval_sh_chebyu_types, 5, 2, 1, 0, &quot;eval_sh_chebyu&quot;, ufunc_eval_sh_chebyu_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_eval_sh_jacobi_loops[5]</span>
<span class="s0">cdef void *ufunc_eval_sh_jacobi_ptr[10]</span>
<span class="s0">cdef void *ufunc_eval_sh_jacobi_data[5]</span>
<span class="s0">cdef char ufunc_eval_sh_jacobi_types[25]</span>
<span class="s0">cdef char *ufunc_eval_sh_jacobi_doc = (</span>
    <span class="s0">&quot;eval_sh_jacobi(n, p, q, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate shifted Jacobi polynomial at a point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined by\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    G_n^{(p, q)}(x)\n&quot;</span>
    <span class="s0">&quot;      = \\binom{2n + p - 1}{n}^{-1} P_n^{(p - q, q - 1)}(2x - 1),\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`P_n^{(\\cdot, \\cdot)}` is the n-th Jacobi\n&quot;</span>
    <span class="s0">&quot;polynomial. See 22.5.2 in [AS]_ for details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : int\n&quot;</span>
    <span class="s0">&quot;    Degree of the polynomial. If not an integer, the result is\n&quot;</span>
    <span class="s0">&quot;    determined via the relation to `binom` and `eval_jacobi`.\n&quot;</span>
    <span class="s0">&quot;p : float\n&quot;</span>
    <span class="s0">&quot;    Parameter\n&quot;</span>
    <span class="s0">&quot;q : float\n&quot;</span>
    <span class="s0">&quot;    Parameter\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;G : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the shifted Jacobi polynomial.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;roots_sh_jacobi : roots and quadrature weights of shifted Jacobi\n&quot;</span>
    <span class="s0">&quot;                  polynomials\n&quot;</span>
    <span class="s0">&quot;sh_jacobi : shifted Jacobi polynomial object\n&quot;</span>
    <span class="s0">&quot;eval_jacobi : evaluate Jacobi polynomials\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;    Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;    Graphs, and Mathematical Tables. New York: Dover, 1972.&quot;)</span>
<span class="s0">ufunc_eval_sh_jacobi_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_lddd__As_lddd_d</span>
<span class="s0">ufunc_eval_sh_jacobi_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_ffff_f</span>
<span class="s0">ufunc_eval_sh_jacobi_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dddD__As_fffF_F</span>
<span class="s0">ufunc_eval_sh_jacobi_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_dddd_d</span>
<span class="s0">ufunc_eval_sh_jacobi_loops[4] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dddD__As_dddD_D</span>
<span class="s0">ufunc_eval_sh_jacobi_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc_eval_sh_jacobi_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_jacobi_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_jacobi_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_jacobi_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_jacobi_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_jacobi_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_jacobi_types[7] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_jacobi_types[8] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_jacobi_types[9] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_jacobi_types[10] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_jacobi_types[11] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_jacobi_types[12] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_jacobi_types[13] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_sh_jacobi_types[14] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_sh_jacobi_types[15] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_jacobi_types[16] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_jacobi_types[17] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_jacobi_types[18] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_jacobi_types[19] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_jacobi_types[20] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_jacobi_types[21] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_jacobi_types[22] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_jacobi_types[23] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_sh_jacobi_types[24] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_sh_jacobi_ptr[2*0] = &lt;void*&gt;_func_eval_sh_jacobi_l</span>
<span class="s0">ufunc_eval_sh_jacobi_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_jacobi&quot;)</span>
<span class="s0">ufunc_eval_sh_jacobi_ptr[2*1] = &lt;void*&gt;_func_eval_sh_jacobi[double]</span>
<span class="s0">ufunc_eval_sh_jacobi_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_jacobi&quot;)</span>
<span class="s0">ufunc_eval_sh_jacobi_ptr[2*2] = &lt;void*&gt;_func_eval_sh_jacobi[double_complex]</span>
<span class="s0">ufunc_eval_sh_jacobi_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_jacobi&quot;)</span>
<span class="s0">ufunc_eval_sh_jacobi_ptr[2*3] = &lt;void*&gt;_func_eval_sh_jacobi[double]</span>
<span class="s0">ufunc_eval_sh_jacobi_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_jacobi&quot;)</span>
<span class="s0">ufunc_eval_sh_jacobi_ptr[2*4] = &lt;void*&gt;_func_eval_sh_jacobi[double_complex]</span>
<span class="s0">ufunc_eval_sh_jacobi_ptr[2*4+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_jacobi&quot;)</span>
<span class="s0">ufunc_eval_sh_jacobi_data[0] = &amp;ufunc_eval_sh_jacobi_ptr[2*0]</span>
<span class="s0">ufunc_eval_sh_jacobi_data[1] = &amp;ufunc_eval_sh_jacobi_ptr[2*1]</span>
<span class="s0">ufunc_eval_sh_jacobi_data[2] = &amp;ufunc_eval_sh_jacobi_ptr[2*2]</span>
<span class="s0">ufunc_eval_sh_jacobi_data[3] = &amp;ufunc_eval_sh_jacobi_ptr[2*3]</span>
<span class="s0">ufunc_eval_sh_jacobi_data[4] = &amp;ufunc_eval_sh_jacobi_ptr[2*4]</span>
<span class="s0">eval_sh_jacobi = np.PyUFunc_FromFuncAndData(ufunc_eval_sh_jacobi_loops, ufunc_eval_sh_jacobi_data, ufunc_eval_sh_jacobi_types, 5, 4, 1, 0, &quot;eval_sh_jacobi&quot;, ufunc_eval_sh_jacobi_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_eval_sh_legendre_loops[5]</span>
<span class="s0">cdef void *ufunc_eval_sh_legendre_ptr[10]</span>
<span class="s0">cdef void *ufunc_eval_sh_legendre_data[5]</span>
<span class="s0">cdef char ufunc_eval_sh_legendre_types[15]</span>
<span class="s0">cdef char *ufunc_eval_sh_legendre_doc = (</span>
    <span class="s0">&quot;eval_sh_legendre(n, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate shifted Legendre polynomial at a point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;These polynomials are defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    P_n^*(x) = P_n(2x - 1)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`P_n` is a Legendre polynomial. See 2.2.11 in [AS]_\n&quot;</span>
    <span class="s0">&quot;for details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Degree of the polynomial. If not an integer, the value is\n&quot;</span>
    <span class="s0">&quot;    determined via the relation to `eval_legendre`.\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Points at which to evaluate the shifted Legendre polynomial\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;P : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the shifted Legendre polynomial\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;roots_sh_legendre : roots and quadrature weights of shifted\n&quot;</span>
    <span class="s0">&quot;                    Legendre polynomials\n&quot;</span>
    <span class="s0">&quot;sh_legendre : shifted Legendre polynomial object\n&quot;</span>
    <span class="s0">&quot;eval_legendre : evaluate Legendre polynomials\n&quot;</span>
    <span class="s0">&quot;numpy.polynomial.legendre.Legendre : Legendre series\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;    Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;    Graphs, and Mathematical Tables. New York: Dover, 1972.&quot;)</span>
<span class="s0">ufunc_eval_sh_legendre_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ld__As_ld_d</span>
<span class="s0">ufunc_eval_sh_legendre_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_eval_sh_legendre_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_fF_F</span>
<span class="s0">ufunc_eval_sh_legendre_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_eval_sh_legendre_loops[4] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_dD_D</span>
<span class="s0">ufunc_eval_sh_legendre_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc_eval_sh_legendre_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_legendre_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_legendre_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_legendre_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_legendre_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_legendre_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_eval_sh_legendre_types[7] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_sh_legendre_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_eval_sh_legendre_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_legendre_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_legendre_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_legendre_types[12] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_eval_sh_legendre_types[13] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_sh_legendre_types[14] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_eval_sh_legendre_ptr[2*0] = &lt;void*&gt;_func_eval_sh_legendre_l</span>
<span class="s0">ufunc_eval_sh_legendre_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_legendre&quot;)</span>
<span class="s0">ufunc_eval_sh_legendre_ptr[2*1] = &lt;void*&gt;_func_eval_sh_legendre[double]</span>
<span class="s0">ufunc_eval_sh_legendre_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_legendre&quot;)</span>
<span class="s0">ufunc_eval_sh_legendre_ptr[2*2] = &lt;void*&gt;_func_eval_sh_legendre[double_complex]</span>
<span class="s0">ufunc_eval_sh_legendre_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_legendre&quot;)</span>
<span class="s0">ufunc_eval_sh_legendre_ptr[2*3] = &lt;void*&gt;_func_eval_sh_legendre[double]</span>
<span class="s0">ufunc_eval_sh_legendre_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_legendre&quot;)</span>
<span class="s0">ufunc_eval_sh_legendre_ptr[2*4] = &lt;void*&gt;_func_eval_sh_legendre[double_complex]</span>
<span class="s0">ufunc_eval_sh_legendre_ptr[2*4+1] = &lt;void*&gt;(&lt;char*&gt;&quot;eval_sh_legendre&quot;)</span>
<span class="s0">ufunc_eval_sh_legendre_data[0] = &amp;ufunc_eval_sh_legendre_ptr[2*0]</span>
<span class="s0">ufunc_eval_sh_legendre_data[1] = &amp;ufunc_eval_sh_legendre_ptr[2*1]</span>
<span class="s0">ufunc_eval_sh_legendre_data[2] = &amp;ufunc_eval_sh_legendre_ptr[2*2]</span>
<span class="s0">ufunc_eval_sh_legendre_data[3] = &amp;ufunc_eval_sh_legendre_ptr[2*3]</span>
<span class="s0">ufunc_eval_sh_legendre_data[4] = &amp;ufunc_eval_sh_legendre_ptr[2*4]</span>
<span class="s0">eval_sh_legendre = np.PyUFunc_FromFuncAndData(ufunc_eval_sh_legendre_loops, ufunc_eval_sh_legendre_data, ufunc_eval_sh_legendre_types, 5, 2, 1, 0, &quot;eval_sh_legendre&quot;, ufunc_eval_sh_legendre_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_exp1_loops[4]</span>
<span class="s0">cdef void *ufunc_exp1_ptr[8]</span>
<span class="s0">cdef void *ufunc_exp1_data[4]</span>
<span class="s0">cdef char ufunc_exp1_types[8]</span>
<span class="s0">cdef char *ufunc_exp1_doc = (</span>
    <span class="s0">&quot;exp1(z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Exponential integral E1.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For complex :math:`z \\ne 0` the exponential integral can be defined as\n&quot;</span>
    <span class="s0">&quot;[1]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;   E_1(z) = \\int_z^\\infty \\frac{e^{-t}}{t} dt,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where the path of the integral does not cross the negative real\n&quot;</span>
    <span class="s0">&quot;axis or pass through the origin.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;z: array_like\n&quot;</span>
    <span class="s0">&quot;    Real or complex argument.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the exponential integral E1\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;expi : exponential integral :math:`Ei`\n&quot;</span>
    <span class="s0">&quot;expn : generalization of :math:`E_1`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;For :math:`x &gt; 0` it is related to the exponential integral\n&quot;</span>
    <span class="s0">&quot;:math:`Ei` (see `expi`) via the relation\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;   E_1(x) = -Ei(-x).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Digital Library of Mathematical Functions, 6.2.1\n&quot;</span>
    <span class="s0">&quot;       https://dlmf.nist.gov/6.2#E1\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It has a pole at 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.exp1(0)\n&quot;</span>
    <span class="s0">&quot;inf\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It has a branch cut on the negative real axis.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.exp1(-1)\n&quot;</span>
    <span class="s0">&quot;nan\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.exp1(complex(-1, 0))\n&quot;</span>
    <span class="s0">&quot;(-1.8951178163559368-3.141592653589793j)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.exp1(complex(-1, -0.0))\n&quot;</span>
    <span class="s0">&quot;(-1.8951178163559368+3.141592653589793j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It approaches 0 along the positive real axis.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.exp1([1, 10, 100, 1000])\n&quot;</span>
    <span class="s0">&quot;array([2.19383934e-01, 4.15696893e-06, 3.68359776e-46, 0.00000000e+00])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is related to `expi`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.array([1, 2, 3, 4])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.exp1(x)\n&quot;</span>
    <span class="s0">&quot;array([0.21938393, 0.04890051, 0.01304838, 0.00377935])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; -sc.expi(-x)\n&quot;</span>
    <span class="s0">&quot;array([0.21938393, 0.04890051, 0.01304838, 0.00377935])&quot;)</span>
<span class="s0">ufunc_exp1_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_exp1_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_exp1_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_F_F</span>
<span class="s0">ufunc_exp1_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_D_D</span>
<span class="s0">ufunc_exp1_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_exp1_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_exp1_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_exp1_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_exp1_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_exp1_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_exp1_types[6] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_exp1_types[7] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_exp1_ptr[2*0] = &lt;void*&gt;_func_exp1_wrap</span>
<span class="s0">ufunc_exp1_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;exp1&quot;)</span>
<span class="s0">ufunc_exp1_ptr[2*1] = &lt;void*&gt;_func_exp1_wrap</span>
<span class="s0">ufunc_exp1_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;exp1&quot;)</span>
<span class="s0">ufunc_exp1_ptr[2*2] = &lt;void*&gt;_func_cexp1_wrap</span>
<span class="s0">ufunc_exp1_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;exp1&quot;)</span>
<span class="s0">ufunc_exp1_ptr[2*3] = &lt;void*&gt;_func_cexp1_wrap</span>
<span class="s0">ufunc_exp1_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;exp1&quot;)</span>
<span class="s0">ufunc_exp1_data[0] = &amp;ufunc_exp1_ptr[2*0]</span>
<span class="s0">ufunc_exp1_data[1] = &amp;ufunc_exp1_ptr[2*1]</span>
<span class="s0">ufunc_exp1_data[2] = &amp;ufunc_exp1_ptr[2*2]</span>
<span class="s0">ufunc_exp1_data[3] = &amp;ufunc_exp1_ptr[2*3]</span>
<span class="s0">exp1 = np.PyUFunc_FromFuncAndData(ufunc_exp1_loops, ufunc_exp1_data, ufunc_exp1_types, 4, 1, 1, 0, &quot;exp1&quot;, ufunc_exp1_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_exp10_loops[2]</span>
<span class="s0">cdef void *ufunc_exp10_ptr[4]</span>
<span class="s0">cdef void *ufunc_exp10_data[2]</span>
<span class="s0">cdef char ufunc_exp10_types[4]</span>
<span class="s0">cdef char *ufunc_exp10_doc = (</span>
    <span class="s0">&quot;exp10(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute ``10**x`` element-wise.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    `x` must contain real numbers.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    ``10**x``, computed element-wise.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import exp10\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; exp10(3)\n&quot;</span>
    <span class="s0">&quot;1000.0\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.array([[-1, -0.5, 0], [0.5, 1, 1.5]])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; exp10(x)\n&quot;</span>
    <span class="s0">&quot;array([[  0.1       ,   0.31622777,   1.        ],\n&quot;</span>
    <span class="s0">&quot;       [  3.16227766,  10.        ,  31.6227766 ]])&quot;)</span>
<span class="s0">ufunc_exp10_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_exp10_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_exp10_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_exp10_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_exp10_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_exp10_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_exp10_ptr[2*0] = &lt;void*&gt;_func_exp10</span>
<span class="s0">ufunc_exp10_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;exp10&quot;)</span>
<span class="s0">ufunc_exp10_ptr[2*1] = &lt;void*&gt;_func_exp10</span>
<span class="s0">ufunc_exp10_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;exp10&quot;)</span>
<span class="s0">ufunc_exp10_data[0] = &amp;ufunc_exp10_ptr[2*0]</span>
<span class="s0">ufunc_exp10_data[1] = &amp;ufunc_exp10_ptr[2*1]</span>
<span class="s0">exp10 = np.PyUFunc_FromFuncAndData(ufunc_exp10_loops, ufunc_exp10_data, ufunc_exp10_types, 2, 1, 1, 0, &quot;exp10&quot;, ufunc_exp10_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_exp2_loops[2]</span>
<span class="s0">cdef void *ufunc_exp2_ptr[4]</span>
<span class="s0">cdef void *ufunc_exp2_data[2]</span>
<span class="s0">cdef char ufunc_exp2_types[4]</span>
<span class="s0">cdef char *ufunc_exp2_doc = (</span>
    <span class="s0">&quot;exp2(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute ``2**x`` element-wise.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    `x` must contain real numbers.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    ``2**x``, computed element-wise.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import exp2\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; exp2(3)\n&quot;</span>
    <span class="s0">&quot;8.0\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.array([[-1, -0.5, 0], [0.5, 1, 1.5]])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; exp2(x)\n&quot;</span>
    <span class="s0">&quot;array([[ 0.5       ,  0.70710678,  1.        ],\n&quot;</span>
    <span class="s0">&quot;       [ 1.41421356,  2.        ,  2.82842712]])&quot;)</span>
<span class="s0">ufunc_exp2_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_exp2_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_exp2_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_exp2_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_exp2_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_exp2_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_exp2_ptr[2*0] = &lt;void*&gt;_func_exp2</span>
<span class="s0">ufunc_exp2_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;exp2&quot;)</span>
<span class="s0">ufunc_exp2_ptr[2*1] = &lt;void*&gt;_func_exp2</span>
<span class="s0">ufunc_exp2_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;exp2&quot;)</span>
<span class="s0">ufunc_exp2_data[0] = &amp;ufunc_exp2_ptr[2*0]</span>
<span class="s0">ufunc_exp2_data[1] = &amp;ufunc_exp2_ptr[2*1]</span>
<span class="s0">exp2 = np.PyUFunc_FromFuncAndData(ufunc_exp2_loops, ufunc_exp2_data, ufunc_exp2_types, 2, 1, 1, 0, &quot;exp2&quot;, ufunc_exp2_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_expi_loops[4]</span>
<span class="s0">cdef void *ufunc_expi_ptr[8]</span>
<span class="s0">cdef void *ufunc_expi_data[4]</span>
<span class="s0">cdef char ufunc_expi_types[8]</span>
<span class="s0">cdef char *ufunc_expi_doc = (</span>
    <span class="s0">&quot;expi(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Exponential integral Ei.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For real :math:`x`, the exponential integral is defined as [1]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    Ei(x) = \\int_{-\\infty}^x \\frac{e^t}{t} dt.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For :math:`x &gt; 0` the integral is understood as a Cauchy principal\n&quot;</span>
    <span class="s0">&quot;value.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is extended to the complex plane by analytic continuation of\n&quot;</span>
    <span class="s0">&quot;the function on the interval :math:`(0, \\infty)`. The complex\n&quot;</span>
    <span class="s0">&quot;variant has a branch cut on the negative real axis.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real or complex valued argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the exponential integral\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The exponential integrals :math:`E_1` and :math:`Ei` satisfy the\n&quot;</span>
    <span class="s0">&quot;relation\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    E_1(x) = -Ei(-x)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;for :math:`x &gt; 0`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;exp1 : Exponential integral :math:`E_1`\n&quot;</span>
    <span class="s0">&quot;expn : Generalized exponential integral :math:`E_n`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Digital Library of Mathematical Functions, 6.2.5\n&quot;</span>
    <span class="s0">&quot;       https://dlmf.nist.gov/6.2#E5\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is related to `exp1`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.array([1, 2, 3, 4])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; -sc.expi(-x)\n&quot;</span>
    <span class="s0">&quot;array([0.21938393, 0.04890051, 0.01304838, 0.00377935])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.exp1(x)\n&quot;</span>
    <span class="s0">&quot;array([0.21938393, 0.04890051, 0.01304838, 0.00377935])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The complex variant has a branch cut on the negative real axis.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.expi(-1 + 1e-12j)\n&quot;</span>
    <span class="s0">&quot;(-0.21938393439552062+3.1415926535894254j)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.expi(-1 - 1e-12j)\n&quot;</span>
    <span class="s0">&quot;(-0.21938393439552062-3.1415926535894254j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;As the complex variant approaches the branch cut, the real parts\n&quot;</span>
    <span class="s0">&quot;approach the value of the real variant.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.expi(-1)\n&quot;</span>
    <span class="s0">&quot;-0.21938393439552062\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The SciPy implementation returns the real variant for complex\n&quot;</span>
    <span class="s0">&quot;values on the branch cut.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.expi(complex(-1, 0.0))\n&quot;</span>
    <span class="s0">&quot;(-0.21938393439552062-0j)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.expi(complex(-1, -0.0))\n&quot;</span>
    <span class="s0">&quot;(-0.21938393439552062-0j)&quot;)</span>
<span class="s0">ufunc_expi_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_expi_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_expi_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_F_F</span>
<span class="s0">ufunc_expi_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_D_D</span>
<span class="s0">ufunc_expi_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_expi_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_expi_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_expi_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_expi_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_expi_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_expi_types[6] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_expi_types[7] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_expi_ptr[2*0] = &lt;void*&gt;_func_expi_wrap</span>
<span class="s0">ufunc_expi_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;expi&quot;)</span>
<span class="s0">ufunc_expi_ptr[2*1] = &lt;void*&gt;_func_expi_wrap</span>
<span class="s0">ufunc_expi_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;expi&quot;)</span>
<span class="s0">ufunc_expi_ptr[2*2] = &lt;void*&gt;_func_cexpi_wrap</span>
<span class="s0">ufunc_expi_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;expi&quot;)</span>
<span class="s0">ufunc_expi_ptr[2*3] = &lt;void*&gt;_func_cexpi_wrap</span>
<span class="s0">ufunc_expi_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;expi&quot;)</span>
<span class="s0">ufunc_expi_data[0] = &amp;ufunc_expi_ptr[2*0]</span>
<span class="s0">ufunc_expi_data[1] = &amp;ufunc_expi_ptr[2*1]</span>
<span class="s0">ufunc_expi_data[2] = &amp;ufunc_expi_ptr[2*2]</span>
<span class="s0">ufunc_expi_data[3] = &amp;ufunc_expi_ptr[2*3]</span>
<span class="s0">expi = np.PyUFunc_FromFuncAndData(ufunc_expi_loops, ufunc_expi_data, ufunc_expi_types, 4, 1, 1, 0, &quot;expi&quot;, ufunc_expi_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_expit_loops[3]</span>
<span class="s0">cdef void *ufunc_expit_ptr[6]</span>
<span class="s0">cdef void *ufunc_expit_data[3]</span>
<span class="s0">cdef char ufunc_expit_types[6]</span>
<span class="s0">cdef char *ufunc_expit_doc = (</span>
    <span class="s0">&quot;expit(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Expit (a.k.a. logistic sigmoid) ufunc for ndarrays.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The expit function, also known as the logistic sigmoid function, is\n&quot;</span>
    <span class="s0">&quot;defined as ``expit(x) = 1/(1+exp(-x))``.  It is the inverse of the\n&quot;</span>
    <span class="s0">&quot;logit function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : ndarray\n&quot;</span>
    <span class="s0">&quot;    The ndarray to apply expit to element-wise.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    An ndarray of the same shape as x. Its entries\n&quot;</span>
    <span class="s0">&quot;    are `expit` of the corresponding entry of x.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;logit\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;As a ufunc expit takes a number of optional\n&quot;</span>
    <span class="s0">&quot;keyword arguments. For more information\n&quot;</span>
    <span class="s0">&quot;see `ufuncs &lt;https://docs.scipy.org/doc/numpy/reference/ufuncs.html&gt;`_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 0.10.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import expit, logit\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; expit([-np.inf, -1.5, 0, 1.5, np.inf])\n&quot;</span>
    <span class="s0">&quot;array([ 0.        ,  0.18242552,  0.5       ,  0.81757448,  1.        ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;`logit` is the inverse of `expit`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; logit(expit([-2.5, 0, 3.1, 5.0]))\n&quot;</span>
    <span class="s0">&quot;array([-2.5,  0. ,  3.1,  5. ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot expit(x) for x in [-6, 6]:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-6, 6, 121)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = expit(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.plot(x, y)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.grid()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.xlim(-6, 6)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.xlabel('x')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.title('expit(x)')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_expit_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_f__As_f_f</span>
<span class="s0">ufunc_expit_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_expit_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_g_g__As_g_g</span>
<span class="s0">ufunc_expit_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_expit_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_expit_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_expit_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_expit_types[4] = &lt;char&gt;NPY_LONGDOUBLE</span>
<span class="s0">ufunc_expit_types[5] = &lt;char&gt;NPY_LONGDOUBLE</span>
<span class="s0">ufunc_expit_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_expitf</span>
<span class="s0">ufunc_expit_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;expit&quot;)</span>
<span class="s0">ufunc_expit_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_expit</span>
<span class="s0">ufunc_expit_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;expit&quot;)</span>
<span class="s0">ufunc_expit_ptr[2*2] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_expitl</span>
<span class="s0">ufunc_expit_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;expit&quot;)</span>
<span class="s0">ufunc_expit_data[0] = &amp;ufunc_expit_ptr[2*0]</span>
<span class="s0">ufunc_expit_data[1] = &amp;ufunc_expit_ptr[2*1]</span>
<span class="s0">ufunc_expit_data[2] = &amp;ufunc_expit_ptr[2*2]</span>
<span class="s0">expit = np.PyUFunc_FromFuncAndData(ufunc_expit_loops, ufunc_expit_data, ufunc_expit_types, 3, 1, 1, 0, &quot;expit&quot;, ufunc_expit_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_expm1_loops[4]</span>
<span class="s0">cdef void *ufunc_expm1_ptr[8]</span>
<span class="s0">cdef void *ufunc_expm1_data[4]</span>
<span class="s0">cdef char ufunc_expm1_types[8]</span>
<span class="s0">cdef char *ufunc_expm1_doc = (</span>
    <span class="s0">&quot;expm1(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute ``exp(x) - 1``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;When `x` is near zero, ``exp(x)`` is near 1, so the numerical calculation\n&quot;</span>
    <span class="s0">&quot;of ``exp(x) - 1`` can suffer from catastrophic loss of precision.\n&quot;</span>
    <span class="s0">&quot;``expm1(x)`` is implemented to avoid the loss of precision that occurs when\n&quot;</span>
    <span class="s0">&quot;`x` is near zero.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    `x` must contain real numbers.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    ``exp(x) - 1`` computed element-wise.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import expm1\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; expm1(1.0)\n&quot;</span>
    <span class="s0">&quot;1.7182818284590451\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; expm1([-0.2, -0.1, 0, 0.1, 0.2])\n&quot;</span>
    <span class="s0">&quot;array([-0.18126925, -0.09516258,  0.        ,  0.10517092,  0.22140276])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The exact value of ``exp(7.5e-13) - 1`` is::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    7.5000000000028125000000007031250000001318...*10**-13.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Here is what ``expm1(7.5e-13)`` gives:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; expm1(7.5e-13)\n&quot;</span>
    <span class="s0">&quot;7.5000000000028135e-13\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compare that to ``exp(7.5e-13) - 1``, where the subtraction results in\n&quot;</span>
    <span class="s0">&quot;a \&quot;catastrophic\&quot; loss of precision:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.exp(7.5e-13) - 1\n&quot;</span>
    <span class="s0">&quot;7.5006667543675576e-13&quot;)</span>
<span class="s0">ufunc_expm1_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_expm1_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_expm1_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_F_F</span>
<span class="s0">ufunc_expm1_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_D_D</span>
<span class="s0">ufunc_expm1_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_expm1_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_expm1_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_expm1_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_expm1_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_expm1_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_expm1_types[6] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_expm1_types[7] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_expm1_ptr[2*0] = &lt;void*&gt;_func_expm1</span>
<span class="s0">ufunc_expm1_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;expm1&quot;)</span>
<span class="s0">ufunc_expm1_ptr[2*1] = &lt;void*&gt;_func_expm1</span>
<span class="s0">ufunc_expm1_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;expm1&quot;)</span>
<span class="s0">ufunc_expm1_ptr[2*2] = &lt;void*&gt;_func_cexpm1</span>
<span class="s0">ufunc_expm1_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;expm1&quot;)</span>
<span class="s0">ufunc_expm1_ptr[2*3] = &lt;void*&gt;_func_cexpm1</span>
<span class="s0">ufunc_expm1_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;expm1&quot;)</span>
<span class="s0">ufunc_expm1_data[0] = &amp;ufunc_expm1_ptr[2*0]</span>
<span class="s0">ufunc_expm1_data[1] = &amp;ufunc_expm1_ptr[2*1]</span>
<span class="s0">ufunc_expm1_data[2] = &amp;ufunc_expm1_ptr[2*2]</span>
<span class="s0">ufunc_expm1_data[3] = &amp;ufunc_expm1_ptr[2*3]</span>
<span class="s0">expm1 = np.PyUFunc_FromFuncAndData(ufunc_expm1_loops, ufunc_expm1_data, ufunc_expm1_types, 4, 1, 1, 0, &quot;expm1&quot;, ufunc_expm1_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_expn_loops[3]</span>
<span class="s0">cdef void *ufunc_expn_ptr[6]</span>
<span class="s0">cdef void *ufunc_expn_data[3]</span>
<span class="s0">cdef char ufunc_expn_types[9]</span>
<span class="s0">cdef char *ufunc_expn_doc = (</span>
    <span class="s0">&quot;expn(n, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Generalized exponential integral En.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For integer :math:`n \\geq 0` and real :math:`x \\geq 0` the\n&quot;</span>
    <span class="s0">&quot;generalized exponential integral is defined as [dlmf]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    E_n(x) = x^{n - 1} \\int_x^\\infty \\frac{e^{-t}}{t^n} dt.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Non-negative integers\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the generalized exponential integral\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;exp1 : special case of :math:`E_n` for :math:`n = 1`\n&quot;</span>
    <span class="s0">&quot;expi : related to :math:`E_n` when :math:`n = 1`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [dlmf] Digital Library of Mathematical Functions, 8.19.2\n&quot;</span>
    <span class="s0">&quot;          https://dlmf.nist.gov/8.19#E2\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Its domain is nonnegative n and x.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.expn(-1, 1.0), sc.expn(1, -1.0)\n&quot;</span>
    <span class="s0">&quot;(nan, nan)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It has a pole at ``x = 0`` for ``n = 1, 2``; for larger ``n`` it\n&quot;</span>
    <span class="s0">&quot;is equal to ``1 / (n - 1)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.expn([0, 1, 2, 3, 4], 0)\n&quot;</span>
    <span class="s0">&quot;array([       inf,        inf, 1.        , 0.5       , 0.33333333])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For n equal to 0 it reduces to ``exp(-x) / x``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.array([1, 2, 3, 4])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.expn(0, x)\n&quot;</span>
    <span class="s0">&quot;array([0.36787944, 0.06766764, 0.01659569, 0.00457891])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.exp(-x) / x\n&quot;</span>
    <span class="s0">&quot;array([0.36787944, 0.06766764, 0.01659569, 0.00457891])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For n equal to 1 it reduces to `exp1`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.expn(1, x)\n&quot;</span>
    <span class="s0">&quot;array([0.21938393, 0.04890051, 0.01304838, 0.00377935])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.exp1(x)\n&quot;</span>
    <span class="s0">&quot;array([0.21938393, 0.04890051, 0.01304838, 0.00377935])&quot;)</span>
<span class="s0">ufunc_expn_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_id__As_ld_d</span>
<span class="s0">ufunc_expn_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_expn_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_expn_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc_expn_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_expn_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_expn_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_expn_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_expn_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_expn_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_expn_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_expn_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_expn_ptr[2*0] = &lt;void*&gt;_func_expn</span>
<span class="s0">ufunc_expn_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;expn&quot;)</span>
<span class="s0">ufunc_expn_ptr[2*1] = &lt;void*&gt;_func_expn_unsafe</span>
<span class="s0">ufunc_expn_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;expn&quot;)</span>
<span class="s0">ufunc_expn_ptr[2*2] = &lt;void*&gt;_func_expn_unsafe</span>
<span class="s0">ufunc_expn_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;expn&quot;)</span>
<span class="s0">ufunc_expn_data[0] = &amp;ufunc_expn_ptr[2*0]</span>
<span class="s0">ufunc_expn_data[1] = &amp;ufunc_expn_ptr[2*1]</span>
<span class="s0">ufunc_expn_data[2] = &amp;ufunc_expn_ptr[2*2]</span>
<span class="s0">expn = np.PyUFunc_FromFuncAndData(ufunc_expn_loops, ufunc_expn_data, ufunc_expn_types, 3, 2, 1, 0, &quot;expn&quot;, ufunc_expn_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_exprel_loops[2]</span>
<span class="s0">cdef void *ufunc_exprel_ptr[4]</span>
<span class="s0">cdef void *ufunc_exprel_data[2]</span>
<span class="s0">cdef char ufunc_exprel_types[4]</span>
<span class="s0">cdef char *ufunc_exprel_doc = (</span>
    <span class="s0">&quot;exprel(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Relative error exponential, ``(exp(x) - 1)/x``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;When `x` is near zero, ``exp(x)`` is near 1, so the numerical calculation\n&quot;</span>
    <span class="s0">&quot;of ``exp(x) - 1`` can suffer from catastrophic loss of precision.\n&quot;</span>
    <span class="s0">&quot;``exprel(x)`` is implemented to avoid the loss of precision that occurs when\n&quot;</span>
    <span class="s0">&quot;`x` is near zero.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : ndarray\n&quot;</span>
    <span class="s0">&quot;    Input array.  `x` must contain real numbers.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    ``(exp(x) - 1)/x``, computed element-wise.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;expm1\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 0.17.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import exprel\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; exprel(0.01)\n&quot;</span>
    <span class="s0">&quot;1.0050167084168056\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; exprel([-0.25, -0.1, 0, 0.1, 0.25])\n&quot;</span>
    <span class="s0">&quot;array([ 0.88479687,  0.95162582,  1.        ,  1.05170918,  1.13610167])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compare ``exprel(5e-9)`` to the naive calculation.  The exact value\n&quot;</span>
    <span class="s0">&quot;is ``1.00000000250000000416...``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; exprel(5e-9)\n&quot;</span>
    <span class="s0">&quot;1.0000000025\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; (np.exp(5e-9) - 1)/5e-9\n&quot;</span>
    <span class="s0">&quot;0.99999999392252903&quot;)</span>
<span class="s0">ufunc_exprel_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_exprel_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_exprel_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_exprel_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_exprel_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_exprel_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_exprel_ptr[2*0] = &lt;void*&gt;_func_exprel</span>
<span class="s0">ufunc_exprel_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;exprel&quot;)</span>
<span class="s0">ufunc_exprel_ptr[2*1] = &lt;void*&gt;_func_exprel</span>
<span class="s0">ufunc_exprel_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;exprel&quot;)</span>
<span class="s0">ufunc_exprel_data[0] = &amp;ufunc_exprel_ptr[2*0]</span>
<span class="s0">ufunc_exprel_data[1] = &amp;ufunc_exprel_ptr[2*1]</span>
<span class="s0">exprel = np.PyUFunc_FromFuncAndData(ufunc_exprel_loops, ufunc_exprel_data, ufunc_exprel_types, 2, 1, 1, 0, &quot;exprel&quot;, ufunc_exprel_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_fdtr_loops[2]</span>
<span class="s0">cdef void *ufunc_fdtr_ptr[4]</span>
<span class="s0">cdef void *ufunc_fdtr_data[2]</span>
<span class="s0">cdef char ufunc_fdtr_types[8]</span>
<span class="s0">cdef char *ufunc_fdtr_doc = (</span>
    <span class="s0">&quot;fdtr(dfn, dfd, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;F cumulative distribution function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the value of the cumulative distribution function of the\n&quot;</span>
    <span class="s0">&quot;F-distribution, also known as Snedecor's F-distribution or the\n&quot;</span>
    <span class="s0">&quot;Fisher-Snedecor distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The F-distribution with parameters :math:`d_n` and :math:`d_d` is the\n&quot;</span>
    <span class="s0">&quot;distribution of the random variable,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    X = \\frac{U_n/d_n}{U_d/d_d},\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`U_n` and :math:`U_d` are random variables distributed\n&quot;</span>
    <span class="s0">&quot;:math:`\\chi^2`, with :math:`d_n` and :math:`d_d` degrees of freedom,\n&quot;</span>
    <span class="s0">&quot;respectively.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;dfn : array_like\n&quot;</span>
    <span class="s0">&quot;    First parameter (positive float).\n&quot;</span>
    <span class="s0">&quot;dfd : array_like\n&quot;</span>
    <span class="s0">&quot;    Second parameter (positive float).\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (nonnegative float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;y : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The CDF of the F-distribution with parameters `dfn` and `dfd` at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;fdtrc : F distribution survival function\n&quot;</span>
    <span class="s0">&quot;fdtri : F distribution inverse cumulative distribution\n&quot;</span>
    <span class="s0">&quot;scipy.stats.f : F distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The regularized incomplete beta function is used, according to the\n&quot;</span>
    <span class="s0">&quot;formula,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    F(d_n, d_d; x) = I_{xd_n/(d_d + xd_n)}(d_n/2, d_d/2).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `fdtr`. The F distribution is also\n&quot;</span>
    <span class="s0">&quot;available as `scipy.stats.f`. Calling `fdtr` directly can improve\n&quot;</span>
    <span class="s0">&quot;performance compared to the ``cdf`` method of `scipy.stats.f` (see last\n&quot;</span>
    <span class="s0">&quot;example below).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Calculate the function for ``dfn=1`` and ``dfd=2`` at ``x=1``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import fdtr\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fdtr(1, 2, 1)\n&quot;</span>
    <span class="s0">&quot;0.5773502691896258\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the function at several points by providing a NumPy array for\n&quot;</span>
    <span class="s0">&quot;`x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.array([0.5, 2., 3.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fdtr(1, 2, x)\n&quot;</span>
    <span class="s0">&quot;array([0.4472136 , 0.70710678, 0.77459667])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function for several parameter sets.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfn_parameters = [1, 5, 10, 50]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfd_parameters = [1, 1, 2, 3]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; parameters_list = list(zip(dfn_parameters, dfd_parameters,\n&quot;</span>
    <span class="s0">&quot;...                            linestyles))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0, 30, 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for parameter_set in parameters_list:\n&quot;</span>
    <span class="s0">&quot;...     dfn, dfd, style = parameter_set\n&quot;</span>
    <span class="s0">&quot;...     fdtr_vals = fdtr(dfn, dfd, x)\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, fdtr_vals, label=rf\&quot;$d_n={dfn},\\, d_d={dfd}$\&quot;,\n&quot;</span>
    <span class="s0">&quot;...             ls=style)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel(\&quot;$x$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(\&quot;F distribution cumulative distribution function\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The F distribution is also available as `scipy.stats.f`. Using `fdtr`\n&quot;</span>
    <span class="s0">&quot;directly can be much faster than calling the ``cdf`` method of\n&quot;</span>
    <span class="s0">&quot;`scipy.stats.f`, especially for small arrays or individual values.\n&quot;</span>
    <span class="s0">&quot;To get the same results one must use the following parametrization:\n&quot;</span>
    <span class="s0">&quot;``stats.f(dfn, dfd).cdf(x)=fdtr(dfn, dfd, x)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.stats import f\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfn, dfd = 1, 2\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fdtr_res = fdtr(dfn, dfd, x)  # this will often be faster than below\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; f_dist_res = f(dfn, dfd).cdf(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fdtr_res == f_dist_res  # test that results are equal\n&quot;</span>
    <span class="s0">&quot;True&quot;)</span>
<span class="s0">ufunc_fdtr_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_fdtr_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_fdtr_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fdtr_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fdtr_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fdtr_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fdtr_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fdtr_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fdtr_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fdtr_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fdtr_ptr[2*0] = &lt;void*&gt;_func_fdtr</span>
<span class="s0">ufunc_fdtr_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;fdtr&quot;)</span>
<span class="s0">ufunc_fdtr_ptr[2*1] = &lt;void*&gt;_func_fdtr</span>
<span class="s0">ufunc_fdtr_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;fdtr&quot;)</span>
<span class="s0">ufunc_fdtr_data[0] = &amp;ufunc_fdtr_ptr[2*0]</span>
<span class="s0">ufunc_fdtr_data[1] = &amp;ufunc_fdtr_ptr[2*1]</span>
<span class="s0">fdtr = np.PyUFunc_FromFuncAndData(ufunc_fdtr_loops, ufunc_fdtr_data, ufunc_fdtr_types, 2, 3, 1, 0, &quot;fdtr&quot;, ufunc_fdtr_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_fdtrc_loops[2]</span>
<span class="s0">cdef void *ufunc_fdtrc_ptr[4]</span>
<span class="s0">cdef void *ufunc_fdtrc_data[2]</span>
<span class="s0">cdef char ufunc_fdtrc_types[8]</span>
<span class="s0">cdef char *ufunc_fdtrc_doc = (</span>
    <span class="s0">&quot;fdtrc(dfn, dfd, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;F survival function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the complemented F-distribution function (the integral of the\n&quot;</span>
    <span class="s0">&quot;density from `x` to infinity).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;dfn : array_like\n&quot;</span>
    <span class="s0">&quot;    First parameter (positive float).\n&quot;</span>
    <span class="s0">&quot;dfd : array_like\n&quot;</span>
    <span class="s0">&quot;    Second parameter (positive float).\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (nonnegative float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;y : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The complemented F-distribution function with parameters `dfn` and\n&quot;</span>
    <span class="s0">&quot;    `dfd` at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;fdtr : F distribution cumulative distribution function\n&quot;</span>
    <span class="s0">&quot;fdtri : F distribution inverse cumulative distribution function\n&quot;</span>
    <span class="s0">&quot;scipy.stats.f : F distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The regularized incomplete beta function is used, according to the\n&quot;</span>
    <span class="s0">&quot;formula,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    F(d_n, d_d; x) = I_{d_d/(d_d + xd_n)}(d_d/2, d_n/2).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `fdtrc`. The F distribution is also\n&quot;</span>
    <span class="s0">&quot;available as `scipy.stats.f`. Calling `fdtrc` directly can improve\n&quot;</span>
    <span class="s0">&quot;performance compared to the ``sf`` method of `scipy.stats.f` (see last\n&quot;</span>
    <span class="s0">&quot;example below).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Calculate the function for ``dfn=1`` and ``dfd=2`` at ``x=1``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import fdtrc\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fdtrc(1, 2, 1)\n&quot;</span>
    <span class="s0">&quot;0.42264973081037427\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the function at several points by providing a NumPy array for\n&quot;</span>
    <span class="s0">&quot;`x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.array([0.5, 2., 3.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fdtrc(1, 2, x)\n&quot;</span>
    <span class="s0">&quot;array([0.5527864 , 0.29289322, 0.22540333])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function for several parameter sets.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfn_parameters = [1, 5, 10, 50]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfd_parameters = [1, 1, 2, 3]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; parameters_list = list(zip(dfn_parameters, dfd_parameters,\n&quot;</span>
    <span class="s0">&quot;...                            linestyles))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0, 30, 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for parameter_set in parameters_list:\n&quot;</span>
    <span class="s0">&quot;...     dfn, dfd, style = parameter_set\n&quot;</span>
    <span class="s0">&quot;...     fdtrc_vals = fdtrc(dfn, dfd, x)\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, fdtrc_vals, label=rf\&quot;$d_n={dfn},\\, d_d={dfd}$\&quot;,\n&quot;</span>
    <span class="s0">&quot;...             ls=style)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel(\&quot;$x$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(\&quot;F distribution survival function\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The F distribution is also available as `scipy.stats.f`. Using `fdtrc`\n&quot;</span>
    <span class="s0">&quot;directly can be much faster than calling the ``sf`` method of\n&quot;</span>
    <span class="s0">&quot;`scipy.stats.f`, especially for small arrays or individual values.\n&quot;</span>
    <span class="s0">&quot;To get the same results one must use the following parametrization:\n&quot;</span>
    <span class="s0">&quot;``stats.f(dfn, dfd).sf(x)=fdtrc(dfn, dfd, x)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.stats import f\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfn, dfd = 1, 2\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fdtrc_res = fdtrc(dfn, dfd, x)  # this will often be faster than below\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; f_dist_res = f(dfn, dfd).sf(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; f_dist_res == fdtrc_res  # test that results are equal\n&quot;</span>
    <span class="s0">&quot;True&quot;)</span>
<span class="s0">ufunc_fdtrc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_fdtrc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_fdtrc_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fdtrc_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fdtrc_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fdtrc_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fdtrc_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fdtrc_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fdtrc_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fdtrc_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fdtrc_ptr[2*0] = &lt;void*&gt;_func_fdtrc</span>
<span class="s0">ufunc_fdtrc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;fdtrc&quot;)</span>
<span class="s0">ufunc_fdtrc_ptr[2*1] = &lt;void*&gt;_func_fdtrc</span>
<span class="s0">ufunc_fdtrc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;fdtrc&quot;)</span>
<span class="s0">ufunc_fdtrc_data[0] = &amp;ufunc_fdtrc_ptr[2*0]</span>
<span class="s0">ufunc_fdtrc_data[1] = &amp;ufunc_fdtrc_ptr[2*1]</span>
<span class="s0">fdtrc = np.PyUFunc_FromFuncAndData(ufunc_fdtrc_loops, ufunc_fdtrc_data, ufunc_fdtrc_types, 2, 3, 1, 0, &quot;fdtrc&quot;, ufunc_fdtrc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_fdtri_loops[2]</span>
<span class="s0">cdef void *ufunc_fdtri_ptr[4]</span>
<span class="s0">cdef void *ufunc_fdtri_data[2]</span>
<span class="s0">cdef char ufunc_fdtri_types[8]</span>
<span class="s0">cdef char *ufunc_fdtri_doc = (</span>
    <span class="s0">&quot;fdtri(dfn, dfd, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The `p`-th quantile of the F-distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is the inverse of the F-distribution CDF, `fdtr`, returning\n&quot;</span>
    <span class="s0">&quot;the `x` such that `fdtr(dfn, dfd, x) = p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;dfn : array_like\n&quot;</span>
    <span class="s0">&quot;    First parameter (positive float).\n&quot;</span>
    <span class="s0">&quot;dfd : array_like\n&quot;</span>
    <span class="s0">&quot;    Second parameter (positive float).\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Cumulative probability, in [0, 1].\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;x : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The quantile corresponding to `p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;fdtr : F distribution cumulative distribution function\n&quot;</span>
    <span class="s0">&quot;fdtrc : F distribution survival function\n&quot;</span>
    <span class="s0">&quot;scipy.stats.f : F distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The computation is carried out using the relation to the inverse\n&quot;</span>
    <span class="s0">&quot;regularized beta function, :math:`I^{-1}_x(a, b)`.  Let\n&quot;</span>
    <span class="s0">&quot;:math:`z = I^{-1}_p(d_d/2, d_n/2).`  Then,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    x = \\frac{d_d (1 - z)}{d_n z}.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;If `p` is such that :math:`x &lt; 0.5`, the following relation is used\n&quot;</span>
    <span class="s0">&quot;instead for improved stability: let\n&quot;</span>
    <span class="s0">&quot;:math:`z' = I^{-1}_{1 - p}(d_n/2, d_d/2).` Then,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    x = \\frac{d_d z'}{d_n (1 - z')}.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `fdtri`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The F distribution is also available as `scipy.stats.f`. Calling\n&quot;</span>
    <span class="s0">&quot;`fdtri` directly can improve performance compared to the ``ppf``\n&quot;</span>
    <span class="s0">&quot;method of `scipy.stats.f` (see last example below).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;`fdtri` represents the inverse of the F distribution CDF which is\n&quot;</span>
    <span class="s0">&quot;available as `fdtr`. Here, we calculate the CDF for ``df1=1``, ``df2=2``\n&quot;</span>
    <span class="s0">&quot;at ``x=3``. `fdtri` then returns ``3`` given the same values for `df1`,\n&quot;</span>
    <span class="s0">&quot;`df2` and the computed CDF value.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import fdtri, fdtr\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; df1, df2 = 1, 2\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 3\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdf_value =  fdtr(df1, df2, x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fdtri(df1, df2, cdf_value)\n&quot;</span>
    <span class="s0">&quot;3.000000000000006\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the function at several points by providing a NumPy array for\n&quot;</span>
    <span class="s0">&quot;`x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.array([0.1, 0.4, 0.7])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fdtri(1, 2, x)\n&quot;</span>
    <span class="s0">&quot;array([0.02020202, 0.38095238, 1.92156863])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function for several parameter sets.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfn_parameters = [50, 10, 1, 50]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfd_parameters = [0.5, 1, 1, 5]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; parameters_list = list(zip(dfn_parameters, dfd_parameters,\n&quot;</span>
    <span class="s0">&quot;...                            linestyles))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0, 1, 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for parameter_set in parameters_list:\n&quot;</span>
    <span class="s0">&quot;...     dfn, dfd, style = parameter_set\n&quot;</span>
    <span class="s0">&quot;...     fdtri_vals = fdtri(dfn, dfd, x)\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, fdtri_vals, label=rf\&quot;$d_n={dfn},\\, d_d={dfd}$\&quot;,\n&quot;</span>
    <span class="s0">&quot;...             ls=style)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel(\&quot;$x$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; title = \&quot;F distribution inverse cumulative distribution function\&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(title)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_ylim(0, 30)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The F distribution is also available as `scipy.stats.f`. Using `fdtri`\n&quot;</span>
    <span class="s0">&quot;directly can be much faster than calling the ``ppf`` method of\n&quot;</span>
    <span class="s0">&quot;`scipy.stats.f`, especially for small arrays or individual values.\n&quot;</span>
    <span class="s0">&quot;To get the same results one must use the following parametrization:\n&quot;</span>
    <span class="s0">&quot;``stats.f(dfn, dfd).ppf(x)=fdtri(dfn, dfd, x)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.stats import f\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfn, dfd = 1, 2\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 0.7\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fdtri_res = fdtri(dfn, dfd, x)  # this will often be faster than below\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; f_dist_res = f(dfn, dfd).ppf(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; f_dist_res == fdtri_res  # test that results are equal\n&quot;</span>
    <span class="s0">&quot;True&quot;)</span>
<span class="s0">ufunc_fdtri_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_fdtri_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_fdtri_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fdtri_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fdtri_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fdtri_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fdtri_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fdtri_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fdtri_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fdtri_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fdtri_ptr[2*0] = &lt;void*&gt;_func_fdtri</span>
<span class="s0">ufunc_fdtri_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;fdtri&quot;)</span>
<span class="s0">ufunc_fdtri_ptr[2*1] = &lt;void*&gt;_func_fdtri</span>
<span class="s0">ufunc_fdtri_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;fdtri&quot;)</span>
<span class="s0">ufunc_fdtri_data[0] = &amp;ufunc_fdtri_ptr[2*0]</span>
<span class="s0">ufunc_fdtri_data[1] = &amp;ufunc_fdtri_ptr[2*1]</span>
<span class="s0">fdtri = np.PyUFunc_FromFuncAndData(ufunc_fdtri_loops, ufunc_fdtri_data, ufunc_fdtri_types, 2, 3, 1, 0, &quot;fdtri&quot;, ufunc_fdtri_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_fdtridfd_loops[2]</span>
<span class="s0">cdef void *ufunc_fdtridfd_ptr[4]</span>
<span class="s0">cdef void *ufunc_fdtridfd_data[2]</span>
<span class="s0">cdef char ufunc_fdtridfd_types[8]</span>
<span class="s0">cdef char *ufunc_fdtridfd_doc = (</span>
    <span class="s0">&quot;fdtridfd(dfn, p, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse to `fdtr` vs dfd\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Finds the F density argument dfd such that ``fdtr(dfn, dfd, x) == p``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;dfn : array_like\n&quot;</span>
    <span class="s0">&quot;    First parameter (positive float).\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Cumulative probability, in [0, 1].\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (nonnegative float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;dfd : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    `dfd` such that ``fdtr(dfn, dfd, x) == p``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;fdtr : F distribution cumulative distribution function\n&quot;</span>
    <span class="s0">&quot;fdtrc : F distribution survival function\n&quot;</span>
    <span class="s0">&quot;fdtri : F distribution quantile function\n&quot;</span>
    <span class="s0">&quot;scipy.stats.f : F distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Compute the F distribution cumulative distribution function for one\n&quot;</span>
    <span class="s0">&quot;parameter set.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import fdtridfd, fdtr\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfn, dfd, x = 10, 5, 2\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdf_value = fdtr(dfn, dfd, x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdf_value\n&quot;</span>
    <span class="s0">&quot;0.7700248806501017\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Verify that `fdtridfd` recovers the original value for `dfd`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fdtridfd(dfn, cdf_value, x)\n&quot;</span>
    <span class="s0">&quot;5.0&quot;)</span>
<span class="s0">ufunc_fdtridfd_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_fdtridfd_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_fdtridfd_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fdtridfd_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fdtridfd_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fdtridfd_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fdtridfd_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fdtridfd_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fdtridfd_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fdtridfd_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fdtridfd_ptr[2*0] = &lt;void*&gt;_func_cdff4_wrap</span>
<span class="s0">ufunc_fdtridfd_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;fdtridfd&quot;)</span>
<span class="s0">ufunc_fdtridfd_ptr[2*1] = &lt;void*&gt;_func_cdff4_wrap</span>
<span class="s0">ufunc_fdtridfd_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;fdtridfd&quot;)</span>
<span class="s0">ufunc_fdtridfd_data[0] = &amp;ufunc_fdtridfd_ptr[2*0]</span>
<span class="s0">ufunc_fdtridfd_data[1] = &amp;ufunc_fdtridfd_ptr[2*1]</span>
<span class="s0">fdtridfd = np.PyUFunc_FromFuncAndData(ufunc_fdtridfd_loops, ufunc_fdtridfd_data, ufunc_fdtridfd_types, 2, 3, 1, 0, &quot;fdtridfd&quot;, ufunc_fdtridfd_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_fresnel_loops[4]</span>
<span class="s0">cdef void *ufunc_fresnel_ptr[8]</span>
<span class="s0">cdef void *ufunc_fresnel_data[4]</span>
<span class="s0">cdef char ufunc_fresnel_types[12]</span>
<span class="s0">cdef char *ufunc_fresnel_doc = (</span>
    <span class="s0">&quot;fresnel(z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Fresnel integrals.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The Fresnel integrals are defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;   S(z) &amp;= \\int_0^z \\sin(\\pi t^2 /2) dt \\\\\n&quot;</span>
    <span class="s0">&quot;   C(z) &amp;= \\int_0^z \\cos(\\pi t^2 /2) dt.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See [dlmf]_ for details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;z : array_like\n&quot;</span>
    <span class="s0">&quot;    Real or complex valued argument\n&quot;</span>
    <span class="s0">&quot;out : 2-tuple of ndarrays, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output arrays for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;S, C : 2-tuple of scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Fresnel integrals\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;fresnel_zeros : zeros of the Fresnel integrals\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [dlmf] NIST Digital Library of Mathematical Functions\n&quot;</span>
    <span class="s0">&quot;          https://dlmf.nist.gov/7.2#iii\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;As z goes to infinity along the real axis, S and C converge to 0.5.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; S, C = sc.fresnel([0.1, 1, 10, 100, np.inf])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; S\n&quot;</span>
    <span class="s0">&quot;array([0.00052359, 0.43825915, 0.46816998, 0.4968169 , 0.5       ])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; C\n&quot;</span>
    <span class="s0">&quot;array([0.09999753, 0.7798934 , 0.49989869, 0.4999999 , 0.5       ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;They are related to the error function `erf`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z = np.array([1, 2, 3, 4])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; zeta = 0.5 * np.sqrt(np.pi) * (1 - 1j) * z\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; S, C = sc.fresnel(z)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; C + 1j*S\n&quot;</span>
    <span class="s0">&quot;array([0.7798934 +0.43825915j, 0.48825341+0.34341568j,\n&quot;</span>
    <span class="s0">&quot;       0.60572079+0.496313j  , 0.49842603+0.42051575j])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; 0.5 * (1 + 1j) * sc.erf(zeta)\n&quot;</span>
    <span class="s0">&quot;array([0.7798934 +0.43825915j, 0.48825341+0.34341568j,\n&quot;</span>
    <span class="s0">&quot;       0.60572079+0.496313j  , 0.49842603+0.42051575j])&quot;)</span>
<span class="s0">ufunc_fresnel_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_d_dd_As_f_ff</span>
<span class="s0">ufunc_fresnel_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_i_d_dd_As_d_dd</span>
<span class="s0">ufunc_fresnel_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_i_D_DD_As_F_FF</span>
<span class="s0">ufunc_fresnel_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_i_D_DD_As_D_DD</span>
<span class="s0">ufunc_fresnel_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fresnel_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fresnel_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_fresnel_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fresnel_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fresnel_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_fresnel_types[6] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_fresnel_types[7] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_fresnel_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_fresnel_types[9] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_fresnel_types[10] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_fresnel_types[11] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_fresnel_ptr[2*0] = &lt;void*&gt;_func_fresnl</span>
<span class="s0">ufunc_fresnel_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;fresnel&quot;)</span>
<span class="s0">ufunc_fresnel_ptr[2*1] = &lt;void*&gt;_func_fresnl</span>
<span class="s0">ufunc_fresnel_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;fresnel&quot;)</span>
<span class="s0">ufunc_fresnel_ptr[2*2] = &lt;void*&gt;_func_cfresnl_wrap</span>
<span class="s0">ufunc_fresnel_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;fresnel&quot;)</span>
<span class="s0">ufunc_fresnel_ptr[2*3] = &lt;void*&gt;_func_cfresnl_wrap</span>
<span class="s0">ufunc_fresnel_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;fresnel&quot;)</span>
<span class="s0">ufunc_fresnel_data[0] = &amp;ufunc_fresnel_ptr[2*0]</span>
<span class="s0">ufunc_fresnel_data[1] = &amp;ufunc_fresnel_ptr[2*1]</span>
<span class="s0">ufunc_fresnel_data[2] = &amp;ufunc_fresnel_ptr[2*2]</span>
<span class="s0">ufunc_fresnel_data[3] = &amp;ufunc_fresnel_ptr[2*3]</span>
<span class="s0">fresnel = np.PyUFunc_FromFuncAndData(ufunc_fresnel_loops, ufunc_fresnel_data, ufunc_fresnel_types, 4, 1, 2, 0, &quot;fresnel&quot;, ufunc_fresnel_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_gamma_loops[4]</span>
<span class="s0">cdef void *ufunc_gamma_ptr[8]</span>
<span class="s0">cdef void *ufunc_gamma_data[4]</span>
<span class="s0">cdef char ufunc_gamma_types[8]</span>
<span class="s0">cdef char *ufunc_gamma_doc = (</span>
    <span class="s0">&quot;gamma(z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The gamma function is defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;   \\Gamma(z) = \\int_0^\\infty t^{z-1} e^{-t} dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;for :math:`\\Re(z) &gt; 0` and is extended to the rest of the complex\n&quot;</span>
    <span class="s0">&quot;plane by analytic continuation. See [dlmf]_ for more details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;z : array_like\n&quot;</span>
    <span class="s0">&quot;    Real or complex valued argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the gamma function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The gamma function is often referred to as the generalized\n&quot;</span>
    <span class="s0">&quot;factorial since :math:`\\Gamma(n + 1) = n!` for natural numbers\n&quot;</span>
    <span class="s0">&quot;:math:`n`. More generally it satisfies the recurrence relation\n&quot;</span>
    <span class="s0">&quot;:math:`\\Gamma(z + 1) = z \\cdot \\Gamma(z)` for complex :math:`z`,\n&quot;</span>
    <span class="s0">&quot;which, combined with the fact that :math:`\\Gamma(1) = 1`, implies\n&quot;</span>
    <span class="s0">&quot;the above identity for :math:`z = n`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [dlmf] NIST Digital Library of Mathematical Functions\n&quot;</span>
    <span class="s0">&quot;          https://dlmf.nist.gov/5.2#E1\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import gamma, factorial\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gamma([0, 0.5, 1, 5])\n&quot;</span>
    <span class="s0">&quot;array([         inf,   1.77245385,   1.        ,  24.        ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z = 2.5 + 1j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gamma(z)\n&quot;</span>
    <span class="s0">&quot;(0.77476210455108352+0.70763120437959293j)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gamma(z+1), z*gamma(z)  # Recurrence property\n&quot;</span>
    <span class="s0">&quot;((1.2292740569981171+2.5438401155000685j),\n&quot;</span>
    <span class="s0">&quot; (1.2292740569981158+2.5438401155000658j))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gamma(0.5)**2  # gamma(0.5) = sqrt(pi)\n&quot;</span>
    <span class="s0">&quot;3.1415926535897927\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot gamma(x) for real x\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-3.5, 5.5, 2251)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = gamma(x)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.plot(x, y, 'b', alpha=0.6, label='gamma(x)')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k = np.arange(1, 7)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.plot(k, factorial(k-1), 'k*', alpha=0.6,\n&quot;</span>
    <span class="s0">&quot;...          label='(x-1)!, x = 1, 2, ...')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.xlim(-3.5, 5.5)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.ylim(-10, 25)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.grid()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.xlabel('x')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.legend(loc='lower right')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_gamma_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_gamma_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_gamma_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_F_F</span>
<span class="s0">ufunc_gamma_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_D_D</span>
<span class="s0">ufunc_gamma_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gamma_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gamma_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gamma_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gamma_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_gamma_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_gamma_types[6] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_gamma_types[7] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_gamma_ptr[2*0] = &lt;void*&gt;_func_Gamma</span>
<span class="s0">ufunc_gamma_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gamma&quot;)</span>
<span class="s0">ufunc_gamma_ptr[2*1] = &lt;void*&gt;_func_Gamma</span>
<span class="s0">ufunc_gamma_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gamma&quot;)</span>
<span class="s0">ufunc_gamma_ptr[2*2] = &lt;void*&gt;_func_cgamma</span>
<span class="s0">ufunc_gamma_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gamma&quot;)</span>
<span class="s0">ufunc_gamma_ptr[2*3] = &lt;void*&gt;_func_cgamma</span>
<span class="s0">ufunc_gamma_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gamma&quot;)</span>
<span class="s0">ufunc_gamma_data[0] = &amp;ufunc_gamma_ptr[2*0]</span>
<span class="s0">ufunc_gamma_data[1] = &amp;ufunc_gamma_ptr[2*1]</span>
<span class="s0">ufunc_gamma_data[2] = &amp;ufunc_gamma_ptr[2*2]</span>
<span class="s0">ufunc_gamma_data[3] = &amp;ufunc_gamma_ptr[2*3]</span>
<span class="s0">gamma = np.PyUFunc_FromFuncAndData(ufunc_gamma_loops, ufunc_gamma_data, ufunc_gamma_types, 4, 1, 1, 0, &quot;gamma&quot;, ufunc_gamma_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_gammainc_loops[2]</span>
<span class="s0">cdef void *ufunc_gammainc_ptr[4]</span>
<span class="s0">cdef void *ufunc_gammainc_data[2]</span>
<span class="s0">cdef char ufunc_gammainc_types[6]</span>
<span class="s0">cdef char *ufunc_gammainc_doc = (</span>
    <span class="s0">&quot;gammainc(a, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Regularized lower incomplete gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    P(a, x) = \\frac{1}{\\Gamma(a)} \\int_0^x t^{a - 1}e^{-t} dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;for :math:`a &gt; 0` and :math:`x \\geq 0`. See [dlmf]_ for details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive parameter\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Nonnegative argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the lower incomplete gamma function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The function satisfies the relation ``gammainc(a, x) +\n&quot;</span>
    <span class="s0">&quot;gammaincc(a, x) = 1`` where `gammaincc` is the regularized upper\n&quot;</span>
    <span class="s0">&quot;incomplete gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The implementation largely follows that of [boost]_.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;gammaincc : regularized upper incomplete gamma function\n&quot;</span>
    <span class="s0">&quot;gammaincinv : inverse of the regularized lower incomplete gamma function\n&quot;</span>
    <span class="s0">&quot;gammainccinv : inverse of the regularized upper incomplete gamma function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [dlmf] NIST Digital Library of Mathematical functions\n&quot;</span>
    <span class="s0">&quot;          https://dlmf.nist.gov/8.2#E4\n&quot;</span>
    <span class="s0">&quot;.. [boost] Maddock et. al., \&quot;Incomplete Gamma Functions\&quot;,\n&quot;</span>
    <span class="s0">&quot;   https://www.boost.org/doc/libs/1_61_0/libs/math/doc/html/math_toolkit/sf_gamma/igamma.html\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is the CDF of the gamma distribution, so it starts at 0 and\n&quot;</span>
    <span class="s0">&quot;monotonically increases to 1.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gammainc(0.5, [0, 1, 10, 100])\n&quot;</span>
    <span class="s0">&quot;array([0.        , 0.84270079, 0.99999226, 1.        ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is equal to one minus the upper incomplete gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a, x = 0.5, 0.4\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gammainc(a, x)\n&quot;</span>
    <span class="s0">&quot;0.6289066304773024\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; 1 - sc.gammaincc(a, x)\n&quot;</span>
    <span class="s0">&quot;0.6289066304773024&quot;)</span>
<span class="s0">ufunc_gammainc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_gammainc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_gammainc_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gammainc_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gammainc_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gammainc_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gammainc_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gammainc_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gammainc_ptr[2*0] = &lt;void*&gt;_func_igam</span>
<span class="s0">ufunc_gammainc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gammainc&quot;)</span>
<span class="s0">ufunc_gammainc_ptr[2*1] = &lt;void*&gt;_func_igam</span>
<span class="s0">ufunc_gammainc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gammainc&quot;)</span>
<span class="s0">ufunc_gammainc_data[0] = &amp;ufunc_gammainc_ptr[2*0]</span>
<span class="s0">ufunc_gammainc_data[1] = &amp;ufunc_gammainc_ptr[2*1]</span>
<span class="s0">gammainc = np.PyUFunc_FromFuncAndData(ufunc_gammainc_loops, ufunc_gammainc_data, ufunc_gammainc_types, 2, 2, 1, 0, &quot;gammainc&quot;, ufunc_gammainc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_gammaincc_loops[2]</span>
<span class="s0">cdef void *ufunc_gammaincc_ptr[4]</span>
<span class="s0">cdef void *ufunc_gammaincc_data[2]</span>
<span class="s0">cdef char ufunc_gammaincc_types[6]</span>
<span class="s0">cdef char *ufunc_gammaincc_doc = (</span>
    <span class="s0">&quot;gammaincc(a, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Regularized upper incomplete gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    Q(a, x) = \\frac{1}{\\Gamma(a)} \\int_x^\\infty t^{a - 1}e^{-t} dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;for :math:`a &gt; 0` and :math:`x \\geq 0`. See [dlmf]_ for details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive parameter\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Nonnegative argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the upper incomplete gamma function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The function satisfies the relation ``gammainc(a, x) +\n&quot;</span>
    <span class="s0">&quot;gammaincc(a, x) = 1`` where `gammainc` is the regularized lower\n&quot;</span>
    <span class="s0">&quot;incomplete gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The implementation largely follows that of [boost]_.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;gammainc : regularized lower incomplete gamma function\n&quot;</span>
    <span class="s0">&quot;gammaincinv : inverse of the regularized lower incomplete gamma function\n&quot;</span>
    <span class="s0">&quot;gammainccinv : inverse of the regularized upper incomplete gamma function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [dlmf] NIST Digital Library of Mathematical functions\n&quot;</span>
    <span class="s0">&quot;          https://dlmf.nist.gov/8.2#E4\n&quot;</span>
    <span class="s0">&quot;.. [boost] Maddock et. al., \&quot;Incomplete Gamma Functions\&quot;,\n&quot;</span>
    <span class="s0">&quot;   https://www.boost.org/doc/libs/1_61_0/libs/math/doc/html/math_toolkit/sf_gamma/igamma.html\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is the survival function of the gamma distribution, so it\n&quot;</span>
    <span class="s0">&quot;starts at 1 and monotonically decreases to 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gammaincc(0.5, [0, 1, 10, 100, 1000])\n&quot;</span>
    <span class="s0">&quot;array([1.00000000e+00, 1.57299207e-01, 7.74421643e-06, 2.08848758e-45,\n&quot;</span>
    <span class="s0">&quot;       0.00000000e+00])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is equal to one minus the lower incomplete gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a, x = 0.5, 0.4\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gammaincc(a, x)\n&quot;</span>
    <span class="s0">&quot;0.37109336952269756\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; 1 - sc.gammainc(a, x)\n&quot;</span>
    <span class="s0">&quot;0.37109336952269756&quot;)</span>
<span class="s0">ufunc_gammaincc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_gammaincc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_gammaincc_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gammaincc_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gammaincc_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gammaincc_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gammaincc_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gammaincc_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gammaincc_ptr[2*0] = &lt;void*&gt;_func_igamc</span>
<span class="s0">ufunc_gammaincc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gammaincc&quot;)</span>
<span class="s0">ufunc_gammaincc_ptr[2*1] = &lt;void*&gt;_func_igamc</span>
<span class="s0">ufunc_gammaincc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gammaincc&quot;)</span>
<span class="s0">ufunc_gammaincc_data[0] = &amp;ufunc_gammaincc_ptr[2*0]</span>
<span class="s0">ufunc_gammaincc_data[1] = &amp;ufunc_gammaincc_ptr[2*1]</span>
<span class="s0">gammaincc = np.PyUFunc_FromFuncAndData(ufunc_gammaincc_loops, ufunc_gammaincc_data, ufunc_gammaincc_types, 2, 2, 1, 0, &quot;gammaincc&quot;, ufunc_gammaincc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_gammainccinv_loops[2]</span>
<span class="s0">cdef void *ufunc_gammainccinv_ptr[4]</span>
<span class="s0">cdef void *ufunc_gammainccinv_data[2]</span>
<span class="s0">cdef char ufunc_gammainccinv_types[6]</span>
<span class="s0">cdef char *ufunc_gammainccinv_doc = (</span>
    <span class="s0">&quot;gammainccinv(a, y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse of the regularized upper incomplete gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Given an input :math:`y` between 0 and 1, returns :math:`x` such\n&quot;</span>
    <span class="s0">&quot;that :math:`y = Q(a, x)`. Here :math:`Q` is the regularized upper\n&quot;</span>
    <span class="s0">&quot;incomplete gamma function; see `gammaincc`. This is well-defined\n&quot;</span>
    <span class="s0">&quot;because the upper incomplete gamma function is monotonic as can\n&quot;</span>
    <span class="s0">&quot;be seen from its definition in [dlmf]_.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive parameter\n&quot;</span>
    <span class="s0">&quot;y : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument between 0 and 1, inclusive\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the inverse of the upper incomplete gamma function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;gammaincc : regularized upper incomplete gamma function\n&quot;</span>
    <span class="s0">&quot;gammainc : regularized lower incomplete gamma function\n&quot;</span>
    <span class="s0">&quot;gammaincinv : inverse of the regularized lower incomplete gamma function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [dlmf] NIST Digital Library of Mathematical Functions\n&quot;</span>
    <span class="s0">&quot;          https://dlmf.nist.gov/8.2#E4\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It starts at infinity and monotonically decreases to 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gammainccinv(0.5, [0, 0.1, 0.5, 1])\n&quot;</span>
    <span class="s0">&quot;array([       inf, 1.35277173, 0.22746821, 0.        ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It inverts the upper incomplete gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a, x = 0.5, [0, 0.1, 0.5, 1]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gammaincc(a, sc.gammainccinv(a, x))\n&quot;</span>
    <span class="s0">&quot;array([0. , 0.1, 0.5, 1. ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a, x = 0.5, [0, 10, 50]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gammainccinv(a, sc.gammaincc(a, x))\n&quot;</span>
    <span class="s0">&quot;array([ 0., 10., 50.])&quot;)</span>
<span class="s0">ufunc_gammainccinv_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_gammainccinv_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_gammainccinv_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gammainccinv_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gammainccinv_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gammainccinv_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gammainccinv_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gammainccinv_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gammainccinv_ptr[2*0] = &lt;void*&gt;_func_igamci</span>
<span class="s0">ufunc_gammainccinv_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gammainccinv&quot;)</span>
<span class="s0">ufunc_gammainccinv_ptr[2*1] = &lt;void*&gt;_func_igamci</span>
<span class="s0">ufunc_gammainccinv_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gammainccinv&quot;)</span>
<span class="s0">ufunc_gammainccinv_data[0] = &amp;ufunc_gammainccinv_ptr[2*0]</span>
<span class="s0">ufunc_gammainccinv_data[1] = &amp;ufunc_gammainccinv_ptr[2*1]</span>
<span class="s0">gammainccinv = np.PyUFunc_FromFuncAndData(ufunc_gammainccinv_loops, ufunc_gammainccinv_data, ufunc_gammainccinv_types, 2, 2, 1, 0, &quot;gammainccinv&quot;, ufunc_gammainccinv_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_gammaincinv_loops[2]</span>
<span class="s0">cdef void *ufunc_gammaincinv_ptr[4]</span>
<span class="s0">cdef void *ufunc_gammaincinv_data[2]</span>
<span class="s0">cdef char ufunc_gammaincinv_types[6]</span>
<span class="s0">cdef char *ufunc_gammaincinv_doc = (</span>
    <span class="s0">&quot;gammaincinv(a, y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse to the regularized lower incomplete gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Given an input :math:`y` between 0 and 1, returns :math:`x` such\n&quot;</span>
    <span class="s0">&quot;that :math:`y = P(a, x)`. Here :math:`P` is the regularized lower\n&quot;</span>
    <span class="s0">&quot;incomplete gamma function; see `gammainc`. This is well-defined\n&quot;</span>
    <span class="s0">&quot;because the lower incomplete gamma function is monotonic as can be\n&quot;</span>
    <span class="s0">&quot;seen from its definition in [dlmf]_.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a : array_like\n&quot;</span>
    <span class="s0">&quot;    Positive parameter\n&quot;</span>
    <span class="s0">&quot;y : array_like\n&quot;</span>
    <span class="s0">&quot;    Parameter between 0 and 1, inclusive\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the inverse of the lower incomplete gamma function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;gammainc : regularized lower incomplete gamma function\n&quot;</span>
    <span class="s0">&quot;gammaincc : regularized upper incomplete gamma function\n&quot;</span>
    <span class="s0">&quot;gammainccinv : inverse of the regularized upper incomplete gamma function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [dlmf] NIST Digital Library of Mathematical Functions\n&quot;</span>
    <span class="s0">&quot;          https://dlmf.nist.gov/8.2#E4\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It starts at 0 and monotonically increases to infinity.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gammaincinv(0.5, [0, 0.1 ,0.5, 1])\n&quot;</span>
    <span class="s0">&quot;array([0.        , 0.00789539, 0.22746821,        inf])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It inverts the lower incomplete gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a, x = 0.5, [0, 0.1, 0.5, 1]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gammainc(a, sc.gammaincinv(a, x))\n&quot;</span>
    <span class="s0">&quot;array([0. , 0.1, 0.5, 1. ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a, x = 0.5, [0, 10, 25]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gammaincinv(a, sc.gammainc(a, x))\n&quot;</span>
    <span class="s0">&quot;array([ 0.        , 10.        , 25.00001465])&quot;)</span>
<span class="s0">ufunc_gammaincinv_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_gammaincinv_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_gammaincinv_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gammaincinv_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gammaincinv_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gammaincinv_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gammaincinv_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gammaincinv_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gammaincinv_ptr[2*0] = &lt;void*&gt;_func_igami</span>
<span class="s0">ufunc_gammaincinv_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gammaincinv&quot;)</span>
<span class="s0">ufunc_gammaincinv_ptr[2*1] = &lt;void*&gt;_func_igami</span>
<span class="s0">ufunc_gammaincinv_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gammaincinv&quot;)</span>
<span class="s0">ufunc_gammaincinv_data[0] = &amp;ufunc_gammaincinv_ptr[2*0]</span>
<span class="s0">ufunc_gammaincinv_data[1] = &amp;ufunc_gammaincinv_ptr[2*1]</span>
<span class="s0">gammaincinv = np.PyUFunc_FromFuncAndData(ufunc_gammaincinv_loops, ufunc_gammaincinv_data, ufunc_gammaincinv_types, 2, 2, 1, 0, &quot;gammaincinv&quot;, ufunc_gammaincinv_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_gammaln_loops[2]</span>
<span class="s0">cdef void *ufunc_gammaln_ptr[4]</span>
<span class="s0">cdef void *ufunc_gammaln_data[2]</span>
<span class="s0">cdef char ufunc_gammaln_types[4]</span>
<span class="s0">cdef char *ufunc_gammaln_doc = (</span>
    <span class="s0">&quot;gammaln(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Logarithm of the absolute value of the gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;   \\ln(\\lvert\\Gamma(x)\\rvert)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`\\Gamma` is the gamma function. For more details on\n&quot;</span>
    <span class="s0">&quot;the gamma function, see [dlmf]_.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the log of the absolute value of gamma\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;gammasgn : sign of the gamma function\n&quot;</span>
    <span class="s0">&quot;loggamma : principal branch of the logarithm of the gamma function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;It is the same function as the Python standard library function\n&quot;</span>
    <span class="s0">&quot;:func:`math.lgamma`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;When used in conjunction with `gammasgn`, this function is useful\n&quot;</span>
    <span class="s0">&quot;for working in logspace on the real axis without having to deal\n&quot;</span>
    <span class="s0">&quot;with complex numbers via the relation ``exp(gammaln(x)) =\n&quot;</span>
    <span class="s0">&quot;gammasgn(x) * gamma(x)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For complex-valued log-gamma, use `loggamma` instead of `gammaln`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [dlmf] NIST Digital Library of Mathematical Functions\n&quot;</span>
    <span class="s0">&quot;          https://dlmf.nist.gov/5\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It has two positive zeros.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gammaln([1, 2])\n&quot;</span>
    <span class="s0">&quot;array([0., 0.])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It has poles at nonpositive integers.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gammaln([0, -1, -2, -3, -4])\n&quot;</span>
    <span class="s0">&quot;array([inf, inf, inf, inf, inf])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It asymptotically approaches ``x * log(x)`` (Stirling's formula).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.array([1e10, 1e20, 1e40, 1e80])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gammaln(x)\n&quot;</span>
    <span class="s0">&quot;array([2.20258509e+11, 4.50517019e+21, 9.11034037e+41, 1.83206807e+82])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x * np.log(x)\n&quot;</span>
    <span class="s0">&quot;array([2.30258509e+11, 4.60517019e+21, 9.21034037e+41, 1.84206807e+82])&quot;)</span>
<span class="s0">ufunc_gammaln_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_gammaln_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_gammaln_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gammaln_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gammaln_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gammaln_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gammaln_ptr[2*0] = &lt;void*&gt;_func_lgam</span>
<span class="s0">ufunc_gammaln_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gammaln&quot;)</span>
<span class="s0">ufunc_gammaln_ptr[2*1] = &lt;void*&gt;_func_lgam</span>
<span class="s0">ufunc_gammaln_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gammaln&quot;)</span>
<span class="s0">ufunc_gammaln_data[0] = &amp;ufunc_gammaln_ptr[2*0]</span>
<span class="s0">ufunc_gammaln_data[1] = &amp;ufunc_gammaln_ptr[2*1]</span>
<span class="s0">gammaln = np.PyUFunc_FromFuncAndData(ufunc_gammaln_loops, ufunc_gammaln_data, ufunc_gammaln_types, 2, 1, 1, 0, &quot;gammaln&quot;, ufunc_gammaln_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_gammasgn_loops[2]</span>
<span class="s0">cdef void *ufunc_gammasgn_ptr[4]</span>
<span class="s0">cdef void *ufunc_gammasgn_data[2]</span>
<span class="s0">cdef char ufunc_gammasgn_types[4]</span>
<span class="s0">cdef char *ufunc_gammasgn_doc = (</span>
    <span class="s0">&quot;gammasgn(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Sign of the gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;   \\text{gammasgn}(x) =\n&quot;</span>
    <span class="s0">&quot;   \\begin{cases}\n&quot;</span>
    <span class="s0">&quot;     +1 &amp; \\Gamma(x) &gt; 0 \\\\\n&quot;</span>
    <span class="s0">&quot;     -1 &amp; \\Gamma(x) &lt; 0\n&quot;</span>
    <span class="s0">&quot;   \\end{cases}\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`\\Gamma` is the gamma function; see `gamma`. This\n&quot;</span>
    <span class="s0">&quot;definition is complete since the gamma function is never zero;\n&quot;</span>
    <span class="s0">&quot;see the discussion after [dlmf]_.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Sign of the gamma function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The gamma function can be computed as ``gammasgn(x) *\n&quot;</span>
    <span class="s0">&quot;np.exp(gammaln(x))``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;gamma : the gamma function\n&quot;</span>
    <span class="s0">&quot;gammaln : log of the absolute value of the gamma function\n&quot;</span>
    <span class="s0">&quot;loggamma : analytic continuation of the log of the gamma function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [dlmf] NIST Digital Library of Mathematical Functions\n&quot;</span>
    <span class="s0">&quot;          https://dlmf.nist.gov/5.2#E1\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is 1 for `x &gt; 0`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gammasgn([1, 2, 3, 4])\n&quot;</span>
    <span class="s0">&quot;array([1., 1., 1., 1.])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It alternates between -1 and 1 for negative integers.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gammasgn([-0.5, -1.5, -2.5, -3.5])\n&quot;</span>
    <span class="s0">&quot;array([-1.,  1., -1.,  1.])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It can be used to compute the gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = [1.5, 0.5, -0.5, -1.5]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gammasgn(x) * np.exp(sc.gammaln(x))\n&quot;</span>
    <span class="s0">&quot;array([ 0.88622693,  1.77245385, -3.5449077 ,  2.3632718 ])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gamma(x)\n&quot;</span>
    <span class="s0">&quot;array([ 0.88622693,  1.77245385, -3.5449077 ,  2.3632718 ])&quot;)</span>
<span class="s0">ufunc_gammasgn_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_gammasgn_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_gammasgn_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gammasgn_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gammasgn_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gammasgn_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gammasgn_ptr[2*0] = &lt;void*&gt;_func_gammasgn</span>
<span class="s0">ufunc_gammasgn_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gammasgn&quot;)</span>
<span class="s0">ufunc_gammasgn_ptr[2*1] = &lt;void*&gt;_func_gammasgn</span>
<span class="s0">ufunc_gammasgn_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gammasgn&quot;)</span>
<span class="s0">ufunc_gammasgn_data[0] = &amp;ufunc_gammasgn_ptr[2*0]</span>
<span class="s0">ufunc_gammasgn_data[1] = &amp;ufunc_gammasgn_ptr[2*1]</span>
<span class="s0">gammasgn = np.PyUFunc_FromFuncAndData(ufunc_gammasgn_loops, ufunc_gammasgn_data, ufunc_gammasgn_types, 2, 1, 1, 0, &quot;gammasgn&quot;, ufunc_gammasgn_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_gdtr_loops[2]</span>
<span class="s0">cdef void *ufunc_gdtr_ptr[4]</span>
<span class="s0">cdef void *ufunc_gdtr_data[2]</span>
<span class="s0">cdef char ufunc_gdtr_types[8]</span>
<span class="s0">cdef char *ufunc_gdtr_doc = (</span>
    <span class="s0">&quot;gdtr(a, b, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Gamma distribution cumulative distribution function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the integral from zero to `x` of the gamma probability density\n&quot;</span>
    <span class="s0">&quot;function,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    F = \\int_0^x \\frac{a^b}{\\Gamma(b)} t^{b-1} e^{-at}\\,dt,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`\\Gamma` is the gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a : array_like\n&quot;</span>
    <span class="s0">&quot;    The rate parameter of the gamma distribution, sometimes denoted\n&quot;</span>
    <span class="s0">&quot;    :math:`\\beta` (float).  It is also the reciprocal of the scale\n&quot;</span>
    <span class="s0">&quot;    parameter :math:`\\theta`.\n&quot;</span>
    <span class="s0">&quot;b : array_like\n&quot;</span>
    <span class="s0">&quot;    The shape parameter of the gamma distribution, sometimes denoted\n&quot;</span>
    <span class="s0">&quot;    :math:`\\alpha` (float).\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    The quantile (upper limit of integration; float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;gdtrc : 1 - CDF of the gamma distribution.\n&quot;</span>
    <span class="s0">&quot;scipy.stats.gamma: Gamma distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;F : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The CDF of the gamma distribution with parameters `a` and `b`\n&quot;</span>
    <span class="s0">&quot;    evaluated at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The evaluation is carried out using the relation to the incomplete gamma\n&quot;</span>
    <span class="s0">&quot;integral (regularized gamma function).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `gdtr`. Calling `gdtr` directly can\n&quot;</span>
    <span class="s0">&quot;improve performance compared to the ``cdf`` method of `scipy.stats.gamma`\n&quot;</span>
    <span class="s0">&quot;(see last example below).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Compute the function for ``a=1``, ``b=2`` at ``x=5``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import gdtr\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gdtr(1., 2., 5.)\n&quot;</span>
    <span class="s0">&quot;0.9595723180054873\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the function for ``a=1`` and ``b=2`` at several points by\n&quot;</span>
    <span class="s0">&quot;providing a NumPy array for `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; xvalues = np.array([1., 2., 3., 4])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gdtr(1., 1., xvalues)\n&quot;</span>
    <span class="s0">&quot;array([0.63212056, 0.86466472, 0.95021293, 0.98168436])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;`gdtr` can evaluate different parameter sets by providing arrays with\n&quot;</span>
    <span class="s0">&quot;broadcasting compatible shapes for `a`, `b` and `x`. Here we compute the\n&quot;</span>
    <span class="s0">&quot;function for three different `a` at four positions `x` and ``b=3``,\n&quot;</span>
    <span class="s0">&quot;resulting in a 3x4 array.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a = np.array([[0.5], [1.5], [2.5]])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.array([1., 2., 3., 4])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a.shape, x.shape\n&quot;</span>
    <span class="s0">&quot;((3, 1), (4,))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gdtr(a, 3., x)\n&quot;</span>
    <span class="s0">&quot;array([[0.01438768, 0.0803014 , 0.19115317, 0.32332358],\n&quot;</span>
    <span class="s0">&quot;       [0.19115317, 0.57680992, 0.82642193, 0.9380312 ],\n&quot;</span>
    <span class="s0">&quot;       [0.45618688, 0.87534798, 0.97974328, 0.9972306 ]])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function for four different parameter sets.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a_parameters = [0.3, 1, 2, 6]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; b_parameters = [2, 10, 15, 20]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; parameters_list = list(zip(a_parameters, b_parameters, linestyles))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0, 30, 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for parameter_set in parameters_list:\n&quot;</span>
    <span class="s0">&quot;...     a, b, style = parameter_set\n&quot;</span>
    <span class="s0">&quot;...     gdtr_vals = gdtr(a, b, x)\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, gdtr_vals, label=f\&quot;$a= {a},\\, b={b}$\&quot;, ls=style)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel(\&quot;$x$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(\&quot;Gamma distribution cumulative distribution function\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The gamma distribution is also available as `scipy.stats.gamma`. Using\n&quot;</span>
    <span class="s0">&quot;`gdtr` directly can be much faster than calling the ``cdf`` method of\n&quot;</span>
    <span class="s0">&quot;`scipy.stats.gamma`, especially for small arrays or individual values.\n&quot;</span>
    <span class="s0">&quot;To get the same results one must use the following parametrization:\n&quot;</span>
    <span class="s0">&quot;``stats.gamma(b, scale=1/a).cdf(x)=gdtr(a, b, x)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.stats import gamma\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a = 2.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; b = 3\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 1.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gdtr_result = gdtr(a, b, x)  # this will often be faster than below\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gamma_dist_result = gamma(b, scale=1/a).cdf(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gdtr_result == gamma_dist_result  # test that results are equal\n&quot;</span>
    <span class="s0">&quot;True&quot;)</span>
<span class="s0">ufunc_gdtr_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_gdtr_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_gdtr_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtr_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtr_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtr_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtr_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtr_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtr_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtr_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtr_ptr[2*0] = &lt;void*&gt;_func_gdtr</span>
<span class="s0">ufunc_gdtr_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gdtr&quot;)</span>
<span class="s0">ufunc_gdtr_ptr[2*1] = &lt;void*&gt;_func_gdtr</span>
<span class="s0">ufunc_gdtr_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gdtr&quot;)</span>
<span class="s0">ufunc_gdtr_data[0] = &amp;ufunc_gdtr_ptr[2*0]</span>
<span class="s0">ufunc_gdtr_data[1] = &amp;ufunc_gdtr_ptr[2*1]</span>
<span class="s0">gdtr = np.PyUFunc_FromFuncAndData(ufunc_gdtr_loops, ufunc_gdtr_data, ufunc_gdtr_types, 2, 3, 1, 0, &quot;gdtr&quot;, ufunc_gdtr_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_gdtrc_loops[2]</span>
<span class="s0">cdef void *ufunc_gdtrc_ptr[4]</span>
<span class="s0">cdef void *ufunc_gdtrc_data[2]</span>
<span class="s0">cdef char ufunc_gdtrc_types[8]</span>
<span class="s0">cdef char *ufunc_gdtrc_doc = (</span>
    <span class="s0">&quot;gdtrc(a, b, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Gamma distribution survival function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Integral from `x` to infinity of the gamma probability density function,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    F = \\int_x^\\infty \\frac{a^b}{\\Gamma(b)} t^{b-1} e^{-at}\\,dt,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`\\Gamma` is the gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a : array_like\n&quot;</span>
    <span class="s0">&quot;    The rate parameter of the gamma distribution, sometimes denoted\n&quot;</span>
    <span class="s0">&quot;    :math:`\\beta` (float). It is also the reciprocal of the scale\n&quot;</span>
    <span class="s0">&quot;    parameter :math:`\\theta`.\n&quot;</span>
    <span class="s0">&quot;b : array_like\n&quot;</span>
    <span class="s0">&quot;    The shape parameter of the gamma distribution, sometimes denoted\n&quot;</span>
    <span class="s0">&quot;    :math:`\\alpha` (float).\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    The quantile (lower limit of integration; float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;F : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The survival function of the gamma distribution with parameters `a`\n&quot;</span>
    <span class="s0">&quot;    and `b` evaluated at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;gdtr: Gamma distribution cumulative distribution function\n&quot;</span>
    <span class="s0">&quot;scipy.stats.gamma: Gamma distribution\n&quot;</span>
    <span class="s0">&quot;gdtrix\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The evaluation is carried out using the relation to the incomplete gamma\n&quot;</span>
    <span class="s0">&quot;integral (regularized gamma function).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `gdtrc`. Calling `gdtrc` directly can\n&quot;</span>
    <span class="s0">&quot;improve performance compared to the ``sf`` method of `scipy.stats.gamma`\n&quot;</span>
    <span class="s0">&quot;(see last example below).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Compute the function for ``a=1`` and ``b=2`` at ``x=5``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import gdtrc\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gdtrc(1., 2., 5.)\n&quot;</span>
    <span class="s0">&quot;0.04042768199451279\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the function for ``a=1``, ``b=2`` at several points by providing\n&quot;</span>
    <span class="s0">&quot;a NumPy array for `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; xvalues = np.array([1., 2., 3., 4])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gdtrc(1., 1., xvalues)\n&quot;</span>
    <span class="s0">&quot;array([0.36787944, 0.13533528, 0.04978707, 0.01831564])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;`gdtrc` can evaluate different parameter sets by providing arrays with\n&quot;</span>
    <span class="s0">&quot;broadcasting compatible shapes for `a`, `b` and `x`. Here we compute the\n&quot;</span>
    <span class="s0">&quot;function for three different `a` at four positions `x` and ``b=3``,\n&quot;</span>
    <span class="s0">&quot;resulting in a 3x4 array.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a = np.array([[0.5], [1.5], [2.5]])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.array([1., 2., 3., 4])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a.shape, x.shape\n&quot;</span>
    <span class="s0">&quot;((3, 1), (4,))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gdtrc(a, 3., x)\n&quot;</span>
    <span class="s0">&quot;array([[0.98561232, 0.9196986 , 0.80884683, 0.67667642],\n&quot;</span>
    <span class="s0">&quot;       [0.80884683, 0.42319008, 0.17357807, 0.0619688 ],\n&quot;</span>
    <span class="s0">&quot;       [0.54381312, 0.12465202, 0.02025672, 0.0027694 ]])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function for four different parameter sets.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a_parameters = [0.3, 1, 2, 6]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; b_parameters = [2, 10, 15, 20]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; parameters_list = list(zip(a_parameters, b_parameters, linestyles))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0, 30, 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for parameter_set in parameters_list:\n&quot;</span>
    <span class="s0">&quot;...     a, b, style = parameter_set\n&quot;</span>
    <span class="s0">&quot;...     gdtrc_vals = gdtrc(a, b, x)\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, gdtrc_vals, label=f\&quot;$a= {a},\\, b={b}$\&quot;, ls=style)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel(\&quot;$x$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(\&quot;Gamma distribution survival function\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The gamma distribution is also available as `scipy.stats.gamma`.\n&quot;</span>
    <span class="s0">&quot;Using `gdtrc` directly can be much faster than calling the ``sf`` method\n&quot;</span>
    <span class="s0">&quot;of `scipy.stats.gamma`, especially for small arrays or individual\n&quot;</span>
    <span class="s0">&quot;values. To get the same results one must use the following parametrization:\n&quot;</span>
    <span class="s0">&quot;``stats.gamma(b, scale=1/a).sf(x)=gdtrc(a, b, x)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.stats import gamma\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a = 2\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; b = 3\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 1.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gdtrc_result = gdtrc(a, b, x)  # this will often be faster than below\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gamma_dist_result = gamma(b, scale=1/a).sf(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gdtrc_result == gamma_dist_result  # test that results are equal\n&quot;</span>
    <span class="s0">&quot;True&quot;)</span>
<span class="s0">ufunc_gdtrc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_gdtrc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_gdtrc_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtrc_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtrc_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtrc_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtrc_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtrc_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtrc_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtrc_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtrc_ptr[2*0] = &lt;void*&gt;_func_gdtrc</span>
<span class="s0">ufunc_gdtrc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gdtrc&quot;)</span>
<span class="s0">ufunc_gdtrc_ptr[2*1] = &lt;void*&gt;_func_gdtrc</span>
<span class="s0">ufunc_gdtrc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gdtrc&quot;)</span>
<span class="s0">ufunc_gdtrc_data[0] = &amp;ufunc_gdtrc_ptr[2*0]</span>
<span class="s0">ufunc_gdtrc_data[1] = &amp;ufunc_gdtrc_ptr[2*1]</span>
<span class="s0">gdtrc = np.PyUFunc_FromFuncAndData(ufunc_gdtrc_loops, ufunc_gdtrc_data, ufunc_gdtrc_types, 2, 3, 1, 0, &quot;gdtrc&quot;, ufunc_gdtrc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_gdtria_loops[2]</span>
<span class="s0">cdef void *ufunc_gdtria_ptr[4]</span>
<span class="s0">cdef void *ufunc_gdtria_data[2]</span>
<span class="s0">cdef char ufunc_gdtria_types[8]</span>
<span class="s0">cdef char *ufunc_gdtria_doc = (</span>
    <span class="s0">&quot;gdtria(p, b, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse of `gdtr` vs a.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the inverse with respect to the parameter `a` of ``p =\n&quot;</span>
    <span class="s0">&quot;gdtr(a, b, x)``, the cumulative distribution function of the gamma\n&quot;</span>
    <span class="s0">&quot;distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability values.\n&quot;</span>
    <span class="s0">&quot;b : array_like\n&quot;</span>
    <span class="s0">&quot;    `b` parameter values of `gdtr(a, b, x)`. `b` is the \&quot;shape\&quot; parameter\n&quot;</span>
    <span class="s0">&quot;    of the gamma distribution.\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Nonnegative real values, from the domain of the gamma distribution.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    If a fourth argument is given, it must be a numpy.ndarray whose size\n&quot;</span>
    <span class="s0">&quot;    matches the broadcast result of `a`, `b` and `x`.  `out` is then the\n&quot;</span>
    <span class="s0">&quot;    array returned by the function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;a : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the `a` parameter such that `p = gdtr(a, b, x)`.  `1/a`\n&quot;</span>
    <span class="s0">&quot;    is the \&quot;scale\&quot; parameter of the gamma distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;gdtr : CDF of the gamma distribution.\n&quot;</span>
    <span class="s0">&quot;gdtrib : Inverse with respect to `b` of `gdtr(a, b, x)`.\n&quot;</span>
    <span class="s0">&quot;gdtrix : Inverse with respect to `x` of `gdtr(a, b, x)`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for the CDFLIB [1]_ Fortran routine `cdfgam`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The cumulative distribution function `p` is computed using a routine by\n&quot;</span>
    <span class="s0">&quot;DiDinato and Morris [2]_. Computation of `a` involves a search for a value\n&quot;</span>
    <span class="s0">&quot;that produces the desired value of `p`. The search relies on the\n&quot;</span>
    <span class="s0">&quot;monotonicity of `p` with `a`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Barry Brown, James Lovato, and Kathy Russell,\n&quot;</span>
    <span class="s0">&quot;       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n&quot;</span>
    <span class="s0">&quot;       Functions, Inverses, and Other Parameters.\n&quot;</span>
    <span class="s0">&quot;.. [2] DiDinato, A. R. and Morris, A. H.,\n&quot;</span>
    <span class="s0">&quot;       Computation of the incomplete gamma function ratios and their\n&quot;</span>
    <span class="s0">&quot;       inverse.  ACM Trans. Math. Softw. 12 (1986), 377-393.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;First evaluate `gdtr`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import gdtr, gdtria\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p = gdtr(1.2, 3.4, 5.6)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; print(p)\n&quot;</span>
    <span class="s0">&quot;0.94378087442\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Verify the inverse.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gdtria(p, 3.4, 5.6)\n&quot;</span>
    <span class="s0">&quot;1.2&quot;)</span>
<span class="s0">ufunc_gdtria_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_gdtria_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_gdtria_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtria_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtria_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtria_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtria_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtria_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtria_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtria_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtria_ptr[2*0] = &lt;void*&gt;_func_cdfgam4_wrap</span>
<span class="s0">ufunc_gdtria_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gdtria&quot;)</span>
<span class="s0">ufunc_gdtria_ptr[2*1] = &lt;void*&gt;_func_cdfgam4_wrap</span>
<span class="s0">ufunc_gdtria_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gdtria&quot;)</span>
<span class="s0">ufunc_gdtria_data[0] = &amp;ufunc_gdtria_ptr[2*0]</span>
<span class="s0">ufunc_gdtria_data[1] = &amp;ufunc_gdtria_ptr[2*1]</span>
<span class="s0">gdtria = np.PyUFunc_FromFuncAndData(ufunc_gdtria_loops, ufunc_gdtria_data, ufunc_gdtria_types, 2, 3, 1, 0, &quot;gdtria&quot;, ufunc_gdtria_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_gdtrib_loops[2]</span>
<span class="s0">cdef void *ufunc_gdtrib_ptr[4]</span>
<span class="s0">cdef void *ufunc_gdtrib_data[2]</span>
<span class="s0">cdef char ufunc_gdtrib_types[8]</span>
<span class="s0">cdef char *ufunc_gdtrib_doc = (</span>
    <span class="s0">&quot;gdtrib(a, p, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse of `gdtr` vs b.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the inverse with respect to the parameter `b` of ``p =\n&quot;</span>
    <span class="s0">&quot;gdtr(a, b, x)``, the cumulative distribution function of the gamma\n&quot;</span>
    <span class="s0">&quot;distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a : array_like\n&quot;</span>
    <span class="s0">&quot;    `a` parameter values of `gdtr(a, b, x)`. `1/a` is the \&quot;scale\&quot;\n&quot;</span>
    <span class="s0">&quot;    parameter of the gamma distribution.\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability values.\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Nonnegative real values, from the domain of the gamma distribution.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    If a fourth argument is given, it must be a numpy.ndarray whose size\n&quot;</span>
    <span class="s0">&quot;    matches the broadcast result of `a`, `b` and `x`.  `out` is then the\n&quot;</span>
    <span class="s0">&quot;    array returned by the function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;b : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the `b` parameter such that `p = gdtr(a, b, x)`.  `b` is\n&quot;</span>
    <span class="s0">&quot;    the \&quot;shape\&quot; parameter of the gamma distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;gdtr : CDF of the gamma distribution.\n&quot;</span>
    <span class="s0">&quot;gdtria : Inverse with respect to `a` of `gdtr(a, b, x)`.\n&quot;</span>
    <span class="s0">&quot;gdtrix : Inverse with respect to `x` of `gdtr(a, b, x)`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for the CDFLIB [1]_ Fortran routine `cdfgam`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The cumulative distribution function `p` is computed using a routine by\n&quot;</span>
    <span class="s0">&quot;DiDinato and Morris [2]_. Computation of `b` involves a search for a value\n&quot;</span>
    <span class="s0">&quot;that produces the desired value of `p`. The search relies on the\n&quot;</span>
    <span class="s0">&quot;monotonicity of `p` with `b`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Barry Brown, James Lovato, and Kathy Russell,\n&quot;</span>
    <span class="s0">&quot;       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n&quot;</span>
    <span class="s0">&quot;       Functions, Inverses, and Other Parameters.\n&quot;</span>
    <span class="s0">&quot;.. [2] DiDinato, A. R. and Morris, A. H.,\n&quot;</span>
    <span class="s0">&quot;       Computation of the incomplete gamma function ratios and their\n&quot;</span>
    <span class="s0">&quot;       inverse.  ACM Trans. Math. Softw. 12 (1986), 377-393.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;First evaluate `gdtr`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import gdtr, gdtrib\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p = gdtr(1.2, 3.4, 5.6)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; print(p)\n&quot;</span>
    <span class="s0">&quot;0.94378087442\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Verify the inverse.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gdtrib(1.2, p, 5.6)\n&quot;</span>
    <span class="s0">&quot;3.3999999999723882&quot;)</span>
<span class="s0">ufunc_gdtrib_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_gdtrib_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_gdtrib_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtrib_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtrib_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtrib_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtrib_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtrib_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtrib_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtrib_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtrib_ptr[2*0] = &lt;void*&gt;_func_cdfgam3_wrap</span>
<span class="s0">ufunc_gdtrib_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gdtrib&quot;)</span>
<span class="s0">ufunc_gdtrib_ptr[2*1] = &lt;void*&gt;_func_cdfgam3_wrap</span>
<span class="s0">ufunc_gdtrib_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gdtrib&quot;)</span>
<span class="s0">ufunc_gdtrib_data[0] = &amp;ufunc_gdtrib_ptr[2*0]</span>
<span class="s0">ufunc_gdtrib_data[1] = &amp;ufunc_gdtrib_ptr[2*1]</span>
<span class="s0">gdtrib = np.PyUFunc_FromFuncAndData(ufunc_gdtrib_loops, ufunc_gdtrib_data, ufunc_gdtrib_types, 2, 3, 1, 0, &quot;gdtrib&quot;, ufunc_gdtrib_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_gdtrix_loops[2]</span>
<span class="s0">cdef void *ufunc_gdtrix_ptr[4]</span>
<span class="s0">cdef void *ufunc_gdtrix_data[2]</span>
<span class="s0">cdef char ufunc_gdtrix_types[8]</span>
<span class="s0">cdef char *ufunc_gdtrix_doc = (</span>
    <span class="s0">&quot;gdtrix(a, b, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse of `gdtr` vs x.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the inverse with respect to the parameter `x` of ``p =\n&quot;</span>
    <span class="s0">&quot;gdtr(a, b, x)``, the cumulative distribution function of the gamma\n&quot;</span>
    <span class="s0">&quot;distribution. This is also known as the pth quantile of the\n&quot;</span>
    <span class="s0">&quot;distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a : array_like\n&quot;</span>
    <span class="s0">&quot;    `a` parameter values of `gdtr(a, b, x)`. `1/a` is the \&quot;scale\&quot;\n&quot;</span>
    <span class="s0">&quot;    parameter of the gamma distribution.\n&quot;</span>
    <span class="s0">&quot;b : array_like\n&quot;</span>
    <span class="s0">&quot;    `b` parameter values of `gdtr(a, b, x)`. `b` is the \&quot;shape\&quot; parameter\n&quot;</span>
    <span class="s0">&quot;    of the gamma distribution.\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability values.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    If a fourth argument is given, it must be a numpy.ndarray whose size\n&quot;</span>
    <span class="s0">&quot;    matches the broadcast result of `a`, `b` and `x`. `out` is then the\n&quot;</span>
    <span class="s0">&quot;    array returned by the function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;x : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the `x` parameter such that `p = gdtr(a, b, x)`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;gdtr : CDF of the gamma distribution.\n&quot;</span>
    <span class="s0">&quot;gdtria : Inverse with respect to `a` of `gdtr(a, b, x)`.\n&quot;</span>
    <span class="s0">&quot;gdtrib : Inverse with respect to `b` of `gdtr(a, b, x)`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for the CDFLIB [1]_ Fortran routine `cdfgam`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The cumulative distribution function `p` is computed using a routine by\n&quot;</span>
    <span class="s0">&quot;DiDinato and Morris [2]_. Computation of `x` involves a search for a value\n&quot;</span>
    <span class="s0">&quot;that produces the desired value of `p`. The search relies on the\n&quot;</span>
    <span class="s0">&quot;monotonicity of `p` with `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Barry Brown, James Lovato, and Kathy Russell,\n&quot;</span>
    <span class="s0">&quot;       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n&quot;</span>
    <span class="s0">&quot;       Functions, Inverses, and Other Parameters.\n&quot;</span>
    <span class="s0">&quot;.. [2] DiDinato, A. R. and Morris, A. H.,\n&quot;</span>
    <span class="s0">&quot;       Computation of the incomplete gamma function ratios and their\n&quot;</span>
    <span class="s0">&quot;       inverse.  ACM Trans. Math. Softw. 12 (1986), 377-393.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;First evaluate `gdtr`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import gdtr, gdtrix\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p = gdtr(1.2, 3.4, 5.6)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; print(p)\n&quot;</span>
    <span class="s0">&quot;0.94378087442\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Verify the inverse.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gdtrix(1.2, 3.4, p)\n&quot;</span>
    <span class="s0">&quot;5.5999999999999996&quot;)</span>
<span class="s0">ufunc_gdtrix_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_gdtrix_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_gdtrix_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtrix_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtrix_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtrix_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_gdtrix_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtrix_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtrix_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtrix_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_gdtrix_ptr[2*0] = &lt;void*&gt;_func_cdfgam2_wrap</span>
<span class="s0">ufunc_gdtrix_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gdtrix&quot;)</span>
<span class="s0">ufunc_gdtrix_ptr[2*1] = &lt;void*&gt;_func_cdfgam2_wrap</span>
<span class="s0">ufunc_gdtrix_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;gdtrix&quot;)</span>
<span class="s0">ufunc_gdtrix_data[0] = &amp;ufunc_gdtrix_ptr[2*0]</span>
<span class="s0">ufunc_gdtrix_data[1] = &amp;ufunc_gdtrix_ptr[2*1]</span>
<span class="s0">gdtrix = np.PyUFunc_FromFuncAndData(ufunc_gdtrix_loops, ufunc_gdtrix_data, ufunc_gdtrix_types, 2, 3, 1, 0, &quot;gdtrix&quot;, ufunc_gdtrix_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_hankel1_loops[2]</span>
<span class="s0">cdef void *ufunc_hankel1_ptr[4]</span>
<span class="s0">cdef void *ufunc_hankel1_data[2]</span>
<span class="s0">cdef char ufunc_hankel1_types[6]</span>
<span class="s0">cdef char *ufunc_hankel1_doc = (</span>
    <span class="s0">&quot;hankel1(v, z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Hankel function of the first kind\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;v : array_like\n&quot;</span>
    <span class="s0">&quot;    Order (float).\n&quot;</span>
    <span class="s0">&quot;z : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float or complex).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Hankel function of the first kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;A wrapper for the AMOS [1]_ routine `zbesh`, which carries out the\n&quot;</span>
    <span class="s0">&quot;computation using the relation,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: H^{(1)}_v(z) = \\frac{2}{\\imath\\pi} \\exp(-\\imath \\pi v/2) K_v(z \\exp(-\\imath\\pi/2))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`K_v` is the modified Bessel function of the second kind.\n&quot;</span>
    <span class="s0">&quot;For negative orders, the relation\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: H^{(1)}_{-v}(z) = H^{(1)}_v(z) \\exp(\\imath\\pi v)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;is used.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;hankel1e : ndarray\n&quot;</span>
    <span class="s0">&quot;    This function with leading exponential behavior stripped off.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Donald E. Amos, \&quot;AMOS, A Portable Package for Bessel Functions\n&quot;</span>
    <span class="s0">&quot;       of a Complex Argument and Nonnegative Order\&quot;,\n&quot;</span>
    <span class="s0">&quot;       http://netlib.org/amos/&quot;)</span>
<span class="s0">ufunc_hankel1_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_fF_F</span>
<span class="s0">ufunc_hankel1_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_dD_D</span>
<span class="s0">ufunc_hankel1_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hankel1_types[1] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_hankel1_types[2] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_hankel1_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hankel1_types[4] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_hankel1_types[5] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_hankel1_ptr[2*0] = &lt;void*&gt;_func_cbesh_wrap1</span>
<span class="s0">ufunc_hankel1_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;hankel1&quot;)</span>
<span class="s0">ufunc_hankel1_ptr[2*1] = &lt;void*&gt;_func_cbesh_wrap1</span>
<span class="s0">ufunc_hankel1_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;hankel1&quot;)</span>
<span class="s0">ufunc_hankel1_data[0] = &amp;ufunc_hankel1_ptr[2*0]</span>
<span class="s0">ufunc_hankel1_data[1] = &amp;ufunc_hankel1_ptr[2*1]</span>
<span class="s0">hankel1 = np.PyUFunc_FromFuncAndData(ufunc_hankel1_loops, ufunc_hankel1_data, ufunc_hankel1_types, 2, 2, 1, 0, &quot;hankel1&quot;, ufunc_hankel1_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_hankel1e_loops[2]</span>
<span class="s0">cdef void *ufunc_hankel1e_ptr[4]</span>
<span class="s0">cdef void *ufunc_hankel1e_data[2]</span>
<span class="s0">cdef char ufunc_hankel1e_types[6]</span>
<span class="s0">cdef char *ufunc_hankel1e_doc = (</span>
    <span class="s0">&quot;hankel1e(v, z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Exponentially scaled Hankel function of the first kind\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined as::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    hankel1e(v, z) = hankel1(v, z) * exp(-1j * z)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;v : array_like\n&quot;</span>
    <span class="s0">&quot;    Order (float).\n&quot;</span>
    <span class="s0">&quot;z : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float or complex).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the exponentially scaled Hankel function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;A wrapper for the AMOS [1]_ routine `zbesh`, which carries out the\n&quot;</span>
    <span class="s0">&quot;computation using the relation,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: H^{(1)}_v(z) = \\frac{2}{\\imath\\pi} \\exp(-\\imath \\pi v/2) K_v(z \\exp(-\\imath\\pi/2))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`K_v` is the modified Bessel function of the second kind.\n&quot;</span>
    <span class="s0">&quot;For negative orders, the relation\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: H^{(1)}_{-v}(z) = H^{(1)}_v(z) \\exp(\\imath\\pi v)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;is used.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Donald E. Amos, \&quot;AMOS, A Portable Package for Bessel Functions\n&quot;</span>
    <span class="s0">&quot;       of a Complex Argument and Nonnegative Order\&quot;,\n&quot;</span>
    <span class="s0">&quot;       http://netlib.org/amos/&quot;)</span>
<span class="s0">ufunc_hankel1e_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_fF_F</span>
<span class="s0">ufunc_hankel1e_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_dD_D</span>
<span class="s0">ufunc_hankel1e_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hankel1e_types[1] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_hankel1e_types[2] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_hankel1e_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hankel1e_types[4] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_hankel1e_types[5] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_hankel1e_ptr[2*0] = &lt;void*&gt;_func_cbesh_wrap1_e</span>
<span class="s0">ufunc_hankel1e_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;hankel1e&quot;)</span>
<span class="s0">ufunc_hankel1e_ptr[2*1] = &lt;void*&gt;_func_cbesh_wrap1_e</span>
<span class="s0">ufunc_hankel1e_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;hankel1e&quot;)</span>
<span class="s0">ufunc_hankel1e_data[0] = &amp;ufunc_hankel1e_ptr[2*0]</span>
<span class="s0">ufunc_hankel1e_data[1] = &amp;ufunc_hankel1e_ptr[2*1]</span>
<span class="s0">hankel1e = np.PyUFunc_FromFuncAndData(ufunc_hankel1e_loops, ufunc_hankel1e_data, ufunc_hankel1e_types, 2, 2, 1, 0, &quot;hankel1e&quot;, ufunc_hankel1e_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_hankel2_loops[2]</span>
<span class="s0">cdef void *ufunc_hankel2_ptr[4]</span>
<span class="s0">cdef void *ufunc_hankel2_data[2]</span>
<span class="s0">cdef char ufunc_hankel2_types[6]</span>
<span class="s0">cdef char *ufunc_hankel2_doc = (</span>
    <span class="s0">&quot;hankel2(v, z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Hankel function of the second kind\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;v : array_like\n&quot;</span>
    <span class="s0">&quot;    Order (float).\n&quot;</span>
    <span class="s0">&quot;z : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float or complex).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Hankel function of the second kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;A wrapper for the AMOS [1]_ routine `zbesh`, which carries out the\n&quot;</span>
    <span class="s0">&quot;computation using the relation,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: H^{(2)}_v(z) = -\\frac{2}{\\imath\\pi} \\exp(\\imath \\pi v/2) K_v(z \\exp(\\imath\\pi/2))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`K_v` is the modified Bessel function of the second kind.\n&quot;</span>
    <span class="s0">&quot;For negative orders, the relation\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: H^{(2)}_{-v}(z) = H^{(2)}_v(z) \\exp(-\\imath\\pi v)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;is used.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;hankel2e : this function with leading exponential behavior stripped off.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Donald E. Amos, \&quot;AMOS, A Portable Package for Bessel Functions\n&quot;</span>
    <span class="s0">&quot;       of a Complex Argument and Nonnegative Order\&quot;,\n&quot;</span>
    <span class="s0">&quot;       http://netlib.org/amos/&quot;)</span>
<span class="s0">ufunc_hankel2_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_fF_F</span>
<span class="s0">ufunc_hankel2_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_dD_D</span>
<span class="s0">ufunc_hankel2_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hankel2_types[1] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_hankel2_types[2] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_hankel2_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hankel2_types[4] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_hankel2_types[5] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_hankel2_ptr[2*0] = &lt;void*&gt;_func_cbesh_wrap2</span>
<span class="s0">ufunc_hankel2_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;hankel2&quot;)</span>
<span class="s0">ufunc_hankel2_ptr[2*1] = &lt;void*&gt;_func_cbesh_wrap2</span>
<span class="s0">ufunc_hankel2_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;hankel2&quot;)</span>
<span class="s0">ufunc_hankel2_data[0] = &amp;ufunc_hankel2_ptr[2*0]</span>
<span class="s0">ufunc_hankel2_data[1] = &amp;ufunc_hankel2_ptr[2*1]</span>
<span class="s0">hankel2 = np.PyUFunc_FromFuncAndData(ufunc_hankel2_loops, ufunc_hankel2_data, ufunc_hankel2_types, 2, 2, 1, 0, &quot;hankel2&quot;, ufunc_hankel2_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_hankel2e_loops[2]</span>
<span class="s0">cdef void *ufunc_hankel2e_ptr[4]</span>
<span class="s0">cdef void *ufunc_hankel2e_data[2]</span>
<span class="s0">cdef char ufunc_hankel2e_types[6]</span>
<span class="s0">cdef char *ufunc_hankel2e_doc = (</span>
    <span class="s0">&quot;hankel2e(v, z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Exponentially scaled Hankel function of the second kind\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined as::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    hankel2e(v, z) = hankel2(v, z) * exp(1j * z)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;v : array_like\n&quot;</span>
    <span class="s0">&quot;    Order (float).\n&quot;</span>
    <span class="s0">&quot;z : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float or complex).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the exponentially scaled Hankel function of the second kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;A wrapper for the AMOS [1]_ routine `zbesh`, which carries out the\n&quot;</span>
    <span class="s0">&quot;computation using the relation,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: H^{(2)}_v(z) = -\\frac{2}{\\imath\\pi} \\exp(\\frac{\\imath \\pi v}{2}) K_v(z exp(\\frac{\\imath\\pi}{2}))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`K_v` is the modified Bessel function of the second kind.\n&quot;</span>
    <span class="s0">&quot;For negative orders, the relation\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: H^{(2)}_{-v}(z) = H^{(2)}_v(z) \\exp(-\\imath\\pi v)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;is used.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Donald E. Amos, \&quot;AMOS, A Portable Package for Bessel Functions\n&quot;</span>
    <span class="s0">&quot;       of a Complex Argument and Nonnegative Order\&quot;,\n&quot;</span>
    <span class="s0">&quot;       http://netlib.org/amos/&quot;)</span>
<span class="s0">ufunc_hankel2e_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_fF_F</span>
<span class="s0">ufunc_hankel2e_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_dD_D</span>
<span class="s0">ufunc_hankel2e_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hankel2e_types[1] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_hankel2e_types[2] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_hankel2e_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hankel2e_types[4] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_hankel2e_types[5] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_hankel2e_ptr[2*0] = &lt;void*&gt;_func_cbesh_wrap2_e</span>
<span class="s0">ufunc_hankel2e_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;hankel2e&quot;)</span>
<span class="s0">ufunc_hankel2e_ptr[2*1] = &lt;void*&gt;_func_cbesh_wrap2_e</span>
<span class="s0">ufunc_hankel2e_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;hankel2e&quot;)</span>
<span class="s0">ufunc_hankel2e_data[0] = &amp;ufunc_hankel2e_ptr[2*0]</span>
<span class="s0">ufunc_hankel2e_data[1] = &amp;ufunc_hankel2e_ptr[2*1]</span>
<span class="s0">hankel2e = np.PyUFunc_FromFuncAndData(ufunc_hankel2e_loops, ufunc_hankel2e_data, ufunc_hankel2e_types, 2, 2, 1, 0, &quot;hankel2e&quot;, ufunc_hankel2e_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_huber_loops[2]</span>
<span class="s0">cdef void *ufunc_huber_ptr[4]</span>
<span class="s0">cdef void *ufunc_huber_data[2]</span>
<span class="s0">cdef char ufunc_huber_types[6]</span>
<span class="s0">cdef char *ufunc_huber_doc = (</span>
    <span class="s0">&quot;huber(delta, r, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Huber loss function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: \\text{huber}(\\delta, r) = \\begin{cases} \\infty &amp; \\delta &lt; 0  \\\\ \\frac{1}{2}r^2 &amp; 0 \\le \\delta, | r | \\le \\delta \\\\ \\delta ( |r| - \\frac{1}{2}\\delta ) &amp; \\text{otherwise} \\end{cases}\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;delta : ndarray\n&quot;</span>
    <span class="s0">&quot;    Input array, indicating the quadratic vs. linear loss changepoint.\n&quot;</span>
    <span class="s0">&quot;r : ndarray\n&quot;</span>
    <span class="s0">&quot;    Input array, possibly representing residuals.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The computed Huber loss function values.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;pseudo_huber : smooth approximation of this function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;`huber` is useful as a loss function in robust statistics or machine\n&quot;</span>
    <span class="s0">&quot;learning to reduce the influence of outliers as compared to the common\n&quot;</span>
    <span class="s0">&quot;squared error loss, residuals with a magnitude higher than `delta` are\n&quot;</span>
    <span class="s0">&quot;not squared [1]_.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Typically, `r` represents residuals, the difference\n&quot;</span>
    <span class="s0">&quot;between a model prediction and data. Then, for :math:`|r|\\leq\\delta`,\n&quot;</span>
    <span class="s0">&quot;`huber` resembles the squared error and for :math:`|r|&gt;\\delta` the\n&quot;</span>
    <span class="s0">&quot;absolute error. This way, the Huber loss often achieves\n&quot;</span>
    <span class="s0">&quot;a fast convergence in model fitting for small residuals like the squared\n&quot;</span>
    <span class="s0">&quot;error loss function and still reduces the influence of outliers\n&quot;</span>
    <span class="s0">&quot;(:math:`|r|&gt;\\delta`) like the absolute error loss. As :math:`\\delta` is\n&quot;</span>
    <span class="s0">&quot;the cutoff between squared and absolute error regimes, it has\n&quot;</span>
    <span class="s0">&quot;to be tuned carefully for each problem. `huber` is also\n&quot;</span>
    <span class="s0">&quot;convex, making it suitable for gradient based optimization.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 0.15.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Peter Huber. \&quot;Robust Estimation of a Location Parameter\&quot;,\n&quot;</span>
    <span class="s0">&quot;       1964. Annals of Statistics. 53 (1): 73 - 101.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Import all necessary modules.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import huber\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the function for ``delta=1`` at ``r=2``\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; huber(1., 2.)\n&quot;</span>
    <span class="s0">&quot;1.5\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the function for different `delta` by providing a NumPy array or\n&quot;</span>
    <span class="s0">&quot;list for `delta`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; huber([1., 3., 5.], 4.)\n&quot;</span>
    <span class="s0">&quot;array([3.5, 7.5, 8. ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the function at different points by providing a NumPy array or\n&quot;</span>
    <span class="s0">&quot;list for `r`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; huber(2., np.array([1., 1.5, 3.]))\n&quot;</span>
    <span class="s0">&quot;array([0.5  , 1.125, 4.   ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function can be calculated for different `delta` and `r` by\n&quot;</span>
    <span class="s0">&quot;providing arrays for both with compatible shapes for broadcasting.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; r = np.array([1., 2.5, 8., 10.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; deltas = np.array([[1.], [5.], [9.]])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; print(r.shape, deltas.shape)\n&quot;</span>
    <span class="s0">&quot;(4,) (3, 1)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; huber(deltas, r)\n&quot;</span>
    <span class="s0">&quot;array([[ 0.5  ,  2.   ,  7.5  ,  9.5  ],\n&quot;</span>
    <span class="s0">&quot;       [ 0.5  ,  3.125, 27.5  , 37.5  ],\n&quot;</span>
    <span class="s0">&quot;       [ 0.5  ,  3.125, 32.   , 49.5  ]])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function for different `delta`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-4, 4, 500)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; deltas = [1, 2, 3]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; linestyles = [\&quot;dashed\&quot;, \&quot;dotted\&quot;, \&quot;dashdot\&quot;]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; combined_plot_parameters = list(zip(deltas, linestyles))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for delta, style in combined_plot_parameters:\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, huber(delta, x), label=f\&quot;$\\delta={delta}$\&quot;, ls=style)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend(loc=\&quot;upper center\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel(\&quot;$x$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(\&quot;Huber loss function $h_{\\delta}(x)$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlim(-4, 4)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_ylim(0, 8)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_huber_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_huber_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_huber_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_huber_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_huber_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_huber_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_huber_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_huber_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_huber_ptr[2*0] = &lt;void*&gt;_func_huber</span>
<span class="s0">ufunc_huber_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;huber&quot;)</span>
<span class="s0">ufunc_huber_ptr[2*1] = &lt;void*&gt;_func_huber</span>
<span class="s0">ufunc_huber_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;huber&quot;)</span>
<span class="s0">ufunc_huber_data[0] = &amp;ufunc_huber_ptr[2*0]</span>
<span class="s0">ufunc_huber_data[1] = &amp;ufunc_huber_ptr[2*1]</span>
<span class="s0">huber = np.PyUFunc_FromFuncAndData(ufunc_huber_loops, ufunc_huber_data, ufunc_huber_types, 2, 2, 1, 0, &quot;huber&quot;, ufunc_huber_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_hyp0f1_loops[4]</span>
<span class="s0">cdef void *ufunc_hyp0f1_ptr[8]</span>
<span class="s0">cdef void *ufunc_hyp0f1_data[4]</span>
<span class="s0">cdef char ufunc_hyp0f1_types[12]</span>
<span class="s0">cdef char *ufunc_hyp0f1_doc = (</span>
    <span class="s0">&quot;hyp0f1(v, z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Confluent hypergeometric limit function 0F1.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;v : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued parameter\n&quot;</span>
    <span class="s0">&quot;z : array_like\n&quot;</span>
    <span class="s0">&quot;    Real- or complex-valued argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The confluent hypergeometric limit function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;This function is defined as:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: _0F_1(v, z) = \\sum_{k=0}^{\\infty}\\frac{z^k}{(v)_k k!}.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It's also the limit as :math:`q \\to \\infty` of :math:`_1F_1(q; v; z/q)`,\n&quot;</span>
    <span class="s0">&quot;and satisfies the differential equation :math:`f''(z) + vf'(z) =\n&quot;</span>
    <span class="s0">&quot;f(z)`. See [1]_ for more information.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Wolfram MathWorld, \&quot;Confluent Hypergeometric Limit Function\&quot;,\n&quot;</span>
    <span class="s0">&quot;       http://mathworld.wolfram.com/ConfluentHypergeometricLimitFunction.html\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is one when `z` is zero.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.hyp0f1(1, 0)\n&quot;</span>
    <span class="s0">&quot;1.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is the limit of the confluent hypergeometric function as `q`\n&quot;</span>
    <span class="s0">&quot;goes to infinity.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; q = np.array([1, 10, 100, 1000])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; v = 1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z = 1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.hyp1f1(q, v, z / q)\n&quot;</span>
    <span class="s0">&quot;array([2.71828183, 2.31481985, 2.28303778, 2.27992985])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.hyp0f1(v, z)\n&quot;</span>
    <span class="s0">&quot;2.2795853023360673\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is related to Bessel functions.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; n = 1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0, 1, 5)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.jv(n, x)\n&quot;</span>
    <span class="s0">&quot;array([0.        , 0.12402598, 0.24226846, 0.3492436 , 0.44005059])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; (0.5 * x)**n / sc.factorial(n) * sc.hyp0f1(n + 1, -0.25 * x**2)\n&quot;</span>
    <span class="s0">&quot;array([0.        , 0.12402598, 0.24226846, 0.3492436 , 0.44005059])&quot;)</span>
<span class="s0">ufunc_hyp0f1_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_hyp0f1_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_fF_F</span>
<span class="s0">ufunc_hyp0f1_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_hyp0f1_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_dD_D</span>
<span class="s0">ufunc_hyp0f1_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyp0f1_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyp0f1_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyp0f1_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyp0f1_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_hyp0f1_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_hyp0f1_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyp0f1_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyp0f1_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyp0f1_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyp0f1_types[10] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_hyp0f1_types[11] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_hyp0f1_ptr[2*0] = &lt;void*&gt;_func__hyp0f1_real</span>
<span class="s0">ufunc_hyp0f1_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;hyp0f1&quot;)</span>
<span class="s0">ufunc_hyp0f1_ptr[2*1] = &lt;void*&gt;_func__hyp0f1_cmplx</span>
<span class="s0">ufunc_hyp0f1_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;hyp0f1&quot;)</span>
<span class="s0">ufunc_hyp0f1_ptr[2*2] = &lt;void*&gt;_func__hyp0f1_real</span>
<span class="s0">ufunc_hyp0f1_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;hyp0f1&quot;)</span>
<span class="s0">ufunc_hyp0f1_ptr[2*3] = &lt;void*&gt;_func__hyp0f1_cmplx</span>
<span class="s0">ufunc_hyp0f1_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;hyp0f1&quot;)</span>
<span class="s0">ufunc_hyp0f1_data[0] = &amp;ufunc_hyp0f1_ptr[2*0]</span>
<span class="s0">ufunc_hyp0f1_data[1] = &amp;ufunc_hyp0f1_ptr[2*1]</span>
<span class="s0">ufunc_hyp0f1_data[2] = &amp;ufunc_hyp0f1_ptr[2*2]</span>
<span class="s0">ufunc_hyp0f1_data[3] = &amp;ufunc_hyp0f1_ptr[2*3]</span>
<span class="s0">hyp0f1 = np.PyUFunc_FromFuncAndData(ufunc_hyp0f1_loops, ufunc_hyp0f1_data, ufunc_hyp0f1_types, 4, 2, 1, 0, &quot;hyp0f1&quot;, ufunc_hyp0f1_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_hyp1f1_loops[4]</span>
<span class="s0">cdef void *ufunc_hyp1f1_ptr[8]</span>
<span class="s0">cdef void *ufunc_hyp1f1_data[4]</span>
<span class="s0">cdef char ufunc_hyp1f1_types[16]</span>
<span class="s0">cdef char *ufunc_hyp1f1_doc = (</span>
    <span class="s0">&quot;hyp1f1(a, b, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Confluent hypergeometric function 1F1.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The confluent hypergeometric function is defined by the series\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;   {}_1F_1(a; b; x) = \\sum_{k = 0}^\\infty \\frac{(a)_k}{(b)_k k!} x^k.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See [dlmf]_ for more details. Here :math:`(\\cdot)_k` is the\n&quot;</span>
    <span class="s0">&quot;Pochhammer symbol; see `poch`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a, b : array_like\n&quot;</span>
    <span class="s0">&quot;    Real parameters\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real or complex argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the confluent hypergeometric function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;hyperu : another confluent hypergeometric function\n&quot;</span>
    <span class="s0">&quot;hyp0f1 : confluent hypergeometric limit function\n&quot;</span>
    <span class="s0">&quot;hyp2f1 : Gaussian hypergeometric function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [dlmf] NIST Digital Library of Mathematical Functions\n&quot;</span>
    <span class="s0">&quot;          https://dlmf.nist.gov/13.2#E2\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is one when `x` is zero:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.hyp1f1(0.5, 0.5, 0)\n&quot;</span>
    <span class="s0">&quot;1.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is singular when `b` is a nonpositive integer.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.hyp1f1(0.5, -1, 0)\n&quot;</span>
    <span class="s0">&quot;inf\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is a polynomial when `a` is a nonpositive integer.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a, b, x = -1, 0.5, np.array([1.0, 2.0, 3.0, 4.0])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.hyp1f1(a, b, x)\n&quot;</span>
    <span class="s0">&quot;array([-1., -3., -5., -7.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; 1 + (a / b) * x\n&quot;</span>
    <span class="s0">&quot;array([-1., -3., -5., -7.])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It reduces to the exponential function when `a = b`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.hyp1f1(2, 2, [1, 2, 3, 4])\n&quot;</span>
    <span class="s0">&quot;array([ 2.71828183,  7.3890561 , 20.08553692, 54.59815003])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.exp([1, 2, 3, 4])\n&quot;</span>
    <span class="s0">&quot;array([ 2.71828183,  7.3890561 , 20.08553692, 54.59815003])&quot;)</span>
<span class="s0">ufunc_hyp1f1_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_hyp1f1_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_D_ddD__As_ffF_F</span>
<span class="s0">ufunc_hyp1f1_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_hyp1f1_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_ddD__As_ddD_D</span>
<span class="s0">ufunc_hyp1f1_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyp1f1_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyp1f1_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyp1f1_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyp1f1_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyp1f1_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyp1f1_types[6] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_hyp1f1_types[7] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_hyp1f1_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyp1f1_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyp1f1_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyp1f1_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyp1f1_types[12] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyp1f1_types[13] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyp1f1_types[14] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_hyp1f1_types[15] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_hyp1f1_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_hyp1f1_double</span>
<span class="s0">ufunc_hyp1f1_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;hyp1f1&quot;)</span>
<span class="s0">ufunc_hyp1f1_ptr[2*1] = &lt;void*&gt;_func_chyp1f1_wrap</span>
<span class="s0">ufunc_hyp1f1_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;hyp1f1&quot;)</span>
<span class="s0">ufunc_hyp1f1_ptr[2*2] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_hyp1f1_double</span>
<span class="s0">ufunc_hyp1f1_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;hyp1f1&quot;)</span>
<span class="s0">ufunc_hyp1f1_ptr[2*3] = &lt;void*&gt;_func_chyp1f1_wrap</span>
<span class="s0">ufunc_hyp1f1_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;hyp1f1&quot;)</span>
<span class="s0">ufunc_hyp1f1_data[0] = &amp;ufunc_hyp1f1_ptr[2*0]</span>
<span class="s0">ufunc_hyp1f1_data[1] = &amp;ufunc_hyp1f1_ptr[2*1]</span>
<span class="s0">ufunc_hyp1f1_data[2] = &amp;ufunc_hyp1f1_ptr[2*2]</span>
<span class="s0">ufunc_hyp1f1_data[3] = &amp;ufunc_hyp1f1_ptr[2*3]</span>
<span class="s0">hyp1f1 = np.PyUFunc_FromFuncAndData(ufunc_hyp1f1_loops, ufunc_hyp1f1_data, ufunc_hyp1f1_types, 4, 3, 1, 0, &quot;hyp1f1&quot;, ufunc_hyp1f1_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_hyp2f1_loops[4]</span>
<span class="s0">cdef void *ufunc_hyp2f1_ptr[8]</span>
<span class="s0">cdef void *ufunc_hyp2f1_data[4]</span>
<span class="s0">cdef char ufunc_hyp2f1_types[20]</span>
<span class="s0">cdef char *ufunc_hyp2f1_doc = (</span>
    <span class="s0">&quot;hyp2f1(a, b, c, z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Gauss hypergeometric function 2F1(a, b; c; z)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a, b, c : array_like\n&quot;</span>
    <span class="s0">&quot;    Arguments, should be real-valued.\n&quot;</span>
    <span class="s0">&quot;z : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument, real or complex.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;hyp2f1 : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The values of the gaussian hypergeometric function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;hyp0f1 : confluent hypergeometric limit function.\n&quot;</span>
    <span class="s0">&quot;hyp1f1 : Kummer's (confluent hypergeometric) function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;This function is defined for :math:`|z| &lt; 1` as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;   \\mathrm{hyp2f1}(a, b, c, z) = \\sum_{n=0}^\\infty\n&quot;</span>
    <span class="s0">&quot;   \\frac{(a)_n (b)_n}{(c)_n}\\frac{z^n}{n!},\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;and defined on the rest of the complex z-plane by analytic\n&quot;</span>
    <span class="s0">&quot;continuation [1]_.\n&quot;</span>
    <span class="s0">&quot;Here :math:`(\\cdot)_n` is the Pochhammer symbol; see `poch`. When\n&quot;</span>
    <span class="s0">&quot;:math:`n` is an integer the result is a polynomial of degree :math:`n`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The implementation for complex values of ``z`` is described in [2]_,\n&quot;</span>
    <span class="s0">&quot;except for ``z`` in the region defined by\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;     0.9 &lt;= \\left|z\\right| &lt; 1.1,\n&quot;</span>
    <span class="s0">&quot;     \\left|1 - z\\right| &gt;= 0.9,\n&quot;</span>
    <span class="s0">&quot;     \\mathrm{real}(z) &gt;= 0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;in which the implementation follows [4]_.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] NIST Digital Library of Mathematical Functions\n&quot;</span>
    <span class="s0">&quot;       https://dlmf.nist.gov/15.2\n&quot;</span>
    <span class="s0">&quot;.. [2] S. Zhang and J.M. Jin, \&quot;Computation of Special Functions\&quot;, Wiley 1996\n&quot;</span>
    <span class="s0">&quot;.. [3] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;.. [4] J.L. Lopez and N.M. Temme, \&quot;New series expansions of the Gauss\n&quot;</span>
    <span class="s0">&quot;       hypergeometric function\&quot;, Adv Comput Math 39, 349-365 (2013).\n&quot;</span>
    <span class="s0">&quot;       https://doi.org/10.1007/s10444-012-9283-y\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It has poles when `c` is a negative integer.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.hyp2f1(1, 1, -2, 1)\n&quot;</span>
    <span class="s0">&quot;inf\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is a polynomial when `a` or `b` is a negative integer.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a, b, c = -1, 1, 1.5\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z = np.linspace(0, 1, 5)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.hyp2f1(a, b, c, z)\n&quot;</span>
    <span class="s0">&quot;array([1.        , 0.83333333, 0.66666667, 0.5       , 0.33333333])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; 1 + a * b * z / c\n&quot;</span>
    <span class="s0">&quot;array([1.        , 0.83333333, 0.66666667, 0.5       , 0.33333333])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is symmetric in `a` and `b`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a = np.linspace(0, 1, 5)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; b = np.linspace(0, 1, 5)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.hyp2f1(a, b, 1, 0.5)\n&quot;</span>
    <span class="s0">&quot;array([1.        , 1.03997334, 1.1803406 , 1.47074441, 2.        ])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.hyp2f1(b, a, 1, 0.5)\n&quot;</span>
    <span class="s0">&quot;array([1.        , 1.03997334, 1.1803406 , 1.47074441, 2.        ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It contains many other functions as special cases.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z = 0.5\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.hyp2f1(1, 1, 2, z)\n&quot;</span>
    <span class="s0">&quot;1.3862943611198901\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; -np.log(1 - z) / z\n&quot;</span>
    <span class="s0">&quot;1.3862943611198906\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.hyp2f1(0.5, 1, 1.5, z**2)\n&quot;</span>
    <span class="s0">&quot;1.098612288668109\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.log((1 + z) / (1 - z)) / (2 * z)\n&quot;</span>
    <span class="s0">&quot;1.0986122886681098\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.hyp2f1(0.5, 1, 1.5, -z**2)\n&quot;</span>
    <span class="s0">&quot;0.9272952180016117\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.arctan(z) / z\n&quot;</span>
    <span class="s0">&quot;0.9272952180016122&quot;)</span>
<span class="s0">ufunc_hyp2f1_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_ffff_f</span>
<span class="s0">ufunc_hyp2f1_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dddD__As_fffF_F</span>
<span class="s0">ufunc_hyp2f1_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_dddd_d</span>
<span class="s0">ufunc_hyp2f1_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dddD__As_dddD_D</span>
<span class="s0">ufunc_hyp2f1_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyp2f1_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyp2f1_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyp2f1_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyp2f1_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyp2f1_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyp2f1_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyp2f1_types[7] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyp2f1_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_hyp2f1_types[9] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_hyp2f1_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyp2f1_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyp2f1_types[12] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyp2f1_types[13] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyp2f1_types[14] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyp2f1_types[15] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyp2f1_types[16] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyp2f1_types[17] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyp2f1_types[18] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_hyp2f1_types[19] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_hyp2f1_ptr[2*0] = &lt;void*&gt;_func_hyp2f1</span>
<span class="s0">ufunc_hyp2f1_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;hyp2f1&quot;)</span>
<span class="s0">ufunc_hyp2f1_ptr[2*1] = &lt;void*&gt;_func_hyp2f1_complex</span>
<span class="s0">ufunc_hyp2f1_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;hyp2f1&quot;)</span>
<span class="s0">ufunc_hyp2f1_ptr[2*2] = &lt;void*&gt;_func_hyp2f1</span>
<span class="s0">ufunc_hyp2f1_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;hyp2f1&quot;)</span>
<span class="s0">ufunc_hyp2f1_ptr[2*3] = &lt;void*&gt;_func_hyp2f1_complex</span>
<span class="s0">ufunc_hyp2f1_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;hyp2f1&quot;)</span>
<span class="s0">ufunc_hyp2f1_data[0] = &amp;ufunc_hyp2f1_ptr[2*0]</span>
<span class="s0">ufunc_hyp2f1_data[1] = &amp;ufunc_hyp2f1_ptr[2*1]</span>
<span class="s0">ufunc_hyp2f1_data[2] = &amp;ufunc_hyp2f1_ptr[2*2]</span>
<span class="s0">ufunc_hyp2f1_data[3] = &amp;ufunc_hyp2f1_ptr[2*3]</span>
<span class="s0">hyp2f1 = np.PyUFunc_FromFuncAndData(ufunc_hyp2f1_loops, ufunc_hyp2f1_data, ufunc_hyp2f1_types, 4, 4, 1, 0, &quot;hyp2f1&quot;, ufunc_hyp2f1_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_hyperu_loops[2]</span>
<span class="s0">cdef void *ufunc_hyperu_ptr[4]</span>
<span class="s0">cdef void *ufunc_hyperu_data[2]</span>
<span class="s0">cdef char ufunc_hyperu_types[8]</span>
<span class="s0">cdef char *ufunc_hyperu_doc = (</span>
    <span class="s0">&quot;hyperu(a, b, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Confluent hypergeometric function U\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is defined as the solution to the equation\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;   x \\frac{d^2w}{dx^2} + (b - x) \\frac{dw}{dx} - aw = 0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;which satisfies the property\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;   U(a, b, x) \\sim x^{-a}\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;as :math:`x \\to \\infty`. See [dlmf]_ for more details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a, b : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued parameters\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of `U`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [dlmf] NIST Digital Library of Mathematics Functions\n&quot;</span>
    <span class="s0">&quot;          https://dlmf.nist.gov/13.2#E6\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It has a branch cut along the negative `x` axis.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-0.1, -10, 5)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.hyperu(1, 1, x)\n&quot;</span>
    <span class="s0">&quot;array([nan, nan, nan, nan, nan])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It approaches zero as `x` goes to infinity.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.array([1, 10, 100])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.hyperu(1, 1, x)\n&quot;</span>
    <span class="s0">&quot;array([0.59634736, 0.09156333, 0.00990194])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It satisfies Kummer's transformation.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a, b, x = 2, 1, 1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.hyperu(a, b, x)\n&quot;</span>
    <span class="s0">&quot;0.1926947246463881\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x**(1 - b) * sc.hyperu(a - b + 1, 2 - b, x)\n&quot;</span>
    <span class="s0">&quot;0.1926947246463881&quot;)</span>
<span class="s0">ufunc_hyperu_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_hyperu_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_hyperu_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyperu_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyperu_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyperu_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_hyperu_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyperu_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyperu_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyperu_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_hyperu_ptr[2*0] = &lt;void*&gt;_func_hyperu</span>
<span class="s0">ufunc_hyperu_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;hyperu&quot;)</span>
<span class="s0">ufunc_hyperu_ptr[2*1] = &lt;void*&gt;_func_hyperu</span>
<span class="s0">ufunc_hyperu_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;hyperu&quot;)</span>
<span class="s0">ufunc_hyperu_data[0] = &amp;ufunc_hyperu_ptr[2*0]</span>
<span class="s0">ufunc_hyperu_data[1] = &amp;ufunc_hyperu_ptr[2*1]</span>
<span class="s0">hyperu = np.PyUFunc_FromFuncAndData(ufunc_hyperu_loops, ufunc_hyperu_data, ufunc_hyperu_types, 2, 3, 1, 0, &quot;hyperu&quot;, ufunc_hyperu_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_i0_loops[2]</span>
<span class="s0">cdef void *ufunc_i0_ptr[4]</span>
<span class="s0">cdef void *ufunc_i0_data[2]</span>
<span class="s0">cdef char ufunc_i0_types[4]</span>
<span class="s0">cdef char *ufunc_i0_doc = (</span>
    <span class="s0">&quot;i0(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Modified Bessel function of order 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined as,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    I_0(x) = \\sum_{k=0}^\\infty \\frac{(x^2/4)^k}{(k!)^2} = J_0(\\imath x),\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`J_0` is the Bessel function of the first kind of order 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float)\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;I : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the modified Bessel function of order 0 at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The range is partitioned into the two intervals [0, 8] and (8, infinity).\n&quot;</span>
    <span class="s0">&quot;Chebyshev polynomial expansions are employed in each interval.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is a wrapper for the Cephes [1]_ routine `i0`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;iv: Modified Bessel function of any order\n&quot;</span>
    <span class="s0">&quot;i0e: Exponentially scaled modified Bessel function of order 0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Calculate the function at one point:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import i0\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; i0(1.)\n&quot;</span>
    <span class="s0">&quot;1.2660658777520082\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate at several points:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; i0(np.array([-2., 0., 3.5]))\n&quot;</span>
    <span class="s0">&quot;array([2.2795853 , 1.        , 7.37820343])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function from -10 to 10.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-10., 10., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = i0(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, y)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_i0_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_i0_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_i0_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_i0_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_i0_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_i0_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_i0_ptr[2*0] = &lt;void*&gt;_func_i0</span>
<span class="s0">ufunc_i0_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;i0&quot;)</span>
<span class="s0">ufunc_i0_ptr[2*1] = &lt;void*&gt;_func_i0</span>
<span class="s0">ufunc_i0_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;i0&quot;)</span>
<span class="s0">ufunc_i0_data[0] = &amp;ufunc_i0_ptr[2*0]</span>
<span class="s0">ufunc_i0_data[1] = &amp;ufunc_i0_ptr[2*1]</span>
<span class="s0">i0 = np.PyUFunc_FromFuncAndData(ufunc_i0_loops, ufunc_i0_data, ufunc_i0_types, 2, 1, 1, 0, &quot;i0&quot;, ufunc_i0_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_i0e_loops[2]</span>
<span class="s0">cdef void *ufunc_i0e_ptr[4]</span>
<span class="s0">cdef void *ufunc_i0e_data[2]</span>
<span class="s0">cdef char ufunc_i0e_types[4]</span>
<span class="s0">cdef char *ufunc_i0e_doc = (</span>
    <span class="s0">&quot;i0e(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Exponentially scaled modified Bessel function of order 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined as::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    i0e(x) = exp(-abs(x)) * i0(x).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float)\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;I : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the exponentially scaled modified Bessel function of order 0\n&quot;</span>
    <span class="s0">&quot;    at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The range is partitioned into the two intervals [0, 8] and (8, infinity).\n&quot;</span>
    <span class="s0">&quot;Chebyshev polynomial expansions are employed in each interval. The\n&quot;</span>
    <span class="s0">&quot;polynomial expansions used are the same as those in `i0`, but\n&quot;</span>
    <span class="s0">&quot;they are not multiplied by the dominant exponential factor.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is a wrapper for the Cephes [1]_ routine `i0e`. `i0e`\n&quot;</span>
    <span class="s0">&quot;is useful for large arguments `x`: for these, `i0` quickly overflows.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;iv: Modified Bessel function of the first kind\n&quot;</span>
    <span class="s0">&quot;i0: Modified Bessel function of order 0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;In the following example `i0` returns infinity whereas `i0e` still returns\n&quot;</span>
    <span class="s0">&quot;a finite number.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import i0, i0e\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; i0(1000.), i0e(1000.)\n&quot;</span>
    <span class="s0">&quot;(inf, 0.012617240455891257)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the function at several points by providing a NumPy array or\n&quot;</span>
    <span class="s0">&quot;list for `x`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; i0e(np.array([-2., 0., 3.]))\n&quot;</span>
    <span class="s0">&quot;array([0.30850832, 1.        , 0.24300035])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function from -10 to 10.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-10., 10., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = i0e(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, y)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_i0e_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_i0e_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_i0e_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_i0e_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_i0e_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_i0e_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_i0e_ptr[2*0] = &lt;void*&gt;_func_i0e</span>
<span class="s0">ufunc_i0e_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;i0e&quot;)</span>
<span class="s0">ufunc_i0e_ptr[2*1] = &lt;void*&gt;_func_i0e</span>
<span class="s0">ufunc_i0e_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;i0e&quot;)</span>
<span class="s0">ufunc_i0e_data[0] = &amp;ufunc_i0e_ptr[2*0]</span>
<span class="s0">ufunc_i0e_data[1] = &amp;ufunc_i0e_ptr[2*1]</span>
<span class="s0">i0e = np.PyUFunc_FromFuncAndData(ufunc_i0e_loops, ufunc_i0e_data, ufunc_i0e_types, 2, 1, 1, 0, &quot;i0e&quot;, ufunc_i0e_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_i1_loops[2]</span>
<span class="s0">cdef void *ufunc_i1_ptr[4]</span>
<span class="s0">cdef void *ufunc_i1_data[2]</span>
<span class="s0">cdef char ufunc_i1_types[4]</span>
<span class="s0">cdef char *ufunc_i1_doc = (</span>
    <span class="s0">&quot;i1(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Modified Bessel function of order 1.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined as,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    I_1(x) = \\frac{1}{2}x \\sum_{k=0}^\\infty \\frac{(x^2/4)^k}{k! (k + 1)!}\n&quot;</span>
    <span class="s0">&quot;           = -\\imath J_1(\\imath x),\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`J_1` is the Bessel function of the first kind of order 1.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float)\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;I : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the modified Bessel function of order 1 at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The range is partitioned into the two intervals [0, 8] and (8, infinity).\n&quot;</span>
    <span class="s0">&quot;Chebyshev polynomial expansions are employed in each interval.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is a wrapper for the Cephes [1]_ routine `i1`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;iv: Modified Bessel function of the first kind\n&quot;</span>
    <span class="s0">&quot;i1e: Exponentially scaled modified Bessel function of order 1\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Calculate the function at one point:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import i1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; i1(1.)\n&quot;</span>
    <span class="s0">&quot;0.5651591039924851\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the function at several points:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; i1(np.array([-2., 0., 6.]))\n&quot;</span>
    <span class="s0">&quot;array([-1.59063685,  0.        , 61.34193678])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function between -10 and 10.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-10., 10., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = i1(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, y)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_i1_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_i1_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_i1_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_i1_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_i1_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_i1_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_i1_ptr[2*0] = &lt;void*&gt;_func_i1</span>
<span class="s0">ufunc_i1_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;i1&quot;)</span>
<span class="s0">ufunc_i1_ptr[2*1] = &lt;void*&gt;_func_i1</span>
<span class="s0">ufunc_i1_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;i1&quot;)</span>
<span class="s0">ufunc_i1_data[0] = &amp;ufunc_i1_ptr[2*0]</span>
<span class="s0">ufunc_i1_data[1] = &amp;ufunc_i1_ptr[2*1]</span>
<span class="s0">i1 = np.PyUFunc_FromFuncAndData(ufunc_i1_loops, ufunc_i1_data, ufunc_i1_types, 2, 1, 1, 0, &quot;i1&quot;, ufunc_i1_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_i1e_loops[2]</span>
<span class="s0">cdef void *ufunc_i1e_ptr[4]</span>
<span class="s0">cdef void *ufunc_i1e_data[2]</span>
<span class="s0">cdef char ufunc_i1e_types[4]</span>
<span class="s0">cdef char *ufunc_i1e_doc = (</span>
    <span class="s0">&quot;i1e(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Exponentially scaled modified Bessel function of order 1.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined as::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    i1e(x) = exp(-abs(x)) * i1(x)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float)\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;I : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the exponentially scaled modified Bessel function of order 1\n&quot;</span>
    <span class="s0">&quot;    at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The range is partitioned into the two intervals [0, 8] and (8, infinity).\n&quot;</span>
    <span class="s0">&quot;Chebyshev polynomial expansions are employed in each interval. The\n&quot;</span>
    <span class="s0">&quot;polynomial expansions used are the same as those in `i1`, but\n&quot;</span>
    <span class="s0">&quot;they are not multiplied by the dominant exponential factor.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is a wrapper for the Cephes [1]_ routine `i1e`. `i1e`\n&quot;</span>
    <span class="s0">&quot;is useful for large arguments `x`: for these, `i1` quickly overflows.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;iv: Modified Bessel function of the first kind\n&quot;</span>
    <span class="s0">&quot;i1: Modified Bessel function of order 1\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;In the following example `i1` returns infinity whereas `i1e` still returns\n&quot;</span>
    <span class="s0">&quot;a finite number.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import i1, i1e\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; i1(1000.), i1e(1000.)\n&quot;</span>
    <span class="s0">&quot;(inf, 0.01261093025692863)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the function at several points by providing a NumPy array or\n&quot;</span>
    <span class="s0">&quot;list for `x`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; i1e(np.array([-2., 0., 6.]))\n&quot;</span>
    <span class="s0">&quot;array([-0.21526929,  0.        ,  0.15205146])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function between -10 and 10.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-10., 10., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = i1e(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, y)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_i1e_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_i1e_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_i1e_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_i1e_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_i1e_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_i1e_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_i1e_ptr[2*0] = &lt;void*&gt;_func_i1e</span>
<span class="s0">ufunc_i1e_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;i1e&quot;)</span>
<span class="s0">ufunc_i1e_ptr[2*1] = &lt;void*&gt;_func_i1e</span>
<span class="s0">ufunc_i1e_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;i1e&quot;)</span>
<span class="s0">ufunc_i1e_data[0] = &amp;ufunc_i1e_ptr[2*0]</span>
<span class="s0">ufunc_i1e_data[1] = &amp;ufunc_i1e_ptr[2*1]</span>
<span class="s0">i1e = np.PyUFunc_FromFuncAndData(ufunc_i1e_loops, ufunc_i1e_data, ufunc_i1e_types, 2, 1, 1, 0, &quot;i1e&quot;, ufunc_i1e_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_inv_boxcox_loops[2]</span>
<span class="s0">cdef void *ufunc_inv_boxcox_ptr[4]</span>
<span class="s0">cdef void *ufunc_inv_boxcox_data[2]</span>
<span class="s0">cdef char ufunc_inv_boxcox_types[6]</span>
<span class="s0">cdef char *ufunc_inv_boxcox_doc = (</span>
    <span class="s0">&quot;inv_boxcox(y, lmbda, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the inverse of the Box-Cox transformation.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Find ``x`` such that::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    y = (x**lmbda - 1) / lmbda  if lmbda != 0\n&quot;</span>
    <span class="s0">&quot;        log(x)                  if lmbda == 0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;y : array_like\n&quot;</span>
    <span class="s0">&quot;    Data to be transformed.\n&quot;</span>
    <span class="s0">&quot;lmbda : array_like\n&quot;</span>
    <span class="s0">&quot;    Power parameter of the Box-Cox transform.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;x : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Transformed data.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 0.16.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import boxcox, inv_boxcox\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = boxcox([1, 4, 10], 2.5)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; inv_boxcox(y, 2.5)\n&quot;</span>
    <span class="s0">&quot;array([1., 4., 10.])&quot;)</span>
<span class="s0">ufunc_inv_boxcox_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_inv_boxcox_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_inv_boxcox_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_inv_boxcox_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_inv_boxcox_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_inv_boxcox_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_inv_boxcox_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_inv_boxcox_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_inv_boxcox_ptr[2*0] = &lt;void*&gt;_func_inv_boxcox</span>
<span class="s0">ufunc_inv_boxcox_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;inv_boxcox&quot;)</span>
<span class="s0">ufunc_inv_boxcox_ptr[2*1] = &lt;void*&gt;_func_inv_boxcox</span>
<span class="s0">ufunc_inv_boxcox_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;inv_boxcox&quot;)</span>
<span class="s0">ufunc_inv_boxcox_data[0] = &amp;ufunc_inv_boxcox_ptr[2*0]</span>
<span class="s0">ufunc_inv_boxcox_data[1] = &amp;ufunc_inv_boxcox_ptr[2*1]</span>
<span class="s0">inv_boxcox = np.PyUFunc_FromFuncAndData(ufunc_inv_boxcox_loops, ufunc_inv_boxcox_data, ufunc_inv_boxcox_types, 2, 2, 1, 0, &quot;inv_boxcox&quot;, ufunc_inv_boxcox_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_inv_boxcox1p_loops[2]</span>
<span class="s0">cdef void *ufunc_inv_boxcox1p_ptr[4]</span>
<span class="s0">cdef void *ufunc_inv_boxcox1p_data[2]</span>
<span class="s0">cdef char ufunc_inv_boxcox1p_types[6]</span>
<span class="s0">cdef char *ufunc_inv_boxcox1p_doc = (</span>
    <span class="s0">&quot;inv_boxcox1p(y, lmbda, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the inverse of the Box-Cox transformation.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Find ``x`` such that::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    y = ((1+x)**lmbda - 1) / lmbda  if lmbda != 0\n&quot;</span>
    <span class="s0">&quot;        log(1+x)                    if lmbda == 0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;y : array_like\n&quot;</span>
    <span class="s0">&quot;    Data to be transformed.\n&quot;</span>
    <span class="s0">&quot;lmbda : array_like\n&quot;</span>
    <span class="s0">&quot;    Power parameter of the Box-Cox transform.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;x : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Transformed data.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 0.16.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import boxcox1p, inv_boxcox1p\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = boxcox1p([1, 4, 10], 2.5)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; inv_boxcox1p(y, 2.5)\n&quot;</span>
    <span class="s0">&quot;array([1., 4., 10.])&quot;)</span>
<span class="s0">ufunc_inv_boxcox1p_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_inv_boxcox1p_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_inv_boxcox1p_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_inv_boxcox1p_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_inv_boxcox1p_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_inv_boxcox1p_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_inv_boxcox1p_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_inv_boxcox1p_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_inv_boxcox1p_ptr[2*0] = &lt;void*&gt;_func_inv_boxcox1p</span>
<span class="s0">ufunc_inv_boxcox1p_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;inv_boxcox1p&quot;)</span>
<span class="s0">ufunc_inv_boxcox1p_ptr[2*1] = &lt;void*&gt;_func_inv_boxcox1p</span>
<span class="s0">ufunc_inv_boxcox1p_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;inv_boxcox1p&quot;)</span>
<span class="s0">ufunc_inv_boxcox1p_data[0] = &amp;ufunc_inv_boxcox1p_ptr[2*0]</span>
<span class="s0">ufunc_inv_boxcox1p_data[1] = &amp;ufunc_inv_boxcox1p_ptr[2*1]</span>
<span class="s0">inv_boxcox1p = np.PyUFunc_FromFuncAndData(ufunc_inv_boxcox1p_loops, ufunc_inv_boxcox1p_data, ufunc_inv_boxcox1p_types, 2, 2, 1, 0, &quot;inv_boxcox1p&quot;, ufunc_inv_boxcox1p_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_it2i0k0_loops[2]</span>
<span class="s0">cdef void *ufunc_it2i0k0_ptr[4]</span>
<span class="s0">cdef void *ufunc_it2i0k0_data[2]</span>
<span class="s0">cdef char ufunc_it2i0k0_types[6]</span>
<span class="s0">cdef char *ufunc_it2i0k0_doc = (</span>
    <span class="s0">&quot;it2i0k0(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Integrals related to modified Bessel functions of order 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes the integrals\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    \\int_0^x \\frac{I_0(t) - 1}{t} dt \\\\\n&quot;</span>
    <span class="s0">&quot;    \\int_x^\\infty \\frac{K_0(t)}{t} dt.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Values at which to evaluate the integrals.\n&quot;</span>
    <span class="s0">&quot;out : tuple of ndarrays, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output arrays for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;ii0 : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The integral for `i0`\n&quot;</span>
    <span class="s0">&quot;ik0 : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The integral for `k0`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] S. Zhang and J.M. Jin, \&quot;Computation of Special Functions\&quot;,\n&quot;</span>
    <span class="s0">&quot;       Wiley 1996\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Evaluate the functions at one point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import it2i0k0\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; int_i, int_k = it2i0k0(1.)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; int_i, int_k\n&quot;</span>
    <span class="s0">&quot;(0.12897944249456852, 0.2085182909001295)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate the functions at several points.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; points = np.array([0.5, 1.5, 3.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; int_i, int_k = it2i0k0(points)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; int_i, int_k\n&quot;</span>
    <span class="s0">&quot;(array([0.03149527, 0.30187149, 1.50012461]),\n&quot;</span>
    <span class="s0">&quot; array([0.66575102, 0.0823715 , 0.00823631]))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the functions from 0 to 5.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0., 5., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; int_i, int_k = it2i0k0(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, int_i, label=r\&quot;$\\int_0^x \\frac{I_0(t)-1}{t}\\,dt$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, int_k, label=r\&quot;$\\int_x^{\\infty} \\frac{K_0(t)}{t}\\,dt$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_ylim(0, 10)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_it2i0k0_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_d_dd_As_f_ff</span>
<span class="s0">ufunc_it2i0k0_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_i_d_dd_As_d_dd</span>
<span class="s0">ufunc_it2i0k0_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_it2i0k0_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_it2i0k0_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_it2i0k0_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_it2i0k0_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_it2i0k0_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_it2i0k0_ptr[2*0] = &lt;void*&gt;_func_it2i0k0_wrap</span>
<span class="s0">ufunc_it2i0k0_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;it2i0k0&quot;)</span>
<span class="s0">ufunc_it2i0k0_ptr[2*1] = &lt;void*&gt;_func_it2i0k0_wrap</span>
<span class="s0">ufunc_it2i0k0_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;it2i0k0&quot;)</span>
<span class="s0">ufunc_it2i0k0_data[0] = &amp;ufunc_it2i0k0_ptr[2*0]</span>
<span class="s0">ufunc_it2i0k0_data[1] = &amp;ufunc_it2i0k0_ptr[2*1]</span>
<span class="s0">it2i0k0 = np.PyUFunc_FromFuncAndData(ufunc_it2i0k0_loops, ufunc_it2i0k0_data, ufunc_it2i0k0_types, 2, 1, 2, 0, &quot;it2i0k0&quot;, ufunc_it2i0k0_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_it2j0y0_loops[2]</span>
<span class="s0">cdef void *ufunc_it2j0y0_ptr[4]</span>
<span class="s0">cdef void *ufunc_it2j0y0_data[2]</span>
<span class="s0">cdef char ufunc_it2j0y0_types[6]</span>
<span class="s0">cdef char *ufunc_it2j0y0_doc = (</span>
    <span class="s0">&quot;it2j0y0(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Integrals related to Bessel functions of the first kind of order 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes the integrals\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    \\int_0^x \\frac{1 - J_0(t)}{t} dt \\\\\n&quot;</span>
    <span class="s0">&quot;    \\int_x^\\infty \\frac{Y_0(t)}{t} dt.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For more on :math:`J_0` and :math:`Y_0` see `j0` and `y0`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Values at which to evaluate the integrals.\n&quot;</span>
    <span class="s0">&quot;out : tuple of ndarrays, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output arrays for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;ij0 : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The integral for `j0`\n&quot;</span>
    <span class="s0">&quot;iy0 : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The integral for `y0`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] S. Zhang and J.M. Jin, \&quot;Computation of Special Functions\&quot;,\n&quot;</span>
    <span class="s0">&quot;       Wiley 1996\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Evaluate the functions at one point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import it2j0y0\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; int_j, int_y = it2j0y0(1.)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; int_j, int_y\n&quot;</span>
    <span class="s0">&quot;(0.12116524699506871, 0.39527290169929336)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate the functions at several points.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; points = np.array([0.5, 1.5, 3.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; int_j, int_y = it2j0y0(points)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; int_j, int_y\n&quot;</span>
    <span class="s0">&quot;(array([0.03100699, 0.26227724, 0.85614669]),\n&quot;</span>
    <span class="s0">&quot; array([ 0.26968854,  0.29769696, -0.02987272]))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the functions from 0 to 10.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0., 10., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; int_j, int_y = it2j0y0(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, int_j, label=r\&quot;$\\int_0^x \\frac{1-J_0(t)}{t}\\,dt$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, int_y, label=r\&quot;$\\int_x^{\\infty} \\frac{Y_0(t)}{t}\\,dt$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_ylim(-2.5, 2.5)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_it2j0y0_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_d_dd_As_f_ff</span>
<span class="s0">ufunc_it2j0y0_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_i_d_dd_As_d_dd</span>
<span class="s0">ufunc_it2j0y0_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_it2j0y0_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_it2j0y0_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_it2j0y0_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_it2j0y0_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_it2j0y0_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_it2j0y0_ptr[2*0] = &lt;void*&gt;_func_it2j0y0_wrap</span>
<span class="s0">ufunc_it2j0y0_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;it2j0y0&quot;)</span>
<span class="s0">ufunc_it2j0y0_ptr[2*1] = &lt;void*&gt;_func_it2j0y0_wrap</span>
<span class="s0">ufunc_it2j0y0_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;it2j0y0&quot;)</span>
<span class="s0">ufunc_it2j0y0_data[0] = &amp;ufunc_it2j0y0_ptr[2*0]</span>
<span class="s0">ufunc_it2j0y0_data[1] = &amp;ufunc_it2j0y0_ptr[2*1]</span>
<span class="s0">it2j0y0 = np.PyUFunc_FromFuncAndData(ufunc_it2j0y0_loops, ufunc_it2j0y0_data, ufunc_it2j0y0_types, 2, 1, 2, 0, &quot;it2j0y0&quot;, ufunc_it2j0y0_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_it2struve0_loops[2]</span>
<span class="s0">cdef void *ufunc_it2struve0_ptr[4]</span>
<span class="s0">cdef void *ufunc_it2struve0_data[2]</span>
<span class="s0">cdef char ufunc_it2struve0_types[4]</span>
<span class="s0">cdef char *ufunc_it2struve0_doc = (</span>
    <span class="s0">&quot;it2struve0(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Integral related to the Struve function of order 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the integral,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    \\int_x^\\infty \\frac{H_0(t)}{t}\\,dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`H_0` is the Struve function of order 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Lower limit of integration.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;I : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The value of the integral.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;struve\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for a Fortran routine created by Shanjie Zhang and Jianming\n&quot;</span>
    <span class="s0">&quot;Jin [1]_.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Zhang, Shanjie and Jin, Jianming. \&quot;Computation of Special\n&quot;</span>
    <span class="s0">&quot;       Functions\&quot;, John Wiley and Sons, 1996.\n&quot;</span>
    <span class="s0">&quot;       https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Evaluate the function at one point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import it2struve0\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; it2struve0(1.)\n&quot;</span>
    <span class="s0">&quot;0.9571973506383524\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate the function at several points by supplying\n&quot;</span>
    <span class="s0">&quot;an array for `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; points = np.array([1., 2., 3.5])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; it2struve0(points)\n&quot;</span>
    <span class="s0">&quot;array([0.95719735, 0.46909296, 0.10366042])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function from -10 to 10.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-10., 10., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; it2struve0_values = it2struve0(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, it2struve0_values)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel(r'$x$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_ylabel(r'$\\int_x^{\\infty}\\frac{H_0(t)}{t}\\,dt$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_it2struve0_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_it2struve0_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_it2struve0_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_it2struve0_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_it2struve0_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_it2struve0_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_it2struve0_ptr[2*0] = &lt;void*&gt;_func_it2struve0_wrap</span>
<span class="s0">ufunc_it2struve0_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;it2struve0&quot;)</span>
<span class="s0">ufunc_it2struve0_ptr[2*1] = &lt;void*&gt;_func_it2struve0_wrap</span>
<span class="s0">ufunc_it2struve0_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;it2struve0&quot;)</span>
<span class="s0">ufunc_it2struve0_data[0] = &amp;ufunc_it2struve0_ptr[2*0]</span>
<span class="s0">ufunc_it2struve0_data[1] = &amp;ufunc_it2struve0_ptr[2*1]</span>
<span class="s0">it2struve0 = np.PyUFunc_FromFuncAndData(ufunc_it2struve0_loops, ufunc_it2struve0_data, ufunc_it2struve0_types, 2, 1, 1, 0, &quot;it2struve0&quot;, ufunc_it2struve0_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_itairy_loops[2]</span>
<span class="s0">cdef void *ufunc_itairy_ptr[4]</span>
<span class="s0">cdef void *ufunc_itairy_data[2]</span>
<span class="s0">cdef char ufunc_itairy_types[10]</span>
<span class="s0">cdef char *ufunc_itairy_doc = (</span>
    <span class="s0">&quot;itairy(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Integrals of Airy functions\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculates the integrals of Airy functions from 0 to `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Upper limit of integration (float).\n&quot;</span>
    <span class="s0">&quot;out : tuple of ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output arrays for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;Apt : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Integral of Ai(t) from 0 to x.\n&quot;</span>
    <span class="s0">&quot;Bpt : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Integral of Bi(t) from 0 to x.\n&quot;</span>
    <span class="s0">&quot;Ant : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Integral of Ai(-t) from 0 to x.\n&quot;</span>
    <span class="s0">&quot;Bnt : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Integral of Bi(-t) from 0 to x.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Wrapper for a Fortran routine created by Shanjie Zhang and Jianming\n&quot;</span>
    <span class="s0">&quot;Jin [1]_.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. [1] Zhang, Shanjie and Jin, Jianming. \&quot;Computation of Special\n&quot;</span>
    <span class="s0">&quot;       Functions\&quot;, John Wiley and Sons, 1996.\n&quot;</span>
    <span class="s0">&quot;       https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Compute the functions at ``x=1.``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import itairy\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; apt, bpt, ant, bnt = itairy(1.)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; apt, bpt, ant, bnt\n&quot;</span>
    <span class="s0">&quot;(0.23631734191710949,\n&quot;</span>
    <span class="s0">&quot; 0.8727691167380077,\n&quot;</span>
    <span class="s0">&quot; 0.46567398346706845,\n&quot;</span>
    <span class="s0">&quot; 0.3730050096342943)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the functions at several points by providing a NumPy array for `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.array([1., 1.5, 2.5, 5])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; apt, bpt, ant, bnt = itairy(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; apt, bpt, ant, bnt\n&quot;</span>
    <span class="s0">&quot;(array([0.23631734, 0.28678675, 0.324638  , 0.33328759]),\n&quot;</span>
    <span class="s0">&quot; array([  0.87276912,   1.62470809,   5.20906691, 321.47831857]),\n&quot;</span>
    <span class="s0">&quot; array([0.46567398, 0.72232876, 0.93187776, 0.7178822 ]),\n&quot;</span>
    <span class="s0">&quot; array([ 0.37300501,  0.35038814, -0.02812939,  0.15873094]))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the functions from -10 to 10.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-10, 10, 500)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; apt, bpt, ant, bnt = itairy(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots(figsize=(6, 5))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, apt, label=\&quot;$\\int_0^x\\, Ai(t)\\, dt$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, bpt, ls=\&quot;dashed\&quot;, label=\&quot;$\\int_0^x\\, Bi(t)\\, dt$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, ant, ls=\&quot;dashdot\&quot;, label=\&quot;$\\int_0^x\\, Ai(-t)\\, dt$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, bnt, ls=\&quot;dotted\&quot;, label=\&quot;$\\int_0^x\\, Bi(-t)\\, dt$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_ylim(-2, 1.5)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend(loc=\&quot;lower right\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_itairy_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_d_dddd_As_f_ffff</span>
<span class="s0">ufunc_itairy_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_i_d_dddd_As_d_dddd</span>
<span class="s0">ufunc_itairy_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_itairy_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_itairy_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_itairy_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_itairy_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_itairy_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_itairy_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_itairy_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_itairy_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_itairy_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_itairy_ptr[2*0] = &lt;void*&gt;_func_itairy_wrap</span>
<span class="s0">ufunc_itairy_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;itairy&quot;)</span>
<span class="s0">ufunc_itairy_ptr[2*1] = &lt;void*&gt;_func_itairy_wrap</span>
<span class="s0">ufunc_itairy_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;itairy&quot;)</span>
<span class="s0">ufunc_itairy_data[0] = &amp;ufunc_itairy_ptr[2*0]</span>
<span class="s0">ufunc_itairy_data[1] = &amp;ufunc_itairy_ptr[2*1]</span>
<span class="s0">itairy = np.PyUFunc_FromFuncAndData(ufunc_itairy_loops, ufunc_itairy_data, ufunc_itairy_types, 2, 1, 4, 0, &quot;itairy&quot;, ufunc_itairy_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_iti0k0_loops[2]</span>
<span class="s0">cdef void *ufunc_iti0k0_ptr[4]</span>
<span class="s0">cdef void *ufunc_iti0k0_data[2]</span>
<span class="s0">cdef char ufunc_iti0k0_types[6]</span>
<span class="s0">cdef char *ufunc_iti0k0_doc = (</span>
    <span class="s0">&quot;iti0k0(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Integrals of modified Bessel functions of order 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes the integrals\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    \\int_0^x I_0(t) dt \\\\\n&quot;</span>
    <span class="s0">&quot;    \\int_0^x K_0(t) dt.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For more on :math:`I_0` and :math:`K_0` see `i0` and `k0`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Values at which to evaluate the integrals.\n&quot;</span>
    <span class="s0">&quot;out : tuple of ndarrays, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output arrays for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;ii0 : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The integral for `i0`\n&quot;</span>
    <span class="s0">&quot;ik0 : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The integral for `k0`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] S. Zhang and J.M. Jin, \&quot;Computation of Special Functions\&quot;,\n&quot;</span>
    <span class="s0">&quot;       Wiley 1996\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Evaluate the functions at one point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import iti0k0\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; int_i, int_k = iti0k0(1.)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; int_i, int_k\n&quot;</span>
    <span class="s0">&quot;(1.0865210970235892, 1.2425098486237771)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate the functions at several points.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; points = np.array([0., 1.5, 3.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; int_i, int_k = iti0k0(points)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; int_i, int_k\n&quot;</span>
    <span class="s0">&quot;(array([0.        , 1.80606937, 6.16096149]),\n&quot;</span>
    <span class="s0">&quot; array([0.        , 1.39458246, 1.53994809]))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the functions from 0 to 5.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0., 5., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; int_i, int_k = iti0k0(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, int_i, label=\&quot;$\\int_0^x I_0(t)\\,dt$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, int_k, label=\&quot;$\\int_0^x K_0(t)\\,dt$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_iti0k0_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_d_dd_As_f_ff</span>
<span class="s0">ufunc_iti0k0_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_i_d_dd_As_d_dd</span>
<span class="s0">ufunc_iti0k0_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_iti0k0_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_iti0k0_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_iti0k0_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_iti0k0_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_iti0k0_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_iti0k0_ptr[2*0] = &lt;void*&gt;_func_it1i0k0_wrap</span>
<span class="s0">ufunc_iti0k0_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;iti0k0&quot;)</span>
<span class="s0">ufunc_iti0k0_ptr[2*1] = &lt;void*&gt;_func_it1i0k0_wrap</span>
<span class="s0">ufunc_iti0k0_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;iti0k0&quot;)</span>
<span class="s0">ufunc_iti0k0_data[0] = &amp;ufunc_iti0k0_ptr[2*0]</span>
<span class="s0">ufunc_iti0k0_data[1] = &amp;ufunc_iti0k0_ptr[2*1]</span>
<span class="s0">iti0k0 = np.PyUFunc_FromFuncAndData(ufunc_iti0k0_loops, ufunc_iti0k0_data, ufunc_iti0k0_types, 2, 1, 2, 0, &quot;iti0k0&quot;, ufunc_iti0k0_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_itj0y0_loops[2]</span>
<span class="s0">cdef void *ufunc_itj0y0_ptr[4]</span>
<span class="s0">cdef void *ufunc_itj0y0_data[2]</span>
<span class="s0">cdef char ufunc_itj0y0_types[6]</span>
<span class="s0">cdef char *ufunc_itj0y0_doc = (</span>
    <span class="s0">&quot;itj0y0(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Integrals of Bessel functions of the first kind of order 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes the integrals\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    \\int_0^x J_0(t) dt \\\\\n&quot;</span>
    <span class="s0">&quot;    \\int_0^x Y_0(t) dt.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For more on :math:`J_0` and :math:`Y_0` see `j0` and `y0`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Values at which to evaluate the integrals.\n&quot;</span>
    <span class="s0">&quot;out : tuple of ndarrays, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output arrays for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;ij0 : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The integral of `j0`\n&quot;</span>
    <span class="s0">&quot;iy0 : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The integral of `y0`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] S. Zhang and J.M. Jin, \&quot;Computation of Special Functions\&quot;,\n&quot;</span>
    <span class="s0">&quot;       Wiley 1996\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Evaluate the functions at one point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import itj0y0\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; int_j, int_y = itj0y0(1.)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; int_j, int_y\n&quot;</span>
    <span class="s0">&quot;(0.9197304100897596, -0.637069376607422)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate the functions at several points.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; points = np.array([0., 1.5, 3.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; int_j, int_y = itj0y0(points)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; int_j, int_y\n&quot;</span>
    <span class="s0">&quot;(array([0.        , 1.24144951, 1.38756725]),\n&quot;</span>
    <span class="s0">&quot; array([ 0.        , -0.51175903,  0.19765826]))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the functions from 0 to 10.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0., 10., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; int_j, int_y = itj0y0(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, int_j, label=\&quot;$\\int_0^x J_0(t)\\,dt$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, int_y, label=\&quot;$\\int_0^x Y_0(t)\\,dt$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_itj0y0_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_d_dd_As_f_ff</span>
<span class="s0">ufunc_itj0y0_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_i_d_dd_As_d_dd</span>
<span class="s0">ufunc_itj0y0_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_itj0y0_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_itj0y0_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_itj0y0_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_itj0y0_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_itj0y0_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_itj0y0_ptr[2*0] = &lt;void*&gt;_func_it1j0y0_wrap</span>
<span class="s0">ufunc_itj0y0_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;itj0y0&quot;)</span>
<span class="s0">ufunc_itj0y0_ptr[2*1] = &lt;void*&gt;_func_it1j0y0_wrap</span>
<span class="s0">ufunc_itj0y0_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;itj0y0&quot;)</span>
<span class="s0">ufunc_itj0y0_data[0] = &amp;ufunc_itj0y0_ptr[2*0]</span>
<span class="s0">ufunc_itj0y0_data[1] = &amp;ufunc_itj0y0_ptr[2*1]</span>
<span class="s0">itj0y0 = np.PyUFunc_FromFuncAndData(ufunc_itj0y0_loops, ufunc_itj0y0_data, ufunc_itj0y0_types, 2, 1, 2, 0, &quot;itj0y0&quot;, ufunc_itj0y0_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_itmodstruve0_loops[2]</span>
<span class="s0">cdef void *ufunc_itmodstruve0_ptr[4]</span>
<span class="s0">cdef void *ufunc_itmodstruve0_data[2]</span>
<span class="s0">cdef char ufunc_itmodstruve0_types[4]</span>
<span class="s0">cdef char *ufunc_itmodstruve0_doc = (</span>
    <span class="s0">&quot;itmodstruve0(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Integral of the modified Struve function of order 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    I = \\int_0^x L_0(t)\\,dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Upper limit of integration (float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;I : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The integral of :math:`L_0` from 0 to `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for a Fortran routine created by Shanjie Zhang and Jianming\n&quot;</span>
    <span class="s0">&quot;Jin [1]_.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;modstruve: Modified Struve function which is integrated by this function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Zhang, Shanjie and Jin, Jianming. \&quot;Computation of Special\n&quot;</span>
    <span class="s0">&quot;       Functions\&quot;, John Wiley and Sons, 1996.\n&quot;</span>
    <span class="s0">&quot;       https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Evaluate the function at one point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import itmodstruve0\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; itmodstruve0(1.)\n&quot;</span>
    <span class="s0">&quot;0.3364726286440384\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate the function at several points by supplying\n&quot;</span>
    <span class="s0">&quot;an array for `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; points = np.array([1., 2., 3.5])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; itmodstruve0(points)\n&quot;</span>
    <span class="s0">&quot;array([0.33647263, 1.588285  , 7.60382578])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function from -10 to 10.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-10., 10., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; itmodstruve0_values = itmodstruve0(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, itmodstruve0_values)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel(r'$x$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_ylabel(r'$\\int_0^xL_0(t)\\,dt$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_itmodstruve0_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_itmodstruve0_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_itmodstruve0_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_itmodstruve0_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_itmodstruve0_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_itmodstruve0_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_itmodstruve0_ptr[2*0] = &lt;void*&gt;_func_itmodstruve0_wrap</span>
<span class="s0">ufunc_itmodstruve0_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;itmodstruve0&quot;)</span>
<span class="s0">ufunc_itmodstruve0_ptr[2*1] = &lt;void*&gt;_func_itmodstruve0_wrap</span>
<span class="s0">ufunc_itmodstruve0_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;itmodstruve0&quot;)</span>
<span class="s0">ufunc_itmodstruve0_data[0] = &amp;ufunc_itmodstruve0_ptr[2*0]</span>
<span class="s0">ufunc_itmodstruve0_data[1] = &amp;ufunc_itmodstruve0_ptr[2*1]</span>
<span class="s0">itmodstruve0 = np.PyUFunc_FromFuncAndData(ufunc_itmodstruve0_loops, ufunc_itmodstruve0_data, ufunc_itmodstruve0_types, 2, 1, 1, 0, &quot;itmodstruve0&quot;, ufunc_itmodstruve0_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_itstruve0_loops[2]</span>
<span class="s0">cdef void *ufunc_itstruve0_ptr[4]</span>
<span class="s0">cdef void *ufunc_itstruve0_data[2]</span>
<span class="s0">cdef char ufunc_itstruve0_types[4]</span>
<span class="s0">cdef char *ufunc_itstruve0_doc = (</span>
    <span class="s0">&quot;itstruve0(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Integral of the Struve function of order 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    I = \\int_0^x H_0(t)\\,dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Upper limit of integration (float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;I : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The integral of :math:`H_0` from 0 to `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;struve: Function which is integrated by this function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for a Fortran routine created by Shanjie Zhang and Jianming\n&quot;</span>
    <span class="s0">&quot;Jin [1]_.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Zhang, Shanjie and Jin, Jianming. \&quot;Computation of Special\n&quot;</span>
    <span class="s0">&quot;       Functions\&quot;, John Wiley and Sons, 1996.\n&quot;</span>
    <span class="s0">&quot;       https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Evaluate the function at one point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import itstruve0\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; itstruve0(1.)\n&quot;</span>
    <span class="s0">&quot;0.30109042670805547\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate the function at several points by supplying\n&quot;</span>
    <span class="s0">&quot;an array for `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; points = np.array([1., 2., 3.5])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; itstruve0(points)\n&quot;</span>
    <span class="s0">&quot;array([0.30109043, 1.01870116, 1.96804581])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function from -20 to 20.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-20., 20., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; istruve0_values = itstruve0(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, istruve0_values)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel(r'$x$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_ylabel(r'$\\int_0^{x}H_0(t)\\,dt$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_itstruve0_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_itstruve0_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_itstruve0_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_itstruve0_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_itstruve0_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_itstruve0_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_itstruve0_ptr[2*0] = &lt;void*&gt;_func_itstruve0_wrap</span>
<span class="s0">ufunc_itstruve0_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;itstruve0&quot;)</span>
<span class="s0">ufunc_itstruve0_ptr[2*1] = &lt;void*&gt;_func_itstruve0_wrap</span>
<span class="s0">ufunc_itstruve0_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;itstruve0&quot;)</span>
<span class="s0">ufunc_itstruve0_data[0] = &amp;ufunc_itstruve0_ptr[2*0]</span>
<span class="s0">ufunc_itstruve0_data[1] = &amp;ufunc_itstruve0_ptr[2*1]</span>
<span class="s0">itstruve0 = np.PyUFunc_FromFuncAndData(ufunc_itstruve0_loops, ufunc_itstruve0_data, ufunc_itstruve0_types, 2, 1, 1, 0, &quot;itstruve0&quot;, ufunc_itstruve0_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_iv_loops[4]</span>
<span class="s0">cdef void *ufunc_iv_ptr[8]</span>
<span class="s0">cdef void *ufunc_iv_data[4]</span>
<span class="s0">cdef char ufunc_iv_types[12]</span>
<span class="s0">cdef char *ufunc_iv_doc = (</span>
    <span class="s0">&quot;iv(v, z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Modified Bessel function of the first kind of real order.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;v : array_like\n&quot;</span>
    <span class="s0">&quot;    Order. If `z` is of real type and negative, `v` must be integer\n&quot;</span>
    <span class="s0">&quot;    valued.\n&quot;</span>
    <span class="s0">&quot;z : array_like of float or complex\n&quot;</span>
    <span class="s0">&quot;    Argument.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the modified Bessel function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;For real `z` and :math:`v \\in [-50, 50]`, the evaluation is carried out\n&quot;</span>
    <span class="s0">&quot;using Temme's method [1]_.  For larger orders, uniform asymptotic\n&quot;</span>
    <span class="s0">&quot;expansions are applied.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For complex `z` and positive `v`, the AMOS [2]_ `zbesi` routine is\n&quot;</span>
    <span class="s0">&quot;called. It uses a power series for small `z`, the asymptotic expansion\n&quot;</span>
    <span class="s0">&quot;for large `abs(z)`, the Miller algorithm normalized by the Wronskian\n&quot;</span>
    <span class="s0">&quot;and a Neumann series for intermediate magnitudes, and the uniform\n&quot;</span>
    <span class="s0">&quot;asymptotic expansions for :math:`I_v(z)` and :math:`J_v(z)` for large\n&quot;</span>
    <span class="s0">&quot;orders. Backward recurrence is used to generate sequences or reduce\n&quot;</span>
    <span class="s0">&quot;orders when necessary.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The calculations above are done in the right half plane and continued\n&quot;</span>
    <span class="s0">&quot;into the left half plane by the formula,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: I_v(z \\exp(\\pm\\imath\\pi)) = \\exp(\\pm\\pi v) I_v(z)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;(valid when the real part of `z` is positive).  For negative `v`, the\n&quot;</span>
    <span class="s0">&quot;formula\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: I_{-v}(z) = I_v(z) + \\frac{2}{\\pi} \\sin(\\pi v) K_v(z)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;is used, where :math:`K_v(z)` is the modified Bessel function of the\n&quot;</span>
    <span class="s0">&quot;second kind, evaluated using the AMOS routine `zbesk`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;ive : This function with leading exponential behavior stripped off.\n&quot;</span>
    <span class="s0">&quot;i0 : Faster version of this function for order 0.\n&quot;</span>
    <span class="s0">&quot;i1 : Faster version of this function for order 1.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Temme, Journal of Computational Physics, vol 21, 343 (1976)\n&quot;</span>
    <span class="s0">&quot;.. [2] Donald E. Amos, \&quot;AMOS, A Portable Package for Bessel Functions\n&quot;</span>
    <span class="s0">&quot;       of a Complex Argument and Nonnegative Order\&quot;,\n&quot;</span>
    <span class="s0">&quot;       http://netlib.org/amos/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Evaluate the function of order 0 at one point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import iv\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; iv(0, 1.)\n&quot;</span>
    <span class="s0">&quot;1.2660658777520084\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate the function at one point for different orders.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; iv(0, 1.), iv(1, 1.), iv(1.5, 1.)\n&quot;</span>
    <span class="s0">&quot;(1.2660658777520084, 0.565159103992485, 0.2935253263474798)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The evaluation for different orders can be carried out in one call by\n&quot;</span>
    <span class="s0">&quot;providing a list or NumPy array as argument for the `v` parameter:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; iv([0, 1, 1.5], 1.)\n&quot;</span>
    <span class="s0">&quot;array([1.26606588, 0.5651591 , 0.29352533])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate the function at several points for order 0 by providing an\n&quot;</span>
    <span class="s0">&quot;array for `z`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; points = np.array([-2., 0., 3.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; iv(0, points)\n&quot;</span>
    <span class="s0">&quot;array([2.2795853 , 1.        , 4.88079259])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;If `z` is an array, the order parameter `v` must be broadcastable to\n&quot;</span>
    <span class="s0">&quot;the correct shape if different orders shall be computed in one call.\n&quot;</span>
    <span class="s0">&quot;To calculate the orders 0 and 1 for an 1D array:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; orders = np.array([[0], [1]])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; orders.shape\n&quot;</span>
    <span class="s0">&quot;(2, 1)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; iv(orders, points)\n&quot;</span>
    <span class="s0">&quot;array([[ 2.2795853 ,  1.        ,  4.88079259],\n&quot;</span>
    <span class="s0">&quot;       [-1.59063685,  0.        ,  3.95337022]])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the functions of order 0 to 3 from -5 to 5.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-5., 5., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for i in range(4):\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, iv(i, x), label=f'$I_{i!r}$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_iv_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_iv_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_fF_F</span>
<span class="s0">ufunc_iv_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_iv_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_dD_D</span>
<span class="s0">ufunc_iv_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_iv_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_iv_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_iv_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_iv_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_iv_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_iv_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_iv_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_iv_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_iv_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_iv_types[10] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_iv_types[11] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_iv_ptr[2*0] = &lt;void*&gt;_func_iv</span>
<span class="s0">ufunc_iv_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;iv&quot;)</span>
<span class="s0">ufunc_iv_ptr[2*1] = &lt;void*&gt;_func_cbesi_wrap</span>
<span class="s0">ufunc_iv_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;iv&quot;)</span>
<span class="s0">ufunc_iv_ptr[2*2] = &lt;void*&gt;_func_iv</span>
<span class="s0">ufunc_iv_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;iv&quot;)</span>
<span class="s0">ufunc_iv_ptr[2*3] = &lt;void*&gt;_func_cbesi_wrap</span>
<span class="s0">ufunc_iv_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;iv&quot;)</span>
<span class="s0">ufunc_iv_data[0] = &amp;ufunc_iv_ptr[2*0]</span>
<span class="s0">ufunc_iv_data[1] = &amp;ufunc_iv_ptr[2*1]</span>
<span class="s0">ufunc_iv_data[2] = &amp;ufunc_iv_ptr[2*2]</span>
<span class="s0">ufunc_iv_data[3] = &amp;ufunc_iv_ptr[2*3]</span>
<span class="s0">iv = np.PyUFunc_FromFuncAndData(ufunc_iv_loops, ufunc_iv_data, ufunc_iv_types, 4, 2, 1, 0, &quot;iv&quot;, ufunc_iv_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_ive_loops[4]</span>
<span class="s0">cdef void *ufunc_ive_ptr[8]</span>
<span class="s0">cdef void *ufunc_ive_data[4]</span>
<span class="s0">cdef char ufunc_ive_types[12]</span>
<span class="s0">cdef char *ufunc_ive_doc = (</span>
    <span class="s0">&quot;ive(v, z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Exponentially scaled modified Bessel function of the first kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined as::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    ive(v, z) = iv(v, z) * exp(-abs(z.real))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For imaginary numbers without a real part, returns the unscaled\n&quot;</span>
    <span class="s0">&quot;Bessel function of the first kind `iv`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;v : array_like of float\n&quot;</span>
    <span class="s0">&quot;    Order.\n&quot;</span>
    <span class="s0">&quot;z : array_like of float or complex\n&quot;</span>
    <span class="s0">&quot;    Argument.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the exponentially scaled modified Bessel function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;For positive `v`, the AMOS [1]_ `zbesi` routine is called. It uses a\n&quot;</span>
    <span class="s0">&quot;power series for small `z`, the asymptotic expansion for large\n&quot;</span>
    <span class="s0">&quot;`abs(z)`, the Miller algorithm normalized by the Wronskian and a\n&quot;</span>
    <span class="s0">&quot;Neumann series for intermediate magnitudes, and the uniform asymptotic\n&quot;</span>
    <span class="s0">&quot;expansions for :math:`I_v(z)` and :math:`J_v(z)` for large orders.\n&quot;</span>
    <span class="s0">&quot;Backward recurrence is used to generate sequences or reduce orders when\n&quot;</span>
    <span class="s0">&quot;necessary.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The calculations above are done in the right half plane and continued\n&quot;</span>
    <span class="s0">&quot;into the left half plane by the formula,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: I_v(z \\exp(\\pm\\imath\\pi)) = \\exp(\\pm\\pi v) I_v(z)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;(valid when the real part of `z` is positive).  For negative `v`, the\n&quot;</span>
    <span class="s0">&quot;formula\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: I_{-v}(z) = I_v(z) + \\frac{2}{\\pi} \\sin(\\pi v) K_v(z)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;is used, where :math:`K_v(z)` is the modified Bessel function of the\n&quot;</span>
    <span class="s0">&quot;second kind, evaluated using the AMOS routine `zbesk`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;`ive` is useful for large arguments `z`: for these, `iv` easily overflows,\n&quot;</span>
    <span class="s0">&quot;while `ive` does not due to the exponential scaling.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;iv: Modified Bessel function of the first kind\n&quot;</span>
    <span class="s0">&quot;i0e: Faster implementation of this function for order 0\n&quot;</span>
    <span class="s0">&quot;i1e: Faster implementation of this function for order 1\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Donald E. Amos, \&quot;AMOS, A Portable Package for Bessel Functions\n&quot;</span>
    <span class="s0">&quot;       of a Complex Argument and Nonnegative Order\&quot;,\n&quot;</span>
    <span class="s0">&quot;       http://netlib.org/amos/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;In the following example `iv` returns infinity whereas `ive` still returns\n&quot;</span>
    <span class="s0">&quot;a finite number.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import iv, ive\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; iv(3, 1000.), ive(3, 1000.)\n&quot;</span>
    <span class="s0">&quot;(inf, 0.01256056218254712)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate the function at one point for different orders by\n&quot;</span>
    <span class="s0">&quot;providing a list or NumPy array as argument for the `v` parameter:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ive([0, 1, 1.5], 1.)\n&quot;</span>
    <span class="s0">&quot;array([0.46575961, 0.20791042, 0.10798193])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate the function at several points for order 0 by providing an\n&quot;</span>
    <span class="s0">&quot;array for `z`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; points = np.array([-2., 0., 3.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ive(0, points)\n&quot;</span>
    <span class="s0">&quot;array([0.30850832, 1.        , 0.24300035])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate the function at several points for different orders by\n&quot;</span>
    <span class="s0">&quot;providing arrays for both `v` for `z`. Both arrays have to be\n&quot;</span>
    <span class="s0">&quot;broadcastable to the correct shape. To calculate the orders 0, 1\n&quot;</span>
    <span class="s0">&quot;and 2 for a 1D array of points:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ive([[0], [1], [2]], points)\n&quot;</span>
    <span class="s0">&quot;array([[ 0.30850832,  1.        ,  0.24300035],\n&quot;</span>
    <span class="s0">&quot;       [-0.21526929,  0.        ,  0.19682671],\n&quot;</span>
    <span class="s0">&quot;       [ 0.09323903,  0.        ,  0.11178255]])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the functions of order 0 to 3 from -5 to 5.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-5., 5., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for i in range(4):\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, ive(i, x), label=f'$I_{i!r}(z)\\cdot e^{{-|z|}}$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel(r\&quot;$z$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_ive_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_ive_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_fF_F</span>
<span class="s0">ufunc_ive_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_ive_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_dD_D</span>
<span class="s0">ufunc_ive_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ive_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ive_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ive_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ive_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_ive_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_ive_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ive_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ive_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ive_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ive_types[10] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_ive_types[11] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_ive_ptr[2*0] = &lt;void*&gt;_func_cbesi_wrap_e_real</span>
<span class="s0">ufunc_ive_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ive&quot;)</span>
<span class="s0">ufunc_ive_ptr[2*1] = &lt;void*&gt;_func_cbesi_wrap_e</span>
<span class="s0">ufunc_ive_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ive&quot;)</span>
<span class="s0">ufunc_ive_ptr[2*2] = &lt;void*&gt;_func_cbesi_wrap_e_real</span>
<span class="s0">ufunc_ive_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ive&quot;)</span>
<span class="s0">ufunc_ive_ptr[2*3] = &lt;void*&gt;_func_cbesi_wrap_e</span>
<span class="s0">ufunc_ive_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ive&quot;)</span>
<span class="s0">ufunc_ive_data[0] = &amp;ufunc_ive_ptr[2*0]</span>
<span class="s0">ufunc_ive_data[1] = &amp;ufunc_ive_ptr[2*1]</span>
<span class="s0">ufunc_ive_data[2] = &amp;ufunc_ive_ptr[2*2]</span>
<span class="s0">ufunc_ive_data[3] = &amp;ufunc_ive_ptr[2*3]</span>
<span class="s0">ive = np.PyUFunc_FromFuncAndData(ufunc_ive_loops, ufunc_ive_data, ufunc_ive_types, 4, 2, 1, 0, &quot;ive&quot;, ufunc_ive_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_j0_loops[2]</span>
<span class="s0">cdef void *ufunc_j0_ptr[4]</span>
<span class="s0">cdef void *ufunc_j0_data[2]</span>
<span class="s0">cdef char ufunc_j0_types[4]</span>
<span class="s0">cdef char *ufunc_j0_doc = (</span>
    <span class="s0">&quot;j0(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Bessel function of the first kind of order 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;J : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the Bessel function of the first kind of order 0 at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The domain is divided into the intervals [0, 5] and (5, infinity). In the\n&quot;</span>
    <span class="s0">&quot;first interval the following rational approximation is used:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    J_0(x) \\approx (w - r_1^2)(w - r_2^2) \\frac{P_3(w)}{Q_8(w)},\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`w = x^2` and :math:`r_1`, :math:`r_2` are the zeros of\n&quot;</span>
    <span class="s0">&quot;:math:`J_0`, and :math:`P_3` and :math:`Q_8` are polynomials of degrees 3\n&quot;</span>
    <span class="s0">&quot;and 8, respectively.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;In the second interval, the Hankel asymptotic expansion is employed with\n&quot;</span>
    <span class="s0">&quot;two rational functions of degree 6/6 and 7/7.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is a wrapper for the Cephes [1]_ routine `j0`.\n&quot;</span>
    <span class="s0">&quot;It should not be confused with the spherical Bessel functions (see\n&quot;</span>
    <span class="s0">&quot;`spherical_jn`).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;jv : Bessel function of real order and complex argument.\n&quot;</span>
    <span class="s0">&quot;spherical_jn : spherical Bessel functions.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Calculate the function at one point:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import j0\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; j0(1.)\n&quot;</span>
    <span class="s0">&quot;0.7651976865579665\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the function at several points:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; j0(np.array([-2., 0., 4.]))\n&quot;</span>
    <span class="s0">&quot;array([ 0.22389078,  1.        , -0.39714981])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function from -20 to 20.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-20., 20., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = j0(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, y)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_j0_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_j0_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_j0_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_j0_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_j0_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_j0_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_j0_ptr[2*0] = &lt;void*&gt;_func_j0</span>
<span class="s0">ufunc_j0_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;j0&quot;)</span>
<span class="s0">ufunc_j0_ptr[2*1] = &lt;void*&gt;_func_j0</span>
<span class="s0">ufunc_j0_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;j0&quot;)</span>
<span class="s0">ufunc_j0_data[0] = &amp;ufunc_j0_ptr[2*0]</span>
<span class="s0">ufunc_j0_data[1] = &amp;ufunc_j0_ptr[2*1]</span>
<span class="s0">j0 = np.PyUFunc_FromFuncAndData(ufunc_j0_loops, ufunc_j0_data, ufunc_j0_types, 2, 1, 1, 0, &quot;j0&quot;, ufunc_j0_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_j1_loops[2]</span>
<span class="s0">cdef void *ufunc_j1_ptr[4]</span>
<span class="s0">cdef void *ufunc_j1_data[2]</span>
<span class="s0">cdef char ufunc_j1_types[4]</span>
<span class="s0">cdef char *ufunc_j1_doc = (</span>
    <span class="s0">&quot;j1(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Bessel function of the first kind of order 1.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;J : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the Bessel function of the first kind of order 1 at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The domain is divided into the intervals [0, 8] and (8, infinity). In the\n&quot;</span>
    <span class="s0">&quot;first interval a 24 term Chebyshev expansion is used. In the second, the\n&quot;</span>
    <span class="s0">&quot;asymptotic trigonometric representation is employed using two rational\n&quot;</span>
    <span class="s0">&quot;functions of degree 5/5.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is a wrapper for the Cephes [1]_ routine `j1`.\n&quot;</span>
    <span class="s0">&quot;It should not be confused with the spherical Bessel functions (see\n&quot;</span>
    <span class="s0">&quot;`spherical_jn`).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;jv: Bessel function of the first kind\n&quot;</span>
    <span class="s0">&quot;spherical_jn: spherical Bessel functions.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Calculate the function at one point:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import j1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; j1(1.)\n&quot;</span>
    <span class="s0">&quot;0.44005058574493355\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the function at several points:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; j1(np.array([-2., 0., 4.]))\n&quot;</span>
    <span class="s0">&quot;array([-0.57672481,  0.        , -0.06604333])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function from -20 to 20.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-20., 20., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = j1(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, y)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_j1_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_j1_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_j1_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_j1_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_j1_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_j1_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_j1_ptr[2*0] = &lt;void*&gt;_func_j1</span>
<span class="s0">ufunc_j1_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;j1&quot;)</span>
<span class="s0">ufunc_j1_ptr[2*1] = &lt;void*&gt;_func_j1</span>
<span class="s0">ufunc_j1_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;j1&quot;)</span>
<span class="s0">ufunc_j1_data[0] = &amp;ufunc_j1_ptr[2*0]</span>
<span class="s0">ufunc_j1_data[1] = &amp;ufunc_j1_ptr[2*1]</span>
<span class="s0">j1 = np.PyUFunc_FromFuncAndData(ufunc_j1_loops, ufunc_j1_data, ufunc_j1_types, 2, 1, 1, 0, &quot;j1&quot;, ufunc_j1_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_jv_loops[4]</span>
<span class="s0">cdef void *ufunc_jv_ptr[8]</span>
<span class="s0">cdef void *ufunc_jv_data[4]</span>
<span class="s0">cdef char ufunc_jv_types[12]</span>
<span class="s0">cdef char *ufunc_jv_doc = (</span>
    <span class="s0">&quot;jv(v, z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Bessel function of the first kind of real order and complex argument.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;v : array_like\n&quot;</span>
    <span class="s0">&quot;    Order (float).\n&quot;</span>
    <span class="s0">&quot;z : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float or complex).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;J : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the Bessel function, :math:`J_v(z)`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;jve : :math:`J_v` with leading exponential behavior stripped off.\n&quot;</span>
    <span class="s0">&quot;spherical_jn : spherical Bessel functions.\n&quot;</span>
    <span class="s0">&quot;j0 : faster version of this function for order 0.\n&quot;</span>
    <span class="s0">&quot;j1 : faster version of this function for order 1.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;For positive `v` values, the computation is carried out using the AMOS\n&quot;</span>
    <span class="s0">&quot;[1]_ `zbesj` routine, which exploits the connection to the modified\n&quot;</span>
    <span class="s0">&quot;Bessel function :math:`I_v`,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    J_v(z) = \\exp(v\\pi\\imath/2) I_v(-\\imath z)\\qquad (\\Im z &gt; 0)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    J_v(z) = \\exp(-v\\pi\\imath/2) I_v(\\imath z)\\qquad (\\Im z &lt; 0)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For negative `v` values the formula,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: J_{-v}(z) = J_v(z) \\cos(\\pi v) - Y_v(z) \\sin(\\pi v)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;is used, where :math:`Y_v(z)` is the Bessel function of the second\n&quot;</span>
    <span class="s0">&quot;kind, computed using the AMOS routine `zbesy`.  Note that the second\n&quot;</span>
    <span class="s0">&quot;term is exactly zero for integer `v`; to improve accuracy the second\n&quot;</span>
    <span class="s0">&quot;term is explicitly omitted for `v` values such that `v = floor(v)`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Not to be confused with the spherical Bessel functions (see `spherical_jn`).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Donald E. Amos, \&quot;AMOS, A Portable Package for Bessel Functions\n&quot;</span>
    <span class="s0">&quot;       of a Complex Argument and Nonnegative Order\&quot;,\n&quot;</span>
    <span class="s0">&quot;       http://netlib.org/amos/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Evaluate the function of order 0 at one point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import jv\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; jv(0, 1.)\n&quot;</span>
    <span class="s0">&quot;0.7651976865579666\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate the function at one point for different orders.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; jv(0, 1.), jv(1, 1.), jv(1.5, 1.)\n&quot;</span>
    <span class="s0">&quot;(0.7651976865579666, 0.44005058574493355, 0.24029783912342725)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The evaluation for different orders can be carried out in one call by\n&quot;</span>
    <span class="s0">&quot;providing a list or NumPy array as argument for the `v` parameter:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; jv([0, 1, 1.5], 1.)\n&quot;</span>
    <span class="s0">&quot;array([0.76519769, 0.44005059, 0.24029784])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate the function at several points for order 0 by providing an\n&quot;</span>
    <span class="s0">&quot;array for `z`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; points = np.array([-2., 0., 3.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; jv(0, points)\n&quot;</span>
    <span class="s0">&quot;array([ 0.22389078,  1.        , -0.26005195])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;If `z` is an array, the order parameter `v` must be broadcastable to\n&quot;</span>
    <span class="s0">&quot;the correct shape if different orders shall be computed in one call.\n&quot;</span>
    <span class="s0">&quot;To calculate the orders 0 and 1 for an 1D array:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; orders = np.array([[0], [1]])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; orders.shape\n&quot;</span>
    <span class="s0">&quot;(2, 1)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; jv(orders, points)\n&quot;</span>
    <span class="s0">&quot;array([[ 0.22389078,  1.        , -0.26005195],\n&quot;</span>
    <span class="s0">&quot;       [-0.57672481,  0.        ,  0.33905896]])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the functions of order 0 to 3 from -10 to 10.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-10., 10., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for i in range(4):\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, jv(i, x), label=f'$J_{i!r}$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_jv_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_jv_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_fF_F</span>
<span class="s0">ufunc_jv_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_jv_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_dD_D</span>
<span class="s0">ufunc_jv_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_jv_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_jv_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_jv_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_jv_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_jv_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_jv_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_jv_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_jv_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_jv_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_jv_types[10] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_jv_types[11] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_jv_ptr[2*0] = &lt;void*&gt;_func_cbesj_wrap_real</span>
<span class="s0">ufunc_jv_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;jv&quot;)</span>
<span class="s0">ufunc_jv_ptr[2*1] = &lt;void*&gt;_func_cbesj_wrap</span>
<span class="s0">ufunc_jv_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;jv&quot;)</span>
<span class="s0">ufunc_jv_ptr[2*2] = &lt;void*&gt;_func_cbesj_wrap_real</span>
<span class="s0">ufunc_jv_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;jv&quot;)</span>
<span class="s0">ufunc_jv_ptr[2*3] = &lt;void*&gt;_func_cbesj_wrap</span>
<span class="s0">ufunc_jv_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;jv&quot;)</span>
<span class="s0">ufunc_jv_data[0] = &amp;ufunc_jv_ptr[2*0]</span>
<span class="s0">ufunc_jv_data[1] = &amp;ufunc_jv_ptr[2*1]</span>
<span class="s0">ufunc_jv_data[2] = &amp;ufunc_jv_ptr[2*2]</span>
<span class="s0">ufunc_jv_data[3] = &amp;ufunc_jv_ptr[2*3]</span>
<span class="s0">jv = np.PyUFunc_FromFuncAndData(ufunc_jv_loops, ufunc_jv_data, ufunc_jv_types, 4, 2, 1, 0, &quot;jv&quot;, ufunc_jv_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_jve_loops[4]</span>
<span class="s0">cdef void *ufunc_jve_ptr[8]</span>
<span class="s0">cdef void *ufunc_jve_data[4]</span>
<span class="s0">cdef char ufunc_jve_types[12]</span>
<span class="s0">cdef char *ufunc_jve_doc = (</span>
    <span class="s0">&quot;jve(v, z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Exponentially scaled Bessel function of the first kind of order `v`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined as::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    jve(v, z) = jv(v, z) * exp(-abs(z.imag))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;v : array_like\n&quot;</span>
    <span class="s0">&quot;    Order (float).\n&quot;</span>
    <span class="s0">&quot;z : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float or complex).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;J : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the exponentially scaled Bessel function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;jv: Unscaled Bessel function of the first kind\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;For positive `v` values, the computation is carried out using the AMOS\n&quot;</span>
    <span class="s0">&quot;[1]_ `zbesj` routine, which exploits the connection to the modified\n&quot;</span>
    <span class="s0">&quot;Bessel function :math:`I_v`,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    J_v(z) = \\exp(v\\pi\\imath/2) I_v(-\\imath z)\\qquad (\\Im z &gt; 0)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    J_v(z) = \\exp(-v\\pi\\imath/2) I_v(\\imath z)\\qquad (\\Im z &lt; 0)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For negative `v` values the formula,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: J_{-v}(z) = J_v(z) \\cos(\\pi v) - Y_v(z) \\sin(\\pi v)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;is used, where :math:`Y_v(z)` is the Bessel function of the second\n&quot;</span>
    <span class="s0">&quot;kind, computed using the AMOS routine `zbesy`.  Note that the second\n&quot;</span>
    <span class="s0">&quot;term is exactly zero for integer `v`; to improve accuracy the second\n&quot;</span>
    <span class="s0">&quot;term is explicitly omitted for `v` values such that `v = floor(v)`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Exponentially scaled Bessel functions are useful for large arguments `z`:\n&quot;</span>
    <span class="s0">&quot;for these, the unscaled Bessel functions can easily under-or overflow.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Donald E. Amos, \&quot;AMOS, A Portable Package for Bessel Functions\n&quot;</span>
    <span class="s0">&quot;       of a Complex Argument and Nonnegative Order\&quot;,\n&quot;</span>
    <span class="s0">&quot;       http://netlib.org/amos/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Compare the output of `jv` and `jve` for large complex arguments for `z`\n&quot;</span>
    <span class="s0">&quot;by computing their values for order ``v=1`` at ``z=1000j``. We see that\n&quot;</span>
    <span class="s0">&quot;`jv` overflows but `jve` returns a finite number:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import jv, jve\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; v = 1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z = 1000j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; jv(v, z), jve(v, z)\n&quot;</span>
    <span class="s0">&quot;((inf+infj), (7.721967686709077e-19+0.012610930256928629j))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For real arguments for `z`, `jve` returns the same as `jv`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; v, z = 1, 1000\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; jv(v, z), jve(v, z)\n&quot;</span>
    <span class="s0">&quot;(0.004728311907089523, 0.004728311907089523)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function can be evaluated for several orders at the same time by\n&quot;</span>
    <span class="s0">&quot;providing a list or NumPy array for `v`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; jve([1, 3, 5], 1j)\n&quot;</span>
    <span class="s0">&quot;array([1.27304208e-17+2.07910415e-01j, -4.99352086e-19-8.15530777e-03j,\n&quot;</span>
    <span class="s0">&quot;       6.11480940e-21+9.98657141e-05j])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;In the same way, the function can be evaluated at several points in one\n&quot;</span>
    <span class="s0">&quot;call by providing a list or NumPy array for `z`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; jve(1, np.array([1j, 2j, 3j]))\n&quot;</span>
    <span class="s0">&quot;array([1.27308412e-17+0.20791042j, 1.31814423e-17+0.21526929j,\n&quot;</span>
    <span class="s0">&quot;       1.20521602e-17+0.19682671j])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is also possible to evaluate several orders at several points\n&quot;</span>
    <span class="s0">&quot;at the same time by providing arrays for `v` and `z` with\n&quot;</span>
    <span class="s0">&quot;compatible shapes for broadcasting. Compute `jve` for two different orders\n&quot;</span>
    <span class="s0">&quot;`v` and three points `z` resulting in a 2x3 array.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; v = np.array([[1], [3]])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z = np.array([1j, 2j, 3j])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; v.shape, z.shape\n&quot;</span>
    <span class="s0">&quot;((2, 1), (3,))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; jve(v, z)\n&quot;</span>
    <span class="s0">&quot;array([[1.27304208e-17+0.20791042j,  1.31810070e-17+0.21526929j,\n&quot;</span>
    <span class="s0">&quot;        1.20517622e-17+0.19682671j],\n&quot;</span>
    <span class="s0">&quot;       [-4.99352086e-19-0.00815531j, -1.76289571e-18-0.02879122j,\n&quot;</span>
    <span class="s0">&quot;        -2.92578784e-18-0.04778332j]])&quot;)</span>
<span class="s0">ufunc_jve_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_jve_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_fF_F</span>
<span class="s0">ufunc_jve_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_jve_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_dD_D</span>
<span class="s0">ufunc_jve_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_jve_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_jve_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_jve_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_jve_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_jve_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_jve_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_jve_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_jve_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_jve_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_jve_types[10] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_jve_types[11] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_jve_ptr[2*0] = &lt;void*&gt;_func_cbesj_wrap_e_real</span>
<span class="s0">ufunc_jve_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;jve&quot;)</span>
<span class="s0">ufunc_jve_ptr[2*1] = &lt;void*&gt;_func_cbesj_wrap_e</span>
<span class="s0">ufunc_jve_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;jve&quot;)</span>
<span class="s0">ufunc_jve_ptr[2*2] = &lt;void*&gt;_func_cbesj_wrap_e_real</span>
<span class="s0">ufunc_jve_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;jve&quot;)</span>
<span class="s0">ufunc_jve_ptr[2*3] = &lt;void*&gt;_func_cbesj_wrap_e</span>
<span class="s0">ufunc_jve_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;jve&quot;)</span>
<span class="s0">ufunc_jve_data[0] = &amp;ufunc_jve_ptr[2*0]</span>
<span class="s0">ufunc_jve_data[1] = &amp;ufunc_jve_ptr[2*1]</span>
<span class="s0">ufunc_jve_data[2] = &amp;ufunc_jve_ptr[2*2]</span>
<span class="s0">ufunc_jve_data[3] = &amp;ufunc_jve_ptr[2*3]</span>
<span class="s0">jve = np.PyUFunc_FromFuncAndData(ufunc_jve_loops, ufunc_jve_data, ufunc_jve_types, 4, 2, 1, 0, &quot;jve&quot;, ufunc_jve_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_k0_loops[2]</span>
<span class="s0">cdef void *ufunc_k0_ptr[4]</span>
<span class="s0">cdef void *ufunc_k0_data[2]</span>
<span class="s0">cdef char ufunc_k0_types[4]</span>
<span class="s0">cdef char *ufunc_k0_doc = (</span>
    <span class="s0">&quot;k0(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Modified Bessel function of the second kind of order 0, :math:`K_0`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is also sometimes referred to as the modified Bessel\n&quot;</span>
    <span class="s0">&quot;function of the third kind of order 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;K : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the modified Bessel function :math:`K_0` at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The range is partitioned into the two intervals [0, 2] and (2, infinity).\n&quot;</span>
    <span class="s0">&quot;Chebyshev polynomial expansions are employed in each interval.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is a wrapper for the Cephes [1]_ routine `k0`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;kv: Modified Bessel function of the second kind of any order\n&quot;</span>
    <span class="s0">&quot;k0e: Exponentially scaled modified Bessel function of the second kind\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Calculate the function at one point:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import k0\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k0(1.)\n&quot;</span>
    <span class="s0">&quot;0.42102443824070823\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the function at several points:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k0(np.array([0.5, 2., 3.]))\n&quot;</span>
    <span class="s0">&quot;array([0.92441907, 0.11389387, 0.0347395 ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function from 0 to 10.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0., 10., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = k0(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, y)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_k0_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_k0_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_k0_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_k0_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_k0_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_k0_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_k0_ptr[2*0] = &lt;void*&gt;_func_k0</span>
<span class="s0">ufunc_k0_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;k0&quot;)</span>
<span class="s0">ufunc_k0_ptr[2*1] = &lt;void*&gt;_func_k0</span>
<span class="s0">ufunc_k0_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;k0&quot;)</span>
<span class="s0">ufunc_k0_data[0] = &amp;ufunc_k0_ptr[2*0]</span>
<span class="s0">ufunc_k0_data[1] = &amp;ufunc_k0_ptr[2*1]</span>
<span class="s0">k0 = np.PyUFunc_FromFuncAndData(ufunc_k0_loops, ufunc_k0_data, ufunc_k0_types, 2, 1, 1, 0, &quot;k0&quot;, ufunc_k0_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_k0e_loops[2]</span>
<span class="s0">cdef void *ufunc_k0e_ptr[4]</span>
<span class="s0">cdef void *ufunc_k0e_data[2]</span>
<span class="s0">cdef char ufunc_k0e_types[4]</span>
<span class="s0">cdef char *ufunc_k0e_doc = (</span>
    <span class="s0">&quot;k0e(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Exponentially scaled modified Bessel function K of order 0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined as::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    k0e(x) = exp(x) * k0(x).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float)\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;K : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the exponentially scaled modified Bessel function K of order\n&quot;</span>
    <span class="s0">&quot;    0 at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The range is partitioned into the two intervals [0, 2] and (2, infinity).\n&quot;</span>
    <span class="s0">&quot;Chebyshev polynomial expansions are employed in each interval.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is a wrapper for the Cephes [1]_ routine `k0e`. `k0e` is\n&quot;</span>
    <span class="s0">&quot;useful for large arguments: for these, `k0` easily underflows.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;kv: Modified Bessel function of the second kind of any order\n&quot;</span>
    <span class="s0">&quot;k0: Modified Bessel function of the second kind\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;In the following example `k0` returns 0 whereas `k0e` still returns a\n&quot;</span>
    <span class="s0">&quot;useful finite number:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import k0, k0e\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k0(1000.), k0e(1000)\n&quot;</span>
    <span class="s0">&quot;(0., 0.03962832160075422)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the function at several points by providing a NumPy array or\n&quot;</span>
    <span class="s0">&quot;list for `x`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k0e(np.array([0.5, 2., 3.]))\n&quot;</span>
    <span class="s0">&quot;array([1.52410939, 0.84156822, 0.6977616 ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function from 0 to 10.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0., 10., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = k0e(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, y)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_k0e_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_k0e_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_k0e_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_k0e_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_k0e_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_k0e_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_k0e_ptr[2*0] = &lt;void*&gt;_func_k0e</span>
<span class="s0">ufunc_k0e_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;k0e&quot;)</span>
<span class="s0">ufunc_k0e_ptr[2*1] = &lt;void*&gt;_func_k0e</span>
<span class="s0">ufunc_k0e_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;k0e&quot;)</span>
<span class="s0">ufunc_k0e_data[0] = &amp;ufunc_k0e_ptr[2*0]</span>
<span class="s0">ufunc_k0e_data[1] = &amp;ufunc_k0e_ptr[2*1]</span>
<span class="s0">k0e = np.PyUFunc_FromFuncAndData(ufunc_k0e_loops, ufunc_k0e_data, ufunc_k0e_types, 2, 1, 1, 0, &quot;k0e&quot;, ufunc_k0e_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_k1_loops[2]</span>
<span class="s0">cdef void *ufunc_k1_ptr[4]</span>
<span class="s0">cdef void *ufunc_k1_data[2]</span>
<span class="s0">cdef char ufunc_k1_types[4]</span>
<span class="s0">cdef char *ufunc_k1_doc = (</span>
    <span class="s0">&quot;k1(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Modified Bessel function of the second kind of order 1, :math:`K_1(x)`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float)\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;K : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the modified Bessel function K of order 1 at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The range is partitioned into the two intervals [0, 2] and (2, infinity).\n&quot;</span>
    <span class="s0">&quot;Chebyshev polynomial expansions are employed in each interval.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is a wrapper for the Cephes [1]_ routine `k1`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;kv: Modified Bessel function of the second kind of any order\n&quot;</span>
    <span class="s0">&quot;k1e: Exponentially scaled modified Bessel function K of order 1\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Calculate the function at one point:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import k1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k1(1.)\n&quot;</span>
    <span class="s0">&quot;0.6019072301972346\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the function at several points:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k1(np.array([0.5, 2., 3.]))\n&quot;</span>
    <span class="s0">&quot;array([1.65644112, 0.13986588, 0.04015643])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function from 0 to 10.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0., 10., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = k1(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, y)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_k1_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_k1_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_k1_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_k1_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_k1_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_k1_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_k1_ptr[2*0] = &lt;void*&gt;_func_k1</span>
<span class="s0">ufunc_k1_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;k1&quot;)</span>
<span class="s0">ufunc_k1_ptr[2*1] = &lt;void*&gt;_func_k1</span>
<span class="s0">ufunc_k1_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;k1&quot;)</span>
<span class="s0">ufunc_k1_data[0] = &amp;ufunc_k1_ptr[2*0]</span>
<span class="s0">ufunc_k1_data[1] = &amp;ufunc_k1_ptr[2*1]</span>
<span class="s0">k1 = np.PyUFunc_FromFuncAndData(ufunc_k1_loops, ufunc_k1_data, ufunc_k1_types, 2, 1, 1, 0, &quot;k1&quot;, ufunc_k1_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_k1e_loops[2]</span>
<span class="s0">cdef void *ufunc_k1e_ptr[4]</span>
<span class="s0">cdef void *ufunc_k1e_data[2]</span>
<span class="s0">cdef char ufunc_k1e_types[4]</span>
<span class="s0">cdef char *ufunc_k1e_doc = (</span>
    <span class="s0">&quot;k1e(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Exponentially scaled modified Bessel function K of order 1\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined as::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    k1e(x) = exp(x) * k1(x)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float)\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;K : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the exponentially scaled modified Bessel function K of order\n&quot;</span>
    <span class="s0">&quot;    1 at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The range is partitioned into the two intervals [0, 2] and (2, infinity).\n&quot;</span>
    <span class="s0">&quot;Chebyshev polynomial expansions are employed in each interval.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is a wrapper for the Cephes [1]_ routine `k1e`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;kv: Modified Bessel function of the second kind of any order\n&quot;</span>
    <span class="s0">&quot;k1: Modified Bessel function of the second kind of order 1\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;In the following example `k1` returns 0 whereas `k1e` still returns a\n&quot;</span>
    <span class="s0">&quot;useful floating point number.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import k1, k1e\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k1(1000.), k1e(1000.)\n&quot;</span>
    <span class="s0">&quot;(0., 0.03964813081296021)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the function at several points by providing a NumPy array or\n&quot;</span>
    <span class="s0">&quot;list for `x`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k1e(np.array([0.5, 2., 3.]))\n&quot;</span>
    <span class="s0">&quot;array([2.73100971, 1.03347685, 0.80656348])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function from 0 to 10.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0., 10., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = k1e(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, y)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_k1e_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_k1e_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_k1e_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_k1e_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_k1e_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_k1e_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_k1e_ptr[2*0] = &lt;void*&gt;_func_k1e</span>
<span class="s0">ufunc_k1e_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;k1e&quot;)</span>
<span class="s0">ufunc_k1e_ptr[2*1] = &lt;void*&gt;_func_k1e</span>
<span class="s0">ufunc_k1e_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;k1e&quot;)</span>
<span class="s0">ufunc_k1e_data[0] = &amp;ufunc_k1e_ptr[2*0]</span>
<span class="s0">ufunc_k1e_data[1] = &amp;ufunc_k1e_ptr[2*1]</span>
<span class="s0">k1e = np.PyUFunc_FromFuncAndData(ufunc_k1e_loops, ufunc_k1e_data, ufunc_k1e_types, 2, 1, 1, 0, &quot;k1e&quot;, ufunc_k1e_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_kei_loops[2]</span>
<span class="s0">cdef void *ufunc_kei_ptr[4]</span>
<span class="s0">cdef void *ufunc_kei_data[2]</span>
<span class="s0">cdef char ufunc_kei_types[4]</span>
<span class="s0">cdef char *ufunc_kei_doc = (</span>
    <span class="s0">&quot;kei(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Kelvin function kei.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    \\mathrm{kei}(x) = \\Im[K_0(x e^{\\pi i / 4})]\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`K_0` is the modified Bessel function of the second\n&quot;</span>
    <span class="s0">&quot;kind (see `kv`). See [dlmf]_ for more details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real argument.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Kelvin function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;ker : the corresponding real part\n&quot;</span>
    <span class="s0">&quot;keip : the derivative of kei\n&quot;</span>
    <span class="s0">&quot;kv : modified Bessel function of the second kind\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [dlmf] NIST, Digital Library of Mathematical Functions,\n&quot;</span>
    <span class="s0">&quot;    https://dlmf.nist.gov/10.61\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;It can be expressed using the modified Bessel function of the\n&quot;</span>
    <span class="s0">&quot;second kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.array([1.0, 2.0, 3.0, 4.0])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.kv(0, x * np.exp(np.pi * 1j / 4)).imag\n&quot;</span>
    <span class="s0">&quot;array([-0.49499464, -0.20240007, -0.05112188,  0.0021984 ])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.kei(x)\n&quot;</span>
    <span class="s0">&quot;array([-0.49499464, -0.20240007, -0.05112188,  0.0021984 ])&quot;)</span>
<span class="s0">ufunc_kei_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_kei_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_kei_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_kei_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_kei_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kei_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kei_ptr[2*0] = &lt;void*&gt;_func_kei_wrap</span>
<span class="s0">ufunc_kei_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;kei&quot;)</span>
<span class="s0">ufunc_kei_ptr[2*1] = &lt;void*&gt;_func_kei_wrap</span>
<span class="s0">ufunc_kei_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;kei&quot;)</span>
<span class="s0">ufunc_kei_data[0] = &amp;ufunc_kei_ptr[2*0]</span>
<span class="s0">ufunc_kei_data[1] = &amp;ufunc_kei_ptr[2*1]</span>
<span class="s0">kei = np.PyUFunc_FromFuncAndData(ufunc_kei_loops, ufunc_kei_data, ufunc_kei_types, 2, 1, 1, 0, &quot;kei&quot;, ufunc_kei_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_keip_loops[2]</span>
<span class="s0">cdef void *ufunc_keip_ptr[4]</span>
<span class="s0">cdef void *ufunc_keip_data[2]</span>
<span class="s0">cdef char ufunc_keip_types[4]</span>
<span class="s0">cdef char *ufunc_keip_doc = (</span>
    <span class="s0">&quot;keip(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Derivative of the Kelvin function kei.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real argument.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The values of the derivative of kei.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;kei\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [dlmf] NIST, Digital Library of Mathematical Functions,\n&quot;</span>
    <span class="s0">&quot;    https://dlmf.nist.gov/10#PT5&quot;)</span>
<span class="s0">ufunc_keip_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_keip_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_keip_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_keip_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_keip_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_keip_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_keip_ptr[2*0] = &lt;void*&gt;_func_keip_wrap</span>
<span class="s0">ufunc_keip_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;keip&quot;)</span>
<span class="s0">ufunc_keip_ptr[2*1] = &lt;void*&gt;_func_keip_wrap</span>
<span class="s0">ufunc_keip_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;keip&quot;)</span>
<span class="s0">ufunc_keip_data[0] = &amp;ufunc_keip_ptr[2*0]</span>
<span class="s0">ufunc_keip_data[1] = &amp;ufunc_keip_ptr[2*1]</span>
<span class="s0">keip = np.PyUFunc_FromFuncAndData(ufunc_keip_loops, ufunc_keip_data, ufunc_keip_types, 2, 1, 1, 0, &quot;keip&quot;, ufunc_keip_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_kelvin_loops[2]</span>
<span class="s0">cdef void *ufunc_kelvin_ptr[4]</span>
<span class="s0">cdef void *ufunc_kelvin_data[2]</span>
<span class="s0">cdef char ufunc_kelvin_types[10]</span>
<span class="s0">cdef char *ufunc_kelvin_doc = (</span>
    <span class="s0">&quot;kelvin(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Kelvin functions as complex numbers\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument\n&quot;</span>
    <span class="s0">&quot;out : tuple of ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output arrays for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;Be, Ke, Bep, Kep : 4-tuple of scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The tuple (Be, Ke, Bep, Kep) contains complex numbers\n&quot;</span>
    <span class="s0">&quot;    representing the real and imaginary Kelvin functions and their\n&quot;</span>
    <span class="s0">&quot;    derivatives evaluated at `x`.  For example, kelvin(x)[0].real =\n&quot;</span>
    <span class="s0">&quot;    ber x and kelvin(x)[0].imag = bei x with similar relationships\n&quot;</span>
    <span class="s0">&quot;    for ker and kei.&quot;)</span>
<span class="s0">ufunc_kelvin_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_d_DDDD_As_f_FFFF</span>
<span class="s0">ufunc_kelvin_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_i_d_DDDD_As_d_DDDD</span>
<span class="s0">ufunc_kelvin_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_kelvin_types[1] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_kelvin_types[2] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_kelvin_types[3] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_kelvin_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_kelvin_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kelvin_types[6] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_kelvin_types[7] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_kelvin_types[8] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_kelvin_types[9] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_kelvin_ptr[2*0] = &lt;void*&gt;_func_kelvin_wrap</span>
<span class="s0">ufunc_kelvin_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;kelvin&quot;)</span>
<span class="s0">ufunc_kelvin_ptr[2*1] = &lt;void*&gt;_func_kelvin_wrap</span>
<span class="s0">ufunc_kelvin_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;kelvin&quot;)</span>
<span class="s0">ufunc_kelvin_data[0] = &amp;ufunc_kelvin_ptr[2*0]</span>
<span class="s0">ufunc_kelvin_data[1] = &amp;ufunc_kelvin_ptr[2*1]</span>
<span class="s0">kelvin = np.PyUFunc_FromFuncAndData(ufunc_kelvin_loops, ufunc_kelvin_data, ufunc_kelvin_types, 2, 1, 4, 0, &quot;kelvin&quot;, ufunc_kelvin_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_ker_loops[2]</span>
<span class="s0">cdef void *ufunc_ker_ptr[4]</span>
<span class="s0">cdef void *ufunc_ker_data[2]</span>
<span class="s0">cdef char ufunc_ker_types[4]</span>
<span class="s0">cdef char *ufunc_ker_doc = (</span>
    <span class="s0">&quot;ker(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Kelvin function ker.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    \\mathrm{ker}(x) = \\Re[K_0(x e^{\\pi i / 4})]\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Where :math:`K_0` is the modified Bessel function of the second\n&quot;</span>
    <span class="s0">&quot;kind (see `kv`). See [dlmf]_ for more details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real argument.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Kelvin function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;kei : the corresponding imaginary part\n&quot;</span>
    <span class="s0">&quot;kerp : the derivative of ker\n&quot;</span>
    <span class="s0">&quot;kv : modified Bessel function of the second kind\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [dlmf] NIST, Digital Library of Mathematical Functions,\n&quot;</span>
    <span class="s0">&quot;    https://dlmf.nist.gov/10.61\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;It can be expressed using the modified Bessel function of the\n&quot;</span>
    <span class="s0">&quot;second kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.array([1.0, 2.0, 3.0, 4.0])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.kv(0, x * np.exp(np.pi * 1j / 4)).real\n&quot;</span>
    <span class="s0">&quot;array([ 0.28670621, -0.04166451, -0.06702923, -0.03617885])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.ker(x)\n&quot;</span>
    <span class="s0">&quot;array([ 0.28670621, -0.04166451, -0.06702923, -0.03617885])&quot;)</span>
<span class="s0">ufunc_ker_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_ker_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_ker_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ker_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ker_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ker_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ker_ptr[2*0] = &lt;void*&gt;_func_ker_wrap</span>
<span class="s0">ufunc_ker_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ker&quot;)</span>
<span class="s0">ufunc_ker_ptr[2*1] = &lt;void*&gt;_func_ker_wrap</span>
<span class="s0">ufunc_ker_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ker&quot;)</span>
<span class="s0">ufunc_ker_data[0] = &amp;ufunc_ker_ptr[2*0]</span>
<span class="s0">ufunc_ker_data[1] = &amp;ufunc_ker_ptr[2*1]</span>
<span class="s0">ker = np.PyUFunc_FromFuncAndData(ufunc_ker_loops, ufunc_ker_data, ufunc_ker_types, 2, 1, 1, 0, &quot;ker&quot;, ufunc_ker_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_kerp_loops[2]</span>
<span class="s0">cdef void *ufunc_kerp_ptr[4]</span>
<span class="s0">cdef void *ufunc_kerp_data[2]</span>
<span class="s0">cdef char ufunc_kerp_types[4]</span>
<span class="s0">cdef char *ufunc_kerp_doc = (</span>
    <span class="s0">&quot;kerp(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Derivative of the Kelvin function ker.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real argument.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the derivative of ker.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;ker\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [dlmf] NIST, Digital Library of Mathematical Functions,\n&quot;</span>
    <span class="s0">&quot;    https://dlmf.nist.gov/10#PT5&quot;)</span>
<span class="s0">ufunc_kerp_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_kerp_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_kerp_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_kerp_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_kerp_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kerp_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kerp_ptr[2*0] = &lt;void*&gt;_func_kerp_wrap</span>
<span class="s0">ufunc_kerp_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;kerp&quot;)</span>
<span class="s0">ufunc_kerp_ptr[2*1] = &lt;void*&gt;_func_kerp_wrap</span>
<span class="s0">ufunc_kerp_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;kerp&quot;)</span>
<span class="s0">ufunc_kerp_data[0] = &amp;ufunc_kerp_ptr[2*0]</span>
<span class="s0">ufunc_kerp_data[1] = &amp;ufunc_kerp_ptr[2*1]</span>
<span class="s0">kerp = np.PyUFunc_FromFuncAndData(ufunc_kerp_loops, ufunc_kerp_data, ufunc_kerp_types, 2, 1, 1, 0, &quot;kerp&quot;, ufunc_kerp_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_kl_div_loops[2]</span>
<span class="s0">cdef void *ufunc_kl_div_ptr[4]</span>
<span class="s0">cdef void *ufunc_kl_div_data[2]</span>
<span class="s0">cdef char ufunc_kl_div_types[6]</span>
<span class="s0">cdef char *ufunc_kl_div_doc = (</span>
    <span class="s0">&quot;kl_div(x, y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Elementwise function for computing Kullback-Leibler divergence.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    \\mathrm{kl\\_div}(x, y) =\n&quot;</span>
    <span class="s0">&quot;      \\begin{cases}\n&quot;</span>
    <span class="s0">&quot;        x \\log(x / y) - x + y &amp; x &gt; 0, y &gt; 0 \\\\\n&quot;</span>
    <span class="s0">&quot;        y &amp; x = 0, y \\ge 0 \\\\\n&quot;</span>
    <span class="s0">&quot;        \\infty &amp; \\text{otherwise}\n&quot;</span>
    <span class="s0">&quot;      \\end{cases}\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x, y : array_like\n&quot;</span>
    <span class="s0">&quot;    Real arguments\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Kullback-Liebler divergence.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;entr, rel_entr, scipy.stats.entropy\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 0.15.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is non-negative and is jointly convex in `x` and `y`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The origin of this function is in convex programming; see [1]_ for\n&quot;</span>
    <span class="s0">&quot;details. This is why the function contains the extra :math:`-x\n&quot;</span>
    <span class="s0">&quot;+ y` terms over what might be expected from the Kullback-Leibler\n&quot;</span>
    <span class="s0">&quot;divergence. For a version of the function without the extra terms,\n&quot;</span>
    <span class="s0">&quot;see `rel_entr`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Boyd, Stephen and Lieven Vandenberghe. *Convex optimization*.\n&quot;</span>
    <span class="s0">&quot;       Cambridge University Press, 2004.\n&quot;</span>
    <span class="s0">&quot;       :doi:`https://doi.org/10.1017/CBO9780511804441`&quot;)</span>
<span class="s0">ufunc_kl_div_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_kl_div_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_kl_div_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_kl_div_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_kl_div_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_kl_div_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kl_div_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kl_div_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kl_div_ptr[2*0] = &lt;void*&gt;_func_kl_div</span>
<span class="s0">ufunc_kl_div_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;kl_div&quot;)</span>
<span class="s0">ufunc_kl_div_ptr[2*1] = &lt;void*&gt;_func_kl_div</span>
<span class="s0">ufunc_kl_div_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;kl_div&quot;)</span>
<span class="s0">ufunc_kl_div_data[0] = &amp;ufunc_kl_div_ptr[2*0]</span>
<span class="s0">ufunc_kl_div_data[1] = &amp;ufunc_kl_div_ptr[2*1]</span>
<span class="s0">kl_div = np.PyUFunc_FromFuncAndData(ufunc_kl_div_loops, ufunc_kl_div_data, ufunc_kl_div_types, 2, 2, 1, 0, &quot;kl_div&quot;, ufunc_kl_div_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_kn_loops[3]</span>
<span class="s0">cdef void *ufunc_kn_ptr[6]</span>
<span class="s0">cdef void *ufunc_kn_data[3]</span>
<span class="s0">cdef char ufunc_kn_types[9]</span>
<span class="s0">cdef char *ufunc_kn_doc = (</span>
    <span class="s0">&quot;kn(n, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Modified Bessel function of the second kind of integer order `n`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the modified Bessel function of the second kind for integer order\n&quot;</span>
    <span class="s0">&quot;`n` at real `z`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;These are also sometimes called functions of the third kind, Basset\n&quot;</span>
    <span class="s0">&quot;functions, or Macdonald functions.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : array_like of int\n&quot;</span>
    <span class="s0">&quot;    Order of Bessel functions (floats will truncate with a warning)\n&quot;</span>
    <span class="s0">&quot;x : array_like of float\n&quot;</span>
    <span class="s0">&quot;    Argument at which to evaluate the Bessel functions\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the Modified Bessel function of the second kind,\n&quot;</span>
    <span class="s0">&quot;    :math:`K_n(x)`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for AMOS [1]_ routine `zbesk`.  For a discussion of the\n&quot;</span>
    <span class="s0">&quot;algorithm used, see [2]_ and the references therein.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;kv : Same function, but accepts real order and complex argument\n&quot;</span>
    <span class="s0">&quot;kvp : Derivative of this function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Donald E. Amos, \&quot;AMOS, A Portable Package for Bessel Functions\n&quot;</span>
    <span class="s0">&quot;       of a Complex Argument and Nonnegative Order\&quot;,\n&quot;</span>
    <span class="s0">&quot;       http://netlib.org/amos/\n&quot;</span>
    <span class="s0">&quot;.. [2] Donald E. Amos, \&quot;Algorithm 644: A portable package for Bessel\n&quot;</span>
    <span class="s0">&quot;       functions of a complex argument and nonnegative order\&quot;, ACM\n&quot;</span>
    <span class="s0">&quot;       TOMS Vol. 12 Issue 3, Sept. 1986, p. 265\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Plot the function of several orders for real input:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import kn\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for N in range(6):\n&quot;</span>
    <span class="s0">&quot;...     plt.plot(x, kn(N, x), label='$K_{}(x)$'.format(N))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.ylim(0, 10)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.title(r'Modified Bessel function of the second kind $K_n(x)$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate for a single value at multiple orders:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; kn([4, 5, 6], 1)\n&quot;</span>
    <span class="s0">&quot;array([   44.23241585,   360.9605896 ,  3653.83831186])&quot;)</span>
<span class="s0">ufunc_kn_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_id__As_ld_d</span>
<span class="s0">ufunc_kn_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_kn_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_kn_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc_kn_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kn_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kn_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_kn_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_kn_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_kn_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kn_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kn_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kn_ptr[2*0] = &lt;void*&gt;_func_cbesk_wrap_real_int</span>
<span class="s0">ufunc_kn_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;kn&quot;)</span>
<span class="s0">ufunc_kn_ptr[2*1] = &lt;void*&gt;_func_kn_unsafe</span>
<span class="s0">ufunc_kn_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;kn&quot;)</span>
<span class="s0">ufunc_kn_ptr[2*2] = &lt;void*&gt;_func_kn_unsafe</span>
<span class="s0">ufunc_kn_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;kn&quot;)</span>
<span class="s0">ufunc_kn_data[0] = &amp;ufunc_kn_ptr[2*0]</span>
<span class="s0">ufunc_kn_data[1] = &amp;ufunc_kn_ptr[2*1]</span>
<span class="s0">ufunc_kn_data[2] = &amp;ufunc_kn_ptr[2*2]</span>
<span class="s0">kn = np.PyUFunc_FromFuncAndData(ufunc_kn_loops, ufunc_kn_data, ufunc_kn_types, 3, 2, 1, 0, &quot;kn&quot;, ufunc_kn_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_kolmogi_loops[2]</span>
<span class="s0">cdef void *ufunc_kolmogi_ptr[4]</span>
<span class="s0">cdef void *ufunc_kolmogi_data[2]</span>
<span class="s0">cdef char ufunc_kolmogi_types[4]</span>
<span class="s0">cdef char *ufunc_kolmogi_doc = (</span>
    <span class="s0">&quot;kolmogi(p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse Survival Function of Kolmogorov distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is the inverse function to `kolmogorov`.\n&quot;</span>
    <span class="s0">&quot;Returns y such that ``kolmogorov(y) == p``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;p : float array_like\n&quot;</span>
    <span class="s0">&quot;    Probability\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The value(s) of kolmogi(p)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;`kolmogorov` is used by `stats.kstest` in the application of the\n&quot;</span>
    <span class="s0">&quot;Kolmogorov-Smirnov Goodness of Fit test. For historial reasons this\n&quot;</span>
    <span class="s0">&quot;function is exposed in `scpy.special`, but the recommended way to achieve\n&quot;</span>
    <span class="s0">&quot;the most accurate CDF/SF/PDF/PPF/ISF computations is to use the\n&quot;</span>
    <span class="s0">&quot;`stats.kstwobign` distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;kolmogorov : The Survival Function for the distribution\n&quot;</span>
    <span class="s0">&quot;scipy.stats.kstwobign : Provides the functionality as a continuous distribution\n&quot;</span>
    <span class="s0">&quot;smirnov, smirnovi : Functions for the one-sided distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import kolmogi\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; kolmogi([0, 0.1, 0.25, 0.5, 0.75, 0.9, 1.0])\n&quot;</span>
    <span class="s0">&quot;array([        inf,  1.22384787,  1.01918472,  0.82757356,  0.67644769,\n&quot;</span>
    <span class="s0">&quot;        0.57117327,  0.        ])&quot;)</span>
<span class="s0">ufunc_kolmogi_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_kolmogi_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_kolmogi_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_kolmogi_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_kolmogi_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kolmogi_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kolmogi_ptr[2*0] = &lt;void*&gt;_func_kolmogi</span>
<span class="s0">ufunc_kolmogi_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;kolmogi&quot;)</span>
<span class="s0">ufunc_kolmogi_ptr[2*1] = &lt;void*&gt;_func_kolmogi</span>
<span class="s0">ufunc_kolmogi_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;kolmogi&quot;)</span>
<span class="s0">ufunc_kolmogi_data[0] = &amp;ufunc_kolmogi_ptr[2*0]</span>
<span class="s0">ufunc_kolmogi_data[1] = &amp;ufunc_kolmogi_ptr[2*1]</span>
<span class="s0">kolmogi = np.PyUFunc_FromFuncAndData(ufunc_kolmogi_loops, ufunc_kolmogi_data, ufunc_kolmogi_types, 2, 1, 1, 0, &quot;kolmogi&quot;, ufunc_kolmogi_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_kolmogorov_loops[2]</span>
<span class="s0">cdef void *ufunc_kolmogorov_ptr[4]</span>
<span class="s0">cdef void *ufunc_kolmogorov_data[2]</span>
<span class="s0">cdef char ufunc_kolmogorov_types[4]</span>
<span class="s0">cdef char *ufunc_kolmogorov_doc = (</span>
    <span class="s0">&quot;kolmogorov(y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Complementary cumulative distribution (Survival Function) function of\n&quot;</span>
    <span class="s0">&quot;Kolmogorov distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the complementary cumulative distribution function of\n&quot;</span>
    <span class="s0">&quot;Kolmogorov's limiting distribution (``D_n*\\sqrt(n)`` as n goes to infinity)\n&quot;</span>
    <span class="s0">&quot;of a two-sided test for equality between an empirical and a theoretical\n&quot;</span>
    <span class="s0">&quot;distribution. It is equal to the (limit as n-&gt;infinity of the)\n&quot;</span>
    <span class="s0">&quot;probability that ``sqrt(n) * max absolute deviation &gt; y``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;y : float array_like\n&quot;</span>
    <span class="s0">&quot;  Absolute deviation between the Empirical CDF (ECDF) and the target CDF,\n&quot;</span>
    <span class="s0">&quot;  multiplied by sqrt(n).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The value(s) of kolmogorov(y)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;`kolmogorov` is used by `stats.kstest` in the application of the\n&quot;</span>
    <span class="s0">&quot;Kolmogorov-Smirnov Goodness of Fit test. For historial reasons this\n&quot;</span>
    <span class="s0">&quot;function is exposed in `scpy.special`, but the recommended way to achieve\n&quot;</span>
    <span class="s0">&quot;the most accurate CDF/SF/PDF/PPF/ISF computations is to use the\n&quot;</span>
    <span class="s0">&quot;`stats.kstwobign` distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;kolmogi : The Inverse Survival Function for the distribution\n&quot;</span>
    <span class="s0">&quot;scipy.stats.kstwobign : Provides the functionality as a continuous distribution\n&quot;</span>
    <span class="s0">&quot;smirnov, smirnovi : Functions for the one-sided distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Show the probability of a gap at least as big as 0, 0.5 and 1.0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import kolmogorov\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.stats import kstwobign\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; kolmogorov([0, 0.5, 1.0])\n&quot;</span>
    <span class="s0">&quot;array([ 1.        ,  0.96394524,  0.26999967])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compare a sample of size 1000 drawn from a Laplace(0, 1) distribution against\n&quot;</span>
    <span class="s0">&quot;the target distribution, a Normal(0, 1) distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.stats import norm, laplace\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; rng = np.random.default_rng()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; n = 1000\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; lap01 = laplace(0, 1)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.sort(lap01.rvs(n, random_state=rng))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.mean(x), np.std(x)\n&quot;</span>
    <span class="s0">&quot;(-0.05841730131499543, 1.3968109101997568)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Construct the Empirical CDF and the K-S statistic Dn.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; target = norm(0,1)  # Normal mean 0, stddev 1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdfs = target.cdf(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ecdfs = np.arange(n+1, dtype=float)/n\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gaps = np.column_stack([cdfs - ecdfs[:n], ecdfs[1:] - cdfs])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; Dn = np.max(gaps)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; Kn = np.sqrt(n) * Dn\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; print('Dn=%f, sqrt(n)*Dn=%f' % (Dn, Kn))\n&quot;</span>
    <span class="s0">&quot;Dn=0.043363, sqrt(n)*Dn=1.371265\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; print(chr(10).join(['For a sample of size n drawn from a N(0, 1) distribution:',\n&quot;</span>
    <span class="s0">&quot;...   ' the approximate Kolmogorov probability that sqrt(n)*Dn&gt;=%f is %f' %  (Kn, kolmogorov(Kn)),\n&quot;</span>
    <span class="s0">&quot;...   ' the approximate Kolmogorov probability that sqrt(n)*Dn&lt;=%f is %f' %  (Kn, kstwobign.cdf(Kn))]))\n&quot;</span>
    <span class="s0">&quot;For a sample of size n drawn from a N(0, 1) distribution:\n&quot;</span>
    <span class="s0">&quot; the approximate Kolmogorov probability that sqrt(n)*Dn&gt;=1.371265 is 0.046533\n&quot;</span>
    <span class="s0">&quot; the approximate Kolmogorov probability that sqrt(n)*Dn&lt;=1.371265 is 0.953467\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the Empirical CDF against the target N(0, 1) CDF.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.step(np.concatenate([[-3], x]), ecdfs, where='post', label='Empirical CDF')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x3 = np.linspace(-3, 3, 100)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.plot(x3, target.cdf(x3), label='CDF for N(0, 1)')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.ylim([0, 1]); plt.grid(True); plt.legend();\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; # Add vertical lines marking Dn+ and Dn-\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; iminus, iplus = np.argmax(gaps, axis=0)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.vlines([x[iminus]], ecdfs[iminus], cdfs[iminus], color='r', linestyle='dashed', lw=4)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.vlines([x[iplus]], cdfs[iplus], ecdfs[iplus+1], color='r', linestyle='dashed', lw=4)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_kolmogorov_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_kolmogorov_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_kolmogorov_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_kolmogorov_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_kolmogorov_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kolmogorov_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kolmogorov_ptr[2*0] = &lt;void*&gt;_func_kolmogorov</span>
<span class="s0">ufunc_kolmogorov_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;kolmogorov&quot;)</span>
<span class="s0">ufunc_kolmogorov_ptr[2*1] = &lt;void*&gt;_func_kolmogorov</span>
<span class="s0">ufunc_kolmogorov_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;kolmogorov&quot;)</span>
<span class="s0">ufunc_kolmogorov_data[0] = &amp;ufunc_kolmogorov_ptr[2*0]</span>
<span class="s0">ufunc_kolmogorov_data[1] = &amp;ufunc_kolmogorov_ptr[2*1]</span>
<span class="s0">kolmogorov = np.PyUFunc_FromFuncAndData(ufunc_kolmogorov_loops, ufunc_kolmogorov_data, ufunc_kolmogorov_types, 2, 1, 1, 0, &quot;kolmogorov&quot;, ufunc_kolmogorov_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_kv_loops[4]</span>
<span class="s0">cdef void *ufunc_kv_ptr[8]</span>
<span class="s0">cdef void *ufunc_kv_data[4]</span>
<span class="s0">cdef char ufunc_kv_types[12]</span>
<span class="s0">cdef char *ufunc_kv_doc = (</span>
    <span class="s0">&quot;kv(v, z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Modified Bessel function of the second kind of real order `v`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the modified Bessel function of the second kind for real order\n&quot;</span>
    <span class="s0">&quot;`v` at complex `z`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;These are also sometimes called functions of the third kind, Basset\n&quot;</span>
    <span class="s0">&quot;functions, or Macdonald functions.  They are defined as those solutions\n&quot;</span>
    <span class="s0">&quot;of the modified Bessel equation for which,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    K_v(x) \\sim \\sqrt{\\pi/(2x)} \\exp(-x)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;as :math:`x \\to \\infty` [3]_.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;v : array_like of float\n&quot;</span>
    <span class="s0">&quot;    Order of Bessel functions\n&quot;</span>
    <span class="s0">&quot;z : array_like of complex\n&quot;</span>
    <span class="s0">&quot;    Argument at which to evaluate the Bessel functions\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The results. Note that input must be of complex type to get complex\n&quot;</span>
    <span class="s0">&quot;    output, e.g. ``kv(3, -2+0j)`` instead of ``kv(3, -2)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for AMOS [1]_ routine `zbesk`.  For a discussion of the\n&quot;</span>
    <span class="s0">&quot;algorithm used, see [2]_ and the references therein.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;kve : This function with leading exponential behavior stripped off.\n&quot;</span>
    <span class="s0">&quot;kvp : Derivative of this function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Donald E. Amos, \&quot;AMOS, A Portable Package for Bessel Functions\n&quot;</span>
    <span class="s0">&quot;       of a Complex Argument and Nonnegative Order\&quot;,\n&quot;</span>
    <span class="s0">&quot;       http://netlib.org/amos/\n&quot;</span>
    <span class="s0">&quot;.. [2] Donald E. Amos, \&quot;Algorithm 644: A portable package for Bessel\n&quot;</span>
    <span class="s0">&quot;       functions of a complex argument and nonnegative order\&quot;, ACM\n&quot;</span>
    <span class="s0">&quot;       TOMS Vol. 12 Issue 3, Sept. 1986, p. 265\n&quot;</span>
    <span class="s0">&quot;.. [3] NIST Digital Library of Mathematical Functions,\n&quot;</span>
    <span class="s0">&quot;       Eq. 10.25.E3. https://dlmf.nist.gov/10.25.E3\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Plot the function of several orders for real input:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import kv\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for N in np.linspace(0, 6, 5):\n&quot;</span>
    <span class="s0">&quot;...     plt.plot(x, kv(N, x), label='$K_{{{}}}(x)$'.format(N))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.ylim(0, 10)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.title(r'Modified Bessel function of the second kind $K_\\nu(x)$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate for a single value at multiple orders:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; kv([4, 4.5, 5], 1+2j)\n&quot;</span>
    <span class="s0">&quot;array([ 0.1992+2.3892j,  2.3493+3.6j   ,  7.2827+3.8104j])&quot;)</span>
<span class="s0">ufunc_kv_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_kv_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_fF_F</span>
<span class="s0">ufunc_kv_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_kv_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_dD_D</span>
<span class="s0">ufunc_kv_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_kv_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_kv_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_kv_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_kv_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_kv_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_kv_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kv_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kv_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kv_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kv_types[10] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_kv_types[11] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_kv_ptr[2*0] = &lt;void*&gt;_func_cbesk_wrap_real</span>
<span class="s0">ufunc_kv_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;kv&quot;)</span>
<span class="s0">ufunc_kv_ptr[2*1] = &lt;void*&gt;_func_cbesk_wrap</span>
<span class="s0">ufunc_kv_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;kv&quot;)</span>
<span class="s0">ufunc_kv_ptr[2*2] = &lt;void*&gt;_func_cbesk_wrap_real</span>
<span class="s0">ufunc_kv_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;kv&quot;)</span>
<span class="s0">ufunc_kv_ptr[2*3] = &lt;void*&gt;_func_cbesk_wrap</span>
<span class="s0">ufunc_kv_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;kv&quot;)</span>
<span class="s0">ufunc_kv_data[0] = &amp;ufunc_kv_ptr[2*0]</span>
<span class="s0">ufunc_kv_data[1] = &amp;ufunc_kv_ptr[2*1]</span>
<span class="s0">ufunc_kv_data[2] = &amp;ufunc_kv_ptr[2*2]</span>
<span class="s0">ufunc_kv_data[3] = &amp;ufunc_kv_ptr[2*3]</span>
<span class="s0">kv = np.PyUFunc_FromFuncAndData(ufunc_kv_loops, ufunc_kv_data, ufunc_kv_types, 4, 2, 1, 0, &quot;kv&quot;, ufunc_kv_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_kve_loops[4]</span>
<span class="s0">cdef void *ufunc_kve_ptr[8]</span>
<span class="s0">cdef void *ufunc_kve_data[4]</span>
<span class="s0">cdef char ufunc_kve_types[12]</span>
<span class="s0">cdef char *ufunc_kve_doc = (</span>
    <span class="s0">&quot;kve(v, z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Exponentially scaled modified Bessel function of the second kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the exponentially scaled, modified Bessel function of the\n&quot;</span>
    <span class="s0">&quot;second kind (sometimes called the third kind) for real order `v` at\n&quot;</span>
    <span class="s0">&quot;complex `z`::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    kve(v, z) = kv(v, z) * exp(z)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;v : array_like of float\n&quot;</span>
    <span class="s0">&quot;    Order of Bessel functions\n&quot;</span>
    <span class="s0">&quot;z : array_like of complex\n&quot;</span>
    <span class="s0">&quot;    Argument at which to evaluate the Bessel functions\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The exponentially scaled modified Bessel function of the second kind.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for AMOS [1]_ routine `zbesk`.  For a discussion of the\n&quot;</span>
    <span class="s0">&quot;algorithm used, see [2]_ and the references therein.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;kv : This function without exponential scaling.\n&quot;</span>
    <span class="s0">&quot;k0e : Faster version of this function for order 0.\n&quot;</span>
    <span class="s0">&quot;k1e : Faster version of this function for order 1.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Donald E. Amos, \&quot;AMOS, A Portable Package for Bessel Functions\n&quot;</span>
    <span class="s0">&quot;       of a Complex Argument and Nonnegative Order\&quot;,\n&quot;</span>
    <span class="s0">&quot;       http://netlib.org/amos/\n&quot;</span>
    <span class="s0">&quot;.. [2] Donald E. Amos, \&quot;Algorithm 644: A portable package for Bessel\n&quot;</span>
    <span class="s0">&quot;       functions of a complex argument and nonnegative order\&quot;, ACM\n&quot;</span>
    <span class="s0">&quot;       TOMS Vol. 12 Issue 3, Sept. 1986, p. 265\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;In the following example `kv` returns 0 whereas `kve` still returns\n&quot;</span>
    <span class="s0">&quot;a useful finite number.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import kv, kve\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; kv(3, 1000.), kve(3, 1000.)\n&quot;</span>
    <span class="s0">&quot;(0.0, 0.03980696128440973)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate the function at one point for different orders by\n&quot;</span>
    <span class="s0">&quot;providing a list or NumPy array as argument for the `v` parameter:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; kve([0, 1, 1.5], 1.)\n&quot;</span>
    <span class="s0">&quot;array([1.14446308, 1.63615349, 2.50662827])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate the function at several points for order 0 by providing an\n&quot;</span>
    <span class="s0">&quot;array for `z`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; points = np.array([1., 3., 10.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; kve(0, points)\n&quot;</span>
    <span class="s0">&quot;array([1.14446308, 0.6977616 , 0.39163193])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate the function at several points for different orders by\n&quot;</span>
    <span class="s0">&quot;providing arrays for both `v` for `z`. Both arrays have to be\n&quot;</span>
    <span class="s0">&quot;broadcastable to the correct shape. To calculate the orders 0, 1\n&quot;</span>
    <span class="s0">&quot;and 2 for a 1D array of points:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; kve([[0], [1], [2]], points)\n&quot;</span>
    <span class="s0">&quot;array([[1.14446308, 0.6977616 , 0.39163193],\n&quot;</span>
    <span class="s0">&quot;       [1.63615349, 0.80656348, 0.41076657],\n&quot;</span>
    <span class="s0">&quot;       [4.41677005, 1.23547058, 0.47378525]])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the functions of order 0 to 3 from 0 to 5.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0., 5., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for i in range(4):\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, kve(i, x), label=f'$K_{i!r}(z)\\cdot e^z$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel(r\&quot;$z$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_ylim(0, 4)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlim(0, 5)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_kve_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_kve_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_fF_F</span>
<span class="s0">ufunc_kve_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_kve_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_dD_D</span>
<span class="s0">ufunc_kve_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_kve_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_kve_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_kve_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_kve_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_kve_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_kve_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kve_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kve_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kve_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_kve_types[10] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_kve_types[11] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_kve_ptr[2*0] = &lt;void*&gt;_func_cbesk_wrap_e_real</span>
<span class="s0">ufunc_kve_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;kve&quot;)</span>
<span class="s0">ufunc_kve_ptr[2*1] = &lt;void*&gt;_func_cbesk_wrap_e</span>
<span class="s0">ufunc_kve_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;kve&quot;)</span>
<span class="s0">ufunc_kve_ptr[2*2] = &lt;void*&gt;_func_cbesk_wrap_e_real</span>
<span class="s0">ufunc_kve_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;kve&quot;)</span>
<span class="s0">ufunc_kve_ptr[2*3] = &lt;void*&gt;_func_cbesk_wrap_e</span>
<span class="s0">ufunc_kve_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;kve&quot;)</span>
<span class="s0">ufunc_kve_data[0] = &amp;ufunc_kve_ptr[2*0]</span>
<span class="s0">ufunc_kve_data[1] = &amp;ufunc_kve_ptr[2*1]</span>
<span class="s0">ufunc_kve_data[2] = &amp;ufunc_kve_ptr[2*2]</span>
<span class="s0">ufunc_kve_data[3] = &amp;ufunc_kve_ptr[2*3]</span>
<span class="s0">kve = np.PyUFunc_FromFuncAndData(ufunc_kve_loops, ufunc_kve_data, ufunc_kve_types, 4, 2, 1, 0, &quot;kve&quot;, ufunc_kve_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_log1p_loops[4]</span>
<span class="s0">cdef void *ufunc_log1p_ptr[8]</span>
<span class="s0">cdef void *ufunc_log1p_data[4]</span>
<span class="s0">cdef char ufunc_log1p_types[8]</span>
<span class="s0">cdef char *ufunc_log1p_doc = (</span>
    <span class="s0">&quot;log1p(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculates log(1 + x) for use when `x` is near zero.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real or complex valued input.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of ``log(1 + x)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;expm1, cosm1\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is more accurate than using ``log(1 + x)`` directly for ``x``\n&quot;</span>
    <span class="s0">&quot;near 0. Note that in the below example ``1 + 1e-17 == 1`` to\n&quot;</span>
    <span class="s0">&quot;double precision.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.log1p(1e-17)\n&quot;</span>
    <span class="s0">&quot;1e-17\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.log(1 + 1e-17)\n&quot;</span>
    <span class="s0">&quot;0.0&quot;)</span>
<span class="s0">ufunc_log1p_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_log1p_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_log1p_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_F_F</span>
<span class="s0">ufunc_log1p_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_D_D</span>
<span class="s0">ufunc_log1p_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_log1p_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_log1p_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_log1p_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_log1p_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_log1p_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_log1p_types[6] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_log1p_types[7] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_log1p_ptr[2*0] = &lt;void*&gt;_func_log1p</span>
<span class="s0">ufunc_log1p_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;log1p&quot;)</span>
<span class="s0">ufunc_log1p_ptr[2*1] = &lt;void*&gt;_func_log1p</span>
<span class="s0">ufunc_log1p_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;log1p&quot;)</span>
<span class="s0">ufunc_log1p_ptr[2*2] = &lt;void*&gt;_func_clog1p</span>
<span class="s0">ufunc_log1p_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;log1p&quot;)</span>
<span class="s0">ufunc_log1p_ptr[2*3] = &lt;void*&gt;_func_clog1p</span>
<span class="s0">ufunc_log1p_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;log1p&quot;)</span>
<span class="s0">ufunc_log1p_data[0] = &amp;ufunc_log1p_ptr[2*0]</span>
<span class="s0">ufunc_log1p_data[1] = &amp;ufunc_log1p_ptr[2*1]</span>
<span class="s0">ufunc_log1p_data[2] = &amp;ufunc_log1p_ptr[2*2]</span>
<span class="s0">ufunc_log1p_data[3] = &amp;ufunc_log1p_ptr[2*3]</span>
<span class="s0">log1p = np.PyUFunc_FromFuncAndData(ufunc_log1p_loops, ufunc_log1p_data, ufunc_log1p_types, 4, 1, 1, 0, &quot;log1p&quot;, ufunc_log1p_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_log_expit_loops[3]</span>
<span class="s0">cdef void *ufunc_log_expit_ptr[6]</span>
<span class="s0">cdef void *ufunc_log_expit_data[3]</span>
<span class="s0">cdef char ufunc_log_expit_types[6]</span>
<span class="s0">cdef char *ufunc_log_expit_doc = (</span>
    <span class="s0">&quot;log_expit(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Logarithm of the logistic sigmoid function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The SciPy implementation of the logistic sigmoid function is\n&quot;</span>
    <span class="s0">&quot;`scipy.special.expit`, so this function is called ``log_expit``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function is mathematically equivalent to ``log(expit(x))``, but\n&quot;</span>
    <span class="s0">&quot;is formulated to avoid loss of precision for inputs with large\n&quot;</span>
    <span class="s0">&quot;(positive or negative) magnitude.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    The values to apply ``log_expit`` to element-wise.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;out : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The computed values, an ndarray of the same shape as ``x``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;expit\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;As a ufunc, ``log_expit`` takes a number of optional keyword arguments.\n&quot;</span>
    <span class="s0">&quot;For more information see\n&quot;</span>
    <span class="s0">&quot;`ufuncs &lt;https://docs.scipy.org/doc/numpy/reference/ufuncs.html&gt;`_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 1.8.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import log_expit, expit\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; log_expit([-3.0, 0.25, 2.5, 5.0])\n&quot;</span>
    <span class="s0">&quot;array([-3.04858735, -0.57593942, -0.07888973, -0.00671535])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Large negative values:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; log_expit([-100, -500, -1000])\n&quot;</span>
    <span class="s0">&quot;array([ -100.,  -500., -1000.])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Note that ``expit(-1000)`` returns 0, so the naive implementation\n&quot;</span>
    <span class="s0">&quot;``log(expit(-1000))`` return ``-inf``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Large positive values:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; log_expit([29, 120, 400])\n&quot;</span>
    <span class="s0">&quot;array([-2.54366565e-013, -7.66764807e-053, -1.91516960e-174])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compare that to the naive implementation:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.log(expit([29, 120, 400]))\n&quot;</span>
    <span class="s0">&quot;array([-2.54463117e-13,  0.00000000e+00,  0.00000000e+00])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The first value is accurate to only 3 digits, and the larger inputs\n&quot;</span>
    <span class="s0">&quot;lose all precision and return 0.&quot;)</span>
<span class="s0">ufunc_log_expit_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_f__As_f_f</span>
<span class="s0">ufunc_log_expit_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_log_expit_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_g_g__As_g_g</span>
<span class="s0">ufunc_log_expit_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_log_expit_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_log_expit_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_log_expit_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_log_expit_types[4] = &lt;char&gt;NPY_LONGDOUBLE</span>
<span class="s0">ufunc_log_expit_types[5] = &lt;char&gt;NPY_LONGDOUBLE</span>
<span class="s0">ufunc_log_expit_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_log_expitf</span>
<span class="s0">ufunc_log_expit_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;log_expit&quot;)</span>
<span class="s0">ufunc_log_expit_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_log_expit</span>
<span class="s0">ufunc_log_expit_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;log_expit&quot;)</span>
<span class="s0">ufunc_log_expit_ptr[2*2] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_log_expitl</span>
<span class="s0">ufunc_log_expit_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;log_expit&quot;)</span>
<span class="s0">ufunc_log_expit_data[0] = &amp;ufunc_log_expit_ptr[2*0]</span>
<span class="s0">ufunc_log_expit_data[1] = &amp;ufunc_log_expit_ptr[2*1]</span>
<span class="s0">ufunc_log_expit_data[2] = &amp;ufunc_log_expit_ptr[2*2]</span>
<span class="s0">log_expit = np.PyUFunc_FromFuncAndData(ufunc_log_expit_loops, ufunc_log_expit_data, ufunc_log_expit_types, 3, 1, 1, 0, &quot;log_expit&quot;, ufunc_log_expit_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_log_ndtr_loops[4]</span>
<span class="s0">cdef void *ufunc_log_ndtr_ptr[8]</span>
<span class="s0">cdef void *ufunc_log_ndtr_data[4]</span>
<span class="s0">cdef char ufunc_log_ndtr_types[8]</span>
<span class="s0">cdef char *ufunc_log_ndtr_doc = (</span>
    <span class="s0">&quot;log_ndtr(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Logarithm of Gaussian cumulative distribution function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the log of the area under the standard Gaussian probability\n&quot;</span>
    <span class="s0">&quot;density function, integrated from minus infinity to `x`::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    log(1/sqrt(2*pi) * integral(exp(-t**2 / 2), t=-inf..x))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like, real or complex\n&quot;</span>
    <span class="s0">&quot;    Argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The value of the log of the normal CDF evaluated at `x`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;erf\n&quot;</span>
    <span class="s0">&quot;erfc\n&quot;</span>
    <span class="s0">&quot;scipy.stats.norm\n&quot;</span>
    <span class="s0">&quot;ndtr\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import log_ndtr, ndtr\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The benefit of ``log_ndtr(x)`` over the naive implementation\n&quot;</span>
    <span class="s0">&quot;``np.log(ndtr(x))`` is most evident with moderate to large positive\n&quot;</span>
    <span class="s0">&quot;values of ``x``:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.array([6, 7, 9, 12, 15, 25])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; log_ndtr(x)\n&quot;</span>
    <span class="s0">&quot;array([-9.86587646e-010, -1.27981254e-012, -1.12858841e-019,\n&quot;</span>
    <span class="s0">&quot;       -1.77648211e-033, -3.67096620e-051, -3.05669671e-138])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The results of the naive calculation for the moderate ``x`` values\n&quot;</span>
    <span class="s0">&quot;have only 5 or 6 correct significant digits. For values of ``x``\n&quot;</span>
    <span class="s0">&quot;greater than approximately 8.3, the naive expression returns 0:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.log(ndtr(x))\n&quot;</span>
    <span class="s0">&quot;array([-9.86587701e-10, -1.27986510e-12,  0.00000000e+00,\n&quot;</span>
    <span class="s0">&quot;        0.00000000e+00,  0.00000000e+00,  0.00000000e+00])&quot;)</span>
<span class="s0">ufunc_log_ndtr_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_log_ndtr_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_log_ndtr_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_F_F</span>
<span class="s0">ufunc_log_ndtr_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_D_D</span>
<span class="s0">ufunc_log_ndtr_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_log_ndtr_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_log_ndtr_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_log_ndtr_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_log_ndtr_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_log_ndtr_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_log_ndtr_types[6] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_log_ndtr_types[7] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_log_ndtr_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_log_ndtr</span>
<span class="s0">ufunc_log_ndtr_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;log_ndtr&quot;)</span>
<span class="s0">ufunc_log_ndtr_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_log_ndtr</span>
<span class="s0">ufunc_log_ndtr_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;log_ndtr&quot;)</span>
<span class="s0">ufunc_log_ndtr_ptr[2*2] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_log_ndtr_complex</span>
<span class="s0">ufunc_log_ndtr_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;log_ndtr&quot;)</span>
<span class="s0">ufunc_log_ndtr_ptr[2*3] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_log_ndtr_complex</span>
<span class="s0">ufunc_log_ndtr_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;log_ndtr&quot;)</span>
<span class="s0">ufunc_log_ndtr_data[0] = &amp;ufunc_log_ndtr_ptr[2*0]</span>
<span class="s0">ufunc_log_ndtr_data[1] = &amp;ufunc_log_ndtr_ptr[2*1]</span>
<span class="s0">ufunc_log_ndtr_data[2] = &amp;ufunc_log_ndtr_ptr[2*2]</span>
<span class="s0">ufunc_log_ndtr_data[3] = &amp;ufunc_log_ndtr_ptr[2*3]</span>
<span class="s0">log_ndtr = np.PyUFunc_FromFuncAndData(ufunc_log_ndtr_loops, ufunc_log_ndtr_data, ufunc_log_ndtr_types, 4, 1, 1, 0, &quot;log_ndtr&quot;, ufunc_log_ndtr_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_loggamma_loops[4]</span>
<span class="s0">cdef void *ufunc_loggamma_ptr[8]</span>
<span class="s0">cdef void *ufunc_loggamma_data[4]</span>
<span class="s0">cdef char ufunc_loggamma_types[8]</span>
<span class="s0">cdef char *ufunc_loggamma_doc = (</span>
    <span class="s0">&quot;loggamma(z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Principal branch of the logarithm of the gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined to be :math:`\\log(\\Gamma(x))` for :math:`x &gt; 0` and\n&quot;</span>
    <span class="s0">&quot;extended to the complex plane by analytic continuation. The\n&quot;</span>
    <span class="s0">&quot;function has a single branch cut on the negative real axis.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 0.18.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;z : array_like\n&quot;</span>
    <span class="s0">&quot;    Values in the complex plane at which to compute ``loggamma``\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Output array for computed values of ``loggamma``\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;loggamma : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of ``loggamma`` at z.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;It is not generally true that :math:`\\log\\Gamma(z) =\n&quot;</span>
    <span class="s0">&quot;\\log(\\Gamma(z))`, though the real parts of the functions do\n&quot;</span>
    <span class="s0">&quot;agree. The benefit of not defining `loggamma` as\n&quot;</span>
    <span class="s0">&quot;:math:`\\log(\\Gamma(z))` is that the latter function has a\n&quot;</span>
    <span class="s0">&quot;complicated branch cut structure whereas `loggamma` is analytic\n&quot;</span>
    <span class="s0">&quot;except for on the negative real axis.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The identities\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;  \\exp(\\log\\Gamma(z)) &amp;= \\Gamma(z) \\\\\n&quot;</span>
    <span class="s0">&quot;  \\log\\Gamma(z + 1) &amp;= \\log(z) + \\log\\Gamma(z)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;make `loggamma` useful for working in complex logspace.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;On the real line `loggamma` is related to `gammaln` via\n&quot;</span>
    <span class="s0">&quot;``exp(loggamma(x + 0j)) = gammasgn(x)*exp(gammaln(x))``, up to\n&quot;</span>
    <span class="s0">&quot;rounding error.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The implementation here is based on [hare1997]_.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;gammaln : logarithm of the absolute value of the gamma function\n&quot;</span>
    <span class="s0">&quot;gammasgn : sign of the gamma function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [hare1997] D.E.G. Hare,\n&quot;</span>
    <span class="s0">&quot;  *Computing the Principal Branch of log-Gamma*,\n&quot;</span>
    <span class="s0">&quot;  Journal of Algorithms, Volume 25, Issue 2, November 1997, pages 221-236.&quot;)</span>
<span class="s0">ufunc_loggamma_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_loggamma_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_loggamma_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_F_F</span>
<span class="s0">ufunc_loggamma_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_D_D</span>
<span class="s0">ufunc_loggamma_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_loggamma_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_loggamma_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_loggamma_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_loggamma_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_loggamma_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_loggamma_types[6] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_loggamma_types[7] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_loggamma_ptr[2*0] = &lt;void*&gt;_func_loggamma_real</span>
<span class="s0">ufunc_loggamma_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;loggamma&quot;)</span>
<span class="s0">ufunc_loggamma_ptr[2*1] = &lt;void*&gt;_func_loggamma_real</span>
<span class="s0">ufunc_loggamma_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;loggamma&quot;)</span>
<span class="s0">ufunc_loggamma_ptr[2*2] = &lt;void*&gt;_func_loggamma</span>
<span class="s0">ufunc_loggamma_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;loggamma&quot;)</span>
<span class="s0">ufunc_loggamma_ptr[2*3] = &lt;void*&gt;_func_loggamma</span>
<span class="s0">ufunc_loggamma_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;loggamma&quot;)</span>
<span class="s0">ufunc_loggamma_data[0] = &amp;ufunc_loggamma_ptr[2*0]</span>
<span class="s0">ufunc_loggamma_data[1] = &amp;ufunc_loggamma_ptr[2*1]</span>
<span class="s0">ufunc_loggamma_data[2] = &amp;ufunc_loggamma_ptr[2*2]</span>
<span class="s0">ufunc_loggamma_data[3] = &amp;ufunc_loggamma_ptr[2*3]</span>
<span class="s0">loggamma = np.PyUFunc_FromFuncAndData(ufunc_loggamma_loops, ufunc_loggamma_data, ufunc_loggamma_types, 4, 1, 1, 0, &quot;loggamma&quot;, ufunc_loggamma_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_logit_loops[3]</span>
<span class="s0">cdef void *ufunc_logit_ptr[6]</span>
<span class="s0">cdef void *ufunc_logit_data[3]</span>
<span class="s0">cdef char ufunc_logit_types[6]</span>
<span class="s0">cdef char *ufunc_logit_doc = (</span>
    <span class="s0">&quot;logit(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Logit ufunc for ndarrays.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The logit function is defined as logit(p) = log(p/(1-p)).\n&quot;</span>
    <span class="s0">&quot;Note that logit(0) = -inf, logit(1) = inf, and logit(p)\n&quot;</span>
    <span class="s0">&quot;for p&lt;0 or p&gt;1 yields nan.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : ndarray\n&quot;</span>
    <span class="s0">&quot;    The ndarray to apply logit to element-wise.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    An ndarray of the same shape as x. Its entries\n&quot;</span>
    <span class="s0">&quot;    are logit of the corresponding entry of x.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;expit\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;As a ufunc logit takes a number of optional\n&quot;</span>
    <span class="s0">&quot;keyword arguments. For more information\n&quot;</span>
    <span class="s0">&quot;see `ufuncs &lt;https://docs.scipy.org/doc/numpy/reference/ufuncs.html&gt;`_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 0.10.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import logit, expit\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; logit([0, 0.25, 0.5, 0.75, 1])\n&quot;</span>
    <span class="s0">&quot;array([       -inf, -1.09861229,  0.        ,  1.09861229,         inf])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;`expit` is the inverse of `logit`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; expit(logit([0.1, 0.75, 0.999]))\n&quot;</span>
    <span class="s0">&quot;array([ 0.1  ,  0.75 ,  0.999])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot logit(x) for x in [0, 1]:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0, 1, 501)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = logit(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.plot(x, y)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.grid()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.ylim(-6, 6)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.xlabel('x')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.title('logit(x)')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_logit_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_f__As_f_f</span>
<span class="s0">ufunc_logit_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_logit_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_g_g__As_g_g</span>
<span class="s0">ufunc_logit_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_logit_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_logit_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_logit_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_logit_types[4] = &lt;char&gt;NPY_LONGDOUBLE</span>
<span class="s0">ufunc_logit_types[5] = &lt;char&gt;NPY_LONGDOUBLE</span>
<span class="s0">ufunc_logit_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_logitf</span>
<span class="s0">ufunc_logit_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;logit&quot;)</span>
<span class="s0">ufunc_logit_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_logit</span>
<span class="s0">ufunc_logit_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;logit&quot;)</span>
<span class="s0">ufunc_logit_ptr[2*2] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_logitl</span>
<span class="s0">ufunc_logit_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;logit&quot;)</span>
<span class="s0">ufunc_logit_data[0] = &amp;ufunc_logit_ptr[2*0]</span>
<span class="s0">ufunc_logit_data[1] = &amp;ufunc_logit_ptr[2*1]</span>
<span class="s0">ufunc_logit_data[2] = &amp;ufunc_logit_ptr[2*2]</span>
<span class="s0">logit = np.PyUFunc_FromFuncAndData(ufunc_logit_loops, ufunc_logit_data, ufunc_logit_types, 3, 1, 1, 0, &quot;logit&quot;, ufunc_logit_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_lpmv_loops[2]</span>
<span class="s0">cdef void *ufunc_lpmv_ptr[4]</span>
<span class="s0">cdef void *ufunc_lpmv_data[2]</span>
<span class="s0">cdef char ufunc_lpmv_types[8]</span>
<span class="s0">cdef char *ufunc_lpmv_doc = (</span>
    <span class="s0">&quot;lpmv(m, v, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Associated Legendre function of integer order and real degree.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    P_v^m = (-1)^m (1 - x^2)^{m/2} \\frac{d^m}{dx^m} P_v(x)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    P_v = \\sum_{k = 0}^\\infty \\frac{(-v)_k (v + 1)_k}{(k!)^2}\n&quot;</span>
    <span class="s0">&quot;            \\left(\\frac{1 - x}{2}\\right)^k\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;is the Legendre function of the first kind. Here :math:`(\\cdot)_k`\n&quot;</span>
    <span class="s0">&quot;is the Pochhammer symbol; see `poch`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Order (int or float). If passed a float not equal to an\n&quot;</span>
    <span class="s0">&quot;    integer the function returns NaN.\n&quot;</span>
    <span class="s0">&quot;v : array_like\n&quot;</span>
    <span class="s0">&quot;    Degree (float).\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float). Must have ``|x| &lt;= 1``.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;pmv : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the associated Legendre function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;lpmn : Compute the associated Legendre function for all orders\n&quot;</span>
    <span class="s0">&quot;       ``0, ..., m`` and degrees ``0, ..., n``.\n&quot;</span>
    <span class="s0">&quot;clpmn : Compute the associated Legendre function at complex\n&quot;</span>
    <span class="s0">&quot;        arguments.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Note that this implementation includes the Condon-Shortley phase.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Zhang, Jin, \&quot;Computation of Special Functions\&quot;, John Wiley\n&quot;</span>
    <span class="s0">&quot;       and Sons, Inc, 1996.&quot;)</span>
<span class="s0">ufunc_lpmv_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_lpmv_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_lpmv_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_lpmv_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_lpmv_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_lpmv_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_lpmv_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_lpmv_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_lpmv_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_lpmv_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_lpmv_ptr[2*0] = &lt;void*&gt;_func_pmv_wrap</span>
<span class="s0">ufunc_lpmv_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;lpmv&quot;)</span>
<span class="s0">ufunc_lpmv_ptr[2*1] = &lt;void*&gt;_func_pmv_wrap</span>
<span class="s0">ufunc_lpmv_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;lpmv&quot;)</span>
<span class="s0">ufunc_lpmv_data[0] = &amp;ufunc_lpmv_ptr[2*0]</span>
<span class="s0">ufunc_lpmv_data[1] = &amp;ufunc_lpmv_ptr[2*1]</span>
<span class="s0">lpmv = np.PyUFunc_FromFuncAndData(ufunc_lpmv_loops, ufunc_lpmv_data, ufunc_lpmv_types, 2, 3, 1, 0, &quot;lpmv&quot;, ufunc_lpmv_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_mathieu_a_loops[2]</span>
<span class="s0">cdef void *ufunc_mathieu_a_ptr[4]</span>
<span class="s0">cdef void *ufunc_mathieu_a_data[2]</span>
<span class="s0">cdef char ufunc_mathieu_a_types[6]</span>
<span class="s0">cdef char *ufunc_mathieu_a_doc = (</span>
    <span class="s0">&quot;mathieu_a(m, q, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Characteristic value of even Mathieu functions\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Order of the function\n&quot;</span>
    <span class="s0">&quot;q : array_like\n&quot;</span>
    <span class="s0">&quot;    Parameter of the function\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Characteristic value for the even solution, ``ce_m(z, q)``, of\n&quot;</span>
    <span class="s0">&quot;    Mathieu's equation.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;mathieu_b, mathieu_cem, mathieu_sem&quot;)</span>
<span class="s0">ufunc_mathieu_a_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_mathieu_a_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_mathieu_a_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_a_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_a_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_a_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_a_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_a_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_a_ptr[2*0] = &lt;void*&gt;_func_cem_cva_wrap</span>
<span class="s0">ufunc_mathieu_a_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;mathieu_a&quot;)</span>
<span class="s0">ufunc_mathieu_a_ptr[2*1] = &lt;void*&gt;_func_cem_cva_wrap</span>
<span class="s0">ufunc_mathieu_a_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;mathieu_a&quot;)</span>
<span class="s0">ufunc_mathieu_a_data[0] = &amp;ufunc_mathieu_a_ptr[2*0]</span>
<span class="s0">ufunc_mathieu_a_data[1] = &amp;ufunc_mathieu_a_ptr[2*1]</span>
<span class="s0">mathieu_a = np.PyUFunc_FromFuncAndData(ufunc_mathieu_a_loops, ufunc_mathieu_a_data, ufunc_mathieu_a_types, 2, 2, 1, 0, &quot;mathieu_a&quot;, ufunc_mathieu_a_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_mathieu_b_loops[2]</span>
<span class="s0">cdef void *ufunc_mathieu_b_ptr[4]</span>
<span class="s0">cdef void *ufunc_mathieu_b_data[2]</span>
<span class="s0">cdef char ufunc_mathieu_b_types[6]</span>
<span class="s0">cdef char *ufunc_mathieu_b_doc = (</span>
    <span class="s0">&quot;mathieu_b(m, q, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Characteristic value of odd Mathieu functions\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Order of the function\n&quot;</span>
    <span class="s0">&quot;q : array_like\n&quot;</span>
    <span class="s0">&quot;    Parameter of the function\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Characteristic value for the odd solution, ``se_m(z, q)``, of Mathieu's\n&quot;</span>
    <span class="s0">&quot;    equation.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;mathieu_a, mathieu_cem, mathieu_sem&quot;)</span>
<span class="s0">ufunc_mathieu_b_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_mathieu_b_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_mathieu_b_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_b_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_b_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_b_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_b_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_b_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_b_ptr[2*0] = &lt;void*&gt;_func_sem_cva_wrap</span>
<span class="s0">ufunc_mathieu_b_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;mathieu_b&quot;)</span>
<span class="s0">ufunc_mathieu_b_ptr[2*1] = &lt;void*&gt;_func_sem_cva_wrap</span>
<span class="s0">ufunc_mathieu_b_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;mathieu_b&quot;)</span>
<span class="s0">ufunc_mathieu_b_data[0] = &amp;ufunc_mathieu_b_ptr[2*0]</span>
<span class="s0">ufunc_mathieu_b_data[1] = &amp;ufunc_mathieu_b_ptr[2*1]</span>
<span class="s0">mathieu_b = np.PyUFunc_FromFuncAndData(ufunc_mathieu_b_loops, ufunc_mathieu_b_data, ufunc_mathieu_b_types, 2, 2, 1, 0, &quot;mathieu_b&quot;, ufunc_mathieu_b_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_mathieu_cem_loops[2]</span>
<span class="s0">cdef void *ufunc_mathieu_cem_ptr[4]</span>
<span class="s0">cdef void *ufunc_mathieu_cem_data[2]</span>
<span class="s0">cdef char ufunc_mathieu_cem_types[10]</span>
<span class="s0">cdef char *ufunc_mathieu_cem_doc = (</span>
    <span class="s0">&quot;mathieu_cem(m, q, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Even Mathieu function and its derivative\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the even Mathieu function, ``ce_m(x, q)``, of order `m` and\n&quot;</span>
    <span class="s0">&quot;parameter `q` evaluated at `x` (given in degrees).  Also returns the\n&quot;</span>
    <span class="s0">&quot;derivative with respect to `x` of ce_m(x, q)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Order of the function\n&quot;</span>
    <span class="s0">&quot;q : array_like\n&quot;</span>
    <span class="s0">&quot;    Parameter of the function\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument of the function, *given in degrees, not radians*\n&quot;</span>
    <span class="s0">&quot;out : tuple of ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output arrays for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;y : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the function\n&quot;</span>
    <span class="s0">&quot;yp : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the derivative vs x\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;mathieu_a, mathieu_b, mathieu_sem&quot;)</span>
<span class="s0">ufunc_mathieu_cem_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_ddd_dd_As_fff_ff</span>
<span class="s0">ufunc_mathieu_cem_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_i_ddd_dd_As_ddd_dd</span>
<span class="s0">ufunc_mathieu_cem_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_cem_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_cem_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_cem_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_cem_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_cem_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_cem_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_cem_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_cem_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_cem_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_cem_ptr[2*0] = &lt;void*&gt;_func_cem_wrap</span>
<span class="s0">ufunc_mathieu_cem_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;mathieu_cem&quot;)</span>
<span class="s0">ufunc_mathieu_cem_ptr[2*1] = &lt;void*&gt;_func_cem_wrap</span>
<span class="s0">ufunc_mathieu_cem_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;mathieu_cem&quot;)</span>
<span class="s0">ufunc_mathieu_cem_data[0] = &amp;ufunc_mathieu_cem_ptr[2*0]</span>
<span class="s0">ufunc_mathieu_cem_data[1] = &amp;ufunc_mathieu_cem_ptr[2*1]</span>
<span class="s0">mathieu_cem = np.PyUFunc_FromFuncAndData(ufunc_mathieu_cem_loops, ufunc_mathieu_cem_data, ufunc_mathieu_cem_types, 2, 3, 2, 0, &quot;mathieu_cem&quot;, ufunc_mathieu_cem_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_mathieu_modcem1_loops[2]</span>
<span class="s0">cdef void *ufunc_mathieu_modcem1_ptr[4]</span>
<span class="s0">cdef void *ufunc_mathieu_modcem1_data[2]</span>
<span class="s0">cdef char ufunc_mathieu_modcem1_types[10]</span>
<span class="s0">cdef char *ufunc_mathieu_modcem1_doc = (</span>
    <span class="s0">&quot;mathieu_modcem1(m, q, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Even modified Mathieu function of the first kind and its derivative\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluates the even modified Mathieu function of the first kind,\n&quot;</span>
    <span class="s0">&quot;``Mc1m(x, q)``, and its derivative at `x` for order `m` and parameter\n&quot;</span>
    <span class="s0">&quot;`q`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Order of the function\n&quot;</span>
    <span class="s0">&quot;q : array_like\n&quot;</span>
    <span class="s0">&quot;    Parameter of the function\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument of the function, *given in degrees, not radians*\n&quot;</span>
    <span class="s0">&quot;out : tuple of ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output arrays for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;y : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the function\n&quot;</span>
    <span class="s0">&quot;yp : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the derivative vs x\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;mathieu_modsem1&quot;)</span>
<span class="s0">ufunc_mathieu_modcem1_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_ddd_dd_As_fff_ff</span>
<span class="s0">ufunc_mathieu_modcem1_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_i_ddd_dd_As_ddd_dd</span>
<span class="s0">ufunc_mathieu_modcem1_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_modcem1_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_modcem1_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_modcem1_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_modcem1_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_modcem1_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_modcem1_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_modcem1_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_modcem1_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_modcem1_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_modcem1_ptr[2*0] = &lt;void*&gt;_func_mcm1_wrap</span>
<span class="s0">ufunc_mathieu_modcem1_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;mathieu_modcem1&quot;)</span>
<span class="s0">ufunc_mathieu_modcem1_ptr[2*1] = &lt;void*&gt;_func_mcm1_wrap</span>
<span class="s0">ufunc_mathieu_modcem1_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;mathieu_modcem1&quot;)</span>
<span class="s0">ufunc_mathieu_modcem1_data[0] = &amp;ufunc_mathieu_modcem1_ptr[2*0]</span>
<span class="s0">ufunc_mathieu_modcem1_data[1] = &amp;ufunc_mathieu_modcem1_ptr[2*1]</span>
<span class="s0">mathieu_modcem1 = np.PyUFunc_FromFuncAndData(ufunc_mathieu_modcem1_loops, ufunc_mathieu_modcem1_data, ufunc_mathieu_modcem1_types, 2, 3, 2, 0, &quot;mathieu_modcem1&quot;, ufunc_mathieu_modcem1_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_mathieu_modcem2_loops[2]</span>
<span class="s0">cdef void *ufunc_mathieu_modcem2_ptr[4]</span>
<span class="s0">cdef void *ufunc_mathieu_modcem2_data[2]</span>
<span class="s0">cdef char ufunc_mathieu_modcem2_types[10]</span>
<span class="s0">cdef char *ufunc_mathieu_modcem2_doc = (</span>
    <span class="s0">&quot;mathieu_modcem2(m, q, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Even modified Mathieu function of the second kind and its derivative\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluates the even modified Mathieu function of the second kind,\n&quot;</span>
    <span class="s0">&quot;Mc2m(x, q), and its derivative at `x` (given in degrees) for order `m`\n&quot;</span>
    <span class="s0">&quot;and parameter `q`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Order of the function\n&quot;</span>
    <span class="s0">&quot;q : array_like\n&quot;</span>
    <span class="s0">&quot;    Parameter of the function\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument of the function, *given in degrees, not radians*\n&quot;</span>
    <span class="s0">&quot;out : tuple of ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output arrays for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;y : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the function\n&quot;</span>
    <span class="s0">&quot;yp : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the derivative vs x\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;mathieu_modsem2&quot;)</span>
<span class="s0">ufunc_mathieu_modcem2_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_ddd_dd_As_fff_ff</span>
<span class="s0">ufunc_mathieu_modcem2_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_i_ddd_dd_As_ddd_dd</span>
<span class="s0">ufunc_mathieu_modcem2_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_modcem2_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_modcem2_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_modcem2_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_modcem2_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_modcem2_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_modcem2_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_modcem2_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_modcem2_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_modcem2_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_modcem2_ptr[2*0] = &lt;void*&gt;_func_mcm2_wrap</span>
<span class="s0">ufunc_mathieu_modcem2_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;mathieu_modcem2&quot;)</span>
<span class="s0">ufunc_mathieu_modcem2_ptr[2*1] = &lt;void*&gt;_func_mcm2_wrap</span>
<span class="s0">ufunc_mathieu_modcem2_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;mathieu_modcem2&quot;)</span>
<span class="s0">ufunc_mathieu_modcem2_data[0] = &amp;ufunc_mathieu_modcem2_ptr[2*0]</span>
<span class="s0">ufunc_mathieu_modcem2_data[1] = &amp;ufunc_mathieu_modcem2_ptr[2*1]</span>
<span class="s0">mathieu_modcem2 = np.PyUFunc_FromFuncAndData(ufunc_mathieu_modcem2_loops, ufunc_mathieu_modcem2_data, ufunc_mathieu_modcem2_types, 2, 3, 2, 0, &quot;mathieu_modcem2&quot;, ufunc_mathieu_modcem2_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_mathieu_modsem1_loops[2]</span>
<span class="s0">cdef void *ufunc_mathieu_modsem1_ptr[4]</span>
<span class="s0">cdef void *ufunc_mathieu_modsem1_data[2]</span>
<span class="s0">cdef char ufunc_mathieu_modsem1_types[10]</span>
<span class="s0">cdef char *ufunc_mathieu_modsem1_doc = (</span>
    <span class="s0">&quot;mathieu_modsem1(m, q, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Odd modified Mathieu function of the first kind and its derivative\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluates the odd modified Mathieu function of the first kind,\n&quot;</span>
    <span class="s0">&quot;Ms1m(x, q), and its derivative at `x` (given in degrees) for order `m`\n&quot;</span>
    <span class="s0">&quot;and parameter `q`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Order of the function\n&quot;</span>
    <span class="s0">&quot;q : array_like\n&quot;</span>
    <span class="s0">&quot;    Parameter of the function\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument of the function, *given in degrees, not radians*\n&quot;</span>
    <span class="s0">&quot;out : tuple of ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output arrays for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;y : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the function\n&quot;</span>
    <span class="s0">&quot;yp : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the derivative vs x\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;mathieu_modcem1&quot;)</span>
<span class="s0">ufunc_mathieu_modsem1_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_ddd_dd_As_fff_ff</span>
<span class="s0">ufunc_mathieu_modsem1_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_i_ddd_dd_As_ddd_dd</span>
<span class="s0">ufunc_mathieu_modsem1_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_modsem1_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_modsem1_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_modsem1_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_modsem1_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_modsem1_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_modsem1_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_modsem1_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_modsem1_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_modsem1_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_modsem1_ptr[2*0] = &lt;void*&gt;_func_msm1_wrap</span>
<span class="s0">ufunc_mathieu_modsem1_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;mathieu_modsem1&quot;)</span>
<span class="s0">ufunc_mathieu_modsem1_ptr[2*1] = &lt;void*&gt;_func_msm1_wrap</span>
<span class="s0">ufunc_mathieu_modsem1_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;mathieu_modsem1&quot;)</span>
<span class="s0">ufunc_mathieu_modsem1_data[0] = &amp;ufunc_mathieu_modsem1_ptr[2*0]</span>
<span class="s0">ufunc_mathieu_modsem1_data[1] = &amp;ufunc_mathieu_modsem1_ptr[2*1]</span>
<span class="s0">mathieu_modsem1 = np.PyUFunc_FromFuncAndData(ufunc_mathieu_modsem1_loops, ufunc_mathieu_modsem1_data, ufunc_mathieu_modsem1_types, 2, 3, 2, 0, &quot;mathieu_modsem1&quot;, ufunc_mathieu_modsem1_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_mathieu_modsem2_loops[2]</span>
<span class="s0">cdef void *ufunc_mathieu_modsem2_ptr[4]</span>
<span class="s0">cdef void *ufunc_mathieu_modsem2_data[2]</span>
<span class="s0">cdef char ufunc_mathieu_modsem2_types[10]</span>
<span class="s0">cdef char *ufunc_mathieu_modsem2_doc = (</span>
    <span class="s0">&quot;mathieu_modsem2(m, q, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Odd modified Mathieu function of the second kind and its derivative\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluates the odd modified Mathieu function of the second kind,\n&quot;</span>
    <span class="s0">&quot;Ms2m(x, q), and its derivative at `x` (given in degrees) for order `m`\n&quot;</span>
    <span class="s0">&quot;and parameter q.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Order of the function\n&quot;</span>
    <span class="s0">&quot;q : array_like\n&quot;</span>
    <span class="s0">&quot;    Parameter of the function\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument of the function, *given in degrees, not radians*\n&quot;</span>
    <span class="s0">&quot;out : tuple of ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output arrays for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;y : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the function\n&quot;</span>
    <span class="s0">&quot;yp : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the derivative vs x\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;mathieu_modcem2&quot;)</span>
<span class="s0">ufunc_mathieu_modsem2_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_ddd_dd_As_fff_ff</span>
<span class="s0">ufunc_mathieu_modsem2_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_i_ddd_dd_As_ddd_dd</span>
<span class="s0">ufunc_mathieu_modsem2_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_modsem2_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_modsem2_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_modsem2_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_modsem2_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_modsem2_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_modsem2_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_modsem2_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_modsem2_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_modsem2_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_modsem2_ptr[2*0] = &lt;void*&gt;_func_msm2_wrap</span>
<span class="s0">ufunc_mathieu_modsem2_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;mathieu_modsem2&quot;)</span>
<span class="s0">ufunc_mathieu_modsem2_ptr[2*1] = &lt;void*&gt;_func_msm2_wrap</span>
<span class="s0">ufunc_mathieu_modsem2_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;mathieu_modsem2&quot;)</span>
<span class="s0">ufunc_mathieu_modsem2_data[0] = &amp;ufunc_mathieu_modsem2_ptr[2*0]</span>
<span class="s0">ufunc_mathieu_modsem2_data[1] = &amp;ufunc_mathieu_modsem2_ptr[2*1]</span>
<span class="s0">mathieu_modsem2 = np.PyUFunc_FromFuncAndData(ufunc_mathieu_modsem2_loops, ufunc_mathieu_modsem2_data, ufunc_mathieu_modsem2_types, 2, 3, 2, 0, &quot;mathieu_modsem2&quot;, ufunc_mathieu_modsem2_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_mathieu_sem_loops[2]</span>
<span class="s0">cdef void *ufunc_mathieu_sem_ptr[4]</span>
<span class="s0">cdef void *ufunc_mathieu_sem_data[2]</span>
<span class="s0">cdef char ufunc_mathieu_sem_types[10]</span>
<span class="s0">cdef char *ufunc_mathieu_sem_doc = (</span>
    <span class="s0">&quot;mathieu_sem(m, q, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Odd Mathieu function and its derivative\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the odd Mathieu function, se_m(x, q), of order `m` and\n&quot;</span>
    <span class="s0">&quot;parameter `q` evaluated at `x` (given in degrees).  Also returns the\n&quot;</span>
    <span class="s0">&quot;derivative with respect to `x` of se_m(x, q).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Order of the function\n&quot;</span>
    <span class="s0">&quot;q : array_like\n&quot;</span>
    <span class="s0">&quot;    Parameter of the function\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument of the function, *given in degrees, not radians*.\n&quot;</span>
    <span class="s0">&quot;out : tuple of ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output arrays for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;y : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the function\n&quot;</span>
    <span class="s0">&quot;yp : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the derivative vs x\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;mathieu_a, mathieu_b, mathieu_cem&quot;)</span>
<span class="s0">ufunc_mathieu_sem_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_ddd_dd_As_fff_ff</span>
<span class="s0">ufunc_mathieu_sem_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_i_ddd_dd_As_ddd_dd</span>
<span class="s0">ufunc_mathieu_sem_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_sem_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_sem_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_sem_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_sem_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_mathieu_sem_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_sem_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_sem_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_sem_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_sem_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_mathieu_sem_ptr[2*0] = &lt;void*&gt;_func_sem_wrap</span>
<span class="s0">ufunc_mathieu_sem_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;mathieu_sem&quot;)</span>
<span class="s0">ufunc_mathieu_sem_ptr[2*1] = &lt;void*&gt;_func_sem_wrap</span>
<span class="s0">ufunc_mathieu_sem_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;mathieu_sem&quot;)</span>
<span class="s0">ufunc_mathieu_sem_data[0] = &amp;ufunc_mathieu_sem_ptr[2*0]</span>
<span class="s0">ufunc_mathieu_sem_data[1] = &amp;ufunc_mathieu_sem_ptr[2*1]</span>
<span class="s0">mathieu_sem = np.PyUFunc_FromFuncAndData(ufunc_mathieu_sem_loops, ufunc_mathieu_sem_data, ufunc_mathieu_sem_types, 2, 3, 2, 0, &quot;mathieu_sem&quot;, ufunc_mathieu_sem_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_modfresnelm_loops[2]</span>
<span class="s0">cdef void *ufunc_modfresnelm_ptr[4]</span>
<span class="s0">cdef void *ufunc_modfresnelm_data[2]</span>
<span class="s0">cdef char ufunc_modfresnelm_types[6]</span>
<span class="s0">cdef char *ufunc_modfresnelm_doc = (</span>
    <span class="s0">&quot;modfresnelm(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Modified Fresnel negative integrals\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Function argument\n&quot;</span>
    <span class="s0">&quot;out : tuple of ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output arrays for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;fm : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Integral ``F_-(x)``: ``integral(exp(-1j*t*t), t=x..inf)``\n&quot;</span>
    <span class="s0">&quot;km : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Integral ``K_-(x)``: ``1/sqrt(pi)*exp(1j*(x*x+pi/4))*fp``\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;modfresnelp&quot;)</span>
<span class="s0">ufunc_modfresnelm_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_d_DD_As_f_FF</span>
<span class="s0">ufunc_modfresnelm_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_i_d_DD_As_d_DD</span>
<span class="s0">ufunc_modfresnelm_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_modfresnelm_types[1] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_modfresnelm_types[2] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_modfresnelm_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_modfresnelm_types[4] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_modfresnelm_types[5] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_modfresnelm_ptr[2*0] = &lt;void*&gt;_func_modified_fresnel_minus_wrap</span>
<span class="s0">ufunc_modfresnelm_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;modfresnelm&quot;)</span>
<span class="s0">ufunc_modfresnelm_ptr[2*1] = &lt;void*&gt;_func_modified_fresnel_minus_wrap</span>
<span class="s0">ufunc_modfresnelm_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;modfresnelm&quot;)</span>
<span class="s0">ufunc_modfresnelm_data[0] = &amp;ufunc_modfresnelm_ptr[2*0]</span>
<span class="s0">ufunc_modfresnelm_data[1] = &amp;ufunc_modfresnelm_ptr[2*1]</span>
<span class="s0">modfresnelm = np.PyUFunc_FromFuncAndData(ufunc_modfresnelm_loops, ufunc_modfresnelm_data, ufunc_modfresnelm_types, 2, 1, 2, 0, &quot;modfresnelm&quot;, ufunc_modfresnelm_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_modfresnelp_loops[2]</span>
<span class="s0">cdef void *ufunc_modfresnelp_ptr[4]</span>
<span class="s0">cdef void *ufunc_modfresnelp_data[2]</span>
<span class="s0">cdef char ufunc_modfresnelp_types[6]</span>
<span class="s0">cdef char *ufunc_modfresnelp_doc = (</span>
    <span class="s0">&quot;modfresnelp(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Modified Fresnel positive integrals\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Function argument\n&quot;</span>
    <span class="s0">&quot;out : tuple of ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output arrays for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;fp : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Integral ``F_+(x)``: ``integral(exp(1j*t*t), t=x..inf)``\n&quot;</span>
    <span class="s0">&quot;kp : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Integral ``K_+(x)``: ``1/sqrt(pi)*exp(-1j*(x*x+pi/4))*fp``\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;modfresnelm&quot;)</span>
<span class="s0">ufunc_modfresnelp_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_d_DD_As_f_FF</span>
<span class="s0">ufunc_modfresnelp_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_i_d_DD_As_d_DD</span>
<span class="s0">ufunc_modfresnelp_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_modfresnelp_types[1] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_modfresnelp_types[2] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_modfresnelp_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_modfresnelp_types[4] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_modfresnelp_types[5] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_modfresnelp_ptr[2*0] = &lt;void*&gt;_func_modified_fresnel_plus_wrap</span>
<span class="s0">ufunc_modfresnelp_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;modfresnelp&quot;)</span>
<span class="s0">ufunc_modfresnelp_ptr[2*1] = &lt;void*&gt;_func_modified_fresnel_plus_wrap</span>
<span class="s0">ufunc_modfresnelp_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;modfresnelp&quot;)</span>
<span class="s0">ufunc_modfresnelp_data[0] = &amp;ufunc_modfresnelp_ptr[2*0]</span>
<span class="s0">ufunc_modfresnelp_data[1] = &amp;ufunc_modfresnelp_ptr[2*1]</span>
<span class="s0">modfresnelp = np.PyUFunc_FromFuncAndData(ufunc_modfresnelp_loops, ufunc_modfresnelp_data, ufunc_modfresnelp_types, 2, 1, 2, 0, &quot;modfresnelp&quot;, ufunc_modfresnelp_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_modstruve_loops[2]</span>
<span class="s0">cdef void *ufunc_modstruve_ptr[4]</span>
<span class="s0">cdef void *ufunc_modstruve_data[2]</span>
<span class="s0">cdef char ufunc_modstruve_types[6]</span>
<span class="s0">cdef char *ufunc_modstruve_doc = (</span>
    <span class="s0">&quot;modstruve(v, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Modified Struve function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Return the value of the modified Struve function of order `v` at `x`.  The\n&quot;</span>
    <span class="s0">&quot;modified Struve function is defined as,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    L_v(x) = -\\imath \\exp(-\\pi\\imath v/2) H_v(\\imath x),\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`H_v` is the Struve function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;v : array_like\n&quot;</span>
    <span class="s0">&quot;    Order of the modified Struve function (float).\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument of the Struve function (float; must be positive unless `v` is\n&quot;</span>
    <span class="s0">&quot;    an integer).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;L : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the modified Struve function of order `v` at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Three methods discussed in [1]_ are used to evaluate the function:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;- power series\n&quot;</span>
    <span class="s0">&quot;- expansion in Bessel functions (if :math:`|x| &lt; |v| + 20`)\n&quot;</span>
    <span class="s0">&quot;- asymptotic large-x expansion (if :math:`x \\geq 0.7v + 12`)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Rounding errors are estimated based on the largest terms in the sums, and\n&quot;</span>
    <span class="s0">&quot;the result associated with the smallest error is returned.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;struve\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] NIST Digital Library of Mathematical Functions\n&quot;</span>
    <span class="s0">&quot;       https://dlmf.nist.gov/11\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Calculate the modified Struve function of order 1 at 2.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import modstruve\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; modstruve(1, 2.)\n&quot;</span>
    <span class="s0">&quot;1.102759787367716\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the modified Struve function at 2 for orders 1, 2 and 3 by\n&quot;</span>
    <span class="s0">&quot;providing a list for the order parameter `v`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; modstruve([1, 2, 3], 2.)\n&quot;</span>
    <span class="s0">&quot;array([1.10275979, 0.41026079, 0.11247294])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the modified Struve function of order 1 for several points\n&quot;</span>
    <span class="s0">&quot;by providing an array for `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; points = np.array([2., 5., 8.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; modstruve(1, points)\n&quot;</span>
    <span class="s0">&quot;array([  1.10275979,  23.72821578, 399.24709139])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the modified Struve function for several orders at several\n&quot;</span>
    <span class="s0">&quot;points by providing arrays for `v` and `z`. The arrays have to be\n&quot;</span>
    <span class="s0">&quot;broadcastable to the correct shapes.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; orders = np.array([[1], [2], [3]])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; points.shape, orders.shape\n&quot;</span>
    <span class="s0">&quot;((3,), (3, 1))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; modstruve(orders, points)\n&quot;</span>
    <span class="s0">&quot;array([[1.10275979e+00, 2.37282158e+01, 3.99247091e+02],\n&quot;</span>
    <span class="s0">&quot;       [4.10260789e-01, 1.65535979e+01, 3.25973609e+02],\n&quot;</span>
    <span class="s0">&quot;       [1.12472937e-01, 9.42430454e+00, 2.33544042e+02]])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the modified Struve functions of order 0 to 3 from -5 to 5.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-5., 5., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for i in range(4):\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, modstruve(i, x), label=f'$L_{i!r}$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend(ncol=2)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlim(-5, 5)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(r\&quot;Modified Struve functions $L_{\\nu}$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_modstruve_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_modstruve_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_modstruve_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_modstruve_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_modstruve_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_modstruve_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_modstruve_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_modstruve_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_modstruve_ptr[2*0] = &lt;void*&gt;_func_struve_l</span>
<span class="s0">ufunc_modstruve_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;modstruve&quot;)</span>
<span class="s0">ufunc_modstruve_ptr[2*1] = &lt;void*&gt;_func_struve_l</span>
<span class="s0">ufunc_modstruve_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;modstruve&quot;)</span>
<span class="s0">ufunc_modstruve_data[0] = &amp;ufunc_modstruve_ptr[2*0]</span>
<span class="s0">ufunc_modstruve_data[1] = &amp;ufunc_modstruve_ptr[2*1]</span>
<span class="s0">modstruve = np.PyUFunc_FromFuncAndData(ufunc_modstruve_loops, ufunc_modstruve_data, ufunc_modstruve_types, 2, 2, 1, 0, &quot;modstruve&quot;, ufunc_modstruve_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_nbdtr_loops[3]</span>
<span class="s0">cdef void *ufunc_nbdtr_ptr[6]</span>
<span class="s0">cdef void *ufunc_nbdtr_data[3]</span>
<span class="s0">cdef char ufunc_nbdtr_types[12]</span>
<span class="s0">cdef char *ufunc_nbdtr_doc = (</span>
    <span class="s0">&quot;nbdtr(k, n, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Negative binomial cumulative distribution function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the sum of the terms 0 through `k` of the negative binomial\n&quot;</span>
    <span class="s0">&quot;distribution probability mass function,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    F = \\sum_{j=0}^k {{n + j - 1}\\choose{j}} p^n (1 - p)^j.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;In a sequence of Bernoulli trials with individual success probabilities\n&quot;</span>
    <span class="s0">&quot;`p`, this is the probability that `k` or fewer failures precede the nth\n&quot;</span>
    <span class="s0">&quot;success.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;k : array_like\n&quot;</span>
    <span class="s0">&quot;    The maximum number of allowed failures (nonnegative int).\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    The target number of successes (positive int).\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability of success in a single event (float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;F : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The probability of `k` or fewer failures before `n` successes in a\n&quot;</span>
    <span class="s0">&quot;    sequence of events with individual success probability `p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;nbdtrc : Negative binomial survival function\n&quot;</span>
    <span class="s0">&quot;nbdtrik : Negative binomial quantile function\n&quot;</span>
    <span class="s0">&quot;scipy.stats.nbinom : Negative binomial distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;If floating point values are passed for `k` or `n`, they will be truncated\n&quot;</span>
    <span class="s0">&quot;to integers.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The terms are not summed directly; instead the regularized incomplete beta\n&quot;</span>
    <span class="s0">&quot;function is employed, according to the formula,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    \\mathrm{nbdtr}(k, n, p) = I_{p}(n, k + 1).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `nbdtr`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The negative binomial distribution is also available as\n&quot;</span>
    <span class="s0">&quot;`scipy.stats.nbinom`. Using `nbdtr` directly can improve performance\n&quot;</span>
    <span class="s0">&quot;compared to the ``cdf`` method of `scipy.stats.nbinom` (see last example).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Compute the function for ``k=10`` and ``n=5`` at ``p=0.5``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import nbdtr\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nbdtr(10, 5, 0.5)\n&quot;</span>
    <span class="s0">&quot;0.940765380859375\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the function for ``n=10`` and ``p=0.5`` at several points by\n&quot;</span>
    <span class="s0">&quot;providing a NumPy array or list for `k`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nbdtr([5, 10, 15], 10, 0.5)\n&quot;</span>
    <span class="s0">&quot;array([0.15087891, 0.58809853, 0.88523853])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function for four different parameter sets.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k = np.arange(130)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; n_parameters = [20, 20, 20, 80]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p_parameters = [0.2, 0.5, 0.8, 0.5]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; parameters_list = list(zip(p_parameters, n_parameters,\n&quot;</span>
    <span class="s0">&quot;...                            linestyles))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 8))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for parameter_set in parameters_list:\n&quot;</span>
    <span class="s0">&quot;...     p, n, style = parameter_set\n&quot;</span>
    <span class="s0">&quot;...     nbdtr_vals = nbdtr(k, n, p)\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(k, nbdtr_vals, label=rf\&quot;$n={n},\\, p={p}$\&quot;,\n&quot;</span>
    <span class="s0">&quot;...             ls=style)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel(\&quot;$k$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(\&quot;Negative binomial cumulative distribution function\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The negative binomial distribution is also available as\n&quot;</span>
    <span class="s0">&quot;`scipy.stats.nbinom`. Using `nbdtr` directly can be much faster than\n&quot;</span>
    <span class="s0">&quot;calling the ``cdf`` method of `scipy.stats.nbinom`, especially for small\n&quot;</span>
    <span class="s0">&quot;arrays or individual values. To get the same results one must use the\n&quot;</span>
    <span class="s0">&quot;following parametrization: ``nbinom(n, p).cdf(k)=nbdtr(k, n, p)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.stats import nbinom\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k, n, p = 5, 3, 0.5\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nbdtr_res = nbdtr(k, n, p)  # this will often be faster than below\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; stats_res = nbinom(n, p).cdf(k)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; stats_res, nbdtr_res  # test that results are equal\n&quot;</span>
    <span class="s0">&quot;(0.85546875, 0.85546875)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;`nbdtr` can evaluate different parameter sets by providing arrays with\n&quot;</span>
    <span class="s0">&quot;shapes compatible for broadcasting for `k`, `n` and `p`. Here we compute\n&quot;</span>
    <span class="s0">&quot;the function for three different `k` at four locations `p`, resulting in\n&quot;</span>
    <span class="s0">&quot;a 3x4 array.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k = np.array([[5], [10], [15]])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p = np.array([0.3, 0.5, 0.7, 0.9])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k.shape, p.shape\n&quot;</span>
    <span class="s0">&quot;((3, 1), (4,))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nbdtr(k, 5, p)\n&quot;</span>
    <span class="s0">&quot;array([[0.15026833, 0.62304687, 0.95265101, 0.9998531 ],\n&quot;</span>
    <span class="s0">&quot;       [0.48450894, 0.94076538, 0.99932777, 0.99999999],\n&quot;</span>
    <span class="s0">&quot;       [0.76249222, 0.99409103, 0.99999445, 1.        ]])&quot;)</span>
<span class="s0">ufunc_nbdtr_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_iid__As_lld_d</span>
<span class="s0">ufunc_nbdtr_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_nbdtr_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_nbdtr_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc_nbdtr_types[1] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc_nbdtr_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtr_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtr_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtr_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtr_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtr_types[7] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtr_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtr_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtr_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtr_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtr_ptr[2*0] = &lt;void*&gt;_func_nbdtr</span>
<span class="s0">ufunc_nbdtr_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nbdtr&quot;)</span>
<span class="s0">ufunc_nbdtr_ptr[2*1] = &lt;void*&gt;_func_nbdtr_unsafe</span>
<span class="s0">ufunc_nbdtr_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nbdtr&quot;)</span>
<span class="s0">ufunc_nbdtr_ptr[2*2] = &lt;void*&gt;_func_nbdtr_unsafe</span>
<span class="s0">ufunc_nbdtr_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nbdtr&quot;)</span>
<span class="s0">ufunc_nbdtr_data[0] = &amp;ufunc_nbdtr_ptr[2*0]</span>
<span class="s0">ufunc_nbdtr_data[1] = &amp;ufunc_nbdtr_ptr[2*1]</span>
<span class="s0">ufunc_nbdtr_data[2] = &amp;ufunc_nbdtr_ptr[2*2]</span>
<span class="s0">nbdtr = np.PyUFunc_FromFuncAndData(ufunc_nbdtr_loops, ufunc_nbdtr_data, ufunc_nbdtr_types, 3, 3, 1, 0, &quot;nbdtr&quot;, ufunc_nbdtr_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_nbdtrc_loops[3]</span>
<span class="s0">cdef void *ufunc_nbdtrc_ptr[6]</span>
<span class="s0">cdef void *ufunc_nbdtrc_data[3]</span>
<span class="s0">cdef char ufunc_nbdtrc_types[12]</span>
<span class="s0">cdef char *ufunc_nbdtrc_doc = (</span>
    <span class="s0">&quot;nbdtrc(k, n, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Negative binomial survival function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the sum of the terms `k + 1` to infinity of the negative binomial\n&quot;</span>
    <span class="s0">&quot;distribution probability mass function,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    F = \\sum_{j=k + 1}^\\infty {{n + j - 1}\\choose{j}} p^n (1 - p)^j.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;In a sequence of Bernoulli trials with individual success probabilities\n&quot;</span>
    <span class="s0">&quot;`p`, this is the probability that more than `k` failures precede the nth\n&quot;</span>
    <span class="s0">&quot;success.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;k : array_like\n&quot;</span>
    <span class="s0">&quot;    The maximum number of allowed failures (nonnegative int).\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    The target number of successes (positive int).\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability of success in a single event (float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;F : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The probability of `k + 1` or more failures before `n` successes in a\n&quot;</span>
    <span class="s0">&quot;    sequence of events with individual success probability `p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;nbdtr : Negative binomial cumulative distribution function\n&quot;</span>
    <span class="s0">&quot;nbdtrik : Negative binomial percentile function\n&quot;</span>
    <span class="s0">&quot;scipy.stats.nbinom : Negative binomial distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;If floating point values are passed for `k` or `n`, they will be truncated\n&quot;</span>
    <span class="s0">&quot;to integers.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The terms are not summed directly; instead the regularized incomplete beta\n&quot;</span>
    <span class="s0">&quot;function is employed, according to the formula,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    \\mathrm{nbdtrc}(k, n, p) = I_{1 - p}(k + 1, n).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `nbdtrc`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The negative binomial distribution is also available as\n&quot;</span>
    <span class="s0">&quot;`scipy.stats.nbinom`. Using `nbdtrc` directly can improve performance\n&quot;</span>
    <span class="s0">&quot;compared to the ``sf`` method of `scipy.stats.nbinom` (see last example).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Compute the function for ``k=10`` and ``n=5`` at ``p=0.5``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import nbdtrc\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nbdtrc(10, 5, 0.5)\n&quot;</span>
    <span class="s0">&quot;0.059234619140624986\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the function for ``n=10`` and ``p=0.5`` at several points by\n&quot;</span>
    <span class="s0">&quot;providing a NumPy array or list for `k`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nbdtrc([5, 10, 15], 10, 0.5)\n&quot;</span>
    <span class="s0">&quot;array([0.84912109, 0.41190147, 0.11476147])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function for four different parameter sets.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k = np.arange(130)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; n_parameters = [20, 20, 20, 80]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p_parameters = [0.2, 0.5, 0.8, 0.5]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; parameters_list = list(zip(p_parameters, n_parameters,\n&quot;</span>
    <span class="s0">&quot;...                            linestyles))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 8))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for parameter_set in parameters_list:\n&quot;</span>
    <span class="s0">&quot;...     p, n, style = parameter_set\n&quot;</span>
    <span class="s0">&quot;...     nbdtrc_vals = nbdtrc(k, n, p)\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(k, nbdtrc_vals, label=rf\&quot;$n={n},\\, p={p}$\&quot;,\n&quot;</span>
    <span class="s0">&quot;...             ls=style)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel(\&quot;$k$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(\&quot;Negative binomial distribution survival function\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The negative binomial distribution is also available as\n&quot;</span>
    <span class="s0">&quot;`scipy.stats.nbinom`. Using `nbdtrc` directly can be much faster than\n&quot;</span>
    <span class="s0">&quot;calling the ``sf`` method of `scipy.stats.nbinom`, especially for small\n&quot;</span>
    <span class="s0">&quot;arrays or individual values. To get the same results one must use the\n&quot;</span>
    <span class="s0">&quot;following parametrization: ``nbinom(n, p).sf(k)=nbdtrc(k, n, p)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.stats import nbinom\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k, n, p = 3, 5, 0.5\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nbdtr_res = nbdtrc(k, n, p)  # this will often be faster than below\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; stats_res = nbinom(n, p).sf(k)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; stats_res, nbdtr_res  # test that results are equal\n&quot;</span>
    <span class="s0">&quot;(0.6367187499999999, 0.6367187499999999)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;`nbdtrc` can evaluate different parameter sets by providing arrays with\n&quot;</span>
    <span class="s0">&quot;shapes compatible for broadcasting for `k`, `n` and `p`. Here we compute\n&quot;</span>
    <span class="s0">&quot;the function for three different `k` at four locations `p`, resulting in\n&quot;</span>
    <span class="s0">&quot;a 3x4 array.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k = np.array([[5], [10], [15]])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p = np.array([0.3, 0.5, 0.7, 0.9])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k.shape, p.shape\n&quot;</span>
    <span class="s0">&quot;((3, 1), (4,))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nbdtrc(k, 5, p)\n&quot;</span>
    <span class="s0">&quot;array([[8.49731667e-01, 3.76953125e-01, 4.73489874e-02, 1.46902600e-04],\n&quot;</span>
    <span class="s0">&quot;       [5.15491059e-01, 5.92346191e-02, 6.72234070e-04, 9.29610100e-09],\n&quot;</span>
    <span class="s0">&quot;       [2.37507779e-01, 5.90896606e-03, 5.55025308e-06, 3.26346760e-13]])&quot;)</span>
<span class="s0">ufunc_nbdtrc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_iid__As_lld_d</span>
<span class="s0">ufunc_nbdtrc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_nbdtrc_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_nbdtrc_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc_nbdtrc_types[1] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc_nbdtrc_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtrc_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtrc_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtrc_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtrc_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtrc_types[7] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtrc_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtrc_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtrc_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtrc_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtrc_ptr[2*0] = &lt;void*&gt;_func_nbdtrc</span>
<span class="s0">ufunc_nbdtrc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nbdtrc&quot;)</span>
<span class="s0">ufunc_nbdtrc_ptr[2*1] = &lt;void*&gt;_func_nbdtrc_unsafe</span>
<span class="s0">ufunc_nbdtrc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nbdtrc&quot;)</span>
<span class="s0">ufunc_nbdtrc_ptr[2*2] = &lt;void*&gt;_func_nbdtrc_unsafe</span>
<span class="s0">ufunc_nbdtrc_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nbdtrc&quot;)</span>
<span class="s0">ufunc_nbdtrc_data[0] = &amp;ufunc_nbdtrc_ptr[2*0]</span>
<span class="s0">ufunc_nbdtrc_data[1] = &amp;ufunc_nbdtrc_ptr[2*1]</span>
<span class="s0">ufunc_nbdtrc_data[2] = &amp;ufunc_nbdtrc_ptr[2*2]</span>
<span class="s0">nbdtrc = np.PyUFunc_FromFuncAndData(ufunc_nbdtrc_loops, ufunc_nbdtrc_data, ufunc_nbdtrc_types, 3, 3, 1, 0, &quot;nbdtrc&quot;, ufunc_nbdtrc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_nbdtri_loops[3]</span>
<span class="s0">cdef void *ufunc_nbdtri_ptr[6]</span>
<span class="s0">cdef void *ufunc_nbdtri_data[3]</span>
<span class="s0">cdef char ufunc_nbdtri_types[12]</span>
<span class="s0">cdef char *ufunc_nbdtri_doc = (</span>
    <span class="s0">&quot;nbdtri(k, n, y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the inverse with respect to the parameter `p` of\n&quot;</span>
    <span class="s0">&quot;`y = nbdtr(k, n, p)`, the negative binomial cumulative distribution\n&quot;</span>
    <span class="s0">&quot;function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;k : array_like\n&quot;</span>
    <span class="s0">&quot;    The maximum number of allowed failures (nonnegative int).\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    The target number of successes (positive int).\n&quot;</span>
    <span class="s0">&quot;y : array_like\n&quot;</span>
    <span class="s0">&quot;    The probability of `k` or fewer failures before `n` successes (float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;p : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Probability of success in a single event (float) such that\n&quot;</span>
    <span class="s0">&quot;    `nbdtr(k, n, p) = y`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;nbdtr : Cumulative distribution function of the negative binomial.\n&quot;</span>
    <span class="s0">&quot;nbdtrc : Negative binomial survival function.\n&quot;</span>
    <span class="s0">&quot;scipy.stats.nbinom : negative binomial distribution.\n&quot;</span>
    <span class="s0">&quot;nbdtrik : Inverse with respect to `k` of `nbdtr(k, n, p)`.\n&quot;</span>
    <span class="s0">&quot;nbdtrin : Inverse with respect to `n` of `nbdtr(k, n, p)`.\n&quot;</span>
    <span class="s0">&quot;scipy.stats.nbinom : Negative binomial distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `nbdtri`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The negative binomial distribution is also available as\n&quot;</span>
    <span class="s0">&quot;`scipy.stats.nbinom`. Using `nbdtri` directly can improve performance\n&quot;</span>
    <span class="s0">&quot;compared to the ``ppf`` method of `scipy.stats.nbinom`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;`nbdtri` is the inverse of `nbdtr` with respect to `p`.\n&quot;</span>
    <span class="s0">&quot;Up to floating point errors the following holds:\n&quot;</span>
    <span class="s0">&quot;``nbdtri(k, n, nbdtr(k, n, p))=p``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import nbdtri, nbdtr\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k, n, y = 5, 10, 0.2\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdf_val = nbdtr(k, n, y)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nbdtri(k, n, cdf_val)\n&quot;</span>
    <span class="s0">&quot;0.20000000000000004\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the function for ``k=10`` and ``n=5`` at several points by\n&quot;</span>
    <span class="s0">&quot;providing a NumPy array or list for `y`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = np.array([0.1, 0.4, 0.8])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nbdtri(3, 5, y)\n&quot;</span>
    <span class="s0">&quot;array([0.34462319, 0.51653095, 0.69677416])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function for three different parameter sets.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; n_parameters = [5, 20, 30, 30]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k_parameters = [20, 20, 60, 80]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; parameters_list = list(zip(n_parameters, k_parameters, linestyles))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdf_vals = np.linspace(0, 1, 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 8))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for parameter_set in parameters_list:\n&quot;</span>
    <span class="s0">&quot;...     n, k, style = parameter_set\n&quot;</span>
    <span class="s0">&quot;...     nbdtri_vals = nbdtri(k, n, cdf_vals)\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(cdf_vals, nbdtri_vals, label=rf\&quot;$k={k},\\ n={n}$\&quot;,\n&quot;</span>
    <span class="s0">&quot;...             ls=style)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_ylabel(\&quot;$p$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel(\&quot;$CDF$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; title = \&quot;nbdtri: inverse of negative binomial CDF with respect to $p$\&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(title)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;`nbdtri` can evaluate different parameter sets by providing arrays with\n&quot;</span>
    <span class="s0">&quot;shapes compatible for broadcasting for `k`, `n` and `p`. Here we compute\n&quot;</span>
    <span class="s0">&quot;the function for three different `k` at four locations `p`, resulting in\n&quot;</span>
    <span class="s0">&quot;a 3x4 array.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k = np.array([[5], [10], [15]])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = np.array([0.3, 0.5, 0.7, 0.9])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k.shape, y.shape\n&quot;</span>
    <span class="s0">&quot;((3, 1), (4,))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nbdtri(k, 5, y)\n&quot;</span>
    <span class="s0">&quot;array([[0.37258157, 0.45169416, 0.53249956, 0.64578407],\n&quot;</span>
    <span class="s0">&quot;       [0.24588501, 0.30451981, 0.36778453, 0.46397088],\n&quot;</span>
    <span class="s0">&quot;       [0.18362101, 0.22966758, 0.28054743, 0.36066188]])&quot;)</span>
<span class="s0">ufunc_nbdtri_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_iid__As_lld_d</span>
<span class="s0">ufunc_nbdtri_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_nbdtri_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_nbdtri_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc_nbdtri_types[1] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc_nbdtri_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtri_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtri_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtri_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtri_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtri_types[7] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtri_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtri_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtri_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtri_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtri_ptr[2*0] = &lt;void*&gt;_func_nbdtri</span>
<span class="s0">ufunc_nbdtri_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nbdtri&quot;)</span>
<span class="s0">ufunc_nbdtri_ptr[2*1] = &lt;void*&gt;_func_nbdtri_unsafe</span>
<span class="s0">ufunc_nbdtri_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nbdtri&quot;)</span>
<span class="s0">ufunc_nbdtri_ptr[2*2] = &lt;void*&gt;_func_nbdtri_unsafe</span>
<span class="s0">ufunc_nbdtri_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nbdtri&quot;)</span>
<span class="s0">ufunc_nbdtri_data[0] = &amp;ufunc_nbdtri_ptr[2*0]</span>
<span class="s0">ufunc_nbdtri_data[1] = &amp;ufunc_nbdtri_ptr[2*1]</span>
<span class="s0">ufunc_nbdtri_data[2] = &amp;ufunc_nbdtri_ptr[2*2]</span>
<span class="s0">nbdtri = np.PyUFunc_FromFuncAndData(ufunc_nbdtri_loops, ufunc_nbdtri_data, ufunc_nbdtri_types, 3, 3, 1, 0, &quot;nbdtri&quot;, ufunc_nbdtri_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_nbdtrik_loops[2]</span>
<span class="s0">cdef void *ufunc_nbdtrik_ptr[4]</span>
<span class="s0">cdef void *ufunc_nbdtrik_data[2]</span>
<span class="s0">cdef char ufunc_nbdtrik_types[8]</span>
<span class="s0">cdef char *ufunc_nbdtrik_doc = (</span>
    <span class="s0">&quot;nbdtrik(y, n, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Negative binomial percentile function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the inverse with respect to the parameter `k` of\n&quot;</span>
    <span class="s0">&quot;`y = nbdtr(k, n, p)`, the negative binomial cumulative distribution\n&quot;</span>
    <span class="s0">&quot;function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;y : array_like\n&quot;</span>
    <span class="s0">&quot;    The probability of `k` or fewer failures before `n` successes (float).\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    The target number of successes (positive int).\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability of success in a single event (float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;k : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The maximum number of allowed failures such that `nbdtr(k, n, p) = y`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;nbdtr : Cumulative distribution function of the negative binomial.\n&quot;</span>
    <span class="s0">&quot;nbdtrc : Survival function of the negative binomial.\n&quot;</span>
    <span class="s0">&quot;nbdtri : Inverse with respect to `p` of `nbdtr(k, n, p)`.\n&quot;</span>
    <span class="s0">&quot;nbdtrin : Inverse with respect to `n` of `nbdtr(k, n, p)`.\n&quot;</span>
    <span class="s0">&quot;scipy.stats.nbinom : Negative binomial distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for the CDFLIB [1]_ Fortran routine `cdfnbn`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Formula 26.5.26 of [2]_,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    \\sum_{j=k + 1}^\\infty {{n + j - 1}\\choose{j}} p^n (1 - p)^j = I_{1 - p}(k + 1, n),\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;is used to reduce calculation of the cumulative distribution function to\n&quot;</span>
    <span class="s0">&quot;that of a regularized incomplete beta :math:`I`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computation of `k` involves a search for a value that produces the desired\n&quot;</span>
    <span class="s0">&quot;value of `y`.  The search relies on the monotonicity of `y` with `k`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Barry Brown, James Lovato, and Kathy Russell,\n&quot;</span>
    <span class="s0">&quot;       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n&quot;</span>
    <span class="s0">&quot;       Functions, Inverses, and Other Parameters.\n&quot;</span>
    <span class="s0">&quot;.. [2] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;       Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;       Graphs, and Mathematical Tables. New York: Dover, 1972.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Compute the negative binomial cumulative distribution function for an\n&quot;</span>
    <span class="s0">&quot;exemplary parameter set.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import nbdtr, nbdtrik\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k, n, p = 5, 2, 0.5\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdf_value = nbdtr(k, n, p)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdf_value\n&quot;</span>
    <span class="s0">&quot;0.9375\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Verify that `nbdtrik` recovers the original value for `k`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nbdtrik(cdf_value, n, p)\n&quot;</span>
    <span class="s0">&quot;5.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function for different parameter sets.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p_parameters = [0.2, 0.5, 0.7, 0.5]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; n_parameters = [30, 30, 30, 80]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; parameters_list = list(zip(p_parameters, n_parameters, linestyles))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdf_vals = np.linspace(0, 1, 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 8))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for parameter_set in parameters_list:\n&quot;</span>
    <span class="s0">&quot;...     p, n, style = parameter_set\n&quot;</span>
    <span class="s0">&quot;...     nbdtrik_vals = nbdtrik(cdf_vals, n, p)\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(cdf_vals, nbdtrik_vals, label=rf\&quot;$n={n},\\ p={p}$\&quot;,\n&quot;</span>
    <span class="s0">&quot;...             ls=style)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_ylabel(\&quot;$k$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel(\&quot;$CDF$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(\&quot;Negative binomial percentile function\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The negative binomial distribution is also available as\n&quot;</span>
    <span class="s0">&quot;`scipy.stats.nbinom`. The percentile function  method ``ppf``\n&quot;</span>
    <span class="s0">&quot;returns the result of `nbdtrik` rounded up to integers:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.stats import nbinom\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; q, n, p = 0.6, 5, 0.5\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nbinom.ppf(q, n, p), nbdtrik(q, n, p)\n&quot;</span>
    <span class="s0">&quot;(5.0, 4.800428460273882)&quot;)</span>
<span class="s0">ufunc_nbdtrik_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_nbdtrik_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_nbdtrik_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtrik_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtrik_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtrik_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtrik_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtrik_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtrik_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtrik_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtrik_ptr[2*0] = &lt;void*&gt;_func_cdfnbn2_wrap</span>
<span class="s0">ufunc_nbdtrik_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nbdtrik&quot;)</span>
<span class="s0">ufunc_nbdtrik_ptr[2*1] = &lt;void*&gt;_func_cdfnbn2_wrap</span>
<span class="s0">ufunc_nbdtrik_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nbdtrik&quot;)</span>
<span class="s0">ufunc_nbdtrik_data[0] = &amp;ufunc_nbdtrik_ptr[2*0]</span>
<span class="s0">ufunc_nbdtrik_data[1] = &amp;ufunc_nbdtrik_ptr[2*1]</span>
<span class="s0">nbdtrik = np.PyUFunc_FromFuncAndData(ufunc_nbdtrik_loops, ufunc_nbdtrik_data, ufunc_nbdtrik_types, 2, 3, 1, 0, &quot;nbdtrik&quot;, ufunc_nbdtrik_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_nbdtrin_loops[2]</span>
<span class="s0">cdef void *ufunc_nbdtrin_ptr[4]</span>
<span class="s0">cdef void *ufunc_nbdtrin_data[2]</span>
<span class="s0">cdef char ufunc_nbdtrin_types[8]</span>
<span class="s0">cdef char *ufunc_nbdtrin_doc = (</span>
    <span class="s0">&quot;nbdtrin(k, y, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse of `nbdtr` vs `n`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the inverse with respect to the parameter `n` of\n&quot;</span>
    <span class="s0">&quot;`y = nbdtr(k, n, p)`, the negative binomial cumulative distribution\n&quot;</span>
    <span class="s0">&quot;function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;k : array_like\n&quot;</span>
    <span class="s0">&quot;    The maximum number of allowed failures (nonnegative int).\n&quot;</span>
    <span class="s0">&quot;y : array_like\n&quot;</span>
    <span class="s0">&quot;    The probability of `k` or fewer failures before `n` successes (float).\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability of success in a single event (float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;n : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The number of successes `n` such that `nbdtr(k, n, p) = y`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;nbdtr : Cumulative distribution function of the negative binomial.\n&quot;</span>
    <span class="s0">&quot;nbdtri : Inverse with respect to `p` of `nbdtr(k, n, p)`.\n&quot;</span>
    <span class="s0">&quot;nbdtrik : Inverse with respect to `k` of `nbdtr(k, n, p)`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for the CDFLIB [1]_ Fortran routine `cdfnbn`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Formula 26.5.26 of [2]_,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    \\sum_{j=k + 1}^\\infty {{n + j - 1}\\choose{j}} p^n (1 - p)^j = I_{1 - p}(k + 1, n),\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;is used to reduce calculation of the cumulative distribution function to\n&quot;</span>
    <span class="s0">&quot;that of a regularized incomplete beta :math:`I`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computation of `n` involves a search for a value that produces the desired\n&quot;</span>
    <span class="s0">&quot;value of `y`.  The search relies on the monotonicity of `y` with `n`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Barry Brown, James Lovato, and Kathy Russell,\n&quot;</span>
    <span class="s0">&quot;       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n&quot;</span>
    <span class="s0">&quot;       Functions, Inverses, and Other Parameters.\n&quot;</span>
    <span class="s0">&quot;.. [2] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;       Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;       Graphs, and Mathematical Tables. New York: Dover, 1972.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Compute the negative binomial cumulative distribution function for an\n&quot;</span>
    <span class="s0">&quot;exemplary parameter set.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import nbdtr, nbdtrin\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k, n, p = 5, 2, 0.5\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdf_value = nbdtr(k, n, p)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdf_value\n&quot;</span>
    <span class="s0">&quot;0.9375\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Verify that `nbdtrin` recovers the original value for `n` up to floating\n&quot;</span>
    <span class="s0">&quot;point accuracy.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nbdtrin(k, cdf_value, p)\n&quot;</span>
    <span class="s0">&quot;1.999999999998137&quot;)</span>
<span class="s0">ufunc_nbdtrin_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_nbdtrin_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_nbdtrin_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtrin_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtrin_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtrin_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nbdtrin_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtrin_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtrin_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtrin_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nbdtrin_ptr[2*0] = &lt;void*&gt;_func_cdfnbn3_wrap</span>
<span class="s0">ufunc_nbdtrin_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nbdtrin&quot;)</span>
<span class="s0">ufunc_nbdtrin_ptr[2*1] = &lt;void*&gt;_func_cdfnbn3_wrap</span>
<span class="s0">ufunc_nbdtrin_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nbdtrin&quot;)</span>
<span class="s0">ufunc_nbdtrin_data[0] = &amp;ufunc_nbdtrin_ptr[2*0]</span>
<span class="s0">ufunc_nbdtrin_data[1] = &amp;ufunc_nbdtrin_ptr[2*1]</span>
<span class="s0">nbdtrin = np.PyUFunc_FromFuncAndData(ufunc_nbdtrin_loops, ufunc_nbdtrin_data, ufunc_nbdtrin_types, 2, 3, 1, 0, &quot;nbdtrin&quot;, ufunc_nbdtrin_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_ncfdtr_loops[2]</span>
<span class="s0">cdef void *ufunc_ncfdtr_ptr[4]</span>
<span class="s0">cdef void *ufunc_ncfdtr_data[2]</span>
<span class="s0">cdef char ufunc_ncfdtr_types[10]</span>
<span class="s0">cdef char *ufunc_ncfdtr_doc = (</span>
    <span class="s0">&quot;ncfdtr(dfn, dfd, nc, f, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Cumulative distribution function of the non-central F distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The non-central F describes the distribution of,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    Z = \\frac{X/d_n}{Y/d_d}\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`X` and :math:`Y` are independently distributed, with\n&quot;</span>
    <span class="s0">&quot;:math:`X` distributed non-central :math:`\\chi^2` with noncentrality\n&quot;</span>
    <span class="s0">&quot;parameter `nc` and :math:`d_n` degrees of freedom, and :math:`Y`\n&quot;</span>
    <span class="s0">&quot;distributed :math:`\\chi^2` with :math:`d_d` degrees of freedom.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;dfn : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom of the numerator sum of squares.  Range (0, inf).\n&quot;</span>
    <span class="s0">&quot;dfd : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom of the denominator sum of squares.  Range (0, inf).\n&quot;</span>
    <span class="s0">&quot;nc : array_like\n&quot;</span>
    <span class="s0">&quot;    Noncentrality parameter.  Should be in range (0, 1e4).\n&quot;</span>
    <span class="s0">&quot;f : array_like\n&quot;</span>
    <span class="s0">&quot;    Quantiles, i.e. the upper limit of integration.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;cdf : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The calculated CDF.  If all inputs are scalar, the return will be a\n&quot;</span>
    <span class="s0">&quot;    float.  Otherwise it will be an array.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;ncfdtri : Quantile function; inverse of `ncfdtr` with respect to `f`.\n&quot;</span>
    <span class="s0">&quot;ncfdtridfd : Inverse of `ncfdtr` with respect to `dfd`.\n&quot;</span>
    <span class="s0">&quot;ncfdtridfn : Inverse of `ncfdtr` with respect to `dfn`.\n&quot;</span>
    <span class="s0">&quot;ncfdtrinc : Inverse of `ncfdtr` with respect to `nc`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for the CDFLIB [1]_ Fortran routine `cdffnc`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The cumulative distribution function is computed using Formula 26.6.20 of\n&quot;</span>
    <span class="s0">&quot;[2]_:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    F(d_n, d_d, n_c, f) = \\sum_{j=0}^\\infty e^{-n_c/2} \\frac{(n_c/2)^j}{j!} I_{x}(\\frac{d_n}{2} + j, \\frac{d_d}{2}),\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`I` is the regularized incomplete beta function, and\n&quot;</span>
    <span class="s0">&quot;:math:`x = f d_n/(f d_n + d_d)`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The computation time required for this routine is proportional to the\n&quot;</span>
    <span class="s0">&quot;noncentrality parameter `nc`.  Very large values of this parameter can\n&quot;</span>
    <span class="s0">&quot;consume immense computer resources.  This is why the search range is\n&quot;</span>
    <span class="s0">&quot;bounded by 10,000.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Barry Brown, James Lovato, and Kathy Russell,\n&quot;</span>
    <span class="s0">&quot;       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n&quot;</span>
    <span class="s0">&quot;       Functions, Inverses, and Other Parameters.\n&quot;</span>
    <span class="s0">&quot;.. [2] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;       Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;       Graphs, and Mathematical Tables. New York: Dover, 1972.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy import special\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy import stats\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the CDF of the non-central F distribution, for nc=0.  Compare with the\n&quot;</span>
    <span class="s0">&quot;F-distribution from scipy.stats:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-1, 8, num=500)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfn = 3\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfd = 2\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ncf_stats = stats.f.cdf(x, dfn, dfd)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ncf_special = special.ncfdtr(dfn, dfd, 0, x)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig = plt.figure()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax = fig.add_subplot(111)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, ncf_stats, 'b-', lw=3)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, ncf_special, 'r-')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_ncfdtr_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_ffff_f</span>
<span class="s0">ufunc_ncfdtr_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_dddd_d</span>
<span class="s0">ufunc_ncfdtr_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtr_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtr_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtr_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtr_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtr_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtr_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtr_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtr_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtr_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtr_ptr[2*0] = &lt;void*&gt;_func_cdffnc1_wrap</span>
<span class="s0">ufunc_ncfdtr_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ncfdtr&quot;)</span>
<span class="s0">ufunc_ncfdtr_ptr[2*1] = &lt;void*&gt;_func_cdffnc1_wrap</span>
<span class="s0">ufunc_ncfdtr_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ncfdtr&quot;)</span>
<span class="s0">ufunc_ncfdtr_data[0] = &amp;ufunc_ncfdtr_ptr[2*0]</span>
<span class="s0">ufunc_ncfdtr_data[1] = &amp;ufunc_ncfdtr_ptr[2*1]</span>
<span class="s0">ncfdtr = np.PyUFunc_FromFuncAndData(ufunc_ncfdtr_loops, ufunc_ncfdtr_data, ufunc_ncfdtr_types, 2, 4, 1, 0, &quot;ncfdtr&quot;, ufunc_ncfdtr_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_ncfdtri_loops[2]</span>
<span class="s0">cdef void *ufunc_ncfdtri_ptr[4]</span>
<span class="s0">cdef void *ufunc_ncfdtri_data[2]</span>
<span class="s0">cdef char ufunc_ncfdtri_types[10]</span>
<span class="s0">cdef char *ufunc_ncfdtri_doc = (</span>
    <span class="s0">&quot;ncfdtri(dfn, dfd, nc, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse with respect to `f` of the CDF of the non-central F distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See `ncfdtr` for more details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;dfn : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom of the numerator sum of squares.  Range (0, inf).\n&quot;</span>
    <span class="s0">&quot;dfd : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom of the denominator sum of squares.  Range (0, inf).\n&quot;</span>
    <span class="s0">&quot;nc : array_like\n&quot;</span>
    <span class="s0">&quot;    Noncentrality parameter.  Should be in range (0, 1e4).\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Value of the cumulative distribution function.  Must be in the\n&quot;</span>
    <span class="s0">&quot;    range [0, 1].\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;f : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Quantiles, i.e., the upper limit of integration.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;ncfdtr : CDF of the non-central F distribution.\n&quot;</span>
    <span class="s0">&quot;ncfdtridfd : Inverse of `ncfdtr` with respect to `dfd`.\n&quot;</span>
    <span class="s0">&quot;ncfdtridfn : Inverse of `ncfdtr` with respect to `dfn`.\n&quot;</span>
    <span class="s0">&quot;ncfdtrinc : Inverse of `ncfdtr` with respect to `nc`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import ncfdtr, ncfdtri\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the CDF for several values of `f`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; f = [0.5, 1, 1.5]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p = ncfdtr(2, 3, 1.5, f)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p\n&quot;</span>
    <span class="s0">&quot;array([ 0.20782291,  0.36107392,  0.47345752])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the inverse.  We recover the values of `f`, as expected:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ncfdtri(2, 3, 1.5, p)\n&quot;</span>
    <span class="s0">&quot;array([ 0.5,  1. ,  1.5])&quot;)</span>
<span class="s0">ufunc_ncfdtri_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_ffff_f</span>
<span class="s0">ufunc_ncfdtri_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_dddd_d</span>
<span class="s0">ufunc_ncfdtri_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtri_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtri_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtri_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtri_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtri_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtri_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtri_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtri_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtri_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtri_ptr[2*0] = &lt;void*&gt;_func_cdffnc2_wrap</span>
<span class="s0">ufunc_ncfdtri_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ncfdtri&quot;)</span>
<span class="s0">ufunc_ncfdtri_ptr[2*1] = &lt;void*&gt;_func_cdffnc2_wrap</span>
<span class="s0">ufunc_ncfdtri_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ncfdtri&quot;)</span>
<span class="s0">ufunc_ncfdtri_data[0] = &amp;ufunc_ncfdtri_ptr[2*0]</span>
<span class="s0">ufunc_ncfdtri_data[1] = &amp;ufunc_ncfdtri_ptr[2*1]</span>
<span class="s0">ncfdtri = np.PyUFunc_FromFuncAndData(ufunc_ncfdtri_loops, ufunc_ncfdtri_data, ufunc_ncfdtri_types, 2, 4, 1, 0, &quot;ncfdtri&quot;, ufunc_ncfdtri_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_ncfdtridfd_loops[2]</span>
<span class="s0">cdef void *ufunc_ncfdtridfd_ptr[4]</span>
<span class="s0">cdef void *ufunc_ncfdtridfd_data[2]</span>
<span class="s0">cdef char ufunc_ncfdtridfd_types[10]</span>
<span class="s0">cdef char *ufunc_ncfdtridfd_doc = (</span>
    <span class="s0">&quot;ncfdtridfd(dfn, p, nc, f, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate degrees of freedom (denominator) for the noncentral F-distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This is the inverse with respect to `dfd` of `ncfdtr`.\n&quot;</span>
    <span class="s0">&quot;See `ncfdtr` for more details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;dfn : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom of the numerator sum of squares.  Range (0, inf).\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Value of the cumulative distribution function.  Must be in the\n&quot;</span>
    <span class="s0">&quot;    range [0, 1].\n&quot;</span>
    <span class="s0">&quot;nc : array_like\n&quot;</span>
    <span class="s0">&quot;    Noncentrality parameter.  Should be in range (0, 1e4).\n&quot;</span>
    <span class="s0">&quot;f : array_like\n&quot;</span>
    <span class="s0">&quot;    Quantiles, i.e., the upper limit of integration.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;dfd : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom of the denominator sum of squares.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;ncfdtr : CDF of the non-central F distribution.\n&quot;</span>
    <span class="s0">&quot;ncfdtri : Quantile function; inverse of `ncfdtr` with respect to `f`.\n&quot;</span>
    <span class="s0">&quot;ncfdtridfn : Inverse of `ncfdtr` with respect to `dfn`.\n&quot;</span>
    <span class="s0">&quot;ncfdtrinc : Inverse of `ncfdtr` with respect to `nc`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The value of the cumulative noncentral F distribution is not necessarily\n&quot;</span>
    <span class="s0">&quot;monotone in either degrees of freedom. There thus may be two values that\n&quot;</span>
    <span class="s0">&quot;provide a given CDF value. This routine assumes monotonicity and will\n&quot;</span>
    <span class="s0">&quot;find an arbitrary one of the two values.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import ncfdtr, ncfdtridfd\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the CDF for several values of `dfd`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfd = [1, 2, 3]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p = ncfdtr(2, dfd, 0.25, 15)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p\n&quot;</span>
    <span class="s0">&quot;array([ 0.8097138 ,  0.93020416,  0.96787852])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the inverse.  We recover the values of `dfd`, as expected:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ncfdtridfd(2, p, 0.25, 15)\n&quot;</span>
    <span class="s0">&quot;array([ 1.,  2.,  3.])&quot;)</span>
<span class="s0">ufunc_ncfdtridfd_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_ffff_f</span>
<span class="s0">ufunc_ncfdtridfd_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_dddd_d</span>
<span class="s0">ufunc_ncfdtridfd_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtridfd_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtridfd_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtridfd_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtridfd_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtridfd_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtridfd_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtridfd_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtridfd_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtridfd_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtridfd_ptr[2*0] = &lt;void*&gt;_func_cdffnc4_wrap</span>
<span class="s0">ufunc_ncfdtridfd_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ncfdtridfd&quot;)</span>
<span class="s0">ufunc_ncfdtridfd_ptr[2*1] = &lt;void*&gt;_func_cdffnc4_wrap</span>
<span class="s0">ufunc_ncfdtridfd_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ncfdtridfd&quot;)</span>
<span class="s0">ufunc_ncfdtridfd_data[0] = &amp;ufunc_ncfdtridfd_ptr[2*0]</span>
<span class="s0">ufunc_ncfdtridfd_data[1] = &amp;ufunc_ncfdtridfd_ptr[2*1]</span>
<span class="s0">ncfdtridfd = np.PyUFunc_FromFuncAndData(ufunc_ncfdtridfd_loops, ufunc_ncfdtridfd_data, ufunc_ncfdtridfd_types, 2, 4, 1, 0, &quot;ncfdtridfd&quot;, ufunc_ncfdtridfd_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_ncfdtridfn_loops[2]</span>
<span class="s0">cdef void *ufunc_ncfdtridfn_ptr[4]</span>
<span class="s0">cdef void *ufunc_ncfdtridfn_data[2]</span>
<span class="s0">cdef char ufunc_ncfdtridfn_types[10]</span>
<span class="s0">cdef char *ufunc_ncfdtridfn_doc = (</span>
    <span class="s0">&quot;ncfdtridfn(p, dfd, nc, f, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate degrees of freedom (numerator) for the noncentral F-distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This is the inverse with respect to `dfn` of `ncfdtr`.\n&quot;</span>
    <span class="s0">&quot;See `ncfdtr` for more details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Value of the cumulative distribution function. Must be in the\n&quot;</span>
    <span class="s0">&quot;    range [0, 1].\n&quot;</span>
    <span class="s0">&quot;dfd : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom of the denominator sum of squares. Range (0, inf).\n&quot;</span>
    <span class="s0">&quot;nc : array_like\n&quot;</span>
    <span class="s0">&quot;    Noncentrality parameter.  Should be in range (0, 1e4).\n&quot;</span>
    <span class="s0">&quot;f : float\n&quot;</span>
    <span class="s0">&quot;    Quantiles, i.e., the upper limit of integration.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;dfn : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom of the numerator sum of squares.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;ncfdtr : CDF of the non-central F distribution.\n&quot;</span>
    <span class="s0">&quot;ncfdtri : Quantile function; inverse of `ncfdtr` with respect to `f`.\n&quot;</span>
    <span class="s0">&quot;ncfdtridfd : Inverse of `ncfdtr` with respect to `dfd`.\n&quot;</span>
    <span class="s0">&quot;ncfdtrinc : Inverse of `ncfdtr` with respect to `nc`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The value of the cumulative noncentral F distribution is not necessarily\n&quot;</span>
    <span class="s0">&quot;monotone in either degrees of freedom. There thus may be two values that\n&quot;</span>
    <span class="s0">&quot;provide a given CDF value. This routine assumes monotonicity and will\n&quot;</span>
    <span class="s0">&quot;find an arbitrary one of the two values.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import ncfdtr, ncfdtridfn\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the CDF for several values of `dfn`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfn = [1, 2, 3]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p = ncfdtr(dfn, 2, 0.25, 15)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p\n&quot;</span>
    <span class="s0">&quot;array([ 0.92562363,  0.93020416,  0.93188394])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the inverse. We recover the values of `dfn`, as expected:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ncfdtridfn(p, 2, 0.25, 15)\n&quot;</span>
    <span class="s0">&quot;array([ 1.,  2.,  3.])&quot;)</span>
<span class="s0">ufunc_ncfdtridfn_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_ffff_f</span>
<span class="s0">ufunc_ncfdtridfn_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_dddd_d</span>
<span class="s0">ufunc_ncfdtridfn_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtridfn_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtridfn_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtridfn_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtridfn_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtridfn_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtridfn_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtridfn_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtridfn_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtridfn_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtridfn_ptr[2*0] = &lt;void*&gt;_func_cdffnc3_wrap</span>
<span class="s0">ufunc_ncfdtridfn_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ncfdtridfn&quot;)</span>
<span class="s0">ufunc_ncfdtridfn_ptr[2*1] = &lt;void*&gt;_func_cdffnc3_wrap</span>
<span class="s0">ufunc_ncfdtridfn_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ncfdtridfn&quot;)</span>
<span class="s0">ufunc_ncfdtridfn_data[0] = &amp;ufunc_ncfdtridfn_ptr[2*0]</span>
<span class="s0">ufunc_ncfdtridfn_data[1] = &amp;ufunc_ncfdtridfn_ptr[2*1]</span>
<span class="s0">ncfdtridfn = np.PyUFunc_FromFuncAndData(ufunc_ncfdtridfn_loops, ufunc_ncfdtridfn_data, ufunc_ncfdtridfn_types, 2, 4, 1, 0, &quot;ncfdtridfn&quot;, ufunc_ncfdtridfn_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_ncfdtrinc_loops[2]</span>
<span class="s0">cdef void *ufunc_ncfdtrinc_ptr[4]</span>
<span class="s0">cdef void *ufunc_ncfdtrinc_data[2]</span>
<span class="s0">cdef char ufunc_ncfdtrinc_types[10]</span>
<span class="s0">cdef char *ufunc_ncfdtrinc_doc = (</span>
    <span class="s0">&quot;ncfdtrinc(dfn, dfd, p, f, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate non-centrality parameter for non-central F distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This is the inverse with respect to `nc` of `ncfdtr`.\n&quot;</span>
    <span class="s0">&quot;See `ncfdtr` for more details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;dfn : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom of the numerator sum of squares. Range (0, inf).\n&quot;</span>
    <span class="s0">&quot;dfd : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom of the denominator sum of squares. Range (0, inf).\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Value of the cumulative distribution function. Must be in the\n&quot;</span>
    <span class="s0">&quot;    range [0, 1].\n&quot;</span>
    <span class="s0">&quot;f : array_like\n&quot;</span>
    <span class="s0">&quot;    Quantiles, i.e., the upper limit of integration.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;nc : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Noncentrality parameter.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;ncfdtr : CDF of the non-central F distribution.\n&quot;</span>
    <span class="s0">&quot;ncfdtri : Quantile function; inverse of `ncfdtr` with respect to `f`.\n&quot;</span>
    <span class="s0">&quot;ncfdtridfd : Inverse of `ncfdtr` with respect to `dfd`.\n&quot;</span>
    <span class="s0">&quot;ncfdtridfn : Inverse of `ncfdtr` with respect to `dfn`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import ncfdtr, ncfdtrinc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the CDF for several values of `nc`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nc = [0.5, 1.5, 2.0]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p = ncfdtr(2, 3, nc, 15)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p\n&quot;</span>
    <span class="s0">&quot;array([ 0.96309246,  0.94327955,  0.93304098])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the inverse. We recover the values of `nc`, as expected:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ncfdtrinc(2, 3, p, 15)\n&quot;</span>
    <span class="s0">&quot;array([ 0.5,  1.5,  2. ])&quot;)</span>
<span class="s0">ufunc_ncfdtrinc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_ffff_f</span>
<span class="s0">ufunc_ncfdtrinc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd__As_dddd_d</span>
<span class="s0">ufunc_ncfdtrinc_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtrinc_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtrinc_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtrinc_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtrinc_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ncfdtrinc_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtrinc_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtrinc_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtrinc_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtrinc_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ncfdtrinc_ptr[2*0] = &lt;void*&gt;_func_cdffnc5_wrap</span>
<span class="s0">ufunc_ncfdtrinc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ncfdtrinc&quot;)</span>
<span class="s0">ufunc_ncfdtrinc_ptr[2*1] = &lt;void*&gt;_func_cdffnc5_wrap</span>
<span class="s0">ufunc_ncfdtrinc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ncfdtrinc&quot;)</span>
<span class="s0">ufunc_ncfdtrinc_data[0] = &amp;ufunc_ncfdtrinc_ptr[2*0]</span>
<span class="s0">ufunc_ncfdtrinc_data[1] = &amp;ufunc_ncfdtrinc_ptr[2*1]</span>
<span class="s0">ncfdtrinc = np.PyUFunc_FromFuncAndData(ufunc_ncfdtrinc_loops, ufunc_ncfdtrinc_data, ufunc_ncfdtrinc_types, 2, 4, 1, 0, &quot;ncfdtrinc&quot;, ufunc_ncfdtrinc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_nctdtr_loops[2]</span>
<span class="s0">cdef void *ufunc_nctdtr_ptr[4]</span>
<span class="s0">cdef void *ufunc_nctdtr_data[2]</span>
<span class="s0">cdef char ufunc_nctdtr_types[8]</span>
<span class="s0">cdef char *ufunc_nctdtr_doc = (</span>
    <span class="s0">&quot;nctdtr(df, nc, t, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Cumulative distribution function of the non-central `t` distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;df : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom of the distribution. Should be in range (0, inf).\n&quot;</span>
    <span class="s0">&quot;nc : array_like\n&quot;</span>
    <span class="s0">&quot;    Noncentrality parameter. Should be in range (-1e6, 1e6).\n&quot;</span>
    <span class="s0">&quot;t : array_like\n&quot;</span>
    <span class="s0">&quot;    Quantiles, i.e., the upper limit of integration.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;cdf : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The calculated CDF. If all inputs are scalar, the return will be a\n&quot;</span>
    <span class="s0">&quot;    float. Otherwise, it will be an array.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;nctdtrit : Inverse CDF (iCDF) of the non-central t distribution.\n&quot;</span>
    <span class="s0">&quot;nctdtridf : Calculate degrees of freedom, given CDF and iCDF values.\n&quot;</span>
    <span class="s0">&quot;nctdtrinc : Calculate non-centrality parameter, given CDF iCDF values.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy import special\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy import stats\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the CDF of the non-central t distribution, for nc=0. Compare with the\n&quot;</span>
    <span class="s0">&quot;t-distribution from scipy.stats:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-5, 5, num=500)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; df = 3\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nct_stats = stats.t.cdf(x, df)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; nct_special = special.nctdtr(df, 0, x)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig = plt.figure()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax = fig.add_subplot(111)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, nct_stats, 'b-', lw=3)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, nct_special, 'r-')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_nctdtr_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_nctdtr_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_nctdtr_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nctdtr_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nctdtr_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nctdtr_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nctdtr_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nctdtr_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nctdtr_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nctdtr_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nctdtr_ptr[2*0] = &lt;void*&gt;_func_cdftnc1_wrap</span>
<span class="s0">ufunc_nctdtr_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nctdtr&quot;)</span>
<span class="s0">ufunc_nctdtr_ptr[2*1] = &lt;void*&gt;_func_cdftnc1_wrap</span>
<span class="s0">ufunc_nctdtr_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nctdtr&quot;)</span>
<span class="s0">ufunc_nctdtr_data[0] = &amp;ufunc_nctdtr_ptr[2*0]</span>
<span class="s0">ufunc_nctdtr_data[1] = &amp;ufunc_nctdtr_ptr[2*1]</span>
<span class="s0">nctdtr = np.PyUFunc_FromFuncAndData(ufunc_nctdtr_loops, ufunc_nctdtr_data, ufunc_nctdtr_types, 2, 3, 1, 0, &quot;nctdtr&quot;, ufunc_nctdtr_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_nctdtridf_loops[2]</span>
<span class="s0">cdef void *ufunc_nctdtridf_ptr[4]</span>
<span class="s0">cdef void *ufunc_nctdtridf_data[2]</span>
<span class="s0">cdef char ufunc_nctdtridf_types[8]</span>
<span class="s0">cdef char *ufunc_nctdtridf_doc = (</span>
    <span class="s0">&quot;nctdtridf(p, nc, t, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate degrees of freedom for non-central t distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See `nctdtr` for more details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    CDF values, in range (0, 1].\n&quot;</span>
    <span class="s0">&quot;nc : array_like\n&quot;</span>
    <span class="s0">&quot;    Noncentrality parameter. Should be in range (-1e6, 1e6).\n&quot;</span>
    <span class="s0">&quot;t : array_like\n&quot;</span>
    <span class="s0">&quot;    Quantiles, i.e., the upper limit of integration.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;cdf : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The calculated CDF. If all inputs are scalar, the return will be a\n&quot;</span>
    <span class="s0">&quot;    float. Otherwise, it will be an array.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;nctdtr :  CDF of the non-central `t` distribution.\n&quot;</span>
    <span class="s0">&quot;nctdtrit : Inverse CDF (iCDF) of the non-central t distribution.\n&quot;</span>
    <span class="s0">&quot;nctdtrinc : Calculate non-centrality parameter, given CDF iCDF values.&quot;)</span>
<span class="s0">ufunc_nctdtridf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_nctdtridf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_nctdtridf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nctdtridf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nctdtridf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nctdtridf_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nctdtridf_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nctdtridf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nctdtridf_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nctdtridf_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nctdtridf_ptr[2*0] = &lt;void*&gt;_func_cdftnc3_wrap</span>
<span class="s0">ufunc_nctdtridf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nctdtridf&quot;)</span>
<span class="s0">ufunc_nctdtridf_ptr[2*1] = &lt;void*&gt;_func_cdftnc3_wrap</span>
<span class="s0">ufunc_nctdtridf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nctdtridf&quot;)</span>
<span class="s0">ufunc_nctdtridf_data[0] = &amp;ufunc_nctdtridf_ptr[2*0]</span>
<span class="s0">ufunc_nctdtridf_data[1] = &amp;ufunc_nctdtridf_ptr[2*1]</span>
<span class="s0">nctdtridf = np.PyUFunc_FromFuncAndData(ufunc_nctdtridf_loops, ufunc_nctdtridf_data, ufunc_nctdtridf_types, 2, 3, 1, 0, &quot;nctdtridf&quot;, ufunc_nctdtridf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_nctdtrinc_loops[2]</span>
<span class="s0">cdef void *ufunc_nctdtrinc_ptr[4]</span>
<span class="s0">cdef void *ufunc_nctdtrinc_data[2]</span>
<span class="s0">cdef char ufunc_nctdtrinc_types[8]</span>
<span class="s0">cdef char *ufunc_nctdtrinc_doc = (</span>
    <span class="s0">&quot;nctdtrinc(df, p, t, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate non-centrality parameter for non-central t distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See `nctdtr` for more details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;df : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom of the distribution. Should be in range (0, inf).\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    CDF values, in range (0, 1].\n&quot;</span>
    <span class="s0">&quot;t : array_like\n&quot;</span>
    <span class="s0">&quot;    Quantiles, i.e., the upper limit of integration.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;nc : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Noncentrality parameter\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;nctdtr :  CDF of the non-central `t` distribution.\n&quot;</span>
    <span class="s0">&quot;nctdtrit : Inverse CDF (iCDF) of the non-central t distribution.\n&quot;</span>
    <span class="s0">&quot;nctdtridf : Calculate degrees of freedom, given CDF and iCDF values.&quot;)</span>
<span class="s0">ufunc_nctdtrinc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_nctdtrinc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_nctdtrinc_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nctdtrinc_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nctdtrinc_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nctdtrinc_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nctdtrinc_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nctdtrinc_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nctdtrinc_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nctdtrinc_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nctdtrinc_ptr[2*0] = &lt;void*&gt;_func_cdftnc4_wrap</span>
<span class="s0">ufunc_nctdtrinc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nctdtrinc&quot;)</span>
<span class="s0">ufunc_nctdtrinc_ptr[2*1] = &lt;void*&gt;_func_cdftnc4_wrap</span>
<span class="s0">ufunc_nctdtrinc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nctdtrinc&quot;)</span>
<span class="s0">ufunc_nctdtrinc_data[0] = &amp;ufunc_nctdtrinc_ptr[2*0]</span>
<span class="s0">ufunc_nctdtrinc_data[1] = &amp;ufunc_nctdtrinc_ptr[2*1]</span>
<span class="s0">nctdtrinc = np.PyUFunc_FromFuncAndData(ufunc_nctdtrinc_loops, ufunc_nctdtrinc_data, ufunc_nctdtrinc_types, 2, 3, 1, 0, &quot;nctdtrinc&quot;, ufunc_nctdtrinc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_nctdtrit_loops[2]</span>
<span class="s0">cdef void *ufunc_nctdtrit_ptr[4]</span>
<span class="s0">cdef void *ufunc_nctdtrit_data[2]</span>
<span class="s0">cdef char ufunc_nctdtrit_types[8]</span>
<span class="s0">cdef char *ufunc_nctdtrit_doc = (</span>
    <span class="s0">&quot;nctdtrit(df, nc, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse cumulative distribution function of the non-central t distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See `nctdtr` for more details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;df : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom of the distribution. Should be in range (0, inf).\n&quot;</span>
    <span class="s0">&quot;nc : array_like\n&quot;</span>
    <span class="s0">&quot;    Noncentrality parameter. Should be in range (-1e6, 1e6).\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    CDF values, in range (0, 1].\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;t : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Quantiles\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;nctdtr :  CDF of the non-central `t` distribution.\n&quot;</span>
    <span class="s0">&quot;nctdtridf : Calculate degrees of freedom, given CDF and iCDF values.\n&quot;</span>
    <span class="s0">&quot;nctdtrinc : Calculate non-centrality parameter, given CDF iCDF values.&quot;)</span>
<span class="s0">ufunc_nctdtrit_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_nctdtrit_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_nctdtrit_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nctdtrit_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nctdtrit_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nctdtrit_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nctdtrit_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nctdtrit_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nctdtrit_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nctdtrit_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nctdtrit_ptr[2*0] = &lt;void*&gt;_func_cdftnc2_wrap</span>
<span class="s0">ufunc_nctdtrit_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nctdtrit&quot;)</span>
<span class="s0">ufunc_nctdtrit_ptr[2*1] = &lt;void*&gt;_func_cdftnc2_wrap</span>
<span class="s0">ufunc_nctdtrit_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nctdtrit&quot;)</span>
<span class="s0">ufunc_nctdtrit_data[0] = &amp;ufunc_nctdtrit_ptr[2*0]</span>
<span class="s0">ufunc_nctdtrit_data[1] = &amp;ufunc_nctdtrit_ptr[2*1]</span>
<span class="s0">nctdtrit = np.PyUFunc_FromFuncAndData(ufunc_nctdtrit_loops, ufunc_nctdtrit_data, ufunc_nctdtrit_types, 2, 3, 1, 0, &quot;nctdtrit&quot;, ufunc_nctdtrit_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_ndtr_loops[4]</span>
<span class="s0">cdef void *ufunc_ndtr_ptr[8]</span>
<span class="s0">cdef void *ufunc_ndtr_data[4]</span>
<span class="s0">cdef char ufunc_ndtr_types[8]</span>
<span class="s0">cdef char *ufunc_ndtr_doc = (</span>
    <span class="s0">&quot;ndtr(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Cumulative distribution of the standard normal distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the area under the standard Gaussian probability\n&quot;</span>
    <span class="s0">&quot;density function, integrated from minus infinity to `x`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;   \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^x \\exp(-t^2/2) dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like, real or complex\n&quot;</span>
    <span class="s0">&quot;    Argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The value of the normal CDF evaluated at `x`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;log_ndtr : Logarithm of ndtr\n&quot;</span>
    <span class="s0">&quot;ndtri : Inverse of ndtr, standard normal percentile function\n&quot;</span>
    <span class="s0">&quot;erf : Error function\n&quot;</span>
    <span class="s0">&quot;erfc : 1 - erf\n&quot;</span>
    <span class="s0">&quot;scipy.stats.norm : Normal distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Evaluate `ndtr` at one point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import ndtr\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ndtr(0.5)\n&quot;</span>
    <span class="s0">&quot;0.6914624612740131\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate the function at several points by providing a NumPy array\n&quot;</span>
    <span class="s0">&quot;or list for `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ndtr([0, 0.5, 2])\n&quot;</span>
    <span class="s0">&quot;array([0.5       , 0.69146246, 0.97724987])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-5, 5, 100)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, ndtr(x))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(\&quot;Standard normal cumulative distribution function $\\Phi$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_ndtr_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_ndtr_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_ndtr_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_F_F</span>
<span class="s0">ufunc_ndtr_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_D_D</span>
<span class="s0">ufunc_ndtr_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ndtr_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ndtr_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ndtr_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ndtr_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_ndtr_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_ndtr_types[6] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_ndtr_types[7] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_ndtr_ptr[2*0] = &lt;void*&gt;_func_ndtr</span>
<span class="s0">ufunc_ndtr_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ndtr&quot;)</span>
<span class="s0">ufunc_ndtr_ptr[2*1] = &lt;void*&gt;_func_ndtr</span>
<span class="s0">ufunc_ndtr_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ndtr&quot;)</span>
<span class="s0">ufunc_ndtr_ptr[2*2] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_ndtr</span>
<span class="s0">ufunc_ndtr_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ndtr&quot;)</span>
<span class="s0">ufunc_ndtr_ptr[2*3] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_ndtr</span>
<span class="s0">ufunc_ndtr_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ndtr&quot;)</span>
<span class="s0">ufunc_ndtr_data[0] = &amp;ufunc_ndtr_ptr[2*0]</span>
<span class="s0">ufunc_ndtr_data[1] = &amp;ufunc_ndtr_ptr[2*1]</span>
<span class="s0">ufunc_ndtr_data[2] = &amp;ufunc_ndtr_ptr[2*2]</span>
<span class="s0">ufunc_ndtr_data[3] = &amp;ufunc_ndtr_ptr[2*3]</span>
<span class="s0">ndtr = np.PyUFunc_FromFuncAndData(ufunc_ndtr_loops, ufunc_ndtr_data, ufunc_ndtr_types, 4, 1, 1, 0, &quot;ndtr&quot;, ufunc_ndtr_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_ndtri_loops[2]</span>
<span class="s0">cdef void *ufunc_ndtri_ptr[4]</span>
<span class="s0">cdef void *ufunc_ndtri_data[2]</span>
<span class="s0">cdef char ufunc_ndtri_types[4]</span>
<span class="s0">cdef char *ufunc_ndtri_doc = (</span>
    <span class="s0">&quot;ndtri(y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse of `ndtr` vs x\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the argument x for which the area under the standard normal\n&quot;</span>
    <span class="s0">&quot;probability density function (integrated from minus infinity to `x`)\n&quot;</span>
    <span class="s0">&quot;is equal to y.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;x : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of x such that ``ndtr(x) == p``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;ndtr : Standard normal cumulative probability distribution\n&quot;</span>
    <span class="s0">&quot;ndtri_exp : Inverse of log_ndtr\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;`ndtri` is the percentile function of the standard normal distribution.\n&quot;</span>
    <span class="s0">&quot;This means it returns the inverse of the cumulative density `ndtr`. First,\n&quot;</span>
    <span class="s0">&quot;let us compute a cumulative density value.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import ndtri, ndtr\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdf_val = ndtr(2)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdf_val\n&quot;</span>
    <span class="s0">&quot;0.9772498680518208\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Verify that `ndtri` yields the original value for `x` up to floating point\n&quot;</span>
    <span class="s0">&quot;errors.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ndtri(cdf_val)\n&quot;</span>
    <span class="s0">&quot;2.0000000000000004\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function. For that purpose, we provide a NumPy array as argument.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0.01, 1, 200)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, ndtri(x))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(\&quot;Standard normal percentile function\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_ndtri_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_ndtri_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_ndtri_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ndtri_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ndtri_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ndtri_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ndtri_ptr[2*0] = &lt;void*&gt;_func_ndtri</span>
<span class="s0">ufunc_ndtri_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ndtri&quot;)</span>
<span class="s0">ufunc_ndtri_ptr[2*1] = &lt;void*&gt;_func_ndtri</span>
<span class="s0">ufunc_ndtri_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ndtri&quot;)</span>
<span class="s0">ufunc_ndtri_data[0] = &amp;ufunc_ndtri_ptr[2*0]</span>
<span class="s0">ufunc_ndtri_data[1] = &amp;ufunc_ndtri_ptr[2*1]</span>
<span class="s0">ndtri = np.PyUFunc_FromFuncAndData(ufunc_ndtri_loops, ufunc_ndtri_data, ufunc_ndtri_types, 2, 1, 1, 0, &quot;ndtri&quot;, ufunc_ndtri_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_ndtri_exp_loops[2]</span>
<span class="s0">cdef void *ufunc_ndtri_exp_ptr[4]</span>
<span class="s0">cdef void *ufunc_ndtri_exp_data[2]</span>
<span class="s0">cdef char ufunc_ndtri_exp_types[4]</span>
<span class="s0">cdef char *ufunc_ndtri_exp_doc = (</span>
    <span class="s0">&quot;ndtri_exp(y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse of `log_ndtr` vs x. Allows for greater precision than\n&quot;</span>
    <span class="s0">&quot;`ndtri` composed with `numpy.exp` for very small values of y and for\n&quot;</span>
    <span class="s0">&quot;y close to 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;y : array_like of float\n&quot;</span>
    <span class="s0">&quot;    Function argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Inverse of the log CDF of the standard normal distribution, evaluated\n&quot;</span>
    <span class="s0">&quot;    at y.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;`ndtri_exp` agrees with the naive implementation when the latter does\n&quot;</span>
    <span class="s0">&quot;not suffer from underflow.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.ndtri_exp(-1)\n&quot;</span>
    <span class="s0">&quot;-0.33747496376420244\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.ndtri(np.exp(-1))\n&quot;</span>
    <span class="s0">&quot;-0.33747496376420244\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For extreme values of y, the naive approach fails\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.ndtri(np.exp(-800))\n&quot;</span>
    <span class="s0">&quot;-inf\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.ndtri(np.exp(-1e-20))\n&quot;</span>
    <span class="s0">&quot;inf\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;whereas `ndtri_exp` is still able to compute the result to high precision.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.ndtri_exp(-800)\n&quot;</span>
    <span class="s0">&quot;-39.88469483825668\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.ndtri_exp(-1e-20)\n&quot;</span>
    <span class="s0">&quot;9.262340089798409\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;log_ndtr, ndtri, ndtr&quot;)</span>
<span class="s0">ufunc_ndtri_exp_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_ndtri_exp_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_ndtri_exp_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ndtri_exp_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_ndtri_exp_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ndtri_exp_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_ndtri_exp_ptr[2*0] = &lt;void*&gt;_func_ndtri_exp</span>
<span class="s0">ufunc_ndtri_exp_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ndtri_exp&quot;)</span>
<span class="s0">ufunc_ndtri_exp_ptr[2*1] = &lt;void*&gt;_func_ndtri_exp</span>
<span class="s0">ufunc_ndtri_exp_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;ndtri_exp&quot;)</span>
<span class="s0">ufunc_ndtri_exp_data[0] = &amp;ufunc_ndtri_exp_ptr[2*0]</span>
<span class="s0">ufunc_ndtri_exp_data[1] = &amp;ufunc_ndtri_exp_ptr[2*1]</span>
<span class="s0">ndtri_exp = np.PyUFunc_FromFuncAndData(ufunc_ndtri_exp_loops, ufunc_ndtri_exp_data, ufunc_ndtri_exp_types, 2, 1, 1, 0, &quot;ndtri_exp&quot;, ufunc_ndtri_exp_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_nrdtrimn_loops[2]</span>
<span class="s0">cdef void *ufunc_nrdtrimn_ptr[4]</span>
<span class="s0">cdef void *ufunc_nrdtrimn_data[2]</span>
<span class="s0">cdef char ufunc_nrdtrimn_types[8]</span>
<span class="s0">cdef char *ufunc_nrdtrimn_doc = (</span>
    <span class="s0">&quot;nrdtrimn(p, x, std, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate mean of normal distribution given other params.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    CDF values, in range (0, 1].\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Quantiles, i.e. the upper limit of integration.\n&quot;</span>
    <span class="s0">&quot;std : array_like\n&quot;</span>
    <span class="s0">&quot;    Standard deviation.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;mn : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The mean of the normal distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;nrdtrimn, ndtr&quot;)</span>
<span class="s0">ufunc_nrdtrimn_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_nrdtrimn_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_nrdtrimn_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nrdtrimn_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nrdtrimn_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nrdtrimn_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nrdtrimn_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nrdtrimn_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nrdtrimn_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nrdtrimn_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nrdtrimn_ptr[2*0] = &lt;void*&gt;_func_cdfnor3_wrap</span>
<span class="s0">ufunc_nrdtrimn_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nrdtrimn&quot;)</span>
<span class="s0">ufunc_nrdtrimn_ptr[2*1] = &lt;void*&gt;_func_cdfnor3_wrap</span>
<span class="s0">ufunc_nrdtrimn_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nrdtrimn&quot;)</span>
<span class="s0">ufunc_nrdtrimn_data[0] = &amp;ufunc_nrdtrimn_ptr[2*0]</span>
<span class="s0">ufunc_nrdtrimn_data[1] = &amp;ufunc_nrdtrimn_ptr[2*1]</span>
<span class="s0">nrdtrimn = np.PyUFunc_FromFuncAndData(ufunc_nrdtrimn_loops, ufunc_nrdtrimn_data, ufunc_nrdtrimn_types, 2, 3, 1, 0, &quot;nrdtrimn&quot;, ufunc_nrdtrimn_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_nrdtrisd_loops[2]</span>
<span class="s0">cdef void *ufunc_nrdtrisd_ptr[4]</span>
<span class="s0">cdef void *ufunc_nrdtrisd_data[2]</span>
<span class="s0">cdef char ufunc_nrdtrisd_types[8]</span>
<span class="s0">cdef char *ufunc_nrdtrisd_doc = (</span>
    <span class="s0">&quot;nrdtrisd(p, x, mn, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate standard deviation of normal distribution given other params.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    CDF values, in range (0, 1].\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Quantiles, i.e. the upper limit of integration.\n&quot;</span>
    <span class="s0">&quot;mn : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The mean of the normal distribution.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;std : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Standard deviation.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;ndtr&quot;)</span>
<span class="s0">ufunc_nrdtrisd_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_nrdtrisd_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_nrdtrisd_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nrdtrisd_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nrdtrisd_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nrdtrisd_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_nrdtrisd_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nrdtrisd_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nrdtrisd_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nrdtrisd_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_nrdtrisd_ptr[2*0] = &lt;void*&gt;_func_cdfnor4_wrap</span>
<span class="s0">ufunc_nrdtrisd_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nrdtrisd&quot;)</span>
<span class="s0">ufunc_nrdtrisd_ptr[2*1] = &lt;void*&gt;_func_cdfnor4_wrap</span>
<span class="s0">ufunc_nrdtrisd_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;nrdtrisd&quot;)</span>
<span class="s0">ufunc_nrdtrisd_data[0] = &amp;ufunc_nrdtrisd_ptr[2*0]</span>
<span class="s0">ufunc_nrdtrisd_data[1] = &amp;ufunc_nrdtrisd_ptr[2*1]</span>
<span class="s0">nrdtrisd = np.PyUFunc_FromFuncAndData(ufunc_nrdtrisd_loops, ufunc_nrdtrisd_data, ufunc_nrdtrisd_types, 2, 3, 1, 0, &quot;nrdtrisd&quot;, ufunc_nrdtrisd_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_obl_ang1_loops[2]</span>
<span class="s0">cdef void *ufunc_obl_ang1_ptr[4]</span>
<span class="s0">cdef void *ufunc_obl_ang1_data[2]</span>
<span class="s0">cdef char ufunc_obl_ang1_types[12]</span>
<span class="s0">cdef char *ufunc_obl_ang1_doc = (</span>
    <span class="s0">&quot;obl_ang1(m, n, c, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Oblate spheroidal angular function of the first kind and its derivative\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes the oblate spheroidal angular function of the first kind\n&quot;</span>
    <span class="s0">&quot;and its derivative (with respect to `x`) for mode parameters m&gt;=0\n&quot;</span>
    <span class="s0">&quot;and n&gt;=m, spheroidal parameter `c` and ``|x| &lt; 1.0``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Mode parameter m (nonnegative)\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Mode parameter n (&gt;= m)\n&quot;</span>
    <span class="s0">&quot;c : array_like\n&quot;</span>
    <span class="s0">&quot;    Spheroidal parameter\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Parameter x (``|x| &lt; 1.0``)\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;s : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the function\n&quot;</span>
    <span class="s0">&quot;sp : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the derivative vs x\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;obl_ang1_cv&quot;)</span>
<span class="s0">ufunc_obl_ang1_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd_d_As_ffff_ff</span>
<span class="s0">ufunc_obl_ang1_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd_d_As_dddd_dd</span>
<span class="s0">ufunc_obl_ang1_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_ang1_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_ang1_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_ang1_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_ang1_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_ang1_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_ang1_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_ang1_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_ang1_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_ang1_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_ang1_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_ang1_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_ang1_ptr[2*0] = &lt;void*&gt;_func_oblate_aswfa_nocv_wrap</span>
<span class="s0">ufunc_obl_ang1_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;obl_ang1&quot;)</span>
<span class="s0">ufunc_obl_ang1_ptr[2*1] = &lt;void*&gt;_func_oblate_aswfa_nocv_wrap</span>
<span class="s0">ufunc_obl_ang1_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;obl_ang1&quot;)</span>
<span class="s0">ufunc_obl_ang1_data[0] = &amp;ufunc_obl_ang1_ptr[2*0]</span>
<span class="s0">ufunc_obl_ang1_data[1] = &amp;ufunc_obl_ang1_ptr[2*1]</span>
<span class="s0">obl_ang1 = np.PyUFunc_FromFuncAndData(ufunc_obl_ang1_loops, ufunc_obl_ang1_data, ufunc_obl_ang1_types, 2, 4, 2, 0, &quot;obl_ang1&quot;, ufunc_obl_ang1_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_obl_ang1_cv_loops[2]</span>
<span class="s0">cdef void *ufunc_obl_ang1_cv_ptr[4]</span>
<span class="s0">cdef void *ufunc_obl_ang1_cv_data[2]</span>
<span class="s0">cdef char ufunc_obl_ang1_cv_types[14]</span>
<span class="s0">cdef char *ufunc_obl_ang1_cv_doc = (</span>
    <span class="s0">&quot;obl_ang1_cv(m, n, c, cv, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Oblate spheroidal angular function obl_ang1 for precomputed characteristic value\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes the oblate spheroidal angular function of the first kind\n&quot;</span>
    <span class="s0">&quot;and its derivative (with respect to `x`) for mode parameters m&gt;=0\n&quot;</span>
    <span class="s0">&quot;and n&gt;=m, spheroidal parameter `c` and ``|x| &lt; 1.0``. Requires\n&quot;</span>
    <span class="s0">&quot;pre-computed characteristic value.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Mode parameter m (nonnegative)\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Mode parameter n (&gt;= m)\n&quot;</span>
    <span class="s0">&quot;c : array_like\n&quot;</span>
    <span class="s0">&quot;    Spheroidal parameter\n&quot;</span>
    <span class="s0">&quot;cv : array_like\n&quot;</span>
    <span class="s0">&quot;    Characteristic value\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Parameter x (``|x| &lt; 1.0``)\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;s : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the function\n&quot;</span>
    <span class="s0">&quot;sp : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the derivative vs x\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;obl_ang1&quot;)</span>
<span class="s0">ufunc_obl_ang1_cv_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_ddddd_dd_As_fffff_ff</span>
<span class="s0">ufunc_obl_ang1_cv_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_i_ddddd_dd_As_ddddd_dd</span>
<span class="s0">ufunc_obl_ang1_cv_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_ang1_cv_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_ang1_cv_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_ang1_cv_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_ang1_cv_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_ang1_cv_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_ang1_cv_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_ang1_cv_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_ang1_cv_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_ang1_cv_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_ang1_cv_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_ang1_cv_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_ang1_cv_types[12] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_ang1_cv_types[13] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_ang1_cv_ptr[2*0] = &lt;void*&gt;_func_oblate_aswfa_wrap</span>
<span class="s0">ufunc_obl_ang1_cv_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;obl_ang1_cv&quot;)</span>
<span class="s0">ufunc_obl_ang1_cv_ptr[2*1] = &lt;void*&gt;_func_oblate_aswfa_wrap</span>
<span class="s0">ufunc_obl_ang1_cv_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;obl_ang1_cv&quot;)</span>
<span class="s0">ufunc_obl_ang1_cv_data[0] = &amp;ufunc_obl_ang1_cv_ptr[2*0]</span>
<span class="s0">ufunc_obl_ang1_cv_data[1] = &amp;ufunc_obl_ang1_cv_ptr[2*1]</span>
<span class="s0">obl_ang1_cv = np.PyUFunc_FromFuncAndData(ufunc_obl_ang1_cv_loops, ufunc_obl_ang1_cv_data, ufunc_obl_ang1_cv_types, 2, 5, 2, 0, &quot;obl_ang1_cv&quot;, ufunc_obl_ang1_cv_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_obl_cv_loops[2]</span>
<span class="s0">cdef void *ufunc_obl_cv_ptr[4]</span>
<span class="s0">cdef void *ufunc_obl_cv_data[2]</span>
<span class="s0">cdef char ufunc_obl_cv_types[8]</span>
<span class="s0">cdef char *ufunc_obl_cv_doc = (</span>
    <span class="s0">&quot;obl_cv(m, n, c, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Characteristic value of oblate spheroidal function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes the characteristic value of oblate spheroidal wave\n&quot;</span>
    <span class="s0">&quot;functions of order `m`, `n` (n&gt;=m) and spheroidal parameter `c`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Mode parameter m (nonnegative)\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Mode parameter n (&gt;= m)\n&quot;</span>
    <span class="s0">&quot;c : array_like\n&quot;</span>
    <span class="s0">&quot;    Spheroidal parameter\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;cv : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Characteristic value&quot;)</span>
<span class="s0">ufunc_obl_cv_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_obl_cv_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_obl_cv_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_cv_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_cv_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_cv_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_cv_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_cv_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_cv_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_cv_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_cv_ptr[2*0] = &lt;void*&gt;_func_oblate_segv_wrap</span>
<span class="s0">ufunc_obl_cv_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;obl_cv&quot;)</span>
<span class="s0">ufunc_obl_cv_ptr[2*1] = &lt;void*&gt;_func_oblate_segv_wrap</span>
<span class="s0">ufunc_obl_cv_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;obl_cv&quot;)</span>
<span class="s0">ufunc_obl_cv_data[0] = &amp;ufunc_obl_cv_ptr[2*0]</span>
<span class="s0">ufunc_obl_cv_data[1] = &amp;ufunc_obl_cv_ptr[2*1]</span>
<span class="s0">obl_cv = np.PyUFunc_FromFuncAndData(ufunc_obl_cv_loops, ufunc_obl_cv_data, ufunc_obl_cv_types, 2, 3, 1, 0, &quot;obl_cv&quot;, ufunc_obl_cv_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_obl_rad1_loops[2]</span>
<span class="s0">cdef void *ufunc_obl_rad1_ptr[4]</span>
<span class="s0">cdef void *ufunc_obl_rad1_data[2]</span>
<span class="s0">cdef char ufunc_obl_rad1_types[12]</span>
<span class="s0">cdef char *ufunc_obl_rad1_doc = (</span>
    <span class="s0">&quot;obl_rad1(m, n, c, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Oblate spheroidal radial function of the first kind and its derivative\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes the oblate spheroidal radial function of the first kind\n&quot;</span>
    <span class="s0">&quot;and its derivative (with respect to `x`) for mode parameters m&gt;=0\n&quot;</span>
    <span class="s0">&quot;and n&gt;=m, spheroidal parameter `c` and ``|x| &lt; 1.0``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Mode parameter m (nonnegative)\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Mode parameter n (&gt;= m)\n&quot;</span>
    <span class="s0">&quot;c : array_like\n&quot;</span>
    <span class="s0">&quot;    Spheroidal parameter\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Parameter x (``|x| &lt; 1.0``)\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;s : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the function\n&quot;</span>
    <span class="s0">&quot;sp : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the derivative vs x\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;obl_rad1_cv&quot;)</span>
<span class="s0">ufunc_obl_rad1_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd_d_As_ffff_ff</span>
<span class="s0">ufunc_obl_rad1_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd_d_As_dddd_dd</span>
<span class="s0">ufunc_obl_rad1_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_rad1_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_rad1_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_rad1_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_rad1_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_rad1_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_rad1_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_rad1_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_rad1_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_rad1_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_rad1_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_rad1_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_rad1_ptr[2*0] = &lt;void*&gt;_func_oblate_radial1_nocv_wrap</span>
<span class="s0">ufunc_obl_rad1_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;obl_rad1&quot;)</span>
<span class="s0">ufunc_obl_rad1_ptr[2*1] = &lt;void*&gt;_func_oblate_radial1_nocv_wrap</span>
<span class="s0">ufunc_obl_rad1_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;obl_rad1&quot;)</span>
<span class="s0">ufunc_obl_rad1_data[0] = &amp;ufunc_obl_rad1_ptr[2*0]</span>
<span class="s0">ufunc_obl_rad1_data[1] = &amp;ufunc_obl_rad1_ptr[2*1]</span>
<span class="s0">obl_rad1 = np.PyUFunc_FromFuncAndData(ufunc_obl_rad1_loops, ufunc_obl_rad1_data, ufunc_obl_rad1_types, 2, 4, 2, 0, &quot;obl_rad1&quot;, ufunc_obl_rad1_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_obl_rad1_cv_loops[2]</span>
<span class="s0">cdef void *ufunc_obl_rad1_cv_ptr[4]</span>
<span class="s0">cdef void *ufunc_obl_rad1_cv_data[2]</span>
<span class="s0">cdef char ufunc_obl_rad1_cv_types[14]</span>
<span class="s0">cdef char *ufunc_obl_rad1_cv_doc = (</span>
    <span class="s0">&quot;obl_rad1_cv(m, n, c, cv, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Oblate spheroidal radial function obl_rad1 for precomputed characteristic value\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes the oblate spheroidal radial function of the first kind\n&quot;</span>
    <span class="s0">&quot;and its derivative (with respect to `x`) for mode parameters m&gt;=0\n&quot;</span>
    <span class="s0">&quot;and n&gt;=m, spheroidal parameter `c` and ``|x| &lt; 1.0``. Requires\n&quot;</span>
    <span class="s0">&quot;pre-computed characteristic value.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Mode parameter m (nonnegative)\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Mode parameter n (&gt;= m)\n&quot;</span>
    <span class="s0">&quot;c : array_like\n&quot;</span>
    <span class="s0">&quot;    Spheroidal parameter\n&quot;</span>
    <span class="s0">&quot;cv : array_like\n&quot;</span>
    <span class="s0">&quot;    Characteristic value\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Parameter x (``|x| &lt; 1.0``)\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;s : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the function\n&quot;</span>
    <span class="s0">&quot;sp : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the derivative vs x\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;obl_rad1&quot;)</span>
<span class="s0">ufunc_obl_rad1_cv_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_ddddd_dd_As_fffff_ff</span>
<span class="s0">ufunc_obl_rad1_cv_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_i_ddddd_dd_As_ddddd_dd</span>
<span class="s0">ufunc_obl_rad1_cv_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_rad1_cv_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_rad1_cv_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_rad1_cv_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_rad1_cv_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_rad1_cv_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_rad1_cv_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_rad1_cv_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_rad1_cv_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_rad1_cv_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_rad1_cv_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_rad1_cv_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_rad1_cv_types[12] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_rad1_cv_types[13] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_rad1_cv_ptr[2*0] = &lt;void*&gt;_func_oblate_radial1_wrap</span>
<span class="s0">ufunc_obl_rad1_cv_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;obl_rad1_cv&quot;)</span>
<span class="s0">ufunc_obl_rad1_cv_ptr[2*1] = &lt;void*&gt;_func_oblate_radial1_wrap</span>
<span class="s0">ufunc_obl_rad1_cv_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;obl_rad1_cv&quot;)</span>
<span class="s0">ufunc_obl_rad1_cv_data[0] = &amp;ufunc_obl_rad1_cv_ptr[2*0]</span>
<span class="s0">ufunc_obl_rad1_cv_data[1] = &amp;ufunc_obl_rad1_cv_ptr[2*1]</span>
<span class="s0">obl_rad1_cv = np.PyUFunc_FromFuncAndData(ufunc_obl_rad1_cv_loops, ufunc_obl_rad1_cv_data, ufunc_obl_rad1_cv_types, 2, 5, 2, 0, &quot;obl_rad1_cv&quot;, ufunc_obl_rad1_cv_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_obl_rad2_loops[2]</span>
<span class="s0">cdef void *ufunc_obl_rad2_ptr[4]</span>
<span class="s0">cdef void *ufunc_obl_rad2_data[2]</span>
<span class="s0">cdef char ufunc_obl_rad2_types[12]</span>
<span class="s0">cdef char *ufunc_obl_rad2_doc = (</span>
    <span class="s0">&quot;obl_rad2(m, n, c, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Oblate spheroidal radial function of the second kind and its derivative.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes the oblate spheroidal radial function of the second kind\n&quot;</span>
    <span class="s0">&quot;and its derivative (with respect to `x`) for mode parameters m&gt;=0\n&quot;</span>
    <span class="s0">&quot;and n&gt;=m, spheroidal parameter `c` and ``|x| &lt; 1.0``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Mode parameter m (nonnegative)\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Mode parameter n (&gt;= m)\n&quot;</span>
    <span class="s0">&quot;c : array_like\n&quot;</span>
    <span class="s0">&quot;    Spheroidal parameter\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Parameter x (``|x| &lt; 1.0``)\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;s : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the function\n&quot;</span>
    <span class="s0">&quot;sp : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the derivative vs x\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;obl_rad2_cv&quot;)</span>
<span class="s0">ufunc_obl_rad2_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd_d_As_ffff_ff</span>
<span class="s0">ufunc_obl_rad2_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd_d_As_dddd_dd</span>
<span class="s0">ufunc_obl_rad2_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_rad2_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_rad2_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_rad2_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_rad2_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_rad2_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_rad2_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_rad2_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_rad2_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_rad2_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_rad2_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_rad2_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_rad2_ptr[2*0] = &lt;void*&gt;_func_oblate_radial2_nocv_wrap</span>
<span class="s0">ufunc_obl_rad2_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;obl_rad2&quot;)</span>
<span class="s0">ufunc_obl_rad2_ptr[2*1] = &lt;void*&gt;_func_oblate_radial2_nocv_wrap</span>
<span class="s0">ufunc_obl_rad2_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;obl_rad2&quot;)</span>
<span class="s0">ufunc_obl_rad2_data[0] = &amp;ufunc_obl_rad2_ptr[2*0]</span>
<span class="s0">ufunc_obl_rad2_data[1] = &amp;ufunc_obl_rad2_ptr[2*1]</span>
<span class="s0">obl_rad2 = np.PyUFunc_FromFuncAndData(ufunc_obl_rad2_loops, ufunc_obl_rad2_data, ufunc_obl_rad2_types, 2, 4, 2, 0, &quot;obl_rad2&quot;, ufunc_obl_rad2_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_obl_rad2_cv_loops[2]</span>
<span class="s0">cdef void *ufunc_obl_rad2_cv_ptr[4]</span>
<span class="s0">cdef void *ufunc_obl_rad2_cv_data[2]</span>
<span class="s0">cdef char ufunc_obl_rad2_cv_types[14]</span>
<span class="s0">cdef char *ufunc_obl_rad2_cv_doc = (</span>
    <span class="s0">&quot;obl_rad2_cv(m, n, c, cv, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Oblate spheroidal radial function obl_rad2 for precomputed characteristic value\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes the oblate spheroidal radial function of the second kind\n&quot;</span>
    <span class="s0">&quot;and its derivative (with respect to `x`) for mode parameters m&gt;=0\n&quot;</span>
    <span class="s0">&quot;and n&gt;=m, spheroidal parameter `c` and ``|x| &lt; 1.0``. Requires\n&quot;</span>
    <span class="s0">&quot;pre-computed characteristic value.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Mode parameter m (nonnegative)\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Mode parameter n (&gt;= m)\n&quot;</span>
    <span class="s0">&quot;c : array_like\n&quot;</span>
    <span class="s0">&quot;    Spheroidal parameter\n&quot;</span>
    <span class="s0">&quot;cv : array_like\n&quot;</span>
    <span class="s0">&quot;    Characteristic value\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Parameter x (``|x| &lt; 1.0``)\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;s : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the function\n&quot;</span>
    <span class="s0">&quot;sp : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the derivative vs x\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;obl_rad2&quot;)</span>
<span class="s0">ufunc_obl_rad2_cv_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_ddddd_dd_As_fffff_ff</span>
<span class="s0">ufunc_obl_rad2_cv_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_i_ddddd_dd_As_ddddd_dd</span>
<span class="s0">ufunc_obl_rad2_cv_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_rad2_cv_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_rad2_cv_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_rad2_cv_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_rad2_cv_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_rad2_cv_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_rad2_cv_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_obl_rad2_cv_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_rad2_cv_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_rad2_cv_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_rad2_cv_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_rad2_cv_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_rad2_cv_types[12] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_rad2_cv_types[13] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_obl_rad2_cv_ptr[2*0] = &lt;void*&gt;_func_oblate_radial2_wrap</span>
<span class="s0">ufunc_obl_rad2_cv_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;obl_rad2_cv&quot;)</span>
<span class="s0">ufunc_obl_rad2_cv_ptr[2*1] = &lt;void*&gt;_func_oblate_radial2_wrap</span>
<span class="s0">ufunc_obl_rad2_cv_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;obl_rad2_cv&quot;)</span>
<span class="s0">ufunc_obl_rad2_cv_data[0] = &amp;ufunc_obl_rad2_cv_ptr[2*0]</span>
<span class="s0">ufunc_obl_rad2_cv_data[1] = &amp;ufunc_obl_rad2_cv_ptr[2*1]</span>
<span class="s0">obl_rad2_cv = np.PyUFunc_FromFuncAndData(ufunc_obl_rad2_cv_loops, ufunc_obl_rad2_cv_data, ufunc_obl_rad2_cv_types, 2, 5, 2, 0, &quot;obl_rad2_cv&quot;, ufunc_obl_rad2_cv_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_owens_t_loops[2]</span>
<span class="s0">cdef void *ufunc_owens_t_ptr[4]</span>
<span class="s0">cdef void *ufunc_owens_t_data[2]</span>
<span class="s0">cdef char ufunc_owens_t_types[6]</span>
<span class="s0">cdef char *ufunc_owens_t_doc = (</span>
    <span class="s0">&quot;owens_t(h, a, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Owen's T Function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function T(h, a) gives the probability of the event\n&quot;</span>
    <span class="s0">&quot;(X &gt; h and 0 &lt; Y &lt; a * X) where X and Y are independent\n&quot;</span>
    <span class="s0">&quot;standard normal random variables.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;h: array_like\n&quot;</span>
    <span class="s0">&quot;    Input value.\n&quot;</span>
    <span class="s0">&quot;a: array_like\n&quot;</span>
    <span class="s0">&quot;    Input value.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;t: scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Probability of the event (X &gt; h and 0 &lt; Y &lt; a * X),\n&quot;</span>
    <span class="s0">&quot;    where X and Y are independent standard normal random variables.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy import special\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a = 3.5\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; h = 0.78\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; special.owens_t(h, a)\n&quot;</span>
    <span class="s0">&quot;0.10877216734852274\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] M. Patefield and D. Tandy, \&quot;Fast and accurate calculation of\n&quot;</span>
    <span class="s0">&quot;       Owen's T Function\&quot;, Statistical Software vol. 5, pp. 1-25, 2000.&quot;)</span>
<span class="s0">ufunc_owens_t_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_owens_t_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_owens_t_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_owens_t_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_owens_t_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_owens_t_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_owens_t_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_owens_t_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_owens_t_ptr[2*0] = &lt;void*&gt;_func_owens_t</span>
<span class="s0">ufunc_owens_t_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;owens_t&quot;)</span>
<span class="s0">ufunc_owens_t_ptr[2*1] = &lt;void*&gt;_func_owens_t</span>
<span class="s0">ufunc_owens_t_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;owens_t&quot;)</span>
<span class="s0">ufunc_owens_t_data[0] = &amp;ufunc_owens_t_ptr[2*0]</span>
<span class="s0">ufunc_owens_t_data[1] = &amp;ufunc_owens_t_ptr[2*1]</span>
<span class="s0">owens_t = np.PyUFunc_FromFuncAndData(ufunc_owens_t_loops, ufunc_owens_t_data, ufunc_owens_t_types, 2, 2, 1, 0, &quot;owens_t&quot;, ufunc_owens_t_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_pbdv_loops[2]</span>
<span class="s0">cdef void *ufunc_pbdv_ptr[4]</span>
<span class="s0">cdef void *ufunc_pbdv_data[2]</span>
<span class="s0">cdef char ufunc_pbdv_types[8]</span>
<span class="s0">cdef char *ufunc_pbdv_doc = (</span>
    <span class="s0">&quot;pbdv(v, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parabolic cylinder function D\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns (d, dp) the parabolic cylinder function Dv(x) in d and the\n&quot;</span>
    <span class="s0">&quot;derivative, Dv'(x) in dp.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;v : array_like\n&quot;</span>
    <span class="s0">&quot;    Real parameter\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;d : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the function\n&quot;</span>
    <span class="s0">&quot;dp : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the derivative vs x&quot;)</span>
<span class="s0">ufunc_pbdv_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_dd_dd_As_ff_ff</span>
<span class="s0">ufunc_pbdv_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_i_dd_dd_As_dd_dd</span>
<span class="s0">ufunc_pbdv_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pbdv_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pbdv_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pbdv_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pbdv_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pbdv_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pbdv_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pbdv_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pbdv_ptr[2*0] = &lt;void*&gt;_func_pbdv_wrap</span>
<span class="s0">ufunc_pbdv_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pbdv&quot;)</span>
<span class="s0">ufunc_pbdv_ptr[2*1] = &lt;void*&gt;_func_pbdv_wrap</span>
<span class="s0">ufunc_pbdv_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pbdv&quot;)</span>
<span class="s0">ufunc_pbdv_data[0] = &amp;ufunc_pbdv_ptr[2*0]</span>
<span class="s0">ufunc_pbdv_data[1] = &amp;ufunc_pbdv_ptr[2*1]</span>
<span class="s0">pbdv = np.PyUFunc_FromFuncAndData(ufunc_pbdv_loops, ufunc_pbdv_data, ufunc_pbdv_types, 2, 2, 2, 0, &quot;pbdv&quot;, ufunc_pbdv_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_pbvv_loops[2]</span>
<span class="s0">cdef void *ufunc_pbvv_ptr[4]</span>
<span class="s0">cdef void *ufunc_pbvv_data[2]</span>
<span class="s0">cdef char ufunc_pbvv_types[8]</span>
<span class="s0">cdef char *ufunc_pbvv_doc = (</span>
    <span class="s0">&quot;pbvv(v, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parabolic cylinder function V\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the parabolic cylinder function Vv(x) in v and the\n&quot;</span>
    <span class="s0">&quot;derivative, Vv'(x) in vp.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;v : array_like\n&quot;</span>
    <span class="s0">&quot;    Real parameter\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;v : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the function\n&quot;</span>
    <span class="s0">&quot;vp : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the derivative vs x&quot;)</span>
<span class="s0">ufunc_pbvv_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_dd_dd_As_ff_ff</span>
<span class="s0">ufunc_pbvv_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_i_dd_dd_As_dd_dd</span>
<span class="s0">ufunc_pbvv_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pbvv_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pbvv_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pbvv_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pbvv_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pbvv_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pbvv_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pbvv_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pbvv_ptr[2*0] = &lt;void*&gt;_func_pbvv_wrap</span>
<span class="s0">ufunc_pbvv_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pbvv&quot;)</span>
<span class="s0">ufunc_pbvv_ptr[2*1] = &lt;void*&gt;_func_pbvv_wrap</span>
<span class="s0">ufunc_pbvv_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pbvv&quot;)</span>
<span class="s0">ufunc_pbvv_data[0] = &amp;ufunc_pbvv_ptr[2*0]</span>
<span class="s0">ufunc_pbvv_data[1] = &amp;ufunc_pbvv_ptr[2*1]</span>
<span class="s0">pbvv = np.PyUFunc_FromFuncAndData(ufunc_pbvv_loops, ufunc_pbvv_data, ufunc_pbvv_types, 2, 2, 2, 0, &quot;pbvv&quot;, ufunc_pbvv_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_pbwa_loops[2]</span>
<span class="s0">cdef void *ufunc_pbwa_ptr[4]</span>
<span class="s0">cdef void *ufunc_pbwa_data[2]</span>
<span class="s0">cdef char ufunc_pbwa_types[8]</span>
<span class="s0">cdef char *ufunc_pbwa_doc = (</span>
    <span class="s0">&quot;pbwa(a, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parabolic cylinder function W.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function is a particular solution to the differential equation\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    y'' + \\left(\\frac{1}{4}x^2 - a\\right)y = 0,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;for a full definition see section 12.14 in [1]_.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a : array_like\n&quot;</span>
    <span class="s0">&quot;    Real parameter\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;w : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the function\n&quot;</span>
    <span class="s0">&quot;wp : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the derivative in x\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The function is a wrapper for a Fortran routine by Zhang and Jin\n&quot;</span>
    <span class="s0">&quot;[2]_. The implementation is accurate only for ``|a|, |x| &lt; 5`` and\n&quot;</span>
    <span class="s0">&quot;returns NaN outside that range.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Digital Library of Mathematical Functions, 14.30.\n&quot;</span>
    <span class="s0">&quot;       https://dlmf.nist.gov/14.30\n&quot;</span>
    <span class="s0">&quot;.. [2] Zhang, Shanjie and Jin, Jianming. \&quot;Computation of Special\n&quot;</span>
    <span class="s0">&quot;       Functions\&quot;, John Wiley and Sons, 1996.\n&quot;</span>
    <span class="s0">&quot;       https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html&quot;)</span>
<span class="s0">ufunc_pbwa_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_dd_dd_As_ff_ff</span>
<span class="s0">ufunc_pbwa_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_i_dd_dd_As_dd_dd</span>
<span class="s0">ufunc_pbwa_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pbwa_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pbwa_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pbwa_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pbwa_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pbwa_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pbwa_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pbwa_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pbwa_ptr[2*0] = &lt;void*&gt;_func_pbwa_wrap</span>
<span class="s0">ufunc_pbwa_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pbwa&quot;)</span>
<span class="s0">ufunc_pbwa_ptr[2*1] = &lt;void*&gt;_func_pbwa_wrap</span>
<span class="s0">ufunc_pbwa_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pbwa&quot;)</span>
<span class="s0">ufunc_pbwa_data[0] = &amp;ufunc_pbwa_ptr[2*0]</span>
<span class="s0">ufunc_pbwa_data[1] = &amp;ufunc_pbwa_ptr[2*1]</span>
<span class="s0">pbwa = np.PyUFunc_FromFuncAndData(ufunc_pbwa_loops, ufunc_pbwa_data, ufunc_pbwa_types, 2, 2, 2, 0, &quot;pbwa&quot;, ufunc_pbwa_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_pdtr_loops[2]</span>
<span class="s0">cdef void *ufunc_pdtr_ptr[4]</span>
<span class="s0">cdef void *ufunc_pdtr_data[2]</span>
<span class="s0">cdef char ufunc_pdtr_types[6]</span>
<span class="s0">cdef char *ufunc_pdtr_doc = (</span>
    <span class="s0">&quot;pdtr(k, m, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Poisson cumulative distribution function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined as the probability that a Poisson-distributed random\n&quot;</span>
    <span class="s0">&quot;variable with event rate :math:`m` is less than or equal to\n&quot;</span>
    <span class="s0">&quot;:math:`k`. More concretely, this works out to be [1]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;   \\exp(-m) \\sum_{j = 0}^{\\lfloor{k}\\rfloor} \\frac{m^j}{j!}.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;k : array_like\n&quot;</span>
    <span class="s0">&quot;    Number of occurrences (nonnegative, real)\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Shape parameter (nonnegative, real)\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Poisson cumulative distribution function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;pdtrc : Poisson survival function\n&quot;</span>
    <span class="s0">&quot;pdtrik : inverse of `pdtr` with respect to `k`\n&quot;</span>
    <span class="s0">&quot;pdtri : inverse of `pdtr` with respect to `m`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] https://en.wikipedia.org/wiki/Poisson_distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is a cumulative distribution function, so it converges to 1\n&quot;</span>
    <span class="s0">&quot;monotonically as `k` goes to infinity.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.pdtr([1, 10, 100, np.inf], 1)\n&quot;</span>
    <span class="s0">&quot;array([0.73575888, 0.99999999, 1.        , 1.        ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is discontinuous at integers and constant between integers.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.pdtr([1, 1.5, 1.9, 2], 1)\n&quot;</span>
    <span class="s0">&quot;array([0.73575888, 0.73575888, 0.73575888, 0.9196986 ])&quot;)</span>
<span class="s0">ufunc_pdtr_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_pdtr_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_pdtr_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pdtr_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pdtr_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pdtr_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pdtr_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pdtr_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pdtr_ptr[2*0] = &lt;void*&gt;_func_pdtr</span>
<span class="s0">ufunc_pdtr_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pdtr&quot;)</span>
<span class="s0">ufunc_pdtr_ptr[2*1] = &lt;void*&gt;_func_pdtr</span>
<span class="s0">ufunc_pdtr_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pdtr&quot;)</span>
<span class="s0">ufunc_pdtr_data[0] = &amp;ufunc_pdtr_ptr[2*0]</span>
<span class="s0">ufunc_pdtr_data[1] = &amp;ufunc_pdtr_ptr[2*1]</span>
<span class="s0">pdtr = np.PyUFunc_FromFuncAndData(ufunc_pdtr_loops, ufunc_pdtr_data, ufunc_pdtr_types, 2, 2, 1, 0, &quot;pdtr&quot;, ufunc_pdtr_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_pdtrc_loops[2]</span>
<span class="s0">cdef void *ufunc_pdtrc_ptr[4]</span>
<span class="s0">cdef void *ufunc_pdtrc_data[2]</span>
<span class="s0">cdef char ufunc_pdtrc_types[6]</span>
<span class="s0">cdef char *ufunc_pdtrc_doc = (</span>
    <span class="s0">&quot;pdtrc(k, m, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Poisson survival function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the sum of the terms from k+1 to infinity of the Poisson\n&quot;</span>
    <span class="s0">&quot;distribution: sum(exp(-m) * m**j / j!, j=k+1..inf) = gammainc(\n&quot;</span>
    <span class="s0">&quot;k+1, m). Arguments must both be non-negative doubles.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;k : array_like\n&quot;</span>
    <span class="s0">&quot;    Number of occurrences (nonnegative, real)\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Shape parameter (nonnegative, real)\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Poisson survival function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;pdtr : Poisson cumulative distribution function\n&quot;</span>
    <span class="s0">&quot;pdtrik : inverse of `pdtr` with respect to `k`\n&quot;</span>
    <span class="s0">&quot;pdtri : inverse of `pdtr` with respect to `m`&quot;)</span>
<span class="s0">ufunc_pdtrc_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_pdtrc_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_pdtrc_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pdtrc_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pdtrc_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pdtrc_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pdtrc_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pdtrc_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pdtrc_ptr[2*0] = &lt;void*&gt;_func_pdtrc</span>
<span class="s0">ufunc_pdtrc_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pdtrc&quot;)</span>
<span class="s0">ufunc_pdtrc_ptr[2*1] = &lt;void*&gt;_func_pdtrc</span>
<span class="s0">ufunc_pdtrc_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pdtrc&quot;)</span>
<span class="s0">ufunc_pdtrc_data[0] = &amp;ufunc_pdtrc_ptr[2*0]</span>
<span class="s0">ufunc_pdtrc_data[1] = &amp;ufunc_pdtrc_ptr[2*1]</span>
<span class="s0">pdtrc = np.PyUFunc_FromFuncAndData(ufunc_pdtrc_loops, ufunc_pdtrc_data, ufunc_pdtrc_types, 2, 2, 1, 0, &quot;pdtrc&quot;, ufunc_pdtrc_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_pdtri_loops[3]</span>
<span class="s0">cdef void *ufunc_pdtri_ptr[6]</span>
<span class="s0">cdef void *ufunc_pdtri_data[3]</span>
<span class="s0">cdef char ufunc_pdtri_types[9]</span>
<span class="s0">cdef char *ufunc_pdtri_doc = (</span>
    <span class="s0">&quot;pdtri(k, y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse to `pdtr` vs m\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the Poisson variable `m` such that the sum from 0 to `k` of\n&quot;</span>
    <span class="s0">&quot;the Poisson density is equal to the given probability `y`:\n&quot;</span>
    <span class="s0">&quot;calculated by ``gammaincinv(k + 1, y)``. `k` must be a nonnegative\n&quot;</span>
    <span class="s0">&quot;integer and `y` between 0 and 1.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;k : array_like\n&quot;</span>
    <span class="s0">&quot;    Number of occurrences (nonnegative, real)\n&quot;</span>
    <span class="s0">&quot;y : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the shape paramter `m` such that ``pdtr(k, m) = p``\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;pdtr : Poisson cumulative distribution function\n&quot;</span>
    <span class="s0">&quot;pdtrc : Poisson survival function\n&quot;</span>
    <span class="s0">&quot;pdtrik : inverse of `pdtr` with respect to `k`&quot;)</span>
<span class="s0">ufunc_pdtri_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_id__As_ld_d</span>
<span class="s0">ufunc_pdtri_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_pdtri_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_pdtri_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc_pdtri_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pdtri_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pdtri_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pdtri_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pdtri_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pdtri_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pdtri_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pdtri_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pdtri_ptr[2*0] = &lt;void*&gt;_func_pdtri</span>
<span class="s0">ufunc_pdtri_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pdtri&quot;)</span>
<span class="s0">ufunc_pdtri_ptr[2*1] = &lt;void*&gt;_func_pdtri_unsafe</span>
<span class="s0">ufunc_pdtri_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pdtri&quot;)</span>
<span class="s0">ufunc_pdtri_ptr[2*2] = &lt;void*&gt;_func_pdtri_unsafe</span>
<span class="s0">ufunc_pdtri_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pdtri&quot;)</span>
<span class="s0">ufunc_pdtri_data[0] = &amp;ufunc_pdtri_ptr[2*0]</span>
<span class="s0">ufunc_pdtri_data[1] = &amp;ufunc_pdtri_ptr[2*1]</span>
<span class="s0">ufunc_pdtri_data[2] = &amp;ufunc_pdtri_ptr[2*2]</span>
<span class="s0">pdtri = np.PyUFunc_FromFuncAndData(ufunc_pdtri_loops, ufunc_pdtri_data, ufunc_pdtri_types, 3, 2, 1, 0, &quot;pdtri&quot;, ufunc_pdtri_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_pdtrik_loops[2]</span>
<span class="s0">cdef void *ufunc_pdtrik_ptr[4]</span>
<span class="s0">cdef void *ufunc_pdtrik_data[2]</span>
<span class="s0">cdef char ufunc_pdtrik_types[6]</span>
<span class="s0">cdef char *ufunc_pdtrik_doc = (</span>
    <span class="s0">&quot;pdtrik(p, m, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse to `pdtr` vs `m`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Shape parameter (nonnegative, real)\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The number of occurrences `k` such that ``pdtr(k, m) = p``\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;pdtr : Poisson cumulative distribution function\n&quot;</span>
    <span class="s0">&quot;pdtrc : Poisson survival function\n&quot;</span>
    <span class="s0">&quot;pdtri : inverse of `pdtr` with respect to `m`&quot;)</span>
<span class="s0">ufunc_pdtrik_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_pdtrik_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_pdtrik_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pdtrik_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pdtrik_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pdtrik_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pdtrik_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pdtrik_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pdtrik_ptr[2*0] = &lt;void*&gt;_func_cdfpoi2_wrap</span>
<span class="s0">ufunc_pdtrik_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pdtrik&quot;)</span>
<span class="s0">ufunc_pdtrik_ptr[2*1] = &lt;void*&gt;_func_cdfpoi2_wrap</span>
<span class="s0">ufunc_pdtrik_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pdtrik&quot;)</span>
<span class="s0">ufunc_pdtrik_data[0] = &amp;ufunc_pdtrik_ptr[2*0]</span>
<span class="s0">ufunc_pdtrik_data[1] = &amp;ufunc_pdtrik_ptr[2*1]</span>
<span class="s0">pdtrik = np.PyUFunc_FromFuncAndData(ufunc_pdtrik_loops, ufunc_pdtrik_data, ufunc_pdtrik_types, 2, 2, 1, 0, &quot;pdtrik&quot;, ufunc_pdtrik_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_poch_loops[2]</span>
<span class="s0">cdef void *ufunc_poch_ptr[4]</span>
<span class="s0">cdef void *ufunc_poch_data[2]</span>
<span class="s0">cdef char ufunc_poch_types[6]</span>
<span class="s0">cdef char *ufunc_poch_doc = (</span>
    <span class="s0">&quot;poch(z, m, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Pochhammer symbol.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The Pochhammer symbol (rising factorial) is defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    (z)_m = \\frac{\\Gamma(z + m)}{\\Gamma(z)}\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For positive integer `m` it reads\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    (z)_m = z (z + 1) ... (z + m - 1)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See [dlmf]_ for more details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;z, m : array_like\n&quot;</span>
    <span class="s0">&quot;    Real-valued arguments.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The value of the function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [dlmf] Nist, Digital Library of Mathematical Functions\n&quot;</span>
    <span class="s0">&quot;    https://dlmf.nist.gov/5.2#iii\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is 1 when m is 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.poch([1, 2, 3, 4], 0)\n&quot;</span>
    <span class="s0">&quot;array([1., 1., 1., 1.])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For z equal to 1 it reduces to the factorial function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.poch(1, 5)\n&quot;</span>
    <span class="s0">&quot;120.0\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; 1 * 2 * 3 * 4 * 5\n&quot;</span>
    <span class="s0">&quot;120\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It can be expressed in terms of the gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z, m = 3.7, 2.1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.poch(z, m)\n&quot;</span>
    <span class="s0">&quot;20.529581933776953\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.gamma(z + m) / sc.gamma(z)\n&quot;</span>
    <span class="s0">&quot;20.52958193377696&quot;)</span>
<span class="s0">ufunc_poch_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_poch_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_poch_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_poch_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_poch_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_poch_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_poch_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_poch_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_poch_ptr[2*0] = &lt;void*&gt;_func_poch</span>
<span class="s0">ufunc_poch_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;poch&quot;)</span>
<span class="s0">ufunc_poch_ptr[2*1] = &lt;void*&gt;_func_poch</span>
<span class="s0">ufunc_poch_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;poch&quot;)</span>
<span class="s0">ufunc_poch_data[0] = &amp;ufunc_poch_ptr[2*0]</span>
<span class="s0">ufunc_poch_data[1] = &amp;ufunc_poch_ptr[2*1]</span>
<span class="s0">poch = np.PyUFunc_FromFuncAndData(ufunc_poch_loops, ufunc_poch_data, ufunc_poch_types, 2, 2, 1, 0, &quot;poch&quot;, ufunc_poch_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_powm1_loops[2]</span>
<span class="s0">cdef void *ufunc_powm1_ptr[4]</span>
<span class="s0">cdef void *ufunc_powm1_data[2]</span>
<span class="s0">cdef char ufunc_powm1_types[6]</span>
<span class="s0">cdef char *ufunc_powm1_doc = (</span>
    <span class="s0">&quot;powm1(x, y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes ``x**y - 1``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is useful when `y` is near 0, or when `x` is near 1.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function is implemented for real types only (unlike ``numpy.power``,\n&quot;</span>
    <span class="s0">&quot;which accepts complex inputs).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    The base. Must be a real type (i.e. integer or float, not complex).\n&quot;</span>
    <span class="s0">&quot;y : array_like\n&quot;</span>
    <span class="s0">&quot;    The exponent. Must be a real type (i.e. integer or float, not complex).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;array_like\n&quot;</span>
    <span class="s0">&quot;    Result of the calculation\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 1.10.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The underlying code is implemented for single precision and double\n&quot;</span>
    <span class="s0">&quot;precision floats only.  Unlike `numpy.power`, integer inputs to\n&quot;</span>
    <span class="s0">&quot;`powm1` are converted to floating point, and complex inputs are\n&quot;</span>
    <span class="s0">&quot;not accepted.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Note the following edge cases:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;* ``powm1(x, 0)`` returns 0 for any ``x``, including 0, ``inf``\n&quot;</span>
    <span class="s0">&quot;  and ``nan``.\n&quot;</span>
    <span class="s0">&quot;* ``powm1(1, y)`` returns 0 for any ``y``, including ``nan``\n&quot;</span>
    <span class="s0">&quot;  and ``inf``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import powm1\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.array([1.2, 10.0, 0.9999999975])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = np.array([1e-9, 1e-11, 0.1875])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; powm1(x, y)\n&quot;</span>
    <span class="s0">&quot;array([ 1.82321557e-10,  2.30258509e-11, -4.68749998e-10])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It can be verified that the relative errors in those results\n&quot;</span>
    <span class="s0">&quot;are less than 2.5e-16.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compare that to the result of ``x**y - 1``, where the\n&quot;</span>
    <span class="s0">&quot;relative errors are all larger than 8e-8:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x**y - 1\n&quot;</span>
    <span class="s0">&quot;array([ 1.82321491e-10,  2.30258035e-11, -4.68750039e-10])&quot;)</span>
<span class="s0">ufunc_powm1_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_f_ff__As_ff_f</span>
<span class="s0">ufunc_powm1_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_powm1_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_powm1_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_powm1_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_powm1_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_powm1_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_powm1_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_powm1_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_powm1_float</span>
<span class="s0">ufunc_powm1_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;powm1&quot;)</span>
<span class="s0">ufunc_powm1_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_powm1_double</span>
<span class="s0">ufunc_powm1_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;powm1&quot;)</span>
<span class="s0">ufunc_powm1_data[0] = &amp;ufunc_powm1_ptr[2*0]</span>
<span class="s0">ufunc_powm1_data[1] = &amp;ufunc_powm1_ptr[2*1]</span>
<span class="s0">powm1 = np.PyUFunc_FromFuncAndData(ufunc_powm1_loops, ufunc_powm1_data, ufunc_powm1_types, 2, 2, 1, 0, &quot;powm1&quot;, ufunc_powm1_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_pro_ang1_loops[2]</span>
<span class="s0">cdef void *ufunc_pro_ang1_ptr[4]</span>
<span class="s0">cdef void *ufunc_pro_ang1_data[2]</span>
<span class="s0">cdef char ufunc_pro_ang1_types[12]</span>
<span class="s0">cdef char *ufunc_pro_ang1_doc = (</span>
    <span class="s0">&quot;pro_ang1(m, n, c, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Prolate spheroidal angular function of the first kind and its derivative\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes the prolate spheroidal angular function of the first kind\n&quot;</span>
    <span class="s0">&quot;and its derivative (with respect to `x`) for mode parameters m&gt;=0\n&quot;</span>
    <span class="s0">&quot;and n&gt;=m, spheroidal parameter `c` and ``|x| &lt; 1.0``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Nonnegative mode parameter m\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Mode parameter n (&gt;= m)\n&quot;</span>
    <span class="s0">&quot;c : array_like\n&quot;</span>
    <span class="s0">&quot;    Spheroidal parameter\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real parameter (``|x| &lt; 1.0``)\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;s : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the function\n&quot;</span>
    <span class="s0">&quot;sp : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the derivative vs x&quot;)</span>
<span class="s0">ufunc_pro_ang1_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd_d_As_ffff_ff</span>
<span class="s0">ufunc_pro_ang1_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd_d_As_dddd_dd</span>
<span class="s0">ufunc_pro_ang1_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_ang1_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_ang1_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_ang1_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_ang1_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_ang1_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_ang1_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_ang1_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_ang1_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_ang1_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_ang1_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_ang1_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_ang1_ptr[2*0] = &lt;void*&gt;_func_prolate_aswfa_nocv_wrap</span>
<span class="s0">ufunc_pro_ang1_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pro_ang1&quot;)</span>
<span class="s0">ufunc_pro_ang1_ptr[2*1] = &lt;void*&gt;_func_prolate_aswfa_nocv_wrap</span>
<span class="s0">ufunc_pro_ang1_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pro_ang1&quot;)</span>
<span class="s0">ufunc_pro_ang1_data[0] = &amp;ufunc_pro_ang1_ptr[2*0]</span>
<span class="s0">ufunc_pro_ang1_data[1] = &amp;ufunc_pro_ang1_ptr[2*1]</span>
<span class="s0">pro_ang1 = np.PyUFunc_FromFuncAndData(ufunc_pro_ang1_loops, ufunc_pro_ang1_data, ufunc_pro_ang1_types, 2, 4, 2, 0, &quot;pro_ang1&quot;, ufunc_pro_ang1_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_pro_ang1_cv_loops[2]</span>
<span class="s0">cdef void *ufunc_pro_ang1_cv_ptr[4]</span>
<span class="s0">cdef void *ufunc_pro_ang1_cv_data[2]</span>
<span class="s0">cdef char ufunc_pro_ang1_cv_types[14]</span>
<span class="s0">cdef char *ufunc_pro_ang1_cv_doc = (</span>
    <span class="s0">&quot;pro_ang1_cv(m, n, c, cv, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Prolate spheroidal angular function pro_ang1 for precomputed characteristic value\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes the prolate spheroidal angular function of the first kind\n&quot;</span>
    <span class="s0">&quot;and its derivative (with respect to `x`) for mode parameters m&gt;=0\n&quot;</span>
    <span class="s0">&quot;and n&gt;=m, spheroidal parameter `c` and ``|x| &lt; 1.0``. Requires\n&quot;</span>
    <span class="s0">&quot;pre-computed characteristic value.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Nonnegative mode parameter m\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Mode parameter n (&gt;= m)\n&quot;</span>
    <span class="s0">&quot;c : array_like\n&quot;</span>
    <span class="s0">&quot;    Spheroidal parameter\n&quot;</span>
    <span class="s0">&quot;cv : array_like\n&quot;</span>
    <span class="s0">&quot;    Characteristic value\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real parameter (``|x| &lt; 1.0``)\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;s : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the function\n&quot;</span>
    <span class="s0">&quot;sp : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the derivative vs x&quot;)</span>
<span class="s0">ufunc_pro_ang1_cv_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_ddddd_dd_As_fffff_ff</span>
<span class="s0">ufunc_pro_ang1_cv_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_i_ddddd_dd_As_ddddd_dd</span>
<span class="s0">ufunc_pro_ang1_cv_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_ang1_cv_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_ang1_cv_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_ang1_cv_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_ang1_cv_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_ang1_cv_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_ang1_cv_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_ang1_cv_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_ang1_cv_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_ang1_cv_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_ang1_cv_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_ang1_cv_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_ang1_cv_types[12] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_ang1_cv_types[13] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_ang1_cv_ptr[2*0] = &lt;void*&gt;_func_prolate_aswfa_wrap</span>
<span class="s0">ufunc_pro_ang1_cv_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pro_ang1_cv&quot;)</span>
<span class="s0">ufunc_pro_ang1_cv_ptr[2*1] = &lt;void*&gt;_func_prolate_aswfa_wrap</span>
<span class="s0">ufunc_pro_ang1_cv_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pro_ang1_cv&quot;)</span>
<span class="s0">ufunc_pro_ang1_cv_data[0] = &amp;ufunc_pro_ang1_cv_ptr[2*0]</span>
<span class="s0">ufunc_pro_ang1_cv_data[1] = &amp;ufunc_pro_ang1_cv_ptr[2*1]</span>
<span class="s0">pro_ang1_cv = np.PyUFunc_FromFuncAndData(ufunc_pro_ang1_cv_loops, ufunc_pro_ang1_cv_data, ufunc_pro_ang1_cv_types, 2, 5, 2, 0, &quot;pro_ang1_cv&quot;, ufunc_pro_ang1_cv_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_pro_cv_loops[2]</span>
<span class="s0">cdef void *ufunc_pro_cv_ptr[4]</span>
<span class="s0">cdef void *ufunc_pro_cv_data[2]</span>
<span class="s0">cdef char ufunc_pro_cv_types[8]</span>
<span class="s0">cdef char *ufunc_pro_cv_doc = (</span>
    <span class="s0">&quot;pro_cv(m, n, c, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Characteristic value of prolate spheroidal function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes the characteristic value of prolate spheroidal wave\n&quot;</span>
    <span class="s0">&quot;functions of order `m`, `n` (n&gt;=m) and spheroidal parameter `c`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Nonnegative mode parameter m\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Mode parameter n (&gt;= m)\n&quot;</span>
    <span class="s0">&quot;c : array_like\n&quot;</span>
    <span class="s0">&quot;    Spheroidal parameter\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;cv : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Characteristic value&quot;)</span>
<span class="s0">ufunc_pro_cv_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_pro_cv_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_pro_cv_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_cv_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_cv_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_cv_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_cv_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_cv_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_cv_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_cv_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_cv_ptr[2*0] = &lt;void*&gt;_func_prolate_segv_wrap</span>
<span class="s0">ufunc_pro_cv_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pro_cv&quot;)</span>
<span class="s0">ufunc_pro_cv_ptr[2*1] = &lt;void*&gt;_func_prolate_segv_wrap</span>
<span class="s0">ufunc_pro_cv_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pro_cv&quot;)</span>
<span class="s0">ufunc_pro_cv_data[0] = &amp;ufunc_pro_cv_ptr[2*0]</span>
<span class="s0">ufunc_pro_cv_data[1] = &amp;ufunc_pro_cv_ptr[2*1]</span>
<span class="s0">pro_cv = np.PyUFunc_FromFuncAndData(ufunc_pro_cv_loops, ufunc_pro_cv_data, ufunc_pro_cv_types, 2, 3, 1, 0, &quot;pro_cv&quot;, ufunc_pro_cv_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_pro_rad1_loops[2]</span>
<span class="s0">cdef void *ufunc_pro_rad1_ptr[4]</span>
<span class="s0">cdef void *ufunc_pro_rad1_data[2]</span>
<span class="s0">cdef char ufunc_pro_rad1_types[12]</span>
<span class="s0">cdef char *ufunc_pro_rad1_doc = (</span>
    <span class="s0">&quot;pro_rad1(m, n, c, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Prolate spheroidal radial function of the first kind and its derivative\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes the prolate spheroidal radial function of the first kind\n&quot;</span>
    <span class="s0">&quot;and its derivative (with respect to `x`) for mode parameters m&gt;=0\n&quot;</span>
    <span class="s0">&quot;and n&gt;=m, spheroidal parameter `c` and ``|x| &lt; 1.0``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Nonnegative mode parameter m\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Mode parameter n (&gt;= m)\n&quot;</span>
    <span class="s0">&quot;c : array_like\n&quot;</span>
    <span class="s0">&quot;    Spheroidal parameter\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real parameter (``|x| &lt; 1.0``)\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;s : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the function\n&quot;</span>
    <span class="s0">&quot;sp : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the derivative vs x&quot;)</span>
<span class="s0">ufunc_pro_rad1_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd_d_As_ffff_ff</span>
<span class="s0">ufunc_pro_rad1_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd_d_As_dddd_dd</span>
<span class="s0">ufunc_pro_rad1_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_rad1_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_rad1_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_rad1_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_rad1_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_rad1_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_rad1_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_rad1_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_rad1_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_rad1_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_rad1_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_rad1_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_rad1_ptr[2*0] = &lt;void*&gt;_func_prolate_radial1_nocv_wrap</span>
<span class="s0">ufunc_pro_rad1_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pro_rad1&quot;)</span>
<span class="s0">ufunc_pro_rad1_ptr[2*1] = &lt;void*&gt;_func_prolate_radial1_nocv_wrap</span>
<span class="s0">ufunc_pro_rad1_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pro_rad1&quot;)</span>
<span class="s0">ufunc_pro_rad1_data[0] = &amp;ufunc_pro_rad1_ptr[2*0]</span>
<span class="s0">ufunc_pro_rad1_data[1] = &amp;ufunc_pro_rad1_ptr[2*1]</span>
<span class="s0">pro_rad1 = np.PyUFunc_FromFuncAndData(ufunc_pro_rad1_loops, ufunc_pro_rad1_data, ufunc_pro_rad1_types, 2, 4, 2, 0, &quot;pro_rad1&quot;, ufunc_pro_rad1_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_pro_rad1_cv_loops[2]</span>
<span class="s0">cdef void *ufunc_pro_rad1_cv_ptr[4]</span>
<span class="s0">cdef void *ufunc_pro_rad1_cv_data[2]</span>
<span class="s0">cdef char ufunc_pro_rad1_cv_types[14]</span>
<span class="s0">cdef char *ufunc_pro_rad1_cv_doc = (</span>
    <span class="s0">&quot;pro_rad1_cv(m, n, c, cv, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Prolate spheroidal radial function pro_rad1 for precomputed characteristic value\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes the prolate spheroidal radial function of the first kind\n&quot;</span>
    <span class="s0">&quot;and its derivative (with respect to `x`) for mode parameters m&gt;=0\n&quot;</span>
    <span class="s0">&quot;and n&gt;=m, spheroidal parameter `c` and ``|x| &lt; 1.0``. Requires\n&quot;</span>
    <span class="s0">&quot;pre-computed characteristic value.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Nonnegative mode parameter m\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Mode parameter n (&gt;= m)\n&quot;</span>
    <span class="s0">&quot;c : array_like\n&quot;</span>
    <span class="s0">&quot;    Spheroidal parameter\n&quot;</span>
    <span class="s0">&quot;cv : array_like\n&quot;</span>
    <span class="s0">&quot;    Characteristic value\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real parameter (``|x| &lt; 1.0``)\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;s : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the function\n&quot;</span>
    <span class="s0">&quot;sp : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the derivative vs x&quot;)</span>
<span class="s0">ufunc_pro_rad1_cv_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_ddddd_dd_As_fffff_ff</span>
<span class="s0">ufunc_pro_rad1_cv_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_i_ddddd_dd_As_ddddd_dd</span>
<span class="s0">ufunc_pro_rad1_cv_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_rad1_cv_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_rad1_cv_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_rad1_cv_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_rad1_cv_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_rad1_cv_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_rad1_cv_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_rad1_cv_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_rad1_cv_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_rad1_cv_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_rad1_cv_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_rad1_cv_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_rad1_cv_types[12] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_rad1_cv_types[13] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_rad1_cv_ptr[2*0] = &lt;void*&gt;_func_prolate_radial1_wrap</span>
<span class="s0">ufunc_pro_rad1_cv_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pro_rad1_cv&quot;)</span>
<span class="s0">ufunc_pro_rad1_cv_ptr[2*1] = &lt;void*&gt;_func_prolate_radial1_wrap</span>
<span class="s0">ufunc_pro_rad1_cv_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pro_rad1_cv&quot;)</span>
<span class="s0">ufunc_pro_rad1_cv_data[0] = &amp;ufunc_pro_rad1_cv_ptr[2*0]</span>
<span class="s0">ufunc_pro_rad1_cv_data[1] = &amp;ufunc_pro_rad1_cv_ptr[2*1]</span>
<span class="s0">pro_rad1_cv = np.PyUFunc_FromFuncAndData(ufunc_pro_rad1_cv_loops, ufunc_pro_rad1_cv_data, ufunc_pro_rad1_cv_types, 2, 5, 2, 0, &quot;pro_rad1_cv&quot;, ufunc_pro_rad1_cv_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_pro_rad2_loops[2]</span>
<span class="s0">cdef void *ufunc_pro_rad2_ptr[4]</span>
<span class="s0">cdef void *ufunc_pro_rad2_data[2]</span>
<span class="s0">cdef char ufunc_pro_rad2_types[12]</span>
<span class="s0">cdef char *ufunc_pro_rad2_doc = (</span>
    <span class="s0">&quot;pro_rad2(m, n, c, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Prolate spheroidal radial function of the second kind and its derivative\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes the prolate spheroidal radial function of the second kind\n&quot;</span>
    <span class="s0">&quot;and its derivative (with respect to `x`) for mode parameters m&gt;=0\n&quot;</span>
    <span class="s0">&quot;and n&gt;=m, spheroidal parameter `c` and ``|x| &lt; 1.0``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Nonnegative mode parameter m\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Mode parameter n (&gt;= m)\n&quot;</span>
    <span class="s0">&quot;c : array_like\n&quot;</span>
    <span class="s0">&quot;    Spheroidal parameter\n&quot;</span>
    <span class="s0">&quot;cv : array_like\n&quot;</span>
    <span class="s0">&quot;    Characteristic value\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real parameter (``|x| &lt; 1.0``)\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;s : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the function\n&quot;</span>
    <span class="s0">&quot;sp : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the derivative vs x&quot;)</span>
<span class="s0">ufunc_pro_rad2_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd_d_As_ffff_ff</span>
<span class="s0">ufunc_pro_rad2_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dddd_d_As_dddd_dd</span>
<span class="s0">ufunc_pro_rad2_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_rad2_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_rad2_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_rad2_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_rad2_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_rad2_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_rad2_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_rad2_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_rad2_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_rad2_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_rad2_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_rad2_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_rad2_ptr[2*0] = &lt;void*&gt;_func_prolate_radial2_nocv_wrap</span>
<span class="s0">ufunc_pro_rad2_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pro_rad2&quot;)</span>
<span class="s0">ufunc_pro_rad2_ptr[2*1] = &lt;void*&gt;_func_prolate_radial2_nocv_wrap</span>
<span class="s0">ufunc_pro_rad2_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pro_rad2&quot;)</span>
<span class="s0">ufunc_pro_rad2_data[0] = &amp;ufunc_pro_rad2_ptr[2*0]</span>
<span class="s0">ufunc_pro_rad2_data[1] = &amp;ufunc_pro_rad2_ptr[2*1]</span>
<span class="s0">pro_rad2 = np.PyUFunc_FromFuncAndData(ufunc_pro_rad2_loops, ufunc_pro_rad2_data, ufunc_pro_rad2_types, 2, 4, 2, 0, &quot;pro_rad2&quot;, ufunc_pro_rad2_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_pro_rad2_cv_loops[2]</span>
<span class="s0">cdef void *ufunc_pro_rad2_cv_ptr[4]</span>
<span class="s0">cdef void *ufunc_pro_rad2_cv_data[2]</span>
<span class="s0">cdef char ufunc_pro_rad2_cv_types[14]</span>
<span class="s0">cdef char *ufunc_pro_rad2_cv_doc = (</span>
    <span class="s0">&quot;pro_rad2_cv(m, n, c, cv, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Prolate spheroidal radial function pro_rad2 for precomputed characteristic value\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Computes the prolate spheroidal radial function of the second kind\n&quot;</span>
    <span class="s0">&quot;and its derivative (with respect to `x`) for mode parameters m&gt;=0\n&quot;</span>
    <span class="s0">&quot;and n&gt;=m, spheroidal parameter `c` and ``|x| &lt; 1.0``. Requires\n&quot;</span>
    <span class="s0">&quot;pre-computed characteristic value.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Nonnegative mode parameter m\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Mode parameter n (&gt;= m)\n&quot;</span>
    <span class="s0">&quot;c : array_like\n&quot;</span>
    <span class="s0">&quot;    Spheroidal parameter\n&quot;</span>
    <span class="s0">&quot;cv : array_like\n&quot;</span>
    <span class="s0">&quot;    Characteristic value\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real parameter (``|x| &lt; 1.0``)\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;s : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the function\n&quot;</span>
    <span class="s0">&quot;sp : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the derivative vs x&quot;)</span>
<span class="s0">ufunc_pro_rad2_cv_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_ddddd_dd_As_fffff_ff</span>
<span class="s0">ufunc_pro_rad2_cv_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_i_ddddd_dd_As_ddddd_dd</span>
<span class="s0">ufunc_pro_rad2_cv_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_rad2_cv_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_rad2_cv_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_rad2_cv_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_rad2_cv_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_rad2_cv_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_rad2_cv_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pro_rad2_cv_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_rad2_cv_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_rad2_cv_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_rad2_cv_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_rad2_cv_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_rad2_cv_types[12] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_rad2_cv_types[13] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pro_rad2_cv_ptr[2*0] = &lt;void*&gt;_func_prolate_radial2_wrap</span>
<span class="s0">ufunc_pro_rad2_cv_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pro_rad2_cv&quot;)</span>
<span class="s0">ufunc_pro_rad2_cv_ptr[2*1] = &lt;void*&gt;_func_prolate_radial2_wrap</span>
<span class="s0">ufunc_pro_rad2_cv_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pro_rad2_cv&quot;)</span>
<span class="s0">ufunc_pro_rad2_cv_data[0] = &amp;ufunc_pro_rad2_cv_ptr[2*0]</span>
<span class="s0">ufunc_pro_rad2_cv_data[1] = &amp;ufunc_pro_rad2_cv_ptr[2*1]</span>
<span class="s0">pro_rad2_cv = np.PyUFunc_FromFuncAndData(ufunc_pro_rad2_cv_loops, ufunc_pro_rad2_cv_data, ufunc_pro_rad2_cv_types, 2, 5, 2, 0, &quot;pro_rad2_cv&quot;, ufunc_pro_rad2_cv_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_pseudo_huber_loops[2]</span>
<span class="s0">cdef void *ufunc_pseudo_huber_ptr[4]</span>
<span class="s0">cdef void *ufunc_pseudo_huber_data[2]</span>
<span class="s0">cdef char ufunc_pseudo_huber_types[6]</span>
<span class="s0">cdef char *ufunc_pseudo_huber_doc = (</span>
    <span class="s0">&quot;pseudo_huber(delta, r, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Pseudo-Huber loss function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: \\mathrm{pseudo\\_huber}(\\delta, r) = \\delta^2 \\left( \\sqrt{ 1 + \\left( \\frac{r}{\\delta} \\right)^2 } - 1 \\right)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;delta : array_like\n&quot;</span>
    <span class="s0">&quot;    Input array, indicating the soft quadratic vs. linear loss changepoint.\n&quot;</span>
    <span class="s0">&quot;r : array_like\n&quot;</span>
    <span class="s0">&quot;    Input array, possibly representing residuals.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;res : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The computed Pseudo-Huber loss function values.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;huber: Similar function which this function approximates\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Like `huber`, `pseudo_huber` often serves as a robust loss function\n&quot;</span>
    <span class="s0">&quot;in statistics or machine learning to reduce the influence of outliers.\n&quot;</span>
    <span class="s0">&quot;Unlike `huber`, `pseudo_huber` is smooth.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Typically, `r` represents residuals, the difference\n&quot;</span>
    <span class="s0">&quot;between a model prediction and data. Then, for :math:`|r|\\leq\\delta`,\n&quot;</span>
    <span class="s0">&quot;`pseudo_huber` resembles the squared error and for :math:`|r|&gt;\\delta` the\n&quot;</span>
    <span class="s0">&quot;absolute error. This way, the Pseudo-Huber loss often achieves\n&quot;</span>
    <span class="s0">&quot;a fast convergence in model fitting for small residuals like the squared\n&quot;</span>
    <span class="s0">&quot;error loss function and still reduces the influence of outliers\n&quot;</span>
    <span class="s0">&quot;(:math:`|r|&gt;\\delta`) like the absolute error loss. As :math:`\\delta` is\n&quot;</span>
    <span class="s0">&quot;the cutoff between squared and absolute error regimes, it has\n&quot;</span>
    <span class="s0">&quot;to be tuned carefully for each problem. `pseudo_huber` is also\n&quot;</span>
    <span class="s0">&quot;convex, making it suitable for gradient based optimization. [1]_ [2]_\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 0.15.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Hartley, Zisserman, \&quot;Multiple View Geometry in Computer Vision\&quot;.\n&quot;</span>
    <span class="s0">&quot;       2003. Cambridge University Press. p. 619\n&quot;</span>
    <span class="s0">&quot;.. [2] Charbonnier et al. \&quot;Deterministic edge-preserving regularization\n&quot;</span>
    <span class="s0">&quot;       in computed imaging\&quot;. 1997. IEEE Trans. Image Processing.\n&quot;</span>
    <span class="s0">&quot;       6 (2): 298 - 311.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Import all necessary modules.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import pseudo_huber, huber\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the function for ``delta=1`` at ``r=2``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; pseudo_huber(1., 2.)\n&quot;</span>
    <span class="s0">&quot;1.2360679774997898\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the function at ``r=2`` for different `delta` by providing\n&quot;</span>
    <span class="s0">&quot;a list or NumPy array for `delta`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; pseudo_huber([1., 2., 4.], 3.)\n&quot;</span>
    <span class="s0">&quot;array([2.16227766, 3.21110255, 4.        ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the function for ``delta=1`` at several points by providing\n&quot;</span>
    <span class="s0">&quot;a list or NumPy array for `r`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; pseudo_huber(2., np.array([1., 1.5, 3., 4.]))\n&quot;</span>
    <span class="s0">&quot;array([0.47213595, 1.        , 3.21110255, 4.94427191])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function can be calculated for different `delta` and `r` by\n&quot;</span>
    <span class="s0">&quot;providing arrays for both with compatible shapes for broadcasting.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; r = np.array([1., 2.5, 8., 10.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; deltas = np.array([[1.], [5.], [9.]])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; print(r.shape, deltas.shape)\n&quot;</span>
    <span class="s0">&quot;(4,) (3, 1)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; pseudo_huber(deltas, r)\n&quot;</span>
    <span class="s0">&quot;array([[ 0.41421356,  1.6925824 ,  7.06225775,  9.04987562],\n&quot;</span>
    <span class="s0">&quot;       [ 0.49509757,  2.95084972, 22.16990566, 30.90169944],\n&quot;</span>
    <span class="s0">&quot;       [ 0.49846624,  3.06693762, 27.37435121, 40.08261642]])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function for different `delta`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-4, 4, 500)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; deltas = [1, 2, 3]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; linestyles = [\&quot;dashed\&quot;, \&quot;dotted\&quot;, \&quot;dashdot\&quot;]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; combined_plot_parameters = list(zip(deltas, linestyles))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for delta, style in combined_plot_parameters:\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, pseudo_huber(delta, x), label=f\&quot;$\\delta={delta}$\&quot;,\n&quot;</span>
    <span class="s0">&quot;...             ls=style)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend(loc=\&quot;upper center\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel(\&quot;$x$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(\&quot;Pseudo-Huber loss function $h_{\\delta}(x)$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlim(-4, 4)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_ylim(0, 8)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Finally, illustrate the difference between `huber` and `pseudo_huber` by\n&quot;</span>
    <span class="s0">&quot;plotting them and their gradients with respect to `r`. The plot shows\n&quot;</span>
    <span class="s0">&quot;that `pseudo_huber` is continuously differentiable while `huber` is not\n&quot;</span>
    <span class="s0">&quot;at the points :math:`\\pm\\delta`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; def huber_grad(delta, x):\n&quot;</span>
    <span class="s0">&quot;...     grad = np.copy(x)\n&quot;</span>
    <span class="s0">&quot;...     linear_area = np.argwhere(np.abs(x) &gt; delta)\n&quot;</span>
    <span class="s0">&quot;...     grad[linear_area]=delta*np.sign(x[linear_area])\n&quot;</span>
    <span class="s0">&quot;...     return grad\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; def pseudo_huber_grad(delta, x):\n&quot;</span>
    <span class="s0">&quot;...     return x* (1+(x/delta)**2)**(-0.5)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x=np.linspace(-3, 3, 500)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; delta = 1.\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots(figsize=(7, 7))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, huber(delta, x), label=\&quot;Huber\&quot;, ls=\&quot;dashed\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, huber_grad(delta, x), label=\&quot;Huber Gradient\&quot;, ls=\&quot;dashdot\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, pseudo_huber(delta, x), label=\&quot;Pseudo-Huber\&quot;, ls=\&quot;dotted\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, pseudo_huber_grad(delta, x), label=\&quot;Pseudo-Huber Gradient\&quot;,\n&quot;</span>
    <span class="s0">&quot;...         ls=\&quot;solid\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend(loc=\&quot;upper center\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_pseudo_huber_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_pseudo_huber_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_pseudo_huber_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pseudo_huber_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pseudo_huber_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_pseudo_huber_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pseudo_huber_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pseudo_huber_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_pseudo_huber_ptr[2*0] = &lt;void*&gt;_func_pseudo_huber</span>
<span class="s0">ufunc_pseudo_huber_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pseudo_huber&quot;)</span>
<span class="s0">ufunc_pseudo_huber_ptr[2*1] = &lt;void*&gt;_func_pseudo_huber</span>
<span class="s0">ufunc_pseudo_huber_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;pseudo_huber&quot;)</span>
<span class="s0">ufunc_pseudo_huber_data[0] = &amp;ufunc_pseudo_huber_ptr[2*0]</span>
<span class="s0">ufunc_pseudo_huber_data[1] = &amp;ufunc_pseudo_huber_ptr[2*1]</span>
<span class="s0">pseudo_huber = np.PyUFunc_FromFuncAndData(ufunc_pseudo_huber_loops, ufunc_pseudo_huber_data, ufunc_pseudo_huber_types, 2, 2, 1, 0, &quot;pseudo_huber&quot;, ufunc_pseudo_huber_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_psi_loops[4]</span>
<span class="s0">cdef void *ufunc_psi_ptr[8]</span>
<span class="s0">cdef void *ufunc_psi_data[4]</span>
<span class="s0">cdef char ufunc_psi_types[8]</span>
<span class="s0">cdef char *ufunc_psi_doc = (</span>
    <span class="s0">&quot;psi(z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The digamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The logarithmic derivative of the gamma function evaluated at ``z``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;z : array_like\n&quot;</span>
    <span class="s0">&quot;    Real or complex argument.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Array for the computed values of ``psi``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;digamma : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Computed values of ``psi``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;For large values not close to the negative real axis, ``psi`` is\n&quot;</span>
    <span class="s0">&quot;computed using the asymptotic series (5.11.2) from [1]_. For small\n&quot;</span>
    <span class="s0">&quot;arguments not close to the negative real axis, the recurrence\n&quot;</span>
    <span class="s0">&quot;relation (5.5.2) from [1]_ is used until the argument is large\n&quot;</span>
    <span class="s0">&quot;enough to use the asymptotic series. For values close to the\n&quot;</span>
    <span class="s0">&quot;negative real axis, the reflection formula (5.5.4) from [1]_ is\n&quot;</span>
    <span class="s0">&quot;used first. Note that ``psi`` has a family of zeros on the\n&quot;</span>
    <span class="s0">&quot;negative real axis which occur between the poles at nonpositive\n&quot;</span>
    <span class="s0">&quot;integers. Around the zeros the reflection formula suffers from\n&quot;</span>
    <span class="s0">&quot;cancellation and the implementation loses precision. The sole\n&quot;</span>
    <span class="s0">&quot;positive zero and the first negative zero, however, are handled\n&quot;</span>
    <span class="s0">&quot;separately by precomputing series expansions using [2]_, so the\n&quot;</span>
    <span class="s0">&quot;function should maintain full accuracy around the origin.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] NIST Digital Library of Mathematical Functions\n&quot;</span>
    <span class="s0">&quot;       https://dlmf.nist.gov/5\n&quot;</span>
    <span class="s0">&quot;.. [2] Fredrik Johansson and others.\n&quot;</span>
    <span class="s0">&quot;       \&quot;mpmath: a Python library for arbitrary-precision floating-point arithmetic\&quot;\n&quot;</span>
    <span class="s0">&quot;       (Version 0.19) http://mpmath.org/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import psi\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z = 3 + 4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; psi(z)\n&quot;</span>
    <span class="s0">&quot;(1.55035981733341+1.0105022091860445j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Verify psi(z) = psi(z + 1) - 1/z:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; psi(z + 1) - 1/z\n&quot;</span>
    <span class="s0">&quot;(1.55035981733341+1.0105022091860445j)&quot;)</span>
<span class="s0">ufunc_psi_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_psi_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_psi_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_F_F</span>
<span class="s0">ufunc_psi_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_D_D</span>
<span class="s0">ufunc_psi_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_psi_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_psi_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_psi_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_psi_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_psi_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_psi_types[6] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_psi_types[7] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_psi_ptr[2*0] = &lt;void*&gt;_func_digamma</span>
<span class="s0">ufunc_psi_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;psi&quot;)</span>
<span class="s0">ufunc_psi_ptr[2*1] = &lt;void*&gt;_func_digamma</span>
<span class="s0">ufunc_psi_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;psi&quot;)</span>
<span class="s0">ufunc_psi_ptr[2*2] = &lt;void*&gt;_func_cdigamma</span>
<span class="s0">ufunc_psi_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;psi&quot;)</span>
<span class="s0">ufunc_psi_ptr[2*3] = &lt;void*&gt;_func_cdigamma</span>
<span class="s0">ufunc_psi_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;psi&quot;)</span>
<span class="s0">ufunc_psi_data[0] = &amp;ufunc_psi_ptr[2*0]</span>
<span class="s0">ufunc_psi_data[1] = &amp;ufunc_psi_ptr[2*1]</span>
<span class="s0">ufunc_psi_data[2] = &amp;ufunc_psi_ptr[2*2]</span>
<span class="s0">ufunc_psi_data[3] = &amp;ufunc_psi_ptr[2*3]</span>
<span class="s0">psi = np.PyUFunc_FromFuncAndData(ufunc_psi_loops, ufunc_psi_data, ufunc_psi_types, 4, 1, 1, 0, &quot;psi&quot;, ufunc_psi_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_radian_loops[2]</span>
<span class="s0">cdef void *ufunc_radian_ptr[4]</span>
<span class="s0">cdef void *ufunc_radian_data[2]</span>
<span class="s0">cdef char ufunc_radian_types[8]</span>
<span class="s0">cdef char *ufunc_radian_doc = (</span>
    <span class="s0">&quot;radian(d, m, s, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Convert from degrees to radians.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the angle given in (d)egrees, (m)inutes, and (s)econds in\n&quot;</span>
    <span class="s0">&quot;radians.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;d : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees, can be real-valued.\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Minutes, can be real-valued.\n&quot;</span>
    <span class="s0">&quot;s : array_like\n&quot;</span>
    <span class="s0">&quot;    Seconds, can be real-valued.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the inputs in radians.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;There are many ways to specify an angle.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.radian(90, 0, 0)\n&quot;</span>
    <span class="s0">&quot;1.5707963267948966\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.radian(0, 60 * 90, 0)\n&quot;</span>
    <span class="s0">&quot;1.5707963267948966\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.radian(0, 0, 60**2 * 90)\n&quot;</span>
    <span class="s0">&quot;1.5707963267948966\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The inputs can be real-valued.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.radian(1.5, 0, 0)\n&quot;</span>
    <span class="s0">&quot;0.02617993877991494\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.radian(1, 30, 0)\n&quot;</span>
    <span class="s0">&quot;0.02617993877991494&quot;)</span>
<span class="s0">ufunc_radian_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_radian_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_radian_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_radian_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_radian_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_radian_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_radian_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_radian_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_radian_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_radian_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_radian_ptr[2*0] = &lt;void*&gt;_func_radian</span>
<span class="s0">ufunc_radian_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;radian&quot;)</span>
<span class="s0">ufunc_radian_ptr[2*1] = &lt;void*&gt;_func_radian</span>
<span class="s0">ufunc_radian_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;radian&quot;)</span>
<span class="s0">ufunc_radian_data[0] = &amp;ufunc_radian_ptr[2*0]</span>
<span class="s0">ufunc_radian_data[1] = &amp;ufunc_radian_ptr[2*1]</span>
<span class="s0">radian = np.PyUFunc_FromFuncAndData(ufunc_radian_loops, ufunc_radian_data, ufunc_radian_types, 2, 3, 1, 0, &quot;radian&quot;, ufunc_radian_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_rel_entr_loops[2]</span>
<span class="s0">cdef void *ufunc_rel_entr_ptr[4]</span>
<span class="s0">cdef void *ufunc_rel_entr_data[2]</span>
<span class="s0">cdef char ufunc_rel_entr_types[6]</span>
<span class="s0">cdef char *ufunc_rel_entr_doc = (</span>
    <span class="s0">&quot;rel_entr(x, y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Elementwise function for computing relative entropy.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    \\mathrm{rel\\_entr}(x, y) =\n&quot;</span>
    <span class="s0">&quot;        \\begin{cases}\n&quot;</span>
    <span class="s0">&quot;            x \\log(x / y) &amp; x &gt; 0, y &gt; 0 \\\\\n&quot;</span>
    <span class="s0">&quot;            0 &amp; x = 0, y \\ge 0 \\\\\n&quot;</span>
    <span class="s0">&quot;            \\infty &amp; \\text{otherwise}\n&quot;</span>
    <span class="s0">&quot;        \\end{cases}\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x, y : array_like\n&quot;</span>
    <span class="s0">&quot;    Input arrays\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Relative entropy of the inputs\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;entr, kl_div, scipy.stats.entropy\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 0.15.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is jointly convex in x and y.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The origin of this function is in convex programming; see\n&quot;</span>
    <span class="s0">&quot;[1]_. Given two discrete probability distributions :math:`p_1,\n&quot;</span>
    <span class="s0">&quot;\\ldots, p_n` and :math:`q_1, \\ldots, q_n`, the definition of relative\n&quot;</span>
    <span class="s0">&quot;entropy in the context of *information theory* is\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    \\sum_{i = 1}^n \\mathrm{rel\\_entr}(p_i, q_i).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;To compute the latter quantity, use `scipy.stats.entropy`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See [2]_ for details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Boyd, Stephen and Lieven Vandenberghe. *Convex optimization*.\n&quot;</span>
    <span class="s0">&quot;       Cambridge University Press, 2004.\n&quot;</span>
    <span class="s0">&quot;       :doi:`https://doi.org/10.1017/CBO9780511804441`\n&quot;</span>
    <span class="s0">&quot;.. [2] Kullback-Leibler divergence,\n&quot;</span>
    <span class="s0">&quot;       https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence&quot;)</span>
<span class="s0">ufunc_rel_entr_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_rel_entr_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_rel_entr_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_rel_entr_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_rel_entr_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_rel_entr_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_rel_entr_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_rel_entr_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_rel_entr_ptr[2*0] = &lt;void*&gt;_func_rel_entr</span>
<span class="s0">ufunc_rel_entr_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;rel_entr&quot;)</span>
<span class="s0">ufunc_rel_entr_ptr[2*1] = &lt;void*&gt;_func_rel_entr</span>
<span class="s0">ufunc_rel_entr_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;rel_entr&quot;)</span>
<span class="s0">ufunc_rel_entr_data[0] = &amp;ufunc_rel_entr_ptr[2*0]</span>
<span class="s0">ufunc_rel_entr_data[1] = &amp;ufunc_rel_entr_ptr[2*1]</span>
<span class="s0">rel_entr = np.PyUFunc_FromFuncAndData(ufunc_rel_entr_loops, ufunc_rel_entr_data, ufunc_rel_entr_types, 2, 2, 1, 0, &quot;rel_entr&quot;, ufunc_rel_entr_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_rgamma_loops[4]</span>
<span class="s0">cdef void *ufunc_rgamma_ptr[8]</span>
<span class="s0">cdef void *ufunc_rgamma_data[4]</span>
<span class="s0">cdef char ufunc_rgamma_types[8]</span>
<span class="s0">cdef char *ufunc_rgamma_doc = (</span>
    <span class="s0">&quot;rgamma(z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Reciprocal of the gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined as :math:`1 / \\Gamma(z)`, where :math:`\\Gamma` is the\n&quot;</span>
    <span class="s0">&quot;gamma function. For more on the gamma function see `gamma`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;z : array_like\n&quot;</span>
    <span class="s0">&quot;    Real or complex valued input\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The gamma function has no zeros and has simple poles at\n&quot;</span>
    <span class="s0">&quot;nonpositive integers, so `rgamma` is an entire function with zeros\n&quot;</span>
    <span class="s0">&quot;at the nonpositive integers. See the discussion in [dlmf]_ for\n&quot;</span>
    <span class="s0">&quot;more details.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;gamma, gammaln, loggamma\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [dlmf] Nist, Digital Library of Mathematical functions,\n&quot;</span>
    <span class="s0">&quot;    https://dlmf.nist.gov/5.2#i\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is the reciprocal of the gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.rgamma([1, 2, 3, 4])\n&quot;</span>
    <span class="s0">&quot;array([1.        , 1.        , 0.5       , 0.16666667])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; 1 / sc.gamma([1, 2, 3, 4])\n&quot;</span>
    <span class="s0">&quot;array([1.        , 1.        , 0.5       , 0.16666667])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is zero at nonpositive integers.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.rgamma([0, -1, -2, -3])\n&quot;</span>
    <span class="s0">&quot;array([0., 0., 0., 0.])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It rapidly underflows to zero along the positive real axis.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.rgamma([10, 100, 179])\n&quot;</span>
    <span class="s0">&quot;array([2.75573192e-006, 1.07151029e-156, 0.00000000e+000])&quot;)</span>
<span class="s0">ufunc_rgamma_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_rgamma_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_rgamma_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_F_F</span>
<span class="s0">ufunc_rgamma_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_D_D</span>
<span class="s0">ufunc_rgamma_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_rgamma_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_rgamma_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_rgamma_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_rgamma_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_rgamma_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_rgamma_types[6] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_rgamma_types[7] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_rgamma_ptr[2*0] = &lt;void*&gt;_func_rgamma</span>
<span class="s0">ufunc_rgamma_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;rgamma&quot;)</span>
<span class="s0">ufunc_rgamma_ptr[2*1] = &lt;void*&gt;_func_rgamma</span>
<span class="s0">ufunc_rgamma_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;rgamma&quot;)</span>
<span class="s0">ufunc_rgamma_ptr[2*2] = &lt;void*&gt;_func_crgamma</span>
<span class="s0">ufunc_rgamma_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;rgamma&quot;)</span>
<span class="s0">ufunc_rgamma_ptr[2*3] = &lt;void*&gt;_func_crgamma</span>
<span class="s0">ufunc_rgamma_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;rgamma&quot;)</span>
<span class="s0">ufunc_rgamma_data[0] = &amp;ufunc_rgamma_ptr[2*0]</span>
<span class="s0">ufunc_rgamma_data[1] = &amp;ufunc_rgamma_ptr[2*1]</span>
<span class="s0">ufunc_rgamma_data[2] = &amp;ufunc_rgamma_ptr[2*2]</span>
<span class="s0">ufunc_rgamma_data[3] = &amp;ufunc_rgamma_ptr[2*3]</span>
<span class="s0">rgamma = np.PyUFunc_FromFuncAndData(ufunc_rgamma_loops, ufunc_rgamma_data, ufunc_rgamma_types, 4, 1, 1, 0, &quot;rgamma&quot;, ufunc_rgamma_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_round_loops[2]</span>
<span class="s0">cdef void *ufunc_round_ptr[4]</span>
<span class="s0">cdef void *ufunc_round_data[2]</span>
<span class="s0">cdef char ufunc_round_types[4]</span>
<span class="s0">cdef char *ufunc_round_doc = (</span>
    <span class="s0">&quot;round(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Round to the nearest integer.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the nearest integer to `x`.  If `x` ends in 0.5 exactly,\n&quot;</span>
    <span class="s0">&quot;the nearest even integer is chosen.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real valued input.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The nearest integers to the elements of `x`. The result is of\n&quot;</span>
    <span class="s0">&quot;    floating type, not integer type.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It rounds to even.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.round([0.5, 1.5])\n&quot;</span>
    <span class="s0">&quot;array([0., 2.])&quot;)</span>
<span class="s0">ufunc_round_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_round_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_round_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_round_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_round_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_round_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_round_ptr[2*0] = &lt;void*&gt;_func_round</span>
<span class="s0">ufunc_round_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;round&quot;)</span>
<span class="s0">ufunc_round_ptr[2*1] = &lt;void*&gt;_func_round</span>
<span class="s0">ufunc_round_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;round&quot;)</span>
<span class="s0">ufunc_round_data[0] = &amp;ufunc_round_ptr[2*0]</span>
<span class="s0">ufunc_round_data[1] = &amp;ufunc_round_ptr[2*1]</span>
<span class="s0">round = np.PyUFunc_FromFuncAndData(ufunc_round_loops, ufunc_round_data, ufunc_round_types, 2, 1, 1, 0, &quot;round&quot;, ufunc_round_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_shichi_loops[4]</span>
<span class="s0">cdef void *ufunc_shichi_ptr[8]</span>
<span class="s0">cdef void *ufunc_shichi_data[4]</span>
<span class="s0">cdef char ufunc_shichi_types[12]</span>
<span class="s0">cdef char *ufunc_shichi_doc = (</span>
    <span class="s0">&quot;shichi(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Hyperbolic sine and cosine integrals.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The hyperbolic sine integral is\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;  \\int_0^x \\frac{\\sinh{t}}{t}dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;and the hyperbolic cosine integral is\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;  \\gamma + \\log(x) + \\int_0^x \\frac{\\cosh{t} - 1}{t} dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`\\gamma` is Euler's constant and :math:`\\log` is the\n&quot;</span>
    <span class="s0">&quot;principal branch of the logarithm [1]_.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real or complex points at which to compute the hyperbolic sine\n&quot;</span>
    <span class="s0">&quot;    and cosine integrals.\n&quot;</span>
    <span class="s0">&quot;out : tuple of ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output arrays for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;si : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Hyperbolic sine integral at ``x``\n&quot;</span>
    <span class="s0">&quot;ci : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Hyperbolic cosine integral at ``x``\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;sici : Sine and cosine integrals.\n&quot;</span>
    <span class="s0">&quot;exp1 : Exponential integral E1.\n&quot;</span>
    <span class="s0">&quot;expi : Exponential integral Ei.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;For real arguments with ``x &lt; 0``, ``chi`` is the real part of the\n&quot;</span>
    <span class="s0">&quot;hyperbolic cosine integral. For such points ``chi(x)`` and ``chi(x\n&quot;</span>
    <span class="s0">&quot;+ 0j)`` differ by a factor of ``1j*pi``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For real arguments the function is computed by calling Cephes'\n&quot;</span>
    <span class="s0">&quot;[2]_ *shichi* routine. For complex arguments the algorithm is based\n&quot;</span>
    <span class="s0">&quot;on Mpmath's [3]_ *shi* and *chi* routines.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;       Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;       Graphs, and Mathematical Tables. New York: Dover, 1972.\n&quot;</span>
    <span class="s0">&quot;       (See Section 5.2.)\n&quot;</span>
    <span class="s0">&quot;.. [2] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;.. [3] Fredrik Johansson and others.\n&quot;</span>
    <span class="s0">&quot;       \&quot;mpmath: a Python library for arbitrary-precision floating-point\n&quot;</span>
    <span class="s0">&quot;       arithmetic\&quot; (Version 0.19) http://mpmath.org/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import shichi, sici\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;`shichi` accepts real or complex input:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; shichi(0.5)\n&quot;</span>
    <span class="s0">&quot;(0.5069967498196671, -0.05277684495649357)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; shichi(0.5 + 2.5j)\n&quot;</span>
    <span class="s0">&quot;((0.11772029666668238+1.831091777729851j),\n&quot;</span>
    <span class="s0">&quot; (0.29912435887648825+1.7395351121166562j))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The hyperbolic sine and cosine integrals Shi(z) and Chi(z) are\n&quot;</span>
    <span class="s0">&quot;related to the sine and cosine integrals Si(z) and Ci(z) by\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;* Shi(z) = -i*Si(i*z)\n&quot;</span>
    <span class="s0">&quot;* Chi(z) = Ci(-i*z) + i*pi/2\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z = 0.25 + 5j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; shi, chi = shichi(z)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; shi, -1j*sici(1j*z)[0]            # Should be the same.\n&quot;</span>
    <span class="s0">&quot;((-0.04834719325101729+1.5469354086921228j),\n&quot;</span>
    <span class="s0">&quot; (-0.04834719325101729+1.5469354086921228j))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; chi, sici(-1j*z)[1] + 1j*np.pi/2  # Should be the same.\n&quot;</span>
    <span class="s0">&quot;((-0.19568708973868087+1.556276312103824j),\n&quot;</span>
    <span class="s0">&quot; (-0.19568708973868087+1.556276312103824j))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the functions evaluated on the real axis:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; xp = np.geomspace(1e-8, 4.0, 250)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.concatenate((-xp[::-1], xp))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; shi, chi = shichi(x)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, shi, label='Shi(x)')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, chi, '--', label='Chi(x)')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel('x')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title('Hyperbolic Sine and Cosine Integrals')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend(shadow=True, framealpha=1, loc='lower right')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.grid(True)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_shichi_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_d_dd_As_f_ff</span>
<span class="s0">ufunc_shichi_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_i_d_dd_As_d_dd</span>
<span class="s0">ufunc_shichi_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_i_D_DD_As_F_FF</span>
<span class="s0">ufunc_shichi_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_i_D_DD_As_D_DD</span>
<span class="s0">ufunc_shichi_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_shichi_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_shichi_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_shichi_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_shichi_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_shichi_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_shichi_types[6] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_shichi_types[7] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_shichi_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_shichi_types[9] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_shichi_types[10] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_shichi_types[11] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_shichi_ptr[2*0] = &lt;void*&gt;_func_shichi</span>
<span class="s0">ufunc_shichi_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;shichi&quot;)</span>
<span class="s0">ufunc_shichi_ptr[2*1] = &lt;void*&gt;_func_shichi</span>
<span class="s0">ufunc_shichi_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;shichi&quot;)</span>
<span class="s0">ufunc_shichi_ptr[2*2] = &lt;void*&gt;_func_cshichi</span>
<span class="s0">ufunc_shichi_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;shichi&quot;)</span>
<span class="s0">ufunc_shichi_ptr[2*3] = &lt;void*&gt;_func_cshichi</span>
<span class="s0">ufunc_shichi_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;shichi&quot;)</span>
<span class="s0">ufunc_shichi_data[0] = &amp;ufunc_shichi_ptr[2*0]</span>
<span class="s0">ufunc_shichi_data[1] = &amp;ufunc_shichi_ptr[2*1]</span>
<span class="s0">ufunc_shichi_data[2] = &amp;ufunc_shichi_ptr[2*2]</span>
<span class="s0">ufunc_shichi_data[3] = &amp;ufunc_shichi_ptr[2*3]</span>
<span class="s0">shichi = np.PyUFunc_FromFuncAndData(ufunc_shichi_loops, ufunc_shichi_data, ufunc_shichi_types, 4, 1, 2, 0, &quot;shichi&quot;, ufunc_shichi_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_sici_loops[4]</span>
<span class="s0">cdef void *ufunc_sici_ptr[8]</span>
<span class="s0">cdef void *ufunc_sici_data[4]</span>
<span class="s0">cdef char ufunc_sici_types[12]</span>
<span class="s0">cdef char *ufunc_sici_doc = (</span>
    <span class="s0">&quot;sici(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Sine and cosine integrals.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The sine integral is\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;  \\int_0^x \\frac{\\sin{t}}{t}dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;and the cosine integral is\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;  \\gamma + \\log(x) + \\int_0^x \\frac{\\cos{t} - 1}{t}dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`\\gamma` is Euler's constant and :math:`\\log` is the\n&quot;</span>
    <span class="s0">&quot;principal branch of the logarithm [1]_.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real or complex points at which to compute the sine and cosine\n&quot;</span>
    <span class="s0">&quot;    integrals.\n&quot;</span>
    <span class="s0">&quot;out : tuple of ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output arrays for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;si : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Sine integral at ``x``\n&quot;</span>
    <span class="s0">&quot;ci : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Cosine integral at ``x``\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;shichi : Hyperbolic sine and cosine integrals.\n&quot;</span>
    <span class="s0">&quot;exp1 : Exponential integral E1.\n&quot;</span>
    <span class="s0">&quot;expi : Exponential integral Ei.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;For real arguments with ``x &lt; 0``, ``ci`` is the real part of the\n&quot;</span>
    <span class="s0">&quot;cosine integral. For such points ``ci(x)`` and ``ci(x + 0j)``\n&quot;</span>
    <span class="s0">&quot;differ by a factor of ``1j*pi``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For real arguments the function is computed by calling Cephes'\n&quot;</span>
    <span class="s0">&quot;[2]_ *sici* routine. For complex arguments the algorithm is based\n&quot;</span>
    <span class="s0">&quot;on Mpmath's [3]_ *si* and *ci* routines.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Milton Abramowitz and Irene A. Stegun, eds.\n&quot;</span>
    <span class="s0">&quot;       Handbook of Mathematical Functions with Formulas,\n&quot;</span>
    <span class="s0">&quot;       Graphs, and Mathematical Tables. New York: Dover, 1972.\n&quot;</span>
    <span class="s0">&quot;       (See Section 5.2.)\n&quot;</span>
    <span class="s0">&quot;.. [2] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;.. [3] Fredrik Johansson and others.\n&quot;</span>
    <span class="s0">&quot;       \&quot;mpmath: a Python library for arbitrary-precision floating-point\n&quot;</span>
    <span class="s0">&quot;       arithmetic\&quot; (Version 0.19) http://mpmath.org/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import sici, exp1\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;`sici` accepts real or complex input:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sici(2.5)\n&quot;</span>
    <span class="s0">&quot;(1.7785201734438267, 0.2858711963653835)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sici(2.5 + 3j)\n&quot;</span>
    <span class="s0">&quot;((4.505735874563953+0.06863305018999577j),\n&quot;</span>
    <span class="s0">&quot;(0.0793644206906966-2.935510262937543j))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For z in the right half plane, the sine and cosine integrals are\n&quot;</span>
    <span class="s0">&quot;related to the exponential integral E1 (implemented in SciPy as\n&quot;</span>
    <span class="s0">&quot;`scipy.special.exp1`) by\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;* Si(z) = (E1(i*z) - E1(-i*z))/2i + pi/2\n&quot;</span>
    <span class="s0">&quot;* Ci(z) = -(E1(i*z) + E1(-i*z))/2\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See [1]_ (equations 5.2.21 and 5.2.23).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;We can verify these relations:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z = 2 - 3j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sici(z)\n&quot;</span>
    <span class="s0">&quot;((4.54751388956229-1.3991965806460565j),\n&quot;</span>
    <span class="s0">&quot;(1.408292501520851+2.9836177420296055j))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; (exp1(1j*z) - exp1(-1j*z))/2j + np.pi/2  # Same as sine integral\n&quot;</span>
    <span class="s0">&quot;(4.54751388956229-1.3991965806460565j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; -(exp1(1j*z) + exp1(-1j*z))/2            # Same as cosine integral\n&quot;</span>
    <span class="s0">&quot;(1.408292501520851+2.9836177420296055j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the functions evaluated on the real axis; the dotted horizontal\n&quot;</span>
    <span class="s0">&quot;lines are at pi/2 and -pi/2:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-16, 16, 150)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; si, ci = sici(x)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, si, label='Si(x)')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, ci, '--', label='Ci(x)')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend(shadow=True, framealpha=1, loc='upper left')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel('x')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title('Sine and Cosine Integrals')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.axhline(np.pi/2, linestyle=':', alpha=0.5, color='k')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.axhline(-np.pi/2, linestyle=':', alpha=0.5, color='k')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.grid(True)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_sici_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_i_d_dd_As_f_ff</span>
<span class="s0">ufunc_sici_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_i_d_dd_As_d_dd</span>
<span class="s0">ufunc_sici_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_i_D_DD_As_F_FF</span>
<span class="s0">ufunc_sici_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_i_D_DD_As_D_DD</span>
<span class="s0">ufunc_sici_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_sici_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_sici_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_sici_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_sici_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_sici_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_sici_types[6] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_sici_types[7] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_sici_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_sici_types[9] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_sici_types[10] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_sici_types[11] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_sici_ptr[2*0] = &lt;void*&gt;_func_sici</span>
<span class="s0">ufunc_sici_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;sici&quot;)</span>
<span class="s0">ufunc_sici_ptr[2*1] = &lt;void*&gt;_func_sici</span>
<span class="s0">ufunc_sici_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;sici&quot;)</span>
<span class="s0">ufunc_sici_ptr[2*2] = &lt;void*&gt;_func_csici</span>
<span class="s0">ufunc_sici_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;sici&quot;)</span>
<span class="s0">ufunc_sici_ptr[2*3] = &lt;void*&gt;_func_csici</span>
<span class="s0">ufunc_sici_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;sici&quot;)</span>
<span class="s0">ufunc_sici_data[0] = &amp;ufunc_sici_ptr[2*0]</span>
<span class="s0">ufunc_sici_data[1] = &amp;ufunc_sici_ptr[2*1]</span>
<span class="s0">ufunc_sici_data[2] = &amp;ufunc_sici_ptr[2*2]</span>
<span class="s0">ufunc_sici_data[3] = &amp;ufunc_sici_ptr[2*3]</span>
<span class="s0">sici = np.PyUFunc_FromFuncAndData(ufunc_sici_loops, ufunc_sici_data, ufunc_sici_types, 4, 1, 2, 0, &quot;sici&quot;, ufunc_sici_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_sindg_loops[2]</span>
<span class="s0">cdef void *ufunc_sindg_ptr[4]</span>
<span class="s0">cdef void *ufunc_sindg_data[2]</span>
<span class="s0">cdef char ufunc_sindg_types[4]</span>
<span class="s0">cdef char *ufunc_sindg_doc = (</span>
    <span class="s0">&quot;sindg(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Sine of the angle `x` given in degrees.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Angle, given in degrees.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Sine at the input.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;cosdg, tandg, cotdg\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is more accurate than using sine directly.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 180 * np.arange(3)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.sindg(x)\n&quot;</span>
    <span class="s0">&quot;array([ 0., -0.,  0.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.sin(x * np.pi / 180)\n&quot;</span>
    <span class="s0">&quot;array([ 0.0000000e+00,  1.2246468e-16, -2.4492936e-16])&quot;)</span>
<span class="s0">ufunc_sindg_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_sindg_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_sindg_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_sindg_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_sindg_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_sindg_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_sindg_ptr[2*0] = &lt;void*&gt;_func_sindg</span>
<span class="s0">ufunc_sindg_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;sindg&quot;)</span>
<span class="s0">ufunc_sindg_ptr[2*1] = &lt;void*&gt;_func_sindg</span>
<span class="s0">ufunc_sindg_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;sindg&quot;)</span>
<span class="s0">ufunc_sindg_data[0] = &amp;ufunc_sindg_ptr[2*0]</span>
<span class="s0">ufunc_sindg_data[1] = &amp;ufunc_sindg_ptr[2*1]</span>
<span class="s0">sindg = np.PyUFunc_FromFuncAndData(ufunc_sindg_loops, ufunc_sindg_data, ufunc_sindg_types, 2, 1, 1, 0, &quot;sindg&quot;, ufunc_sindg_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_smirnov_loops[3]</span>
<span class="s0">cdef void *ufunc_smirnov_ptr[6]</span>
<span class="s0">cdef void *ufunc_smirnov_data[3]</span>
<span class="s0">cdef char ufunc_smirnov_types[9]</span>
<span class="s0">cdef char *ufunc_smirnov_doc = (</span>
    <span class="s0">&quot;smirnov(n, d, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Kolmogorov-Smirnov complementary cumulative distribution function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the exact Kolmogorov-Smirnov complementary cumulative\n&quot;</span>
    <span class="s0">&quot;distribution function,(aka the Survival Function) of Dn+ (or Dn-)\n&quot;</span>
    <span class="s0">&quot;for a one-sided test of equality between an empirical and a\n&quot;</span>
    <span class="s0">&quot;theoretical distribution. It is equal to the probability that the\n&quot;</span>
    <span class="s0">&quot;maximum difference between a theoretical distribution and an empirical\n&quot;</span>
    <span class="s0">&quot;one based on `n` samples is greater than d.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : int\n&quot;</span>
    <span class="s0">&quot;  Number of samples\n&quot;</span>
    <span class="s0">&quot;d : float array_like\n&quot;</span>
    <span class="s0">&quot;  Deviation between the Empirical CDF (ECDF) and the target CDF.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The value(s) of smirnov(n, d), Prob(Dn+ &gt;= d) (Also Prob(Dn- &gt;= d))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;smirnovi : The Inverse Survival Function for the distribution\n&quot;</span>
    <span class="s0">&quot;scipy.stats.ksone : Provides the functionality as a continuous distribution\n&quot;</span>
    <span class="s0">&quot;kolmogorov, kolmogi : Functions for the two-sided distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;`smirnov` is used by `stats.kstest` in the application of the\n&quot;</span>
    <span class="s0">&quot;Kolmogorov-Smirnov Goodness of Fit test. For historial reasons this\n&quot;</span>
    <span class="s0">&quot;function is exposed in `scpy.special`, but the recommended way to achieve\n&quot;</span>
    <span class="s0">&quot;the most accurate CDF/SF/PDF/PPF/ISF computations is to use the\n&quot;</span>
    <span class="s0">&quot;`stats.ksone` distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import smirnov\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.stats import norm\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Show the probability of a gap at least as big as 0, 0.5 and 1.0 for a\n&quot;</span>
    <span class="s0">&quot;sample of size 5.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; smirnov(5, [0, 0.5, 1.0])\n&quot;</span>
    <span class="s0">&quot;array([ 1.   ,  0.056,  0.   ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compare a sample of size 5 against N(0, 1), the standard normal\n&quot;</span>
    <span class="s0">&quot;distribution with mean 0 and standard deviation 1.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;`x` is the sample.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.array([-1.392, -0.135, 0.114, 0.190, 1.82])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; target = norm(0, 1)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdfs = target.cdf(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdfs\n&quot;</span>
    <span class="s0">&quot;array([0.0819612 , 0.44630594, 0.5453811 , 0.57534543, 0.9656205 ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Construct the empirical CDF and the K-S statistics (Dn+, Dn-, Dn).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; n = len(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ecdfs = np.arange(n+1, dtype=float)/n\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cols = np.column_stack([x, ecdfs[1:], cdfs, cdfs - ecdfs[:n],\n&quot;</span>
    <span class="s0">&quot;...                        ecdfs[1:] - cdfs])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; with np.printoptions(precision=3):\n&quot;</span>
    <span class="s0">&quot;...    print(cols)\n&quot;</span>
    <span class="s0">&quot;[[-1.392  0.2    0.082  0.082  0.118]\n&quot;</span>
    <span class="s0">&quot; [-0.135  0.4    0.446  0.246 -0.046]\n&quot;</span>
    <span class="s0">&quot; [ 0.114  0.6    0.545  0.145  0.055]\n&quot;</span>
    <span class="s0">&quot; [ 0.19   0.8    0.575 -0.025  0.225]\n&quot;</span>
    <span class="s0">&quot; [ 1.82   1.     0.966  0.166  0.034]]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gaps = cols[:, -2:]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; Dnpm = np.max(gaps, axis=0)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; print(f'Dn-={Dnpm[0]:f}, Dn+={Dnpm[1]:f}')\n&quot;</span>
    <span class="s0">&quot;Dn-=0.246306, Dn+=0.224655\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; probs = smirnov(n, Dnpm)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; print(f'For a sample of size {n} drawn from N(0, 1):',\n&quot;</span>
    <span class="s0">&quot;...       f' Smirnov n={n}: Prob(Dn- &gt;= {Dnpm[0]:f}) = {probs[0]:.4f}',\n&quot;</span>
    <span class="s0">&quot;...       f' Smirnov n={n}: Prob(Dn+ &gt;= {Dnpm[1]:f}) = {probs[1]:.4f}',\n&quot;</span>
    <span class="s0">&quot;...       sep='\\n')\n&quot;</span>
    <span class="s0">&quot;For a sample of size 5 drawn from N(0, 1):\n&quot;</span>
    <span class="s0">&quot; Smirnov n=5: Prob(Dn- &gt;= 0.246306) = 0.4711\n&quot;</span>
    <span class="s0">&quot; Smirnov n=5: Prob(Dn+ &gt;= 0.224655) = 0.5245\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the empirical CDF and the standard normal CDF.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.step(np.concatenate(([-2.5], x, [2.5])),\n&quot;</span>
    <span class="s0">&quot;...          np.concatenate((ecdfs, [1])),\n&quot;</span>
    <span class="s0">&quot;...          where='post', label='Empirical CDF')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; xx = np.linspace(-2.5, 2.5, 100)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.plot(xx, target.cdf(xx), '--', label='CDF for N(0, 1)')\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Add vertical lines marking Dn+ and Dn-.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; iminus, iplus = np.argmax(gaps, axis=0)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.vlines([x[iminus]], ecdfs[iminus], cdfs[iminus], color='r',\n&quot;</span>
    <span class="s0">&quot;...            alpha=0.5, lw=4)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.vlines([x[iplus]], cdfs[iplus], ecdfs[iplus+1], color='m',\n&quot;</span>
    <span class="s0">&quot;...            alpha=0.5, lw=4)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.grid(True)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.legend(framealpha=1, shadow=True)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_smirnov_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_id__As_ld_d</span>
<span class="s0">ufunc_smirnov_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_smirnov_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_smirnov_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc_smirnov_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_smirnov_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_smirnov_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_smirnov_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_smirnov_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_smirnov_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_smirnov_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_smirnov_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_smirnov_ptr[2*0] = &lt;void*&gt;_func_smirnov</span>
<span class="s0">ufunc_smirnov_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;smirnov&quot;)</span>
<span class="s0">ufunc_smirnov_ptr[2*1] = &lt;void*&gt;_func_smirnov_unsafe</span>
<span class="s0">ufunc_smirnov_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;smirnov&quot;)</span>
<span class="s0">ufunc_smirnov_ptr[2*2] = &lt;void*&gt;_func_smirnov_unsafe</span>
<span class="s0">ufunc_smirnov_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;smirnov&quot;)</span>
<span class="s0">ufunc_smirnov_data[0] = &amp;ufunc_smirnov_ptr[2*0]</span>
<span class="s0">ufunc_smirnov_data[1] = &amp;ufunc_smirnov_ptr[2*1]</span>
<span class="s0">ufunc_smirnov_data[2] = &amp;ufunc_smirnov_ptr[2*2]</span>
<span class="s0">smirnov = np.PyUFunc_FromFuncAndData(ufunc_smirnov_loops, ufunc_smirnov_data, ufunc_smirnov_types, 3, 2, 1, 0, &quot;smirnov&quot;, ufunc_smirnov_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_smirnovi_loops[3]</span>
<span class="s0">cdef void *ufunc_smirnovi_ptr[6]</span>
<span class="s0">cdef void *ufunc_smirnovi_data[3]</span>
<span class="s0">cdef char ufunc_smirnovi_types[9]</span>
<span class="s0">cdef char *ufunc_smirnovi_doc = (</span>
    <span class="s0">&quot;smirnovi(n, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse to `smirnov`\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns `d` such that ``smirnov(n, d) == p``, the critical value\n&quot;</span>
    <span class="s0">&quot;corresponding to `p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : int\n&quot;</span>
    <span class="s0">&quot;  Number of samples\n&quot;</span>
    <span class="s0">&quot;p : float array_like\n&quot;</span>
    <span class="s0">&quot;    Probability\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The value(s) of smirnovi(n, p), the critical values.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;smirnov : The Survival Function (SF) for the distribution\n&quot;</span>
    <span class="s0">&quot;scipy.stats.ksone : Provides the functionality as a continuous distribution\n&quot;</span>
    <span class="s0">&quot;kolmogorov, kolmogi : Functions for the two-sided distribution\n&quot;</span>
    <span class="s0">&quot;scipy.stats.kstwobign : Two-sided Kolmogorov-Smirnov distribution, large n\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;`smirnov` is used by `stats.kstest` in the application of the\n&quot;</span>
    <span class="s0">&quot;Kolmogorov-Smirnov Goodness of Fit test. For historial reasons this\n&quot;</span>
    <span class="s0">&quot;function is exposed in `scpy.special`, but the recommended way to achieve\n&quot;</span>
    <span class="s0">&quot;the most accurate CDF/SF/PDF/PPF/ISF computations is to use the\n&quot;</span>
    <span class="s0">&quot;`stats.ksone` distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import smirnovi, smirnov\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; n = 24\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; deviations = [0.1, 0.2, 0.3]\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Use `smirnov` to compute the complementary CDF of the Smirnov\n&quot;</span>
    <span class="s0">&quot;distribution for the given number of samples and deviations.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p = smirnov(n, deviations)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p\n&quot;</span>
    <span class="s0">&quot;array([0.58105083, 0.12826832, 0.01032231])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The inverse function ``smirnovi(n, p)`` returns ``deviations``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; smirnovi(n, p)\n&quot;</span>
    <span class="s0">&quot;array([0.1, 0.2, 0.3])&quot;)</span>
<span class="s0">ufunc_smirnovi_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_id__As_ld_d</span>
<span class="s0">ufunc_smirnovi_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_smirnovi_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_smirnovi_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc_smirnovi_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_smirnovi_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_smirnovi_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_smirnovi_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_smirnovi_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_smirnovi_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_smirnovi_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_smirnovi_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_smirnovi_ptr[2*0] = &lt;void*&gt;_func_smirnovi</span>
<span class="s0">ufunc_smirnovi_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;smirnovi&quot;)</span>
<span class="s0">ufunc_smirnovi_ptr[2*1] = &lt;void*&gt;_func_smirnovi_unsafe</span>
<span class="s0">ufunc_smirnovi_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;smirnovi&quot;)</span>
<span class="s0">ufunc_smirnovi_ptr[2*2] = &lt;void*&gt;_func_smirnovi_unsafe</span>
<span class="s0">ufunc_smirnovi_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;smirnovi&quot;)</span>
<span class="s0">ufunc_smirnovi_data[0] = &amp;ufunc_smirnovi_ptr[2*0]</span>
<span class="s0">ufunc_smirnovi_data[1] = &amp;ufunc_smirnovi_ptr[2*1]</span>
<span class="s0">ufunc_smirnovi_data[2] = &amp;ufunc_smirnovi_ptr[2*2]</span>
<span class="s0">smirnovi = np.PyUFunc_FromFuncAndData(ufunc_smirnovi_loops, ufunc_smirnovi_data, ufunc_smirnovi_types, 3, 2, 1, 0, &quot;smirnovi&quot;, ufunc_smirnovi_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_spence_loops[4]</span>
<span class="s0">cdef void *ufunc_spence_ptr[8]</span>
<span class="s0">cdef void *ufunc_spence_data[4]</span>
<span class="s0">cdef char ufunc_spence_types[8]</span>
<span class="s0">cdef char *ufunc_spence_doc = (</span>
    <span class="s0">&quot;spence(z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Spence's function, also known as the dilogarithm.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is defined to be\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;  \\int_1^z \\frac{\\log(t)}{1 - t}dt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;for complex :math:`z`, where the contour of integration is taken\n&quot;</span>
    <span class="s0">&quot;to avoid the branch cut of the logarithm. Spence's function is\n&quot;</span>
    <span class="s0">&quot;analytic everywhere except the negative real axis where it has a\n&quot;</span>
    <span class="s0">&quot;branch cut.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;z : array_like\n&quot;</span>
    <span class="s0">&quot;    Points at which to evaluate Spence's function\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;s : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Computed values of Spence's function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;There is a different convention which defines Spence's function by\n&quot;</span>
    <span class="s0">&quot;the integral\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;  -\\int_0^z \\frac{\\log(1 - t)}{t}dt;\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;this is our ``spence(1 - z)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import spence\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function is defined for complex inputs:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; spence([1-1j, 1.5+2j, 3j, -10-5j])\n&quot;</span>
    <span class="s0">&quot;array([-0.20561676+0.91596559j, -0.86766909-1.39560134j,\n&quot;</span>
    <span class="s0">&quot;       -0.59422064-2.49129918j, -1.14044398+6.80075924j])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For complex inputs on the branch cut, which is the negative real axis,\n&quot;</span>
    <span class="s0">&quot;the function returns the limit for ``z`` with positive imaginary part.\n&quot;</span>
    <span class="s0">&quot;For example, in the following, note the sign change of the imaginary\n&quot;</span>
    <span class="s0">&quot;part of the output for ``z = -2`` and ``z = -2 - 1e-8j``:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; spence([-2 + 1e-8j, -2, -2 - 1e-8j])\n&quot;</span>
    <span class="s0">&quot;array([2.32018041-3.45139229j, 2.32018042-3.4513923j ,\n&quot;</span>
    <span class="s0">&quot;       2.32018041+3.45139229j])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function returns ``nan`` for real inputs on the branch cut:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; spence(-1.5)\n&quot;</span>
    <span class="s0">&quot;nan\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Verify some particular values: ``spence(0) = pi**2/6``,\n&quot;</span>
    <span class="s0">&quot;``spence(1) = 0`` and ``spence(2) = -pi**2/12``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; spence([0, 1, 2])\n&quot;</span>
    <span class="s0">&quot;array([ 1.64493407,  0.        , -0.82246703])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.pi**2/6, -np.pi**2/12\n&quot;</span>
    <span class="s0">&quot;(1.6449340668482264, -0.8224670334241132)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Verify the identity::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    spence(z) + spence(1 - z) = pi**2/6 - log(z)*log(1 - z)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z = 3 + 4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; spence(z) + spence(1 - z)\n&quot;</span>
    <span class="s0">&quot;(-2.6523186143876067+1.8853470951513935j)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.pi**2/6 - np.log(z)*np.log(1 - z)\n&quot;</span>
    <span class="s0">&quot;(-2.652318614387606+1.885347095151394j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function for positive real input.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0, 6, 400)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, spence(x))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.grid()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel('x')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title('spence(x)')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_spence_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_spence_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_spence_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_F_F</span>
<span class="s0">ufunc_spence_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_D_D</span>
<span class="s0">ufunc_spence_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_spence_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_spence_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_spence_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_spence_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_spence_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_spence_types[6] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_spence_types[7] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_spence_ptr[2*0] = &lt;void*&gt;_func_spence</span>
<span class="s0">ufunc_spence_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;spence&quot;)</span>
<span class="s0">ufunc_spence_ptr[2*1] = &lt;void*&gt;_func_spence</span>
<span class="s0">ufunc_spence_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;spence&quot;)</span>
<span class="s0">ufunc_spence_ptr[2*2] = &lt;void*&gt;_func_cspence</span>
<span class="s0">ufunc_spence_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;spence&quot;)</span>
<span class="s0">ufunc_spence_ptr[2*3] = &lt;void*&gt;_func_cspence</span>
<span class="s0">ufunc_spence_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;spence&quot;)</span>
<span class="s0">ufunc_spence_data[0] = &amp;ufunc_spence_ptr[2*0]</span>
<span class="s0">ufunc_spence_data[1] = &amp;ufunc_spence_ptr[2*1]</span>
<span class="s0">ufunc_spence_data[2] = &amp;ufunc_spence_ptr[2*2]</span>
<span class="s0">ufunc_spence_data[3] = &amp;ufunc_spence_ptr[2*3]</span>
<span class="s0">spence = np.PyUFunc_FromFuncAndData(ufunc_spence_loops, ufunc_spence_data, ufunc_spence_types, 4, 1, 1, 0, &quot;spence&quot;, ufunc_spence_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_sph_harm_loops[3]</span>
<span class="s0">cdef void *ufunc_sph_harm_ptr[6]</span>
<span class="s0">cdef void *ufunc_sph_harm_data[3]</span>
<span class="s0">cdef char ufunc_sph_harm_types[15]</span>
<span class="s0">cdef char *ufunc_sph_harm_doc = (</span>
    <span class="s0">&quot;sph_harm(m, n, theta, phi, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute spherical harmonics.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The spherical harmonics are defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    Y^m_n(\\theta,\\phi) = \\sqrt{\\frac{2n+1}{4\\pi} \\frac{(n-m)!}{(n+m)!}}\n&quot;</span>
    <span class="s0">&quot;      e^{i m \\theta} P^m_n(\\cos(\\phi))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`P_n^m` are the associated Legendre functions; see `lpmv`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;m : array_like\n&quot;</span>
    <span class="s0">&quot;    Order of the harmonic (int); must have ``|m| &lt;= n``.\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;   Degree of the harmonic (int); must have ``n &gt;= 0``. This is\n&quot;</span>
    <span class="s0">&quot;   often denoted by ``l`` (lower case L) in descriptions of\n&quot;</span>
    <span class="s0">&quot;   spherical harmonics.\n&quot;</span>
    <span class="s0">&quot;theta : array_like\n&quot;</span>
    <span class="s0">&quot;   Azimuthal (longitudinal) coordinate; must be in ``[0, 2*pi]``.\n&quot;</span>
    <span class="s0">&quot;phi : array_like\n&quot;</span>
    <span class="s0">&quot;   Polar (colatitudinal) coordinate; must be in ``[0, pi]``.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;y_mn : complex scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;   The harmonic :math:`Y^m_n` sampled at ``theta`` and ``phi``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;There are different conventions for the meanings of the input\n&quot;</span>
    <span class="s0">&quot;arguments ``theta`` and ``phi``. In SciPy ``theta`` is the\n&quot;</span>
    <span class="s0">&quot;azimuthal angle and ``phi`` is the polar angle. It is common to\n&quot;</span>
    <span class="s0">&quot;see the opposite convention, that is, ``theta`` as the polar angle\n&quot;</span>
    <span class="s0">&quot;and ``phi`` as the azimuthal angle.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Note that SciPy's spherical harmonics include the Condon-Shortley\n&quot;</span>
    <span class="s0">&quot;phase [2]_ because it is part of `lpmv`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;With SciPy's conventions, the first several spherical harmonics\n&quot;</span>
    <span class="s0">&quot;are\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    Y_0^0(\\theta, \\phi) &amp;= \\frac{1}{2} \\sqrt{\\frac{1}{\\pi}} \\\\\n&quot;</span>
    <span class="s0">&quot;    Y_1^{-1}(\\theta, \\phi) &amp;= \\frac{1}{2} \\sqrt{\\frac{3}{2\\pi}}\n&quot;</span>
    <span class="s0">&quot;                                e^{-i\\theta} \\sin(\\phi) \\\\\n&quot;</span>
    <span class="s0">&quot;    Y_1^0(\\theta, \\phi) &amp;= \\frac{1}{2} \\sqrt{\\frac{3}{\\pi}}\n&quot;</span>
    <span class="s0">&quot;                             \\cos(\\phi) \\\\\n&quot;</span>
    <span class="s0">&quot;    Y_1^1(\\theta, \\phi) &amp;= -\\frac{1}{2} \\sqrt{\\frac{3}{2\\pi}}\n&quot;</span>
    <span class="s0">&quot;                             e^{i\\theta} \\sin(\\phi).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Digital Library of Mathematical Functions, 14.30.\n&quot;</span>
    <span class="s0">&quot;       https://dlmf.nist.gov/14.30\n&quot;</span>
    <span class="s0">&quot;.. [2] https://en.wikipedia.org/wiki/Spherical_harmonics#Condon.E2.80.93Shortley_phase&quot;)</span>
<span class="s0">ufunc_sph_harm_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_D_iidd__As_lldd_D</span>
<span class="s0">ufunc_sph_harm_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dddd__As_ffff_F</span>
<span class="s0">ufunc_sph_harm_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dddd__As_dddd_D</span>
<span class="s0">ufunc_sph_harm_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc_sph_harm_types[1] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc_sph_harm_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_sph_harm_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_sph_harm_types[4] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_sph_harm_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_sph_harm_types[6] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_sph_harm_types[7] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_sph_harm_types[8] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_sph_harm_types[9] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_sph_harm_types[10] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_sph_harm_types[11] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_sph_harm_types[12] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_sph_harm_types[13] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_sph_harm_types[14] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_sph_harm_ptr[2*0] = &lt;void*&gt;_func_sph_harmonic</span>
<span class="s0">ufunc_sph_harm_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;sph_harm&quot;)</span>
<span class="s0">ufunc_sph_harm_ptr[2*1] = &lt;void*&gt;_func_sph_harmonic_unsafe</span>
<span class="s0">ufunc_sph_harm_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;sph_harm&quot;)</span>
<span class="s0">ufunc_sph_harm_ptr[2*2] = &lt;void*&gt;_func_sph_harmonic_unsafe</span>
<span class="s0">ufunc_sph_harm_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;sph_harm&quot;)</span>
<span class="s0">ufunc_sph_harm_data[0] = &amp;ufunc_sph_harm_ptr[2*0]</span>
<span class="s0">ufunc_sph_harm_data[1] = &amp;ufunc_sph_harm_ptr[2*1]</span>
<span class="s0">ufunc_sph_harm_data[2] = &amp;ufunc_sph_harm_ptr[2*2]</span>
<span class="s0">sph_harm = np.PyUFunc_FromFuncAndData(ufunc_sph_harm_loops, ufunc_sph_harm_data, ufunc_sph_harm_types, 3, 4, 1, 0, &quot;sph_harm&quot;, ufunc_sph_harm_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_stdtr_loops[2]</span>
<span class="s0">cdef void *ufunc_stdtr_ptr[4]</span>
<span class="s0">cdef void *ufunc_stdtr_data[2]</span>
<span class="s0">cdef char ufunc_stdtr_types[6]</span>
<span class="s0">cdef char *ufunc_stdtr_doc = (</span>
    <span class="s0">&quot;stdtr(df, t, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Student t distribution cumulative distribution function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the integral:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    \\frac{\\Gamma((df+1)/2)}{\\sqrt{\\pi df} \\Gamma(df/2)}\n&quot;</span>
    <span class="s0">&quot;    \\int_{-\\infty}^t (1+x^2/df)^{-(df+1)/2}\\, dx\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;df : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom\n&quot;</span>
    <span class="s0">&quot;t : array_like\n&quot;</span>
    <span class="s0">&quot;    Upper bound of the integral\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the Student t CDF at t\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;stdtridf : inverse of stdtr with respect to `df`\n&quot;</span>
    <span class="s0">&quot;stdtrit : inverse of stdtr with respect to `t`\n&quot;</span>
    <span class="s0">&quot;scipy.stats.t : student t distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The student t distribution is also available as `scipy.stats.t`.\n&quot;</span>
    <span class="s0">&quot;Calling `stdtr` directly can improve performance compared to the\n&quot;</span>
    <span class="s0">&quot;``cdf`` method of `scipy.stats.t` (see last example below).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Calculate the function for ``df=3`` at ``t=1``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import stdtr\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; stdtr(3, 1)\n&quot;</span>
    <span class="s0">&quot;0.8044988905221148\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function for three different degrees of freedom.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; parameters = [(1, \&quot;solid\&quot;), (3, \&quot;dashed\&quot;), (10, \&quot;dotted\&quot;)]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for (df, linestyle) in parameters:\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, stdtr(df, x), ls=linestyle, label=f\&quot;$df={df}$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(\&quot;Student t distribution cumulative distribution function\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function can be computed for several degrees of freedom at the same\n&quot;</span>
    <span class="s0">&quot;time by providing a NumPy array or list for `df`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; stdtr([1, 2, 3], 1)\n&quot;</span>
    <span class="s0">&quot;array([0.75      , 0.78867513, 0.80449889])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is possible to calculate the function at several points for several\n&quot;</span>
    <span class="s0">&quot;different degrees of freedom simultaneously by providing arrays for `df`\n&quot;</span>
    <span class="s0">&quot;and `t` with shapes compatible for broadcasting. Compute `stdtr` at\n&quot;</span>
    <span class="s0">&quot;4 points for 3 degrees of freedom resulting in an array of shape 3x4.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfs = np.array([[1], [2], [3]])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; t = np.array([2, 4, 6, 8])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfs.shape, t.shape\n&quot;</span>
    <span class="s0">&quot;((3, 1), (4,))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; stdtr(dfs, t)\n&quot;</span>
    <span class="s0">&quot;array([[0.85241638, 0.92202087, 0.94743154, 0.96041658],\n&quot;</span>
    <span class="s0">&quot;       [0.90824829, 0.97140452, 0.98666426, 0.99236596],\n&quot;</span>
    <span class="s0">&quot;       [0.93033702, 0.98599577, 0.99536364, 0.99796171]])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The t distribution is also available as `scipy.stats.t`. Calling `stdtr`\n&quot;</span>
    <span class="s0">&quot;directly can be much faster than calling the ``cdf`` method of\n&quot;</span>
    <span class="s0">&quot;`scipy.stats.t`. To get the same results, one must use the following\n&quot;</span>
    <span class="s0">&quot;parametrization: ``scipy.stats.t(df).cdf(x) = stdtr(df, x)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.stats import t\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; df, x = 3, 1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; stdtr_result = stdtr(df, x)  # this can be faster than below\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; stats_result = t(df).cdf(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; stats_result == stdtr_result  # test that results are equal\n&quot;</span>
    <span class="s0">&quot;True&quot;)</span>
<span class="s0">ufunc_stdtr_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_stdtr_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_stdtr_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_stdtr_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_stdtr_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_stdtr_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_stdtr_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_stdtr_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_stdtr_ptr[2*0] = &lt;void*&gt;_func_cdft1_wrap</span>
<span class="s0">ufunc_stdtr_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;stdtr&quot;)</span>
<span class="s0">ufunc_stdtr_ptr[2*1] = &lt;void*&gt;_func_cdft1_wrap</span>
<span class="s0">ufunc_stdtr_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;stdtr&quot;)</span>
<span class="s0">ufunc_stdtr_data[0] = &amp;ufunc_stdtr_ptr[2*0]</span>
<span class="s0">ufunc_stdtr_data[1] = &amp;ufunc_stdtr_ptr[2*1]</span>
<span class="s0">stdtr = np.PyUFunc_FromFuncAndData(ufunc_stdtr_loops, ufunc_stdtr_data, ufunc_stdtr_types, 2, 2, 1, 0, &quot;stdtr&quot;, ufunc_stdtr_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_stdtridf_loops[2]</span>
<span class="s0">cdef void *ufunc_stdtridf_ptr[4]</span>
<span class="s0">cdef void *ufunc_stdtridf_data[2]</span>
<span class="s0">cdef char ufunc_stdtridf_types[6]</span>
<span class="s0">cdef char *ufunc_stdtridf_doc = (</span>
    <span class="s0">&quot;stdtridf(p, t, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Inverse of `stdtr` vs df\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the argument df such that stdtr(df, t) is equal to `p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability\n&quot;</span>
    <span class="s0">&quot;t : array_like\n&quot;</span>
    <span class="s0">&quot;    Upper bound of the integral\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;df : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of `df` such that ``stdtr(df, t) == p``\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;stdtr : Student t CDF\n&quot;</span>
    <span class="s0">&quot;stdtrit : inverse of stdtr with respect to `t`\n&quot;</span>
    <span class="s0">&quot;scipy.stats.t : Student t distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Compute the student t cumulative distribution function for one\n&quot;</span>
    <span class="s0">&quot;parameter set.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import stdtr, stdtridf\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; df, x = 5, 2\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdf_value = stdtr(df, x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdf_value\n&quot;</span>
    <span class="s0">&quot;0.9490302605850709\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Verify that `stdtridf` recovers the original value for `df` given\n&quot;</span>
    <span class="s0">&quot;the CDF value and `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; stdtridf(cdf_value, x)\n&quot;</span>
    <span class="s0">&quot;5.0&quot;)</span>
<span class="s0">ufunc_stdtridf_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_stdtridf_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_stdtridf_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_stdtridf_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_stdtridf_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_stdtridf_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_stdtridf_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_stdtridf_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_stdtridf_ptr[2*0] = &lt;void*&gt;_func_cdft3_wrap</span>
<span class="s0">ufunc_stdtridf_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;stdtridf&quot;)</span>
<span class="s0">ufunc_stdtridf_ptr[2*1] = &lt;void*&gt;_func_cdft3_wrap</span>
<span class="s0">ufunc_stdtridf_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;stdtridf&quot;)</span>
<span class="s0">ufunc_stdtridf_data[0] = &amp;ufunc_stdtridf_ptr[2*0]</span>
<span class="s0">ufunc_stdtridf_data[1] = &amp;ufunc_stdtridf_ptr[2*1]</span>
<span class="s0">stdtridf = np.PyUFunc_FromFuncAndData(ufunc_stdtridf_loops, ufunc_stdtridf_data, ufunc_stdtridf_types, 2, 2, 1, 0, &quot;stdtridf&quot;, ufunc_stdtridf_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_stdtrit_loops[2]</span>
<span class="s0">cdef void *ufunc_stdtrit_ptr[4]</span>
<span class="s0">cdef void *ufunc_stdtrit_data[2]</span>
<span class="s0">cdef char ufunc_stdtrit_types[6]</span>
<span class="s0">cdef char *ufunc_stdtrit_doc = (</span>
    <span class="s0">&quot;stdtrit(df, p, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The `p`-th quantile of the student t distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is the inverse of the student t distribution cumulative\n&quot;</span>
    <span class="s0">&quot;distribution function (CDF), returning `t` such that `stdtr(df, t) = p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the argument `t` such that stdtr(df, t) is equal to `p`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;df : array_like\n&quot;</span>
    <span class="s0">&quot;    Degrees of freedom\n&quot;</span>
    <span class="s0">&quot;p : array_like\n&quot;</span>
    <span class="s0">&quot;    Probability\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;t : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of `t` such that ``stdtr(df, t) == p``\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;stdtr : Student t CDF\n&quot;</span>
    <span class="s0">&quot;stdtridf : inverse of stdtr with respect to `df`\n&quot;</span>
    <span class="s0">&quot;scipy.stats.t : Student t distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The student t distribution is also available as `scipy.stats.t`. Calling\n&quot;</span>
    <span class="s0">&quot;`stdtrit` directly can improve performance compared to the ``ppf``\n&quot;</span>
    <span class="s0">&quot;method of `scipy.stats.t` (see last example below).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;`stdtrit` represents the inverse of the student t distribution CDF which\n&quot;</span>
    <span class="s0">&quot;is available as `stdtr`. Here, we calculate the CDF for ``df`` at\n&quot;</span>
    <span class="s0">&quot;``x=1``. `stdtrit` then returns ``1`` up to floating point errors\n&quot;</span>
    <span class="s0">&quot;given the same value for `df` and the computed CDF value.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import stdtr, stdtrit\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; df = 3\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cdf_value = stdtr(df, x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; stdtrit(df, cdf_value)\n&quot;</span>
    <span class="s0">&quot;0.9999999994418539\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function for three different degrees of freedom.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0, 1, 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; parameters = [(1, \&quot;solid\&quot;), (2, \&quot;dashed\&quot;), (5, \&quot;dotted\&quot;)]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for (df, linestyle) in parameters:\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, stdtrit(df, x), ls=linestyle, label=f\&quot;$df={df}$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_ylim(-10, 10)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(\&quot;Student t distribution quantile function\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function can be computed for several degrees of freedom at the same\n&quot;</span>
    <span class="s0">&quot;time by providing a NumPy array or list for `df`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; stdtrit([1, 2, 3], 0.7)\n&quot;</span>
    <span class="s0">&quot;array([0.72654253, 0.6172134 , 0.58438973])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is possible to calculate the function at several points for several\n&quot;</span>
    <span class="s0">&quot;different degrees of freedom simultaneously by providing arrays for `df`\n&quot;</span>
    <span class="s0">&quot;and `p` with shapes compatible for broadcasting. Compute `stdtrit` at\n&quot;</span>
    <span class="s0">&quot;4 points for 3 degrees of freedom resulting in an array of shape 3x4.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfs = np.array([[1], [2], [3]])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p = np.array([0.2, 0.4, 0.7, 0.8])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; dfs.shape, p.shape\n&quot;</span>
    <span class="s0">&quot;((3, 1), (4,))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; stdtrit(dfs, p)\n&quot;</span>
    <span class="s0">&quot;array([[-1.37638192, -0.3249197 ,  0.72654253,  1.37638192],\n&quot;</span>
    <span class="s0">&quot;       [-1.06066017, -0.28867513,  0.6172134 ,  1.06066017],\n&quot;</span>
    <span class="s0">&quot;       [-0.97847231, -0.27667066,  0.58438973,  0.97847231]])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The t distribution is also available as `scipy.stats.t`. Calling `stdtrit`\n&quot;</span>
    <span class="s0">&quot;directly can be much faster than calling the ``ppf`` method of\n&quot;</span>
    <span class="s0">&quot;`scipy.stats.t`. To get the same results, one must use the following\n&quot;</span>
    <span class="s0">&quot;parametrization: ``scipy.stats.t(df).ppf(x) = stdtrit(df, x)``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.stats import t\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; df, x = 3, 0.5\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; stdtrit_result = stdtrit(df, x)  # this can be faster than below\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; stats_result = t(df).ppf(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; stats_result == stdtrit_result  # test that results are equal\n&quot;</span>
    <span class="s0">&quot;True&quot;)</span>
<span class="s0">ufunc_stdtrit_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_stdtrit_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_stdtrit_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_stdtrit_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_stdtrit_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_stdtrit_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_stdtrit_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_stdtrit_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_stdtrit_ptr[2*0] = &lt;void*&gt;_func_cdft2_wrap</span>
<span class="s0">ufunc_stdtrit_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;stdtrit&quot;)</span>
<span class="s0">ufunc_stdtrit_ptr[2*1] = &lt;void*&gt;_func_cdft2_wrap</span>
<span class="s0">ufunc_stdtrit_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;stdtrit&quot;)</span>
<span class="s0">ufunc_stdtrit_data[0] = &amp;ufunc_stdtrit_ptr[2*0]</span>
<span class="s0">ufunc_stdtrit_data[1] = &amp;ufunc_stdtrit_ptr[2*1]</span>
<span class="s0">stdtrit = np.PyUFunc_FromFuncAndData(ufunc_stdtrit_loops, ufunc_stdtrit_data, ufunc_stdtrit_types, 2, 2, 1, 0, &quot;stdtrit&quot;, ufunc_stdtrit_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_struve_loops[2]</span>
<span class="s0">cdef void *ufunc_struve_ptr[4]</span>
<span class="s0">cdef void *ufunc_struve_data[2]</span>
<span class="s0">cdef char ufunc_struve_types[6]</span>
<span class="s0">cdef char *ufunc_struve_doc = (</span>
    <span class="s0">&quot;struve(v, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Struve function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Return the value of the Struve function of order `v` at `x`.  The Struve\n&quot;</span>
    <span class="s0">&quot;function is defined as,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    H_v(x) = (z/2)^{v + 1} \\sum_{n=0}^\\infty \\frac{(-1)^n (z/2)^{2n}}{\\Gamma(n + \\frac{3}{2}) \\Gamma(n + v + \\frac{3}{2})},\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`\\Gamma` is the gamma function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;v : array_like\n&quot;</span>
    <span class="s0">&quot;    Order of the Struve function (float).\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument of the Struve function (float; must be positive unless `v` is\n&quot;</span>
    <span class="s0">&quot;    an integer).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;H : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the Struve function of order `v` at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Three methods discussed in [1]_ are used to evaluate the Struve function:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;- power series\n&quot;</span>
    <span class="s0">&quot;- expansion in Bessel functions (if :math:`|z| &lt; |v| + 20`)\n&quot;</span>
    <span class="s0">&quot;- asymptotic large-z expansion (if :math:`z \\geq 0.7v + 12`)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Rounding errors are estimated based on the largest terms in the sums, and\n&quot;</span>
    <span class="s0">&quot;the result associated with the smallest error is returned.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;modstruve: Modified Struve function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] NIST Digital Library of Mathematical Functions\n&quot;</span>
    <span class="s0">&quot;       https://dlmf.nist.gov/11\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Calculate the Struve function of order 1 at 2.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import struve\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; struve(1, 2.)\n&quot;</span>
    <span class="s0">&quot;0.6467637282835622\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the Struve function at 2 for orders 1, 2 and 3 by providing\n&quot;</span>
    <span class="s0">&quot;a list for the order parameter `v`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; struve([1, 2, 3], 2.)\n&quot;</span>
    <span class="s0">&quot;array([0.64676373, 0.28031806, 0.08363767])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the Struve function of order 1 for several points by providing\n&quot;</span>
    <span class="s0">&quot;an array for `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; points = np.array([2., 5., 8.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; struve(1, points)\n&quot;</span>
    <span class="s0">&quot;array([0.64676373, 0.80781195, 0.48811605])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the Struve function for several orders at several points by\n&quot;</span>
    <span class="s0">&quot;providing arrays for `v` and `z`. The arrays have to be broadcastable\n&quot;</span>
    <span class="s0">&quot;to the correct shapes.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; orders = np.array([[1], [2], [3]])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; points.shape, orders.shape\n&quot;</span>
    <span class="s0">&quot;((3,), (3, 1))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; struve(orders, points)\n&quot;</span>
    <span class="s0">&quot;array([[0.64676373, 0.80781195, 0.48811605],\n&quot;</span>
    <span class="s0">&quot;       [0.28031806, 1.56937455, 1.51769363],\n&quot;</span>
    <span class="s0">&quot;       [0.08363767, 1.50872065, 2.98697513]])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the Struve functions of order 0 to 3 from -10 to 10.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-10., 10., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for i in range(4):\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, struve(i, x), label=f'$H_{i!r}$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend(ncol=2)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlim(-10, 10)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title(r\&quot;Struve functions $H_{\\nu}$\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_struve_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_struve_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_struve_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_struve_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_struve_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_struve_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_struve_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_struve_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_struve_ptr[2*0] = &lt;void*&gt;_func_struve_h</span>
<span class="s0">ufunc_struve_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;struve&quot;)</span>
<span class="s0">ufunc_struve_ptr[2*1] = &lt;void*&gt;_func_struve_h</span>
<span class="s0">ufunc_struve_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;struve&quot;)</span>
<span class="s0">ufunc_struve_data[0] = &amp;ufunc_struve_ptr[2*0]</span>
<span class="s0">ufunc_struve_data[1] = &amp;ufunc_struve_ptr[2*1]</span>
<span class="s0">struve = np.PyUFunc_FromFuncAndData(ufunc_struve_loops, ufunc_struve_data, ufunc_struve_types, 2, 2, 1, 0, &quot;struve&quot;, ufunc_struve_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_tandg_loops[2]</span>
<span class="s0">cdef void *ufunc_tandg_ptr[4]</span>
<span class="s0">cdef void *ufunc_tandg_data[2]</span>
<span class="s0">cdef char ufunc_tandg_types[4]</span>
<span class="s0">cdef char *ufunc_tandg_doc = (</span>
    <span class="s0">&quot;tandg(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Tangent of angle `x` given in degrees.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Angle, given in degrees.\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Tangent at the input.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;sindg, cosdg, cotdg\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import scipy.special as sc\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is more accurate than using tangent directly.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = 180 * np.arange(3)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sc.tandg(x)\n&quot;</span>
    <span class="s0">&quot;array([0., 0., 0.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.tan(x * np.pi / 180)\n&quot;</span>
    <span class="s0">&quot;array([ 0.0000000e+00, -1.2246468e-16, -2.4492936e-16])&quot;)</span>
<span class="s0">ufunc_tandg_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_tandg_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_tandg_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_tandg_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_tandg_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_tandg_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_tandg_ptr[2*0] = &lt;void*&gt;_func_tandg</span>
<span class="s0">ufunc_tandg_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;tandg&quot;)</span>
<span class="s0">ufunc_tandg_ptr[2*1] = &lt;void*&gt;_func_tandg</span>
<span class="s0">ufunc_tandg_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;tandg&quot;)</span>
<span class="s0">ufunc_tandg_data[0] = &amp;ufunc_tandg_ptr[2*0]</span>
<span class="s0">ufunc_tandg_data[1] = &amp;ufunc_tandg_ptr[2*1]</span>
<span class="s0">tandg = np.PyUFunc_FromFuncAndData(ufunc_tandg_loops, ufunc_tandg_data, ufunc_tandg_types, 2, 1, 1, 0, &quot;tandg&quot;, ufunc_tandg_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_tklmbda_loops[2]</span>
<span class="s0">cdef void *ufunc_tklmbda_ptr[4]</span>
<span class="s0">cdef void *ufunc_tklmbda_data[2]</span>
<span class="s0">cdef char ufunc_tklmbda_types[6]</span>
<span class="s0">cdef char *ufunc_tklmbda_doc = (</span>
    <span class="s0">&quot;tklmbda(x, lmbda, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Cumulative distribution function of the Tukey lambda distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x, lmbda : array_like\n&quot;</span>
    <span class="s0">&quot;    Parameters\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;cdf : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the Tukey lambda CDF\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;scipy.stats.tukeylambda : Tukey lambda distribution\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import tklmbda, expit\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute the cumulative distribution function (CDF) of the Tukey lambda\n&quot;</span>
    <span class="s0">&quot;distribution at several ``x`` values for `lmbda` = -1.5.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-2, 2, 9)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x\n&quot;</span>
    <span class="s0">&quot;array([-2. , -1.5, -1. , -0.5,  0. ,  0.5,  1. ,  1.5,  2. ])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; tklmbda(x, -1.5)\n&quot;</span>
    <span class="s0">&quot;array([0.34688734, 0.3786554 , 0.41528805, 0.45629737, 0.5       ,\n&quot;</span>
    <span class="s0">&quot;       0.54370263, 0.58471195, 0.6213446 , 0.65311266])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;When `lmbda` is 0, the function is the logistic sigmoid function,\n&quot;</span>
    <span class="s0">&quot;which is implemented in `scipy.special` as `expit`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; tklmbda(x, 0)\n&quot;</span>
    <span class="s0">&quot;array([0.11920292, 0.18242552, 0.26894142, 0.37754067, 0.5       ,\n&quot;</span>
    <span class="s0">&quot;       0.62245933, 0.73105858, 0.81757448, 0.88079708])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; expit(x)\n&quot;</span>
    <span class="s0">&quot;array([0.11920292, 0.18242552, 0.26894142, 0.37754067, 0.5       ,\n&quot;</span>
    <span class="s0">&quot;       0.62245933, 0.73105858, 0.81757448, 0.88079708])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;When `lmbda` is 1, the Tukey lambda distribution is uniform on the\n&quot;</span>
    <span class="s0">&quot;interval [-1, 1], so the CDF increases linearly.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; t = np.linspace(-1, 1, 9)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; tklmbda(t, 1)\n&quot;</span>
    <span class="s0">&quot;array([0.   , 0.125, 0.25 , 0.375, 0.5  , 0.625, 0.75 , 0.875, 1.   ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;In the following, we generate plots for several values of `lmbda`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The first figure shows graphs for `lmbda` &lt;= 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; styles = ['-', '-.', '--', ':']\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-12, 12, 500)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for k, lmbda in enumerate([-1.0, -0.5, 0.0]):\n&quot;</span>
    <span class="s0">&quot;...     y = tklmbda(x, lmbda)\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, y, styles[k], label=f'$\\lambda$ = {lmbda:-4.1f}')\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title('tklmbda(x, $\\lambda$)')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_label('x')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend(framealpha=1, shadow=True)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.grid(True)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The second figure shows graphs for `lmbda` &gt; 0.  The dots in the\n&quot;</span>
    <span class="s0">&quot;graphs show the bounds of the support of the distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-4.2, 4.2, 500)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; lmbdas = [0.25, 0.5, 1.0, 1.5]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for k, lmbda in enumerate(lmbdas):\n&quot;</span>
    <span class="s0">&quot;...     y = tklmbda(x, lmbda)\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, y, styles[k], label=f'$\\lambda$ = {lmbda}')\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_prop_cycle(None)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for lmbda in lmbdas:\n&quot;</span>
    <span class="s0">&quot;...     ax.plot([-1/lmbda, 1/lmbda], [0, 1], '.', ms=8)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_title('tklmbda(x, $\\lambda$)')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_xlabel('x')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend(framealpha=1, shadow=True)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.grid(True)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.tight_layout()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The CDF of the Tukey lambda distribution is also implemented as the\n&quot;</span>
    <span class="s0">&quot;``cdf`` method of `scipy.stats.tukeylambda`.  In the following,\n&quot;</span>
    <span class="s0">&quot;``tukeylambda.cdf(x, -0.5)`` and ``tklmbda(x, -0.5)`` compute the\n&quot;</span>
    <span class="s0">&quot;same values:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.stats import tukeylambda\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-2, 2, 9)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; tukeylambda.cdf(x, -0.5)\n&quot;</span>
    <span class="s0">&quot;array([0.21995157, 0.27093858, 0.33541677, 0.41328161, 0.5       ,\n&quot;</span>
    <span class="s0">&quot;       0.58671839, 0.66458323, 0.72906142, 0.78004843])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; tklmbda(x, -0.5)\n&quot;</span>
    <span class="s0">&quot;array([0.21995157, 0.27093858, 0.33541677, 0.41328161, 0.5       ,\n&quot;</span>
    <span class="s0">&quot;       0.58671839, 0.66458323, 0.72906142, 0.78004843])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The implementation in ``tukeylambda`` also provides location and scale\n&quot;</span>
    <span class="s0">&quot;parameters, and other methods such as ``pdf()`` (the probability\n&quot;</span>
    <span class="s0">&quot;density function) and ``ppf()`` (the inverse of the CDF), so for\n&quot;</span>
    <span class="s0">&quot;working with the Tukey lambda distribution, ``tukeylambda`` is more\n&quot;</span>
    <span class="s0">&quot;generally useful.  The primary advantage of ``tklmbda`` is that it is\n&quot;</span>
    <span class="s0">&quot;significantly faster than ``tukeylambda.cdf``.&quot;)</span>
<span class="s0">ufunc_tklmbda_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_tklmbda_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_tklmbda_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_tklmbda_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_tklmbda_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_tklmbda_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_tklmbda_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_tklmbda_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_tklmbda_ptr[2*0] = &lt;void*&gt;_func_tukeylambdacdf</span>
<span class="s0">ufunc_tklmbda_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;tklmbda&quot;)</span>
<span class="s0">ufunc_tklmbda_ptr[2*1] = &lt;void*&gt;_func_tukeylambdacdf</span>
<span class="s0">ufunc_tklmbda_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;tklmbda&quot;)</span>
<span class="s0">ufunc_tklmbda_data[0] = &amp;ufunc_tklmbda_ptr[2*0]</span>
<span class="s0">ufunc_tklmbda_data[1] = &amp;ufunc_tklmbda_ptr[2*1]</span>
<span class="s0">tklmbda = np.PyUFunc_FromFuncAndData(ufunc_tklmbda_loops, ufunc_tklmbda_data, ufunc_tklmbda_types, 2, 2, 1, 0, &quot;tklmbda&quot;, ufunc_tklmbda_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_voigt_profile_loops[2]</span>
<span class="s0">cdef void *ufunc_voigt_profile_ptr[4]</span>
<span class="s0">cdef void *ufunc_voigt_profile_data[2]</span>
<span class="s0">cdef char ufunc_voigt_profile_types[8]</span>
<span class="s0">cdef char *ufunc_voigt_profile_doc = (</span>
    <span class="s0">&quot;voigt_profile(x, sigma, gamma, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Voigt profile.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The Voigt profile is a convolution of a 1-D Normal distribution with\n&quot;</span>
    <span class="s0">&quot;standard deviation ``sigma`` and a 1-D Cauchy distribution with half-width at\n&quot;</span>
    <span class="s0">&quot;half-maximum ``gamma``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;If ``sigma = 0``, PDF of Cauchy distribution is returned.\n&quot;</span>
    <span class="s0">&quot;Conversely, if ``gamma = 0``, PDF of Normal distribution is returned.\n&quot;</span>
    <span class="s0">&quot;If ``sigma = gamma = 0``, the return value is ``Inf`` for ``x = 0``, and ``0`` for all other ``x``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Real argument\n&quot;</span>
    <span class="s0">&quot;sigma : array_like\n&quot;</span>
    <span class="s0">&quot;    The standard deviation of the Normal distribution part\n&quot;</span>
    <span class="s0">&quot;gamma : array_like\n&quot;</span>
    <span class="s0">&quot;    The half-width at half-maximum of the Cauchy distribution part\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    The Voigt profile at the given arguments\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;It can be expressed in terms of Faddeeva function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: V(x; \\sigma, \\gamma) = \\frac{Re[w(z)]}{\\sigma\\sqrt{2\\pi}},\n&quot;</span>
    <span class="s0">&quot;.. math:: z = \\frac{x + i\\gamma}{\\sqrt{2}\\sigma}\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`w(z)` is the Faddeeva function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;wofz : Faddeeva function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] https://en.wikipedia.org/wiki/Voigt_profile\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Calculate the function at point 2 for ``sigma=1`` and ``gamma=1``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import voigt_profile\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; voigt_profile(2, 1., 1.)\n&quot;</span>
    <span class="s0">&quot;0.09071519942627544\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate the function at several points by providing a NumPy array\n&quot;</span>
    <span class="s0">&quot;for `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; values = np.array([-2., 0., 5])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; voigt_profile(values, 1., 1.)\n&quot;</span>
    <span class="s0">&quot;array([0.0907152 , 0.20870928, 0.01388492])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function for different parameter sets.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 8))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-10, 10, 500)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; parameters_list = [(1.5, 0., \&quot;solid\&quot;), (1.3, 0.5, \&quot;dashed\&quot;),\n&quot;</span>
    <span class="s0">&quot;...                    (0., 1.8, \&quot;dotted\&quot;), (1., 1., \&quot;dashdot\&quot;)]\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for params in parameters_list:\n&quot;</span>
    <span class="s0">&quot;...     sigma, gamma, linestyle = params\n&quot;</span>
    <span class="s0">&quot;...     voigt = voigt_profile(x, sigma, gamma)\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, voigt, label=rf\&quot;$\\sigma={sigma},\\, \\gamma={gamma}$\&quot;,\n&quot;</span>
    <span class="s0">&quot;...             ls=linestyle)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Verify visually that the Voigt profile indeed arises as the convolution\n&quot;</span>
    <span class="s0">&quot;of a normal and a Cauchy distribution.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.signal import convolve\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x, dx = np.linspace(-10, 10, 500, retstep=True)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; def gaussian(x, sigma):\n&quot;</span>
    <span class="s0">&quot;...     return np.exp(-0.5 * x**2/sigma**2)/(sigma * np.sqrt(2*np.pi))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; def cauchy(x, gamma):\n&quot;</span>
    <span class="s0">&quot;...     return gamma/(np.pi * (np.square(x)+gamma**2))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; sigma = 2\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gamma = 1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; gauss_profile = gaussian(x, sigma)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; cauchy_profile = cauchy(x, gamma)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; convolved = dx * convolve(cauchy_profile, gauss_profile, mode=\&quot;same\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; voigt = voigt_profile(x, sigma, gamma)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 8))\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, gauss_profile, label=\&quot;Gauss: $G$\&quot;, c='b')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, cauchy_profile, label=\&quot;Cauchy: $C$\&quot;, c='y', ls=\&quot;dashed\&quot;)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; xx = 0.5*(x[1:] + x[:-1])  # midpoints\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(xx, convolved[1:], label=\&quot;Convolution: $G * C$\&quot;, ls='dashdot',\n&quot;</span>
    <span class="s0">&quot;...         c='k')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, voigt, label=\&quot;Voigt\&quot;, ls='dotted', c='r')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_voigt_profile_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_voigt_profile_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_voigt_profile_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_voigt_profile_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_voigt_profile_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_voigt_profile_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_voigt_profile_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_voigt_profile_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_voigt_profile_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_voigt_profile_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_voigt_profile_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_voigt_profile</span>
<span class="s0">ufunc_voigt_profile_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;voigt_profile&quot;)</span>
<span class="s0">ufunc_voigt_profile_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_voigt_profile</span>
<span class="s0">ufunc_voigt_profile_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;voigt_profile&quot;)</span>
<span class="s0">ufunc_voigt_profile_data[0] = &amp;ufunc_voigt_profile_ptr[2*0]</span>
<span class="s0">ufunc_voigt_profile_data[1] = &amp;ufunc_voigt_profile_ptr[2*1]</span>
<span class="s0">voigt_profile = np.PyUFunc_FromFuncAndData(ufunc_voigt_profile_loops, ufunc_voigt_profile_data, ufunc_voigt_profile_types, 2, 3, 1, 0, &quot;voigt_profile&quot;, ufunc_voigt_profile_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_wofz_loops[2]</span>
<span class="s0">cdef void *ufunc_wofz_ptr[4]</span>
<span class="s0">cdef void *ufunc_wofz_data[2]</span>
<span class="s0">cdef char ufunc_wofz_types[4]</span>
<span class="s0">cdef char *ufunc_wofz_doc = (</span>
    <span class="s0">&quot;wofz(z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Faddeeva function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the value of the Faddeeva function for complex argument::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    exp(-z**2) * erfc(-i*z)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;z : array_like\n&quot;</span>
    <span class="s0">&quot;    complex argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the Faddeeva function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;dawsn, erf, erfc, erfcx, erfi\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Steven G. Johnson, Faddeeva W function implementation.\n&quot;</span>
    <span class="s0">&quot;   http://ab-initio.mit.edu/Faddeeva\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy import special\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(-3, 3)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z = special.wofz(x)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.plot(x, z.real, label='wofz(x).real')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.plot(x, z.imag, label='wofz(x).imag')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.xlabel('$x$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.legend(framealpha=1, shadow=True)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.grid(alpha=0.25)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_wofz_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_F_F</span>
<span class="s0">ufunc_wofz_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_D_D</span>
<span class="s0">ufunc_wofz_types[0] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_wofz_types[1] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_wofz_types[2] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_wofz_types[3] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_wofz_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_w</span>
<span class="s0">ufunc_wofz_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;wofz&quot;)</span>
<span class="s0">ufunc_wofz_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_faddeeva_w</span>
<span class="s0">ufunc_wofz_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;wofz&quot;)</span>
<span class="s0">ufunc_wofz_data[0] = &amp;ufunc_wofz_ptr[2*0]</span>
<span class="s0">ufunc_wofz_data[1] = &amp;ufunc_wofz_ptr[2*1]</span>
<span class="s0">wofz = np.PyUFunc_FromFuncAndData(ufunc_wofz_loops, ufunc_wofz_data, ufunc_wofz_types, 2, 1, 1, 0, &quot;wofz&quot;, ufunc_wofz_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_wright_bessel_loops[2]</span>
<span class="s0">cdef void *ufunc_wright_bessel_ptr[4]</span>
<span class="s0">cdef void *ufunc_wright_bessel_data[2]</span>
<span class="s0">cdef char ufunc_wright_bessel_types[8]</span>
<span class="s0">cdef char *ufunc_wright_bessel_doc = (</span>
    <span class="s0">&quot;wright_bessel(a, b, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Wright's generalized Bessel function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Wright's generalized Bessel function is an entire function and defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: \\Phi(a, b; x) = \\sum_{k=0}^\\infty \\frac{x^k}{k! \\Gamma(a k + b)}\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also [1].\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;a : array_like of float\n&quot;</span>
    <span class="s0">&quot;    a &gt;= 0\n&quot;</span>
    <span class="s0">&quot;b : array_like of float\n&quot;</span>
    <span class="s0">&quot;    b &gt;= 0\n&quot;</span>
    <span class="s0">&quot;x : array_like of float\n&quot;</span>
    <span class="s0">&quot;    x &gt;= 0\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the Wright's generalized Bessel function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Due to the compexity of the function with its three parameters, only\n&quot;</span>
    <span class="s0">&quot;non-negative arguments are implemented.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import wright_bessel\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a, b, x = 1.5, 1.1, 2.5\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; wright_bessel(a, b-1, x)\n&quot;</span>
    <span class="s0">&quot;4.5314465939443025\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Now, let us verify the relation\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: \\Phi(a, b-1; x) = a x \\Phi(a, b+a; x) + (b-1) \\Phi(a, b; x)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; a * x * wright_bessel(a, b+a, x) + (b-1) * wright_bessel(a, b, x)\n&quot;</span>
    <span class="s0">&quot;4.5314465939443025\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Digital Library of Mathematical Functions, 10.46.\n&quot;</span>
    <span class="s0">&quot;       https://dlmf.nist.gov/10.46.E1&quot;)</span>
<span class="s0">ufunc_wright_bessel_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_fff_f</span>
<span class="s0">ufunc_wright_bessel_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_ddd__As_ddd_d</span>
<span class="s0">ufunc_wright_bessel_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_wright_bessel_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_wright_bessel_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_wright_bessel_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_wright_bessel_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_wright_bessel_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_wright_bessel_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_wright_bessel_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_wright_bessel_ptr[2*0] = &lt;void*&gt;_func_wright_bessel_scalar</span>
<span class="s0">ufunc_wright_bessel_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;wright_bessel&quot;)</span>
<span class="s0">ufunc_wright_bessel_ptr[2*1] = &lt;void*&gt;_func_wright_bessel_scalar</span>
<span class="s0">ufunc_wright_bessel_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;wright_bessel&quot;)</span>
<span class="s0">ufunc_wright_bessel_data[0] = &amp;ufunc_wright_bessel_ptr[2*0]</span>
<span class="s0">ufunc_wright_bessel_data[1] = &amp;ufunc_wright_bessel_ptr[2*1]</span>
<span class="s0">wright_bessel = np.PyUFunc_FromFuncAndData(ufunc_wright_bessel_loops, ufunc_wright_bessel_data, ufunc_wright_bessel_types, 2, 3, 1, 0, &quot;wright_bessel&quot;, ufunc_wright_bessel_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_wrightomega_loops[4]</span>
<span class="s0">cdef void *ufunc_wrightomega_ptr[8]</span>
<span class="s0">cdef void *ufunc_wrightomega_data[4]</span>
<span class="s0">cdef char ufunc_wrightomega_types[8]</span>
<span class="s0">cdef char *ufunc_wrightomega_doc = (</span>
    <span class="s0">&quot;wrightomega(z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Wright Omega function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Defined as the solution to\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    \\omega + \\log(\\omega) = z\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`\\log` is the principal branch of the complex logarithm.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;z : array_like\n&quot;</span>
    <span class="s0">&quot;    Points at which to evaluate the Wright Omega function\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function values\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;omega : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of the Wright Omega function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 0.19.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function can also be defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    \\omega(z) = W_{K(z)}(e^z)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`K(z) = \\lceil (\\Im(z) - \\pi)/(2\\pi) \\rceil` is the\n&quot;</span>
    <span class="s0">&quot;unwinding number and :math:`W` is the Lambert W function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The implementation here is taken from [1]_.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;lambertw : The Lambert W function\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Lawrence, Corless, and Jeffrey, \&quot;Algorithm 917: Complex\n&quot;</span>
    <span class="s0">&quot;       Double-Precision Evaluation of the Wright :math:`\\omega`\n&quot;</span>
    <span class="s0">&quot;       Function.\&quot; ACM Transactions on Mathematical Software,\n&quot;</span>
    <span class="s0">&quot;       2012. :doi:`10.1145/2168773.2168779`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import wrightomega, lambertw\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; wrightomega([-2, -1, 0, 1, 2])\n&quot;</span>
    <span class="s0">&quot;array([0.12002824, 0.27846454, 0.56714329, 1.        , 1.5571456 ])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Complex input:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; wrightomega(3 + 5j)\n&quot;</span>
    <span class="s0">&quot;(1.5804428632097158+3.8213626783287937j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Verify that ``wrightomega(z)`` satisfies ``w + log(w) = z``:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; w = -5 + 4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; wrightomega(w + np.log(w))\n&quot;</span>
    <span class="s0">&quot;(-5+4j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Verify the connection to ``lambertw``:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z = 0.5 + 3j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; wrightomega(z)\n&quot;</span>
    <span class="s0">&quot;(0.0966015889280649+1.4937828458191993j)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; lambertw(np.exp(z))\n&quot;</span>
    <span class="s0">&quot;(0.09660158892806493+1.4937828458191993j)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z = 0.5 + 4j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; wrightomega(z)\n&quot;</span>
    <span class="s0">&quot;(-0.3362123489037213+2.282986001579032j)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; lambertw(np.exp(z), k=1)\n&quot;</span>
    <span class="s0">&quot;(-0.33621234890372115+2.282986001579032j)&quot;)</span>
<span class="s0">ufunc_wrightomega_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_wrightomega_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_wrightomega_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_F_F</span>
<span class="s0">ufunc_wrightomega_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_D__As_D_D</span>
<span class="s0">ufunc_wrightomega_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_wrightomega_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_wrightomega_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_wrightomega_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_wrightomega_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_wrightomega_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_wrightomega_types[6] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_wrightomega_types[7] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_wrightomega_ptr[2*0] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_wrightomega_real</span>
<span class="s0">ufunc_wrightomega_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;wrightomega&quot;)</span>
<span class="s0">ufunc_wrightomega_ptr[2*1] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_wrightomega_real</span>
<span class="s0">ufunc_wrightomega_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;wrightomega&quot;)</span>
<span class="s0">ufunc_wrightomega_ptr[2*2] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_wrightomega</span>
<span class="s0">ufunc_wrightomega_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;wrightomega&quot;)</span>
<span class="s0">ufunc_wrightomega_ptr[2*3] = &lt;void*&gt;scipy.special._ufuncs_cxx._export_wrightomega</span>
<span class="s0">ufunc_wrightomega_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;wrightomega&quot;)</span>
<span class="s0">ufunc_wrightomega_data[0] = &amp;ufunc_wrightomega_ptr[2*0]</span>
<span class="s0">ufunc_wrightomega_data[1] = &amp;ufunc_wrightomega_ptr[2*1]</span>
<span class="s0">ufunc_wrightomega_data[2] = &amp;ufunc_wrightomega_ptr[2*2]</span>
<span class="s0">ufunc_wrightomega_data[3] = &amp;ufunc_wrightomega_ptr[2*3]</span>
<span class="s0">wrightomega = np.PyUFunc_FromFuncAndData(ufunc_wrightomega_loops, ufunc_wrightomega_data, ufunc_wrightomega_types, 4, 1, 1, 0, &quot;wrightomega&quot;, ufunc_wrightomega_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_xlog1py_loops[4]</span>
<span class="s0">cdef void *ufunc_xlog1py_ptr[8]</span>
<span class="s0">cdef void *ufunc_xlog1py_data[4]</span>
<span class="s0">cdef char ufunc_xlog1py_types[12]</span>
<span class="s0">cdef char *ufunc_xlog1py_doc = (</span>
    <span class="s0">&quot;xlog1py(x, y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute ``x*log1p(y)`` so that the result is 0 if ``x = 0``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Multiplier\n&quot;</span>
    <span class="s0">&quot;y : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;z : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Computed x*log1p(y)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 0.13.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;This example shows how the function can be used to calculate the log of\n&quot;</span>
    <span class="s0">&quot;the probability mass function for a geometric discrete random variable.\n&quot;</span>
    <span class="s0">&quot;The probability mass function of the geometric distribution is defined\n&quot;</span>
    <span class="s0">&quot;as follows:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: f(k) = (1-p)^{k-1} p\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`p` is the probability of a single success\n&quot;</span>
    <span class="s0">&quot;and :math:`1-p` is the probability of a single failure\n&quot;</span>
    <span class="s0">&quot;and :math:`k` is the number of trials to get the first success.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import xlog1py\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; p = 0.5\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; k = 100\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; _pmf = np.power(1 - p, k - 1) * p\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; _pmf\n&quot;</span>
    <span class="s0">&quot;7.888609052210118e-31\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;If we take k as a relatively large number the value of the probability\n&quot;</span>
    <span class="s0">&quot;mass function can become very low. In such cases taking the log of the\n&quot;</span>
    <span class="s0">&quot;pmf would be more suitable as the log function can change the values\n&quot;</span>
    <span class="s0">&quot;to a scale that is more appropriate to work with.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; _log_pmf = xlog1py(k - 1, -p) + np.log(p)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; _log_pmf\n&quot;</span>
    <span class="s0">&quot;-69.31471805599453\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;We can confirm that we get a value close to the original pmf value by\n&quot;</span>
    <span class="s0">&quot;taking the exponential of the log pmf.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; _orig_pmf = np.exp(_log_pmf)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; np.isclose(_pmf, _orig_pmf)\n&quot;</span>
    <span class="s0">&quot;True&quot;)</span>
<span class="s0">ufunc_xlog1py_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_xlog1py_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_xlog1py_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_DD__As_FF_F</span>
<span class="s0">ufunc_xlog1py_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_DD__As_DD_D</span>
<span class="s0">ufunc_xlog1py_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_xlog1py_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_xlog1py_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_xlog1py_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_xlog1py_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_xlog1py_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_xlog1py_types[6] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_xlog1py_types[7] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_xlog1py_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_xlog1py_types[9] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_xlog1py_types[10] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_xlog1py_types[11] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_xlog1py_ptr[2*0] = &lt;void*&gt;_func_xlog1py[double]</span>
<span class="s0">ufunc_xlog1py_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;xlog1py&quot;)</span>
<span class="s0">ufunc_xlog1py_ptr[2*1] = &lt;void*&gt;_func_xlog1py[double]</span>
<span class="s0">ufunc_xlog1py_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;xlog1py&quot;)</span>
<span class="s0">ufunc_xlog1py_ptr[2*2] = &lt;void*&gt;_func_xlog1py[double_complex]</span>
<span class="s0">ufunc_xlog1py_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;xlog1py&quot;)</span>
<span class="s0">ufunc_xlog1py_ptr[2*3] = &lt;void*&gt;_func_xlog1py[double_complex]</span>
<span class="s0">ufunc_xlog1py_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;xlog1py&quot;)</span>
<span class="s0">ufunc_xlog1py_data[0] = &amp;ufunc_xlog1py_ptr[2*0]</span>
<span class="s0">ufunc_xlog1py_data[1] = &amp;ufunc_xlog1py_ptr[2*1]</span>
<span class="s0">ufunc_xlog1py_data[2] = &amp;ufunc_xlog1py_ptr[2*2]</span>
<span class="s0">ufunc_xlog1py_data[3] = &amp;ufunc_xlog1py_ptr[2*3]</span>
<span class="s0">xlog1py = np.PyUFunc_FromFuncAndData(ufunc_xlog1py_loops, ufunc_xlog1py_data, ufunc_xlog1py_types, 4, 2, 1, 0, &quot;xlog1py&quot;, ufunc_xlog1py_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_xlogy_loops[4]</span>
<span class="s0">cdef void *ufunc_xlogy_ptr[8]</span>
<span class="s0">cdef void *ufunc_xlogy_data[4]</span>
<span class="s0">cdef char ufunc_xlogy_types[12]</span>
<span class="s0">cdef char *ufunc_xlogy_doc = (</span>
    <span class="s0">&quot;xlogy(x, y, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compute ``x*log(y)`` so that the result is 0 if ``x = 0``.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Multiplier\n&quot;</span>
    <span class="s0">&quot;y : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;z : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Computed x*log(y)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;The log function used in the computation is the natural log.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. versionadded:: 0.13.0\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;We can use this function to calculate the binary logistic loss also\n&quot;</span>
    <span class="s0">&quot;known as the binary cross entropy. This loss function is used for\n&quot;</span>
    <span class="s0">&quot;binary classification problems and is defined as:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;    L = 1/n * \\sum_{i=0}^n -(y_i*log(y\\_pred_i) + (1-y_i)*log(1-y\\_pred_i))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;We can define the parameters `x` and `y` as y and y_pred respectively.\n&quot;</span>
    <span class="s0">&quot;y is the array of the actual labels which over here can be either 0 or 1.\n&quot;</span>
    <span class="s0">&quot;y_pred is the array of the predicted probabilities with respect to\n&quot;</span>
    <span class="s0">&quot;the positive class (1).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import xlogy\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = np.array([0, 1, 0, 1, 1, 0])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y_pred = np.array([0.3, 0.8, 0.4, 0.7, 0.9, 0.2])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; n = len(y)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; loss = -(xlogy(y, y_pred) + xlogy(1 - y, 1 - y_pred)).sum()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; loss /= n\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; loss\n&quot;</span>
    <span class="s0">&quot;0.29597052165495025\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;A lower loss is usually better as it indicates that the predictions are\n&quot;</span>
    <span class="s0">&quot;similar to the actual labels. In this example since our predicted\n&quot;</span>
    <span class="s0">&quot;probabilties are close to the actual labels, we get an overall loss\n&quot;</span>
    <span class="s0">&quot;that is reasonably low and appropriate.&quot;)</span>
<span class="s0">ufunc_xlogy_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_xlogy_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_xlogy_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_D_DD__As_FF_F</span>
<span class="s0">ufunc_xlogy_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_DD__As_DD_D</span>
<span class="s0">ufunc_xlogy_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_xlogy_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_xlogy_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_xlogy_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_xlogy_types[4] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_xlogy_types[5] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_xlogy_types[6] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_xlogy_types[7] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_xlogy_types[8] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_xlogy_types[9] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_xlogy_types[10] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_xlogy_types[11] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_xlogy_ptr[2*0] = &lt;void*&gt;_func_xlogy[double]</span>
<span class="s0">ufunc_xlogy_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;xlogy&quot;)</span>
<span class="s0">ufunc_xlogy_ptr[2*1] = &lt;void*&gt;_func_xlogy[double]</span>
<span class="s0">ufunc_xlogy_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;xlogy&quot;)</span>
<span class="s0">ufunc_xlogy_ptr[2*2] = &lt;void*&gt;_func_xlogy[double_complex]</span>
<span class="s0">ufunc_xlogy_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;xlogy&quot;)</span>
<span class="s0">ufunc_xlogy_ptr[2*3] = &lt;void*&gt;_func_xlogy[double_complex]</span>
<span class="s0">ufunc_xlogy_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;xlogy&quot;)</span>
<span class="s0">ufunc_xlogy_data[0] = &amp;ufunc_xlogy_ptr[2*0]</span>
<span class="s0">ufunc_xlogy_data[1] = &amp;ufunc_xlogy_ptr[2*1]</span>
<span class="s0">ufunc_xlogy_data[2] = &amp;ufunc_xlogy_ptr[2*2]</span>
<span class="s0">ufunc_xlogy_data[3] = &amp;ufunc_xlogy_ptr[2*3]</span>
<span class="s0">xlogy = np.PyUFunc_FromFuncAndData(ufunc_xlogy_loops, ufunc_xlogy_data, ufunc_xlogy_types, 4, 2, 1, 0, &quot;xlogy&quot;, ufunc_xlogy_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_y0_loops[2]</span>
<span class="s0">cdef void *ufunc_y0_ptr[4]</span>
<span class="s0">cdef void *ufunc_y0_data[2]</span>
<span class="s0">cdef char ufunc_y0_types[4]</span>
<span class="s0">cdef char *ufunc_y0_doc = (</span>
    <span class="s0">&quot;y0(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Bessel function of the second kind of order 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;Y : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the Bessel function of the second kind of order 0 at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The domain is divided into the intervals [0, 5] and (5, infinity). In the\n&quot;</span>
    <span class="s0">&quot;first interval a rational approximation :math:`R(x)` is employed to\n&quot;</span>
    <span class="s0">&quot;compute,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    Y_0(x) = R(x) + \\frac{2 \\log(x) J_0(x)}{\\pi},\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where :math:`J_0` is the Bessel function of the first kind of order 0.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;In the second interval, the Hankel asymptotic expansion is employed with\n&quot;</span>
    <span class="s0">&quot;two rational functions of degree 6/6 and 7/7.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is a wrapper for the Cephes [1]_ routine `y0`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;j0: Bessel function of the first kind of order 0\n&quot;</span>
    <span class="s0">&quot;yv: Bessel function of the first kind\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Calculate the function at one point:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import y0\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y0(1.)\n&quot;</span>
    <span class="s0">&quot;0.08825696421567697\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate at several points:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y0(np.array([0.5, 2., 3.]))\n&quot;</span>
    <span class="s0">&quot;array([-0.44451873,  0.51037567,  0.37685001])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function from 0 to 10.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0., 10., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = y0(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, y)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_y0_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_y0_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_y0_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_y0_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_y0_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_y0_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_y0_ptr[2*0] = &lt;void*&gt;_func_y0</span>
<span class="s0">ufunc_y0_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;y0&quot;)</span>
<span class="s0">ufunc_y0_ptr[2*1] = &lt;void*&gt;_func_y0</span>
<span class="s0">ufunc_y0_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;y0&quot;)</span>
<span class="s0">ufunc_y0_data[0] = &amp;ufunc_y0_ptr[2*0]</span>
<span class="s0">ufunc_y0_data[1] = &amp;ufunc_y0_ptr[2*1]</span>
<span class="s0">y0 = np.PyUFunc_FromFuncAndData(ufunc_y0_loops, ufunc_y0_data, ufunc_y0_types, 2, 1, 1, 0, &quot;y0&quot;, ufunc_y0_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_y1_loops[2]</span>
<span class="s0">cdef void *ufunc_y1_ptr[4]</span>
<span class="s0">cdef void *ufunc_y1_data[2]</span>
<span class="s0">cdef char ufunc_y1_types[4]</span>
<span class="s0">cdef char *ufunc_y1_doc = (</span>
    <span class="s0">&quot;y1(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Bessel function of the second kind of order 1.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;Y : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the Bessel function of the second kind of order 1 at `x`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The domain is divided into the intervals [0, 8] and (8, infinity). In the\n&quot;</span>
    <span class="s0">&quot;first interval a 25 term Chebyshev expansion is used, and computing\n&quot;</span>
    <span class="s0">&quot;:math:`J_1` (the Bessel function of the first kind) is required. In the\n&quot;</span>
    <span class="s0">&quot;second, the asymptotic trigonometric representation is employed using two\n&quot;</span>
    <span class="s0">&quot;rational functions of degree 5/5.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is a wrapper for the Cephes [1]_ routine `y1`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;j1: Bessel function of the first kind of order 1\n&quot;</span>
    <span class="s0">&quot;yn: Bessel function of the second kind\n&quot;</span>
    <span class="s0">&quot;yv: Bessel function of the second kind\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Calculate the function at one point:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import y1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y1(1.)\n&quot;</span>
    <span class="s0">&quot;-0.7812128213002888\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Calculate at several points:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y1(np.array([0.5, 2., 3.]))\n&quot;</span>
    <span class="s0">&quot;array([-1.47147239, -0.10703243,  0.32467442])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the function from 0 to 10.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0., 10., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; y = y1(x)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.plot(x, y)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_y1_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_y1_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_y1_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_y1_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_y1_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_y1_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_y1_ptr[2*0] = &lt;void*&gt;_func_y1</span>
<span class="s0">ufunc_y1_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;y1&quot;)</span>
<span class="s0">ufunc_y1_ptr[2*1] = &lt;void*&gt;_func_y1</span>
<span class="s0">ufunc_y1_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;y1&quot;)</span>
<span class="s0">ufunc_y1_data[0] = &amp;ufunc_y1_ptr[2*0]</span>
<span class="s0">ufunc_y1_data[1] = &amp;ufunc_y1_ptr[2*1]</span>
<span class="s0">y1 = np.PyUFunc_FromFuncAndData(ufunc_y1_loops, ufunc_y1_data, ufunc_y1_types, 2, 1, 1, 0, &quot;y1&quot;, ufunc_y1_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_yn_loops[3]</span>
<span class="s0">cdef void *ufunc_yn_ptr[6]</span>
<span class="s0">cdef void *ufunc_yn_data[3]</span>
<span class="s0">cdef char ufunc_yn_types[9]</span>
<span class="s0">cdef char *ufunc_yn_doc = (</span>
    <span class="s0">&quot;yn(n, x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Bessel function of the second kind of integer order and real argument.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;n : array_like\n&quot;</span>
    <span class="s0">&quot;    Order (integer).\n&quot;</span>
    <span class="s0">&quot;x : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;Y : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the Bessel function, :math:`Y_n(x)`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;Wrapper for the Cephes [1]_ routine `yn`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function is evaluated by forward recurrence on `n`, starting with\n&quot;</span>
    <span class="s0">&quot;values computed by the Cephes routines `y0` and `y1`. If `n = 0` or 1,\n&quot;</span>
    <span class="s0">&quot;the routine for `y0` or `y1` is called directly.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;yv : For real order and real or complex argument.\n&quot;</span>
    <span class="s0">&quot;y0: faster implementation of this function for order 0\n&quot;</span>
    <span class="s0">&quot;y1: faster implementation of this function for order 1\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Cephes Mathematical Functions Library,\n&quot;</span>
    <span class="s0">&quot;       http://www.netlib.org/cephes/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Evaluate the function of order 0 at one point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import yn\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; yn(0, 1.)\n&quot;</span>
    <span class="s0">&quot;0.08825696421567697\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate the function at one point for different orders.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; yn(0, 1.), yn(1, 1.), yn(2, 1.)\n&quot;</span>
    <span class="s0">&quot;(0.08825696421567697, -0.7812128213002888, -1.6506826068162546)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The evaluation for different orders can be carried out in one call by\n&quot;</span>
    <span class="s0">&quot;providing a list or NumPy array as argument for the `v` parameter:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; yn([0, 1, 2], 1.)\n&quot;</span>
    <span class="s0">&quot;array([ 0.08825696, -0.78121282, -1.65068261])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate the function at several points for order 0 by providing an\n&quot;</span>
    <span class="s0">&quot;array for `z`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; points = np.array([0.5, 3., 8.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; yn(0, points)\n&quot;</span>
    <span class="s0">&quot;array([-0.44451873,  0.37685001,  0.22352149])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;If `z` is an array, the order parameter `v` must be broadcastable to\n&quot;</span>
    <span class="s0">&quot;the correct shape if different orders shall be computed in one call.\n&quot;</span>
    <span class="s0">&quot;To calculate the orders 0 and 1 for an 1D array:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; orders = np.array([[0], [1]])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; orders.shape\n&quot;</span>
    <span class="s0">&quot;(2, 1)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; yn(orders, points)\n&quot;</span>
    <span class="s0">&quot;array([[-0.44451873,  0.37685001,  0.22352149],\n&quot;</span>
    <span class="s0">&quot;       [-1.47147239,  0.32467442, -0.15806046]])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the functions of order 0 to 3 from 0 to 10.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0., 10., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for i in range(4):\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, yn(i, x), label=f'$Y_{i!r}$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_ylim(-3, 1)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_yn_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_id__As_ld_d</span>
<span class="s0">ufunc_yn_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_yn_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_yn_types[0] = &lt;char&gt;NPY_LONG</span>
<span class="s0">ufunc_yn_types[1] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_yn_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_yn_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_yn_types[4] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_yn_types[5] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_yn_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_yn_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_yn_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_yn_ptr[2*0] = &lt;void*&gt;_func_yn</span>
<span class="s0">ufunc_yn_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;yn&quot;)</span>
<span class="s0">ufunc_yn_ptr[2*1] = &lt;void*&gt;_func_yn_unsafe</span>
<span class="s0">ufunc_yn_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;yn&quot;)</span>
<span class="s0">ufunc_yn_ptr[2*2] = &lt;void*&gt;_func_yn_unsafe</span>
<span class="s0">ufunc_yn_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;yn&quot;)</span>
<span class="s0">ufunc_yn_data[0] = &amp;ufunc_yn_ptr[2*0]</span>
<span class="s0">ufunc_yn_data[1] = &amp;ufunc_yn_ptr[2*1]</span>
<span class="s0">ufunc_yn_data[2] = &amp;ufunc_yn_ptr[2*2]</span>
<span class="s0">yn = np.PyUFunc_FromFuncAndData(ufunc_yn_loops, ufunc_yn_data, ufunc_yn_types, 3, 2, 1, 0, &quot;yn&quot;, ufunc_yn_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_yv_loops[4]</span>
<span class="s0">cdef void *ufunc_yv_ptr[8]</span>
<span class="s0">cdef void *ufunc_yv_data[4]</span>
<span class="s0">cdef char ufunc_yv_types[12]</span>
<span class="s0">cdef char *ufunc_yv_doc = (</span>
    <span class="s0">&quot;yv(v, z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Bessel function of the second kind of real order and complex argument.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;v : array_like\n&quot;</span>
    <span class="s0">&quot;    Order (float).\n&quot;</span>
    <span class="s0">&quot;z : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float or complex).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;Y : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the Bessel function of the second kind, :math:`Y_v(x)`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;For positive `v` values, the computation is carried out using the\n&quot;</span>
    <span class="s0">&quot;AMOS [1]_ `zbesy` routine, which exploits the connection to the Hankel\n&quot;</span>
    <span class="s0">&quot;Bessel functions :math:`H_v^{(1)}` and :math:`H_v^{(2)}`,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: Y_v(z) = \\frac{1}{2\\imath} (H_v^{(1)} - H_v^{(2)}).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For negative `v` values the formula,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: Y_{-v}(z) = Y_v(z) \\cos(\\pi v) + J_v(z) \\sin(\\pi v)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;is used, where :math:`J_v(z)` is the Bessel function of the first kind,\n&quot;</span>
    <span class="s0">&quot;computed using the AMOS routine `zbesj`.  Note that the second term is\n&quot;</span>
    <span class="s0">&quot;exactly zero for integer `v`; to improve accuracy the second term is\n&quot;</span>
    <span class="s0">&quot;explicitly omitted for `v` values such that `v = floor(v)`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;yve : :math:`Y_v` with leading exponential behavior stripped off.\n&quot;</span>
    <span class="s0">&quot;y0: faster implementation of this function for order 0\n&quot;</span>
    <span class="s0">&quot;y1: faster implementation of this function for order 1\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Donald E. Amos, \&quot;AMOS, A Portable Package for Bessel Functions\n&quot;</span>
    <span class="s0">&quot;       of a Complex Argument and Nonnegative Order\&quot;,\n&quot;</span>
    <span class="s0">&quot;       http://netlib.org/amos/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Evaluate the function of order 0 at one point.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import yv\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; yv(0, 1.)\n&quot;</span>
    <span class="s0">&quot;0.088256964215677\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate the function at one point for different orders.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; yv(0, 1.), yv(1, 1.), yv(1.5, 1.)\n&quot;</span>
    <span class="s0">&quot;(0.088256964215677, -0.7812128213002889, -1.102495575160179)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The evaluation for different orders can be carried out in one call by\n&quot;</span>
    <span class="s0">&quot;providing a list or NumPy array as argument for the `v` parameter:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; yv([0, 1, 1.5], 1.)\n&quot;</span>
    <span class="s0">&quot;array([ 0.08825696, -0.78121282, -1.10249558])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Evaluate the function at several points for order 0 by providing an\n&quot;</span>
    <span class="s0">&quot;array for `z`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; points = np.array([0.5, 3., 8.])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; yv(0, points)\n&quot;</span>
    <span class="s0">&quot;array([-0.44451873,  0.37685001,  0.22352149])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;If `z` is an array, the order parameter `v` must be broadcastable to\n&quot;</span>
    <span class="s0">&quot;the correct shape if different orders shall be computed in one call.\n&quot;</span>
    <span class="s0">&quot;To calculate the orders 0 and 1 for an 1D array:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; orders = np.array([[0], [1]])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; orders.shape\n&quot;</span>
    <span class="s0">&quot;(2, 1)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; yv(orders, points)\n&quot;</span>
    <span class="s0">&quot;array([[-0.44451873,  0.37685001,  0.22352149],\n&quot;</span>
    <span class="s0">&quot;       [-1.47147239,  0.32467442, -0.15806046]])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Plot the functions of order 0 to 3 from 0 to 10.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import matplotlib.pyplot as plt\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; fig, ax = plt.subplots()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; x = np.linspace(0., 10., 1000)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; for i in range(4):\n&quot;</span>
    <span class="s0">&quot;...     ax.plot(x, yv(i, x), label=f'$Y_{i!r}$')\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.set_ylim(-3, 1)\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; ax.legend()\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; plt.show()&quot;)</span>
<span class="s0">ufunc_yv_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_yv_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_fF_F</span>
<span class="s0">ufunc_yv_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_yv_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_dD_D</span>
<span class="s0">ufunc_yv_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_yv_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_yv_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_yv_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_yv_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_yv_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_yv_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_yv_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_yv_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_yv_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_yv_types[10] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_yv_types[11] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_yv_ptr[2*0] = &lt;void*&gt;_func_cbesy_wrap_real</span>
<span class="s0">ufunc_yv_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;yv&quot;)</span>
<span class="s0">ufunc_yv_ptr[2*1] = &lt;void*&gt;_func_cbesy_wrap</span>
<span class="s0">ufunc_yv_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;yv&quot;)</span>
<span class="s0">ufunc_yv_ptr[2*2] = &lt;void*&gt;_func_cbesy_wrap_real</span>
<span class="s0">ufunc_yv_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;yv&quot;)</span>
<span class="s0">ufunc_yv_ptr[2*3] = &lt;void*&gt;_func_cbesy_wrap</span>
<span class="s0">ufunc_yv_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;yv&quot;)</span>
<span class="s0">ufunc_yv_data[0] = &amp;ufunc_yv_ptr[2*0]</span>
<span class="s0">ufunc_yv_data[1] = &amp;ufunc_yv_ptr[2*1]</span>
<span class="s0">ufunc_yv_data[2] = &amp;ufunc_yv_ptr[2*2]</span>
<span class="s0">ufunc_yv_data[3] = &amp;ufunc_yv_ptr[2*3]</span>
<span class="s0">yv = np.PyUFunc_FromFuncAndData(ufunc_yv_loops, ufunc_yv_data, ufunc_yv_types, 4, 2, 1, 0, &quot;yv&quot;, ufunc_yv_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_yve_loops[4]</span>
<span class="s0">cdef void *ufunc_yve_ptr[8]</span>
<span class="s0">cdef void *ufunc_yve_data[4]</span>
<span class="s0">cdef char ufunc_yve_types[12]</span>
<span class="s0">cdef char *ufunc_yve_doc = (</span>
    <span class="s0">&quot;yve(v, z, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Exponentially scaled Bessel function of the second kind of real order.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns the exponentially scaled Bessel function of the second\n&quot;</span>
    <span class="s0">&quot;kind of real order `v` at complex `z`::\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;    yve(v, z) = yv(v, z) * exp(-abs(z.imag))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;v : array_like\n&quot;</span>
    <span class="s0">&quot;    Order (float).\n&quot;</span>
    <span class="s0">&quot;z : array_like\n&quot;</span>
    <span class="s0">&quot;    Argument (float or complex).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;Y : scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Value of the exponentially scaled Bessel function.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;yv: Unscaled Bessel function of the second kind of real order.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Notes\n&quot;</span>
    <span class="s0">&quot;-----\n&quot;</span>
    <span class="s0">&quot;For positive `v` values, the computation is carried out using the\n&quot;</span>
    <span class="s0">&quot;AMOS [1]_ `zbesy` routine, which exploits the connection to the Hankel\n&quot;</span>
    <span class="s0">&quot;Bessel functions :math:`H_v^{(1)}` and :math:`H_v^{(2)}`,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: Y_v(z) = \\frac{1}{2\\imath} (H_v^{(1)} - H_v^{(2)}).\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For negative `v` values the formula,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: Y_{-v}(z) = Y_v(z) \\cos(\\pi v) + J_v(z) \\sin(\\pi v)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;is used, where :math:`J_v(z)` is the Bessel function of the first kind,\n&quot;</span>
    <span class="s0">&quot;computed using the AMOS routine `zbesj`.  Note that the second term is\n&quot;</span>
    <span class="s0">&quot;exactly zero for integer `v`; to improve accuracy the second term is\n&quot;</span>
    <span class="s0">&quot;explicitly omitted for `v` values such that `v = floor(v)`.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Exponentially scaled Bessel functions are useful for large `z`:\n&quot;</span>
    <span class="s0">&quot;for these, the unscaled Bessel functions can easily under-or overflow.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [1] Donald E. Amos, \&quot;AMOS, A Portable Package for Bessel Functions\n&quot;</span>
    <span class="s0">&quot;       of a Complex Argument and Nonnegative Order\&quot;,\n&quot;</span>
    <span class="s0">&quot;       http://netlib.org/amos/\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;Compare the output of `yv` and `yve` for large complex arguments for `z`\n&quot;</span>
    <span class="s0">&quot;by computing their values for order ``v=1`` at ``z=1000j``. We see that\n&quot;</span>
    <span class="s0">&quot;`yv` returns nan but `yve` returns a finite number:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import yv, yve\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; v = 1\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z = 1000j\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; yv(v, z), yve(v, z)\n&quot;</span>
    <span class="s0">&quot;((nan+nanj), (-0.012610930256928629+7.721967686709076e-19j))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;For real arguments for `z`, `yve` returns the same as `yv` up to\n&quot;</span>
    <span class="s0">&quot;floating point errors.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; v, z = 1, 1000\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; yv(v, z), yve(v, z)\n&quot;</span>
    <span class="s0">&quot;(-0.02478433129235178, -0.02478433129235179)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;The function can be evaluated for several orders at the same time by\n&quot;</span>
    <span class="s0">&quot;providing a list or NumPy array for `v`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; yve([1, 2, 3], 1j)\n&quot;</span>
    <span class="s0">&quot;array([-0.20791042+0.14096627j,  0.38053618-0.04993878j,\n&quot;</span>
    <span class="s0">&quot;       0.00815531-1.66311097j])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;In the same way, the function can be evaluated at several points in one\n&quot;</span>
    <span class="s0">&quot;call by providing a list or NumPy array for `z`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; yve(1, np.array([1j, 2j, 3j]))\n&quot;</span>
    <span class="s0">&quot;array([-0.20791042+0.14096627j, -0.21526929+0.01205044j,\n&quot;</span>
    <span class="s0">&quot;       -0.19682671+0.00127278j])\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;It is also possible to evaluate several orders at several points\n&quot;</span>
    <span class="s0">&quot;at the same time by providing arrays for `v` and `z` with\n&quot;</span>
    <span class="s0">&quot;broadcasting compatible shapes. Compute `yve` for two different orders\n&quot;</span>
    <span class="s0">&quot;`v` and three points `z` resulting in a 2x3 array.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; v = np.array([[1], [2]])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; z = np.array([3j, 4j, 5j])\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; v.shape, z.shape\n&quot;</span>
    <span class="s0">&quot;((2, 1), (3,))\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; yve(v, z)\n&quot;</span>
    <span class="s0">&quot;array([[-1.96826713e-01+1.27277544e-03j, -1.78750840e-01+1.45558819e-04j,\n&quot;</span>
    <span class="s0">&quot;        -1.63972267e-01+1.73494110e-05j],\n&quot;</span>
    <span class="s0">&quot;       [1.94960056e-03-1.11782545e-01j,  2.02902325e-04-1.17626501e-01j,\n&quot;</span>
    <span class="s0">&quot;        2.27727687e-05-1.17951906e-01j]])&quot;)</span>
<span class="s0">ufunc_yve_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_ff_f</span>
<span class="s0">ufunc_yve_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_fF_F</span>
<span class="s0">ufunc_yve_loops[2] = &lt;np.PyUFuncGenericFunction&gt;loop_d_dd__As_dd_d</span>
<span class="s0">ufunc_yve_loops[3] = &lt;np.PyUFuncGenericFunction&gt;loop_D_dD__As_dD_D</span>
<span class="s0">ufunc_yve_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_yve_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_yve_types[2] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_yve_types[3] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_yve_types[4] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_yve_types[5] = &lt;char&gt;NPY_CFLOAT</span>
<span class="s0">ufunc_yve_types[6] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_yve_types[7] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_yve_types[8] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_yve_types[9] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_yve_types[10] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_yve_types[11] = &lt;char&gt;NPY_CDOUBLE</span>
<span class="s0">ufunc_yve_ptr[2*0] = &lt;void*&gt;_func_cbesy_wrap_e_real</span>
<span class="s0">ufunc_yve_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;yve&quot;)</span>
<span class="s0">ufunc_yve_ptr[2*1] = &lt;void*&gt;_func_cbesy_wrap_e</span>
<span class="s0">ufunc_yve_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;yve&quot;)</span>
<span class="s0">ufunc_yve_ptr[2*2] = &lt;void*&gt;_func_cbesy_wrap_e_real</span>
<span class="s0">ufunc_yve_ptr[2*2+1] = &lt;void*&gt;(&lt;char*&gt;&quot;yve&quot;)</span>
<span class="s0">ufunc_yve_ptr[2*3] = &lt;void*&gt;_func_cbesy_wrap_e</span>
<span class="s0">ufunc_yve_ptr[2*3+1] = &lt;void*&gt;(&lt;char*&gt;&quot;yve&quot;)</span>
<span class="s0">ufunc_yve_data[0] = &amp;ufunc_yve_ptr[2*0]</span>
<span class="s0">ufunc_yve_data[1] = &amp;ufunc_yve_ptr[2*1]</span>
<span class="s0">ufunc_yve_data[2] = &amp;ufunc_yve_ptr[2*2]</span>
<span class="s0">ufunc_yve_data[3] = &amp;ufunc_yve_ptr[2*3]</span>
<span class="s0">yve = np.PyUFunc_FromFuncAndData(ufunc_yve_loops, ufunc_yve_data, ufunc_yve_types, 4, 2, 1, 0, &quot;yve&quot;, ufunc_yve_doc, 0)</span>

<span class="s0">cdef np.PyUFuncGenericFunction ufunc_zetac_loops[2]</span>
<span class="s0">cdef void *ufunc_zetac_ptr[4]</span>
<span class="s0">cdef void *ufunc_zetac_data[2]</span>
<span class="s0">cdef char ufunc_zetac_types[4]</span>
<span class="s0">cdef char *ufunc_zetac_doc = (</span>
    <span class="s0">&quot;zetac(x, out=None)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Riemann zeta function minus 1.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;This function is defined as\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;.. math:: \\zeta(x) = \\sum_{k=2}^{\\infty} 1 / k^x,\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;where ``x &gt; 1``.  For ``x &lt; 1`` the analytic continuation is\n&quot;</span>
    <span class="s0">&quot;computed. For more information on the Riemann zeta function, see\n&quot;</span>
    <span class="s0">&quot;[dlmf]_.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Parameters\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;x : array_like of float\n&quot;</span>
    <span class="s0">&quot;    Values at which to compute zeta(x) - 1 (must be real).\n&quot;</span>
    <span class="s0">&quot;out : ndarray, optional\n&quot;</span>
    <span class="s0">&quot;    Optional output array for the function results\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Returns\n&quot;</span>
    <span class="s0">&quot;-------\n&quot;</span>
    <span class="s0">&quot;scalar or ndarray\n&quot;</span>
    <span class="s0">&quot;    Values of zeta(x) - 1.\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;See Also\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;zeta\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Examples\n&quot;</span>
    <span class="s0">&quot;--------\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; import numpy as np\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; from scipy.special import zetac, zeta\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Some special values:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; zetac(2), np.pi**2/6 - 1\n&quot;</span>
    <span class="s0">&quot;(0.64493406684822641, 0.6449340668482264)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; zetac(-1), -1.0/12 - 1\n&quot;</span>
    <span class="s0">&quot;(-1.0833333333333333, -1.0833333333333333)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;Compare ``zetac(x)`` to ``zeta(x) - 1`` for large `x`:\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;&gt;&gt;&gt; zetac(60), zeta(60) - 1\n&quot;</span>
    <span class="s0">&quot;(8.673617380119933e-19, 0.0)\n&quot;</span>
    <span class="s0">&quot;\n&quot;</span>
    <span class="s0">&quot;References\n&quot;</span>
    <span class="s0">&quot;----------\n&quot;</span>
    <span class="s0">&quot;.. [dlmf] NIST Digital Library of Mathematical Functions\n&quot;</span>
    <span class="s0">&quot;          https://dlmf.nist.gov/25&quot;)</span>
<span class="s0">ufunc_zetac_loops[0] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_f_f</span>
<span class="s0">ufunc_zetac_loops[1] = &lt;np.PyUFuncGenericFunction&gt;loop_d_d__As_d_d</span>
<span class="s0">ufunc_zetac_types[0] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_zetac_types[1] = &lt;char&gt;NPY_FLOAT</span>
<span class="s0">ufunc_zetac_types[2] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_zetac_types[3] = &lt;char&gt;NPY_DOUBLE</span>
<span class="s0">ufunc_zetac_ptr[2*0] = &lt;void*&gt;_func_zetac</span>
<span class="s0">ufunc_zetac_ptr[2*0+1] = &lt;void*&gt;(&lt;char*&gt;&quot;zetac&quot;)</span>
<span class="s0">ufunc_zetac_ptr[2*1] = &lt;void*&gt;_func_zetac</span>
<span class="s0">ufunc_zetac_ptr[2*1+1] = &lt;void*&gt;(&lt;char*&gt;&quot;zetac&quot;)</span>
<span class="s0">ufunc_zetac_data[0] = &amp;ufunc_zetac_ptr[2*0]</span>
<span class="s0">ufunc_zetac_data[1] = &amp;ufunc_zetac_ptr[2*1]</span>
<span class="s0">zetac = np.PyUFunc_FromFuncAndData(ufunc_zetac_loops, ufunc_zetac_data, ufunc_zetac_types, 2, 1, 1, 0, &quot;zetac&quot;, ufunc_zetac_doc, 0)</span>

<span class="s0">#</span>
<span class="s0"># Aliases</span>
<span class="s0">#</span>
<span class="s0">jn = jv</span>
</pre>
</body>
</html>