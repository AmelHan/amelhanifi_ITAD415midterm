<html>
<head>
<title>count_model.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #6a8759;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
count_model.py</font>
</center></td></tr></table>
<pre><span class="s0">__all__ = [</span><span class="s1">&quot;ZeroInflatedPoisson&quot;</span><span class="s2">, </span><span class="s1">&quot;ZeroInflatedGeneralizedPoisson&quot;</span><span class="s2">,</span>
           <span class="s1">&quot;ZeroInflatedNegativeBinomialP&quot;</span><span class="s0">]</span>

<span class="s2">import </span><span class="s0">warnings</span>
<span class="s2">import </span><span class="s0">numpy </span><span class="s2">as </span><span class="s0">np</span>
<span class="s2">import </span><span class="s0">statsmodels.base.model </span><span class="s2">as </span><span class="s0">base</span>
<span class="s2">import </span><span class="s0">statsmodels.base.wrapper </span><span class="s2">as </span><span class="s0">wrap</span>
<span class="s2">import </span><span class="s0">statsmodels.regression.linear_model </span><span class="s2">as </span><span class="s0">lm</span>
<span class="s2">from </span><span class="s0">statsmodels.discrete.discrete_model </span><span class="s2">import </span><span class="s0">(DiscreteModel</span><span class="s2">, </span><span class="s0">CountModel</span><span class="s2">,</span>
                                                 <span class="s0">Poisson</span><span class="s2">, </span><span class="s0">Logit</span><span class="s2">, </span><span class="s0">CountResults</span><span class="s2">,</span>
                                                 <span class="s0">L1CountResults</span><span class="s2">, </span><span class="s0">Probit</span><span class="s2">,</span>
                                                 <span class="s0">_discrete_results_docs</span><span class="s2">,</span>
                                                 <span class="s0">_validate_l1_method</span><span class="s2">,</span>
                                                 <span class="s0">GeneralizedPoisson</span><span class="s2">,</span>
                                                 <span class="s0">NegativeBinomialP)</span>
<span class="s2">from </span><span class="s0">statsmodels.distributions </span><span class="s2">import </span><span class="s0">zipoisson</span><span class="s2">, </span><span class="s0">zigenpoisson</span><span class="s2">, </span><span class="s0">zinegbin</span>
<span class="s2">from </span><span class="s0">statsmodels.tools.numdiff </span><span class="s2">import </span><span class="s0">approx_fprime</span><span class="s2">, </span><span class="s0">approx_hess</span>
<span class="s2">from </span><span class="s0">statsmodels.tools.decorators </span><span class="s2">import </span><span class="s0">cache_readonly</span>
<span class="s2">from </span><span class="s0">statsmodels.tools.sm_exceptions </span><span class="s2">import </span><span class="s0">ConvergenceWarning</span>
<span class="s2">from </span><span class="s0">statsmodels.compat.pandas </span><span class="s2">import </span><span class="s0">Appender</span>


<span class="s0">_doc_zi_params = </span><span class="s1">&quot;&quot;&quot; 
    exog_infl : array_like or None 
        Explanatory variables for the binary inflation model, i.e. for 
        mixing probability model. If None, then a constant is used. 
    offset : array_like 
        Offset is added to the linear prediction with coefficient equal to 1. 
    exposure : array_like 
        Log(exposure) is added to the linear prediction with coefficient 
        equal to 1. 
    inflation : {'logit', 'probit'} 
        The model for the zero inflation, either Logit (default) or Probit 
    &quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s0">GenericZeroInflated(CountModel):</span>
    <span class="s0">__doc__ = </span><span class="s1">&quot;&quot;&quot; 
    Generic Zero Inflated Model 
 
    %(params)s 
    %(extra_params)s 
 
    Attributes 
    ---------- 
    endog : ndarray 
        A reference to the endogenous response variable 
    exog : ndarray 
        A reference to the exogenous design. 
    exog_infl : ndarray 
        A reference to the zero-inflated exogenous design. 
    &quot;&quot;&quot; </span><span class="s0">% {</span><span class="s1">'params' </span><span class="s0">: base._model_params_doc</span><span class="s2">,</span>
           <span class="s1">'extra_params' </span><span class="s0">: _doc_zi_params + base._missing_param_doc}</span>

    <span class="s2">def </span><span class="s0">__init__(self</span><span class="s2">, </span><span class="s0">endog</span><span class="s2">, </span><span class="s0">exog</span><span class="s2">, </span><span class="s0">exog_infl=</span><span class="s2">None, </span><span class="s0">offset=</span><span class="s2">None,</span>
                 <span class="s0">inflation=</span><span class="s1">'logit'</span><span class="s2">, </span><span class="s0">exposure=</span><span class="s2">None, </span><span class="s0">missing=</span><span class="s1">'none'</span><span class="s2">, </span><span class="s0">**kwargs):</span>
        <span class="s0">super(GenericZeroInflated</span><span class="s2">, </span><span class="s0">self).__init__(endog</span><span class="s2">, </span><span class="s0">exog</span><span class="s2">, </span><span class="s0">offset=offset</span><span class="s2">,</span>
                                                  <span class="s0">exposure=exposure</span><span class="s2">,</span>
                                                  <span class="s0">missing=missing</span><span class="s2">, </span><span class="s0">**kwargs)</span>

        <span class="s2">if </span><span class="s0">exog_infl </span><span class="s2">is None</span><span class="s0">:</span>
            <span class="s0">self.k_inflate = </span><span class="s3">1</span>
            <span class="s0">self._no_exog_infl = </span><span class="s2">True</span>
            <span class="s0">self.exog_infl = np.ones((endog.size</span><span class="s2">, </span><span class="s0">self.k_inflate)</span><span class="s2">,</span>
                                     <span class="s0">dtype=np.float64)</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">self.exog_infl = exog_infl</span>
            <span class="s0">self.k_inflate = exog_infl.shape[</span><span class="s3">1</span><span class="s0">]</span>
            <span class="s0">self._no_exog_infl = </span><span class="s2">False</span>

        <span class="s2">if </span><span class="s0">len(exog.shape) == </span><span class="s3">1</span><span class="s0">:</span>
            <span class="s0">self.k_exog = </span><span class="s3">1</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">self.k_exog = exog.shape[</span><span class="s3">1</span><span class="s0">]</span>

        <span class="s0">self.infl = inflation</span>
        <span class="s2">if </span><span class="s0">inflation == </span><span class="s1">'logit'</span><span class="s0">:</span>
            <span class="s0">self.model_infl = Logit(np.zeros(self.exog_infl.shape[</span><span class="s3">0</span><span class="s0">])</span><span class="s2">,</span>
                                    <span class="s0">self.exog_infl)</span>
            <span class="s0">self._hessian_inflate = self._hessian_logit</span>
        <span class="s2">elif </span><span class="s0">inflation == </span><span class="s1">'probit'</span><span class="s0">:</span>
            <span class="s0">self.model_infl = Probit(np.zeros(self.exog_infl.shape[</span><span class="s3">0</span><span class="s0">])</span><span class="s2">,</span>
                                    <span class="s0">self.exog_infl)</span>
            <span class="s0">self._hessian_inflate = self._hessian_probit</span>

        <span class="s2">else</span><span class="s0">:</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;inflation == %s, which is not handled&quot;</span>
                             <span class="s0">% inflation)</span>

        <span class="s0">self.inflation = inflation</span>
        <span class="s0">self.k_extra = self.k_inflate</span>

        <span class="s2">if </span><span class="s0">len(self.exog) != len(self.exog_infl):</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">'exog and exog_infl have different number of'</span>
                             <span class="s1">'observation. `missing` handling is not supported'</span><span class="s0">)</span>

        <span class="s0">infl_names = [</span><span class="s1">'inflate_%s' </span><span class="s0">% i </span><span class="s2">for </span><span class="s0">i </span><span class="s2">in </span><span class="s0">self.model_infl.data.param_names]</span>
        <span class="s0">self.exog_names[:] = infl_names + list(self.exog_names)</span>
        <span class="s0">self.exog_infl = np.asarray(self.exog_infl</span><span class="s2">, </span><span class="s0">dtype=np.float64)</span>

        <span class="s0">self._init_keys.extend([</span><span class="s1">'exog_infl'</span><span class="s2">, </span><span class="s1">'inflation'</span><span class="s0">])</span>
        <span class="s0">self._null_drop_keys = [</span><span class="s1">'exog_infl'</span><span class="s0">]</span>

    <span class="s2">def </span><span class="s0">_get_exogs(self):</span>
        <span class="s4">&quot;&quot;&quot;list of exogs, for internal use in post-estimation 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s0">(self.exog</span><span class="s2">, </span><span class="s0">self.exog_infl)</span>

    <span class="s2">def </span><span class="s0">loglike(self</span><span class="s2">, </span><span class="s0">params):</span>
        <span class="s4">&quot;&quot;&quot; 
        Loglikelihood of Generic Zero Inflated model. 
 
        Parameters 
        ---------- 
        params : array_like 
            The parameters of the model. 
 
        Returns 
        ------- 
        loglike : float 
            The log-likelihood function of the model evaluated at `params`. 
            See notes. 
 
        Notes 
        ----- 
        .. math:: \\ln L=\\sum_{y_{i}=0}\\ln(w_{i}+(1-w_{i})*P_{main\\_model})+ 
            \\sum_{y_{i}&gt;0}(\\ln(1-w_{i})+L_{main\\_model}) 
            where P - pdf of main model, L - loglike function of main model. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s0">np.sum(self.loglikeobs(params))</span>

    <span class="s2">def </span><span class="s0">loglikeobs(self</span><span class="s2">, </span><span class="s0">params):</span>
        <span class="s4">&quot;&quot;&quot; 
        Loglikelihood for observations of Generic Zero Inflated model. 
 
        Parameters 
        ---------- 
        params : array_like 
            The parameters of the model. 
 
        Returns 
        ------- 
        loglike : ndarray 
            The log likelihood for each observation of the model evaluated 
            at `params`. See Notes for definition. 
 
        Notes 
        ----- 
        .. math:: \\ln L=\\ln(w_{i}+(1-w_{i})*P_{main\\_model})+ 
            \\ln(1-w_{i})+L_{main\\_model} 
            where P - pdf of main model, L - loglike function of main model. 
 
        for observations :math:`i=1,...,n` 
        &quot;&quot;&quot;</span>
        <span class="s0">params_infl = params[:self.k_inflate]</span>
        <span class="s0">params_main = params[self.k_inflate:]</span>

        <span class="s0">y = self.endog</span>
        <span class="s0">w = self.model_infl.predict(params_infl)</span>

        <span class="s0">w = np.clip(w</span><span class="s2">, </span><span class="s0">np.finfo(float).eps</span><span class="s2">, </span><span class="s3">1 </span><span class="s0">- np.finfo(float).eps)</span>
        <span class="s0">llf_main = self.model_main.loglikeobs(params_main)</span>
        <span class="s0">zero_idx = np.nonzero(y == </span><span class="s3">0</span><span class="s0">)[</span><span class="s3">0</span><span class="s0">]</span>
        <span class="s0">nonzero_idx = np.nonzero(y)[</span><span class="s3">0</span><span class="s0">]</span>

        <span class="s0">llf = np.zeros_like(y</span><span class="s2">, </span><span class="s0">dtype=np.float64)</span>
        <span class="s0">llf[zero_idx] = (np.log(w[zero_idx] +</span>
            <span class="s0">(</span><span class="s3">1 </span><span class="s0">- w[zero_idx]) * np.exp(llf_main[zero_idx])))</span>
        <span class="s0">llf[nonzero_idx] = np.log(</span><span class="s3">1 </span><span class="s0">- w[nonzero_idx]) + llf_main[nonzero_idx]</span>

        <span class="s2">return </span><span class="s0">llf</span>

    <span class="s0">@Appender(DiscreteModel.fit.__doc__)</span>
    <span class="s2">def </span><span class="s0">fit(self</span><span class="s2">, </span><span class="s0">start_params=</span><span class="s2">None, </span><span class="s0">method=</span><span class="s1">'bfgs'</span><span class="s2">, </span><span class="s0">maxiter=</span><span class="s3">35</span><span class="s2">,</span>
            <span class="s0">full_output=</span><span class="s3">1</span><span class="s2">, </span><span class="s0">disp=</span><span class="s3">1</span><span class="s2">, </span><span class="s0">callback=</span><span class="s2">None,</span>
            <span class="s0">cov_type=</span><span class="s1">'nonrobust'</span><span class="s2">, </span><span class="s0">cov_kwds=</span><span class="s2">None, </span><span class="s0">use_t=</span><span class="s2">None, </span><span class="s0">**kwargs):</span>
        <span class="s2">if </span><span class="s0">start_params </span><span class="s2">is None</span><span class="s0">:</span>
            <span class="s0">offset = getattr(self</span><span class="s2">, </span><span class="s1">&quot;offset&quot;</span><span class="s2">, </span><span class="s3">0</span><span class="s0">) + getattr(self</span><span class="s2">, </span><span class="s1">&quot;exposure&quot;</span><span class="s2">, </span><span class="s3">0</span><span class="s0">)</span>
            <span class="s2">if </span><span class="s0">np.size(offset) == </span><span class="s3">1 </span><span class="s2">and </span><span class="s0">offset == </span><span class="s3">0</span><span class="s0">:</span>
                <span class="s0">offset = </span><span class="s2">None</span>
            <span class="s0">start_params = self._get_start_params()</span>

        <span class="s2">if </span><span class="s0">callback </span><span class="s2">is None</span><span class="s0">:</span>
            <span class="s5"># work around perfect separation callback #3895</span>
            <span class="s0">callback = </span><span class="s2">lambda </span><span class="s0">*x: x</span>

        <span class="s0">mlefit = super(GenericZeroInflated</span><span class="s2">, </span><span class="s0">self).fit(start_params=start_params</span><span class="s2">,</span>
                       <span class="s0">maxiter=maxiter</span><span class="s2">, </span><span class="s0">disp=disp</span><span class="s2">, </span><span class="s0">method=method</span><span class="s2">,</span>
                       <span class="s0">full_output=full_output</span><span class="s2">, </span><span class="s0">callback=callback</span><span class="s2">,</span>
                       <span class="s0">**kwargs)</span>

        <span class="s0">zipfit = self.result_class(self</span><span class="s2">, </span><span class="s0">mlefit._results)</span>
        <span class="s0">result = self.result_class_wrapper(zipfit)</span>

        <span class="s2">if </span><span class="s0">cov_kwds </span><span class="s2">is None</span><span class="s0">:</span>
            <span class="s0">cov_kwds = {}</span>

        <span class="s0">result._get_robustcov_results(cov_type=cov_type</span><span class="s2">,</span>
                                      <span class="s0">use_self=</span><span class="s2">True, </span><span class="s0">use_t=use_t</span><span class="s2">, </span><span class="s0">**cov_kwds)</span>
        <span class="s2">return </span><span class="s0">result</span>

    <span class="s0">@Appender(DiscreteModel.fit_regularized.__doc__)</span>
    <span class="s2">def </span><span class="s0">fit_regularized(self</span><span class="s2">, </span><span class="s0">start_params=</span><span class="s2">None, </span><span class="s0">method=</span><span class="s1">'l1'</span><span class="s2">,</span>
            <span class="s0">maxiter=</span><span class="s1">'defined_by_method'</span><span class="s2">, </span><span class="s0">full_output=</span><span class="s3">1</span><span class="s2">, </span><span class="s0">disp=</span><span class="s3">1</span><span class="s2">, </span><span class="s0">callback=</span><span class="s2">None,</span>
            <span class="s0">alpha=</span><span class="s3">0</span><span class="s2">, </span><span class="s0">trim_mode=</span><span class="s1">'auto'</span><span class="s2">, </span><span class="s0">auto_trim_tol=</span><span class="s3">0.01</span><span class="s2">, </span><span class="s0">size_trim_tol=</span><span class="s3">1e-4</span><span class="s2">,</span>
            <span class="s0">qc_tol=</span><span class="s3">0.03</span><span class="s2">, </span><span class="s0">**kwargs):</span>

        <span class="s0">_validate_l1_method(method)</span>

        <span class="s2">if </span><span class="s0">np.size(alpha) == </span><span class="s3">1 </span><span class="s2">and </span><span class="s0">alpha != </span><span class="s3">0</span><span class="s0">:</span>
            <span class="s0">k_params = self.k_exog + self.k_inflate</span>
            <span class="s0">alpha = alpha * np.ones(k_params)</span>

        <span class="s0">extra = self.k_extra - self.k_inflate</span>
        <span class="s0">alpha_p = alpha[:-(self.k_extra - extra)] </span><span class="s2">if </span><span class="s0">(self.k_extra</span>
            <span class="s2">and </span><span class="s0">np.size(alpha) &gt; </span><span class="s3">1</span><span class="s0">) </span><span class="s2">else </span><span class="s0">alpha</span>
        <span class="s2">if </span><span class="s0">start_params </span><span class="s2">is None</span><span class="s0">:</span>
            <span class="s0">offset = getattr(self</span><span class="s2">, </span><span class="s1">&quot;offset&quot;</span><span class="s2">, </span><span class="s3">0</span><span class="s0">) + getattr(self</span><span class="s2">, </span><span class="s1">&quot;exposure&quot;</span><span class="s2">, </span><span class="s3">0</span><span class="s0">)</span>
            <span class="s2">if </span><span class="s0">np.size(offset) == </span><span class="s3">1 </span><span class="s2">and </span><span class="s0">offset == </span><span class="s3">0</span><span class="s0">:</span>
                <span class="s0">offset = </span><span class="s2">None</span>
            <span class="s0">start_params = self.model_main.fit_regularized(</span>
                <span class="s0">start_params=start_params</span><span class="s2">, </span><span class="s0">method=method</span><span class="s2">, </span><span class="s0">maxiter=maxiter</span><span class="s2">,</span>
                <span class="s0">full_output=full_output</span><span class="s2">, </span><span class="s0">disp=</span><span class="s3">0</span><span class="s2">, </span><span class="s0">callback=callback</span><span class="s2">,</span>
                <span class="s0">alpha=alpha_p</span><span class="s2">, </span><span class="s0">trim_mode=trim_mode</span><span class="s2">, </span><span class="s0">auto_trim_tol=auto_trim_tol</span><span class="s2">,</span>
                <span class="s0">size_trim_tol=size_trim_tol</span><span class="s2">, </span><span class="s0">qc_tol=qc_tol</span><span class="s2">, </span><span class="s0">**kwargs).params</span>
            <span class="s0">start_params = np.append(np.ones(self.k_inflate)</span><span class="s2">, </span><span class="s0">start_params)</span>
        <span class="s0">cntfit = super(CountModel</span><span class="s2">, </span><span class="s0">self).fit_regularized(</span>
                <span class="s0">start_params=start_params</span><span class="s2">, </span><span class="s0">method=method</span><span class="s2">, </span><span class="s0">maxiter=maxiter</span><span class="s2">,</span>
                <span class="s0">full_output=full_output</span><span class="s2">, </span><span class="s0">disp=disp</span><span class="s2">, </span><span class="s0">callback=callback</span><span class="s2">,</span>
                <span class="s0">alpha=alpha</span><span class="s2">, </span><span class="s0">trim_mode=trim_mode</span><span class="s2">, </span><span class="s0">auto_trim_tol=auto_trim_tol</span><span class="s2">,</span>
                <span class="s0">size_trim_tol=size_trim_tol</span><span class="s2">, </span><span class="s0">qc_tol=qc_tol</span><span class="s2">, </span><span class="s0">**kwargs)</span>

        <span class="s0">discretefit = self.result_class_reg(self</span><span class="s2">, </span><span class="s0">cntfit)</span>
        <span class="s2">return </span><span class="s0">self.result_class_reg_wrapper(discretefit)</span>

    <span class="s2">def </span><span class="s0">score_obs(self</span><span class="s2">, </span><span class="s0">params):</span>
        <span class="s4">&quot;&quot;&quot; 
        Generic Zero Inflated model score (gradient) vector of the log-likelihood 
 
        Parameters 
        ---------- 
        params : array_like 
            The parameters of the model 
 
        Returns 
        ------- 
        score : ndarray, 1-D 
            The score vector of the model, i.e. the first derivative of the 
            loglikelihood function, evaluated at `params` 
        &quot;&quot;&quot;</span>
        <span class="s0">params_infl = params[:self.k_inflate]</span>
        <span class="s0">params_main = params[self.k_inflate:]</span>

        <span class="s0">y = self.endog</span>
        <span class="s0">w = self.model_infl.predict(params_infl)</span>
        <span class="s0">w = np.clip(w</span><span class="s2">, </span><span class="s0">np.finfo(float).eps</span><span class="s2">, </span><span class="s3">1 </span><span class="s0">- np.finfo(float).eps)</span>
        <span class="s0">score_main = self.model_main.score_obs(params_main)</span>
        <span class="s0">llf_main = self.model_main.loglikeobs(params_main)</span>
        <span class="s0">llf = self.loglikeobs(params)</span>
        <span class="s0">zero_idx = np.nonzero(y == </span><span class="s3">0</span><span class="s0">)[</span><span class="s3">0</span><span class="s0">]</span>
        <span class="s0">nonzero_idx = np.nonzero(y)[</span><span class="s3">0</span><span class="s0">]</span>

        <span class="s0">mu = self.model_main.predict(params_main)</span>

        <span class="s5"># TODO: need to allow for complex to use CS numerical derivatives</span>
        <span class="s0">dldp = np.zeros((self.exog.shape[</span><span class="s3">0</span><span class="s0">]</span><span class="s2">, </span><span class="s0">self.k_exog)</span><span class="s2">, </span><span class="s0">dtype=np.float64)</span>
        <span class="s0">dldw = np.zeros_like(self.exog_infl</span><span class="s2">, </span><span class="s0">dtype=np.float64)</span>

        <span class="s0">dldp[zero_idx</span><span class="s2">,</span><span class="s0">:] = (score_main[zero_idx].T *</span>
                     <span class="s0">(</span><span class="s3">1 </span><span class="s0">- (w[zero_idx]) / np.exp(llf[zero_idx]))).T</span>
        <span class="s0">dldp[nonzero_idx</span><span class="s2">,</span><span class="s0">:] = score_main[nonzero_idx]</span>

        <span class="s2">if </span><span class="s0">self.inflation == </span><span class="s1">'logit'</span><span class="s0">:</span>
            <span class="s0">dldw[zero_idx</span><span class="s2">,</span><span class="s0">:] =  (self.exog_infl[zero_idx].T * w[zero_idx] *</span>
                                 <span class="s0">(</span><span class="s3">1 </span><span class="s0">- w[zero_idx]) *</span>
                                 <span class="s0">(</span><span class="s3">1 </span><span class="s0">- np.exp(llf_main[zero_idx])) /</span>
                                  <span class="s0">np.exp(llf[zero_idx])).T</span>
            <span class="s0">dldw[nonzero_idx</span><span class="s2">,</span><span class="s0">:] = -(self.exog_infl[nonzero_idx].T *</span>
                                    <span class="s0">w[nonzero_idx]).T</span>
        <span class="s2">elif </span><span class="s0">self.inflation == </span><span class="s1">'probit'</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">approx_fprime(params</span><span class="s2">, </span><span class="s0">self.loglikeobs)</span>

        <span class="s2">return </span><span class="s0">np.hstack((dldw</span><span class="s2">, </span><span class="s0">dldp))</span>

    <span class="s2">def </span><span class="s0">score(self</span><span class="s2">, </span><span class="s0">params):</span>
        <span class="s2">return </span><span class="s0">self.score_obs(params).sum(</span><span class="s3">0</span><span class="s0">)</span>

    <span class="s2">def </span><span class="s0">_hessian_main(self</span><span class="s2">, </span><span class="s0">params):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s0">_hessian_logit(self</span><span class="s2">, </span><span class="s0">params):</span>
        <span class="s0">params_infl = params[:self.k_inflate]</span>
        <span class="s0">params_main = params[self.k_inflate:]</span>

        <span class="s0">y = self.endog</span>
        <span class="s0">w = self.model_infl.predict(params_infl)</span>
        <span class="s0">w = np.clip(w</span><span class="s2">, </span><span class="s0">np.finfo(float).eps</span><span class="s2">, </span><span class="s3">1 </span><span class="s0">- np.finfo(float).eps)</span>
        <span class="s0">score_main = self.model_main.score_obs(params_main)</span>
        <span class="s0">llf_main = self.model_main.loglikeobs(params_main)</span>
        <span class="s0">llf = self.loglikeobs(params)</span>
        <span class="s0">zero_idx = np.nonzero(y == </span><span class="s3">0</span><span class="s0">)[</span><span class="s3">0</span><span class="s0">]</span>
        <span class="s0">nonzero_idx = np.nonzero(y)[</span><span class="s3">0</span><span class="s0">]</span>

        <span class="s0">hess_arr = np.zeros((self.k_inflate</span><span class="s2">, </span><span class="s0">self.k_exog + self.k_inflate))</span>

        <span class="s0">pmf = np.exp(llf)</span>

        <span class="s5">#d2l/dw2</span>
        <span class="s2">for </span><span class="s0">i </span><span class="s2">in </span><span class="s0">range(self.k_inflate):</span>
            <span class="s2">for </span><span class="s0">j </span><span class="s2">in </span><span class="s0">range(i</span><span class="s2">, </span><span class="s0">-</span><span class="s3">1</span><span class="s2">, </span><span class="s0">-</span><span class="s3">1</span><span class="s0">):</span>
                <span class="s0">hess_arr[i</span><span class="s2">, </span><span class="s0">j] = ((</span>
                    <span class="s0">self.exog_infl[zero_idx</span><span class="s2">, </span><span class="s0">i] * self.exog_infl[zero_idx</span><span class="s2">, </span><span class="s0">j] *</span>
                    <span class="s0">(w[zero_idx] * (</span><span class="s3">1 </span><span class="s0">- w[zero_idx]) * ((</span><span class="s3">1 </span><span class="s0">-</span>
                    <span class="s0">np.exp(llf_main[zero_idx])) * (</span><span class="s3">1 </span><span class="s0">- </span><span class="s3">2 </span><span class="s0">* w[zero_idx]) *</span>
                    <span class="s0">np.exp(llf[zero_idx]) - (w[zero_idx] - w[zero_idx]**</span><span class="s3">2</span><span class="s0">) *</span>
                    <span class="s0">(</span><span class="s3">1 </span><span class="s0">- np.exp(llf_main[zero_idx]))**</span><span class="s3">2</span><span class="s0">) /</span>
                    <span class="s0">pmf[zero_idx]**</span><span class="s3">2</span><span class="s0">)).sum() -</span>
                    <span class="s0">(self.exog_infl[nonzero_idx</span><span class="s2">, </span><span class="s0">i] * self.exog_infl[nonzero_idx</span><span class="s2">, </span><span class="s0">j] *</span>
                    <span class="s0">w[nonzero_idx] * (</span><span class="s3">1 </span><span class="s0">- w[nonzero_idx])).sum())</span>

        <span class="s5">#d2l/dpdw</span>
        <span class="s2">for </span><span class="s0">i </span><span class="s2">in </span><span class="s0">range(self.k_inflate):</span>
            <span class="s2">for </span><span class="s0">j </span><span class="s2">in </span><span class="s0">range(self.k_exog):</span>
                <span class="s0">hess_arr[i</span><span class="s2">, </span><span class="s0">j + self.k_inflate] = -(score_main[zero_idx</span><span class="s2">, </span><span class="s0">j] *</span>
                    <span class="s0">w[zero_idx] * (</span><span class="s3">1 </span><span class="s0">- w[zero_idx]) *</span>
                    <span class="s0">self.exog_infl[zero_idx</span><span class="s2">, </span><span class="s0">i] / pmf[zero_idx]).sum()</span>

        <span class="s2">return </span><span class="s0">hess_arr</span>

    <span class="s2">def </span><span class="s0">_hessian_probit(self</span><span class="s2">, </span><span class="s0">params):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s0">hessian(self</span><span class="s2">, </span><span class="s0">params):</span>
        <span class="s4">&quot;&quot;&quot; 
        Generic Zero Inflated model Hessian matrix of the loglikelihood 
 
        Parameters 
        ---------- 
        params : array_like 
            The parameters of the model 
 
        Returns 
        ------- 
        hess : ndarray, (k_vars, k_vars) 
            The Hessian, second derivative of loglikelihood function, 
            evaluated at `params` 
 
        Notes 
        ----- 
        &quot;&quot;&quot;</span>
        <span class="s0">hess_arr_main = self._hessian_main(params)</span>
        <span class="s0">hess_arr_infl = self._hessian_inflate(params)</span>

        <span class="s2">if </span><span class="s0">hess_arr_main </span><span class="s2">is None or </span><span class="s0">hess_arr_infl </span><span class="s2">is None</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">approx_hess(params</span><span class="s2">, </span><span class="s0">self.loglike)</span>

        <span class="s0">dim = self.k_exog + self.k_inflate</span>

        <span class="s0">hess_arr = np.zeros((dim</span><span class="s2">, </span><span class="s0">dim))</span>

        <span class="s0">hess_arr[:self.k_inflate</span><span class="s2">,</span><span class="s0">:] = hess_arr_infl</span>
        <span class="s0">hess_arr[self.k_inflate:</span><span class="s2">,</span><span class="s0">self.k_inflate:] = hess_arr_main</span>

        <span class="s0">tri_idx = np.triu_indices(self.k_exog + self.k_inflate</span><span class="s2">, </span><span class="s0">k=</span><span class="s3">1</span><span class="s0">)</span>
        <span class="s0">hess_arr[tri_idx] = hess_arr.T[tri_idx]</span>

        <span class="s2">return </span><span class="s0">hess_arr</span>

    <span class="s2">def </span><span class="s0">predict(self</span><span class="s2">, </span><span class="s0">params</span><span class="s2">, </span><span class="s0">exog=</span><span class="s2">None, </span><span class="s0">exog_infl=</span><span class="s2">None, </span><span class="s0">exposure=</span><span class="s2">None,</span>
                <span class="s0">offset=</span><span class="s2">None, </span><span class="s0">which=</span><span class="s1">'mean'</span><span class="s2">, </span><span class="s0">y_values=</span><span class="s2">None</span><span class="s0">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Predict expected response or other statistic given exogenous variables. 
 
        Parameters 
        ---------- 
        params : array_like 
            The parameters of the model. 
        exog : ndarray, optional 
            Explanatory variables for the main count model. 
            If ``exog`` is None, then the data from the model will be used. 
        exog_infl : ndarray, optional 
            Explanatory variables for the zero-inflation model. 
            ``exog_infl`` has to be provided if ``exog`` was provided unless 
            ``exog_infl`` in the model is only a constant. 
        offset : ndarray, optional 
            Offset is added to the linear predictor of the mean function with 
            coefficient equal to 1. 
            Default is zero if exog is not None, and the model offset if exog 
            is None. 
        exposure : ndarray, optional 
            Log(exposure) is added to the linear predictor with coefficient 
            equal to 1. If exposure is specified, then it will be logged by 
            the method. The user does not need to log it first. 
            Default is one if exog is is not None, and it is the model exposure 
            if exog is None. 
        which : str (optional) 
            Statitistic to predict. Default is 'mean'. 
 
            - 'mean' : the conditional expectation of endog E(y | x). This 
              takes inflated zeros into account. 
            - 'linear' : the linear predictor of the mean function. 
            - 'var' : returns the estimated variance of endog implied by the 
              model. 
            - 'mean-main' : mean of the main count model 
            - 'prob-main' : probability of selecting the main model. 
                The probability of zero inflation is ``1 - prob-main``. 
            - 'mean-nonzero' : expected value conditional on having observation 
              larger than zero, E(y | X, y&gt;0) 
            - 'prob-zero' : probability of observing a zero count. P(y=0 | x) 
            - 'prob' : probabilities of each count from 0 to max(endog), or 
              for y_values if those are provided. This is a multivariate 
              return (2-dim when predicting for several observations). 
 
        y_values : array_like 
            Values of the random variable endog at which pmf is evaluated. 
            Only used if ``which=&quot;prob&quot;`` 
        &quot;&quot;&quot;</span>
        <span class="s0">no_exog = </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s0">exog </span><span class="s2">is None</span><span class="s0">:</span>
            <span class="s0">no_exog = </span><span class="s2">True</span>
            <span class="s0">exog = self.exog</span>

        <span class="s2">if </span><span class="s0">exog_infl </span><span class="s2">is None</span><span class="s0">:</span>
            <span class="s2">if </span><span class="s0">no_exog:</span>
                <span class="s0">exog_infl = self.exog_infl</span>
            <span class="s2">else</span><span class="s0">:</span>
                <span class="s2">if </span><span class="s0">self._no_exog_infl:</span>
                    <span class="s0">exog_infl = np.ones((len(exog)</span><span class="s2">, </span><span class="s3">1</span><span class="s0">))</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">exog_infl = np.asarray(exog_infl)</span>
            <span class="s2">if </span><span class="s0">exog_infl.ndim == </span><span class="s3">1 </span><span class="s2">and </span><span class="s0">self.k_inflate == </span><span class="s3">1</span><span class="s0">:</span>
                <span class="s0">exog_infl = exog_infl[:</span><span class="s2">, None</span><span class="s0">]</span>

        <span class="s2">if </span><span class="s0">exposure </span><span class="s2">is None</span><span class="s0">:</span>
            <span class="s2">if </span><span class="s0">no_exog:</span>
                <span class="s0">exposure = getattr(self</span><span class="s2">, </span><span class="s1">'exposure'</span><span class="s2">, </span><span class="s3">0</span><span class="s0">)</span>
            <span class="s2">else</span><span class="s0">:</span>
                <span class="s0">exposure = </span><span class="s3">0</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">exposure = np.log(exposure)</span>

        <span class="s2">if </span><span class="s0">offset </span><span class="s2">is None</span><span class="s0">:</span>
            <span class="s2">if </span><span class="s0">no_exog:</span>
                <span class="s0">offset = getattr(self</span><span class="s2">, </span><span class="s1">'offset'</span><span class="s2">, </span><span class="s3">0</span><span class="s0">)</span>
            <span class="s2">else</span><span class="s0">:</span>
                <span class="s0">offset = </span><span class="s3">0</span>

        <span class="s0">params_infl = params[:self.k_inflate]</span>
        <span class="s0">params_main = params[self.k_inflate:]</span>

        <span class="s0">prob_main = </span><span class="s3">1 </span><span class="s0">- self.model_infl.predict(params_infl</span><span class="s2">, </span><span class="s0">exog_infl)</span>

        <span class="s0">lin_pred = np.dot(exog</span><span class="s2">, </span><span class="s0">params_main[:self.exog.shape[</span><span class="s3">1</span><span class="s0">]]) + exposure + offset</span>

        <span class="s5"># Refactor: This is pretty hacky,</span>
        <span class="s5"># there should be an appropriate predict method in model_main</span>
        <span class="s5"># this is just prob(y=0 | model_main)</span>
        <span class="s0">tmp_exog = self.model_main.exog</span>
        <span class="s0">tmp_endog = self.model_main.endog</span>
        <span class="s0">tmp_offset = getattr(self.model_main</span><span class="s2">, </span><span class="s1">'offset'</span><span class="s2">, False</span><span class="s0">)</span>
        <span class="s0">tmp_exposure = getattr(self.model_main</span><span class="s2">, </span><span class="s1">'exposure'</span><span class="s2">, False</span><span class="s0">)</span>
        <span class="s0">self.model_main.exog = exog</span>
        <span class="s0">self.model_main.endog = np.zeros((exog.shape[</span><span class="s3">0</span><span class="s0">]))</span>
        <span class="s0">self.model_main.offset = offset</span>
        <span class="s0">self.model_main.exposure = exposure</span>
        <span class="s0">llf = self.model_main.loglikeobs(params_main)</span>
        <span class="s0">self.model_main.exog = tmp_exog</span>
        <span class="s0">self.model_main.endog = tmp_endog</span>
        <span class="s5"># tmp_offset might be an array with elementwise equality testing</span>
        <span class="s5">#if np.size(tmp_offset) == 1 and tmp_offset[0] == 'no':</span>
        <span class="s2">if </span><span class="s0">tmp_offset </span><span class="s2">is False</span><span class="s0">:</span>
            <span class="s2">del </span><span class="s0">self.model_main.offset</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">self.model_main.offset = tmp_offset</span>
        <span class="s5">#if np.size(tmp_exposure) == 1 and tmp_exposure[0] == 'no':</span>
        <span class="s2">if </span><span class="s0">tmp_exposure </span><span class="s2">is False</span><span class="s0">:</span>
            <span class="s2">del </span><span class="s0">self.model_main.exposure</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">self.model_main.exposure = tmp_exposure</span>
        <span class="s5"># end hack</span>

        <span class="s0">prob_zero = (</span><span class="s3">1 </span><span class="s0">- prob_main) + prob_main * np.exp(llf)</span>

        <span class="s2">if </span><span class="s0">which == </span><span class="s1">'mean'</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">prob_main * np.exp(lin_pred)</span>
        <span class="s2">elif </span><span class="s0">which == </span><span class="s1">'mean-main'</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">np.exp(lin_pred)</span>
        <span class="s2">elif </span><span class="s0">which == </span><span class="s1">'linear'</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">lin_pred</span>
        <span class="s2">elif </span><span class="s0">which == </span><span class="s1">'mean-nonzero'</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">prob_main * np.exp(lin_pred) / (</span><span class="s3">1 </span><span class="s0">- prob_zero)</span>
        <span class="s2">elif </span><span class="s0">which == </span><span class="s1">'prob-zero'</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">prob_zero</span>
        <span class="s2">elif </span><span class="s0">which == </span><span class="s1">'prob-main'</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">prob_main</span>
        <span class="s2">elif </span><span class="s0">which == </span><span class="s1">'var'</span><span class="s0">:</span>
            <span class="s0">mu = np.exp(lin_pred)</span>
            <span class="s2">return </span><span class="s0">self._predict_var(params</span><span class="s2">, </span><span class="s0">mu</span><span class="s2">, </span><span class="s3">1 </span><span class="s0">- prob_main)</span>
        <span class="s2">elif </span><span class="s0">which == </span><span class="s1">'prob'</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">self._predict_prob(params</span><span class="s2">, </span><span class="s0">exog</span><span class="s2">, </span><span class="s0">exog_infl</span><span class="s2">, </span><span class="s0">exposure</span><span class="s2">,</span>
                                      <span class="s0">offset</span><span class="s2">, </span><span class="s0">y_values=y_values)</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">'which = %s is not available' </span><span class="s0">% which)</span>

    <span class="s2">def </span><span class="s0">_derivative_predict(self</span><span class="s2">, </span><span class="s0">params</span><span class="s2">, </span><span class="s0">exog=</span><span class="s2">None, </span><span class="s0">transform=</span><span class="s1">'dydx'</span><span class="s0">):</span>
        <span class="s4">&quot;&quot;&quot;NotImplemented 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s0">NotImplementedError</span>

    <span class="s2">def </span><span class="s0">_derivative_exog(self</span><span class="s2">, </span><span class="s0">params</span><span class="s2">, </span><span class="s0">exog=</span><span class="s2">None, </span><span class="s0">transform=</span><span class="s1">&quot;dydx&quot;</span><span class="s2">,</span>
                         <span class="s0">dummy_idx=</span><span class="s2">None, </span><span class="s0">count_idx=</span><span class="s2">None</span><span class="s0">):</span>
        <span class="s4">&quot;&quot;&quot;NotImplemented 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s0">NotImplementedError</span>

    <span class="s2">def </span><span class="s0">_deriv_mean_dparams(self</span><span class="s2">, </span><span class="s0">params):</span>
        <span class="s4">&quot;&quot;&quot; 
        Derivative of the expected endog with respect to the parameters. 
 
        Parameters 
        ---------- 
        params : ndarray 
            parameter at which score is evaluated 
 
        Returns 
        ------- 
        The value of the derivative of the expected endog with respect 
        to the parameter vector. 
        &quot;&quot;&quot;</span>
        <span class="s0">params_infl = params[:self.k_inflate]</span>
        <span class="s0">params_main = params[self.k_inflate:]</span>

        <span class="s0">w = self.model_infl.predict(params_infl)</span>
        <span class="s0">w = np.clip(w</span><span class="s2">, </span><span class="s0">np.finfo(float).eps</span><span class="s2">, </span><span class="s3">1 </span><span class="s0">- np.finfo(float).eps)</span>
        <span class="s0">mu = self.model_main.predict(params_main)</span>

        <span class="s0">score_infl = self.model_infl._deriv_mean_dparams(params_infl)</span>
        <span class="s0">score_main = self.model_main._deriv_mean_dparams(params_main)</span>

        <span class="s0">dmat_infl = - mu[:</span><span class="s2">, None</span><span class="s0">] * score_infl</span>
        <span class="s0">dmat_main = (</span><span class="s3">1 </span><span class="s0">- w[:</span><span class="s2">, None</span><span class="s0">]) * score_main</span>

        <span class="s0">dmat = np.column_stack((dmat_infl</span><span class="s2">, </span><span class="s0">dmat_main))</span>
        <span class="s2">return </span><span class="s0">dmat</span>

    <span class="s2">def </span><span class="s0">_deriv_score_obs_dendog(self</span><span class="s2">, </span><span class="s0">params):</span>
        <span class="s4">&quot;&quot;&quot;derivative of score_obs w.r.t. endog 
 
        Parameters 
        ---------- 
        params : ndarray 
            parameter at which score is evaluated 
 
        Returns 
        ------- 
        derivative : ndarray_2d 
            The derivative of the score_obs with respect to endog. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s0">NotImplementedError</span>

        <span class="s5"># The below currently does not work, discontinuity at zero</span>
        <span class="s5"># see https://github.com/statsmodels/statsmodels/pull/7951#issuecomment-996355875  # noqa</span>
        <span class="s2">from </span><span class="s0">statsmodels.tools.numdiff </span><span class="s2">import </span><span class="s0">_approx_fprime_scalar</span>
        <span class="s0">endog_original = self.endog</span>

        <span class="s2">def </span><span class="s0">f(y):</span>
            <span class="s2">if </span><span class="s0">y.ndim == </span><span class="s3">2 </span><span class="s2">and </span><span class="s0">y.shape[</span><span class="s3">1</span><span class="s0">] == </span><span class="s3">1</span><span class="s0">:</span>
                <span class="s0">y = y[:</span><span class="s2">, </span><span class="s3">0</span><span class="s0">]</span>
            <span class="s0">self.endog = y</span>
            <span class="s0">self.model_main.endog = y</span>
            <span class="s0">sf = self.score_obs(params)</span>
            <span class="s0">self.endog = endog_original</span>
            <span class="s0">self.model_main.endog = endog_original</span>
            <span class="s2">return </span><span class="s0">sf</span>

        <span class="s0">ds = _approx_fprime_scalar(self.endog[:</span><span class="s2">, None</span><span class="s0">]</span><span class="s2">, </span><span class="s0">f</span><span class="s2">, </span><span class="s0">epsilon=</span><span class="s3">1e-2</span><span class="s0">)</span>

        <span class="s2">return </span><span class="s0">ds</span>


<span class="s2">class </span><span class="s0">ZeroInflatedPoisson(GenericZeroInflated):</span>
    <span class="s0">__doc__ = </span><span class="s1">&quot;&quot;&quot; 
    Poisson Zero Inflated Model 
 
    %(params)s 
    %(extra_params)s 
 
    Attributes 
    ---------- 
    endog : ndarray 
        A reference to the endogenous response variable 
    exog : ndarray 
        A reference to the exogenous design. 
    exog_infl : ndarray 
        A reference to the zero-inflated exogenous design. 
    &quot;&quot;&quot; </span><span class="s0">% {</span><span class="s1">'params' </span><span class="s0">: base._model_params_doc</span><span class="s2">,</span>
           <span class="s1">'extra_params' </span><span class="s0">: _doc_zi_params + base._missing_param_doc}</span>

    <span class="s2">def </span><span class="s0">__init__(self</span><span class="s2">, </span><span class="s0">endog</span><span class="s2">, </span><span class="s0">exog</span><span class="s2">, </span><span class="s0">exog_infl=</span><span class="s2">None, </span><span class="s0">offset=</span><span class="s2">None, </span><span class="s0">exposure=</span><span class="s2">None,</span>
                 <span class="s0">inflation=</span><span class="s1">'logit'</span><span class="s2">, </span><span class="s0">missing=</span><span class="s1">'none'</span><span class="s2">, </span><span class="s0">**kwargs):</span>
        <span class="s0">super(ZeroInflatedPoisson</span><span class="s2">, </span><span class="s0">self).__init__(endog</span><span class="s2">, </span><span class="s0">exog</span><span class="s2">, </span><span class="s0">offset=offset</span><span class="s2">,</span>
                                                  <span class="s0">inflation=inflation</span><span class="s2">,</span>
                                                  <span class="s0">exog_infl=exog_infl</span><span class="s2">,</span>
                                                  <span class="s0">exposure=exposure</span><span class="s2">,</span>
                                                  <span class="s0">missing=missing</span><span class="s2">, </span><span class="s0">**kwargs)</span>
        <span class="s0">self.model_main = Poisson(self.endog</span><span class="s2">, </span><span class="s0">self.exog</span><span class="s2">, </span><span class="s0">offset=offset</span><span class="s2">,</span>
                                  <span class="s0">exposure=exposure)</span>
        <span class="s0">self.distribution = zipoisson</span>
        <span class="s0">self.result_class = ZeroInflatedPoissonResults</span>
        <span class="s0">self.result_class_wrapper = ZeroInflatedPoissonResultsWrapper</span>
        <span class="s0">self.result_class_reg = L1ZeroInflatedPoissonResults</span>
        <span class="s0">self.result_class_reg_wrapper = L1ZeroInflatedPoissonResultsWrapper</span>

    <span class="s2">def </span><span class="s0">_hessian_main(self</span><span class="s2">, </span><span class="s0">params):</span>
        <span class="s0">params_infl = params[:self.k_inflate]</span>
        <span class="s0">params_main = params[self.k_inflate:]</span>

        <span class="s0">y = self.endog</span>
        <span class="s0">w = self.model_infl.predict(params_infl)</span>
        <span class="s0">w = np.clip(w</span><span class="s2">, </span><span class="s0">np.finfo(float).eps</span><span class="s2">, </span><span class="s3">1 </span><span class="s0">- np.finfo(float).eps)</span>
        <span class="s0">score = self.score(params)</span>
        <span class="s0">zero_idx = np.nonzero(y == </span><span class="s3">0</span><span class="s0">)[</span><span class="s3">0</span><span class="s0">]</span>
        <span class="s0">nonzero_idx = np.nonzero(y)[</span><span class="s3">0</span><span class="s0">]</span>

        <span class="s0">mu = self.model_main.predict(params_main)</span>

        <span class="s0">hess_arr = np.zeros((self.k_exog</span><span class="s2">, </span><span class="s0">self.k_exog))</span>

        <span class="s0">coeff = (</span><span class="s3">1 </span><span class="s0">+ w[zero_idx] * (np.exp(mu[zero_idx]) - </span><span class="s3">1</span><span class="s0">))</span>

        <span class="s5">#d2l/dp2</span>
        <span class="s2">for </span><span class="s0">i </span><span class="s2">in </span><span class="s0">range(self.k_exog):</span>
            <span class="s2">for </span><span class="s0">j </span><span class="s2">in </span><span class="s0">range(i</span><span class="s2">, </span><span class="s0">-</span><span class="s3">1</span><span class="s2">, </span><span class="s0">-</span><span class="s3">1</span><span class="s0">):</span>
                <span class="s0">hess_arr[i</span><span class="s2">, </span><span class="s0">j] = ((</span>
                    <span class="s0">self.exog[zero_idx</span><span class="s2">, </span><span class="s0">i] * self.exog[zero_idx</span><span class="s2">, </span><span class="s0">j] *</span>
                    <span class="s0">mu[zero_idx] * (w[zero_idx] - </span><span class="s3">1</span><span class="s0">) * (</span><span class="s3">1 </span><span class="s0">/ coeff -</span>
                    <span class="s0">w[zero_idx] * mu[zero_idx] * np.exp(mu[zero_idx]) /</span>
                    <span class="s0">coeff**</span><span class="s3">2</span><span class="s0">)).sum() - (mu[nonzero_idx] * self.exog[nonzero_idx</span><span class="s2">, </span><span class="s0">i] *</span>
                    <span class="s0">self.exog[nonzero_idx</span><span class="s2">, </span><span class="s0">j]).sum())</span>

        <span class="s2">return </span><span class="s0">hess_arr</span>

    <span class="s2">def </span><span class="s0">_predict_prob(self</span><span class="s2">, </span><span class="s0">params</span><span class="s2">, </span><span class="s0">exog</span><span class="s2">, </span><span class="s0">exog_infl</span><span class="s2">, </span><span class="s0">exposure</span><span class="s2">, </span><span class="s0">offset</span><span class="s2">,</span>
                      <span class="s0">y_values=</span><span class="s2">None</span><span class="s0">):</span>
        <span class="s0">params_infl = params[:self.k_inflate]</span>
        <span class="s0">params_main = params[self.k_inflate:]</span>

        <span class="s2">if </span><span class="s0">y_values </span><span class="s2">is None</span><span class="s0">:</span>
            <span class="s0">y_values = np.atleast_2d(np.arange(</span><span class="s3">0</span><span class="s2">, </span><span class="s0">np.max(self.endog)+</span><span class="s3">1</span><span class="s0">))</span>

        <span class="s2">if </span><span class="s0">len(exog_infl.shape) &lt; </span><span class="s3">2</span><span class="s0">:</span>
            <span class="s0">transform = </span><span class="s2">True</span>
            <span class="s0">w = np.atleast_2d(</span>
                <span class="s0">self.model_infl.predict(params_infl</span><span class="s2">, </span><span class="s0">exog_infl))[:</span><span class="s2">, None</span><span class="s0">]</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">transform = </span><span class="s2">False</span>
            <span class="s0">w = self.model_infl.predict(params_infl</span><span class="s2">, </span><span class="s0">exog_infl)[:</span><span class="s2">, None</span><span class="s0">]</span>

        <span class="s0">w = np.clip(w</span><span class="s2">, </span><span class="s0">np.finfo(float).eps</span><span class="s2">, </span><span class="s3">1 </span><span class="s0">- np.finfo(float).eps)</span>
        <span class="s0">mu = self.model_main.predict(params_main</span><span class="s2">, </span><span class="s0">exog</span><span class="s2">,</span>
            <span class="s0">offset=offset)[:</span><span class="s2">, None</span><span class="s0">]</span>
        <span class="s0">result = self.distribution.pmf(y_values</span><span class="s2">, </span><span class="s0">mu</span><span class="s2">, </span><span class="s0">w)</span>
        <span class="s2">return </span><span class="s0">result[</span><span class="s3">0</span><span class="s0">] </span><span class="s2">if </span><span class="s0">transform </span><span class="s2">else </span><span class="s0">result</span>

    <span class="s2">def </span><span class="s0">_predict_var(self</span><span class="s2">, </span><span class="s0">params</span><span class="s2">, </span><span class="s0">mu</span><span class="s2">, </span><span class="s0">prob_infl):</span>
        <span class="s4">&quot;&quot;&quot;predict values for conditional variance V(endog | exog) 
 
        Parameters 
        ---------- 
        params : array_like 
            The model parameters. This is only used to extract extra params 
            like dispersion parameter. 
        mu : array_like 
            Array of mean predictions for main model. 
        prob_inlf : array_like 
            Array of predicted probabilities of zero-inflation `w`. 
 
        Returns 
        ------- 
        Predicted conditional variance. 
        &quot;&quot;&quot;</span>
        <span class="s0">w = prob_infl</span>
        <span class="s0">var_ = (</span><span class="s3">1 </span><span class="s0">- w) * mu * (</span><span class="s3">1 </span><span class="s0">+ w * mu)</span>
        <span class="s2">return </span><span class="s0">var_</span>

    <span class="s2">def </span><span class="s0">_get_start_params(self):</span>
        <span class="s2">with </span><span class="s0">warnings.catch_warnings():</span>
            <span class="s0">warnings.simplefilter(</span><span class="s1">&quot;ignore&quot;</span><span class="s2">, </span><span class="s0">category=ConvergenceWarning)</span>
            <span class="s0">start_params = self.model_main.fit(disp=</span><span class="s3">0</span><span class="s2">, </span><span class="s0">method=</span><span class="s1">&quot;nm&quot;</span><span class="s0">).params</span>
        <span class="s0">start_params = np.append(np.ones(self.k_inflate) * </span><span class="s3">0.1</span><span class="s2">, </span><span class="s0">start_params)</span>
        <span class="s2">return </span><span class="s0">start_params</span>

    <span class="s2">def </span><span class="s0">get_distribution(self</span><span class="s2">, </span><span class="s0">params</span><span class="s2">, </span><span class="s0">exog=</span><span class="s2">None, </span><span class="s0">exog_infl=</span><span class="s2">None,</span>
                         <span class="s0">exposure=</span><span class="s2">None, </span><span class="s0">offset=</span><span class="s2">None</span><span class="s0">):</span>
        <span class="s4">&quot;&quot;&quot;Get frozen instance of distribution based on predicted parameters. 
 
        Parameters 
        ---------- 
        params : array_like 
            The parameters of the model. 
        exog : ndarray, optional 
            Explanatory variables for the main count model. 
            If ``exog`` is None, then the data from the model will be used. 
        exog_infl : ndarray, optional 
            Explanatory variables for the zero-inflation model. 
            ``exog_infl`` has to be provided if ``exog`` was provided unless 
            ``exog_infl`` in the model is only a constant. 
        offset : ndarray, optional 
            Offset is added to the linear predictor of the mean function with 
            coefficient equal to 1. 
            Default is zero if exog is not None, and the model offset if exog 
            is None. 
        exposure : ndarray, optional 
            Log(exposure) is added to the linear predictor  of the mean 
            function with coefficient equal to 1. If exposure is specified, 
            then it will be logged by the method. The user does not need to 
            log it first. 
            Default is one if exog is is not None, and it is the model exposure 
            if exog is None. 
 
        Returns 
        ------- 
        Instance of frozen scipy distribution subclass. 
        &quot;&quot;&quot;</span>
        <span class="s0">mu = self.predict(params</span><span class="s2">, </span><span class="s0">exog=exog</span><span class="s2">, </span><span class="s0">exog_infl=exog_infl</span><span class="s2">,</span>
                          <span class="s0">exposure=exposure</span><span class="s2">, </span><span class="s0">offset=offset</span><span class="s2">, </span><span class="s0">which=</span><span class="s1">&quot;mean-main&quot;</span><span class="s0">)</span>
        <span class="s0">w = self.predict(params</span><span class="s2">, </span><span class="s0">exog=exog</span><span class="s2">, </span><span class="s0">exog_infl=exog_infl</span><span class="s2">,</span>
                         <span class="s0">exposure=exposure</span><span class="s2">, </span><span class="s0">offset=offset</span><span class="s2">, </span><span class="s0">which=</span><span class="s1">&quot;prob-main&quot;</span><span class="s0">)</span>

        <span class="s5"># distr = self.distribution(mu[:, None], 1 - w[:, None])</span>
        <span class="s0">distr = self.distribution(mu</span><span class="s2">, </span><span class="s3">1 </span><span class="s0">- w)</span>
        <span class="s2">return </span><span class="s0">distr</span>


<span class="s2">class </span><span class="s0">ZeroInflatedGeneralizedPoisson(GenericZeroInflated):</span>
    <span class="s0">__doc__ = </span><span class="s1">&quot;&quot;&quot; 
    Zero Inflated Generalized Poisson Model 
 
    %(params)s 
    %(extra_params)s 
 
    Attributes 
    ---------- 
    endog : ndarray 
        A reference to the endogenous response variable 
    exog : ndarray 
        A reference to the exogenous design. 
    exog_infl : ndarray 
        A reference to the zero-inflated exogenous design. 
    p : scalar 
        P denotes parametrizations for ZIGP regression. 
    &quot;&quot;&quot; </span><span class="s0">% {</span><span class="s1">'params' </span><span class="s0">: base._model_params_doc</span><span class="s2">,</span>
           <span class="s1">'extra_params' </span><span class="s0">: _doc_zi_params +</span>
           <span class="s1">&quot;&quot;&quot;p : float 
        dispersion power parameter for the GeneralizedPoisson model.  p=1 for 
        ZIGP-1 and p=2 for ZIGP-2. Default is p=2 
    &quot;&quot;&quot; </span><span class="s0">+ base._missing_param_doc}</span>

    <span class="s2">def </span><span class="s0">__init__(self</span><span class="s2">, </span><span class="s0">endog</span><span class="s2">, </span><span class="s0">exog</span><span class="s2">, </span><span class="s0">exog_infl=</span><span class="s2">None, </span><span class="s0">offset=</span><span class="s2">None, </span><span class="s0">exposure=</span><span class="s2">None,</span>
                 <span class="s0">inflation=</span><span class="s1">'logit'</span><span class="s2">, </span><span class="s0">p=</span><span class="s3">2</span><span class="s2">, </span><span class="s0">missing=</span><span class="s1">'none'</span><span class="s2">, </span><span class="s0">**kwargs):</span>
        <span class="s0">super(ZeroInflatedGeneralizedPoisson</span><span class="s2">, </span><span class="s0">self).__init__(endog</span><span class="s2">, </span><span class="s0">exog</span><span class="s2">,</span>
                                                  <span class="s0">offset=offset</span><span class="s2">,</span>
                                                  <span class="s0">inflation=inflation</span><span class="s2">,</span>
                                                  <span class="s0">exog_infl=exog_infl</span><span class="s2">,</span>
                                                  <span class="s0">exposure=exposure</span><span class="s2">,</span>
                                                  <span class="s0">missing=missing</span><span class="s2">, </span><span class="s0">**kwargs)</span>
        <span class="s0">self.model_main = GeneralizedPoisson(self.endog</span><span class="s2">, </span><span class="s0">self.exog</span><span class="s2">,</span>
            <span class="s0">offset=offset</span><span class="s2">, </span><span class="s0">exposure=exposure</span><span class="s2">, </span><span class="s0">p=p)</span>
        <span class="s0">self.distribution = zigenpoisson</span>
        <span class="s0">self.k_exog += </span><span class="s3">1</span>
        <span class="s0">self.k_extra += </span><span class="s3">1</span>
        <span class="s0">self.exog_names.append(</span><span class="s1">&quot;alpha&quot;</span><span class="s0">)</span>
        <span class="s0">self.result_class = ZeroInflatedGeneralizedPoissonResults</span>
        <span class="s0">self.result_class_wrapper = ZeroInflatedGeneralizedPoissonResultsWrapper</span>
        <span class="s0">self.result_class_reg = L1ZeroInflatedGeneralizedPoissonResults</span>
        <span class="s0">self.result_class_reg_wrapper = L1ZeroInflatedGeneralizedPoissonResultsWrapper</span>

    <span class="s2">def </span><span class="s0">_get_init_kwds(self):</span>
        <span class="s0">kwds = super(ZeroInflatedGeneralizedPoisson</span><span class="s2">, </span><span class="s0">self)._get_init_kwds()</span>
        <span class="s0">kwds[</span><span class="s1">'p'</span><span class="s0">] = self.model_main.parameterization + </span><span class="s3">1</span>
        <span class="s2">return </span><span class="s0">kwds</span>

    <span class="s2">def </span><span class="s0">_predict_prob(self</span><span class="s2">, </span><span class="s0">params</span><span class="s2">, </span><span class="s0">exog</span><span class="s2">, </span><span class="s0">exog_infl</span><span class="s2">, </span><span class="s0">exposure</span><span class="s2">, </span><span class="s0">offset</span><span class="s2">,</span>
                      <span class="s0">y_values=</span><span class="s2">None</span><span class="s0">):</span>
        <span class="s0">params_infl = params[:self.k_inflate]</span>
        <span class="s0">params_main = params[self.k_inflate:]</span>

        <span class="s0">p = self.model_main.parameterization + </span><span class="s3">1</span>
        <span class="s2">if </span><span class="s0">y_values </span><span class="s2">is None</span><span class="s0">:</span>
            <span class="s0">y_values = np.atleast_2d(np.arange(</span><span class="s3">0</span><span class="s2">, </span><span class="s0">np.max(self.endog)+</span><span class="s3">1</span><span class="s0">))</span>

        <span class="s2">if </span><span class="s0">len(exog_infl.shape) &lt; </span><span class="s3">2</span><span class="s0">:</span>
            <span class="s0">transform = </span><span class="s2">True</span>
            <span class="s0">w = np.atleast_2d(</span>
                <span class="s0">self.model_infl.predict(params_infl</span><span class="s2">, </span><span class="s0">exog_infl))[:</span><span class="s2">, None</span><span class="s0">]</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">transform = </span><span class="s2">False</span>
            <span class="s0">w = self.model_infl.predict(params_infl</span><span class="s2">, </span><span class="s0">exog_infl)[:</span><span class="s2">, None</span><span class="s0">]</span>

        <span class="s0">w[w == </span><span class="s3">1.</span><span class="s0">] = np.nextafter(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s0">)</span>
        <span class="s0">mu = self.model_main.predict(params_main</span><span class="s2">, </span><span class="s0">exog</span><span class="s2">,</span>
            <span class="s0">exposure=exposure</span><span class="s2">, </span><span class="s0">offset=offset)[:</span><span class="s2">, None</span><span class="s0">]</span>
        <span class="s0">result = self.distribution.pmf(y_values</span><span class="s2">, </span><span class="s0">mu</span><span class="s2">, </span><span class="s0">params_main[-</span><span class="s3">1</span><span class="s0">]</span><span class="s2">, </span><span class="s0">p</span><span class="s2">, </span><span class="s0">w)</span>
        <span class="s2">return </span><span class="s0">result[</span><span class="s3">0</span><span class="s0">] </span><span class="s2">if </span><span class="s0">transform </span><span class="s2">else </span><span class="s0">result</span>

    <span class="s2">def </span><span class="s0">_predict_var(self</span><span class="s2">, </span><span class="s0">params</span><span class="s2">, </span><span class="s0">mu</span><span class="s2">, </span><span class="s0">prob_infl):</span>
        <span class="s4">&quot;&quot;&quot;predict values for conditional variance V(endog | exog) 
 
        Parameters 
        ---------- 
        params : array_like 
            The model parameters. This is only used to extract extra params 
            like dispersion parameter. 
        mu : array_like 
            Array of mean predictions for main model. 
        prob_inlf : array_like 
            Array of predicted probabilities of zero-inflation `w`. 
 
        Returns 
        ------- 
        Predicted conditional variance. 
        &quot;&quot;&quot;</span>
        <span class="s0">alpha = params[-</span><span class="s3">1</span><span class="s0">]</span>
        <span class="s0">w = prob_infl</span>
        <span class="s0">p = self.model_main.parameterization</span>
        <span class="s0">var_ = (</span><span class="s3">1 </span><span class="s0">- w) * mu * ((</span><span class="s3">1 </span><span class="s0">+ alpha * mu**p)**</span><span class="s3">2 </span><span class="s0">+ w * mu)</span>
        <span class="s2">return </span><span class="s0">var_</span>

    <span class="s2">def </span><span class="s0">_get_start_params(self):</span>
        <span class="s2">with </span><span class="s0">warnings.catch_warnings():</span>
            <span class="s0">warnings.simplefilter(</span><span class="s1">&quot;ignore&quot;</span><span class="s2">, </span><span class="s0">category=ConvergenceWarning)</span>
            <span class="s0">start_params = ZeroInflatedPoisson(self.endog</span><span class="s2">, </span><span class="s0">self.exog</span><span class="s2">,</span>
                <span class="s0">exog_infl=self.exog_infl).fit(disp=</span><span class="s3">0</span><span class="s0">).params</span>
        <span class="s0">start_params = np.append(start_params</span><span class="s2">, </span><span class="s3">0.1</span><span class="s0">)</span>
        <span class="s2">return </span><span class="s0">start_params</span>

    <span class="s0">@Appender(ZeroInflatedPoisson.get_distribution.__doc__)</span>
    <span class="s2">def </span><span class="s0">get_distribution(self</span><span class="s2">, </span><span class="s0">params</span><span class="s2">, </span><span class="s0">exog=</span><span class="s2">None, </span><span class="s0">exog_infl=</span><span class="s2">None,</span>
                         <span class="s0">exposure=</span><span class="s2">None, </span><span class="s0">offset=</span><span class="s2">None</span><span class="s0">):</span>

        <span class="s0">p = self.model_main.parameterization + </span><span class="s3">1</span>
        <span class="s0">mu = self.predict(params</span><span class="s2">, </span><span class="s0">exog=exog</span><span class="s2">, </span><span class="s0">exog_infl=exog_infl</span><span class="s2">,</span>
                          <span class="s0">exposure=exposure</span><span class="s2">, </span><span class="s0">offset=offset</span><span class="s2">, </span><span class="s0">which=</span><span class="s1">&quot;mean-main&quot;</span><span class="s0">)</span>
        <span class="s0">w = self.predict(params</span><span class="s2">, </span><span class="s0">exog=exog</span><span class="s2">, </span><span class="s0">exog_infl=exog_infl</span><span class="s2">,</span>
                         <span class="s0">exposure=exposure</span><span class="s2">, </span><span class="s0">offset=offset</span><span class="s2">, </span><span class="s0">which=</span><span class="s1">&quot;prob-main&quot;</span><span class="s0">)</span>
        <span class="s5"># distr = self.distribution(mu[:, None], params[-1], p, 1 - w[:, None])</span>
        <span class="s0">distr = self.distribution(mu</span><span class="s2">, </span><span class="s0">params[-</span><span class="s3">1</span><span class="s0">]</span><span class="s2">, </span><span class="s0">p</span><span class="s2">, </span><span class="s3">1 </span><span class="s0">- w)</span>
        <span class="s2">return </span><span class="s0">distr</span>


<span class="s2">class </span><span class="s0">ZeroInflatedNegativeBinomialP(GenericZeroInflated):</span>
    <span class="s0">__doc__ = </span><span class="s1">&quot;&quot;&quot; 
    Zero Inflated Generalized Negative Binomial Model 
 
    %(params)s 
    %(extra_params)s 
 
    Attributes 
    ---------- 
    endog : ndarray 
        A reference to the endogenous response variable 
    exog : ndarray 
        A reference to the exogenous design. 
    exog_infl : ndarray 
        A reference to the zero-inflated exogenous design. 
    p : scalar 
        P denotes parametrizations for ZINB regression. p=1 for ZINB-1 and 
    p=2 for ZINB-2. Default is p=2 
    &quot;&quot;&quot; </span><span class="s0">% {</span><span class="s1">'params' </span><span class="s0">: base._model_params_doc</span><span class="s2">,</span>
           <span class="s1">'extra_params' </span><span class="s0">: _doc_zi_params +</span>
           <span class="s1">&quot;&quot;&quot;p : float 
        dispersion power parameter for the NegativeBinomialP model.  p=1 for 
        ZINB-1 and p=2 for ZINM-2. Default is p=2 
    &quot;&quot;&quot; </span><span class="s0">+ base._missing_param_doc}</span>

    <span class="s2">def </span><span class="s0">__init__(self</span><span class="s2">, </span><span class="s0">endog</span><span class="s2">, </span><span class="s0">exog</span><span class="s2">, </span><span class="s0">exog_infl=</span><span class="s2">None, </span><span class="s0">offset=</span><span class="s2">None, </span><span class="s0">exposure=</span><span class="s2">None,</span>
                 <span class="s0">inflation=</span><span class="s1">'logit'</span><span class="s2">, </span><span class="s0">p=</span><span class="s3">2</span><span class="s2">, </span><span class="s0">missing=</span><span class="s1">'none'</span><span class="s2">, </span><span class="s0">**kwargs):</span>
        <span class="s0">super(ZeroInflatedNegativeBinomialP</span><span class="s2">, </span><span class="s0">self).__init__(endog</span><span class="s2">, </span><span class="s0">exog</span><span class="s2">,</span>
                                                  <span class="s0">offset=offset</span><span class="s2">,</span>
                                                  <span class="s0">inflation=inflation</span><span class="s2">,</span>
                                                  <span class="s0">exog_infl=exog_infl</span><span class="s2">,</span>
                                                  <span class="s0">exposure=exposure</span><span class="s2">,</span>
                                                  <span class="s0">missing=missing</span><span class="s2">, </span><span class="s0">**kwargs)</span>
        <span class="s0">self.model_main = NegativeBinomialP(self.endog</span><span class="s2">, </span><span class="s0">self.exog</span><span class="s2">,</span>
            <span class="s0">offset=offset</span><span class="s2">, </span><span class="s0">exposure=exposure</span><span class="s2">, </span><span class="s0">p=p)</span>
        <span class="s0">self.distribution = zinegbin</span>
        <span class="s0">self.k_exog += </span><span class="s3">1</span>
        <span class="s0">self.k_extra += </span><span class="s3">1</span>
        <span class="s0">self.exog_names.append(</span><span class="s1">&quot;alpha&quot;</span><span class="s0">)</span>
        <span class="s0">self.result_class = ZeroInflatedNegativeBinomialResults</span>
        <span class="s0">self.result_class_wrapper = ZeroInflatedNegativeBinomialResultsWrapper</span>
        <span class="s0">self.result_class_reg = L1ZeroInflatedNegativeBinomialResults</span>
        <span class="s0">self.result_class_reg_wrapper = L1ZeroInflatedNegativeBinomialResultsWrapper</span>

    <span class="s2">def </span><span class="s0">_get_init_kwds(self):</span>
        <span class="s0">kwds = super(ZeroInflatedNegativeBinomialP</span><span class="s2">, </span><span class="s0">self)._get_init_kwds()</span>
        <span class="s0">kwds[</span><span class="s1">'p'</span><span class="s0">] = self.model_main.parameterization</span>
        <span class="s2">return </span><span class="s0">kwds</span>

    <span class="s2">def </span><span class="s0">_predict_prob(self</span><span class="s2">, </span><span class="s0">params</span><span class="s2">, </span><span class="s0">exog</span><span class="s2">, </span><span class="s0">exog_infl</span><span class="s2">, </span><span class="s0">exposure</span><span class="s2">, </span><span class="s0">offset</span><span class="s2">,</span>
                      <span class="s0">y_values=</span><span class="s2">None</span><span class="s0">):</span>
        <span class="s0">params_infl = params[:self.k_inflate]</span>
        <span class="s0">params_main = params[self.k_inflate:]</span>

        <span class="s0">p = self.model_main.parameterization</span>
        <span class="s2">if </span><span class="s0">y_values </span><span class="s2">is None</span><span class="s0">:</span>
            <span class="s0">y_values = np.arange(</span><span class="s3">0</span><span class="s2">, </span><span class="s0">np.max(self.endog)+</span><span class="s3">1</span><span class="s0">)</span>

        <span class="s2">if </span><span class="s0">len(exog_infl.shape) &lt; </span><span class="s3">2</span><span class="s0">:</span>
            <span class="s0">transform = </span><span class="s2">True</span>
            <span class="s0">w = np.atleast_2d(</span>
                <span class="s0">self.model_infl.predict(params_infl</span><span class="s2">, </span><span class="s0">exog_infl))[:</span><span class="s2">, None</span><span class="s0">]</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">transform = </span><span class="s2">False</span>
            <span class="s0">w = self.model_infl.predict(params_infl</span><span class="s2">, </span><span class="s0">exog_infl)[:</span><span class="s2">, None</span><span class="s0">]</span>

        <span class="s0">w = np.clip(w</span><span class="s2">, </span><span class="s0">np.finfo(float).eps</span><span class="s2">, </span><span class="s3">1 </span><span class="s0">- np.finfo(float).eps)</span>
        <span class="s0">mu = self.model_main.predict(params_main</span><span class="s2">, </span><span class="s0">exog</span><span class="s2">,</span>
            <span class="s0">exposure=exposure</span><span class="s2">, </span><span class="s0">offset=offset)[:</span><span class="s2">, None</span><span class="s0">]</span>
        <span class="s0">result = self.distribution.pmf(y_values</span><span class="s2">, </span><span class="s0">mu</span><span class="s2">, </span><span class="s0">params_main[-</span><span class="s3">1</span><span class="s0">]</span><span class="s2">, </span><span class="s0">p</span><span class="s2">, </span><span class="s0">w)</span>
        <span class="s2">return </span><span class="s0">result[</span><span class="s3">0</span><span class="s0">] </span><span class="s2">if </span><span class="s0">transform </span><span class="s2">else </span><span class="s0">result</span>

    <span class="s2">def </span><span class="s0">_predict_var(self</span><span class="s2">, </span><span class="s0">params</span><span class="s2">, </span><span class="s0">mu</span><span class="s2">, </span><span class="s0">prob_infl):</span>
        <span class="s4">&quot;&quot;&quot;predict values for conditional variance V(endog | exog) 
 
        Parameters 
        ---------- 
        params : array_like 
            The model parameters. This is only used to extract extra params 
            like dispersion parameter. 
        mu : array_like 
            Array of mean predictions for main model. 
        prob_inlf : array_like 
            Array of predicted probabilities of zero-inflation `w`. 
 
        Returns 
        ------- 
        Predicted conditional variance. 
        &quot;&quot;&quot;</span>
        <span class="s0">alpha = params[-</span><span class="s3">1</span><span class="s0">]</span>
        <span class="s0">w = prob_infl</span>
        <span class="s0">p = self.model_main.parameterization</span>
        <span class="s0">var_ = (</span><span class="s3">1 </span><span class="s0">- w) * mu * (</span><span class="s3">1 </span><span class="s0">+ alpha * mu**(p - </span><span class="s3">1</span><span class="s0">) + w * mu)</span>
        <span class="s2">return </span><span class="s0">var_</span>

    <span class="s2">def </span><span class="s0">_get_start_params(self):</span>
        <span class="s2">with </span><span class="s0">warnings.catch_warnings():</span>
            <span class="s0">warnings.simplefilter(</span><span class="s1">&quot;ignore&quot;</span><span class="s2">, </span><span class="s0">category=ConvergenceWarning)</span>
            <span class="s0">start_params = self.model_main.fit(disp=</span><span class="s3">0</span><span class="s2">, </span><span class="s0">method=</span><span class="s1">'nm'</span><span class="s0">).params</span>
        <span class="s0">start_params = np.append(np.zeros(self.k_inflate)</span><span class="s2">, </span><span class="s0">start_params)</span>
        <span class="s2">return </span><span class="s0">start_params</span>

    <span class="s0">@Appender(ZeroInflatedPoisson.get_distribution.__doc__)</span>
    <span class="s2">def </span><span class="s0">get_distribution(self</span><span class="s2">, </span><span class="s0">params</span><span class="s2">, </span><span class="s0">exog=</span><span class="s2">None, </span><span class="s0">exog_infl=</span><span class="s2">None,</span>
                         <span class="s0">exposure=</span><span class="s2">None, </span><span class="s0">offset=</span><span class="s2">None</span><span class="s0">):</span>

        <span class="s0">p = self.model_main.parameterization</span>
        <span class="s0">mu = self.predict(params</span><span class="s2">, </span><span class="s0">exog=exog</span><span class="s2">, </span><span class="s0">exog_infl=exog_infl</span><span class="s2">,</span>
                          <span class="s0">exposure=exposure</span><span class="s2">, </span><span class="s0">offset=offset</span><span class="s2">, </span><span class="s0">which=</span><span class="s1">&quot;mean-main&quot;</span><span class="s0">)</span>
        <span class="s0">w = self.predict(params</span><span class="s2">, </span><span class="s0">exog=exog</span><span class="s2">, </span><span class="s0">exog_infl=exog_infl</span><span class="s2">,</span>
                         <span class="s0">exposure=exposure</span><span class="s2">, </span><span class="s0">offset=offset</span><span class="s2">, </span><span class="s0">which=</span><span class="s1">&quot;prob-main&quot;</span><span class="s0">)</span>

        <span class="s5"># distr = self.distribution(mu[:, None], params[-1], p, 1 - w[:, None])</span>
        <span class="s0">distr = self.distribution(mu</span><span class="s2">, </span><span class="s0">params[-</span><span class="s3">1</span><span class="s0">]</span><span class="s2">, </span><span class="s0">p</span><span class="s2">, </span><span class="s3">1 </span><span class="s0">- w)</span>
        <span class="s2">return </span><span class="s0">distr</span>


<span class="s2">class </span><span class="s0">ZeroInflatedResults(CountResults):</span>

    <span class="s2">def </span><span class="s0">get_prediction(self</span><span class="s2">, </span><span class="s0">exog=</span><span class="s2">None, </span><span class="s0">exog_infl=</span><span class="s2">None, </span><span class="s0">exposure=</span><span class="s2">None,</span>
                       <span class="s0">offset=</span><span class="s2">None, </span><span class="s0">which=</span><span class="s1">'mean'</span><span class="s2">, </span><span class="s0">average=</span><span class="s2">False,</span>
                       <span class="s0">agg_weights=</span><span class="s2">None, </span><span class="s0">y_values=</span><span class="s2">None,</span>
                       <span class="s0">transform=</span><span class="s2">True, </span><span class="s0">row_labels=</span><span class="s2">None</span><span class="s0">):</span>

        <span class="s2">import </span><span class="s0">statsmodels.base._prediction_inference </span><span class="s2">as </span><span class="s0">pred</span>

        <span class="s0">pred_kwds = {</span>
            <span class="s1">'exog_infl'</span><span class="s0">: exog_infl</span><span class="s2">,</span>
            <span class="s1">'exposure'</span><span class="s0">: exposure</span><span class="s2">,</span>
            <span class="s1">'offset'</span><span class="s0">: offset</span><span class="s2">,</span>
            <span class="s1">'y_values'</span><span class="s0">: y_values</span><span class="s2">,</span>
            <span class="s0">}</span>

        <span class="s0">res = pred.get_prediction_delta(self</span><span class="s2">, </span><span class="s0">exog=exog</span><span class="s2">, </span><span class="s0">which=which</span><span class="s2">,</span>
                                        <span class="s0">average=average</span><span class="s2">,</span>
                                        <span class="s0">agg_weights=agg_weights</span><span class="s2">,</span>
                                        <span class="s0">pred_kwds=pred_kwds)</span>
        <span class="s2">return </span><span class="s0">res</span>

    <span class="s2">def </span><span class="s0">get_influence(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Influence and outlier measures 
 
        See notes section for influence measures that do not apply for 
        zero inflated models. 
 
        Returns 
        ------- 
        MLEInfluence 
            The instance has methods to calculate the main influence and 
            outlier measures as attributes. 
 
        See Also 
        -------- 
        statsmodels.stats.outliers_influence.MLEInfluence 
 
        Notes 
        ----- 
        ZeroInflated models have functions that are not differentiable 
        with respect to sample endog if endog=0. This means that generalized 
        leverage cannot be computed in the usual definition. 
 
        Currently, both the generalized leverage, in `hat_matrix_diag` 
        attribute and studetized residuals are not available. In the influence 
        plot generalized leverage is replaced by a hat matrix diagonal that 
        only takes combined exog into account, computed in the same way as 
        for OLS. This is a measure for exog outliers but does not take 
        specific features of the model into account. 
        &quot;&quot;&quot;</span>
        <span class="s5"># same as sumper in DiscreteResults, only added for docstring</span>
        <span class="s2">from </span><span class="s0">statsmodels.stats.outliers_influence </span><span class="s2">import </span><span class="s0">MLEInfluence</span>
        <span class="s2">return </span><span class="s0">MLEInfluence(self)</span>


<span class="s2">class </span><span class="s0">ZeroInflatedPoissonResults(ZeroInflatedResults):</span>
    <span class="s0">__doc__ = _discrete_results_docs % {</span>
    <span class="s1">&quot;one_line_description&quot;</span><span class="s0">: </span><span class="s1">&quot;A results class for Zero Inflated Poisson&quot;</span><span class="s2">,</span>
    <span class="s1">&quot;extra_attr&quot;</span><span class="s0">: </span><span class="s1">&quot;&quot;</span><span class="s0">}</span>

    <span class="s0">@cache_readonly</span>
    <span class="s2">def </span><span class="s0">_dispersion_factor(self):</span>
        <span class="s0">mu = self.predict(which=</span><span class="s1">'linear'</span><span class="s0">)</span>
        <span class="s0">w = </span><span class="s3">1 </span><span class="s0">- self.predict() / np.exp(self.predict(which=</span><span class="s1">'linear'</span><span class="s0">))</span>
        <span class="s2">return </span><span class="s0">(</span><span class="s3">1 </span><span class="s0">+ w * np.exp(mu))</span>

    <span class="s2">def </span><span class="s0">get_margeff(self</span><span class="s2">, </span><span class="s0">at=</span><span class="s1">'overall'</span><span class="s2">, </span><span class="s0">method=</span><span class="s1">'dydx'</span><span class="s2">, </span><span class="s0">atexog=</span><span class="s2">None,</span>
                    <span class="s0">dummy=</span><span class="s2">False, </span><span class="s0">count=</span><span class="s2">False</span><span class="s0">):</span>
        <span class="s4">&quot;&quot;&quot;Get marginal effects of the fitted model. 
 
        Not yet implemented for Zero Inflated Models 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s0">NotImplementedError(</span><span class="s1">&quot;not yet implemented for zero inflation&quot;</span><span class="s0">)</span>


<span class="s2">class </span><span class="s0">L1ZeroInflatedPoissonResults(L1CountResults</span><span class="s2">, </span><span class="s0">ZeroInflatedPoissonResults):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s0">ZeroInflatedPoissonResultsWrapper(lm.RegressionResultsWrapper):</span>
    <span class="s2">pass</span>
<span class="s0">wrap.populate_wrapper(ZeroInflatedPoissonResultsWrapper</span><span class="s2">,</span>
                      <span class="s0">ZeroInflatedPoissonResults)</span>


<span class="s2">class </span><span class="s0">L1ZeroInflatedPoissonResultsWrapper(lm.RegressionResultsWrapper):</span>
    <span class="s2">pass</span>
<span class="s0">wrap.populate_wrapper(L1ZeroInflatedPoissonResultsWrapper</span><span class="s2">,</span>
                      <span class="s0">L1ZeroInflatedPoissonResults)</span>


<span class="s2">class </span><span class="s0">ZeroInflatedGeneralizedPoissonResults(ZeroInflatedResults):</span>
    <span class="s0">__doc__ = _discrete_results_docs % {</span>
        <span class="s1">&quot;one_line_description&quot;</span><span class="s0">: </span><span class="s1">&quot;A results class for Zero Inflated Generalized Poisson&quot;</span><span class="s2">,</span>
        <span class="s1">&quot;extra_attr&quot;</span><span class="s0">: </span><span class="s1">&quot;&quot;</span><span class="s0">}</span>

    <span class="s0">@cache_readonly</span>
    <span class="s2">def </span><span class="s0">_dispersion_factor(self):</span>
        <span class="s0">p = self.model.model_main.parameterization</span>
        <span class="s0">alpha = self.params[self.model.k_inflate:][-</span><span class="s3">1</span><span class="s0">]</span>
        <span class="s0">mu = np.exp(self.predict(which=</span><span class="s1">'linear'</span><span class="s0">))</span>
        <span class="s0">w = </span><span class="s3">1 </span><span class="s0">- self.predict() / mu</span>
        <span class="s2">return </span><span class="s0">((</span><span class="s3">1 </span><span class="s0">+ alpha * mu**p)**</span><span class="s3">2 </span><span class="s0">+ w * mu)</span>

    <span class="s2">def </span><span class="s0">get_margeff(self</span><span class="s2">, </span><span class="s0">at=</span><span class="s1">'overall'</span><span class="s2">, </span><span class="s0">method=</span><span class="s1">'dydx'</span><span class="s2">, </span><span class="s0">atexog=</span><span class="s2">None,</span>
                    <span class="s0">dummy=</span><span class="s2">False, </span><span class="s0">count=</span><span class="s2">False</span><span class="s0">):</span>
        <span class="s4">&quot;&quot;&quot;Get marginal effects of the fitted model. 
 
        Not yet implemented for Zero Inflated Models 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s0">NotImplementedError(</span><span class="s1">&quot;not yet implemented for zero inflation&quot;</span><span class="s0">)</span>


<span class="s2">class </span><span class="s0">L1ZeroInflatedGeneralizedPoissonResults(L1CountResults</span><span class="s2">,</span>
        <span class="s0">ZeroInflatedGeneralizedPoissonResults):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s0">ZeroInflatedGeneralizedPoissonResultsWrapper(</span>
        <span class="s0">lm.RegressionResultsWrapper):</span>
    <span class="s2">pass</span>
<span class="s0">wrap.populate_wrapper(ZeroInflatedGeneralizedPoissonResultsWrapper</span><span class="s2">,</span>
                      <span class="s0">ZeroInflatedGeneralizedPoissonResults)</span>


<span class="s2">class </span><span class="s0">L1ZeroInflatedGeneralizedPoissonResultsWrapper(</span>
        <span class="s0">lm.RegressionResultsWrapper):</span>
    <span class="s2">pass</span>
<span class="s0">wrap.populate_wrapper(L1ZeroInflatedGeneralizedPoissonResultsWrapper</span><span class="s2">,</span>
                      <span class="s0">L1ZeroInflatedGeneralizedPoissonResults)</span>


<span class="s2">class </span><span class="s0">ZeroInflatedNegativeBinomialResults(ZeroInflatedResults):</span>
    <span class="s0">__doc__ = _discrete_results_docs % {</span>
        <span class="s1">&quot;one_line_description&quot;</span><span class="s0">: </span><span class="s1">&quot;A results class for Zero Inflated Generalized Negative Binomial&quot;</span><span class="s2">,</span>
        <span class="s1">&quot;extra_attr&quot;</span><span class="s0">: </span><span class="s1">&quot;&quot;</span><span class="s0">}</span>

    <span class="s0">@cache_readonly</span>
    <span class="s2">def </span><span class="s0">_dispersion_factor(self):</span>
        <span class="s0">p = self.model.model_main.parameterization</span>
        <span class="s0">alpha = self.params[self.model.k_inflate:][-</span><span class="s3">1</span><span class="s0">]</span>
        <span class="s0">mu = np.exp(self.predict(which=</span><span class="s1">'linear'</span><span class="s0">))</span>
        <span class="s0">w = </span><span class="s3">1 </span><span class="s0">- self.predict() / mu</span>
        <span class="s2">return </span><span class="s0">(</span><span class="s3">1 </span><span class="s0">+ alpha * mu**(p-</span><span class="s3">1</span><span class="s0">) + w * mu)</span>

    <span class="s2">def </span><span class="s0">get_margeff(self</span><span class="s2">, </span><span class="s0">at=</span><span class="s1">'overall'</span><span class="s2">, </span><span class="s0">method=</span><span class="s1">'dydx'</span><span class="s2">, </span><span class="s0">atexog=</span><span class="s2">None,</span>
            <span class="s0">dummy=</span><span class="s2">False, </span><span class="s0">count=</span><span class="s2">False</span><span class="s0">):</span>
        <span class="s4">&quot;&quot;&quot;Get marginal effects of the fitted model. 
 
        Not yet implemented for Zero Inflated Models 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s0">NotImplementedError(</span><span class="s1">&quot;not yet implemented for zero inflation&quot;</span><span class="s0">)</span>


<span class="s2">class </span><span class="s0">L1ZeroInflatedNegativeBinomialResults(L1CountResults</span><span class="s2">,</span>
        <span class="s0">ZeroInflatedNegativeBinomialResults):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s0">ZeroInflatedNegativeBinomialResultsWrapper(</span>
        <span class="s0">lm.RegressionResultsWrapper):</span>
    <span class="s2">pass</span>
<span class="s0">wrap.populate_wrapper(ZeroInflatedNegativeBinomialResultsWrapper</span><span class="s2">,</span>
                      <span class="s0">ZeroInflatedNegativeBinomialResults)</span>


<span class="s2">class </span><span class="s0">L1ZeroInflatedNegativeBinomialResultsWrapper(</span>
        <span class="s0">lm.RegressionResultsWrapper):</span>
    <span class="s2">pass</span>
<span class="s0">wrap.populate_wrapper(L1ZeroInflatedNegativeBinomialResultsWrapper</span><span class="s2">,</span>
                      <span class="s0">L1ZeroInflatedNegativeBinomialResults)</span>
</pre>
</body>
</html>