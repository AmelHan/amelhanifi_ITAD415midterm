<html>
<head>
<title>contrasts.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
contrasts.py</font>
</center></td></tr></table>
<pre><span class="s0"># This file is part of Patsy</span>
<span class="s0"># Copyright (C) 2011-2012 Nathaniel Smith &lt;njs@pobox.com&gt;</span>
<span class="s0"># See file LICENSE.txt for license information.</span>

<span class="s0"># http://www.ats.ucla.edu/stat/r/library/contrast_coding.htm</span>
<span class="s0"># http://www.ats.ucla.edu/stat/sas/webbooks/reg/chapter5/sasreg5.htm</span>

<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">print_function</span>

<span class="s0"># These are made available in the patsy.* namespace</span>
<span class="s1">__all__ = [</span><span class="s3">&quot;ContrastMatrix&quot;</span><span class="s2">, </span><span class="s3">&quot;Treatment&quot;</span><span class="s2">, </span><span class="s3">&quot;Poly&quot;</span><span class="s2">, </span><span class="s3">&quot;Sum&quot;</span><span class="s2">, </span><span class="s3">&quot;Helmert&quot;</span><span class="s2">, </span><span class="s3">&quot;Diff&quot;</span><span class="s1">]</span>

<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">six</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">patsy </span><span class="s2">import </span><span class="s1">PatsyError</span>
<span class="s2">from </span><span class="s1">patsy.util </span><span class="s2">import </span><span class="s1">(repr_pretty_delegate</span><span class="s2">, </span><span class="s1">repr_pretty_impl</span><span class="s2">,</span>
                        <span class="s1">safe_issubdtype</span><span class="s2">,</span>
                        <span class="s1">no_pickling</span><span class="s2">, </span><span class="s1">assert_no_pickling)</span>

<span class="s2">class </span><span class="s1">ContrastMatrix(object):</span>
    <span class="s4">&quot;&quot;&quot;A simple container for a matrix used for coding categorical factors. 
 
    Attributes: 
 
    .. attribute:: matrix 
 
       A 2d ndarray, where each column corresponds to one column of the 
       resulting design matrix, and each row contains the entries for a single 
       categorical variable level. Usually n-by-n for a full rank coding or 
       n-by-(n-1) for a reduced rank coding, though other options are 
       possible. 
 
    .. attribute:: column_suffixes 
 
       A list of strings to be appended to the factor name, to produce the 
       final column names. E.g. for treatment coding the entries will look 
       like ``&quot;[T.level1]&quot;``. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">matrix</span><span class="s2">, </span><span class="s1">column_suffixes):</span>
        <span class="s1">self.matrix = np.asarray(matrix)</span>
        <span class="s1">self.column_suffixes = column_suffixes</span>
        <span class="s2">if </span><span class="s1">self.matrix.shape[</span><span class="s5">1</span><span class="s1">] != len(column_suffixes):</span>
            <span class="s2">raise </span><span class="s1">PatsyError(</span><span class="s3">&quot;matrix and column_suffixes don't conform&quot;</span><span class="s1">)</span>

    <span class="s1">__repr__ = repr_pretty_delegate</span>
    <span class="s2">def </span><span class="s1">_repr_pretty_(self</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">cycle):</span>
        <span class="s1">repr_pretty_impl(p</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">[self.matrix</span><span class="s2">, </span><span class="s1">self.column_suffixes])</span>

    <span class="s1">__getstate__ = no_pickling</span>

<span class="s2">def </span><span class="s1">test_ContrastMatrix():</span>
    <span class="s1">cm = ContrastMatrix([[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">])</span>
    <span class="s2">assert </span><span class="s1">np.array_equal(cm.matrix</span><span class="s2">, </span><span class="s1">np.eye(</span><span class="s5">2</span><span class="s1">))</span>
    <span class="s2">assert </span><span class="s1">cm.column_suffixes == [</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">]</span>
    <span class="s0"># smoke test</span>
    <span class="s1">repr(cm)</span>

    <span class="s2">import </span><span class="s1">pytest</span>
    <span class="s1">pytest.raises(PatsyError</span><span class="s2">, </span><span class="s1">ContrastMatrix</span><span class="s2">, </span><span class="s1">[[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">])</span>

    <span class="s1">assert_no_pickling(cm)</span>

<span class="s0"># This always produces an object of the type that Python calls 'str' (whether</span>
<span class="s0"># that be a Python 2 string-of-bytes or a Python 3 string-of-unicode). It does</span>
<span class="s0"># *not* make any particular guarantees about being reversible or having other</span>
<span class="s0"># such useful programmatic properties -- it just produces something that will</span>
<span class="s0"># be nice for users to look at.</span>
<span class="s2">def </span><span class="s1">_obj_to_readable_str(obj):</span>
    <span class="s2">if </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s2">return </span><span class="s1">obj</span>
    <span class="s2">elif </span><span class="s1">sys.version_info &gt;= (</span><span class="s5">3</span><span class="s2">,</span><span class="s1">) </span><span class="s2">and </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">bytes):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">obj.decode(</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">UnicodeDecodeError:</span>
            <span class="s2">return </span><span class="s1">repr(obj)</span>
    <span class="s2">elif </span><span class="s1">sys.version_info &lt; (</span><span class="s5">3</span><span class="s2">,</span><span class="s1">) </span><span class="s2">and </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">unicode):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">obj.encode(</span><span class="s3">&quot;ascii&quot;</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">UnicodeEncodeError:</span>
            <span class="s2">return </span><span class="s1">repr(obj)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">repr(obj)</span>

<span class="s2">def </span><span class="s1">test__obj_to_readable_str():</span>
    <span class="s2">def </span><span class="s1">t(obj</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s1">got = _obj_to_readable_str(obj)</span>
        <span class="s2">assert </span><span class="s1">type(got) </span><span class="s2">is </span><span class="s1">str</span>
        <span class="s2">assert </span><span class="s1">got == expected</span>
    <span class="s1">t(</span><span class="s5">1</span><span class="s2">, </span><span class="s3">&quot;1&quot;</span><span class="s1">)</span>
    <span class="s1">t(</span><span class="s5">1.0</span><span class="s2">, </span><span class="s3">&quot;1.0&quot;</span><span class="s1">)</span>
    <span class="s1">t(</span><span class="s3">&quot;asdf&quot;</span><span class="s2">, </span><span class="s3">&quot;asdf&quot;</span><span class="s1">)</span>
    <span class="s1">t(six.u(</span><span class="s3">&quot;asdf&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;asdf&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s5">3</span><span class="s2">,</span><span class="s1">):</span>
        <span class="s0"># we can use &quot;foo&quot;.encode here b/c this is python 3!</span>
        <span class="s0"># a utf-8 encoded euro-sign comes out as a real euro sign.</span>
        <span class="s1">t(</span><span class="s3">&quot;</span><span class="s2">\u20ac</span><span class="s3">&quot;</span><span class="s1">.encode(</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">six.u(</span><span class="s3">&quot;</span><span class="s2">\u20ac</span><span class="s3">&quot;</span><span class="s1">))</span>
        <span class="s0"># but a iso-8859-15 euro sign can't be decoded, and we fall back on</span>
        <span class="s0"># repr()</span>
        <span class="s1">t(</span><span class="s3">&quot;</span><span class="s2">\u20ac</span><span class="s3">&quot;</span><span class="s1">.encode(</span><span class="s3">&quot;iso-8859-15&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;b'</span><span class="s2">\\</span><span class="s3">xa4'&quot;</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">t(six.u(</span><span class="s3">&quot;</span><span class="s2">\u20ac</span><span class="s3">&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;u'</span><span class="s2">\\</span><span class="s3">u20ac'&quot;</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">_name_levels(prefix</span><span class="s2">, </span><span class="s1">levels):</span>
    <span class="s2">return </span><span class="s1">[</span><span class="s3">&quot;[%s%s]&quot; </span><span class="s1">% (prefix</span><span class="s2">, </span><span class="s1">_obj_to_readable_str(level)) </span><span class="s2">for </span><span class="s1">level </span><span class="s2">in </span><span class="s1">levels]</span>

<span class="s2">def </span><span class="s1">test__name_levels():</span>
    <span class="s2">assert </span><span class="s1">_name_levels(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">]) == [</span><span class="s3">&quot;[ab]&quot;</span><span class="s2">, </span><span class="s3">&quot;[ac]&quot;</span><span class="s1">]</span>

<span class="s2">def </span><span class="s1">_dummy_code(levels):</span>
    <span class="s2">return </span><span class="s1">ContrastMatrix(np.eye(len(levels))</span><span class="s2">, </span><span class="s1">_name_levels(</span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s1">levels))</span>

<span class="s2">def </span><span class="s1">_get_level(levels</span><span class="s2">, </span><span class="s1">level_ref):</span>
    <span class="s2">if </span><span class="s1">level_ref </span><span class="s2">in </span><span class="s1">levels:</span>
        <span class="s2">return </span><span class="s1">levels.index(level_ref)</span>
    <span class="s2">if </span><span class="s1">isinstance(level_ref</span><span class="s2">, </span><span class="s1">six.integer_types):</span>
        <span class="s2">if </span><span class="s1">level_ref &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">level_ref += len(levels)</span>
        <span class="s2">if not </span><span class="s1">(</span><span class="s5">0 </span><span class="s1">&lt;= level_ref &lt; len(levels)):</span>
            <span class="s2">raise </span><span class="s1">PatsyError(</span><span class="s3">&quot;specified level %r is out of range&quot;</span>
                                <span class="s1">% (level_ref</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s2">return </span><span class="s1">level_ref</span>
    <span class="s2">raise </span><span class="s1">PatsyError(</span><span class="s3">&quot;specified level %r not found&quot; </span><span class="s1">% (level_ref</span><span class="s2">,</span><span class="s1">))</span>

<span class="s2">def </span><span class="s1">test__get_level():</span>
    <span class="s2">assert </span><span class="s1">_get_level([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s5">0</span><span class="s1">) == </span><span class="s5">0</span>
    <span class="s2">assert </span><span class="s1">_get_level([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">) == </span><span class="s5">2</span>
    <span class="s2">assert </span><span class="s1">_get_level([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">) == </span><span class="s5">1</span>
    <span class="s0"># For integer levels, we check identity before treating it as an index</span>
    <span class="s2">assert </span><span class="s1">_get_level([</span><span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">0</span><span class="s1">) == </span><span class="s5">2</span>
    <span class="s2">import </span><span class="s1">pytest</span>
    <span class="s1">pytest.raises(PatsyError</span><span class="s2">, </span><span class="s1">_get_level</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">pytest.raises(PatsyError</span><span class="s2">, </span><span class="s1">_get_level</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">-</span><span class="s5">3</span><span class="s1">)</span>
    <span class="s1">pytest.raises(PatsyError</span><span class="s2">, </span><span class="s1">_get_level</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)</span>

    <span class="s2">if not </span><span class="s1">six.PY3:</span>
        <span class="s2">assert </span><span class="s1">_get_level([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">long(</span><span class="s5">0</span><span class="s1">)) == </span><span class="s5">0</span>
        <span class="s2">assert </span><span class="s1">_get_level([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">long(-</span><span class="s5">1</span><span class="s1">)) == </span><span class="s5">2</span>
        <span class="s2">assert </span><span class="s1">_get_level([</span><span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">long(</span><span class="s5">0</span><span class="s1">)) == </span><span class="s5">2</span>


<span class="s2">class </span><span class="s1">Treatment(object):</span>
    <span class="s4">&quot;&quot;&quot;Treatment coding (also known as dummy coding). 
 
    This is the default coding. 
 
    For reduced-rank coding, one level is chosen as the &quot;reference&quot;, and its 
    mean behaviour is represented by the intercept. Each column of the 
    resulting matrix represents the difference between the mean of one level 
    and this reference level. 
 
    For full-rank coding, classic &quot;dummy&quot; coding is used, and each column of 
    the resulting matrix represents the mean of the corresponding level. 
 
    The reference level defaults to the first level, or can be specified 
    explicitly. 
 
    .. ipython:: python 
 
       # reduced rank 
       dmatrix(&quot;C(a, Treatment)&quot;, balanced(a=3)) 
       # full rank 
       dmatrix(&quot;0 + C(a, Treatment)&quot;, balanced(a=3)) 
       # Setting a reference level 
       dmatrix(&quot;C(a, Treatment(1))&quot;, balanced(a=3)) 
       dmatrix(&quot;C(a, Treatment('a2'))&quot;, balanced(a=3)) 
 
    Equivalent to R ``contr.treatment``. The R documentation suggests that 
    using ``Treatment(reference=-1)`` will produce contrasts that are 
    &quot;equivalent to those produced by many (but not all) SAS procedures&quot;. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">reference=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self.reference = reference</span>

    <span class="s2">def </span><span class="s1">code_with_intercept(self</span><span class="s2">, </span><span class="s1">levels):</span>
        <span class="s2">return </span><span class="s1">_dummy_code(levels)</span>

    <span class="s2">def </span><span class="s1">code_without_intercept(self</span><span class="s2">, </span><span class="s1">levels):</span>
        <span class="s2">if </span><span class="s1">self.reference </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">reference = </span><span class="s5">0</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">reference = _get_level(levels</span><span class="s2">, </span><span class="s1">self.reference)</span>
        <span class="s1">eye = np.eye(len(levels) - </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">contrasts = np.vstack((eye[:reference</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">,</span>
                                <span class="s1">np.zeros((</span><span class="s5">1</span><span class="s2">, </span><span class="s1">len(levels) - </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
                                <span class="s1">eye[reference:</span><span class="s2">, </span><span class="s1">:]))</span>
        <span class="s1">names = _name_levels(</span><span class="s3">&quot;T.&quot;</span><span class="s2">, </span><span class="s1">levels[:reference] + levels[reference + </span><span class="s5">1</span><span class="s1">:])</span>
        <span class="s2">return </span><span class="s1">ContrastMatrix(contrasts</span><span class="s2">, </span><span class="s1">names)</span>

    <span class="s1">__getstate__ = no_pickling</span>

<span class="s2">def </span><span class="s1">test_Treatment():</span>
    <span class="s1">t1 = Treatment()</span>
    <span class="s1">matrix = t1.code_with_intercept([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s2">assert </span><span class="s1">matrix.column_suffixes == [</span><span class="s3">&quot;[a]&quot;</span><span class="s2">, </span><span class="s3">&quot;[b]&quot;</span><span class="s2">, </span><span class="s3">&quot;[c]&quot;</span><span class="s1">]</span>
    <span class="s2">assert </span><span class="s1">np.allclose(matrix.matrix</span><span class="s2">, </span><span class="s1">[[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]])</span>
    <span class="s1">matrix = t1.code_without_intercept([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s2">assert </span><span class="s1">matrix.column_suffixes == [</span><span class="s3">&quot;[T.b]&quot;</span><span class="s2">, </span><span class="s3">&quot;[T.c]&quot;</span><span class="s1">]</span>
    <span class="s2">assert </span><span class="s1">np.allclose(matrix.matrix</span><span class="s2">, </span><span class="s1">[[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]])</span>
    <span class="s1">matrix = Treatment(reference=</span><span class="s5">1</span><span class="s1">).code_without_intercept([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s2">assert </span><span class="s1">matrix.column_suffixes == [</span><span class="s3">&quot;[T.a]&quot;</span><span class="s2">, </span><span class="s3">&quot;[T.c]&quot;</span><span class="s1">]</span>
    <span class="s2">assert </span><span class="s1">np.allclose(matrix.matrix</span><span class="s2">, </span><span class="s1">[[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]])</span>
    <span class="s1">matrix = Treatment(reference=-</span><span class="s5">2</span><span class="s1">).code_without_intercept([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s2">assert </span><span class="s1">matrix.column_suffixes == [</span><span class="s3">&quot;[T.a]&quot;</span><span class="s2">, </span><span class="s3">&quot;[T.c]&quot;</span><span class="s1">]</span>
    <span class="s2">assert </span><span class="s1">np.allclose(matrix.matrix</span><span class="s2">, </span><span class="s1">[[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]])</span>
    <span class="s1">matrix = Treatment(reference=</span><span class="s3">&quot;b&quot;</span><span class="s1">).code_without_intercept([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s2">assert </span><span class="s1">matrix.column_suffixes == [</span><span class="s3">&quot;[T.a]&quot;</span><span class="s2">, </span><span class="s3">&quot;[T.c]&quot;</span><span class="s1">]</span>
    <span class="s2">assert </span><span class="s1">np.allclose(matrix.matrix</span><span class="s2">, </span><span class="s1">[[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]])</span>
    <span class="s0"># Make sure the default is always the first level, even if there is a</span>
    <span class="s0"># different level called 0.</span>
    <span class="s1">matrix = Treatment().code_without_intercept([</span><span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">])</span>
    <span class="s2">assert </span><span class="s1">matrix.column_suffixes == [</span><span class="s3">&quot;[T.1]&quot;</span><span class="s2">, </span><span class="s3">&quot;[T.0]&quot;</span><span class="s1">]</span>
    <span class="s2">assert </span><span class="s1">np.allclose(matrix.matrix</span><span class="s2">, </span><span class="s1">[[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]])</span>

<span class="s2">class </span><span class="s1">Poly(object):</span>
    <span class="s4">&quot;&quot;&quot;Orthogonal polynomial contrast coding. 
 
    This coding scheme treats the levels as ordered samples from an underlying 
    continuous scale, whose effect takes an unknown functional form which is 
    `Taylor-decomposed`__ into the sum of a linear, quadratic, etc. components. 
 
    .. __: https://en.wikipedia.org/wiki/Taylor_series 
 
    For reduced-rank coding, you get a linear column, a quadratic column, 
    etc., up to the number of levels provided. 
 
    For full-rank coding, the same scheme is used, except that the zero-order 
    constant polynomial is also included. I.e., you get an intercept column 
    included as part of your categorical term. 
 
    By default the levels are treated as equally spaced, but you can override 
    this by providing a value for the `scores` argument. 
 
    Examples: 
 
    .. ipython:: python 
 
       # Reduced rank 
       dmatrix(&quot;C(a, Poly)&quot;, balanced(a=4)) 
       # Full rank 
       dmatrix(&quot;0 + C(a, Poly)&quot;, balanced(a=3)) 
       # Explicit scores 
       dmatrix(&quot;C(a, Poly([1, 2, 10]))&quot;, balanced(a=3)) 
 
    This is equivalent to R's ``contr.poly``. (But note that in R, reduced 
    rank encodings are always dummy-coded, regardless of what contrast you 
    have set.) 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">scores=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self.scores = scores</span>

    <span class="s2">def </span><span class="s1">_code_either(self</span><span class="s2">, </span><span class="s1">intercept</span><span class="s2">, </span><span class="s1">levels):</span>
        <span class="s1">n = len(levels)</span>
        <span class="s1">scores = self.scores</span>
        <span class="s2">if </span><span class="s1">scores </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">scores = np.arange(n)</span>
        <span class="s1">scores = np.asarray(scores</span><span class="s2">, </span><span class="s1">dtype=float)</span>
        <span class="s2">if </span><span class="s1">len(scores) != n:</span>
            <span class="s2">raise </span><span class="s1">PatsyError(</span><span class="s3">&quot;number of levels (%s) does not match&quot;</span>
                                <span class="s3">&quot; number of scores (%s)&quot;</span>
                                <span class="s1">% (n</span><span class="s2">, </span><span class="s1">len(scores)))</span>
        <span class="s0"># Strategy: just make a matrix whose columns are naive linear,</span>
        <span class="s0"># quadratic, etc., functions of the raw scores, and then use 'qr' to</span>
        <span class="s0"># orthogonalize each column against those to its left.</span>
        <span class="s1">scores -= scores.mean()</span>
        <span class="s1">raw_poly = scores.reshape((-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)) ** np.arange(n).reshape((</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">q</span><span class="s2">, </span><span class="s1">r = np.linalg.qr(raw_poly)</span>
        <span class="s1">q *= np.sign(np.diag(r))</span>
        <span class="s1">q /= np.sqrt(np.sum(q ** </span><span class="s5">2</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">1</span><span class="s1">))</span>
        <span class="s0"># The constant term is always all 1's -- we don't normalize it.</span>
        <span class="s1">q[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = </span><span class="s5">1</span>
        <span class="s1">names = [</span><span class="s3">&quot;.Constant&quot;</span><span class="s2">, </span><span class="s3">&quot;.Linear&quot;</span><span class="s2">, </span><span class="s3">&quot;.Quadratic&quot;</span><span class="s2">, </span><span class="s3">&quot;.Cubic&quot;</span><span class="s1">]</span>
        <span class="s1">names += [</span><span class="s3">&quot;^%s&quot; </span><span class="s1">% (i</span><span class="s2">,</span><span class="s1">) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">4</span><span class="s2">, </span><span class="s1">n)]</span>
        <span class="s1">names = names[:n]</span>
        <span class="s2">if </span><span class="s1">intercept:</span>
            <span class="s2">return </span><span class="s1">ContrastMatrix(q</span><span class="s2">, </span><span class="s1">names)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># We always include the constant/intercept column as something to</span>
            <span class="s0"># orthogonalize against, but we don't always return it:</span>
            <span class="s2">return </span><span class="s1">ContrastMatrix(q[:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">names[</span><span class="s5">1</span><span class="s1">:])</span>

    <span class="s2">def </span><span class="s1">code_with_intercept(self</span><span class="s2">, </span><span class="s1">levels):</span>
        <span class="s2">return </span><span class="s1">self._code_either(</span><span class="s2">True, </span><span class="s1">levels)</span>

    <span class="s2">def </span><span class="s1">code_without_intercept(self</span><span class="s2">, </span><span class="s1">levels):</span>
        <span class="s2">return </span><span class="s1">self._code_either(</span><span class="s2">False, </span><span class="s1">levels)</span>

    <span class="s1">__getstate__ = no_pickling</span>

<span class="s2">def </span><span class="s1">test_Poly():</span>
    <span class="s1">t1 = Poly()</span>
    <span class="s1">matrix = t1.code_with_intercept([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s2">assert </span><span class="s1">matrix.column_suffixes == [</span><span class="s3">&quot;.Constant&quot;</span><span class="s2">, </span><span class="s3">&quot;.Linear&quot;</span><span class="s2">, </span><span class="s3">&quot;.Quadratic&quot;</span><span class="s1">]</span>
    <span class="s0"># Values from R 'options(digits=15); contr.poly(3)'</span>
    <span class="s1">expected = [[</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">7.07106781186548e-01</span><span class="s2">, </span><span class="s5">0.408248290463863</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.816496580927726</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">7.07106781186547e-01</span><span class="s2">, </span><span class="s5">0.408248290463863</span><span class="s1">]]</span>
    <span class="s1">print(matrix.matrix)</span>
    <span class="s2">assert </span><span class="s1">np.allclose(matrix.matrix</span><span class="s2">, </span><span class="s1">expected)</span>
    <span class="s1">matrix = t1.code_without_intercept([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s2">assert </span><span class="s1">matrix.column_suffixes == [</span><span class="s3">&quot;.Linear&quot;</span><span class="s2">, </span><span class="s3">&quot;.Quadratic&quot;</span><span class="s1">]</span>
    <span class="s0"># Values from R 'options(digits=15); contr.poly(3)'</span>
    <span class="s1">print(matrix.matrix)</span>
    <span class="s2">assert </span><span class="s1">np.allclose(matrix.matrix</span><span class="s2">,</span>
                       <span class="s1">[[-</span><span class="s5">7.07106781186548e-01</span><span class="s2">, </span><span class="s5">0.408248290463863</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.816496580927726</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s5">7.07106781186547e-01</span><span class="s2">, </span><span class="s5">0.408248290463863</span><span class="s1">]])</span>

    <span class="s1">matrix = Poly(scores=[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">11</span><span class="s1">]).code_with_intercept([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s2">assert </span><span class="s1">matrix.column_suffixes == [</span><span class="s3">&quot;.Constant&quot;</span><span class="s2">, </span><span class="s3">&quot;.Linear&quot;</span><span class="s2">, </span><span class="s3">&quot;.Quadratic&quot;</span><span class="s1">]</span>
    <span class="s0"># Values from R 'options(digits=15); contr.poly(3, scores=c(0, 10, 11))'</span>
    <span class="s1">print(matrix.matrix)</span>
    <span class="s2">assert </span><span class="s1">np.allclose(matrix.matrix</span><span class="s2">,</span>
                       <span class="s1">[[</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.813733471206735</span><span class="s2">, </span><span class="s5">0.0671156055214024</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0.348742916231458</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.7382716607354268</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0.464990554975277</span><span class="s2">, </span><span class="s5">0.6711560552140243</span><span class="s1">]])</span>

    <span class="s0"># we had an integer/float handling bug for score vectors whose mean was</span>
    <span class="s0"># non-integer, so check one of those:</span>
    <span class="s1">matrix = Poly(scores=[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">12</span><span class="s1">]).code_with_intercept([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s2">assert </span><span class="s1">matrix.column_suffixes == [</span><span class="s3">&quot;.Constant&quot;</span><span class="s2">, </span><span class="s3">&quot;.Linear&quot;</span><span class="s2">, </span><span class="s3">&quot;.Quadratic&quot;</span><span class="s1">]</span>
    <span class="s0"># Values from R 'options(digits=15); contr.poly(3, scores=c(0, 10, 12))'</span>
    <span class="s1">print(matrix.matrix)</span>
    <span class="s2">assert </span><span class="s1">np.allclose(matrix.matrix</span><span class="s2">,</span>
                       <span class="s1">[[</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.806559132617443</span><span class="s2">, </span><span class="s5">0.127000127000191</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0.293294230042706</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.762000762001143</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0.513264902574736</span><span class="s2">, </span><span class="s5">0.635000635000952</span><span class="s1">]])</span>

    <span class="s2">import </span><span class="s1">pytest</span>
    <span class="s1">pytest.raises(PatsyError</span><span class="s2">,</span>
                  <span class="s1">Poly(scores=[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]).code_with_intercept</span><span class="s2">,</span>
                  <span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">])</span>

    <span class="s1">matrix = t1.code_with_intercept(list(range(</span><span class="s5">6</span><span class="s1">)))</span>
    <span class="s2">assert </span><span class="s1">matrix.column_suffixes == [</span><span class="s3">&quot;.Constant&quot;</span><span class="s2">, </span><span class="s3">&quot;.Linear&quot;</span><span class="s2">, </span><span class="s3">&quot;.Quadratic&quot;</span><span class="s2">,</span>
                                      <span class="s3">&quot;.Cubic&quot;</span><span class="s2">, </span><span class="s3">&quot;^4&quot;</span><span class="s2">, </span><span class="s3">&quot;^5&quot;</span><span class="s1">]</span>


<span class="s2">class </span><span class="s1">Sum(object):</span>
    <span class="s4">&quot;&quot;&quot;Deviation coding (also known as sum-to-zero coding). 
 
    Compares the mean of each level to the mean-of-means. (In a balanced 
    design, compares the mean of each level to the overall mean.) 
 
    For full-rank coding, a standard intercept term is added. 
 
    One level must be omitted to avoid redundancy; by default this is the last 
    level, but this can be adjusted via the `omit` argument. 
 
    .. warning:: There are multiple definitions of 'deviation coding' in 
       use. Make sure this is the one you expect before trying to interpret 
       your results! 
 
    Examples: 
 
    .. ipython:: python 
 
       # Reduced rank 
       dmatrix(&quot;C(a, Sum)&quot;, balanced(a=4)) 
       # Full rank 
       dmatrix(&quot;0 + C(a, Sum)&quot;, balanced(a=4)) 
       # Omit a different level 
       dmatrix(&quot;C(a, Sum(1))&quot;, balanced(a=3)) 
       dmatrix(&quot;C(a, Sum('a1'))&quot;, balanced(a=3)) 
 
    This is equivalent to R's `contr.sum`. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">omit=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self.omit = omit</span>

    <span class="s2">def </span><span class="s1">_omit_i(self</span><span class="s2">, </span><span class="s1">levels):</span>
        <span class="s2">if </span><span class="s1">self.omit </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s0"># We assume below that this is positive</span>
            <span class="s2">return </span><span class="s1">len(levels) - </span><span class="s5">1</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">_get_level(levels</span><span class="s2">, </span><span class="s1">self.omit)</span>

    <span class="s2">def </span><span class="s1">_sum_contrast(self</span><span class="s2">, </span><span class="s1">levels):</span>
        <span class="s1">n = len(levels)</span>
        <span class="s1">omit_i = self._omit_i(levels)</span>
        <span class="s1">eye = np.eye(n - </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">out = np.empty((n</span><span class="s2">, </span><span class="s1">n - </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">out[:omit_i</span><span class="s2">, </span><span class="s1">:] = eye[:omit_i</span><span class="s2">, </span><span class="s1">:]</span>
        <span class="s1">out[omit_i</span><span class="s2">, </span><span class="s1">:] = -</span><span class="s5">1</span>
        <span class="s1">out[omit_i + </span><span class="s5">1</span><span class="s1">:</span><span class="s2">, </span><span class="s1">:] = eye[omit_i:</span><span class="s2">, </span><span class="s1">:]</span>
        <span class="s2">return </span><span class="s1">out</span>

    <span class="s2">def </span><span class="s1">code_with_intercept(self</span><span class="s2">, </span><span class="s1">levels):</span>
        <span class="s1">contrast = self.code_without_intercept(levels)</span>
        <span class="s1">matrix = np.column_stack((np.ones(len(levels))</span><span class="s2">,</span>
                                  <span class="s1">contrast.matrix))</span>
        <span class="s1">column_suffixes = [</span><span class="s3">&quot;[mean]&quot;</span><span class="s1">] + contrast.column_suffixes</span>
        <span class="s2">return </span><span class="s1">ContrastMatrix(matrix</span><span class="s2">, </span><span class="s1">column_suffixes)</span>

    <span class="s2">def </span><span class="s1">code_without_intercept(self</span><span class="s2">, </span><span class="s1">levels):</span>
        <span class="s1">matrix = self._sum_contrast(levels)</span>
        <span class="s1">omit_i = self._omit_i(levels)</span>
        <span class="s1">included_levels = levels[:omit_i] + levels[omit_i + </span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s2">return </span><span class="s1">ContrastMatrix(matrix</span><span class="s2">, </span><span class="s1">_name_levels(</span><span class="s3">&quot;S.&quot;</span><span class="s2">, </span><span class="s1">included_levels))</span>

    <span class="s1">__getstate__ = no_pickling</span>

<span class="s2">def </span><span class="s1">test_Sum():</span>
    <span class="s1">t1 = Sum()</span>
    <span class="s1">matrix = t1.code_with_intercept([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s2">assert </span><span class="s1">matrix.column_suffixes == [</span><span class="s3">&quot;[mean]&quot;</span><span class="s2">, </span><span class="s3">&quot;[S.a]&quot;</span><span class="s2">, </span><span class="s3">&quot;[S.b]&quot;</span><span class="s1">]</span>
    <span class="s2">assert </span><span class="s1">np.allclose(matrix.matrix</span><span class="s2">, </span><span class="s1">[[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]])</span>
    <span class="s1">matrix = t1.code_without_intercept([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s2">assert </span><span class="s1">matrix.column_suffixes == [</span><span class="s3">&quot;[S.a]&quot;</span><span class="s2">, </span><span class="s3">&quot;[S.b]&quot;</span><span class="s1">]</span>
    <span class="s2">assert </span><span class="s1">np.allclose(matrix.matrix</span><span class="s2">, </span><span class="s1">[[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]])</span>
    <span class="s0"># Check that it's not thrown off by negative integer term names</span>
    <span class="s1">matrix = t1.code_without_intercept([-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2</span><span class="s2">, </span><span class="s1">-</span><span class="s5">3</span><span class="s1">])</span>
    <span class="s2">assert </span><span class="s1">matrix.column_suffixes == [</span><span class="s3">&quot;[S.-1]&quot;</span><span class="s2">, </span><span class="s3">&quot;[S.-2]&quot;</span><span class="s1">]</span>
    <span class="s2">assert </span><span class="s1">np.allclose(matrix.matrix</span><span class="s2">, </span><span class="s1">[[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]])</span>
    <span class="s1">t2 = Sum(omit=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">matrix = t2.code_with_intercept([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s2">assert </span><span class="s1">matrix.column_suffixes == [</span><span class="s3">&quot;[mean]&quot;</span><span class="s2">, </span><span class="s3">&quot;[S.a]&quot;</span><span class="s2">, </span><span class="s3">&quot;[S.c]&quot;</span><span class="s1">]</span>
    <span class="s2">assert </span><span class="s1">np.allclose(matrix.matrix</span><span class="s2">, </span><span class="s1">[[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]])</span>
    <span class="s1">matrix = t2.code_without_intercept([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s2">assert </span><span class="s1">matrix.column_suffixes == [</span><span class="s3">&quot;[S.a]&quot;</span><span class="s2">, </span><span class="s3">&quot;[S.c]&quot;</span><span class="s1">]</span>
    <span class="s2">assert </span><span class="s1">np.allclose(matrix.matrix</span><span class="s2">, </span><span class="s1">[[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]])</span>
    <span class="s1">matrix = t2.code_without_intercept([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s1">])</span>
    <span class="s2">assert </span><span class="s1">matrix.column_suffixes == [</span><span class="s3">&quot;[S.0]&quot;</span><span class="s2">, </span><span class="s3">&quot;[S.2]&quot;</span><span class="s1">]</span>
    <span class="s2">assert </span><span class="s1">np.allclose(matrix.matrix</span><span class="s2">, </span><span class="s1">[[-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]])</span>
    <span class="s1">t3 = Sum(omit=-</span><span class="s5">3</span><span class="s1">)</span>
    <span class="s1">matrix = t3.code_with_intercept([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s2">assert </span><span class="s1">matrix.column_suffixes == [</span><span class="s3">&quot;[mean]&quot;</span><span class="s2">, </span><span class="s3">&quot;[S.b]&quot;</span><span class="s2">, </span><span class="s3">&quot;[S.c]&quot;</span><span class="s1">]</span>
    <span class="s2">assert </span><span class="s1">np.allclose(matrix.matrix</span><span class="s2">, </span><span class="s1">[[</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]])</span>
    <span class="s1">matrix = t3.code_without_intercept([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s2">assert </span><span class="s1">matrix.column_suffixes == [</span><span class="s3">&quot;[S.b]&quot;</span><span class="s2">, </span><span class="s3">&quot;[S.c]&quot;</span><span class="s1">]</span>
    <span class="s2">assert </span><span class="s1">np.allclose(matrix.matrix</span><span class="s2">, </span><span class="s1">[[-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]])</span>
    <span class="s1">t4 = Sum(omit=</span><span class="s3">&quot;a&quot;</span><span class="s1">)</span>
    <span class="s1">matrix = t3.code_with_intercept([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s2">assert </span><span class="s1">matrix.column_suffixes == [</span><span class="s3">&quot;[mean]&quot;</span><span class="s2">, </span><span class="s3">&quot;[S.b]&quot;</span><span class="s2">, </span><span class="s3">&quot;[S.c]&quot;</span><span class="s1">]</span>
    <span class="s2">assert </span><span class="s1">np.allclose(matrix.matrix</span><span class="s2">, </span><span class="s1">[[</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]])</span>
    <span class="s1">matrix = t3.code_without_intercept([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s2">assert </span><span class="s1">matrix.column_suffixes == [</span><span class="s3">&quot;[S.b]&quot;</span><span class="s2">, </span><span class="s3">&quot;[S.c]&quot;</span><span class="s1">]</span>
    <span class="s2">assert </span><span class="s1">np.allclose(matrix.matrix</span><span class="s2">, </span><span class="s1">[[-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]])</span>

<span class="s2">class </span><span class="s1">Helmert(object):</span>
    <span class="s4">&quot;&quot;&quot;Helmert contrasts. 
 
    Compares the second level with the first, the third with the average of 
    the first two, and so on. 
 
    For full-rank coding, a standard intercept term is added. 
 
    .. warning:: There are multiple definitions of 'Helmert coding' in 
       use. Make sure this is the one you expect before trying to interpret 
       your results! 
 
    Examples: 
 
    .. ipython:: python 
 
       # Reduced rank 
       dmatrix(&quot;C(a, Helmert)&quot;, balanced(a=4)) 
       # Full rank 
       dmatrix(&quot;0 + C(a, Helmert)&quot;, balanced(a=4)) 
 
    This is equivalent to R's `contr.helmert`. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">_helmert_contrast(self</span><span class="s2">, </span><span class="s1">levels):</span>
        <span class="s1">n = len(levels)</span>
        <span class="s0">#http://www.ats.ucla.edu/stat/sas/webbooks/reg/chapter5/sasreg5.htm#HELMERT</span>
        <span class="s0">#contr = np.eye(n - 1)</span>
        <span class="s0">#int_range = np.arange(n - 1., 1, -1)</span>
        <span class="s0">#denom = np.repeat(int_range, np.arange(n - 2, 0, -1))</span>
        <span class="s0">#contr[np.tril_indices(n - 1, -1)] = -1. / denom</span>

        <span class="s0">#http://www.ats.ucla.edu/stat/r/library/contrast_coding.htm#HELMERT</span>
        <span class="s0">#contr = np.zeros((n - 1., n - 1))</span>
        <span class="s0">#int_range = np.arange(n, 1, -1)</span>
        <span class="s0">#denom = np.repeat(int_range[:-1], np.arange(n - 2, 0, -1))</span>
        <span class="s0">#contr[np.diag_indices(n - 1)] = (int_range - 1.) / int_range</span>
        <span class="s0">#contr[np.tril_indices(n - 1, -1)] = -1. / denom</span>
        <span class="s0">#contr = np.vstack((contr, -1./int_range))</span>

        <span class="s0">#r-like</span>
        <span class="s1">contr = np.zeros((n</span><span class="s2">, </span><span class="s1">n - </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">contr[</span><span class="s5">1</span><span class="s1">:][np.diag_indices(n - </span><span class="s5">1</span><span class="s1">)] = np.arange(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">n)</span>
        <span class="s1">contr[np.triu_indices(n - </span><span class="s5">1</span><span class="s1">)] = -</span><span class="s5">1</span>
        <span class="s2">return </span><span class="s1">contr</span>

    <span class="s2">def </span><span class="s1">code_with_intercept(self</span><span class="s2">, </span><span class="s1">levels):</span>
        <span class="s1">contrast = np.column_stack((np.ones(len(levels))</span><span class="s2">,</span>
                                    <span class="s1">self._helmert_contrast(levels)))</span>
        <span class="s1">column_suffixes = _name_levels(</span><span class="s3">&quot;H.&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;intercept&quot;</span><span class="s1">] + list(levels[</span><span class="s5">1</span><span class="s1">:]))</span>
        <span class="s2">return </span><span class="s1">ContrastMatrix(contrast</span><span class="s2">, </span><span class="s1">column_suffixes)</span>

    <span class="s2">def </span><span class="s1">code_without_intercept(self</span><span class="s2">, </span><span class="s1">levels):</span>
        <span class="s1">contrast = self._helmert_contrast(levels)</span>
        <span class="s2">return </span><span class="s1">ContrastMatrix(contrast</span><span class="s2">,</span>
                              <span class="s1">_name_levels(</span><span class="s3">&quot;H.&quot;</span><span class="s2">, </span><span class="s1">levels[</span><span class="s5">1</span><span class="s1">:]))</span>

    <span class="s1">__getstate__ = no_pickling</span>

<span class="s2">def </span><span class="s1">test_Helmert():</span>
    <span class="s1">t1 = Helmert()</span>
    <span class="s2">for </span><span class="s1">levels </span><span class="s2">in </span><span class="s1">([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s3">&quot;d&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s3">&quot;d&quot;</span><span class="s1">)):</span>
        <span class="s1">matrix = t1.code_with_intercept(levels)</span>
        <span class="s2">assert </span><span class="s1">matrix.column_suffixes == [</span><span class="s3">&quot;[H.intercept]&quot;</span><span class="s2">,</span>
                                          <span class="s3">&quot;[H.b]&quot;</span><span class="s2">,</span>
                                          <span class="s3">&quot;[H.c]&quot;</span><span class="s2">,</span>
                                          <span class="s3">&quot;[H.d]&quot;</span><span class="s1">]</span>
        <span class="s2">assert </span><span class="s1">np.allclose(matrix.matrix</span><span class="s2">, </span><span class="s1">[[</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
                                           <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
                                           <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
                                           <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]])</span>
        <span class="s1">matrix = t1.code_without_intercept(levels)</span>
        <span class="s2">assert </span><span class="s1">matrix.column_suffixes == [</span><span class="s3">&quot;[H.b]&quot;</span><span class="s2">, </span><span class="s3">&quot;[H.c]&quot;</span><span class="s2">, </span><span class="s3">&quot;[H.d]&quot;</span><span class="s1">]</span>
        <span class="s2">assert </span><span class="s1">np.allclose(matrix.matrix</span><span class="s2">, </span><span class="s1">[[-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
                                           <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
                                           <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
                                           <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]])</span>

<span class="s2">class </span><span class="s1">Diff(object):</span>
    <span class="s4">&quot;&quot;&quot;Backward difference coding. 
 
    This coding scheme is useful for ordered factors, and compares the mean of 
    each level with the preceding level. So you get the second level minus the 
    first, the third level minus the second, etc. 
 
    For full-rank coding, a standard intercept term is added (which gives the 
    mean value for the first level). 
 
    Examples: 
 
    .. ipython:: python 
 
       # Reduced rank 
       dmatrix(&quot;C(a, Diff)&quot;, balanced(a=3)) 
       # Full rank 
       dmatrix(&quot;0 + C(a, Diff)&quot;, balanced(a=3)) 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">_diff_contrast(self</span><span class="s2">, </span><span class="s1">levels):</span>
        <span class="s1">nlevels = len(levels)</span>
        <span class="s1">contr = np.zeros((nlevels</span><span class="s2">, </span><span class="s1">nlevels-</span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">int_range = np.arange(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">nlevels)</span>
        <span class="s1">upper_int = np.repeat(int_range</span><span class="s2">, </span><span class="s1">int_range)</span>
        <span class="s1">row_i</span><span class="s2">, </span><span class="s1">col_i = np.triu_indices(nlevels-</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s0"># we want to iterate down the columns not across the rows</span>
        <span class="s0"># it would be nice if the index functions had a row/col order arg</span>
        <span class="s1">col_order = np.argsort(col_i)</span>
        <span class="s1">contr[row_i[col_order]</span><span class="s2">,</span>
              <span class="s1">col_i[col_order]] = (upper_int-nlevels)/float(nlevels)</span>
        <span class="s1">lower_int = np.repeat(int_range</span><span class="s2">, </span><span class="s1">int_range[::-</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">row_i</span><span class="s2">, </span><span class="s1">col_i = np.tril_indices(nlevels-</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s0"># we want to iterate down the columns not across the rows</span>
        <span class="s1">col_order = np.argsort(col_i)</span>
        <span class="s1">contr[row_i[col_order]+</span><span class="s5">1</span><span class="s2">, </span><span class="s1">col_i[col_order]] = lower_int/float(nlevels)</span>
        <span class="s2">return </span><span class="s1">contr</span>

    <span class="s2">def </span><span class="s1">code_with_intercept(self</span><span class="s2">, </span><span class="s1">levels):</span>
        <span class="s1">contrast = np.column_stack((np.ones(len(levels))</span><span class="s2">,</span>
                                    <span class="s1">self._diff_contrast(levels)))</span>
        <span class="s2">return </span><span class="s1">ContrastMatrix(contrast</span><span class="s2">, </span><span class="s1">_name_levels(</span><span class="s3">&quot;D.&quot;</span><span class="s2">, </span><span class="s1">levels))</span>

    <span class="s2">def </span><span class="s1">code_without_intercept(self</span><span class="s2">, </span><span class="s1">levels):</span>
        <span class="s1">contrast = self._diff_contrast(levels)</span>
        <span class="s2">return </span><span class="s1">ContrastMatrix(contrast</span><span class="s2">, </span><span class="s1">_name_levels(</span><span class="s3">&quot;D.&quot;</span><span class="s2">, </span><span class="s1">levels[:-</span><span class="s5">1</span><span class="s1">]))</span>

    <span class="s1">__getstate__ = no_pickling</span>

<span class="s2">def </span><span class="s1">test_diff():</span>
    <span class="s1">t1 = Diff()</span>
    <span class="s1">matrix = t1.code_with_intercept([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s3">&quot;d&quot;</span><span class="s1">])</span>
    <span class="s2">assert </span><span class="s1">matrix.column_suffixes == [</span><span class="s3">&quot;[D.a]&quot;</span><span class="s2">, </span><span class="s3">&quot;[D.b]&quot;</span><span class="s2">, </span><span class="s3">&quot;[D.c]&quot;</span><span class="s2">,</span>
                                      <span class="s3">&quot;[D.d]&quot;</span><span class="s1">]</span>
    <span class="s2">assert </span><span class="s1">np.allclose(matrix.matrix</span><span class="s2">, </span><span class="s1">[[</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">3</span><span class="s1">/</span><span class="s5">4.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">/</span><span class="s5">2.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">/</span><span class="s5">4.</span><span class="s1">]</span><span class="s2">,</span>
                                        <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">/</span><span class="s5">4.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">/</span><span class="s5">2.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">/</span><span class="s5">4.</span><span class="s1">]</span><span class="s2">,</span>
                                        <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">/</span><span class="s5">4.</span><span class="s2">, </span><span class="s5">1.</span><span class="s1">/</span><span class="s5">2</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">/</span><span class="s5">4.</span><span class="s1">]</span><span class="s2">,</span>
                                        <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">/</span><span class="s5">4.</span><span class="s2">, </span><span class="s5">1</span><span class="s1">/</span><span class="s5">2.</span><span class="s2">, </span><span class="s5">3</span><span class="s1">/</span><span class="s5">4.</span><span class="s1">]])</span>
    <span class="s1">matrix = t1.code_without_intercept([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s3">&quot;d&quot;</span><span class="s1">])</span>
    <span class="s2">assert </span><span class="s1">matrix.column_suffixes == [</span><span class="s3">&quot;[D.a]&quot;</span><span class="s2">, </span><span class="s3">&quot;[D.b]&quot;</span><span class="s2">, </span><span class="s3">&quot;[D.c]&quot;</span><span class="s1">]</span>
    <span class="s2">assert </span><span class="s1">np.allclose(matrix.matrix</span><span class="s2">, </span><span class="s1">[[-</span><span class="s5">3</span><span class="s1">/</span><span class="s5">4.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">/</span><span class="s5">2.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">/</span><span class="s5">4.</span><span class="s1">]</span><span class="s2">,</span>
                                        <span class="s1">[</span><span class="s5">1</span><span class="s1">/</span><span class="s5">4.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">/</span><span class="s5">2.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">/</span><span class="s5">4.</span><span class="s1">]</span><span class="s2">,</span>
                                        <span class="s1">[</span><span class="s5">1</span><span class="s1">/</span><span class="s5">4.</span><span class="s2">, </span><span class="s5">2.</span><span class="s1">/</span><span class="s5">4</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">/</span><span class="s5">4.</span><span class="s1">]</span><span class="s2">,</span>
                                        <span class="s1">[</span><span class="s5">1</span><span class="s1">/</span><span class="s5">4.</span><span class="s2">, </span><span class="s5">1</span><span class="s1">/</span><span class="s5">2.</span><span class="s2">, </span><span class="s5">3</span><span class="s1">/</span><span class="s5">4.</span><span class="s1">]])</span>

<span class="s0"># contrast can be:</span>
<span class="s0">#   -- a ContrastMatrix</span>
<span class="s0">#   -- a simple np.ndarray</span>
<span class="s0">#   -- an object with code_with_intercept and code_without_intercept methods</span>
<span class="s0">#   -- a function returning one of the above</span>
<span class="s0">#   -- None, in which case the above rules are applied to 'default'</span>
<span class="s0"># This function always returns a ContrastMatrix.</span>
<span class="s2">def </span><span class="s1">code_contrast_matrix(intercept</span><span class="s2">, </span><span class="s1">levels</span><span class="s2">, </span><span class="s1">contrast</span><span class="s2">, </span><span class="s1">default=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">if </span><span class="s1">contrast </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">contrast = default</span>
    <span class="s2">if </span><span class="s1">callable(contrast):</span>
        <span class="s1">contrast = contrast()</span>
    <span class="s2">if </span><span class="s1">isinstance(contrast</span><span class="s2">, </span><span class="s1">ContrastMatrix):</span>
        <span class="s2">return </span><span class="s1">contrast</span>
    <span class="s1">as_array = np.asarray(contrast)</span>
    <span class="s2">if </span><span class="s1">safe_issubdtype(as_array.dtype</span><span class="s2">, </span><span class="s1">np.number):</span>
        <span class="s2">return </span><span class="s1">ContrastMatrix(as_array</span><span class="s2">,</span>
                              <span class="s1">_name_levels(</span><span class="s3">&quot;custom&quot;</span><span class="s2">, </span><span class="s1">range(as_array.shape[</span><span class="s5">1</span><span class="s1">])))</span>
    <span class="s2">if </span><span class="s1">intercept:</span>
        <span class="s2">return </span><span class="s1">contrast.code_with_intercept(levels)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">contrast.code_without_intercept(levels)</span>

</pre>
</body>
</html>