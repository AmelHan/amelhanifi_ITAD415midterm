<html>
<head>
<title>test_delayed.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #a5c261;}
.s6 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_delayed.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">pickle</span>
<span class="s0">import </span><span class="s1">types</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">namedtuple</span>
<span class="s0">from </span><span class="s1">dataclasses </span><span class="s0">import </span><span class="s1">dataclass</span><span class="s0">, </span><span class="s1">field</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">partial</span>
<span class="s0">from </span><span class="s1">operator </span><span class="s0">import </span><span class="s1">add</span><span class="s0">, </span><span class="s1">setitem</span>
<span class="s0">from </span><span class="s1">random </span><span class="s0">import </span><span class="s1">random</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">NamedTuple</span>

<span class="s0">import </span><span class="s1">cloudpickle</span>
<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">from </span><span class="s1">tlz </span><span class="s0">import </span><span class="s1">merge</span>

<span class="s0">import </span><span class="s1">dask</span>
<span class="s0">import </span><span class="s1">dask.bag </span><span class="s0">as </span><span class="s1">db</span>
<span class="s0">from </span><span class="s1">dask </span><span class="s0">import </span><span class="s1">compute</span>
<span class="s0">from </span><span class="s1">dask.delayed </span><span class="s0">import </span><span class="s1">Delayed</span><span class="s0">, </span><span class="s1">delayed</span><span class="s0">, </span><span class="s1">to_task_dask</span>
<span class="s0">from </span><span class="s1">dask.highlevelgraph </span><span class="s0">import </span><span class="s1">HighLevelGraph</span>
<span class="s0">from </span><span class="s1">dask.utils_test </span><span class="s0">import </span><span class="s1">inc</span>


<span class="s0">class </span><span class="s1">Tuple:</span>
    <span class="s1">__dask_scheduler__ = staticmethod(dask.threaded.get)</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">dsk</span><span class="s0">, </span><span class="s1">keys):</span>
        <span class="s1">self._dask = dsk</span>
        <span class="s1">self._keys = keys</span>

    <span class="s0">def </span><span class="s1">__dask_tokenize__(self):</span>
        <span class="s0">return </span><span class="s1">self._keys</span>

    <span class="s0">def </span><span class="s1">__dask_graph__(self):</span>
        <span class="s0">return </span><span class="s1">self._dask</span>

    <span class="s0">def </span><span class="s1">__dask_keys__(self):</span>
        <span class="s0">return </span><span class="s1">self._keys</span>

    <span class="s0">def </span><span class="s1">__dask_postcompute__(self):</span>
        <span class="s0">return </span><span class="s1">tuple</span><span class="s0">, </span><span class="s1">()</span>


<span class="s1">@pytest.mark.filterwarnings(</span><span class="s2">&quot;ignore:The dask.delayed:UserWarning&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_to_task_dask():</span>
    <span class="s1">a = delayed(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;a&quot;</span><span class="s1">)</span>
    <span class="s1">b = delayed(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;b&quot;</span><span class="s1">)</span>
    <span class="s1">task</span><span class="s0">, </span><span class="s1">dask = to_task_dask([a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span>
    <span class="s0">assert </span><span class="s1">task == [</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span>

    <span class="s1">task</span><span class="s0">, </span><span class="s1">dask = to_task_dask((a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
    <span class="s0">assert </span><span class="s1">task == (tuple</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span>
    <span class="s0">assert </span><span class="s1">dict(dask) == merge(a.dask</span><span class="s0">, </span><span class="s1">b.dask)</span>

    <span class="s1">task</span><span class="s0">, </span><span class="s1">dask = to_task_dask({a: </span><span class="s3">1</span><span class="s0">, </span><span class="s1">b: </span><span class="s3">2</span><span class="s1">})</span>
    <span class="s0">assert </span><span class="s1">task == (dict</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]]) </span><span class="s0">or </span><span class="s1">task == (dict</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]])</span>
    <span class="s0">assert </span><span class="s1">dict(dask) == merge(a.dask</span><span class="s0">, </span><span class="s1">b.dask)</span>

    <span class="s1">f = namedtuple(</span><span class="s2">&quot;f&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s1">x = f(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">task</span><span class="s0">, </span><span class="s1">dask = to_task_dask(x)</span>
    <span class="s0">assert </span><span class="s1">task == (f</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">dict(dask) == merge(a.dask</span><span class="s0">, </span><span class="s1">b.dask)</span>

    <span class="s1">task</span><span class="s0">, </span><span class="s1">dask = to_task_dask(slice(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
    <span class="s0">assert </span><span class="s1">task == (slice</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">dict(dask) == merge(a.dask</span><span class="s0">, </span><span class="s1">b.dask)</span>

    <span class="s4"># Issue https://github.com/dask/dask/issues/2107</span>
    <span class="s0">class </span><span class="s1">MyClass(dict):</span>
        <span class="s0">pass</span>

    <span class="s1">task</span><span class="s0">, </span><span class="s1">dask = to_task_dask(MyClass())</span>
    <span class="s0">assert </span><span class="s1">type(task) </span><span class="s0">is </span><span class="s1">MyClass</span>
    <span class="s0">assert </span><span class="s1">dict(dask) == {}</span>

    <span class="s4"># Custom dask objects</span>
    <span class="s1">x = Tuple({</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s3">2</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">: (add</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">)}</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s1">task</span><span class="s0">, </span><span class="s1">dask = to_task_dask(x)</span>
    <span class="s0">assert </span><span class="s1">task </span><span class="s0">in </span><span class="s1">dask</span>
    <span class="s1">f = dask.pop(task)</span>
    <span class="s0">assert </span><span class="s1">f == (tuple</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s0">assert </span><span class="s1">dask == x._dask</span>


<span class="s0">def </span><span class="s1">test_delayed():</span>
    <span class="s1">add2 = delayed(add)</span>
    <span class="s0">assert </span><span class="s1">add2(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">).compute() == </span><span class="s3">3</span>
    <span class="s0">assert </span><span class="s1">(add2(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">) + </span><span class="s3">3</span><span class="s1">).compute() == </span><span class="s3">6</span>
    <span class="s0">assert </span><span class="s1">add2(add2(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s3">3</span><span class="s1">).compute() == </span><span class="s3">6</span>

    <span class="s1">a = delayed(</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">a.compute() == </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s3">1 </span><span class="s0">in </span><span class="s1">a.dask.values()</span>
    <span class="s1">b = add2(add2(a</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">a.key </span><span class="s0">in </span><span class="s1">b.dask</span>


<span class="s0">def </span><span class="s1">test_delayed_with_namedtuple():</span>
    <span class="s0">class </span><span class="s1">ANamedTuple(NamedTuple):</span>
        <span class="s1">a: int  </span><span class="s4"># type: ignore[annotation-unchecked]</span>

    <span class="s1">literal = dask.delayed(</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">with_class = dask.delayed({</span><span class="s2">&quot;a&quot;</span><span class="s1">: ANamedTuple(a=literal)})</span>

    <span class="s0">def </span><span class="s1">return_nested(obj):</span>
        <span class="s0">return </span><span class="s1">obj[</span><span class="s2">&quot;a&quot;</span><span class="s1">].a</span>

    <span class="s1">final = delayed(return_nested)(with_class)</span>

    <span class="s0">assert </span><span class="s1">final.compute() == </span><span class="s3">3</span>


<span class="s1">@dataclass</span>
<span class="s0">class </span><span class="s1">ANonFrozenDataClass:</span>
    <span class="s1">a: int</span>


<span class="s1">@dataclass(frozen=</span><span class="s0">True</span><span class="s1">)</span>
<span class="s0">class </span><span class="s1">AFrozenDataClass:</span>
    <span class="s1">a: int</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;cls&quot;</span><span class="s0">, </span><span class="s1">(ANonFrozenDataClass</span><span class="s0">, </span><span class="s1">AFrozenDataClass))</span>
<span class="s0">def </span><span class="s1">test_delayed_with_dataclass(cls):</span>
    <span class="s1">literal = delayed(</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">with_class = delayed({</span><span class="s2">&quot;data&quot;</span><span class="s1">: cls(a=literal)})</span>

    <span class="s0">def </span><span class="s1">return_nested(obj):</span>
        <span class="s0">return </span><span class="s1">obj[</span><span class="s2">&quot;data&quot;</span><span class="s1">].a</span>

    <span class="s1">final = delayed(return_nested)(with_class)</span>

    <span class="s0">assert </span><span class="s1">final.compute() == </span><span class="s3">3</span>


<span class="s0">def </span><span class="s1">test_delayed_with_dataclass_with_custom_init():</span>
    <span class="s1">@dataclass()</span>
    <span class="s0">class </span><span class="s1">ADataClass:</span>
        <span class="s1">a: int  </span><span class="s4"># type: ignore[annotation-unchecked]</span>

        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">b: int):</span>
            <span class="s1">self.a = b</span>

    <span class="s1">literal = dask.delayed(</span><span class="s3">3</span><span class="s1">)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(TypeError) </span><span class="s0">as </span><span class="s1">e:</span>
        <span class="s1">dask.delayed({</span><span class="s2">&quot;data&quot;</span><span class="s1">: ADataClass(b=literal)})</span>

    <span class="s1">e.match(</span><span class="s2">r&quot;ADataClass&quot;</span><span class="s1">)</span>
    <span class="s1">e.match(</span><span class="s2">r&quot;custom __init__ is not supported&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_delayed_with_dataclass_with_eager_custom_init():</span>
    <span class="s1">@dataclass()</span>
    <span class="s0">class </span><span class="s1">ADataClass:</span>
        <span class="s1">a: int  </span><span class="s4"># type: ignore[annotation-unchecked]</span>

        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">b: int):</span>
            <span class="s1">self.a = b</span>

    <span class="s1">with_class = delayed({</span><span class="s2">&quot;data&quot;</span><span class="s1">: ADataClass(b=</span><span class="s3">3</span><span class="s1">)})</span>

    <span class="s0">def </span><span class="s1">return_nested(obj):</span>
        <span class="s0">return </span><span class="s1">obj[</span><span class="s2">&quot;data&quot;</span><span class="s1">].a</span>

    <span class="s1">final = delayed(return_nested)(with_class)</span>

    <span class="s0">assert </span><span class="s1">final.compute() == </span><span class="s3">3</span>


<span class="s0">def </span><span class="s1">test_delayed_with_eager_dataclass_with_set_init_false_field():</span>
    <span class="s1">@dataclass</span>
    <span class="s0">class </span><span class="s1">ADataClass:</span>
        <span class="s1">a: int  </span><span class="s4"># type: ignore[annotation-unchecked]</span>
        <span class="s1">b: int = field(init=</span><span class="s0">False</span><span class="s1">)  </span><span class="s4"># type: ignore[annotation-unchecked]</span>

    <span class="s0">def </span><span class="s1">prep_dataclass(a):</span>
        <span class="s1">data = ADataClass(a=a)</span>
        <span class="s1">data.b = </span><span class="s3">4</span>
        <span class="s0">return </span><span class="s1">data</span>

    <span class="s1">with_class = delayed({</span><span class="s2">&quot;data&quot;</span><span class="s1">: prep_dataclass(</span><span class="s3">3</span><span class="s1">)})</span>

    <span class="s0">def </span><span class="s1">return_nested(obj):</span>
        <span class="s0">return </span><span class="s1">obj[</span><span class="s2">&quot;data&quot;</span><span class="s1">].a</span>

    <span class="s1">final = delayed(return_nested)(with_class)</span>

    <span class="s0">assert </span><span class="s1">final.compute() == </span><span class="s3">3</span>


<span class="s0">def </span><span class="s1">test_delayed_with_dataclass_with_set_init_false_field():</span>
    <span class="s1">@dataclass</span>
    <span class="s0">class </span><span class="s1">ADataClass:</span>
        <span class="s1">a: int  </span><span class="s4"># type: ignore[annotation-unchecked]</span>
        <span class="s1">b: int = field(init=</span><span class="s0">False</span><span class="s1">)  </span><span class="s4"># type: ignore[annotation-unchecked]</span>

    <span class="s1">literal = dask.delayed(</span><span class="s3">3</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">prep_dataclass(a):</span>
        <span class="s1">data = ADataClass(a=a)</span>
        <span class="s1">data.b = </span><span class="s3">4</span>
        <span class="s0">return </span><span class="s1">data</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError) </span><span class="s0">as </span><span class="s1">e:</span>
        <span class="s1">dask.delayed(prep_dataclass(literal))</span>

    <span class="s1">e.match(</span><span class="s2">r&quot;ADataClass&quot;</span><span class="s1">)</span>
    <span class="s1">e.match(</span><span class="s2">r&quot;`init=False` are not supported&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_delayed_with_dataclass_with_unset_init_false_field():</span>
    <span class="s1">@dataclass</span>
    <span class="s0">class </span><span class="s1">ADataClass:</span>
        <span class="s1">a: int  </span><span class="s4"># type: ignore[annotation-unchecked]</span>
        <span class="s1">b: int = field(init=</span><span class="s0">False</span><span class="s1">)  </span><span class="s4"># type: ignore[annotation-unchecked]</span>

    <span class="s1">literal = dask.delayed(</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">with_class = delayed({</span><span class="s2">&quot;data&quot;</span><span class="s1">: ADataClass(a=literal)})</span>

    <span class="s0">def </span><span class="s1">return_nested(obj):</span>
        <span class="s0">return </span><span class="s1">obj[</span><span class="s2">&quot;data&quot;</span><span class="s1">].a</span>

    <span class="s1">final = delayed(return_nested)(with_class)</span>

    <span class="s0">assert </span><span class="s1">final.compute() == </span><span class="s3">3</span>


<span class="s0">def </span><span class="s1">test_operators():</span>
    <span class="s1">a = delayed([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span>
    <span class="s0">assert </span><span class="s1">a[</span><span class="s3">0</span><span class="s1">].compute() == </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">(a + a).compute() == [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span>
    <span class="s1">b = delayed(</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">a[:b].compute() == [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span>

    <span class="s1">a = delayed(</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">(a + </span><span class="s3">1</span><span class="s1">).compute() == </span><span class="s3">11</span>
    <span class="s0">assert </span><span class="s1">(</span><span class="s3">1 </span><span class="s1">+ a).compute() == </span><span class="s3">11</span>
    <span class="s0">assert </span><span class="s1">(a &gt;&gt; </span><span class="s3">1</span><span class="s1">).compute() == </span><span class="s3">5</span>
    <span class="s0">assert </span><span class="s1">(a &gt; </span><span class="s3">2</span><span class="s1">).compute()</span>
    <span class="s0">assert </span><span class="s1">(a**</span><span class="s3">2</span><span class="s1">).compute() == </span><span class="s3">100</span>

    <span class="s0">class </span><span class="s1">dummy:</span>
        <span class="s0">def </span><span class="s1">__matmul__(self</span><span class="s0">, </span><span class="s1">other):</span>
            <span class="s0">return </span><span class="s3">4</span>

    <span class="s1">c = delayed(dummy())</span>
    <span class="s1">d = delayed(dummy())</span>
    <span class="s0">assert </span><span class="s1">(c @ d).compute() == </span><span class="s3">4</span>


<span class="s0">def </span><span class="s1">test_methods():</span>
    <span class="s1">a = delayed(</span><span class="s2">&quot;a b c d e&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">a.split(</span><span class="s2">&quot; &quot;</span><span class="s1">).compute() == [</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s0">, </span><span class="s2">&quot;e&quot;</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">a.upper().replace(</span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s1">).split().count(</span><span class="s2">&quot;A&quot;</span><span class="s1">).compute() == </span><span class="s3">2</span>
    <span class="s0">assert </span><span class="s1">a.split(</span><span class="s2">&quot; &quot;</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">True</span><span class="s1">).key == a.split(</span><span class="s2">&quot; &quot;</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">True</span><span class="s1">).key</span>
    <span class="s1">o = a.split(</span><span class="s2">&quot; &quot;</span><span class="s0">, </span><span class="s1">dask_key_name=</span><span class="s2">&quot;test&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">o.key == </span><span class="s2">&quot;test&quot;</span>


<span class="s0">def </span><span class="s1">test_attributes():</span>
    <span class="s1">a = delayed(</span><span class="s3">2 </span><span class="s1">+ </span><span class="s3">1j</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">a.real._key == a.real._key</span>
    <span class="s0">assert </span><span class="s1">a.real.compute() == </span><span class="s3">2</span>
    <span class="s0">assert </span><span class="s1">a.imag.compute() == </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">(a.real + a.imag).compute() == </span><span class="s3">3</span>


<span class="s0">def </span><span class="s1">test_method_getattr_call_same_task():</span>
    <span class="s1">a = delayed([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span>
    <span class="s1">o = a.index(</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s4"># Don't getattr the method, then call in separate task</span>
    <span class="s0">assert </span><span class="s1">getattr </span><span class="s0">not in </span><span class="s1">{v[</span><span class="s3">0</span><span class="s1">] </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">o.__dask_graph__().values()}</span>


<span class="s0">def </span><span class="s1">test_np_dtype_of_delayed():</span>
    <span class="s4"># This used to result in a segfault due to recursion, see</span>
    <span class="s4"># https://github.com/dask/dask/pull/4374#issuecomment-454381465</span>
    <span class="s1">np = pytest.importorskip(</span><span class="s2">&quot;numpy&quot;</span><span class="s1">)</span>
    <span class="s1">x = delayed(</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
        <span class="s1">np.dtype(x)</span>
    <span class="s0">assert </span><span class="s1">delayed(np.array([</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;f8&quot;</span><span class="s1">)).dtype.compute() == np.dtype(</span><span class="s2">&quot;f8&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_delayed_visualise_warn():</span>
    <span class="s4"># Raise a warning when user calls visualise()</span>
    <span class="s4"># instead of visualize()</span>
    <span class="s0">def </span><span class="s1">inc(x):</span>
        <span class="s0">return </span><span class="s1">x + </span><span class="s3">1</span>

    <span class="s1">z = dask.delayed(inc)(</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">z.compute()</span>

    <span class="s0">with </span><span class="s1">pytest.warns(</span>
        <span class="s1">UserWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;dask.delayed objects have no `visualise` method&quot;</span>
    <span class="s1">):</span>
        <span class="s1">z.visualise(file_name=</span><span class="s2">&quot;desk_graph.svg&quot;</span><span class="s1">)</span>

    <span class="s4"># with no args</span>
    <span class="s0">with </span><span class="s1">pytest.warns(</span>
        <span class="s1">UserWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;dask.delayed objects have no `visualise` method&quot;</span>
    <span class="s1">):</span>
        <span class="s1">z.visualise()</span>


<span class="s0">def </span><span class="s1">test_delayed_errors():</span>
    <span class="s1">a = delayed([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span>
    <span class="s4"># Immutable</span>
    <span class="s1">pytest.raises(TypeError</span><span class="s0">, lambda</span><span class="s1">: setattr(a</span><span class="s0">, </span><span class="s2">&quot;foo&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
    <span class="s1">pytest.raises(TypeError</span><span class="s0">, lambda</span><span class="s1">: setitem(a</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
    <span class="s4"># Can't iterate, or check if contains</span>
    <span class="s1">pytest.raises(TypeError</span><span class="s0">, lambda</span><span class="s1">: </span><span class="s3">1 </span><span class="s0">in </span><span class="s1">a)</span>
    <span class="s1">pytest.raises(TypeError</span><span class="s0">, lambda</span><span class="s1">: list(a))</span>
    <span class="s4"># No dynamic generation of magic/hidden methods</span>
    <span class="s1">pytest.raises(AttributeError</span><span class="s0">, lambda</span><span class="s1">: a._hidden())</span>
    <span class="s4"># Truth of delayed forbidden</span>
    <span class="s1">pytest.raises(TypeError</span><span class="s0">, lambda</span><span class="s1">: bool(a))</span>


<span class="s0">def </span><span class="s1">test_common_subexpressions():</span>
    <span class="s1">a = delayed([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span>
    <span class="s1">res = a[</span><span class="s3">0</span><span class="s1">] + a[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">a[</span><span class="s3">0</span><span class="s1">].key </span><span class="s0">in </span><span class="s1">res.dask</span>
    <span class="s0">assert </span><span class="s1">a.key </span><span class="s0">in </span><span class="s1">res.dask</span>
    <span class="s0">assert </span><span class="s1">len(res.dask) == </span><span class="s3">3</span>


<span class="s0">def </span><span class="s1">test_delayed_optimize():</span>
    <span class="s1">x = Delayed(</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: (inc</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">: (inc</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">)})</span>
    <span class="s1">(x2</span><span class="s0">,</span><span class="s1">) = dask.optimize(x)</span>
    <span class="s4"># Delayed's __dask_optimize__ culls out 'c'</span>
    <span class="s0">assert </span><span class="s1">sorted(x2.dask.keys()) == [</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">x2._layer != x2._key</span>
    <span class="s4"># Optimize generates its own layer name, which doesn't match the key.</span>
    <span class="s4"># `Delayed._rebuild` handles this.</span>


<span class="s0">def </span><span class="s1">test_lists():</span>
    <span class="s1">a = delayed(</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">b = delayed(</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">c = delayed(sum)([a</span><span class="s0">, </span><span class="s1">b])</span>
    <span class="s0">assert </span><span class="s1">c.compute() == </span><span class="s3">3</span>


<span class="s0">def </span><span class="s1">test_literates():</span>
    <span class="s1">a = delayed(</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">b = a + </span><span class="s3">1</span>
    <span class="s1">lit = (a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">delayed(lit).compute() == (</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">lit = [a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">delayed(lit).compute() == [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span>
    <span class="s1">lit = {a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">3</span><span class="s1">}</span>
    <span class="s0">assert </span><span class="s1">delayed(lit).compute() == {</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">}</span>
    <span class="s1">lit = {a: </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s1">b: </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s3">3</span><span class="s1">: </span><span class="s2">&quot;c&quot;</span><span class="s1">}</span>
    <span class="s0">assert </span><span class="s1">delayed(lit).compute() == {</span><span class="s3">1</span><span class="s1">: </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s1">: </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s3">3</span><span class="s1">: </span><span class="s2">&quot;c&quot;</span><span class="s1">}</span>
    <span class="s0">assert </span><span class="s1">delayed(lit)[a].compute() == </span><span class="s2">&quot;a&quot;</span>
    <span class="s1">lit = {</span><span class="s2">&quot;a&quot;</span><span class="s1">: a</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: b</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">: </span><span class="s3">3</span><span class="s1">}</span>
    <span class="s0">assert </span><span class="s1">delayed(lit).compute() == {</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s3">2</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">: </span><span class="s3">3</span><span class="s1">}</span>
    <span class="s0">assert </span><span class="s1">delayed(lit)[</span><span class="s2">&quot;a&quot;</span><span class="s1">].compute() == </span><span class="s3">1</span>


<span class="s0">def </span><span class="s1">test_literates_keys():</span>
    <span class="s1">a = delayed(</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">b = a + </span><span class="s3">1</span>
    <span class="s1">lit = (a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">delayed(lit).key != delayed(lit).key</span>
    <span class="s0">assert </span><span class="s1">delayed(lit</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">True</span><span class="s1">).key == delayed(lit</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">True</span><span class="s1">).key</span>


<span class="s0">def </span><span class="s1">test_lists_are_concrete():</span>
    <span class="s1">a = delayed(</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">b = delayed(</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">c = delayed(max)([[a</span><span class="s0">, </span><span class="s3">10</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[b</span><span class="s0">, </span><span class="s3">20</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">key=</span><span class="s0">lambda </span><span class="s1">x: x[</span><span class="s3">0</span><span class="s1">])[</span><span class="s3">1</span><span class="s1">]</span>

    <span class="s0">assert </span><span class="s1">c.compute() == </span><span class="s3">20</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;typ&quot;</span><span class="s0">, </span><span class="s1">[list</span><span class="s0">, </span><span class="s1">tuple</span><span class="s0">, </span><span class="s1">set])</span>
<span class="s0">def </span><span class="s1">test_iterators(typ):</span>
    <span class="s1">a = delayed(</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">b = delayed(</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">c = delayed(sum)(iter(typ([a</span><span class="s0">, </span><span class="s1">b])))</span>

    <span class="s1">x = c.compute()</span>
    <span class="s0">assert </span><span class="s1">x == </span><span class="s3">3</span>

    <span class="s0">def </span><span class="s1">f(seq):</span>
        <span class="s0">return </span><span class="s1">sum(seq)</span>

    <span class="s1">c = delayed(f)(iter(typ([a</span><span class="s0">, </span><span class="s1">b])))</span>
    <span class="s0">assert </span><span class="s1">c.compute() == </span><span class="s3">3</span>


<span class="s0">def </span><span class="s1">test_traverse_false():</span>
    <span class="s4"># Create a list with a dask value, and test that it's not computed</span>
    <span class="s0">def </span><span class="s1">fail(*args):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;shouldn't have computed&quot;</span><span class="s1">)</span>

    <span class="s1">a = delayed(fail)()</span>

    <span class="s4"># list</span>
    <span class="s1">x = [a</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span>
    <span class="s1">res = delayed(x</span><span class="s0">, </span><span class="s1">traverse=</span><span class="s0">False</span><span class="s1">).compute()</span>
    <span class="s0">assert </span><span class="s1">len(res) == </span><span class="s3">4</span>
    <span class="s0">assert </span><span class="s1">res[</span><span class="s3">0</span><span class="s1">] </span><span class="s0">is </span><span class="s1">a</span>
    <span class="s0">assert </span><span class="s1">res[</span><span class="s3">1</span><span class="s1">:] == x[</span><span class="s3">1</span><span class="s1">:]</span>

    <span class="s4"># tuple that looks like a task</span>
    <span class="s1">x = (fail</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">(fail</span><span class="s0">, </span><span class="s1">a))</span>
    <span class="s1">res = delayed(x</span><span class="s0">, </span><span class="s1">traverse=</span><span class="s0">False</span><span class="s1">).compute()</span>
    <span class="s0">assert </span><span class="s1">isinstance(res</span><span class="s0">, </span><span class="s1">tuple)</span>
    <span class="s0">assert </span><span class="s1">res[</span><span class="s3">0</span><span class="s1">] == fail</span>
    <span class="s0">assert </span><span class="s1">res[</span><span class="s3">1</span><span class="s1">] </span><span class="s0">is </span><span class="s1">a</span>

    <span class="s4"># list containing task-like-things</span>
    <span class="s1">x = [</span><span class="s3">1</span><span class="s0">, </span><span class="s1">(fail</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">, </span><span class="s1">a]</span>
    <span class="s1">res = delayed(x</span><span class="s0">, </span><span class="s1">traverse=</span><span class="s0">False</span><span class="s1">).compute()</span>
    <span class="s0">assert </span><span class="s1">isinstance(res</span><span class="s0">, </span><span class="s1">list)</span>
    <span class="s0">assert </span><span class="s1">res[</span><span class="s3">0</span><span class="s1">] == </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">res[</span><span class="s3">1</span><span class="s1">][</span><span class="s3">0</span><span class="s1">] == fail </span><span class="s0">and </span><span class="s1">res[</span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">] </span><span class="s0">is </span><span class="s1">a</span>
    <span class="s0">assert </span><span class="s1">res[</span><span class="s3">2</span><span class="s1">] </span><span class="s0">is </span><span class="s1">a</span>

    <span class="s4"># traverse=False still hits top level</span>
    <span class="s1">b = delayed(</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">x = delayed(b</span><span class="s0">, </span><span class="s1">traverse=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">x.compute() == </span><span class="s3">1</span>


<span class="s0">def </span><span class="s1">test_pure():</span>
    <span class="s1">v1 = delayed(add</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">True</span><span class="s1">)(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">v2 = delayed(add</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">True</span><span class="s1">)(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">v1.key == v2.key</span>

    <span class="s1">myrand = delayed(random)</span>
    <span class="s0">assert </span><span class="s1">myrand().key != myrand().key</span>


<span class="s0">def </span><span class="s1">test_pure_global_setting():</span>
    <span class="s4"># delayed functions</span>
    <span class="s1">func = delayed(add)</span>

    <span class="s0">with </span><span class="s1">dask.config.set(delayed_pure=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">assert </span><span class="s1">func(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">).key == func(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">).key</span>

    <span class="s0">with </span><span class="s1">dask.config.set(delayed_pure=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s0">assert </span><span class="s1">func(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">).key != func(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">).key</span>

    <span class="s1">func = delayed(add</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">dask.config.set(delayed_pure=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s0">assert </span><span class="s1">func(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">).key == func(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">).key</span>

    <span class="s4"># delayed objects</span>
    <span class="s0">assert </span><span class="s1">delayed(</span><span class="s3">1</span><span class="s1">).key != delayed(</span><span class="s3">1</span><span class="s1">).key</span>
    <span class="s0">with </span><span class="s1">dask.config.set(delayed_pure=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">assert </span><span class="s1">delayed(</span><span class="s3">1</span><span class="s1">).key == delayed(</span><span class="s3">1</span><span class="s1">).key</span>

    <span class="s0">with </span><span class="s1">dask.config.set(delayed_pure=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s0">assert </span><span class="s1">delayed(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">True</span><span class="s1">).key == delayed(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">True</span><span class="s1">).key</span>

    <span class="s4"># delayed methods</span>
    <span class="s1">data = delayed([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span>
    <span class="s0">assert </span><span class="s1">data.index(</span><span class="s3">1</span><span class="s1">).key != data.index(</span><span class="s3">1</span><span class="s1">).key</span>

    <span class="s0">with </span><span class="s1">dask.config.set(delayed_pure=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">assert </span><span class="s1">data.index(</span><span class="s3">1</span><span class="s1">).key == data.index(</span><span class="s3">1</span><span class="s1">).key</span>
        <span class="s0">assert </span><span class="s1">data.index(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">False</span><span class="s1">).key != data.index(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">False</span><span class="s1">).key</span>

    <span class="s0">with </span><span class="s1">dask.config.set(delayed_pure=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s0">assert </span><span class="s1">data.index(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">True</span><span class="s1">).key == data.index(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">True</span><span class="s1">).key</span>

    <span class="s4"># magic methods always pure</span>
    <span class="s0">with </span><span class="s1">dask.config.set(delayed_pure=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s0">assert </span><span class="s1">data.index.key == data.index.key</span>
        <span class="s1">element = data[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">(element + element).key == (element + element).key</span>


<span class="s0">def </span><span class="s1">test_nout():</span>
    <span class="s1">func = delayed(</span><span class="s0">lambda </span><span class="s1">x: (x</span><span class="s0">, </span><span class="s1">-x)</span><span class="s0">, </span><span class="s1">nout=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">x = func(</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">len(x) == </span><span class="s3">2</span>
    <span class="s1">a</span><span class="s0">, </span><span class="s1">b = x</span>
    <span class="s0">assert </span><span class="s1">compute(a</span><span class="s0">, </span><span class="s1">b) == (</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">a._length </span><span class="s0">is None</span>
    <span class="s0">assert </span><span class="s1">b._length </span><span class="s0">is None</span>
    <span class="s1">pytest.raises(TypeError</span><span class="s0">, lambda</span><span class="s1">: len(a))</span>
    <span class="s1">pytest.raises(TypeError</span><span class="s0">, lambda</span><span class="s1">: list(a))</span>

    <span class="s1">pytest.raises(ValueError</span><span class="s0">, lambda</span><span class="s1">: delayed(add</span><span class="s0">, </span><span class="s1">nout=-</span><span class="s3">1</span><span class="s1">))</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s0">, lambda</span><span class="s1">: delayed(add</span><span class="s0">, </span><span class="s1">nout=</span><span class="s0">True</span><span class="s1">))</span>

    <span class="s1">func = delayed(add</span><span class="s0">, </span><span class="s1">nout=</span><span class="s0">None</span><span class="s1">)</span>
    <span class="s1">a = func(</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">a._length </span><span class="s0">is None</span>
    <span class="s1">pytest.raises(TypeError</span><span class="s0">, lambda</span><span class="s1">: list(a))</span>
    <span class="s1">pytest.raises(TypeError</span><span class="s0">, lambda</span><span class="s1">: len(a))</span>

    <span class="s1">func = delayed(</span><span class="s0">lambda </span><span class="s1">x: (x</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">nout=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">x = func(</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">len(x) == </span><span class="s3">1</span>
    <span class="s1">(a</span><span class="s0">,</span><span class="s1">) = x</span>
    <span class="s0">assert </span><span class="s1">a.compute() == </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">a._length </span><span class="s0">is None</span>
    <span class="s1">pytest.raises(TypeError</span><span class="s0">, lambda</span><span class="s1">: len(a))</span>

    <span class="s1">func = delayed(</span><span class="s0">lambda </span><span class="s1">x: tuple()</span><span class="s0">, </span><span class="s1">nout=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">x = func(</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">len(x) == </span><span class="s3">0</span>
    <span class="s0">assert </span><span class="s1">x.compute() == tuple()</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;x&quot;</span><span class="s0">,</span>
    <span class="s1">[[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(add</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">()]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_nout_with_tasks(x):</span>
    <span class="s1">length = len(x)</span>
    <span class="s1">d = delayed(x</span><span class="s0">, </span><span class="s1">nout=length)</span>
    <span class="s0">assert </span><span class="s1">len(d) == len(list(d)) == length</span>
    <span class="s0">assert </span><span class="s1">d.compute() == x</span>


<span class="s0">def </span><span class="s1">test_kwargs():</span>
    <span class="s0">def </span><span class="s1">mysum(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">c=()</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">return </span><span class="s1">a + b + sum(c) + sum(kwargs.values())</span>

    <span class="s1">dmysum = delayed(mysum)</span>
    <span class="s1">ten = dmysum(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">c=[delayed(</span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">four=dmysum(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
    <span class="s0">assert </span><span class="s1">ten.compute() == </span><span class="s3">10</span>
    <span class="s1">dmysum = delayed(mysum</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">c = [delayed(</span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">ten = dmysum(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">c=c</span><span class="s0">, </span><span class="s1">four=dmysum(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
    <span class="s0">assert </span><span class="s1">ten.compute() == </span><span class="s3">10</span>
    <span class="s0">assert </span><span class="s1">dmysum(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">c=c</span><span class="s0">, </span><span class="s1">four=dmysum(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)).key == ten.key</span>
    <span class="s0">assert </span><span class="s1">dmysum(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">c=c</span><span class="s0">, </span><span class="s1">four=dmysum(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)).key != ten.key</span>
    <span class="s0">assert </span><span class="s1">dmysum(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">c=c</span><span class="s0">, </span><span class="s1">four=</span><span class="s3">4</span><span class="s1">).key != ten.key</span>
    <span class="s0">assert </span><span class="s1">dmysum(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">c=c</span><span class="s0">, </span><span class="s1">four=</span><span class="s3">4</span><span class="s1">).key != dmysum(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">c=c</span><span class="s0">, </span><span class="s1">four=</span><span class="s3">4</span><span class="s1">).key</span>


<span class="s0">def </span><span class="s1">test_custom_delayed():</span>
    <span class="s1">x = Tuple({</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s3">2</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">: (add</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">)}</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s1">x2 = delayed(add</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">True</span><span class="s1">)(x</span><span class="s0">, </span><span class="s1">(</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">))</span>
    <span class="s1">n = delayed(len</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">True</span><span class="s1">)(x)</span>
    <span class="s0">assert </span><span class="s1">delayed(len</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">True</span><span class="s1">)(x).key == n.key</span>
    <span class="s0">assert </span><span class="s1">x2.compute() == (</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">compute(n</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s1">x) == (</span><span class="s3">3</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>


<span class="s1">@pytest.mark.filterwarnings(</span><span class="s2">&quot;ignore:The dask.delayed:UserWarning&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_array_delayed():</span>
    <span class="s1">np = pytest.importorskip(</span><span class="s2">&quot;numpy&quot;</span><span class="s1">)</span>
    <span class="s1">da = pytest.importorskip(</span><span class="s2">&quot;dask.array&quot;</span><span class="s1">)</span>

    <span class="s1">arr = np.arange(</span><span class="s3">100</span><span class="s1">).reshape((</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">))</span>
    <span class="s1">darr = da.from_array(arr</span><span class="s0">, </span><span class="s1">chunks=(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">5</span><span class="s1">))</span>
    <span class="s1">val = delayed(sum)([arr</span><span class="s0">, </span><span class="s1">darr</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
    <span class="s0">assert </span><span class="s1">isinstance(val</span><span class="s0">, </span><span class="s1">Delayed)</span>
    <span class="s0">assert </span><span class="s1">np.allclose(val.compute()</span><span class="s0">, </span><span class="s1">arr + arr + </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">val.sum().compute() == (arr + arr + </span><span class="s3">1</span><span class="s1">).sum()</span>
    <span class="s0">assert </span><span class="s1">val[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">].compute() == (arr + arr + </span><span class="s3">1</span><span class="s1">)[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span>

    <span class="s1">task</span><span class="s0">, </span><span class="s1">dsk = to_task_dask(darr)</span>
    <span class="s0">assert not </span><span class="s1">darr.dask.keys() - dsk.keys()</span>
    <span class="s1">diff = dsk.keys() - darr.dask.keys()</span>
    <span class="s0">assert </span><span class="s1">len(diff) == </span><span class="s3">1</span>

    <span class="s1">delayed_arr = delayed(darr)</span>
    <span class="s0">assert </span><span class="s1">(delayed_arr.compute() == arr).all()</span>


<span class="s0">def </span><span class="s1">test_array_bag_delayed():</span>
    <span class="s1">da = pytest.importorskip(</span><span class="s2">&quot;dask.array&quot;</span><span class="s1">)</span>
    <span class="s1">np = pytest.importorskip(</span><span class="s2">&quot;numpy&quot;</span><span class="s1">)</span>

    <span class="s1">arr1 = np.arange(</span><span class="s3">100</span><span class="s1">).reshape((</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">))</span>
    <span class="s1">arr2 = arr1.dot(arr1.T)</span>
    <span class="s1">darr1 = da.from_array(arr1</span><span class="s0">, </span><span class="s1">chunks=(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">5</span><span class="s1">))</span>
    <span class="s1">darr2 = da.from_array(arr2</span><span class="s0">, </span><span class="s1">chunks=(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">5</span><span class="s1">))</span>
    <span class="s1">b = db.from_sequence([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span>
    <span class="s1">seq = [arr1</span><span class="s0">, </span><span class="s1">arr2</span><span class="s0">, </span><span class="s1">darr1</span><span class="s0">, </span><span class="s1">darr2</span><span class="s0">, </span><span class="s1">b]</span>
    <span class="s1">out = delayed(sum)([i.sum() </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">seq])</span>
    <span class="s0">assert </span><span class="s1">out.compute() == </span><span class="s3">2 </span><span class="s1">* arr1.sum() + </span><span class="s3">2 </span><span class="s1">* arr2.sum() + sum([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">test_delayed_picklable():</span>
    <span class="s4"># Delayed</span>
    <span class="s1">x = delayed(divmod</span><span class="s0">, </span><span class="s1">nout=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">True</span><span class="s1">)(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">y = pickle.loads(pickle.dumps(x))</span>
    <span class="s0">assert </span><span class="s1">x.dask == y.dask</span>
    <span class="s0">assert </span><span class="s1">x._key == y._key</span>
    <span class="s0">assert </span><span class="s1">x._length == y._length</span>
    <span class="s4"># DelayedLeaf</span>
    <span class="s1">x = delayed(</span><span class="s3">1j </span><span class="s1">+ </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">y = pickle.loads(pickle.dumps(x))</span>
    <span class="s0">assert </span><span class="s1">x.dask == y.dask</span>
    <span class="s0">assert </span><span class="s1">x._key == y._key</span>
    <span class="s0">assert </span><span class="s1">x._nout == y._nout</span>
    <span class="s0">assert </span><span class="s1">x._pure == y._pure</span>
    <span class="s4"># DelayedAttr</span>
    <span class="s1">x = x.real</span>
    <span class="s1">y = pickle.loads(pickle.dumps(x))</span>
    <span class="s0">assert </span><span class="s1">x._obj._key == y._obj._key</span>
    <span class="s0">assert </span><span class="s1">x._obj.dask == y._obj.dask</span>
    <span class="s0">assert </span><span class="s1">x._attr == y._attr</span>
    <span class="s0">assert </span><span class="s1">x._key == y._key</span>


<span class="s0">def </span><span class="s1">test_delayed_compute_forward_kwargs():</span>
    <span class="s1">x = delayed(</span><span class="s3">1</span><span class="s1">) + </span><span class="s3">2</span>
    <span class="s1">x.compute(bogus_keyword=</span><span class="s3">10</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_delayed_method_descriptor():</span>
    <span class="s1">delayed(bytes.decode)(</span><span class="s5">b&quot;&quot;</span><span class="s1">)  </span><span class="s4"># does not err</span>


<span class="s0">def </span><span class="s1">test_delayed_callable():</span>
    <span class="s1">f = delayed(add</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">v = f(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">v.dask == {v.key: (add</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)}</span>

    <span class="s0">assert </span><span class="s1">f.dask == {f.key: add}</span>
    <span class="s0">assert </span><span class="s1">f.compute() == add</span>


<span class="s0">def </span><span class="s1">test_delayed_name_on_call():</span>
    <span class="s1">f = delayed(add</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">f(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">dask_key_name=</span><span class="s2">&quot;foo&quot;</span><span class="s1">)._key == </span><span class="s2">&quot;foo&quot;</span>


<span class="s0">def </span><span class="s1">test_callable_obj():</span>
    <span class="s0">class </span><span class="s1">Foo:</span>
        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">a):</span>
            <span class="s1">self.a = a</span>

        <span class="s0">def </span><span class="s1">__call__(self):</span>
            <span class="s0">return </span><span class="s3">2</span>

    <span class="s1">foo = Foo(</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">f = delayed(foo)</span>
    <span class="s0">assert </span><span class="s1">f.compute() </span><span class="s0">is </span><span class="s1">foo</span>
    <span class="s0">assert </span><span class="s1">f.a.compute() == </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">f().compute() == </span><span class="s3">2</span>


<span class="s0">def </span><span class="s1">identity(x):</span>
    <span class="s0">return </span><span class="s1">x</span>


<span class="s0">def </span><span class="s1">test_name_consistent_across_instances():</span>
    <span class="s1">func = delayed(identity</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s1">data = {</span><span class="s2">&quot;x&quot;</span><span class="s1">: </span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: </span><span class="s3">25</span><span class="s0">, </span><span class="s2">&quot;z&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]}</span>
    <span class="s0">assert </span><span class="s1">func(data)._key == </span><span class="s2">&quot;identity-4f318f3c27b869239e97c3ac07f7201a&quot;</span>

    <span class="s1">data = {</span><span class="s2">&quot;x&quot;</span><span class="s1">: </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">: </span><span class="s2">&quot;x&quot;</span><span class="s1">}</span>
    <span class="s0">assert </span><span class="s1">func(data)._key == func(data)._key</span>
    <span class="s0">assert </span><span class="s1">func(</span><span class="s3">1</span><span class="s1">)._key == </span><span class="s2">&quot;identity-7258833899272585e16d0ec36b21a3de&quot;</span>


<span class="s0">def </span><span class="s1">test_sensitive_to_partials():</span>
    <span class="s0">assert </span><span class="s1">(</span>
        <span class="s1">delayed(partial(add</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">True</span><span class="s1">)(</span><span class="s3">2</span><span class="s1">)._key</span>
        <span class="s1">!= delayed(partial(add</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">True</span><span class="s1">)(</span><span class="s3">2</span><span class="s1">)._key</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_delayed_name():</span>
    <span class="s0">assert </span><span class="s1">delayed(</span><span class="s3">1</span><span class="s1">)._key.startswith(</span><span class="s2">&quot;int-&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">delayed(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">True</span><span class="s1">)._key.startswith(</span><span class="s2">&quot;int-&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">delayed(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;X&quot;</span><span class="s1">)._key == </span><span class="s2">&quot;X&quot;</span>

    <span class="s0">def </span><span class="s1">myfunc(x):</span>
        <span class="s0">return </span><span class="s1">x + </span><span class="s3">1</span>

    <span class="s0">assert </span><span class="s1">delayed(myfunc)(</span><span class="s3">1</span><span class="s1">).key.startswith(</span><span class="s2">&quot;myfunc&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_finalize_name():</span>
    <span class="s1">da = pytest.importorskip(</span><span class="s2">&quot;dask.array&quot;</span><span class="s1">)</span>

    <span class="s1">x = da.ones(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">chunks=</span><span class="s3">5</span><span class="s1">)</span>
    <span class="s1">v = delayed([x])</span>
    <span class="s0">assert </span><span class="s1">set(x.dask).issubset(v.dask)</span>

    <span class="s0">def </span><span class="s1">key(s):</span>
        <span class="s0">if </span><span class="s1">isinstance(s</span><span class="s0">, </span><span class="s1">tuple):</span>
            <span class="s1">s = s[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s4"># Ignore _ in 'ones_like'</span>
        <span class="s0">return </span><span class="s1">s.split(</span><span class="s2">&quot;-&quot;</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">].replace(</span><span class="s2">&quot;_&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">)</span>

    <span class="s0">assert </span><span class="s1">all(key(k).isalpha() </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">v.dask)</span>


<span class="s0">def </span><span class="s1">test_keys_from_array():</span>
    <span class="s1">da = pytest.importorskip(</span><span class="s2">&quot;dask.array&quot;</span><span class="s1">)</span>
    <span class="s0">from </span><span class="s1">dask.array.utils </span><span class="s0">import </span><span class="s1">_check_dsk</span>

    <span class="s1">X = da.ones((</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">chunks=</span><span class="s3">5</span><span class="s1">).to_delayed().flatten()</span>
    <span class="s1">xs = [delayed(inc)(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">X]</span>

    <span class="s1">_check_dsk(xs[</span><span class="s3">0</span><span class="s1">].dask)</span>


<span class="s4"># Mostly copied from https://github.com/pytoolz/toolz/pull/220</span>
<span class="s0">def </span><span class="s1">test_delayed_decorator_on_method():</span>
    <span class="s0">class </span><span class="s1">A:</span>
        <span class="s1">BASE = </span><span class="s3">10</span>

        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">base):</span>
            <span class="s1">self.BASE = base</span>

        <span class="s1">@delayed</span>
        <span class="s0">def </span><span class="s1">addmethod(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y):</span>
            <span class="s0">return </span><span class="s1">self.BASE + x + y</span>

        <span class="s1">@classmethod</span>
        <span class="s1">@delayed</span>
        <span class="s0">def </span><span class="s1">addclass(cls</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y):</span>
            <span class="s0">return </span><span class="s1">cls.BASE + x + y</span>

        <span class="s1">@staticmethod</span>
        <span class="s1">@delayed</span>
        <span class="s0">def </span><span class="s1">addstatic(x</span><span class="s0">, </span><span class="s1">y):</span>
            <span class="s0">return </span><span class="s1">x + y</span>

    <span class="s1">a = A(</span><span class="s3">100</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">a.addmethod(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">).compute() == </span><span class="s3">107</span>
    <span class="s0">assert </span><span class="s1">A.addmethod(a</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">).compute() == </span><span class="s3">107</span>

    <span class="s0">assert </span><span class="s1">a.addclass(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">).compute() == </span><span class="s3">17</span>
    <span class="s0">assert </span><span class="s1">A.addclass(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">).compute() == </span><span class="s3">17</span>

    <span class="s0">assert </span><span class="s1">a.addstatic(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">).compute() == </span><span class="s3">7</span>
    <span class="s0">assert </span><span class="s1">A.addstatic(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">).compute() == </span><span class="s3">7</span>

    <span class="s4"># We want the decorated methods to be actual methods for instance methods</span>
    <span class="s4"># and class methods since their first arguments are the object and the</span>
    <span class="s4"># class respectively. Or in other words, the first argument is generated by</span>
    <span class="s4"># the runtime based on the object/class before the dot.</span>
    <span class="s0">assert </span><span class="s1">isinstance(a.addmethod</span><span class="s0">, </span><span class="s1">types.MethodType)</span>
    <span class="s0">assert </span><span class="s1">isinstance(A.addclass</span><span class="s0">, </span><span class="s1">types.MethodType)</span>

    <span class="s4"># For static methods (and regular functions), the decorated methods should</span>
    <span class="s4"># be Delayed objects.</span>
    <span class="s0">assert </span><span class="s1">isinstance(A.addstatic</span><span class="s0">, </span><span class="s1">Delayed)</span>


<span class="s0">def </span><span class="s1">test_attribute_of_attribute():</span>
    <span class="s1">x = delayed(</span><span class="s3">123</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">isinstance(x.a</span><span class="s0">, </span><span class="s1">Delayed)</span>
    <span class="s0">assert </span><span class="s1">isinstance(x.a.b</span><span class="s0">, </span><span class="s1">Delayed)</span>
    <span class="s0">assert </span><span class="s1">isinstance(x.a.b.c</span><span class="s0">, </span><span class="s1">Delayed)</span>


<span class="s0">def </span><span class="s1">test_check_meta_flag():</span>
    <span class="s1">dd = pytest.importorskip(</span><span class="s2">&quot;dask.dataframe&quot;</span><span class="s1">)</span>
    <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">Series</span>

    <span class="s1">a = Series([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;category&quot;</span><span class="s1">)</span>
    <span class="s1">b = Series([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;category&quot;</span><span class="s1">)</span>
    <span class="s1">da = delayed(</span><span class="s0">lambda </span><span class="s1">x: x)(a)</span>
    <span class="s1">db = delayed(</span><span class="s0">lambda </span><span class="s1">x: x)(b)</span>

    <span class="s1">c = dd.from_delayed([da</span><span class="s0">, </span><span class="s1">db]</span><span class="s0">, </span><span class="s1">verify_meta=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">dd.utils.assert_eq(c</span><span class="s0">, </span><span class="s1">c)</span>


<span class="s0">def </span><span class="s1">modlevel_eager(x):</span>
    <span class="s0">return </span><span class="s1">x + </span><span class="s3">1</span>


<span class="s1">@delayed</span>
<span class="s0">def </span><span class="s1">modlevel_delayed1(x):</span>
    <span class="s0">return </span><span class="s1">x + </span><span class="s3">1</span>


<span class="s1">@delayed(pure=</span><span class="s0">False</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">modlevel_delayed2(x):</span>
    <span class="s0">return </span><span class="s1">x + </span><span class="s3">1</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;f&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">delayed(modlevel_eager)</span><span class="s0">,</span>
        <span class="s1">pytest.param(modlevel_delayed1</span><span class="s0">, </span><span class="s1">marks=pytest.mark.xfail(reason=</span><span class="s2">&quot;#3369&quot;</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">pytest.param(modlevel_delayed2</span><span class="s0">, </span><span class="s1">marks=pytest.mark.xfail(reason=</span><span class="s2">&quot;#3369&quot;</span><span class="s1">))</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_pickle(f):</span>
    <span class="s1">d = f(</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">d = pickle.loads(pickle.dumps(d</span><span class="s0">, </span><span class="s1">protocol=pickle.HIGHEST_PROTOCOL))</span>
    <span class="s0">assert </span><span class="s1">d.compute() == </span><span class="s3">3</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;f&quot;</span><span class="s0">, </span><span class="s1">[delayed(modlevel_eager)</span><span class="s0">, </span><span class="s1">modlevel_delayed1</span><span class="s0">, </span><span class="s1">modlevel_delayed2]</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_cloudpickle(f):</span>
    <span class="s1">d = f(</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">d = cloudpickle.loads(cloudpickle.dumps(d</span><span class="s0">, </span><span class="s1">protocol=pickle.HIGHEST_PROTOCOL))</span>
    <span class="s0">assert </span><span class="s1">d.compute() == </span><span class="s3">3</span>


<span class="s0">def </span><span class="s1">test_dask_layers():</span>
    <span class="s1">d1 = delayed(</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">d1.dask.layers.keys() == {d1.key}</span>
    <span class="s0">assert </span><span class="s1">d1.dask.dependencies == {d1.key: set()}</span>
    <span class="s0">assert </span><span class="s1">d1.__dask_layers__() == (d1.key</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s1">d2 = modlevel_delayed1(d1)</span>
    <span class="s0">assert </span><span class="s1">d2.dask.layers.keys() == {d1.key</span><span class="s0">, </span><span class="s1">d2.key}</span>
    <span class="s0">assert </span><span class="s1">d2.dask.dependencies == {d1.key: set()</span><span class="s0">, </span><span class="s1">d2.key: {d1.key}}</span>
    <span class="s0">assert </span><span class="s1">d2.__dask_layers__() == (d2.key</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s1">hlg = HighLevelGraph.from_collections(</span><span class="s2">&quot;foo&quot;</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;alias&quot;</span><span class="s1">: d2.key}</span><span class="s0">, </span><span class="s1">dependencies=[d2])</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;not in&quot;</span><span class="s1">):</span>
        <span class="s1">Delayed(</span><span class="s2">&quot;alias&quot;</span><span class="s0">, </span><span class="s1">hlg)</span>

    <span class="s1">explicit = Delayed(</span><span class="s2">&quot;alias&quot;</span><span class="s0">, </span><span class="s1">hlg</span><span class="s0">, </span><span class="s1">layer=</span><span class="s2">&quot;foo&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">explicit.__dask_layers__() == (</span><span class="s2">&quot;foo&quot;</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s1">explicit.dask.validate()</span>


<span class="s0">def </span><span class="s1">test_annotations_survive_optimization():</span>
    <span class="s0">with </span><span class="s1">dask.annotate(foo=</span><span class="s2">&quot;bar&quot;</span><span class="s1">):</span>
        <span class="s1">graph = HighLevelGraph.from_collections(</span>
            <span class="s2">&quot;b&quot;</span><span class="s0">,</span>
            <span class="s1">{</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: (inc</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">: (inc</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">)}</span><span class="s0">,</span>
            <span class="s1">[]</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">d = Delayed(</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s1">graph)</span>

    <span class="s0">assert </span><span class="s1">type(d.dask) </span><span class="s0">is </span><span class="s1">HighLevelGraph</span>
    <span class="s0">assert </span><span class="s1">len(d.dask.layers) == </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">len(d.dask.layers[</span><span class="s2">&quot;b&quot;</span><span class="s1">]) == </span><span class="s3">3</span>
    <span class="s0">assert </span><span class="s1">d.dask.layers[</span><span class="s2">&quot;b&quot;</span><span class="s1">].annotations == {</span><span class="s2">&quot;foo&quot;</span><span class="s1">: </span><span class="s2">&quot;bar&quot;</span><span class="s1">}</span>

    <span class="s4"># Ensure optimizing a Delayed object returns a HighLevelGraph</span>
    <span class="s4"># and doesn't loose annotations</span>
    <span class="s1">(d_opt</span><span class="s0">,</span><span class="s1">) = dask.optimize(d)</span>
    <span class="s0">assert </span><span class="s1">type(d_opt.dask) </span><span class="s0">is </span><span class="s1">HighLevelGraph</span>
    <span class="s0">assert </span><span class="s1">len(d_opt.dask.layers) == </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">len(d_opt.dask.layers[</span><span class="s2">&quot;b&quot;</span><span class="s1">]) == </span><span class="s3">2  </span><span class="s4"># c is culled</span>
    <span class="s0">assert </span><span class="s1">d_opt.dask.layers[</span><span class="s2">&quot;b&quot;</span><span class="s1">].annotations == {</span><span class="s2">&quot;foo&quot;</span><span class="s1">: </span><span class="s2">&quot;bar&quot;</span><span class="s1">}</span>


<span class="s0">def </span><span class="s1">test_delayed_function_attributes_forwarded():</span>
    <span class="s1">@delayed</span>
    <span class="s0">def </span><span class="s1">add(x</span><span class="s0">, </span><span class="s1">y):</span>
        <span class="s6">&quot;&quot;&quot;This is a docstring&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">x + y</span>

    <span class="s0">assert </span><span class="s1">add.__name__ == </span><span class="s2">&quot;add&quot;</span>
    <span class="s0">assert </span><span class="s1">add.__doc__ == </span><span class="s2">&quot;This is a docstring&quot;</span>
</pre>
</body>
</html>