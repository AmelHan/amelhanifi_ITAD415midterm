<html>
<head>
<title>test_penalized.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_penalized.py</font>
</center></td></tr></table>
<pre><span class="s0"># -*- coding: utf-8 -*-</span>
<span class="s2">&quot;&quot;&quot; 
Created on Sun May 10 12:39:33 2015 
 
Author: Josef Perktold 
License: BSD-3 
&quot;&quot;&quot;</span>

<span class="s3">import </span><span class="s1">warnings</span>

<span class="s3">import </span><span class="s1">pytest</span>
<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">numpy.testing </span><span class="s3">import </span><span class="s1">assert_allclose</span><span class="s3">, </span><span class="s1">assert_equal</span>
<span class="s3">from </span><span class="s1">statsmodels.discrete.discrete_model </span><span class="s3">import </span><span class="s1">Poisson</span><span class="s3">, </span><span class="s1">Logit</span><span class="s3">, </span><span class="s1">Probit</span>
<span class="s3">from </span><span class="s1">statsmodels.genmod.generalized_linear_model </span><span class="s3">import </span><span class="s1">GLM</span>
<span class="s3">from </span><span class="s1">statsmodels.genmod.families </span><span class="s3">import </span><span class="s1">family</span>
<span class="s3">from </span><span class="s1">statsmodels.sandbox.regression.penalized </span><span class="s3">import </span><span class="s1">TheilGLS</span>
<span class="s3">from </span><span class="s1">statsmodels.base._penalized </span><span class="s3">import </span><span class="s1">PenalizedMixin</span>
<span class="s3">import </span><span class="s1">statsmodels.base._penalties </span><span class="s3">as </span><span class="s1">smpen</span>


<span class="s3">class </span><span class="s1">PoissonPenalized(PenalizedMixin</span><span class="s3">, </span><span class="s1">Poisson):</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">LogitPenalized(PenalizedMixin</span><span class="s3">, </span><span class="s1">Logit):</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">ProbitPenalized(PenalizedMixin</span><span class="s3">, </span><span class="s1">Probit):</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">GLMPenalized(PenalizedMixin</span><span class="s3">, </span><span class="s1">GLM):</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">CheckPenalizedPoisson:</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>
        <span class="s0"># simulate data</span>
        <span class="s1">np.random.seed(</span><span class="s4">987865</span><span class="s1">)</span>

        <span class="s1">nobs</span><span class="s3">, </span><span class="s1">k_vars = </span><span class="s4">500</span><span class="s3">, </span><span class="s4">10</span>
        <span class="s1">k_nonzero = </span><span class="s4">4</span>
        <span class="s1">x = ((np.random.rand(nobs</span><span class="s3">, </span><span class="s1">k_vars) +</span>
              <span class="s4">0.5</span><span class="s1">* (np.random.rand(nobs</span><span class="s3">, </span><span class="s4">1</span><span class="s1">) - </span><span class="s4">0.5</span><span class="s1">)) * </span><span class="s4">2 </span><span class="s1">- </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">x *= </span><span class="s4">1.2</span>
        <span class="s1">x[:</span><span class="s3">, </span><span class="s4">0</span><span class="s1">] = </span><span class="s4">1</span>
        <span class="s1">beta = np.zeros(k_vars)</span>
        <span class="s1">beta[:k_nonzero] = </span><span class="s4">1. </span><span class="s1">/ np.arange(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">k_nonzero + </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">linpred = x.dot(beta)</span>
        <span class="s1">y = cls._generate_endog(linpred)</span>

        <span class="s1">cls.k_nonzero = k_nonzero</span>
        <span class="s1">cls.x = x</span>
        <span class="s1">cls.y = y</span>

        <span class="s0"># defaults to be overwritten by subclasses</span>
        <span class="s1">cls.rtol = </span><span class="s4">1e-4</span>
        <span class="s1">cls.atol = </span><span class="s4">1e-6</span>
        <span class="s1">cls.exog_index = slice(</span><span class="s3">None, None, None</span><span class="s1">)</span>
        <span class="s1">cls.k_params = k_vars</span>
        <span class="s1">cls.skip_hessian = </span><span class="s3">False  </span><span class="s0"># can be overwritten in _initialize</span>
        <span class="s1">cls.penalty = smpen.SCADSmoothed(</span><span class="s4">0.1</span><span class="s3">, </span><span class="s1">c0=</span><span class="s4">0.0001</span><span class="s1">)  </span><span class="s0"># default for tests</span>
        <span class="s1">cls._initialize()</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_generate_endog(cls</span><span class="s3">, </span><span class="s1">linpred):</span>
        <span class="s1">mu = np.exp(linpred)</span>
        <span class="s1">np.random.seed(</span><span class="s4">999</span><span class="s1">)</span>
        <span class="s1">y = np.random.poisson(mu)</span>
        <span class="s3">return </span><span class="s1">y</span>

    <span class="s3">def </span><span class="s1">test_params_table(self):</span>
        <span class="s1">res1 = self.res1</span>
        <span class="s1">res2 = self.res2</span>
        <span class="s1">assert_equal((res1.params != </span><span class="s4">0</span><span class="s1">).sum()</span><span class="s3">, </span><span class="s1">self.k_params)</span>
        <span class="s1">assert_allclose(res1.params[self.exog_index]</span><span class="s3">, </span><span class="s1">res2.params</span><span class="s3">,</span>
                        <span class="s1">rtol=self.rtol</span><span class="s3">, </span><span class="s1">atol=self.atol)</span>
        <span class="s1">assert_allclose(res1.bse[self.exog_index]</span><span class="s3">, </span><span class="s1">res2.bse</span><span class="s3">, </span><span class="s1">rtol=self.rtol</span><span class="s3">,</span>
                        <span class="s1">atol=self.atol)</span>
        <span class="s3">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s0"># silence scipy distribution warnigns becaus of zero bse</span>
            <span class="s1">warnings.simplefilter(</span><span class="s5">'ignore'</span><span class="s3">, </span><span class="s1">RuntimeWarning)</span>
            <span class="s1">assert_allclose(res1.pvalues[self.exog_index]</span><span class="s3">, </span><span class="s1">res2.pvalues</span><span class="s3">,</span>
                            <span class="s1">rtol=self.rtol</span><span class="s3">, </span><span class="s1">atol=self.atol)</span>
        <span class="s1">assert_allclose(res1.predict()</span><span class="s3">, </span><span class="s1">res2.predict()</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">0.05</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.smoke</span>
    <span class="s3">def </span><span class="s1">test_summary(self):</span>
        <span class="s1">self.res1.summary()</span>

    <span class="s1">@pytest.mark.smoke</span>
    <span class="s3">def </span><span class="s1">test_summary2(self):</span>
        <span class="s1">summ = self.res1.summary2()</span>
        <span class="s3">assert </span><span class="s1">isinstance(summ.as_latex()</span><span class="s3">, </span><span class="s1">str)</span>
        <span class="s3">assert </span><span class="s1">isinstance(summ.as_html()</span><span class="s3">, </span><span class="s1">str)</span>
        <span class="s3">assert </span><span class="s1">isinstance(summ.as_text()</span><span class="s3">, </span><span class="s1">str)</span>

    <span class="s3">def </span><span class="s1">test_numdiff(self):</span>
        <span class="s1">res1 = self.res1</span>

        <span class="s0"># avoid checking score at MLE, score close to zero</span>
        <span class="s1">p = res1.params * </span><span class="s4">0.98</span>
        <span class="s0"># GLM concentrates out scale which affects derivatives, see #4616</span>
        <span class="s1">kwds = {</span><span class="s5">'scale'</span><span class="s1">: </span><span class="s4">1</span><span class="s1">} </span><span class="s3">if </span><span class="s1">isinstance(res1.model</span><span class="s3">, </span><span class="s1">GLM) </span><span class="s3">else </span><span class="s1">{}</span>

        <span class="s1">assert_allclose(res1.model.score(p</span><span class="s3">, </span><span class="s1">**kwds)[self.exog_index]</span><span class="s3">,</span>
                        <span class="s1">res1.model.score_numdiff(p</span><span class="s3">, </span><span class="s1">**kwds)[self.exog_index]</span><span class="s3">,</span>
                        <span class="s1">rtol=</span><span class="s4">0.025</span><span class="s1">)</span>

        <span class="s3">if not </span><span class="s1">self.skip_hessian:</span>
            <span class="s3">if </span><span class="s1">isinstance(self.exog_index</span><span class="s3">, </span><span class="s1">slice):</span>
                <span class="s1">idx1 = idx2 = self.exog_index</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">idx1 = self.exog_index[:</span><span class="s3">, None</span><span class="s1">]</span>
                <span class="s1">idx2 = self.exog_index</span>

            <span class="s1">h1 = res1.model.hessian(res1.params</span><span class="s3">, </span><span class="s1">**kwds)[idx1</span><span class="s3">, </span><span class="s1">idx2]</span>
            <span class="s1">h2 = res1.model.hessian_numdiff(res1.params</span><span class="s3">, </span><span class="s1">**kwds)[idx1</span><span class="s3">, </span><span class="s1">idx2]</span>
            <span class="s1">assert_allclose(h1</span><span class="s3">, </span><span class="s1">h2</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">0.02</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">TestPenalizedPoissonNonePenal(CheckPenalizedPoisson):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_initialize(cls):</span>
        <span class="s1">y</span><span class="s3">, </span><span class="s1">x = cls.y</span><span class="s3">, </span><span class="s1">cls.x</span>

        <span class="s1">modp = Poisson(y</span><span class="s3">, </span><span class="s1">x)</span>
        <span class="s1">cls.res2 = modp.fit(disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">mod = PoissonPenalized(y</span><span class="s3">, </span><span class="s1">x)  </span><span class="s0"># default no penalty</span>
        <span class="s1">mod.pen_weight = </span><span class="s4">0</span>
        <span class="s1">cls.res1 = mod.fit(method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s3">, </span><span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">cls.atol = </span><span class="s4">5e-6</span>


<span class="s3">class </span><span class="s1">TestPenalizedPoissonNoPenal(CheckPenalizedPoisson):</span>
    <span class="s0"># TODO: check, adjust cov_type</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_initialize(cls):</span>
        <span class="s1">y</span><span class="s3">, </span><span class="s1">x = cls.y</span><span class="s3">, </span><span class="s1">cls.x</span>

        <span class="s1">modp = Poisson(y</span><span class="s3">, </span><span class="s1">x)</span>
        <span class="s1">cls.res2 = modp.fit(disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">mod = PoissonPenalized(y</span><span class="s3">, </span><span class="s1">x)</span>
        <span class="s1">mod.pen_weight = </span><span class="s4">0</span>
        <span class="s1">cls.res1 = mod.fit(method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s3">, </span><span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">cls.atol = </span><span class="s4">5e-6</span>


<span class="s3">class </span><span class="s1">TestPenalizedGLMPoissonNoPenal(CheckPenalizedPoisson):</span>
    <span class="s0"># TODO: check, adjust cov_type</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_initialize(cls):</span>
        <span class="s1">y</span><span class="s3">, </span><span class="s1">x = cls.y</span><span class="s3">, </span><span class="s1">cls.x</span>

        <span class="s1">modp = GLM(y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">family=family.Poisson())</span>
        <span class="s1">cls.res2 = modp.fit()</span>

        <span class="s1">mod = GLMPenalized(y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">family=family.Poisson()</span><span class="s3">, </span><span class="s1">penal=cls.penalty)</span>
        <span class="s1">mod.pen_weight = </span><span class="s4">0</span>
        <span class="s1">cls.res1 = mod.fit(method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s3">, </span><span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">cls.atol = </span><span class="s4">5e-6</span>


<span class="s3">class </span><span class="s1">TestPenalizedPoissonOracle(CheckPenalizedPoisson):</span>
    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_initialize(cls):</span>
        <span class="s1">y</span><span class="s3">, </span><span class="s1">x = cls.y</span><span class="s3">, </span><span class="s1">cls.x</span>
        <span class="s1">modp = Poisson(y</span><span class="s3">, </span><span class="s1">x[:</span><span class="s3">, </span><span class="s1">:cls.k_nonzero])</span>
        <span class="s1">cls.res2 = modp.fit(disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">mod = PoissonPenalized(y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">penal=cls.penalty)</span>
        <span class="s1">mod.pen_weight *= </span><span class="s4">1.5</span>
        <span class="s1">mod.penal.tau = </span><span class="s4">0.05</span>
        <span class="s1">cls.res1 = mod.fit(method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s3">, </span><span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">cls.exog_index = slice(</span><span class="s3">None, </span><span class="s1">cls.k_nonzero</span><span class="s3">, None</span><span class="s1">)</span>

        <span class="s1">cls.atol = </span><span class="s4">5e-3</span>


<span class="s3">class </span><span class="s1">TestPenalizedGLMPoissonOracle(CheckPenalizedPoisson):</span>
    <span class="s0"># TODO: check, adjust cov_type</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_initialize(cls):</span>
        <span class="s1">y</span><span class="s3">, </span><span class="s1">x = cls.y</span><span class="s3">, </span><span class="s1">cls.x</span>
        <span class="s1">modp = GLM(y</span><span class="s3">, </span><span class="s1">x[:</span><span class="s3">, </span><span class="s1">:cls.k_nonzero]</span><span class="s3">, </span><span class="s1">family=family.Poisson())</span>
        <span class="s1">cls.res2 = modp.fit()</span>

        <span class="s1">mod = GLMPenalized(y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">family=family.Poisson()</span><span class="s3">, </span><span class="s1">penal=cls.penalty)</span>
        <span class="s1">mod.pen_weight *= </span><span class="s4">1.5  </span><span class="s0"># same as discrete Poisson</span>
        <span class="s1">mod.penal.tau = </span><span class="s4">0.05</span>
        <span class="s1">cls.res1 = mod.fit(method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s1">)</span>

        <span class="s1">cls.exog_index = slice(</span><span class="s3">None, </span><span class="s1">cls.k_nonzero</span><span class="s3">, None</span><span class="s1">)</span>

        <span class="s1">cls.atol = </span><span class="s4">5e-3</span>


<span class="s3">class </span><span class="s1">TestPenalizedPoissonOracleHC(CheckPenalizedPoisson):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_initialize(cls):</span>
        <span class="s1">y</span><span class="s3">, </span><span class="s1">x = cls.y</span><span class="s3">, </span><span class="s1">cls.x</span>
        <span class="s1">cov_type = </span><span class="s5">'HC0'</span>
        <span class="s1">modp = Poisson(y</span><span class="s3">, </span><span class="s1">x[:</span><span class="s3">, </span><span class="s1">:cls.k_nonzero])</span>
        <span class="s1">cls.res2 = modp.fit(cov_type=cov_type</span><span class="s3">, </span><span class="s1">method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s3">,</span>
                            <span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">mod = PoissonPenalized(y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">penal=cls.penalty)</span>
        <span class="s1">mod.pen_weight *= </span><span class="s4">1.5</span>
        <span class="s1">mod.penal.tau = </span><span class="s4">0.05</span>
        <span class="s1">cls.res1 = mod.fit(cov_type=cov_type</span><span class="s3">, </span><span class="s1">method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s3">,</span>
                           <span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">cls.exog_index = slice(</span><span class="s3">None, </span><span class="s1">cls.k_nonzero</span><span class="s3">, None</span><span class="s1">)</span>

        <span class="s1">cls.atol = </span><span class="s4">5e-3</span>

    <span class="s3">def </span><span class="s1">test_cov_type(self):</span>
        <span class="s1">res1 = self.res1</span>
        <span class="s1">res2 = self.res2</span>

        <span class="s1">assert_equal(self.res1.cov_type</span><span class="s3">, </span><span class="s5">'HC0'</span><span class="s1">)</span>
        <span class="s1">cov_kwds = {</span><span class="s5">'description'</span><span class="s1">: </span><span class="s5">'Standard Errors are heteroscedasticity '</span>
                    <span class="s5">'robust (HC0)'</span><span class="s3">,</span>
                    <span class="s5">'adjust_df'</span><span class="s1">: </span><span class="s3">False, </span><span class="s5">'use_t'</span><span class="s1">: </span><span class="s3">False, </span><span class="s5">'scaling_factor'</span><span class="s1">: </span><span class="s3">None</span><span class="s1">}</span>
        <span class="s1">assert_equal(self.res1.cov_kwds</span><span class="s3">, </span><span class="s1">cov_kwds)</span>
        <span class="s0"># numbers are regression test using bfgs</span>
        <span class="s1">params = np.array([</span><span class="s4">0.96817787574701109</span><span class="s3">, </span><span class="s4">0.43674374940137434</span><span class="s3">,</span>
                           <span class="s4">0.33096260487556745</span><span class="s3">, </span><span class="s4">0.27415680046693747</span><span class="s1">])</span>
        <span class="s1">bse = np.array([</span><span class="s4">0.028126650444581985</span><span class="s3">, </span><span class="s4">0.033099984564283147</span><span class="s3">,</span>
                        <span class="s4">0.033184585514904545</span><span class="s3">, </span><span class="s4">0.034282504130503301</span><span class="s1">])</span>
        <span class="s1">assert_allclose(res2.params[:self.k_nonzero]</span><span class="s3">, </span><span class="s1">params</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">1e-5</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res2.bse[:self.k_nonzero]</span><span class="s3">, </span><span class="s1">bse</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.params[:self.k_nonzero]</span><span class="s3">, </span><span class="s1">params</span><span class="s3">, </span><span class="s1">atol=self.atol)</span>
        <span class="s1">assert_allclose(res1.bse[:self.k_nonzero]</span><span class="s3">, </span><span class="s1">bse</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">0.02</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">TestPenalizedGLMPoissonOracleHC(CheckPenalizedPoisson):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_initialize(cls):</span>
        <span class="s1">y</span><span class="s3">, </span><span class="s1">x = cls.y</span><span class="s3">, </span><span class="s1">cls.x</span>
        <span class="s1">cov_type = </span><span class="s5">'HC0'</span>
        <span class="s1">modp = GLM(y</span><span class="s3">, </span><span class="s1">x[:</span><span class="s3">, </span><span class="s1">:cls.k_nonzero]</span><span class="s3">, </span><span class="s1">family=family.Poisson())</span>
        <span class="s1">cls.res2 = modp.fit(cov_type=cov_type</span><span class="s3">, </span><span class="s1">method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s3">,</span>
                            <span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">mod = GLMPenalized(y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">family=family.Poisson()</span><span class="s3">, </span><span class="s1">penal=cls.penalty)</span>
        <span class="s1">mod.pen_weight *= </span><span class="s4">1.5  </span><span class="s0"># same as ddiscrete Poisson</span>
        <span class="s1">mod.penal.tau = </span><span class="s4">0.05</span>
        <span class="s1">cls.res1 = mod.fit(cov_type=cov_type</span><span class="s3">, </span><span class="s1">method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s3">,</span>
                           <span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">cls.exog_index = slice(</span><span class="s3">None, </span><span class="s1">cls.k_nonzero</span><span class="s3">, None</span><span class="s1">)</span>

        <span class="s1">cls.atol = </span><span class="s4">5e-3</span>


<span class="s3">class </span><span class="s1">TestPenalizedPoissonGLMOracleHC(CheckPenalizedPoisson):</span>
    <span class="s0"># compare discrete Poisson and GLM-Poisson</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_initialize(cls):</span>
        <span class="s1">y</span><span class="s3">, </span><span class="s1">x = cls.y</span><span class="s3">, </span><span class="s1">cls.x</span>
        <span class="s1">cov_type = </span><span class="s5">'HC0'</span>
        <span class="s1">modp = PoissonPenalized(y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">penal=cls.penalty)</span>
        <span class="s1">modp.pen_weight *= </span><span class="s4">1.5  </span><span class="s0"># same as discrete Poisson 1.5</span>
        <span class="s1">modp.penal.tau = </span><span class="s4">0.05</span>
        <span class="s1">cls.res2 = modp.fit(cov_type=cov_type</span><span class="s3">, </span><span class="s1">method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s3">,</span>
                            <span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">mod = GLMPenalized(y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">family=family.Poisson()</span><span class="s3">, </span><span class="s1">penal=cls.penalty)</span>
        <span class="s1">mod.pen_weight *= </span><span class="s4">1.5  </span><span class="s0"># same as discrete Poisson 1.5</span>
        <span class="s1">mod.penal.tau = </span><span class="s4">0.05</span>
        <span class="s1">cls.res1 = mod.fit(cov_type=cov_type</span><span class="s3">, </span><span class="s1">method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s3">,</span>
                           <span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">cls.exog_index = slice(</span><span class="s3">None, None, None</span><span class="s1">)</span>

        <span class="s1">cls.atol = </span><span class="s4">1e-4</span>


<span class="s3">class </span><span class="s1">TestPenalizedPoissonOraclePenalized(CheckPenalizedPoisson):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_initialize(cls):</span>
        <span class="s1">y</span><span class="s3">, </span><span class="s1">x = cls.y</span><span class="s3">, </span><span class="s1">cls.x</span>
        <span class="s1">modp = PoissonPenalized(y</span><span class="s3">, </span><span class="s1">x[:</span><span class="s3">, </span><span class="s1">:cls.k_nonzero]</span><span class="s3">, </span><span class="s1">penal=cls.penalty)</span>
        <span class="s1">cls.res2 = modp.fit(method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s3">, </span><span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">mod = PoissonPenalized(y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">penal=cls.penalty)</span>
        <span class="s0"># mod.pen_weight *= 1.5</span>
        <span class="s0"># mod.penal.tau = 0.05</span>
        <span class="s1">cls.res1 = mod.fit(method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s3">, </span><span class="s1">trim=</span><span class="s3">False, </span><span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">cls.exog_index = slice(</span><span class="s3">None, </span><span class="s1">cls.k_nonzero</span><span class="s3">, None</span><span class="s1">)</span>

        <span class="s1">cls.atol = </span><span class="s4">1e-3</span>


<span class="s3">class </span><span class="s1">TestPenalizedPoissonOraclePenalized2(CheckPenalizedPoisson):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_initialize(cls):</span>
        <span class="s1">y</span><span class="s3">, </span><span class="s1">x = cls.y</span><span class="s3">, </span><span class="s1">cls.x</span>
        <span class="s1">modp = PoissonPenalized(y</span><span class="s3">, </span><span class="s1">x[:</span><span class="s3">, </span><span class="s1">:cls.k_nonzero]</span><span class="s3">, </span><span class="s1">penal=cls.penalty)</span>
        <span class="s1">modp.pen_weight *= </span><span class="s4">10  </span><span class="s0"># need to penalize more to get oracle selection</span>
        <span class="s1">modp.penal.tau = </span><span class="s4">0.05</span>
        <span class="s1">sp2 = np.array([</span><span class="s4">0.96817921</span><span class="s3">, </span><span class="s4">0.43673551</span><span class="s3">, </span><span class="s4">0.33096011</span><span class="s3">, </span><span class="s4">0.27416614</span><span class="s1">])</span>
        <span class="s1">cls.res2 = modp.fit(start_params=sp2 * </span><span class="s4">0.5</span><span class="s3">, </span><span class="s1">method=</span><span class="s5">'bfgs'</span><span class="s3">,</span>
                            <span class="s1">maxiter=</span><span class="s4">100</span><span class="s3">, </span><span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">params_notrim = np.array([</span>
            <span class="s4">9.68178874e-01</span><span class="s3">, </span><span class="s4">4.36744981e-01</span><span class="s3">, </span><span class="s4">3.30965041e-01</span><span class="s3">, </span><span class="s4">2.74161883e-01</span><span class="s3">,</span>
            <span class="s1">-</span><span class="s4">2.58988461e-06</span><span class="s3">, </span><span class="s1">-</span><span class="s4">1.24352640e-06</span><span class="s3">, </span><span class="s4">4.48584458e-08</span><span class="s3">, </span><span class="s1">-</span><span class="s4">2.46876149e-06</span><span class="s3">,</span>
            <span class="s1">-</span><span class="s4">1.02471074e-05</span><span class="s3">, </span><span class="s1">-</span><span class="s4">4.39248098e-06</span><span class="s1">])</span>

        <span class="s1">mod = PoissonPenalized(y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">penal=cls.penalty)</span>
        <span class="s1">mod.pen_weight *= </span><span class="s4">10  </span><span class="s0"># need to penalize more to get oracle selection</span>
        <span class="s1">mod.penal.tau = </span><span class="s4">0.05</span>
        <span class="s1">cls.res1 = mod.fit(start_params=params_notrim * </span><span class="s4">0.5</span><span class="s3">,</span>
                           <span class="s1">method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s3">, </span><span class="s1">trim=</span><span class="s3">True, </span><span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">cls.exog_index = slice(</span><span class="s3">None, </span><span class="s1">cls.k_nonzero</span><span class="s3">, None</span><span class="s1">)</span>

        <span class="s1">cls.atol = </span><span class="s4">1e-8</span>
        <span class="s1">cls.k_params = cls.k_nonzero</span>

    <span class="s3">def </span><span class="s1">test_zeros(self):</span>

        <span class="s0"># first test for trimmed result</span>
        <span class="s1">assert_equal(self.res1.params[self.k_nonzero:]</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s0"># we also set bse to zero, TODO: check fit_regularized</span>
        <span class="s1">assert_equal(self.res1.bse[self.k_nonzero:]</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">TestPenalizedPoissonOraclePenalized2HC(CheckPenalizedPoisson):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_initialize(cls):</span>
        <span class="s1">y</span><span class="s3">, </span><span class="s1">x = cls.y</span><span class="s3">, </span><span class="s1">cls.x</span>
        <span class="s1">cov_type = </span><span class="s5">'HC0'</span>
        <span class="s1">modp = PoissonPenalized(y</span><span class="s3">, </span><span class="s1">x[:</span><span class="s3">, </span><span class="s1">:cls.k_nonzero]</span><span class="s3">, </span><span class="s1">penal=cls.penalty)</span>
        <span class="s1">modp.pen_weight *= </span><span class="s4">10  </span><span class="s0"># need to penalize more to get oracle selection</span>
        <span class="s1">modp.penal.tau = </span><span class="s4">0.05</span>
        <span class="s1">sp2 = np.array([</span><span class="s4">0.96817921</span><span class="s3">, </span><span class="s4">0.43673551</span><span class="s3">, </span><span class="s4">0.33096011</span><span class="s3">, </span><span class="s4">0.27416614</span><span class="s1">])</span>
        <span class="s1">cls.res2 = modp.fit(start_params=sp2 * </span><span class="s4">0.5</span><span class="s3">, </span><span class="s1">cov_type=cov_type</span><span class="s3">,</span>
                            <span class="s1">method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s3">, </span><span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">params_notrim = np.array([</span>
            <span class="s4">9.68178874e-01</span><span class="s3">, </span><span class="s4">4.36744981e-01</span><span class="s3">, </span><span class="s4">3.30965041e-01</span><span class="s3">, </span><span class="s4">2.74161883e-01</span><span class="s3">,</span>
            <span class="s1">-</span><span class="s4">2.58988461e-06</span><span class="s3">, </span><span class="s1">-</span><span class="s4">1.24352640e-06</span><span class="s3">, </span><span class="s4">4.48584458e-08</span><span class="s3">, </span><span class="s1">-</span><span class="s4">2.46876149e-06</span><span class="s3">,</span>
            <span class="s1">-</span><span class="s4">1.02471074e-05</span><span class="s3">, </span><span class="s1">-</span><span class="s4">4.39248098e-06</span><span class="s1">])</span>

        <span class="s1">mod = PoissonPenalized(y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">penal=cls.penalty)</span>
        <span class="s1">mod.pen_weight *= </span><span class="s4">10  </span><span class="s0"># need to penalize more to get oracle selection</span>
        <span class="s1">mod.penal.tau = </span><span class="s4">0.05</span>
        <span class="s1">cls.res1 = mod.fit(start_params=params_notrim * </span><span class="s4">0.5</span><span class="s3">,</span><span class="s1">cov_type=cov_type</span><span class="s3">,</span>
                           <span class="s1">method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s3">, </span><span class="s1">trim=</span><span class="s3">True, </span><span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">cls.exog_index = slice(</span><span class="s3">None, </span><span class="s1">cls.k_nonzero</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">cls.atol = </span><span class="s4">1e-12</span>
        <span class="s1">cls.k_params = cls.k_nonzero</span>

    <span class="s3">def </span><span class="s1">test_cov_type(self):</span>
        <span class="s1">res1 = self.res1</span>
        <span class="s1">res2 = self.res2</span>

        <span class="s1">assert_equal(self.res1.cov_type</span><span class="s3">, </span><span class="s5">'HC0'</span><span class="s1">)</span>
        <span class="s1">assert_equal(self.res1.results_constrained.cov_type</span><span class="s3">, </span><span class="s5">'HC0'</span><span class="s1">)</span>
        <span class="s1">cov_kwds = {</span><span class="s5">'description'</span><span class="s1">: </span><span class="s5">'Standard Errors are heteroscedasticity '</span>
                                   <span class="s5">'robust (HC0)'</span><span class="s3">,</span>
                    <span class="s5">'adjust_df'</span><span class="s1">: </span><span class="s3">False, </span><span class="s5">'use_t'</span><span class="s1">: </span><span class="s3">False, </span><span class="s5">'scaling_factor'</span><span class="s1">: </span><span class="s3">None</span><span class="s1">}</span>
        <span class="s1">assert_equal(self.res1.cov_kwds</span><span class="s3">, </span><span class="s1">cov_kwds)</span>
        <span class="s1">assert_equal(self.res1.cov_kwds</span><span class="s3">, </span><span class="s1">self.res1.results_constrained.cov_kwds)</span>

        <span class="s0"># numbers are regression test using bfgs</span>
        <span class="s1">params = np.array([</span><span class="s4">0.96817787574701109</span><span class="s3">, </span><span class="s4">0.43674374940137434</span><span class="s3">,</span>
                           <span class="s4">0.33096260487556745</span><span class="s3">, </span><span class="s4">0.27415680046693747</span><span class="s1">])</span>
        <span class="s1">bse = np.array([</span><span class="s4">0.028126650444581985</span><span class="s3">, </span><span class="s4">0.033099984564283147</span><span class="s3">,</span>
                        <span class="s4">0.033184585514904545</span><span class="s3">, </span><span class="s4">0.034282504130503301</span><span class="s1">])</span>
        <span class="s1">assert_allclose(res2.params[:self.k_nonzero]</span><span class="s3">, </span><span class="s1">params</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">1e-5</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res2.bse[:self.k_nonzero]</span><span class="s3">, </span><span class="s1">bse</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">5e-6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.params[:self.k_nonzero]</span><span class="s3">, </span><span class="s1">params</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">1e-5</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.bse[:self.k_nonzero]</span><span class="s3">, </span><span class="s1">bse</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">5e-6</span><span class="s1">)</span>


<span class="s0"># the following classes are copies of Poisson with model adjustments</span>

<span class="s3">class </span><span class="s1">CheckPenalizedLogit(CheckPenalizedPoisson):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_generate_endog(cls</span><span class="s3">, </span><span class="s1">linpred):</span>
        <span class="s1">mu = </span><span class="s4">1 </span><span class="s1">/ (</span><span class="s4">1 </span><span class="s1">+ np.exp(-linpred + linpred.mean() - </span><span class="s4">0.5</span><span class="s1">))</span>
        <span class="s1">np.random.seed(</span><span class="s4">999</span><span class="s1">)</span>
        <span class="s1">y = np.random.rand(len(mu)) &lt; mu</span>
        <span class="s3">return </span><span class="s1">y</span>


<span class="s3">class </span><span class="s1">TestPenalizedLogitNoPenal(CheckPenalizedLogit):</span>
    <span class="s0"># TODO: check, adjust cov_type</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_initialize(cls):</span>
        <span class="s1">y</span><span class="s3">, </span><span class="s1">x = cls.y</span><span class="s3">, </span><span class="s1">cls.x</span>

        <span class="s1">modp = Logit(y</span><span class="s3">, </span><span class="s1">x)</span>
        <span class="s1">cls.res2 = modp.fit(disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">mod = LogitPenalized(y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">penal=cls.penalty)</span>
        <span class="s1">mod.pen_weight = </span><span class="s4">0</span>
        <span class="s1">cls.res1 = mod.fit(disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">cls.atol = </span><span class="s4">1e-4  </span><span class="s0"># why not closer ?</span>


<span class="s3">class </span><span class="s1">TestPenalizedLogitOracle(CheckPenalizedLogit):</span>
    <span class="s0"># TODO: check, adjust cov_type</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_initialize(cls):</span>
        <span class="s1">y</span><span class="s3">, </span><span class="s1">x = cls.y</span><span class="s3">, </span><span class="s1">cls.x</span>
        <span class="s1">modp = Logit(y</span><span class="s3">, </span><span class="s1">x[:</span><span class="s3">, </span><span class="s1">:cls.k_nonzero])</span>
        <span class="s1">cls.res2 = modp.fit(disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">mod = LogitPenalized(y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">penal=cls.penalty)</span>
        <span class="s1">mod.pen_weight *= </span><span class="s4">.5</span>
        <span class="s1">mod.penal.tau = </span><span class="s4">0.05</span>
        <span class="s1">cls.res1 = mod.fit(method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s3">, </span><span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">cls.exog_index = slice(</span><span class="s3">None, </span><span class="s1">cls.k_nonzero</span><span class="s3">, None</span><span class="s1">)</span>

        <span class="s1">cls.atol = </span><span class="s4">5e-3</span>


<span class="s3">class </span><span class="s1">TestPenalizedGLMLogitOracle(CheckPenalizedLogit):</span>
    <span class="s0"># TODO: check, adjust cov_type</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_initialize(cls):</span>
        <span class="s1">y</span><span class="s3">, </span><span class="s1">x = cls.y</span><span class="s3">, </span><span class="s1">cls.x</span>
        <span class="s1">modp = GLM(y</span><span class="s3">, </span><span class="s1">x[:</span><span class="s3">, </span><span class="s1">:cls.k_nonzero]</span><span class="s3">, </span><span class="s1">family=family.Binomial())</span>
        <span class="s1">cls.res2 = modp.fit(disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">mod = GLMPenalized(y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">family=family.Binomial()</span><span class="s3">, </span><span class="s1">penal=cls.penalty)</span>
        <span class="s1">mod.pen_weight *= </span><span class="s4">.5</span>
        <span class="s1">mod.penal.tau = </span><span class="s4">0.05</span>
        <span class="s1">cls.res1 = mod.fit(method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s3">, </span><span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">cls.exog_index = slice(</span><span class="s3">None, </span><span class="s1">cls.k_nonzero</span><span class="s3">, None</span><span class="s1">)</span>

        <span class="s1">cls.atol = </span><span class="s4">5e-3</span>


<span class="s3">class </span><span class="s1">TestPenalizedLogitOraclePenalized(CheckPenalizedLogit):</span>
    <span class="s0"># TODO: check, adjust cov_type</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_initialize(cls):</span>
        <span class="s1">y</span><span class="s3">, </span><span class="s1">x = cls.y</span><span class="s3">, </span><span class="s1">cls.x</span>
        <span class="s1">modp = LogitPenalized(y</span><span class="s3">, </span><span class="s1">x[:</span><span class="s3">, </span><span class="s1">:cls.k_nonzero]</span><span class="s3">, </span><span class="s1">penal=cls.penalty)</span>
        <span class="s1">cls.res2 = modp.fit(method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s3">, </span><span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">mod = LogitPenalized(y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">penal=cls.penalty)</span>
        <span class="s0"># mod.pen_weight *= 1.5</span>
        <span class="s0"># mod.penal.tau = 0.05</span>
        <span class="s1">cls.res1 = mod.fit(method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s3">, </span><span class="s1">trim=</span><span class="s3">False, </span><span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">cls.exog_index = slice(</span><span class="s3">None, </span><span class="s1">cls.k_nonzero</span><span class="s3">, None</span><span class="s1">)</span>

        <span class="s1">cls.atol = </span><span class="s4">1e-3</span>


<span class="s3">class </span><span class="s1">TestPenalizedLogitOraclePenalized2(CheckPenalizedLogit):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_initialize(cls):</span>
        <span class="s1">y</span><span class="s3">, </span><span class="s1">x = cls.y</span><span class="s3">, </span><span class="s1">cls.x</span>
        <span class="s1">modp = LogitPenalized(y</span><span class="s3">, </span><span class="s1">x[:</span><span class="s3">, </span><span class="s1">:cls.k_nonzero]</span><span class="s3">, </span><span class="s1">penal=cls.penalty)</span>
        <span class="s1">modp.pen_weight *= </span><span class="s4">0.5</span>
        <span class="s1">modp.penal.tau = </span><span class="s4">0.05</span>
        <span class="s1">cls.res2 = modp.fit(method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s3">, </span><span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">mod = LogitPenalized(y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">penal=cls.penalty)</span>
        <span class="s1">mod.pen_weight *= </span><span class="s4">0.5</span>
        <span class="s1">mod.penal.tau = </span><span class="s4">0.05</span>
        <span class="s1">cls.res1 = mod.fit(method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s3">, </span><span class="s1">trim=</span><span class="s3">True, </span><span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">cls.exog_index = slice(</span><span class="s3">None, </span><span class="s1">cls.k_nonzero</span><span class="s3">, None</span><span class="s1">)</span>

        <span class="s1">cls.atol = </span><span class="s4">1e-8</span>
        <span class="s1">cls.k_params = cls.k_nonzero</span>

    <span class="s3">def </span><span class="s1">test_zeros(self):</span>

        <span class="s0"># test for trimmed result</span>
        <span class="s1">assert_equal(self.res1.params[self.k_nonzero:]</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s0"># we also set bse to zero</span>
        <span class="s1">assert_equal(self.res1.bse[self.k_nonzero:]</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>


<span class="s0"># the following classes are copies of Poisson with model adjustments</span>
<span class="s3">class </span><span class="s1">CheckPenalizedBinomCount(CheckPenalizedPoisson):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_generate_endog(cls</span><span class="s3">, </span><span class="s1">linpred):</span>
        <span class="s1">mu = </span><span class="s4">1 </span><span class="s1">/ (</span><span class="s4">1 </span><span class="s1">+ np.exp(-linpred + linpred.mean() - </span><span class="s4">0.5</span><span class="s1">))</span>
        <span class="s1">np.random.seed(</span><span class="s4">999</span><span class="s1">)</span>
        <span class="s1">n_trials = </span><span class="s4">5 </span><span class="s1">* np.ones(len(mu)</span><span class="s3">, </span><span class="s1">int)</span>
        <span class="s1">n_trials[:len(mu)//</span><span class="s4">2</span><span class="s1">] += </span><span class="s4">5</span>
        <span class="s1">y = np.random.binomial(n_trials</span><span class="s3">, </span><span class="s1">mu)</span>
        <span class="s3">return </span><span class="s1">np.column_stack((y</span><span class="s3">, </span><span class="s1">n_trials - y))</span>


<span class="s3">class </span><span class="s1">TestPenalizedGLMBinomCountNoPenal(CheckPenalizedBinomCount):</span>
    <span class="s0"># TODO: check, adjust cov_type</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_initialize(cls):</span>
        <span class="s1">y</span><span class="s3">, </span><span class="s1">x = cls.y</span><span class="s3">, </span><span class="s1">cls.x</span>
        <span class="s1">x = x[:</span><span class="s3">, </span><span class="s1">:</span><span class="s4">4</span><span class="s1">]</span>
        <span class="s1">offset = -</span><span class="s4">0.25 </span><span class="s1">* np.ones(len(y))  </span><span class="s0"># also check offset</span>
        <span class="s1">modp = GLM(y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">family=family.Binomial()</span><span class="s3">, </span><span class="s1">offset=offset)</span>
        <span class="s1">cls.res2 = modp.fit(method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">max_start_irls=</span><span class="s4">100</span><span class="s1">)</span>

        <span class="s1">mod = GLMPenalized(y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">family=family.Binomial()</span><span class="s3">, </span><span class="s1">offset=offset</span><span class="s3">,</span>
                           <span class="s1">penal=cls.penalty)</span>
        <span class="s1">mod.pen_weight = </span><span class="s4">0</span>
        <span class="s1">cls.res1 = mod.fit(method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">max_start_irls=</span><span class="s4">3</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s3">, </span><span class="s1">disp=</span><span class="s4">0</span><span class="s3">,</span>
                           <span class="s1">start_params=cls.res2.params*</span><span class="s4">0.9</span><span class="s1">)</span>

        <span class="s1">cls.atol = </span><span class="s4">1e-10</span>
        <span class="s1">cls.k_params = </span><span class="s4">4</span>

    <span class="s3">def </span><span class="s1">test_deriv(self):</span>
        <span class="s1">res1 = self.res1</span>
        <span class="s1">res2 = self.res2</span>
        <span class="s1">assert_allclose(res1.model.score(res2.params * </span><span class="s4">0.98</span><span class="s1">)</span><span class="s3">,</span>
                        <span class="s1">res2.model.score(res2.params * </span><span class="s4">0.98</span><span class="s1">)</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.model.score_obs(res2.params * </span><span class="s4">0.98</span><span class="s1">)</span><span class="s3">,</span>
                        <span class="s1">res2.model.score_obs(res2.params * </span><span class="s4">0.98</span><span class="s1">)</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-10</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">TestPenalizedGLMBinomCountOracleHC(CheckPenalizedBinomCount):</span>
    <span class="s0"># TODO: There are still problems with this case</span>
    <span class="s0"># using the standard optimization, I get convergence failures and</span>
    <span class="s0"># different estimates depending on details, e.g. small changes in pen_weight</span>
    <span class="s0"># most likely convexity fails with SCAD in this case</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_initialize(cls):</span>
        <span class="s1">y</span><span class="s3">, </span><span class="s1">x = cls.y</span><span class="s3">, </span><span class="s1">cls.x</span>
        <span class="s1">offset = -</span><span class="s4">0.25 </span><span class="s1">* np.ones(len(y))  </span><span class="s0"># also check offset</span>
        <span class="s1">cov_type = </span><span class="s5">'HC0'</span>
        <span class="s1">modp = GLM(y</span><span class="s3">, </span><span class="s1">x[:</span><span class="s3">, </span><span class="s1">:cls.k_nonzero]</span><span class="s3">, </span><span class="s1">family=family.Binomial()</span><span class="s3">,</span>
                   <span class="s1">offset=offset)</span>
        <span class="s1">cls.res2 = modp.fit(cov_type=cov_type</span><span class="s3">, </span><span class="s1">method=</span><span class="s5">'newton'</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">1000</span><span class="s3">,</span>
                            <span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">mod = GLMPenalized(y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">family=family.Binomial()</span><span class="s3">, </span><span class="s1">offset=offset</span><span class="s3">,</span>
                           <span class="s1">penal=cls.penalty)</span>
        <span class="s1">mod.pen_weight *= </span><span class="s4">1  </span><span class="s0"># lower than in other cases</span>
        <span class="s1">mod.penal.tau = </span><span class="s4">0.05</span>
        <span class="s1">cls.res1 = mod.fit(cov_type=cov_type</span><span class="s3">, </span><span class="s1">method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">max_start_irls=</span><span class="s4">0</span><span class="s3">,</span>
                           <span class="s1">maxiter=</span><span class="s4">100</span><span class="s3">, </span><span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">cls.exog_index = slice(</span><span class="s3">None, </span><span class="s1">cls.k_nonzero</span><span class="s3">, None</span><span class="s1">)</span>

        <span class="s1">cls.atol = </span><span class="s4">1e-3</span>


<span class="s3">class </span><span class="s1">TestPenalizedGLMBinomCountOracleHC2(CheckPenalizedBinomCount):</span>
    <span class="s0"># TODO: There are still problems with this case, see other class</span>
    <span class="s0"># with trimming of small parameters, needs larger trim threshold</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_initialize(cls):</span>
        <span class="s1">y</span><span class="s3">, </span><span class="s1">x = cls.y</span><span class="s3">, </span><span class="s1">cls.x</span>
        <span class="s1">offset = -</span><span class="s4">0.25 </span><span class="s1">* np.ones(len(y))  </span><span class="s0"># also check offset</span>
        <span class="s1">cov_type = </span><span class="s5">'HC0'</span>
        <span class="s1">modp = GLM(y</span><span class="s3">, </span><span class="s1">x[:</span><span class="s3">, </span><span class="s1">:cls.k_nonzero]</span><span class="s3">, </span><span class="s1">family=family.Binomial()</span><span class="s3">,</span>
                   <span class="s1">offset=offset)</span>
        <span class="s1">cls.res2 = modp.fit(cov_type=cov_type</span><span class="s3">, </span><span class="s1">method=</span><span class="s5">'newton'</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">1000</span><span class="s3">,</span>
                            <span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">mod = GLMPenalized(y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">family=family.Binomial()</span><span class="s3">, </span><span class="s1">offset=offset</span><span class="s3">,</span>
                           <span class="s1">penal=cls.penalty)</span>
        <span class="s1">mod.pen_weight *= </span><span class="s4">1  </span><span class="s0"># lower than in other cases</span>
        <span class="s1">mod.penal.tau = </span><span class="s4">0.05</span>
        <span class="s1">cls.res1 = mod.fit(cov_type=cov_type</span><span class="s3">, </span><span class="s1">method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">max_start_irls=</span><span class="s4">0</span><span class="s3">,</span>
                           <span class="s1">maxiter=</span><span class="s4">100</span><span class="s3">, </span><span class="s1">disp=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">trim=</span><span class="s4">0.001</span><span class="s1">)</span>

        <span class="s1">cls.exog_index = slice(</span><span class="s3">None, </span><span class="s1">cls.k_nonzero</span><span class="s3">, None</span><span class="s1">)</span>

        <span class="s1">cls.atol = </span><span class="s4">1e-3</span>
        <span class="s1">cls.k_params = cls.k_nonzero</span>


<span class="s0"># the following classes are copies of Poisson with model adjustments</span>
<span class="s3">class </span><span class="s1">CheckPenalizedGaussian(CheckPenalizedPoisson):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_generate_endog(cls</span><span class="s3">, </span><span class="s1">linpred):</span>
        <span class="s1">sig_e = np.sqrt(</span><span class="s4">0.1</span><span class="s1">)</span>
        <span class="s1">np.random.seed(</span><span class="s4">999</span><span class="s1">)</span>
        <span class="s1">y = linpred + sig_e * np.random.rand(len(linpred))</span>
        <span class="s3">return </span><span class="s1">y</span>


<span class="s3">class </span><span class="s1">TestPenalizedGLMGaussianOracleHC(CheckPenalizedGaussian):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_initialize(cls):</span>
        <span class="s1">y</span><span class="s3">, </span><span class="s1">x = cls.y</span><span class="s3">, </span><span class="s1">cls.x</span>
        <span class="s0"># adding 10 to avoid strict rtol at predicted values close to zero</span>
        <span class="s1">y = y + </span><span class="s4">10</span>
        <span class="s1">cov_type = </span><span class="s5">'HC0'</span>
        <span class="s1">modp = GLM(y</span><span class="s3">, </span><span class="s1">x[:</span><span class="s3">, </span><span class="s1">:cls.k_nonzero]</span><span class="s3">, </span><span class="s1">family=family.Gaussian())</span>
        <span class="s1">cls.res2 = modp.fit(cov_type=cov_type</span><span class="s3">, </span><span class="s1">method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s3">,</span>
                            <span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">mod = GLMPenalized(y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">family=family.Gaussian()</span><span class="s3">, </span><span class="s1">penal=cls.penalty)</span>
        <span class="s1">mod.pen_weight *= </span><span class="s4">1.5  </span><span class="s0"># same as discrete Poisson</span>
        <span class="s1">mod.penal.tau = </span><span class="s4">0.05</span>
        <span class="s1">cls.res1 = mod.fit(cov_type=cov_type</span><span class="s3">, </span><span class="s1">method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s3">,</span>
                           <span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">cls.exog_index = slice(</span><span class="s3">None, </span><span class="s1">cls.k_nonzero</span><span class="s3">, None</span><span class="s1">)</span>

        <span class="s1">cls.atol = </span><span class="s4">5e-6</span>
        <span class="s1">cls.rtol = </span><span class="s4">1e-6</span>


<span class="s3">class </span><span class="s1">TestPenalizedGLMGaussianOracleHC2(CheckPenalizedGaussian):</span>
    <span class="s0"># with trimming</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_initialize(cls):</span>
        <span class="s1">y</span><span class="s3">, </span><span class="s1">x = cls.y</span><span class="s3">, </span><span class="s1">cls.x</span>
        <span class="s0"># adding 10 to avoid strict rtol at predicted values close to zero</span>
        <span class="s1">y = y + </span><span class="s4">10</span>
        <span class="s1">cov_type = </span><span class="s5">'HC0'</span>
        <span class="s1">modp = GLM(y</span><span class="s3">, </span><span class="s1">x[:</span><span class="s3">, </span><span class="s1">:cls.k_nonzero]</span><span class="s3">, </span><span class="s1">family=family.Gaussian())</span>
        <span class="s1">cls.res2 = modp.fit(cov_type=cov_type</span><span class="s3">, </span><span class="s1">method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s3">,</span>
                            <span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">mod = GLMPenalized(y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">family=family.Gaussian()</span><span class="s3">, </span><span class="s1">penal=cls.penalty)</span>
        <span class="s1">mod.pen_weight *= </span><span class="s4">1.5  </span><span class="s0"># same as discrete Poisson</span>
        <span class="s1">mod.penal.tau = </span><span class="s4">0.05</span>
        <span class="s1">cls.res1 = mod.fit(cov_type=cov_type</span><span class="s3">, </span><span class="s1">method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s3">,</span>
                           <span class="s1">disp=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">trim=</span><span class="s3">True</span><span class="s1">)</span>

        <span class="s1">cls.exog_index = slice(</span><span class="s3">None, </span><span class="s1">cls.k_nonzero</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">cls.k_params = cls.k_nonzero</span>
        <span class="s1">cls.atol = </span><span class="s4">1e-5</span>
        <span class="s1">cls.rtol = </span><span class="s4">1e-5</span>


<span class="s3">class </span><span class="s1">TestPenalizedGLMGaussianL2(CheckPenalizedGaussian):</span>
    <span class="s0"># L2 penalty on redundant exog</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_initialize(cls):</span>
        <span class="s1">y</span><span class="s3">, </span><span class="s1">x = cls.y</span><span class="s3">, </span><span class="s1">cls.x</span>
        <span class="s0"># adding 10 to avoid strict rtol at predicted values close to zero</span>
        <span class="s1">y = y + </span><span class="s4">10</span>
        <span class="s1">cov_type = </span><span class="s5">'HC0'</span>
        <span class="s1">modp = GLM(y</span><span class="s3">, </span><span class="s1">x[:</span><span class="s3">, </span><span class="s1">:cls.k_nonzero]</span><span class="s3">, </span><span class="s1">family=family.Gaussian())</span>
        <span class="s1">cls.res2 = modp.fit(cov_type=cov_type</span><span class="s3">, </span><span class="s1">method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s3">,</span>
                            <span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">weights = (np.arange(x.shape[</span><span class="s4">1</span><span class="s1">]) &gt;= </span><span class="s4">4</span><span class="s1">).astype(float)</span>
        <span class="s1">mod = GLMPenalized(y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">family=family.Gaussian()</span><span class="s3">,</span>
                           <span class="s1">penal=smpen.L2ConstraintsPenalty(weights=weights))</span>
        <span class="s0"># make pen_weight large to force redundant to close to zero</span>
        <span class="s1">mod.pen_weight *= </span><span class="s4">500</span>
        <span class="s1">cls.res1 = mod.fit(cov_type=cov_type</span><span class="s3">, </span><span class="s1">method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s3">,</span>
                           <span class="s1">disp=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">trim=</span><span class="s3">False</span><span class="s1">)</span>

        <span class="s1">cls.exog_index = slice(</span><span class="s3">None, </span><span class="s1">cls.k_nonzero</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">cls.k_params = x.shape[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">cls.atol = </span><span class="s4">1e-5</span>
        <span class="s1">cls.rtol = </span><span class="s4">1e-5</span>


<span class="s3">class </span><span class="s1">TestPenalizedGLMGaussianL2Theil(CheckPenalizedGaussian):</span>
    <span class="s0"># L2 penalty on redundant exog</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_initialize(cls):</span>
        <span class="s1">y</span><span class="s3">, </span><span class="s1">x = cls.y</span><span class="s3">, </span><span class="s1">cls.x</span>
        <span class="s0"># adding 10 to avoid strict rtol at predicted values close to zero</span>
        <span class="s1">y = y + </span><span class="s4">10</span>
        <span class="s1">k = x.shape[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">cov_type = </span><span class="s5">'HC0'</span>
        <span class="s1">restriction = np.eye(k)[</span><span class="s4">2</span><span class="s1">:]</span>
        <span class="s1">modp = TheilGLS(y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">r_matrix=restriction)</span>
        <span class="s0"># the corresponding Theil penweight seems to be 2 * nobs / sigma2_e</span>
        <span class="s1">cls.res2 = modp.fit(pen_weight=</span><span class="s4">120.74564413221599 </span><span class="s1">* </span><span class="s4">1000</span><span class="s3">, </span><span class="s1">use_t=</span><span class="s3">False</span><span class="s1">)</span>

        <span class="s1">pen = smpen.L2ConstraintsPenalty(restriction=restriction)</span>
        <span class="s1">mod = GLMPenalized(y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">family=family.Gaussian()</span><span class="s3">,</span>
                           <span class="s1">penal=pen)</span>
        <span class="s0"># use default weight for GLMPenalized</span>
        <span class="s1">mod.pen_weight *= </span><span class="s4">1</span>
        <span class="s1">cls.res1 = mod.fit(cov_type=cov_type</span><span class="s3">, </span><span class="s1">method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s3">,</span>
                           <span class="s1">disp=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">trim=</span><span class="s3">False</span><span class="s1">)</span>

        <span class="s1">cls.k_nonzero = k</span>
        <span class="s1">cls.exog_index = slice(</span><span class="s3">None, </span><span class="s1">cls.k_nonzero</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">cls.k_params = x.shape[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">cls.atol = </span><span class="s4">1e-5</span>
        <span class="s1">cls.rtol = </span><span class="s4">1e-5</span>

    <span class="s3">def </span><span class="s1">test_params_table(self):</span>
        <span class="s0"># override inherited because match is not good except for params and predict</span>
        <span class="s0"># The cov_type in GLMPenalized and in TheilGLS are not the same</span>
        <span class="s0"># both use sandwiches but TheilGLS sandwich is not HC</span>
        <span class="s0"># relative difference in bse up to 7%</span>
        <span class="s1">res1 = self.res1</span>
        <span class="s1">res2 = self.res2</span>
        <span class="s1">assert_equal((res1.params != </span><span class="s4">0</span><span class="s1">).sum()</span><span class="s3">, </span><span class="s1">self.k_params)</span>
        <span class="s1">assert_allclose(res1.params</span><span class="s3">, </span><span class="s1">res2.params</span><span class="s3">, </span><span class="s1">rtol=self.rtol</span><span class="s3">,</span>
                        <span class="s1">atol=self.atol)</span>

        <span class="s1">exog_index = slice(</span><span class="s3">None, None, None</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.bse[exog_index]</span><span class="s3">, </span><span class="s1">res2.bse[exog_index]</span><span class="s3">,</span>
                        <span class="s1">rtol=</span><span class="s4">0.1</span><span class="s3">, </span><span class="s1">atol=self.atol)</span>
        <span class="s1">assert_allclose(res1.tvalues[exog_index]</span><span class="s3">, </span><span class="s1">res2.tvalues[exog_index]</span><span class="s3">,</span>
                        <span class="s1">rtol=</span><span class="s4">0.08</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">5e-3</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.pvalues[exog_index]</span><span class="s3">, </span><span class="s1">res2.pvalues[exog_index]</span><span class="s3">,</span>
                        <span class="s1">rtol=</span><span class="s4">0.1</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">5e-3</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.predict()</span><span class="s3">, </span><span class="s1">res2.predict()</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-5</span><span class="s1">)</span>
</pre>
</body>
</html>