<html>
<head>
<title>constructor.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #6a8759;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
constructor.py</font>
</center></td></tr></table>
<pre>
<span class="s0">__all__ = [</span>
    <span class="s1">'BaseConstructor'</span><span class="s2">,</span>
    <span class="s1">'SafeConstructor'</span><span class="s2">,</span>
    <span class="s1">'FullConstructor'</span><span class="s2">,</span>
    <span class="s1">'UnsafeConstructor'</span><span class="s2">,</span>
    <span class="s1">'Constructor'</span><span class="s2">,</span>
    <span class="s1">'ConstructorError'</span>
<span class="s0">]</span>

<span class="s2">from </span><span class="s0">.error </span><span class="s2">import </span><span class="s0">*</span>
<span class="s2">from </span><span class="s0">.nodes </span><span class="s2">import </span><span class="s0">*</span>

<span class="s2">import </span><span class="s0">collections.abc</span><span class="s2">, </span><span class="s0">datetime</span><span class="s2">, </span><span class="s0">base64</span><span class="s2">, </span><span class="s0">binascii</span><span class="s2">, </span><span class="s0">re</span><span class="s2">, </span><span class="s0">sys</span><span class="s2">, </span><span class="s0">types</span>

<span class="s2">class </span><span class="s0">ConstructorError(MarkedYAMLError):</span>
    <span class="s2">pass</span>

<span class="s2">class </span><span class="s0">BaseConstructor:</span>

    <span class="s0">yaml_constructors = {}</span>
    <span class="s0">yaml_multi_constructors = {}</span>

    <span class="s2">def </span><span class="s0">__init__(self):</span>
        <span class="s0">self.constructed_objects = {}</span>
        <span class="s0">self.recursive_objects = {}</span>
        <span class="s0">self.state_generators = []</span>
        <span class="s0">self.deep_construct = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s0">check_data(self):</span>
        <span class="s3"># If there are more documents available?</span>
        <span class="s2">return </span><span class="s0">self.check_node()</span>

    <span class="s2">def </span><span class="s0">check_state_key(self</span><span class="s2">, </span><span class="s0">key):</span>
        <span class="s4">&quot;&quot;&quot;Block special attributes/methods from being set in a newly created 
        object, to prevent user-controlled methods from being called during 
        deserialization&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s0">self.get_state_keys_blacklist_regexp().match(key):</span>
            <span class="s2">raise </span><span class="s0">ConstructorError(</span><span class="s2">None, None,</span>
                <span class="s1">&quot;blacklisted key '%s' in instance state found&quot; </span><span class="s0">% (key</span><span class="s2">,</span><span class="s0">)</span><span class="s2">, None</span><span class="s0">)</span>

    <span class="s2">def </span><span class="s0">get_data(self):</span>
        <span class="s3"># Construct and return the next document.</span>
        <span class="s2">if </span><span class="s0">self.check_node():</span>
            <span class="s2">return </span><span class="s0">self.construct_document(self.get_node())</span>

    <span class="s2">def </span><span class="s0">get_single_data(self):</span>
        <span class="s3"># Ensure that the stream contains a single document and construct it.</span>
        <span class="s0">node = self.get_single_node()</span>
        <span class="s2">if </span><span class="s0">node </span><span class="s2">is not None</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">self.construct_document(node)</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s0">construct_document(self</span><span class="s2">, </span><span class="s0">node):</span>
        <span class="s0">data = self.construct_object(node)</span>
        <span class="s2">while </span><span class="s0">self.state_generators:</span>
            <span class="s0">state_generators = self.state_generators</span>
            <span class="s0">self.state_generators = []</span>
            <span class="s2">for </span><span class="s0">generator </span><span class="s2">in </span><span class="s0">state_generators:</span>
                <span class="s2">for </span><span class="s0">dummy </span><span class="s2">in </span><span class="s0">generator:</span>
                    <span class="s2">pass</span>
        <span class="s0">self.constructed_objects = {}</span>
        <span class="s0">self.recursive_objects = {}</span>
        <span class="s0">self.deep_construct = </span><span class="s2">False</span>
        <span class="s2">return </span><span class="s0">data</span>

    <span class="s2">def </span><span class="s0">construct_object(self</span><span class="s2">, </span><span class="s0">node</span><span class="s2">, </span><span class="s0">deep=</span><span class="s2">False</span><span class="s0">):</span>
        <span class="s2">if </span><span class="s0">node </span><span class="s2">in </span><span class="s0">self.constructed_objects:</span>
            <span class="s2">return </span><span class="s0">self.constructed_objects[node]</span>
        <span class="s2">if </span><span class="s0">deep:</span>
            <span class="s0">old_deep = self.deep_construct</span>
            <span class="s0">self.deep_construct = </span><span class="s2">True</span>
        <span class="s2">if </span><span class="s0">node </span><span class="s2">in </span><span class="s0">self.recursive_objects:</span>
            <span class="s2">raise </span><span class="s0">ConstructorError(</span><span class="s2">None, None,</span>
                    <span class="s1">&quot;found unconstructable recursive node&quot;</span><span class="s2">, </span><span class="s0">node.start_mark)</span>
        <span class="s0">self.recursive_objects[node] = </span><span class="s2">None</span>
        <span class="s0">constructor = </span><span class="s2">None</span>
        <span class="s0">tag_suffix = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s0">node.tag </span><span class="s2">in </span><span class="s0">self.yaml_constructors:</span>
            <span class="s0">constructor = self.yaml_constructors[node.tag]</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s2">for </span><span class="s0">tag_prefix </span><span class="s2">in </span><span class="s0">self.yaml_multi_constructors:</span>
                <span class="s2">if </span><span class="s0">tag_prefix </span><span class="s2">is not None and </span><span class="s0">node.tag.startswith(tag_prefix):</span>
                    <span class="s0">tag_suffix = node.tag[len(tag_prefix):]</span>
                    <span class="s0">constructor = self.yaml_multi_constructors[tag_prefix]</span>
                    <span class="s2">break</span>
            <span class="s2">else</span><span class="s0">:</span>
                <span class="s2">if None in </span><span class="s0">self.yaml_multi_constructors:</span>
                    <span class="s0">tag_suffix = node.tag</span>
                    <span class="s0">constructor = self.yaml_multi_constructors[</span><span class="s2">None</span><span class="s0">]</span>
                <span class="s2">elif None in </span><span class="s0">self.yaml_constructors:</span>
                    <span class="s0">constructor = self.yaml_constructors[</span><span class="s2">None</span><span class="s0">]</span>
                <span class="s2">elif </span><span class="s0">isinstance(node</span><span class="s2">, </span><span class="s0">ScalarNode):</span>
                    <span class="s0">constructor = self.__class__.construct_scalar</span>
                <span class="s2">elif </span><span class="s0">isinstance(node</span><span class="s2">, </span><span class="s0">SequenceNode):</span>
                    <span class="s0">constructor = self.__class__.construct_sequence</span>
                <span class="s2">elif </span><span class="s0">isinstance(node</span><span class="s2">, </span><span class="s0">MappingNode):</span>
                    <span class="s0">constructor = self.__class__.construct_mapping</span>
        <span class="s2">if </span><span class="s0">tag_suffix </span><span class="s2">is None</span><span class="s0">:</span>
            <span class="s0">data = constructor(self</span><span class="s2">, </span><span class="s0">node)</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">data = constructor(self</span><span class="s2">, </span><span class="s0">tag_suffix</span><span class="s2">, </span><span class="s0">node)</span>
        <span class="s2">if </span><span class="s0">isinstance(data</span><span class="s2">, </span><span class="s0">types.GeneratorType):</span>
            <span class="s0">generator = data</span>
            <span class="s0">data = next(generator)</span>
            <span class="s2">if </span><span class="s0">self.deep_construct:</span>
                <span class="s2">for </span><span class="s0">dummy </span><span class="s2">in </span><span class="s0">generator:</span>
                    <span class="s2">pass</span>
            <span class="s2">else</span><span class="s0">:</span>
                <span class="s0">self.state_generators.append(generator)</span>
        <span class="s0">self.constructed_objects[node] = data</span>
        <span class="s2">del </span><span class="s0">self.recursive_objects[node]</span>
        <span class="s2">if </span><span class="s0">deep:</span>
            <span class="s0">self.deep_construct = old_deep</span>
        <span class="s2">return </span><span class="s0">data</span>

    <span class="s2">def </span><span class="s0">construct_scalar(self</span><span class="s2">, </span><span class="s0">node):</span>
        <span class="s2">if not </span><span class="s0">isinstance(node</span><span class="s2">, </span><span class="s0">ScalarNode):</span>
            <span class="s2">raise </span><span class="s0">ConstructorError(</span><span class="s2">None, None,</span>
                    <span class="s1">&quot;expected a scalar node, but found %s&quot; </span><span class="s0">% node.id</span><span class="s2">,</span>
                    <span class="s0">node.start_mark)</span>
        <span class="s2">return </span><span class="s0">node.value</span>

    <span class="s2">def </span><span class="s0">construct_sequence(self</span><span class="s2">, </span><span class="s0">node</span><span class="s2">, </span><span class="s0">deep=</span><span class="s2">False</span><span class="s0">):</span>
        <span class="s2">if not </span><span class="s0">isinstance(node</span><span class="s2">, </span><span class="s0">SequenceNode):</span>
            <span class="s2">raise </span><span class="s0">ConstructorError(</span><span class="s2">None, None,</span>
                    <span class="s1">&quot;expected a sequence node, but found %s&quot; </span><span class="s0">% node.id</span><span class="s2">,</span>
                    <span class="s0">node.start_mark)</span>
        <span class="s2">return </span><span class="s0">[self.construct_object(child</span><span class="s2">, </span><span class="s0">deep=deep)</span>
                <span class="s2">for </span><span class="s0">child </span><span class="s2">in </span><span class="s0">node.value]</span>

    <span class="s2">def </span><span class="s0">construct_mapping(self</span><span class="s2">, </span><span class="s0">node</span><span class="s2">, </span><span class="s0">deep=</span><span class="s2">False</span><span class="s0">):</span>
        <span class="s2">if not </span><span class="s0">isinstance(node</span><span class="s2">, </span><span class="s0">MappingNode):</span>
            <span class="s2">raise </span><span class="s0">ConstructorError(</span><span class="s2">None, None,</span>
                    <span class="s1">&quot;expected a mapping node, but found %s&quot; </span><span class="s0">% node.id</span><span class="s2">,</span>
                    <span class="s0">node.start_mark)</span>
        <span class="s0">mapping = {}</span>
        <span class="s2">for </span><span class="s0">key_node</span><span class="s2">, </span><span class="s0">value_node </span><span class="s2">in </span><span class="s0">node.value:</span>
            <span class="s0">key = self.construct_object(key_node</span><span class="s2">, </span><span class="s0">deep=deep)</span>
            <span class="s2">if not </span><span class="s0">isinstance(key</span><span class="s2">, </span><span class="s0">collections.abc.Hashable):</span>
                <span class="s2">raise </span><span class="s0">ConstructorError(</span><span class="s1">&quot;while constructing a mapping&quot;</span><span class="s2">, </span><span class="s0">node.start_mark</span><span class="s2">,</span>
                        <span class="s1">&quot;found unhashable key&quot;</span><span class="s2">, </span><span class="s0">key_node.start_mark)</span>
            <span class="s0">value = self.construct_object(value_node</span><span class="s2">, </span><span class="s0">deep=deep)</span>
            <span class="s0">mapping[key] = value</span>
        <span class="s2">return </span><span class="s0">mapping</span>

    <span class="s2">def </span><span class="s0">construct_pairs(self</span><span class="s2">, </span><span class="s0">node</span><span class="s2">, </span><span class="s0">deep=</span><span class="s2">False</span><span class="s0">):</span>
        <span class="s2">if not </span><span class="s0">isinstance(node</span><span class="s2">, </span><span class="s0">MappingNode):</span>
            <span class="s2">raise </span><span class="s0">ConstructorError(</span><span class="s2">None, None,</span>
                    <span class="s1">&quot;expected a mapping node, but found %s&quot; </span><span class="s0">% node.id</span><span class="s2">,</span>
                    <span class="s0">node.start_mark)</span>
        <span class="s0">pairs = []</span>
        <span class="s2">for </span><span class="s0">key_node</span><span class="s2">, </span><span class="s0">value_node </span><span class="s2">in </span><span class="s0">node.value:</span>
            <span class="s0">key = self.construct_object(key_node</span><span class="s2">, </span><span class="s0">deep=deep)</span>
            <span class="s0">value = self.construct_object(value_node</span><span class="s2">, </span><span class="s0">deep=deep)</span>
            <span class="s0">pairs.append((key</span><span class="s2">, </span><span class="s0">value))</span>
        <span class="s2">return </span><span class="s0">pairs</span>

    <span class="s0">@classmethod</span>
    <span class="s2">def </span><span class="s0">add_constructor(cls</span><span class="s2">, </span><span class="s0">tag</span><span class="s2">, </span><span class="s0">constructor):</span>
        <span class="s2">if not </span><span class="s1">'yaml_constructors' </span><span class="s2">in </span><span class="s0">cls.__dict__:</span>
            <span class="s0">cls.yaml_constructors = cls.yaml_constructors.copy()</span>
        <span class="s0">cls.yaml_constructors[tag] = constructor</span>

    <span class="s0">@classmethod</span>
    <span class="s2">def </span><span class="s0">add_multi_constructor(cls</span><span class="s2">, </span><span class="s0">tag_prefix</span><span class="s2">, </span><span class="s0">multi_constructor):</span>
        <span class="s2">if not </span><span class="s1">'yaml_multi_constructors' </span><span class="s2">in </span><span class="s0">cls.__dict__:</span>
            <span class="s0">cls.yaml_multi_constructors = cls.yaml_multi_constructors.copy()</span>
        <span class="s0">cls.yaml_multi_constructors[tag_prefix] = multi_constructor</span>

<span class="s2">class </span><span class="s0">SafeConstructor(BaseConstructor):</span>

    <span class="s2">def </span><span class="s0">construct_scalar(self</span><span class="s2">, </span><span class="s0">node):</span>
        <span class="s2">if </span><span class="s0">isinstance(node</span><span class="s2">, </span><span class="s0">MappingNode):</span>
            <span class="s2">for </span><span class="s0">key_node</span><span class="s2">, </span><span class="s0">value_node </span><span class="s2">in </span><span class="s0">node.value:</span>
                <span class="s2">if </span><span class="s0">key_node.tag == </span><span class="s1">'tag:yaml.org,2002:value'</span><span class="s0">:</span>
                    <span class="s2">return </span><span class="s0">self.construct_scalar(value_node)</span>
        <span class="s2">return </span><span class="s0">super().construct_scalar(node)</span>

    <span class="s2">def </span><span class="s0">flatten_mapping(self</span><span class="s2">, </span><span class="s0">node):</span>
        <span class="s0">merge = []</span>
        <span class="s0">index = </span><span class="s5">0</span>
        <span class="s2">while </span><span class="s0">index &lt; len(node.value):</span>
            <span class="s0">key_node</span><span class="s2">, </span><span class="s0">value_node = node.value[index]</span>
            <span class="s2">if </span><span class="s0">key_node.tag == </span><span class="s1">'tag:yaml.org,2002:merge'</span><span class="s0">:</span>
                <span class="s2">del </span><span class="s0">node.value[index]</span>
                <span class="s2">if </span><span class="s0">isinstance(value_node</span><span class="s2">, </span><span class="s0">MappingNode):</span>
                    <span class="s0">self.flatten_mapping(value_node)</span>
                    <span class="s0">merge.extend(value_node.value)</span>
                <span class="s2">elif </span><span class="s0">isinstance(value_node</span><span class="s2">, </span><span class="s0">SequenceNode):</span>
                    <span class="s0">submerge = []</span>
                    <span class="s2">for </span><span class="s0">subnode </span><span class="s2">in </span><span class="s0">value_node.value:</span>
                        <span class="s2">if not </span><span class="s0">isinstance(subnode</span><span class="s2">, </span><span class="s0">MappingNode):</span>
                            <span class="s2">raise </span><span class="s0">ConstructorError(</span><span class="s1">&quot;while constructing a mapping&quot;</span><span class="s2">,</span>
                                    <span class="s0">node.start_mark</span><span class="s2">,</span>
                                    <span class="s1">&quot;expected a mapping for merging, but found %s&quot;</span>
                                    <span class="s0">% subnode.id</span><span class="s2">, </span><span class="s0">subnode.start_mark)</span>
                        <span class="s0">self.flatten_mapping(subnode)</span>
                        <span class="s0">submerge.append(subnode.value)</span>
                    <span class="s0">submerge.reverse()</span>
                    <span class="s2">for </span><span class="s0">value </span><span class="s2">in </span><span class="s0">submerge:</span>
                        <span class="s0">merge.extend(value)</span>
                <span class="s2">else</span><span class="s0">:</span>
                    <span class="s2">raise </span><span class="s0">ConstructorError(</span><span class="s1">&quot;while constructing a mapping&quot;</span><span class="s2">, </span><span class="s0">node.start_mark</span><span class="s2">,</span>
                            <span class="s1">&quot;expected a mapping or list of mappings for merging, but found %s&quot;</span>
                            <span class="s0">% value_node.id</span><span class="s2">, </span><span class="s0">value_node.start_mark)</span>
            <span class="s2">elif </span><span class="s0">key_node.tag == </span><span class="s1">'tag:yaml.org,2002:value'</span><span class="s0">:</span>
                <span class="s0">key_node.tag = </span><span class="s1">'tag:yaml.org,2002:str'</span>
                <span class="s0">index += </span><span class="s5">1</span>
            <span class="s2">else</span><span class="s0">:</span>
                <span class="s0">index += </span><span class="s5">1</span>
        <span class="s2">if </span><span class="s0">merge:</span>
            <span class="s0">node.value = merge + node.value</span>

    <span class="s2">def </span><span class="s0">construct_mapping(self</span><span class="s2">, </span><span class="s0">node</span><span class="s2">, </span><span class="s0">deep=</span><span class="s2">False</span><span class="s0">):</span>
        <span class="s2">if </span><span class="s0">isinstance(node</span><span class="s2">, </span><span class="s0">MappingNode):</span>
            <span class="s0">self.flatten_mapping(node)</span>
        <span class="s2">return </span><span class="s0">super().construct_mapping(node</span><span class="s2">, </span><span class="s0">deep=deep)</span>

    <span class="s2">def </span><span class="s0">construct_yaml_null(self</span><span class="s2">, </span><span class="s0">node):</span>
        <span class="s0">self.construct_scalar(node)</span>
        <span class="s2">return None</span>

    <span class="s0">bool_values = {</span>
        <span class="s1">'yes'</span><span class="s0">:      </span><span class="s2">True,</span>
        <span class="s1">'no'</span><span class="s0">:       </span><span class="s2">False,</span>
        <span class="s1">'true'</span><span class="s0">:     </span><span class="s2">True,</span>
        <span class="s1">'false'</span><span class="s0">:    </span><span class="s2">False,</span>
        <span class="s1">'on'</span><span class="s0">:       </span><span class="s2">True,</span>
        <span class="s1">'off'</span><span class="s0">:      </span><span class="s2">False,</span>
    <span class="s0">}</span>

    <span class="s2">def </span><span class="s0">construct_yaml_bool(self</span><span class="s2">, </span><span class="s0">node):</span>
        <span class="s0">value = self.construct_scalar(node)</span>
        <span class="s2">return </span><span class="s0">self.bool_values[value.lower()]</span>

    <span class="s2">def </span><span class="s0">construct_yaml_int(self</span><span class="s2">, </span><span class="s0">node):</span>
        <span class="s0">value = self.construct_scalar(node)</span>
        <span class="s0">value = value.replace(</span><span class="s1">'_'</span><span class="s2">, </span><span class="s1">''</span><span class="s0">)</span>
        <span class="s0">sign = +</span><span class="s5">1</span>
        <span class="s2">if </span><span class="s0">value[</span><span class="s5">0</span><span class="s0">] == </span><span class="s1">'-'</span><span class="s0">:</span>
            <span class="s0">sign = -</span><span class="s5">1</span>
        <span class="s2">if </span><span class="s0">value[</span><span class="s5">0</span><span class="s0">] </span><span class="s2">in </span><span class="s1">'+-'</span><span class="s0">:</span>
            <span class="s0">value = value[</span><span class="s5">1</span><span class="s0">:]</span>
        <span class="s2">if </span><span class="s0">value == </span><span class="s1">'0'</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s5">0</span>
        <span class="s2">elif </span><span class="s0">value.startswith(</span><span class="s1">'0b'</span><span class="s0">):</span>
            <span class="s2">return </span><span class="s0">sign*int(value[</span><span class="s5">2</span><span class="s0">:]</span><span class="s2">, </span><span class="s5">2</span><span class="s0">)</span>
        <span class="s2">elif </span><span class="s0">value.startswith(</span><span class="s1">'0x'</span><span class="s0">):</span>
            <span class="s2">return </span><span class="s0">sign*int(value[</span><span class="s5">2</span><span class="s0">:]</span><span class="s2">, </span><span class="s5">16</span><span class="s0">)</span>
        <span class="s2">elif </span><span class="s0">value[</span><span class="s5">0</span><span class="s0">] == </span><span class="s1">'0'</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">sign*int(value</span><span class="s2">, </span><span class="s5">8</span><span class="s0">)</span>
        <span class="s2">elif </span><span class="s1">':' </span><span class="s2">in </span><span class="s0">value:</span>
            <span class="s0">digits = [int(part) </span><span class="s2">for </span><span class="s0">part </span><span class="s2">in </span><span class="s0">value.split(</span><span class="s1">':'</span><span class="s0">)]</span>
            <span class="s0">digits.reverse()</span>
            <span class="s0">base = </span><span class="s5">1</span>
            <span class="s0">value = </span><span class="s5">0</span>
            <span class="s2">for </span><span class="s0">digit </span><span class="s2">in </span><span class="s0">digits:</span>
                <span class="s0">value += digit*base</span>
                <span class="s0">base *= </span><span class="s5">60</span>
            <span class="s2">return </span><span class="s0">sign*value</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">sign*int(value)</span>

    <span class="s0">inf_value = </span><span class="s5">1e300</span>
    <span class="s2">while </span><span class="s0">inf_value != inf_value*inf_value:</span>
        <span class="s0">inf_value *= inf_value</span>
    <span class="s0">nan_value = -inf_value/inf_value   </span><span class="s3"># Trying to make a quiet NaN (like C99).</span>

    <span class="s2">def </span><span class="s0">construct_yaml_float(self</span><span class="s2">, </span><span class="s0">node):</span>
        <span class="s0">value = self.construct_scalar(node)</span>
        <span class="s0">value = value.replace(</span><span class="s1">'_'</span><span class="s2">, </span><span class="s1">''</span><span class="s0">).lower()</span>
        <span class="s0">sign = +</span><span class="s5">1</span>
        <span class="s2">if </span><span class="s0">value[</span><span class="s5">0</span><span class="s0">] == </span><span class="s1">'-'</span><span class="s0">:</span>
            <span class="s0">sign = -</span><span class="s5">1</span>
        <span class="s2">if </span><span class="s0">value[</span><span class="s5">0</span><span class="s0">] </span><span class="s2">in </span><span class="s1">'+-'</span><span class="s0">:</span>
            <span class="s0">value = value[</span><span class="s5">1</span><span class="s0">:]</span>
        <span class="s2">if </span><span class="s0">value == </span><span class="s1">'.inf'</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">sign*self.inf_value</span>
        <span class="s2">elif </span><span class="s0">value == </span><span class="s1">'.nan'</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">self.nan_value</span>
        <span class="s2">elif </span><span class="s1">':' </span><span class="s2">in </span><span class="s0">value:</span>
            <span class="s0">digits = [float(part) </span><span class="s2">for </span><span class="s0">part </span><span class="s2">in </span><span class="s0">value.split(</span><span class="s1">':'</span><span class="s0">)]</span>
            <span class="s0">digits.reverse()</span>
            <span class="s0">base = </span><span class="s5">1</span>
            <span class="s0">value = </span><span class="s5">0.0</span>
            <span class="s2">for </span><span class="s0">digit </span><span class="s2">in </span><span class="s0">digits:</span>
                <span class="s0">value += digit*base</span>
                <span class="s0">base *= </span><span class="s5">60</span>
            <span class="s2">return </span><span class="s0">sign*value</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">sign*float(value)</span>

    <span class="s2">def </span><span class="s0">construct_yaml_binary(self</span><span class="s2">, </span><span class="s0">node):</span>
        <span class="s2">try</span><span class="s0">:</span>
            <span class="s0">value = self.construct_scalar(node).encode(</span><span class="s1">'ascii'</span><span class="s0">)</span>
        <span class="s2">except </span><span class="s0">UnicodeEncodeError </span><span class="s2">as </span><span class="s0">exc:</span>
            <span class="s2">raise </span><span class="s0">ConstructorError(</span><span class="s2">None, None,</span>
                    <span class="s1">&quot;failed to convert base64 data into ascii: %s&quot; </span><span class="s0">% exc</span><span class="s2">,</span>
                    <span class="s0">node.start_mark)</span>
        <span class="s2">try</span><span class="s0">:</span>
            <span class="s2">if </span><span class="s0">hasattr(base64</span><span class="s2">, </span><span class="s1">'decodebytes'</span><span class="s0">):</span>
                <span class="s2">return </span><span class="s0">base64.decodebytes(value)</span>
            <span class="s2">else</span><span class="s0">:</span>
                <span class="s2">return </span><span class="s0">base64.decodestring(value)</span>
        <span class="s2">except </span><span class="s0">binascii.Error </span><span class="s2">as </span><span class="s0">exc:</span>
            <span class="s2">raise </span><span class="s0">ConstructorError(</span><span class="s2">None, None,</span>
                    <span class="s1">&quot;failed to decode base64 data: %s&quot; </span><span class="s0">% exc</span><span class="s2">, </span><span class="s0">node.start_mark)</span>

    <span class="s0">timestamp_regexp = re.compile(</span>
            <span class="s1">r'''^(?P&lt;year&gt;[0-9][0-9][0-9][0-9]) 
                -(?P&lt;month&gt;[0-9][0-9]?) 
                -(?P&lt;day&gt;[0-9][0-9]?) 
                (?:(?:[Tt]|[ \t]+) 
                (?P&lt;hour&gt;[0-9][0-9]?) 
                :(?P&lt;minute&gt;[0-9][0-9]) 
                :(?P&lt;second&gt;[0-9][0-9]) 
                (?:\.(?P&lt;fraction&gt;[0-9]*))? 
                (?:[ \t]*(?P&lt;tz&gt;Z|(?P&lt;tz_sign&gt;[-+])(?P&lt;tz_hour&gt;[0-9][0-9]?) 
                (?::(?P&lt;tz_minute&gt;[0-9][0-9]))?))?)?$'''</span><span class="s2">, </span><span class="s0">re.X)</span>

    <span class="s2">def </span><span class="s0">construct_yaml_timestamp(self</span><span class="s2">, </span><span class="s0">node):</span>
        <span class="s0">value = self.construct_scalar(node)</span>
        <span class="s0">match = self.timestamp_regexp.match(node.value)</span>
        <span class="s0">values = match.groupdict()</span>
        <span class="s0">year = int(values[</span><span class="s1">'year'</span><span class="s0">])</span>
        <span class="s0">month = int(values[</span><span class="s1">'month'</span><span class="s0">])</span>
        <span class="s0">day = int(values[</span><span class="s1">'day'</span><span class="s0">])</span>
        <span class="s2">if not </span><span class="s0">values[</span><span class="s1">'hour'</span><span class="s0">]:</span>
            <span class="s2">return </span><span class="s0">datetime.date(year</span><span class="s2">, </span><span class="s0">month</span><span class="s2">, </span><span class="s0">day)</span>
        <span class="s0">hour = int(values[</span><span class="s1">'hour'</span><span class="s0">])</span>
        <span class="s0">minute = int(values[</span><span class="s1">'minute'</span><span class="s0">])</span>
        <span class="s0">second = int(values[</span><span class="s1">'second'</span><span class="s0">])</span>
        <span class="s0">fraction = </span><span class="s5">0</span>
        <span class="s0">tzinfo = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s0">values[</span><span class="s1">'fraction'</span><span class="s0">]:</span>
            <span class="s0">fraction = values[</span><span class="s1">'fraction'</span><span class="s0">][:</span><span class="s5">6</span><span class="s0">]</span>
            <span class="s2">while </span><span class="s0">len(fraction) &lt; </span><span class="s5">6</span><span class="s0">:</span>
                <span class="s0">fraction += </span><span class="s1">'0'</span>
            <span class="s0">fraction = int(fraction)</span>
        <span class="s2">if </span><span class="s0">values[</span><span class="s1">'tz_sign'</span><span class="s0">]:</span>
            <span class="s0">tz_hour = int(values[</span><span class="s1">'tz_hour'</span><span class="s0">])</span>
            <span class="s0">tz_minute = int(values[</span><span class="s1">'tz_minute'</span><span class="s0">] </span><span class="s2">or </span><span class="s5">0</span><span class="s0">)</span>
            <span class="s0">delta = datetime.timedelta(hours=tz_hour</span><span class="s2">, </span><span class="s0">minutes=tz_minute)</span>
            <span class="s2">if </span><span class="s0">values[</span><span class="s1">'tz_sign'</span><span class="s0">] == </span><span class="s1">'-'</span><span class="s0">:</span>
                <span class="s0">delta = -delta</span>
            <span class="s0">tzinfo = datetime.timezone(delta)</span>
        <span class="s2">elif </span><span class="s0">values[</span><span class="s1">'tz'</span><span class="s0">]:</span>
            <span class="s0">tzinfo = datetime.timezone.utc</span>
        <span class="s2">return </span><span class="s0">datetime.datetime(year</span><span class="s2">, </span><span class="s0">month</span><span class="s2">, </span><span class="s0">day</span><span class="s2">, </span><span class="s0">hour</span><span class="s2">, </span><span class="s0">minute</span><span class="s2">, </span><span class="s0">second</span><span class="s2">, </span><span class="s0">fraction</span><span class="s2">,</span>
                                 <span class="s0">tzinfo=tzinfo)</span>

    <span class="s2">def </span><span class="s0">construct_yaml_omap(self</span><span class="s2">, </span><span class="s0">node):</span>
        <span class="s3"># Note: we do not check for duplicate keys, because it's too</span>
        <span class="s3"># CPU-expensive.</span>
        <span class="s0">omap = []</span>
        <span class="s2">yield </span><span class="s0">omap</span>
        <span class="s2">if not </span><span class="s0">isinstance(node</span><span class="s2">, </span><span class="s0">SequenceNode):</span>
            <span class="s2">raise </span><span class="s0">ConstructorError(</span><span class="s1">&quot;while constructing an ordered map&quot;</span><span class="s2">, </span><span class="s0">node.start_mark</span><span class="s2">,</span>
                    <span class="s1">&quot;expected a sequence, but found %s&quot; </span><span class="s0">% node.id</span><span class="s2">, </span><span class="s0">node.start_mark)</span>
        <span class="s2">for </span><span class="s0">subnode </span><span class="s2">in </span><span class="s0">node.value:</span>
            <span class="s2">if not </span><span class="s0">isinstance(subnode</span><span class="s2">, </span><span class="s0">MappingNode):</span>
                <span class="s2">raise </span><span class="s0">ConstructorError(</span><span class="s1">&quot;while constructing an ordered map&quot;</span><span class="s2">, </span><span class="s0">node.start_mark</span><span class="s2">,</span>
                        <span class="s1">&quot;expected a mapping of length 1, but found %s&quot; </span><span class="s0">% subnode.id</span><span class="s2">,</span>
                        <span class="s0">subnode.start_mark)</span>
            <span class="s2">if </span><span class="s0">len(subnode.value) != </span><span class="s5">1</span><span class="s0">:</span>
                <span class="s2">raise </span><span class="s0">ConstructorError(</span><span class="s1">&quot;while constructing an ordered map&quot;</span><span class="s2">, </span><span class="s0">node.start_mark</span><span class="s2">,</span>
                        <span class="s1">&quot;expected a single mapping item, but found %d items&quot; </span><span class="s0">% len(subnode.value)</span><span class="s2">,</span>
                        <span class="s0">subnode.start_mark)</span>
            <span class="s0">key_node</span><span class="s2">, </span><span class="s0">value_node = subnode.value[</span><span class="s5">0</span><span class="s0">]</span>
            <span class="s0">key = self.construct_object(key_node)</span>
            <span class="s0">value = self.construct_object(value_node)</span>
            <span class="s0">omap.append((key</span><span class="s2">, </span><span class="s0">value))</span>

    <span class="s2">def </span><span class="s0">construct_yaml_pairs(self</span><span class="s2">, </span><span class="s0">node):</span>
        <span class="s3"># Note: the same code as `construct_yaml_omap`.</span>
        <span class="s0">pairs = []</span>
        <span class="s2">yield </span><span class="s0">pairs</span>
        <span class="s2">if not </span><span class="s0">isinstance(node</span><span class="s2">, </span><span class="s0">SequenceNode):</span>
            <span class="s2">raise </span><span class="s0">ConstructorError(</span><span class="s1">&quot;while constructing pairs&quot;</span><span class="s2">, </span><span class="s0">node.start_mark</span><span class="s2">,</span>
                    <span class="s1">&quot;expected a sequence, but found %s&quot; </span><span class="s0">% node.id</span><span class="s2">, </span><span class="s0">node.start_mark)</span>
        <span class="s2">for </span><span class="s0">subnode </span><span class="s2">in </span><span class="s0">node.value:</span>
            <span class="s2">if not </span><span class="s0">isinstance(subnode</span><span class="s2">, </span><span class="s0">MappingNode):</span>
                <span class="s2">raise </span><span class="s0">ConstructorError(</span><span class="s1">&quot;while constructing pairs&quot;</span><span class="s2">, </span><span class="s0">node.start_mark</span><span class="s2">,</span>
                        <span class="s1">&quot;expected a mapping of length 1, but found %s&quot; </span><span class="s0">% subnode.id</span><span class="s2">,</span>
                        <span class="s0">subnode.start_mark)</span>
            <span class="s2">if </span><span class="s0">len(subnode.value) != </span><span class="s5">1</span><span class="s0">:</span>
                <span class="s2">raise </span><span class="s0">ConstructorError(</span><span class="s1">&quot;while constructing pairs&quot;</span><span class="s2">, </span><span class="s0">node.start_mark</span><span class="s2">,</span>
                        <span class="s1">&quot;expected a single mapping item, but found %d items&quot; </span><span class="s0">% len(subnode.value)</span><span class="s2">,</span>
                        <span class="s0">subnode.start_mark)</span>
            <span class="s0">key_node</span><span class="s2">, </span><span class="s0">value_node = subnode.value[</span><span class="s5">0</span><span class="s0">]</span>
            <span class="s0">key = self.construct_object(key_node)</span>
            <span class="s0">value = self.construct_object(value_node)</span>
            <span class="s0">pairs.append((key</span><span class="s2">, </span><span class="s0">value))</span>

    <span class="s2">def </span><span class="s0">construct_yaml_set(self</span><span class="s2">, </span><span class="s0">node):</span>
        <span class="s0">data = set()</span>
        <span class="s2">yield </span><span class="s0">data</span>
        <span class="s0">value = self.construct_mapping(node)</span>
        <span class="s0">data.update(value)</span>

    <span class="s2">def </span><span class="s0">construct_yaml_str(self</span><span class="s2">, </span><span class="s0">node):</span>
        <span class="s2">return </span><span class="s0">self.construct_scalar(node)</span>

    <span class="s2">def </span><span class="s0">construct_yaml_seq(self</span><span class="s2">, </span><span class="s0">node):</span>
        <span class="s0">data = []</span>
        <span class="s2">yield </span><span class="s0">data</span>
        <span class="s0">data.extend(self.construct_sequence(node))</span>

    <span class="s2">def </span><span class="s0">construct_yaml_map(self</span><span class="s2">, </span><span class="s0">node):</span>
        <span class="s0">data = {}</span>
        <span class="s2">yield </span><span class="s0">data</span>
        <span class="s0">value = self.construct_mapping(node)</span>
        <span class="s0">data.update(value)</span>

    <span class="s2">def </span><span class="s0">construct_yaml_object(self</span><span class="s2">, </span><span class="s0">node</span><span class="s2">, </span><span class="s0">cls):</span>
        <span class="s0">data = cls.__new__(cls)</span>
        <span class="s2">yield </span><span class="s0">data</span>
        <span class="s2">if </span><span class="s0">hasattr(data</span><span class="s2">, </span><span class="s1">'__setstate__'</span><span class="s0">):</span>
            <span class="s0">state = self.construct_mapping(node</span><span class="s2">, </span><span class="s0">deep=</span><span class="s2">True</span><span class="s0">)</span>
            <span class="s0">data.__setstate__(state)</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">state = self.construct_mapping(node)</span>
            <span class="s0">data.__dict__.update(state)</span>

    <span class="s2">def </span><span class="s0">construct_undefined(self</span><span class="s2">, </span><span class="s0">node):</span>
        <span class="s2">raise </span><span class="s0">ConstructorError(</span><span class="s2">None, None,</span>
                <span class="s1">&quot;could not determine a constructor for the tag %r&quot; </span><span class="s0">% node.tag</span><span class="s2">,</span>
                <span class="s0">node.start_mark)</span>

<span class="s0">SafeConstructor.add_constructor(</span>
        <span class="s1">'tag:yaml.org,2002:null'</span><span class="s2">,</span>
        <span class="s0">SafeConstructor.construct_yaml_null)</span>

<span class="s0">SafeConstructor.add_constructor(</span>
        <span class="s1">'tag:yaml.org,2002:bool'</span><span class="s2">,</span>
        <span class="s0">SafeConstructor.construct_yaml_bool)</span>

<span class="s0">SafeConstructor.add_constructor(</span>
        <span class="s1">'tag:yaml.org,2002:int'</span><span class="s2">,</span>
        <span class="s0">SafeConstructor.construct_yaml_int)</span>

<span class="s0">SafeConstructor.add_constructor(</span>
        <span class="s1">'tag:yaml.org,2002:float'</span><span class="s2">,</span>
        <span class="s0">SafeConstructor.construct_yaml_float)</span>

<span class="s0">SafeConstructor.add_constructor(</span>
        <span class="s1">'tag:yaml.org,2002:binary'</span><span class="s2">,</span>
        <span class="s0">SafeConstructor.construct_yaml_binary)</span>

<span class="s0">SafeConstructor.add_constructor(</span>
        <span class="s1">'tag:yaml.org,2002:timestamp'</span><span class="s2">,</span>
        <span class="s0">SafeConstructor.construct_yaml_timestamp)</span>

<span class="s0">SafeConstructor.add_constructor(</span>
        <span class="s1">'tag:yaml.org,2002:omap'</span><span class="s2">,</span>
        <span class="s0">SafeConstructor.construct_yaml_omap)</span>

<span class="s0">SafeConstructor.add_constructor(</span>
        <span class="s1">'tag:yaml.org,2002:pairs'</span><span class="s2">,</span>
        <span class="s0">SafeConstructor.construct_yaml_pairs)</span>

<span class="s0">SafeConstructor.add_constructor(</span>
        <span class="s1">'tag:yaml.org,2002:set'</span><span class="s2">,</span>
        <span class="s0">SafeConstructor.construct_yaml_set)</span>

<span class="s0">SafeConstructor.add_constructor(</span>
        <span class="s1">'tag:yaml.org,2002:str'</span><span class="s2">,</span>
        <span class="s0">SafeConstructor.construct_yaml_str)</span>

<span class="s0">SafeConstructor.add_constructor(</span>
        <span class="s1">'tag:yaml.org,2002:seq'</span><span class="s2">,</span>
        <span class="s0">SafeConstructor.construct_yaml_seq)</span>

<span class="s0">SafeConstructor.add_constructor(</span>
        <span class="s1">'tag:yaml.org,2002:map'</span><span class="s2">,</span>
        <span class="s0">SafeConstructor.construct_yaml_map)</span>

<span class="s0">SafeConstructor.add_constructor(</span><span class="s2">None,</span>
        <span class="s0">SafeConstructor.construct_undefined)</span>

<span class="s2">class </span><span class="s0">FullConstructor(SafeConstructor):</span>
    <span class="s3"># 'extend' is blacklisted because it is used by</span>
    <span class="s3"># construct_python_object_apply to add `listitems` to a newly generate</span>
    <span class="s3"># python instance</span>
    <span class="s2">def </span><span class="s0">get_state_keys_blacklist(self):</span>
        <span class="s2">return </span><span class="s0">[</span><span class="s1">'^extend$'</span><span class="s2">, </span><span class="s1">'^__.*__$'</span><span class="s0">]</span>

    <span class="s2">def </span><span class="s0">get_state_keys_blacklist_regexp(self):</span>
        <span class="s2">if not </span><span class="s0">hasattr(self</span><span class="s2">, </span><span class="s1">'state_keys_blacklist_regexp'</span><span class="s0">):</span>
            <span class="s0">self.state_keys_blacklist_regexp = re.compile(</span><span class="s1">'(' </span><span class="s0">+ </span><span class="s1">'|'</span><span class="s0">.join(self.get_state_keys_blacklist()) + </span><span class="s1">')'</span><span class="s0">)</span>
        <span class="s2">return </span><span class="s0">self.state_keys_blacklist_regexp</span>

    <span class="s2">def </span><span class="s0">construct_python_str(self</span><span class="s2">, </span><span class="s0">node):</span>
        <span class="s2">return </span><span class="s0">self.construct_scalar(node)</span>

    <span class="s2">def </span><span class="s0">construct_python_unicode(self</span><span class="s2">, </span><span class="s0">node):</span>
        <span class="s2">return </span><span class="s0">self.construct_scalar(node)</span>

    <span class="s2">def </span><span class="s0">construct_python_bytes(self</span><span class="s2">, </span><span class="s0">node):</span>
        <span class="s2">try</span><span class="s0">:</span>
            <span class="s0">value = self.construct_scalar(node).encode(</span><span class="s1">'ascii'</span><span class="s0">)</span>
        <span class="s2">except </span><span class="s0">UnicodeEncodeError </span><span class="s2">as </span><span class="s0">exc:</span>
            <span class="s2">raise </span><span class="s0">ConstructorError(</span><span class="s2">None, None,</span>
                    <span class="s1">&quot;failed to convert base64 data into ascii: %s&quot; </span><span class="s0">% exc</span><span class="s2">,</span>
                    <span class="s0">node.start_mark)</span>
        <span class="s2">try</span><span class="s0">:</span>
            <span class="s2">if </span><span class="s0">hasattr(base64</span><span class="s2">, </span><span class="s1">'decodebytes'</span><span class="s0">):</span>
                <span class="s2">return </span><span class="s0">base64.decodebytes(value)</span>
            <span class="s2">else</span><span class="s0">:</span>
                <span class="s2">return </span><span class="s0">base64.decodestring(value)</span>
        <span class="s2">except </span><span class="s0">binascii.Error </span><span class="s2">as </span><span class="s0">exc:</span>
            <span class="s2">raise </span><span class="s0">ConstructorError(</span><span class="s2">None, None,</span>
                    <span class="s1">&quot;failed to decode base64 data: %s&quot; </span><span class="s0">% exc</span><span class="s2">, </span><span class="s0">node.start_mark)</span>

    <span class="s2">def </span><span class="s0">construct_python_long(self</span><span class="s2">, </span><span class="s0">node):</span>
        <span class="s2">return </span><span class="s0">self.construct_yaml_int(node)</span>

    <span class="s2">def </span><span class="s0">construct_python_complex(self</span><span class="s2">, </span><span class="s0">node):</span>
       <span class="s2">return </span><span class="s0">complex(self.construct_scalar(node))</span>

    <span class="s2">def </span><span class="s0">construct_python_tuple(self</span><span class="s2">, </span><span class="s0">node):</span>
        <span class="s2">return </span><span class="s0">tuple(self.construct_sequence(node))</span>

    <span class="s2">def </span><span class="s0">find_python_module(self</span><span class="s2">, </span><span class="s0">name</span><span class="s2">, </span><span class="s0">mark</span><span class="s2">, </span><span class="s0">unsafe=</span><span class="s2">False</span><span class="s0">):</span>
        <span class="s2">if not </span><span class="s0">name:</span>
            <span class="s2">raise </span><span class="s0">ConstructorError(</span><span class="s1">&quot;while constructing a Python module&quot;</span><span class="s2">, </span><span class="s0">mark</span><span class="s2">,</span>
                    <span class="s1">&quot;expected non-empty name appended to the tag&quot;</span><span class="s2">, </span><span class="s0">mark)</span>
        <span class="s2">if </span><span class="s0">unsafe:</span>
            <span class="s2">try</span><span class="s0">:</span>
                <span class="s0">__import__(name)</span>
            <span class="s2">except </span><span class="s0">ImportError </span><span class="s2">as </span><span class="s0">exc:</span>
                <span class="s2">raise </span><span class="s0">ConstructorError(</span><span class="s1">&quot;while constructing a Python module&quot;</span><span class="s2">, </span><span class="s0">mark</span><span class="s2">,</span>
                        <span class="s1">&quot;cannot find module %r (%s)&quot; </span><span class="s0">% (name</span><span class="s2">, </span><span class="s0">exc)</span><span class="s2">, </span><span class="s0">mark)</span>
        <span class="s2">if </span><span class="s0">name </span><span class="s2">not in </span><span class="s0">sys.modules:</span>
            <span class="s2">raise </span><span class="s0">ConstructorError(</span><span class="s1">&quot;while constructing a Python module&quot;</span><span class="s2">, </span><span class="s0">mark</span><span class="s2">,</span>
                    <span class="s1">&quot;module %r is not imported&quot; </span><span class="s0">% name</span><span class="s2">, </span><span class="s0">mark)</span>
        <span class="s2">return </span><span class="s0">sys.modules[name]</span>

    <span class="s2">def </span><span class="s0">find_python_name(self</span><span class="s2">, </span><span class="s0">name</span><span class="s2">, </span><span class="s0">mark</span><span class="s2">, </span><span class="s0">unsafe=</span><span class="s2">False</span><span class="s0">):</span>
        <span class="s2">if not </span><span class="s0">name:</span>
            <span class="s2">raise </span><span class="s0">ConstructorError(</span><span class="s1">&quot;while constructing a Python object&quot;</span><span class="s2">, </span><span class="s0">mark</span><span class="s2">,</span>
                    <span class="s1">&quot;expected non-empty name appended to the tag&quot;</span><span class="s2">, </span><span class="s0">mark)</span>
        <span class="s2">if </span><span class="s1">'.' </span><span class="s2">in </span><span class="s0">name:</span>
            <span class="s0">module_name</span><span class="s2">, </span><span class="s0">object_name = name.rsplit(</span><span class="s1">'.'</span><span class="s2">, </span><span class="s5">1</span><span class="s0">)</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">module_name = </span><span class="s1">'builtins'</span>
            <span class="s0">object_name = name</span>
        <span class="s2">if </span><span class="s0">unsafe:</span>
            <span class="s2">try</span><span class="s0">:</span>
                <span class="s0">__import__(module_name)</span>
            <span class="s2">except </span><span class="s0">ImportError </span><span class="s2">as </span><span class="s0">exc:</span>
                <span class="s2">raise </span><span class="s0">ConstructorError(</span><span class="s1">&quot;while constructing a Python object&quot;</span><span class="s2">, </span><span class="s0">mark</span><span class="s2">,</span>
                        <span class="s1">&quot;cannot find module %r (%s)&quot; </span><span class="s0">% (module_name</span><span class="s2">, </span><span class="s0">exc)</span><span class="s2">, </span><span class="s0">mark)</span>
        <span class="s2">if </span><span class="s0">module_name </span><span class="s2">not in </span><span class="s0">sys.modules:</span>
            <span class="s2">raise </span><span class="s0">ConstructorError(</span><span class="s1">&quot;while constructing a Python object&quot;</span><span class="s2">, </span><span class="s0">mark</span><span class="s2">,</span>
                    <span class="s1">&quot;module %r is not imported&quot; </span><span class="s0">% module_name</span><span class="s2">, </span><span class="s0">mark)</span>
        <span class="s0">module = sys.modules[module_name]</span>
        <span class="s2">if not </span><span class="s0">hasattr(module</span><span class="s2">, </span><span class="s0">object_name):</span>
            <span class="s2">raise </span><span class="s0">ConstructorError(</span><span class="s1">&quot;while constructing a Python object&quot;</span><span class="s2">, </span><span class="s0">mark</span><span class="s2">,</span>
                    <span class="s1">&quot;cannot find %r in the module %r&quot;</span>
                    <span class="s0">% (object_name</span><span class="s2">, </span><span class="s0">module.__name__)</span><span class="s2">, </span><span class="s0">mark)</span>
        <span class="s2">return </span><span class="s0">getattr(module</span><span class="s2">, </span><span class="s0">object_name)</span>

    <span class="s2">def </span><span class="s0">construct_python_name(self</span><span class="s2">, </span><span class="s0">suffix</span><span class="s2">, </span><span class="s0">node):</span>
        <span class="s0">value = self.construct_scalar(node)</span>
        <span class="s2">if </span><span class="s0">value:</span>
            <span class="s2">raise </span><span class="s0">ConstructorError(</span><span class="s1">&quot;while constructing a Python name&quot;</span><span class="s2">, </span><span class="s0">node.start_mark</span><span class="s2">,</span>
                    <span class="s1">&quot;expected the empty value, but found %r&quot; </span><span class="s0">% value</span><span class="s2">, </span><span class="s0">node.start_mark)</span>
        <span class="s2">return </span><span class="s0">self.find_python_name(suffix</span><span class="s2">, </span><span class="s0">node.start_mark)</span>

    <span class="s2">def </span><span class="s0">construct_python_module(self</span><span class="s2">, </span><span class="s0">suffix</span><span class="s2">, </span><span class="s0">node):</span>
        <span class="s0">value = self.construct_scalar(node)</span>
        <span class="s2">if </span><span class="s0">value:</span>
            <span class="s2">raise </span><span class="s0">ConstructorError(</span><span class="s1">&quot;while constructing a Python module&quot;</span><span class="s2">, </span><span class="s0">node.start_mark</span><span class="s2">,</span>
                    <span class="s1">&quot;expected the empty value, but found %r&quot; </span><span class="s0">% value</span><span class="s2">, </span><span class="s0">node.start_mark)</span>
        <span class="s2">return </span><span class="s0">self.find_python_module(suffix</span><span class="s2">, </span><span class="s0">node.start_mark)</span>

    <span class="s2">def </span><span class="s0">make_python_instance(self</span><span class="s2">, </span><span class="s0">suffix</span><span class="s2">, </span><span class="s0">node</span><span class="s2">,</span>
            <span class="s0">args=</span><span class="s2">None, </span><span class="s0">kwds=</span><span class="s2">None, </span><span class="s0">newobj=</span><span class="s2">False, </span><span class="s0">unsafe=</span><span class="s2">False</span><span class="s0">):</span>
        <span class="s2">if not </span><span class="s0">args:</span>
            <span class="s0">args = []</span>
        <span class="s2">if not </span><span class="s0">kwds:</span>
            <span class="s0">kwds = {}</span>
        <span class="s0">cls = self.find_python_name(suffix</span><span class="s2">, </span><span class="s0">node.start_mark)</span>
        <span class="s2">if not </span><span class="s0">(unsafe </span><span class="s2">or </span><span class="s0">isinstance(cls</span><span class="s2">, </span><span class="s0">type)):</span>
            <span class="s2">raise </span><span class="s0">ConstructorError(</span><span class="s1">&quot;while constructing a Python instance&quot;</span><span class="s2">, </span><span class="s0">node.start_mark</span><span class="s2">,</span>
                    <span class="s1">&quot;expected a class, but found %r&quot; </span><span class="s0">% type(cls)</span><span class="s2">,</span>
                    <span class="s0">node.start_mark)</span>
        <span class="s2">if </span><span class="s0">newobj </span><span class="s2">and </span><span class="s0">isinstance(cls</span><span class="s2">, </span><span class="s0">type):</span>
            <span class="s2">return </span><span class="s0">cls.__new__(cls</span><span class="s2">, </span><span class="s0">*args</span><span class="s2">, </span><span class="s0">**kwds)</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">cls(*args</span><span class="s2">, </span><span class="s0">**kwds)</span>

    <span class="s2">def </span><span class="s0">set_python_instance_state(self</span><span class="s2">, </span><span class="s0">instance</span><span class="s2">, </span><span class="s0">state</span><span class="s2">, </span><span class="s0">unsafe=</span><span class="s2">False</span><span class="s0">):</span>
        <span class="s2">if </span><span class="s0">hasattr(instance</span><span class="s2">, </span><span class="s1">'__setstate__'</span><span class="s0">):</span>
            <span class="s0">instance.__setstate__(state)</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">slotstate = {}</span>
            <span class="s2">if </span><span class="s0">isinstance(state</span><span class="s2">, </span><span class="s0">tuple) </span><span class="s2">and </span><span class="s0">len(state) == </span><span class="s5">2</span><span class="s0">:</span>
                <span class="s0">state</span><span class="s2">, </span><span class="s0">slotstate = state</span>
            <span class="s2">if </span><span class="s0">hasattr(instance</span><span class="s2">, </span><span class="s1">'__dict__'</span><span class="s0">):</span>
                <span class="s2">if not </span><span class="s0">unsafe </span><span class="s2">and </span><span class="s0">state:</span>
                    <span class="s2">for </span><span class="s0">key </span><span class="s2">in </span><span class="s0">state.keys():</span>
                        <span class="s0">self.check_state_key(key)</span>
                <span class="s0">instance.__dict__.update(state)</span>
            <span class="s2">elif </span><span class="s0">state:</span>
                <span class="s0">slotstate.update(state)</span>
            <span class="s2">for </span><span class="s0">key</span><span class="s2">, </span><span class="s0">value </span><span class="s2">in </span><span class="s0">slotstate.items():</span>
                <span class="s2">if not </span><span class="s0">unsafe:</span>
                    <span class="s0">self.check_state_key(key)</span>
                <span class="s0">setattr(instance</span><span class="s2">, </span><span class="s0">key</span><span class="s2">, </span><span class="s0">value)</span>

    <span class="s2">def </span><span class="s0">construct_python_object(self</span><span class="s2">, </span><span class="s0">suffix</span><span class="s2">, </span><span class="s0">node):</span>
        <span class="s3"># Format:</span>
        <span class="s3">#   !!python/object:module.name { ... state ... }</span>
        <span class="s0">instance = self.make_python_instance(suffix</span><span class="s2">, </span><span class="s0">node</span><span class="s2">, </span><span class="s0">newobj=</span><span class="s2">True</span><span class="s0">)</span>
        <span class="s2">yield </span><span class="s0">instance</span>
        <span class="s0">deep = hasattr(instance</span><span class="s2">, </span><span class="s1">'__setstate__'</span><span class="s0">)</span>
        <span class="s0">state = self.construct_mapping(node</span><span class="s2">, </span><span class="s0">deep=deep)</span>
        <span class="s0">self.set_python_instance_state(instance</span><span class="s2">, </span><span class="s0">state)</span>

    <span class="s2">def </span><span class="s0">construct_python_object_apply(self</span><span class="s2">, </span><span class="s0">suffix</span><span class="s2">, </span><span class="s0">node</span><span class="s2">, </span><span class="s0">newobj=</span><span class="s2">False</span><span class="s0">):</span>
        <span class="s3"># Format:</span>
        <span class="s3">#   !!python/object/apply       # (or !!python/object/new)</span>
        <span class="s3">#   args: [ ... arguments ... ]</span>
        <span class="s3">#   kwds: { ... keywords ... }</span>
        <span class="s3">#   state: ... state ...</span>
        <span class="s3">#   listitems: [ ... listitems ... ]</span>
        <span class="s3">#   dictitems: { ... dictitems ... }</span>
        <span class="s3"># or short format:</span>
        <span class="s3">#   !!python/object/apply [ ... arguments ... ]</span>
        <span class="s3"># The difference between !!python/object/apply and !!python/object/new</span>
        <span class="s3"># is how an object is created, check make_python_instance for details.</span>
        <span class="s2">if </span><span class="s0">isinstance(node</span><span class="s2">, </span><span class="s0">SequenceNode):</span>
            <span class="s0">args = self.construct_sequence(node</span><span class="s2">, </span><span class="s0">deep=</span><span class="s2">True</span><span class="s0">)</span>
            <span class="s0">kwds = {}</span>
            <span class="s0">state = {}</span>
            <span class="s0">listitems = []</span>
            <span class="s0">dictitems = {}</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">value = self.construct_mapping(node</span><span class="s2">, </span><span class="s0">deep=</span><span class="s2">True</span><span class="s0">)</span>
            <span class="s0">args = value.get(</span><span class="s1">'args'</span><span class="s2">, </span><span class="s0">[])</span>
            <span class="s0">kwds = value.get(</span><span class="s1">'kwds'</span><span class="s2">, </span><span class="s0">{})</span>
            <span class="s0">state = value.get(</span><span class="s1">'state'</span><span class="s2">, </span><span class="s0">{})</span>
            <span class="s0">listitems = value.get(</span><span class="s1">'listitems'</span><span class="s2">, </span><span class="s0">[])</span>
            <span class="s0">dictitems = value.get(</span><span class="s1">'dictitems'</span><span class="s2">, </span><span class="s0">{})</span>
        <span class="s0">instance = self.make_python_instance(suffix</span><span class="s2">, </span><span class="s0">node</span><span class="s2">, </span><span class="s0">args</span><span class="s2">, </span><span class="s0">kwds</span><span class="s2">, </span><span class="s0">newobj)</span>
        <span class="s2">if </span><span class="s0">state:</span>
            <span class="s0">self.set_python_instance_state(instance</span><span class="s2">, </span><span class="s0">state)</span>
        <span class="s2">if </span><span class="s0">listitems:</span>
            <span class="s0">instance.extend(listitems)</span>
        <span class="s2">if </span><span class="s0">dictitems:</span>
            <span class="s2">for </span><span class="s0">key </span><span class="s2">in </span><span class="s0">dictitems:</span>
                <span class="s0">instance[key] = dictitems[key]</span>
        <span class="s2">return </span><span class="s0">instance</span>

    <span class="s2">def </span><span class="s0">construct_python_object_new(self</span><span class="s2">, </span><span class="s0">suffix</span><span class="s2">, </span><span class="s0">node):</span>
        <span class="s2">return </span><span class="s0">self.construct_python_object_apply(suffix</span><span class="s2">, </span><span class="s0">node</span><span class="s2">, </span><span class="s0">newobj=</span><span class="s2">True</span><span class="s0">)</span>

<span class="s0">FullConstructor.add_constructor(</span>
    <span class="s1">'tag:yaml.org,2002:python/none'</span><span class="s2">,</span>
    <span class="s0">FullConstructor.construct_yaml_null)</span>

<span class="s0">FullConstructor.add_constructor(</span>
    <span class="s1">'tag:yaml.org,2002:python/bool'</span><span class="s2">,</span>
    <span class="s0">FullConstructor.construct_yaml_bool)</span>

<span class="s0">FullConstructor.add_constructor(</span>
    <span class="s1">'tag:yaml.org,2002:python/str'</span><span class="s2">,</span>
    <span class="s0">FullConstructor.construct_python_str)</span>

<span class="s0">FullConstructor.add_constructor(</span>
    <span class="s1">'tag:yaml.org,2002:python/unicode'</span><span class="s2">,</span>
    <span class="s0">FullConstructor.construct_python_unicode)</span>

<span class="s0">FullConstructor.add_constructor(</span>
    <span class="s1">'tag:yaml.org,2002:python/bytes'</span><span class="s2">,</span>
    <span class="s0">FullConstructor.construct_python_bytes)</span>

<span class="s0">FullConstructor.add_constructor(</span>
    <span class="s1">'tag:yaml.org,2002:python/int'</span><span class="s2">,</span>
    <span class="s0">FullConstructor.construct_yaml_int)</span>

<span class="s0">FullConstructor.add_constructor(</span>
    <span class="s1">'tag:yaml.org,2002:python/long'</span><span class="s2">,</span>
    <span class="s0">FullConstructor.construct_python_long)</span>

<span class="s0">FullConstructor.add_constructor(</span>
    <span class="s1">'tag:yaml.org,2002:python/float'</span><span class="s2">,</span>
    <span class="s0">FullConstructor.construct_yaml_float)</span>

<span class="s0">FullConstructor.add_constructor(</span>
    <span class="s1">'tag:yaml.org,2002:python/complex'</span><span class="s2">,</span>
    <span class="s0">FullConstructor.construct_python_complex)</span>

<span class="s0">FullConstructor.add_constructor(</span>
    <span class="s1">'tag:yaml.org,2002:python/list'</span><span class="s2">,</span>
    <span class="s0">FullConstructor.construct_yaml_seq)</span>

<span class="s0">FullConstructor.add_constructor(</span>
    <span class="s1">'tag:yaml.org,2002:python/tuple'</span><span class="s2">,</span>
    <span class="s0">FullConstructor.construct_python_tuple)</span>

<span class="s0">FullConstructor.add_constructor(</span>
    <span class="s1">'tag:yaml.org,2002:python/dict'</span><span class="s2">,</span>
    <span class="s0">FullConstructor.construct_yaml_map)</span>

<span class="s0">FullConstructor.add_multi_constructor(</span>
    <span class="s1">'tag:yaml.org,2002:python/name:'</span><span class="s2">,</span>
    <span class="s0">FullConstructor.construct_python_name)</span>

<span class="s2">class </span><span class="s0">UnsafeConstructor(FullConstructor):</span>

    <span class="s2">def </span><span class="s0">find_python_module(self</span><span class="s2">, </span><span class="s0">name</span><span class="s2">, </span><span class="s0">mark):</span>
        <span class="s2">return </span><span class="s0">super(UnsafeConstructor</span><span class="s2">, </span><span class="s0">self).find_python_module(name</span><span class="s2">, </span><span class="s0">mark</span><span class="s2">, </span><span class="s0">unsafe=</span><span class="s2">True</span><span class="s0">)</span>

    <span class="s2">def </span><span class="s0">find_python_name(self</span><span class="s2">, </span><span class="s0">name</span><span class="s2">, </span><span class="s0">mark):</span>
        <span class="s2">return </span><span class="s0">super(UnsafeConstructor</span><span class="s2">, </span><span class="s0">self).find_python_name(name</span><span class="s2">, </span><span class="s0">mark</span><span class="s2">, </span><span class="s0">unsafe=</span><span class="s2">True</span><span class="s0">)</span>

    <span class="s2">def </span><span class="s0">make_python_instance(self</span><span class="s2">, </span><span class="s0">suffix</span><span class="s2">, </span><span class="s0">node</span><span class="s2">, </span><span class="s0">args=</span><span class="s2">None, </span><span class="s0">kwds=</span><span class="s2">None, </span><span class="s0">newobj=</span><span class="s2">False</span><span class="s0">):</span>
        <span class="s2">return </span><span class="s0">super(UnsafeConstructor</span><span class="s2">, </span><span class="s0">self).make_python_instance(</span>
            <span class="s0">suffix</span><span class="s2">, </span><span class="s0">node</span><span class="s2">, </span><span class="s0">args</span><span class="s2">, </span><span class="s0">kwds</span><span class="s2">, </span><span class="s0">newobj</span><span class="s2">, </span><span class="s0">unsafe=</span><span class="s2">True</span><span class="s0">)</span>

    <span class="s2">def </span><span class="s0">set_python_instance_state(self</span><span class="s2">, </span><span class="s0">instance</span><span class="s2">, </span><span class="s0">state):</span>
        <span class="s2">return </span><span class="s0">super(UnsafeConstructor</span><span class="s2">, </span><span class="s0">self).set_python_instance_state(</span>
            <span class="s0">instance</span><span class="s2">, </span><span class="s0">state</span><span class="s2">, </span><span class="s0">unsafe=</span><span class="s2">True</span><span class="s0">)</span>

<span class="s0">UnsafeConstructor.add_multi_constructor(</span>
    <span class="s1">'tag:yaml.org,2002:python/module:'</span><span class="s2">,</span>
    <span class="s0">UnsafeConstructor.construct_python_module)</span>

<span class="s0">UnsafeConstructor.add_multi_constructor(</span>
    <span class="s1">'tag:yaml.org,2002:python/object:'</span><span class="s2">,</span>
    <span class="s0">UnsafeConstructor.construct_python_object)</span>

<span class="s0">UnsafeConstructor.add_multi_constructor(</span>
    <span class="s1">'tag:yaml.org,2002:python/object/new:'</span><span class="s2">,</span>
    <span class="s0">UnsafeConstructor.construct_python_object_new)</span>

<span class="s0">UnsafeConstructor.add_multi_constructor(</span>
    <span class="s1">'tag:yaml.org,2002:python/object/apply:'</span><span class="s2">,</span>
    <span class="s0">UnsafeConstructor.construct_python_object_apply)</span>

<span class="s3"># Constructor is same as UnsafeConstructor. Need to leave this in place in case</span>
<span class="s3"># people have extended it directly.</span>
<span class="s2">class </span><span class="s0">Constructor(UnsafeConstructor):</span>
    <span class="s2">pass</span>
</pre>
</body>
</html>