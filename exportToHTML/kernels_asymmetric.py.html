<html>
<head>
<title>kernels_asymmetric.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
kernels_asymmetric.py</font>
</center></td></tr></table>
<pre><span class="s0"># -*- coding: utf-8 -*-</span>
<span class="s2">&quot;&quot;&quot;Asymmetric kernels for R+ and unit interval 
 
References 
---------- 
 
.. [1] Bouezmarni, Taoufik, and Olivier Scaillet. 2005. “Consistency of 
   Asymmetric Kernel Density Estimators and Smoothed Histograms with 
   Application to Income Data.” Econometric Theory 21 (2): 390–412. 
 
.. [2] Chen, Song Xi. 1999. “Beta Kernel Estimators for Density Functions.” 
   Computational Statistics &amp; Data Analysis 31 (2): 131–45. 
   https://doi.org/10.1016/S0167-9473(99)00010-9. 
 
.. [3] Chen, Song Xi. 2000. “Probability Density Function Estimation Using 
   Gamma Kernels.” 
   Annals of the Institute of Statistical Mathematics 52 (3): 471–80. 
   https://doi.org/10.1023/A:1004165218295. 
 
.. [4] Jin, Xiaodong, and Janusz Kawczak. 2003. “Birnbaum-Saunders and 
   Lognormal Kernel Estimators for Modelling Durations in High Frequency 
   Financial Data.” Annals of Economics and Finance 4: 103–24. 
 
.. [5] Micheaux, Pierre Lafaye de, and Frédéric Ouimet. 2020. “A Study of Seven 
   Asymmetric Kernels for the Estimation of Cumulative Distribution Functions,” 
   November. https://arxiv.org/abs/2011.14893v1. 
 
.. [6] Mombeni, Habib Allah, B Masouri, and Mohammad Reza Akhoond. 2019. 
   “Asymmetric Kernels for Boundary Modification in Distribution Function 
   Estimation.” REVSTAT, 1–27. 
 
.. [7] Scaillet, O. 2004. “Density Estimation Using Inverse and Reciprocal 
   Inverse Gaussian Kernels.” 
   Journal of Nonparametric Statistics 16 (1–2): 217–26. 
   https://doi.org/10.1080/10485250310001624819. 
 
 
Created on Mon Mar  8 11:12:24 2021 
 
Author: Josef Perktold 
License: BSD-3 
 
&quot;&quot;&quot;</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">scipy </span><span class="s3">import </span><span class="s1">special</span><span class="s3">, </span><span class="s1">stats</span>

<span class="s1">doc_params = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">Parameters 
    ---------- 
    x : array_like, float 
        Points for which density is evaluated. ``x`` can be scalar or 1-dim. 
    sample : ndarray, 1-d 
        Sample from which kde is computed. 
    bw : float 
        Bandwidth parameter, there is currently no default value for it. 
 
    Returns 
    ------- 
    Components for kernel estimation&quot;&quot;&quot;</span>


<span class="s3">def </span><span class="s1">pdf_kernel_asym(x</span><span class="s3">, </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">bw</span><span class="s3">, </span><span class="s1">kernel_type</span><span class="s3">, </span><span class="s1">weights=</span><span class="s3">None, </span><span class="s1">batch_size=</span><span class="s5">10</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Density estimate based on asymmetric kernel. 
 
    Parameters 
    ---------- 
    x : array_like, float 
        Points for which density is evaluated. ``x`` can be scalar or 1-dim. 
    sample : ndarray, 1-d 
        Sample from which kernel estimate is computed. 
    bw : float 
        Bandwidth parameter, there is currently no default value for it. 
    kernel_type : str or callable 
        Kernel name or kernel function. 
        Currently supported kernel names are &quot;beta&quot;, &quot;beta2&quot;, &quot;gamma&quot;, 
        &quot;gamma2&quot;, &quot;bs&quot;, &quot;invgamma&quot;, &quot;invgauss&quot;, &quot;lognorm&quot;, &quot;recipinvgauss&quot; and 
        &quot;weibull&quot;. 
    weights : None or ndarray 
        If weights is not None, then kernel for sample points are weighted 
        by it. No weights corresponds to uniform weighting of each component 
        with 1 / nobs, where nobs is the size of `sample`. 
    batch_size : float 
        If x is an 1-dim array, then points can be evaluated in vectorized 
        form. To limit the amount of memory, a loop can work in batches. 
        The number of batches is determined so that the intermediate array 
        sizes are limited by 
 
        ``np.size(batch) * len(sample) &lt; batch_size * 1000``. 
 
        Default is to have at most 10000 elements in intermediate arrays. 
 
    Returns 
    ------- 
    pdf : float or ndarray 
        Estimate of pdf at points x. ``pdf`` has the same size or shape as x. 
    &quot;&quot;&quot;</span>

    <span class="s3">if </span><span class="s1">callable(kernel_type):</span>
        <span class="s1">kfunc = kernel_type</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">kfunc = kernel_dict_pdf[kernel_type]</span>

    <span class="s1">batch_size = batch_size * </span><span class="s5">1000</span>

    <span class="s3">if </span><span class="s1">np.size(x) * len(sample) &lt; batch_size:</span>
        <span class="s0"># no batch-loop</span>
        <span class="s3">if </span><span class="s1">np.size(x) &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">x = np.asarray(x)[:</span><span class="s3">, None</span><span class="s1">]</span>

        <span class="s1">pdfi = kfunc(x</span><span class="s3">, </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">bw)</span>
        <span class="s3">if </span><span class="s1">weights </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">pdf = pdfi.mean(-</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">pdf = pdfi @ weights</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s0"># batch, designed for 1-d x</span>
        <span class="s3">if </span><span class="s1">weights </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">weights = np.ones(len(sample)) / len(sample)</span>

        <span class="s1">k = batch_size // len(sample)</span>
        <span class="s1">n = len(x) // k</span>
        <span class="s1">x_split = np.array_split(x</span><span class="s3">, </span><span class="s1">n)</span>
        <span class="s1">pdf = np.concatenate([(kfunc(xi[:</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">, </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">bw) @ weights)</span>
                              <span class="s3">for </span><span class="s1">xi </span><span class="s3">in </span><span class="s1">x_split])</span>

    <span class="s3">return </span><span class="s1">pdf</span>


<span class="s3">def </span><span class="s1">cdf_kernel_asym(x</span><span class="s3">, </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">bw</span><span class="s3">, </span><span class="s1">kernel_type</span><span class="s3">, </span><span class="s1">weights=</span><span class="s3">None, </span><span class="s1">batch_size=</span><span class="s5">10</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Estimate of cumulative distribution based on asymmetric kernel. 
 
    Parameters 
    ---------- 
    x : array_like, float 
        Points for which density is evaluated. ``x`` can be scalar or 1-dim. 
    sample : ndarray, 1-d 
        Sample from which kernel estimate is computed. 
    bw : float 
        Bandwidth parameter, there is currently no default value for it. 
    kernel_type : str or callable 
        Kernel name or kernel function. 
        Currently supported kernel names are &quot;beta&quot;, &quot;beta2&quot;, &quot;gamma&quot;, 
        &quot;gamma2&quot;, &quot;bs&quot;, &quot;invgamma&quot;, &quot;invgauss&quot;, &quot;lognorm&quot;, &quot;recipinvgauss&quot; and 
        &quot;weibull&quot;. 
    weights : None or ndarray 
        If weights is not None, then kernel for sample points are weighted 
        by it. No weights corresponds to uniform weighting of each component 
        with 1 / nobs, where nobs is the size of `sample`. 
    batch_size : float 
        If x is an 1-dim array, then points can be evaluated in vectorized 
        form. To limit the amount of memory, a loop can work in batches. 
        The number of batches is determined so that the intermediate array 
        sizes are limited by 
 
        ``np.size(batch) * len(sample) &lt; batch_size * 1000``. 
 
        Default is to have at most 10000 elements in intermediate arrays. 
 
    Returns 
    ------- 
    cdf : float or ndarray 
        Estimate of cdf at points x. ``cdf`` has the same size or shape as x. 
    &quot;&quot;&quot;</span>

    <span class="s3">if </span><span class="s1">callable(kernel_type):</span>
        <span class="s1">kfunc = kernel_type</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">kfunc = kernel_dict_cdf[kernel_type]</span>

    <span class="s1">batch_size = batch_size * </span><span class="s5">1000</span>

    <span class="s3">if </span><span class="s1">np.size(x) * len(sample) &lt; batch_size:</span>
        <span class="s0"># no batch-loop</span>
        <span class="s3">if </span><span class="s1">np.size(x) &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">x = np.asarray(x)[:</span><span class="s3">, None</span><span class="s1">]</span>

        <span class="s1">cdfi = kfunc(x</span><span class="s3">, </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">bw)</span>
        <span class="s3">if </span><span class="s1">weights </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">cdf = cdfi.mean(-</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">cdf = cdfi @ weights</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s0"># batch, designed for 1-d x</span>
        <span class="s3">if </span><span class="s1">weights </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">weights = np.ones(len(sample)) / len(sample)</span>

        <span class="s1">k = batch_size // len(sample)</span>
        <span class="s1">n = len(x) // k</span>
        <span class="s1">x_split = np.array_split(x</span><span class="s3">, </span><span class="s1">n)</span>
        <span class="s1">cdf = np.concatenate([(kfunc(xi[:</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">, </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">bw) @ weights)</span>
                              <span class="s3">for </span><span class="s1">xi </span><span class="s3">in </span><span class="s1">x_split])</span>

    <span class="s3">return </span><span class="s1">cdf</span>


<span class="s3">def </span><span class="s1">kernel_pdf_beta(x</span><span class="s3">, </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">bw):</span>
    <span class="s0"># Beta kernel for density, pdf, estimation</span>
    <span class="s3">return </span><span class="s1">stats.beta.pdf(sample</span><span class="s3">, </span><span class="s1">x / bw + </span><span class="s5">1</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1 </span><span class="s1">- x) / bw + </span><span class="s5">1</span><span class="s1">)</span>


<span class="s1">kernel_pdf_beta.__doc__ = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">Beta kernel for density, pdf, estimation. 
 
    {doc_params} 
 
    References 
    ---------- 
    .. [1] Bouezmarni, Taoufik, and Olivier Scaillet. 2005. “Consistency of 
       Asymmetric Kernel Density Estimators and Smoothed Histograms with 
       Application to Income Data.” Econometric Theory 21 (2): 390–412. 
 
    .. [2] Chen, Song Xi. 1999. “Beta Kernel Estimators for Density Functions.” 
       Computational Statistics &amp; Data Analysis 31 (2): 131–45. 
       https://doi.org/10.1016/S0167-9473(99)00010-9. 
    &quot;&quot;&quot;</span><span class="s1">.format(doc_params=doc_params)</span>


<span class="s3">def </span><span class="s1">kernel_cdf_beta(x</span><span class="s3">, </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">bw):</span>
    <span class="s0"># Beta kernel for cumulative distribution, cdf, estimation</span>
    <span class="s3">return </span><span class="s1">stats.beta.sf(sample</span><span class="s3">, </span><span class="s1">x / bw + </span><span class="s5">1</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1 </span><span class="s1">- x) / bw + </span><span class="s5">1</span><span class="s1">)</span>


<span class="s1">kernel_cdf_beta.__doc__ = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">Beta kernel for cumulative distribution, cdf, estimation. 
 
    {doc_params} 
 
    References 
    ---------- 
    .. [1] Bouezmarni, Taoufik, and Olivier Scaillet. 2005. “Consistency of 
       Asymmetric Kernel Density Estimators and Smoothed Histograms with 
       Application to Income Data.” Econometric Theory 21 (2): 390–412. 
 
    .. [2] Chen, Song Xi. 1999. “Beta Kernel Estimators for Density Functions.” 
       Computational Statistics &amp; Data Analysis 31 (2): 131–45. 
       https://doi.org/10.1016/S0167-9473(99)00010-9. 
    &quot;&quot;&quot;</span><span class="s1">.format(doc_params=doc_params)</span>


<span class="s3">def </span><span class="s1">kernel_pdf_beta2(x</span><span class="s3">, </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">bw):</span>
    <span class="s0"># Beta kernel for density, pdf, estimation with boundary corrections</span>

    <span class="s0"># a = 2 * bw**2 + 2.5 -</span>
    <span class="s0">#     np.sqrt(4 * bw**4 + 6 * bw**2 + 2.25 - x**2 - x / bw)</span>
    <span class="s0"># terms a1 and a2 are independent of x</span>
    <span class="s1">a1 = </span><span class="s5">2 </span><span class="s1">* bw**</span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">2.5</span>
    <span class="s1">a2 = </span><span class="s5">4 </span><span class="s1">* bw**</span><span class="s5">4 </span><span class="s1">+ </span><span class="s5">6 </span><span class="s1">* bw**</span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">2.25</span>

    <span class="s3">if </span><span class="s1">np.size(x) == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s0"># without vectorizing:</span>
        <span class="s3">if </span><span class="s1">x &lt; </span><span class="s5">2 </span><span class="s1">* bw:</span>
            <span class="s1">a = a1 - np.sqrt(a2 - x**</span><span class="s5">2 </span><span class="s1">- x / bw)</span>
            <span class="s1">pdf = stats.beta.pdf(sample</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1 </span><span class="s1">- x) / bw)</span>
        <span class="s3">elif </span><span class="s1">x &gt; (</span><span class="s5">1 </span><span class="s1">- </span><span class="s5">2 </span><span class="s1">* bw):</span>
            <span class="s1">x_ = </span><span class="s5">1 </span><span class="s1">- x</span>
            <span class="s1">a = a1 - np.sqrt(a2 - x_**</span><span class="s5">2 </span><span class="s1">- x_ / bw)</span>
            <span class="s1">pdf = stats.beta.pdf(sample</span><span class="s3">, </span><span class="s1">x / bw</span><span class="s3">, </span><span class="s1">a)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">pdf = stats.beta.pdf(sample</span><span class="s3">, </span><span class="s1">x / bw</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1 </span><span class="s1">- x) / bw)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">alpha = x / bw</span>
        <span class="s1">beta = (</span><span class="s5">1 </span><span class="s1">- x) / bw</span>

        <span class="s1">mask_low = x &lt; </span><span class="s5">2 </span><span class="s1">* bw</span>
        <span class="s1">x_ = x[mask_low]</span>
        <span class="s1">alpha[mask_low] = a1 - np.sqrt(a2 - x_**</span><span class="s5">2 </span><span class="s1">- x_ / bw)</span>

        <span class="s1">mask_upp = x &gt; (</span><span class="s5">1 </span><span class="s1">- </span><span class="s5">2 </span><span class="s1">* bw)</span>
        <span class="s1">x_ = </span><span class="s5">1 </span><span class="s1">- x[mask_upp]</span>
        <span class="s1">beta[mask_upp] = a1 - np.sqrt(a2 - x_**</span><span class="s5">2 </span><span class="s1">- x_ / bw)</span>

        <span class="s1">pdf = stats.beta.pdf(sample</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">beta)</span>

    <span class="s3">return </span><span class="s1">pdf</span>


<span class="s1">kernel_pdf_beta2.__doc__ = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">Beta kernel for density, pdf, estimation with boundary corrections. 
 
    {doc_params} 
 
    References 
    ---------- 
    .. [1] Bouezmarni, Taoufik, and Olivier Scaillet. 2005. “Consistency of 
       Asymmetric Kernel Density Estimators and Smoothed Histograms with 
       Application to Income Data.” Econometric Theory 21 (2): 390–412. 
 
    .. [2] Chen, Song Xi. 1999. “Beta Kernel Estimators for Density Functions.” 
       Computational Statistics &amp; Data Analysis 31 (2): 131–45. 
       https://doi.org/10.1016/S0167-9473(99)00010-9. 
    &quot;&quot;&quot;</span><span class="s1">.format(doc_params=doc_params)</span>


<span class="s3">def </span><span class="s1">kernel_cdf_beta2(x</span><span class="s3">, </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">bw):</span>
    <span class="s0"># Beta kernel for cdf estimation with boundary correction</span>

    <span class="s0"># a = 2 * bw**2 + 2.5 -</span>
    <span class="s0">#     np.sqrt(4 * bw**4 + 6 * bw**2 + 2.25 - x**2 - x / bw)</span>
    <span class="s0"># terms a1 and a2 are independent of x</span>
    <span class="s1">a1 = </span><span class="s5">2 </span><span class="s1">* bw**</span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">2.5</span>
    <span class="s1">a2 = </span><span class="s5">4 </span><span class="s1">* bw**</span><span class="s5">4 </span><span class="s1">+ </span><span class="s5">6 </span><span class="s1">* bw**</span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">2.25</span>

    <span class="s3">if </span><span class="s1">np.size(x) == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s0"># without vectorizing:</span>
        <span class="s3">if </span><span class="s1">x &lt; </span><span class="s5">2 </span><span class="s1">* bw:</span>
            <span class="s1">a = a1 - np.sqrt(a2 - x**</span><span class="s5">2 </span><span class="s1">- x / bw)</span>
            <span class="s1">pdf = stats.beta.sf(sample</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1 </span><span class="s1">- x) / bw)</span>
        <span class="s3">elif </span><span class="s1">x &gt; (</span><span class="s5">1 </span><span class="s1">- </span><span class="s5">2 </span><span class="s1">* bw):</span>
            <span class="s1">x_ = </span><span class="s5">1 </span><span class="s1">- x</span>
            <span class="s1">a = a1 - np.sqrt(a2 - x_**</span><span class="s5">2 </span><span class="s1">- x_ / bw)</span>
            <span class="s1">pdf = stats.beta.sf(sample</span><span class="s3">, </span><span class="s1">x / bw</span><span class="s3">, </span><span class="s1">a)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">pdf = stats.beta.sf(sample</span><span class="s3">, </span><span class="s1">x / bw</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1 </span><span class="s1">- x) / bw)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">alpha = x / bw</span>
        <span class="s1">beta = (</span><span class="s5">1 </span><span class="s1">- x) / bw</span>
        <span class="s1">mask_low = x &lt; </span><span class="s5">2 </span><span class="s1">* bw</span>

        <span class="s1">x_ = x[mask_low]</span>
        <span class="s1">alpha[mask_low] = a1 - np.sqrt(a2 - x_**</span><span class="s5">2 </span><span class="s1">- x_ / bw)</span>

        <span class="s1">mask_upp = x &gt; (</span><span class="s5">1 </span><span class="s1">- </span><span class="s5">2 </span><span class="s1">* bw)</span>
        <span class="s1">x_ = </span><span class="s5">1 </span><span class="s1">- x[mask_upp]</span>
        <span class="s1">beta[mask_upp] = a1 - np.sqrt(a2 - x_**</span><span class="s5">2 </span><span class="s1">- x_ / bw)</span>

        <span class="s1">pdf = stats.beta.sf(sample</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">beta)</span>

    <span class="s3">return </span><span class="s1">pdf</span>


<span class="s1">kernel_cdf_beta2.__doc__ = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">Beta kernel for cdf estimation with boundary correction. 
 
    {doc_params} 
 
    References 
    ---------- 
    .. [1] Bouezmarni, Taoufik, and Olivier Scaillet. 2005. “Consistency of 
       Asymmetric Kernel Density Estimators and Smoothed Histograms with 
       Application to Income Data.” Econometric Theory 21 (2): 390–412. 
 
    .. [2] Chen, Song Xi. 1999. “Beta Kernel Estimators for Density Functions.” 
       Computational Statistics &amp; Data Analysis 31 (2): 131–45. 
       https://doi.org/10.1016/S0167-9473(99)00010-9. 
    &quot;&quot;&quot;</span><span class="s1">.format(doc_params=doc_params)</span>


<span class="s3">def </span><span class="s1">kernel_pdf_gamma(x</span><span class="s3">, </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">bw):</span>
    <span class="s0"># Gamma kernel for density, pdf, estimation</span>
    <span class="s1">pdfi = stats.gamma.pdf(sample</span><span class="s3">, </span><span class="s1">x / bw + </span><span class="s5">1</span><span class="s3">, </span><span class="s1">scale=bw)</span>
    <span class="s3">return </span><span class="s1">pdfi</span>


<span class="s1">kernel_pdf_gamma.__doc__ = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">Gamma kernel for density, pdf, estimation. 
 
    {doc_params} 
 
    References 
    ---------- 
    .. [1] Bouezmarni, Taoufik, and Olivier Scaillet. 2005. “Consistency of 
       Asymmetric Kernel Density Estimators and Smoothed Histograms with 
       Application to Income Data.” Econometric Theory 21 (2): 390–412. 
 
    .. [2] Chen, Song Xi. 2000. “Probability Density Function Estimation Using 
       Gamma Krnels.” 
       Annals of the Institute of Statistical Mathematics 52 (3): 471–80. 
       https://doi.org/10.1023/A:1004165218295. 
    &quot;&quot;&quot;</span><span class="s1">.format(doc_params=doc_params)</span>


<span class="s3">def </span><span class="s1">kernel_cdf_gamma(x</span><span class="s3">, </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">bw):</span>
    <span class="s0"># Gamma kernel for density, pdf, estimation</span>
    <span class="s0"># kernel cdf uses the survival function, but I don't know why.</span>
    <span class="s1">cdfi = stats.gamma.sf(sample</span><span class="s3">, </span><span class="s1">x / bw + </span><span class="s5">1</span><span class="s3">, </span><span class="s1">scale=bw)</span>
    <span class="s3">return </span><span class="s1">cdfi</span>


<span class="s1">kernel_cdf_gamma.__doc__ = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">Gamma kernel for cumulative distribution, cdf, estimation. 
 
    {doc_params} 
 
    References 
    ---------- 
    .. [1] Bouezmarni, Taoufik, and Olivier Scaillet. 2005. “Consistency of 
       Asymmetric Kernel Density Estimators and Smoothed Histograms with 
       Application to Income Data.” Econometric Theory 21 (2): 390–412. 
 
    .. [2] Chen, Song Xi. 2000. “Probability Density Function Estimation Using 
       Gamma Krnels.” 
       Annals of the Institute of Statistical Mathematics 52 (3): 471–80. 
       https://doi.org/10.1023/A:1004165218295. 
    &quot;&quot;&quot;</span><span class="s1">.format(doc_params=doc_params)</span>


<span class="s3">def </span><span class="s1">_kernel_pdf_gamma(x</span><span class="s3">, </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">bw):</span>
    <span class="s2">&quot;&quot;&quot;Gamma kernel for pdf, without boundary corrected part. 
 
    drops `+ 1` in shape parameter 
 
    It should be possible to use this if probability in 
    neighborhood of zero boundary is small. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">stats.gamma.pdf(sample</span><span class="s3">, </span><span class="s1">x / bw</span><span class="s3">, </span><span class="s1">scale=bw)</span>


<span class="s3">def </span><span class="s1">_kernel_cdf_gamma(x</span><span class="s3">, </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">bw):</span>
    <span class="s2">&quot;&quot;&quot;Gamma kernel for cdf, without boundary corrected part. 
 
    drops `+ 1` in shape parameter 
 
    It should be possible to use this if probability in 
    neighborhood of zero boundary is small. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">stats.gamma.sf(sample</span><span class="s3">, </span><span class="s1">x / bw</span><span class="s3">, </span><span class="s1">scale=bw)</span>


<span class="s3">def </span><span class="s1">kernel_pdf_gamma2(x</span><span class="s3">, </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">bw):</span>
    <span class="s0"># Gamma kernel for density, pdf, estimation with boundary correction</span>
    <span class="s3">if </span><span class="s1">np.size(x) == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s0"># without vectorizing, easier to read</span>
        <span class="s3">if </span><span class="s1">x &lt; </span><span class="s5">2 </span><span class="s1">* bw:</span>
            <span class="s1">a = (x / bw)**</span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">1</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">a = x / bw</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">a = x / bw</span>
        <span class="s1">mask = x &lt; </span><span class="s5">2 </span><span class="s1">* bw</span>
        <span class="s1">a[mask] = a[mask]**</span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">1</span>
    <span class="s1">pdf = stats.gamma.pdf(sample</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">scale=bw)</span>

    <span class="s3">return </span><span class="s1">pdf</span>


<span class="s1">kernel_pdf_gamma2.__doc__ = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">Gamma kernel for density, pdf, estimation with boundary correction. 
 
    {doc_params} 
 
    References 
    ---------- 
    .. [1] Bouezmarni, Taoufik, and Olivier Scaillet. 2005. “Consistency of 
       Asymmetric Kernel Density Estimators and Smoothed Histograms with 
       Application to Income Data.” Econometric Theory 21 (2): 390–412. 
 
    .. [2] Chen, Song Xi. 2000. “Probability Density Function Estimation Using 
       Gamma Krnels.” 
       Annals of the Institute of Statistical Mathematics 52 (3): 471–80. 
       https://doi.org/10.1023/A:1004165218295. 
    &quot;&quot;&quot;</span><span class="s1">.format(doc_params=doc_params)</span>


<span class="s3">def </span><span class="s1">kernel_cdf_gamma2(x</span><span class="s3">, </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">bw):</span>
    <span class="s0"># Gamma kernel for cdf estimation with boundary correction</span>
    <span class="s3">if </span><span class="s1">np.size(x) == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s0"># without vectorizing</span>
        <span class="s3">if </span><span class="s1">x &lt; </span><span class="s5">2 </span><span class="s1">* bw:</span>
            <span class="s1">a = (x / bw)**</span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">1</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">a = x / bw</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">a = x / bw</span>
        <span class="s1">mask = x &lt; </span><span class="s5">2 </span><span class="s1">* bw</span>
        <span class="s1">a[mask] = a[mask]**</span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">1</span>
    <span class="s1">pdf = stats.gamma.sf(sample</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">scale=bw)</span>

    <span class="s3">return </span><span class="s1">pdf</span>


<span class="s1">kernel_cdf_gamma2.__doc__ = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">Gamma kernel for cdf estimation with boundary correction. 
 
    {doc_params} 
 
    References 
    ---------- 
    .. [1] Bouezmarni, Taoufik, and Olivier Scaillet. 2005. “Consistency of 
       Asymmetric Kernel Density Estimators and Smoothed Histograms with 
       Application to Income Data.” Econometric Theory 21 (2): 390–412. 
 
    .. [2] Chen, Song Xi. 2000. “Probability Density Function Estimation Using 
       Gamma Krnels.” 
       Annals of the Institute of Statistical Mathematics 52 (3): 471–80. 
       https://doi.org/10.1023/A:1004165218295. 
    &quot;&quot;&quot;</span><span class="s1">.format(doc_params=doc_params)</span>


<span class="s3">def </span><span class="s1">kernel_pdf_invgamma(x</span><span class="s3">, </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">bw):</span>
    <span class="s0"># Inverse gamma kernel for density, pdf, estimation</span>
    <span class="s3">return </span><span class="s1">stats.invgamma.pdf(sample</span><span class="s3">, </span><span class="s5">1 </span><span class="s1">/ bw + </span><span class="s5">1</span><span class="s3">, </span><span class="s1">scale=x / bw)</span>


<span class="s1">kernel_pdf_invgamma.__doc__ = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">Inverse gamma kernel for density, pdf, estimation. 
 
    Based on cdf kernel by Micheaux and Ouimet (2020) 
 
    {doc_params} 
 
    References 
    ---------- 
    .. [1] Micheaux, Pierre Lafaye de, and Frédéric Ouimet. 2020. “A Study of 
       Seven Asymmetric Kernels for the Estimation of Cumulative Distribution 
       Functions,” November. https://arxiv.org/abs/2011.14893v1. 
    &quot;&quot;&quot;</span><span class="s1">.format(doc_params=doc_params)</span>


<span class="s3">def </span><span class="s1">kernel_cdf_invgamma(x</span><span class="s3">, </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">bw):</span>
    <span class="s0"># Inverse gamma kernel for cumulative distribution, cdf, estimation</span>
    <span class="s3">return </span><span class="s1">stats.invgamma.sf(sample</span><span class="s3">, </span><span class="s5">1 </span><span class="s1">/ bw + </span><span class="s5">1</span><span class="s3">, </span><span class="s1">scale=x / bw)</span>


<span class="s1">kernel_cdf_invgamma.__doc__ = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">Inverse gamma kernel for cumulative distribution, cdf, estimation. 
 
    {doc_params} 
 
    References 
    ---------- 
    .. [1] Micheaux, Pierre Lafaye de, and Frédéric Ouimet. 2020. “A Study of 
       Seven Asymmetric Kernels for the Estimation of Cumulative Distribution 
       Functions,” November. https://arxiv.org/abs/2011.14893v1. 
    &quot;&quot;&quot;</span><span class="s1">.format(doc_params=doc_params)</span>


<span class="s3">def </span><span class="s1">kernel_pdf_invgauss(x</span><span class="s3">, </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">bw):</span>
    <span class="s0"># Inverse gaussian kernel for density, pdf, estimation</span>
    <span class="s1">m = x</span>
    <span class="s1">lam = </span><span class="s5">1 </span><span class="s1">/ bw</span>
    <span class="s3">return </span><span class="s1">stats.invgauss.pdf(sample</span><span class="s3">, </span><span class="s1">m / lam</span><span class="s3">, </span><span class="s1">scale=lam)</span>


<span class="s1">kernel_pdf_invgauss.__doc__ = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">Inverse gaussian kernel for density, pdf, estimation. 
 
    {doc_params} 
 
    References 
    ---------- 
    .. [1] Scaillet, O. 2004. “Density Estimation Using Inverse and Reciprocal 
       Inverse Gaussian Kernels.” 
       Journal of Nonparametric Statistics 16 (1–2): 217–26. 
       https://doi.org/10.1080/10485250310001624819. 
    &quot;&quot;&quot;</span><span class="s1">.format(doc_params=doc_params)</span>


<span class="s3">def </span><span class="s1">kernel_pdf_invgauss_(x</span><span class="s3">, </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">bw):</span>
    <span class="s2">&quot;&quot;&quot;Inverse gaussian kernel density, explicit formula. 
 
    Scaillet 2004 
    &quot;&quot;&quot;</span>
    <span class="s1">pdf = (</span><span class="s5">1 </span><span class="s1">/ np.sqrt(</span><span class="s5">2 </span><span class="s1">* np.pi * bw * sample**</span><span class="s5">3</span><span class="s1">) *</span>
           <span class="s1">np.exp(- </span><span class="s5">1 </span><span class="s1">/ (</span><span class="s5">2 </span><span class="s1">* bw * x) * (sample / x - </span><span class="s5">2 </span><span class="s1">+ x / sample)))</span>
    <span class="s3">return </span><span class="s1">pdf.mean(-</span><span class="s5">1</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">kernel_cdf_invgauss(x</span><span class="s3">, </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">bw):</span>
    <span class="s0"># Inverse gaussian kernel for cumulative distribution, cdf, estimation</span>
    <span class="s1">m = x</span>
    <span class="s1">lam = </span><span class="s5">1 </span><span class="s1">/ bw</span>
    <span class="s3">return </span><span class="s1">stats.invgauss.sf(sample</span><span class="s3">, </span><span class="s1">m / lam</span><span class="s3">, </span><span class="s1">scale=lam)</span>


<span class="s1">kernel_cdf_invgauss.__doc__ = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">Inverse gaussian kernel for cumulative distribution, cdf, estimation. 
 
    {doc_params} 
 
    References 
    ---------- 
    .. [1] Scaillet, O. 2004. “Density Estimation Using Inverse and Reciprocal 
       Inverse Gaussian Kernels.” 
       Journal of Nonparametric Statistics 16 (1–2): 217–26. 
       https://doi.org/10.1080/10485250310001624819. 
    &quot;&quot;&quot;</span><span class="s1">.format(doc_params=doc_params)</span>


<span class="s3">def </span><span class="s1">kernel_pdf_recipinvgauss(x</span><span class="s3">, </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">bw):</span>
    <span class="s0"># Reciprocal inverse gaussian kernel for density, pdf, estimation</span>

    <span class="s0"># need shape-scale parameterization for scipy</span>
    <span class="s0"># references use m, lambda parameterization</span>
    <span class="s1">m = </span><span class="s5">1 </span><span class="s1">/ (x - bw)</span>
    <span class="s1">lam = </span><span class="s5">1 </span><span class="s1">/ bw</span>
    <span class="s3">return </span><span class="s1">stats.recipinvgauss.pdf(sample</span><span class="s3">, </span><span class="s1">m / lam</span><span class="s3">, </span><span class="s1">scale=</span><span class="s5">1 </span><span class="s1">/ lam)</span>


<span class="s1">kernel_pdf_recipinvgauss.__doc__ = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">Reciprocal inverse gaussian kernel for density, pdf, estimation. 
 
    {doc_params} 
 
    References 
    ---------- 
    .. [1] Scaillet, O. 2004. “Density Estimation Using Inverse and Reciprocal 
       Inverse Gaussian Kernels.” 
       Journal of Nonparametric Statistics 16 (1–2): 217–26. 
       https://doi.org/10.1080/10485250310001624819. 
    &quot;&quot;&quot;</span><span class="s1">.format(doc_params=doc_params)</span>


<span class="s3">def </span><span class="s1">kernel_pdf_recipinvgauss_(x</span><span class="s3">, </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">bw):</span>
    <span class="s2">&quot;&quot;&quot;Reciprocal inverse gaussian kernel density, explicit formula. 
 
    Scaillet 2004 
    &quot;&quot;&quot;</span>

    <span class="s1">pdf = (</span><span class="s5">1 </span><span class="s1">/ np.sqrt(</span><span class="s5">2 </span><span class="s1">* np.pi * bw * sample) *</span>
           <span class="s1">np.exp(- (x - bw) / (</span><span class="s5">2 </span><span class="s1">* bw) * sample / (x - bw) - </span><span class="s5">2 </span><span class="s1">+</span>
                  <span class="s1">(x - bw) / sample))</span>
    <span class="s3">return </span><span class="s1">pdf</span>


<span class="s3">def </span><span class="s1">kernel_cdf_recipinvgauss(x</span><span class="s3">, </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">bw):</span>
    <span class="s0"># Reciprocal inverse gaussian kernel for cdf estimation</span>

    <span class="s0"># need shape-scale parameterization for scipy</span>
    <span class="s0"># references use m, lambda parameterization</span>
    <span class="s1">m = </span><span class="s5">1 </span><span class="s1">/ (x - bw)</span>
    <span class="s1">lam = </span><span class="s5">1 </span><span class="s1">/ bw</span>
    <span class="s3">return </span><span class="s1">stats.recipinvgauss.sf(sample</span><span class="s3">, </span><span class="s1">m / lam</span><span class="s3">, </span><span class="s1">scale=</span><span class="s5">1 </span><span class="s1">/ lam)</span>


<span class="s1">kernel_cdf_recipinvgauss.__doc__ = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">Reciprocal inverse gaussian kernel for cdf estimation. 
 
    {doc_params} 
 
    References 
    ---------- 
    .. [1] Scaillet, O. 2004. “Density Estimation Using Inverse and Reciprocal 
       Inverse Gaussian Kernels.” 
       Journal of Nonparametric Statistics 16 (1–2): 217–26. 
       https://doi.org/10.1080/10485250310001624819. 
    &quot;&quot;&quot;</span><span class="s1">.format(doc_params=doc_params)</span>


<span class="s3">def </span><span class="s1">kernel_pdf_bs(x</span><span class="s3">, </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">bw):</span>
    <span class="s0"># Birnbaum Saunders (normal) kernel for density, pdf, estimation</span>
    <span class="s3">return </span><span class="s1">stats.fatiguelife.pdf(sample</span><span class="s3">, </span><span class="s1">bw</span><span class="s3">, </span><span class="s1">scale=x)</span>


<span class="s1">kernel_pdf_bs.__doc__ = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">Birnbaum Saunders (normal) kernel for density, pdf, estimation. 
 
    {doc_params} 
 
    References 
    ---------- 
    .. [1] Jin, Xiaodong, and Janusz Kawczak. 2003. “Birnbaum-Saunders and 
       Lognormal Kernel Estimators for Modelling Durations in High Frequency 
       Financial Data.” Annals of Economics and Finance 4: 103–24. 
    &quot;&quot;&quot;</span><span class="s1">.format(doc_params=doc_params)</span>


<span class="s3">def </span><span class="s1">kernel_cdf_bs(x</span><span class="s3">, </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">bw):</span>
    <span class="s0"># Birnbaum Saunders (normal) kernel for cdf estimation</span>
    <span class="s3">return </span><span class="s1">stats.fatiguelife.sf(sample</span><span class="s3">, </span><span class="s1">bw</span><span class="s3">, </span><span class="s1">scale=x)</span>


<span class="s1">kernel_cdf_bs.__doc__ = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">Birnbaum Saunders (normal) kernel for cdf estimation. 
 
    {doc_params} 
 
    References 
    ---------- 
    .. [1] Jin, Xiaodong, and Janusz Kawczak. 2003. “Birnbaum-Saunders and 
       Lognormal Kernel Estimators for Modelling Durations in High Frequency 
       Financial Data.” Annals of Economics and Finance 4: 103–24. 
    .. [2] Mombeni, Habib Allah, B Masouri, and Mohammad Reza Akhoond. 2019. 
       “Asymmetric Kernels for Boundary Modification in Distribution Function 
       Estimation.” REVSTAT, 1–27. 
    &quot;&quot;&quot;</span><span class="s1">.format(doc_params=doc_params)</span>


<span class="s3">def </span><span class="s1">kernel_pdf_lognorm(x</span><span class="s3">, </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">bw):</span>
    <span class="s0"># Log-normal kernel for density, pdf, estimation</span>

    <span class="s0"># need shape-scale parameterization for scipy</span>
    <span class="s0"># not sure why JK picked this normalization, makes required bw small</span>
    <span class="s0"># maybe we should skip this transformation and just use bw</span>
    <span class="s0"># Funke and Kawka 2015 (table 1) use bw (or bw**2) corresponding to</span>
    <span class="s0">#    variance of normal pdf</span>
    <span class="s0"># bw = np.exp(bw_**2 / 4) - 1  # this is inverse transformation</span>
    <span class="s1">bw_ = np.sqrt(</span><span class="s5">4</span><span class="s1">*np.log(</span><span class="s5">1</span><span class="s1">+bw))</span>
    <span class="s3">return </span><span class="s1">stats.lognorm.pdf(sample</span><span class="s3">, </span><span class="s1">bw_</span><span class="s3">, </span><span class="s1">scale=x)</span>


<span class="s1">kernel_pdf_lognorm.__doc__ = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">Log-normal kernel for density, pdf, estimation. 
 
    {doc_params} 
 
    Notes 
    ----- 
    Warning: parameterization of bandwidth will likely be changed 
 
    References 
    ---------- 
    .. [1] Jin, Xiaodong, and Janusz Kawczak. 2003. “Birnbaum-Saunders and 
       Lognormal Kernel Estimators for Modelling Durations in High Frequency 
       Financial Data.” Annals of Economics and Finance 4: 103–24. 
    &quot;&quot;&quot;</span><span class="s1">.format(doc_params=doc_params)</span>


<span class="s3">def </span><span class="s1">kernel_cdf_lognorm(x</span><span class="s3">, </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">bw):</span>
    <span class="s0"># Log-normal kernel for cumulative distribution, cdf, estimation</span>

    <span class="s0"># need shape-scale parameterization for scipy</span>
    <span class="s0"># not sure why JK picked this normalization, makes required bw small</span>
    <span class="s0"># maybe we should skip this transformation and just use bw</span>
    <span class="s0"># Funke and Kawka 2015 (table 1) use bw (or bw**2) corresponding to</span>
    <span class="s0">#    variance of normal pdf</span>
    <span class="s0"># bw = np.exp(bw_**2 / 4) - 1  # this is inverse transformation</span>
    <span class="s1">bw_ = np.sqrt(</span><span class="s5">4</span><span class="s1">*np.log(</span><span class="s5">1</span><span class="s1">+bw))</span>
    <span class="s3">return </span><span class="s1">stats.lognorm.sf(sample</span><span class="s3">, </span><span class="s1">bw_</span><span class="s3">, </span><span class="s1">scale=x)</span>


<span class="s1">kernel_cdf_lognorm.__doc__ = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">Log-normal kernel for cumulative distribution, cdf, estimation. 
 
    {doc_params} 
 
    Notes 
    ----- 
    Warning: parameterization of bandwidth will likely be changed 
 
    References 
    ---------- 
    .. [1] Jin, Xiaodong, and Janusz Kawczak. 2003. “Birnbaum-Saunders and 
       Lognormal Kernel Estimators for Modelling Durations in High Frequency 
       Financial Data.” Annals of Economics and Finance 4: 103–24. 
    &quot;&quot;&quot;</span><span class="s1">.format(doc_params=doc_params)</span>


<span class="s3">def </span><span class="s1">kernel_pdf_lognorm_(x</span><span class="s3">, </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">bw):</span>
    <span class="s2">&quot;&quot;&quot;Log-normal kernel for density, pdf, estimation, explicit formula. 
 
    Jin, Kawczak 2003 
    &quot;&quot;&quot;</span>
    <span class="s1">term = </span><span class="s5">8 </span><span class="s1">* np.log(</span><span class="s5">1 </span><span class="s1">+ bw)  </span><span class="s0"># this is 2 * variance in normal pdf</span>
    <span class="s1">pdf = (</span><span class="s5">1 </span><span class="s1">/ np.sqrt(term * np.pi) / sample *</span>
           <span class="s1">np.exp(- (np.log(x) - np.log(sample))**</span><span class="s5">2 </span><span class="s1">/ term))</span>
    <span class="s3">return </span><span class="s1">pdf.mean(-</span><span class="s5">1</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">kernel_pdf_weibull(x</span><span class="s3">, </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">bw):</span>
    <span class="s0"># Weibull kernel for density, pdf, estimation</span>

    <span class="s0"># need shape-scale parameterization for scipy</span>
    <span class="s0"># references use m, lambda parameterization</span>
    <span class="s3">return </span><span class="s1">stats.weibull_min.pdf(sample</span><span class="s3">, </span><span class="s5">1 </span><span class="s1">/ bw</span><span class="s3">,</span>
                                 <span class="s1">scale=x / special.gamma(</span><span class="s5">1 </span><span class="s1">+ bw))</span>


<span class="s1">kernel_pdf_weibull.__doc__ = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">Weibull kernel for density, pdf, estimation. 
 
    Based on cdf kernel by Mombeni et al. (2019) 
 
    {doc_params} 
 
    References 
    ---------- 
    .. [1] Mombeni, Habib Allah, B Masouri, and Mohammad Reza Akhoond. 2019. 
       “Asymmetric Kernels for Boundary Modification in Distribution Function 
       Estimation.” REVSTAT, 1–27. 
    &quot;&quot;&quot;</span><span class="s1">.format(doc_params=doc_params)</span>


<span class="s3">def </span><span class="s1">kernel_cdf_weibull(x</span><span class="s3">, </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">bw):</span>
    <span class="s0"># Weibull kernel for cumulative distribution, cdf, estimation</span>

    <span class="s0"># need shape-scale parameterization for scipy</span>
    <span class="s0"># references use m, lambda parameterization</span>
    <span class="s3">return </span><span class="s1">stats.weibull_min.sf(sample</span><span class="s3">, </span><span class="s5">1 </span><span class="s1">/ bw</span><span class="s3">,</span>
                                <span class="s1">scale=x / special.gamma(</span><span class="s5">1 </span><span class="s1">+ bw))</span>


<span class="s1">kernel_cdf_weibull.__doc__ = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
    </span><span class="s4">Weibull kernel for cumulative distribution, cdf, estimation. 
 
    {doc_params} 
 
    References 
    ---------- 
    .. [1] Mombeni, Habib Allah, B Masouri, and Mohammad Reza Akhoond. 2019. 
       “Asymmetric Kernels for Boundary Modification in Distribution Function 
       Estimation.” REVSTAT, 1–27. 
    &quot;&quot;&quot;</span><span class="s1">.format(doc_params=doc_params)</span>


<span class="s0"># produced wth</span>
<span class="s0"># print(&quot;\n&quot;.join(['&quot;%s&quot;: %s,' % (i.split(&quot;_&quot;)[-1], i) for i in dir(kern)</span>
<span class="s0">#                  if &quot;kernel&quot; in i and not i.endswith(&quot;_&quot;)]))</span>
<span class="s1">kernel_dict_cdf = {</span>
    <span class="s4">&quot;beta&quot;</span><span class="s1">: kernel_cdf_beta</span><span class="s3">,</span>
    <span class="s4">&quot;beta2&quot;</span><span class="s1">: kernel_cdf_beta2</span><span class="s3">,</span>
    <span class="s4">&quot;bs&quot;</span><span class="s1">: kernel_cdf_bs</span><span class="s3">,</span>
    <span class="s4">&quot;gamma&quot;</span><span class="s1">: kernel_cdf_gamma</span><span class="s3">,</span>
    <span class="s4">&quot;gamma2&quot;</span><span class="s1">: kernel_cdf_gamma2</span><span class="s3">,</span>
    <span class="s4">&quot;invgamma&quot;</span><span class="s1">: kernel_cdf_invgamma</span><span class="s3">,</span>
    <span class="s4">&quot;invgauss&quot;</span><span class="s1">: kernel_cdf_invgauss</span><span class="s3">,</span>
    <span class="s4">&quot;lognorm&quot;</span><span class="s1">: kernel_cdf_lognorm</span><span class="s3">,</span>
    <span class="s4">&quot;recipinvgauss&quot;</span><span class="s1">: kernel_cdf_recipinvgauss</span><span class="s3">,</span>
    <span class="s4">&quot;weibull&quot;</span><span class="s1">: kernel_cdf_weibull</span><span class="s3">,</span>
    <span class="s1">}</span>

<span class="s1">kernel_dict_pdf = {</span>
    <span class="s4">&quot;beta&quot;</span><span class="s1">: kernel_pdf_beta</span><span class="s3">,</span>
    <span class="s4">&quot;beta2&quot;</span><span class="s1">: kernel_pdf_beta2</span><span class="s3">,</span>
    <span class="s4">&quot;bs&quot;</span><span class="s1">: kernel_pdf_bs</span><span class="s3">,</span>
    <span class="s4">&quot;gamma&quot;</span><span class="s1">: kernel_pdf_gamma</span><span class="s3">,</span>
    <span class="s4">&quot;gamma2&quot;</span><span class="s1">: kernel_pdf_gamma2</span><span class="s3">,</span>
    <span class="s4">&quot;invgamma&quot;</span><span class="s1">: kernel_pdf_invgamma</span><span class="s3">,</span>
    <span class="s4">&quot;invgauss&quot;</span><span class="s1">: kernel_pdf_invgauss</span><span class="s3">,</span>
    <span class="s4">&quot;lognorm&quot;</span><span class="s1">: kernel_pdf_lognorm</span><span class="s3">,</span>
    <span class="s4">&quot;recipinvgauss&quot;</span><span class="s1">: kernel_pdf_recipinvgauss</span><span class="s3">,</span>
    <span class="s4">&quot;weibull&quot;</span><span class="s1">: kernel_pdf_weibull</span><span class="s3">,</span>
    <span class="s1">}</span>
</pre>
</body>
</html>