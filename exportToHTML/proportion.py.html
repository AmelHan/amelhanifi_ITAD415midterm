<html>
<head>
<title>proportion.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
proportion.py</font>
</center></td></tr></table>
<pre><span class="s0"># -*- coding: utf-8 -*-</span>
<span class="s2">&quot;&quot;&quot; 
Tests and Confidence Intervals for Binomial Proportions 
 
Created on Fri Mar 01 00:23:07 2013 
 
Author: Josef Perktold 
License: BSD-3 
&quot;&quot;&quot;</span>

<span class="s3">from </span><span class="s1">statsmodels.compat.python </span><span class="s3">import </span><span class="s1">lzip</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Callable</span><span class="s3">, </span><span class="s1">Tuple</span>
<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">import </span><span class="s1">pandas </span><span class="s3">as </span><span class="s1">pd</span>
<span class="s3">from </span><span class="s1">scipy </span><span class="s3">import </span><span class="s1">optimize</span><span class="s3">, </span><span class="s1">stats</span>

<span class="s3">from </span><span class="s1">statsmodels.stats.base </span><span class="s3">import </span><span class="s1">AllPairsResults</span><span class="s3">, </span><span class="s1">HolderTuple</span>
<span class="s3">from </span><span class="s1">statsmodels.stats.weightstats </span><span class="s3">import </span><span class="s1">_zstat_generic2</span>
<span class="s3">from </span><span class="s1">statsmodels.tools.sm_exceptions </span><span class="s3">import </span><span class="s1">HypothesisTestWarning</span>
<span class="s3">from </span><span class="s1">statsmodels.tools.testing </span><span class="s3">import </span><span class="s1">Holder</span>
<span class="s3">from </span><span class="s1">statsmodels.tools.validation </span><span class="s3">import </span><span class="s1">array_like</span>

<span class="s1">FLOAT_INFO = np.finfo(float)</span>


<span class="s3">def </span><span class="s1">_bound_proportion_confint(</span>
    <span class="s1">func: Callable[[float]</span><span class="s3">, </span><span class="s1">float]</span><span class="s3">, </span><span class="s1">qi: float</span><span class="s3">, </span><span class="s1">lower: bool = </span><span class="s3">True</span>
<span class="s1">) -&gt; float:</span>
    <span class="s2">&quot;&quot;&quot; 
    Try hard to find a bound different from eps/1 - eps in proportion_confint 
 
    Parameters 
    ---------- 
    func : callable 
        Callable function to use as the objective of the search 
    qi : float 
        The empirical success rate 
    lower : bool 
        Whether to fund a lower bound for the left side of the CI 
 
    Returns 
    ------- 
    float 
        The coarse bound 
    &quot;&quot;&quot;</span>
    <span class="s1">default = FLOAT_INFO.eps </span><span class="s3">if </span><span class="s1">lower </span><span class="s3">else </span><span class="s4">1.0 </span><span class="s1">- FLOAT_INFO.eps</span>

    <span class="s3">def </span><span class="s1">step(v):</span>
        <span class="s3">return </span><span class="s1">v / </span><span class="s4">8 </span><span class="s3">if </span><span class="s1">lower </span><span class="s3">else </span><span class="s1">v + (</span><span class="s4">1.0 </span><span class="s1">- v) / </span><span class="s4">8</span>

    <span class="s1">x = step(qi)</span>
    <span class="s1">w = func(x)</span>
    <span class="s1">cnt = </span><span class="s4">1</span>
    <span class="s3">while </span><span class="s1">w &gt; </span><span class="s4">0 </span><span class="s3">and </span><span class="s1">cnt &lt; </span><span class="s4">10</span><span class="s1">:</span>
        <span class="s1">x = step(x)</span>
        <span class="s1">w = func(x)</span>
        <span class="s1">cnt += </span><span class="s4">1</span>
    <span class="s3">return </span><span class="s1">x </span><span class="s3">if </span><span class="s1">cnt &lt; </span><span class="s4">10 </span><span class="s3">else </span><span class="s1">default</span>


<span class="s3">def </span><span class="s1">_bisection_search_conservative(</span>
    <span class="s1">func: Callable[[float]</span><span class="s3">, </span><span class="s1">float]</span><span class="s3">, </span><span class="s1">lb: float</span><span class="s3">, </span><span class="s1">ub: float</span><span class="s3">, </span><span class="s1">steps: int = </span><span class="s4">27</span>
<span class="s1">) -&gt; Tuple[float</span><span class="s3">, </span><span class="s1">float]:</span>
    <span class="s2">&quot;&quot;&quot; 
    Private function used as a fallback by proportion_confint 
 
    Used when brentq returns a non-conservative bound for the CI 
 
    Parameters 
    ---------- 
    func : callable 
        Callable function to use as the objective of the search 
    lb : float 
        Lower bound 
    ub : float 
        Upper bound 
    steps : int 
        Number of steps to use in the bisection 
 
    Returns 
    ------- 
    est : float 
        The estimated value.  Will always produce a negative value of func 
    func_val : float 
        The value of the function at the estimate 
    &quot;&quot;&quot;</span>
    <span class="s1">upper = func(ub)</span>
    <span class="s1">lower = func(lb)</span>
    <span class="s1">best = upper </span><span class="s3">if </span><span class="s1">upper &lt; </span><span class="s4">0 </span><span class="s3">else </span><span class="s1">lower</span>
    <span class="s1">best_pt = ub </span><span class="s3">if </span><span class="s1">upper &lt; </span><span class="s4">0 </span><span class="s3">else </span><span class="s1">lb</span>
    <span class="s3">if </span><span class="s1">np.sign(lower) == np.sign(upper):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;problem with signs&quot;</span><span class="s1">)</span>
    <span class="s1">mp = (ub + lb) / </span><span class="s4">2</span>
    <span class="s1">mid = func(mp)</span>
    <span class="s3">if </span><span class="s1">(mid &lt; </span><span class="s4">0</span><span class="s1">) </span><span class="s3">and </span><span class="s1">(mid &gt; best):</span>
        <span class="s1">best = mid</span>
        <span class="s1">best_pt = mp</span>
    <span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">range(steps):</span>
        <span class="s3">if </span><span class="s1">np.sign(mid) == np.sign(upper):</span>
            <span class="s1">ub = mp</span>
            <span class="s1">upper = mid</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">lb = mp</span>
        <span class="s1">mp = (ub + lb) / </span><span class="s4">2</span>
        <span class="s1">mid = func(mp)</span>
        <span class="s3">if </span><span class="s1">(mid &lt; </span><span class="s4">0</span><span class="s1">) </span><span class="s3">and </span><span class="s1">(mid &gt; best):</span>
            <span class="s1">best = mid</span>
            <span class="s1">best_pt = mp</span>
    <span class="s3">return </span><span class="s1">best_pt</span><span class="s3">, </span><span class="s1">best</span>


<span class="s3">def </span><span class="s1">proportion_confint(count</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">alpha:float=</span><span class="s4">0.05</span><span class="s3">, </span><span class="s1">method=</span><span class="s5">&quot;normal&quot;</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Confidence interval for a binomial proportion 
 
    Parameters 
    ---------- 
    count : {int or float, array_like} 
        number of successes, can be pandas Series or DataFrame. Arrays 
        must contain integer values if method is &quot;binom_test&quot;. 
    nobs : {int or float, array_like} 
        total number of trials.  Arrays must contain integer values if method 
        is &quot;binom_test&quot;. 
    alpha : float 
        Significance level, default 0.05. Must be in (0, 1) 
    method : {&quot;normal&quot;, &quot;agresti_coull&quot;, &quot;beta&quot;, &quot;wilson&quot;, &quot;binom_test&quot;} 
        default: &quot;normal&quot; 
        method to use for confidence interval. Supported methods: 
 
         - `normal` : asymptotic normal approximation 
         - `agresti_coull` : Agresti-Coull interval 
         - `beta` : Clopper-Pearson interval based on Beta distribution 
         - `wilson` : Wilson Score interval 
         - `jeffreys` : Jeffreys Bayesian Interval 
         - `binom_test` : Numerical inversion of binom_test 
 
    Returns 
    ------- 
    ci_low, ci_upp : {float, ndarray, Series DataFrame} 
        lower and upper confidence level with coverage (approximately) 1-alpha. 
        When a pandas object is returned, then the index is taken from `count`. 
 
    Notes 
    ----- 
    Beta, the Clopper-Pearson exact interval has coverage at least 1-alpha, 
    but is in general conservative. Most of the other methods have average 
    coverage equal to 1-alpha, but will have smaller coverage in some cases. 
 
    The &quot;beta&quot; and &quot;jeffreys&quot; interval are central, they use alpha/2 in each 
    tail, and alpha is not adjusted at the boundaries. In the extreme case 
    when `count` is zero or equal to `nobs`, then the coverage will be only 
    1 - alpha/2 in the case of &quot;beta&quot;. 
 
    The confidence intervals are clipped to be in the [0, 1] interval in the 
    case of &quot;normal&quot; and &quot;agresti_coull&quot;. 
 
    Method &quot;binom_test&quot; directly inverts the binomial test in scipy.stats. 
    which has discrete steps. 
 
    TODO: binom_test intervals raise an exception in small samples if one 
       interval bound is close to zero or one. 
 
    References 
    ---------- 
    .. [*] https://en.wikipedia.org/wiki/Binomial_proportion_confidence_interval 
 
    .. [*] Brown, Lawrence D.; Cai, T. Tony; DasGupta, Anirban (2001). 
       &quot;Interval Estimation for a Binomial Proportion&quot;, Statistical 
       Science 16 (2): 101–133. doi:10.1214/ss/1009213286. 
    &quot;&quot;&quot;</span>
    <span class="s1">is_scalar = np.isscalar(count) </span><span class="s3">and </span><span class="s1">np.isscalar(nobs)</span>
    <span class="s1">is_pandas = isinstance(count</span><span class="s3">, </span><span class="s1">(pd.Series</span><span class="s3">, </span><span class="s1">pd.DataFrame))</span>
    <span class="s1">count_a = array_like(count</span><span class="s3">, </span><span class="s5">&quot;count&quot;</span><span class="s3">, </span><span class="s1">optional=</span><span class="s3">False, </span><span class="s1">ndim=</span><span class="s3">None</span><span class="s1">)</span>
    <span class="s1">nobs_a = array_like(nobs</span><span class="s3">, </span><span class="s5">&quot;nobs&quot;</span><span class="s3">, </span><span class="s1">optional=</span><span class="s3">False, </span><span class="s1">ndim=</span><span class="s3">None</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_check(x: np.ndarray</span><span class="s3">, </span><span class="s1">name: str) -&gt; np.ndarray:</span>
        <span class="s3">if </span><span class="s1">np.issubdtype(x.dtype</span><span class="s3">, </span><span class="s1">np.integer):</span>
            <span class="s3">return </span><span class="s1">x</span>
        <span class="s1">y = x.astype(np.int64</span><span class="s3">, </span><span class="s1">casting=</span><span class="s5">&quot;unsafe&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">np.any(y != x):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">} </span><span class="s5">must have an integral dtype. Found data with &quot;</span>
                <span class="s5">f&quot;dtype </span><span class="s3">{</span><span class="s1">x.dtype</span><span class="s3">}</span><span class="s5">&quot;</span>
            <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">y</span>

    <span class="s3">if </span><span class="s1">method == </span><span class="s5">&quot;binom_test&quot;</span><span class="s1">:</span>
        <span class="s1">count_a = _check(np.asarray(count_a)</span><span class="s3">, </span><span class="s5">&quot;count&quot;</span><span class="s1">)</span>
        <span class="s1">nobs_a = _check(np.asarray(nobs_a)</span><span class="s3">, </span><span class="s5">&quot;count&quot;</span><span class="s1">)</span>

    <span class="s1">q_ = count_a / nobs_a</span>
    <span class="s1">alpha_2 = </span><span class="s4">0.5 </span><span class="s1">* alpha</span>

    <span class="s3">if </span><span class="s1">method == </span><span class="s5">&quot;normal&quot;</span><span class="s1">:</span>
        <span class="s1">std_ = np.sqrt(q_ * (</span><span class="s4">1 </span><span class="s1">- q_) / nobs_a)</span>
        <span class="s1">dist = stats.norm.isf(alpha / </span><span class="s4">2.0</span><span class="s1">) * std_</span>
        <span class="s1">ci_low = q_ - dist</span>
        <span class="s1">ci_upp = q_ + dist</span>
    <span class="s3">elif </span><span class="s1">method == </span><span class="s5">&quot;binom_test&quot;</span><span class="s1">:</span>
        <span class="s0"># inverting the binomial test</span>
        <span class="s3">def </span><span class="s1">func_factory(count: int</span><span class="s3">, </span><span class="s1">nobs: int) -&gt; Callable[[float]</span><span class="s3">, </span><span class="s1">float]:</span>
            <span class="s3">if </span><span class="s1">hasattr(stats</span><span class="s3">, </span><span class="s5">&quot;binomtest&quot;</span><span class="s1">):</span>

                <span class="s3">def </span><span class="s1">func(qi):</span>
                    <span class="s3">return </span><span class="s1">stats.binomtest(count</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">p=qi).pvalue - alpha</span>

            <span class="s3">else</span><span class="s1">:</span>
                <span class="s0"># Remove after min SciPy &gt;= 1.7</span>
                <span class="s3">def </span><span class="s1">func(qi):</span>
                    <span class="s3">return </span><span class="s1">stats.binom_test(count</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">p=qi) - alpha</span>

            <span class="s3">return </span><span class="s1">func</span>

        <span class="s1">bcast = np.broadcast(count_a</span><span class="s3">, </span><span class="s1">nobs_a)</span>
        <span class="s1">ci_low = np.zeros(bcast.shape)</span>
        <span class="s1">ci_upp = np.zeros(bcast.shape)</span>
        <span class="s1">index = bcast.index</span>
        <span class="s3">for </span><span class="s1">c</span><span class="s3">, </span><span class="s1">n </span><span class="s3">in </span><span class="s1">bcast:</span>
            <span class="s0"># Enforce symmetry</span>
            <span class="s1">reverse = </span><span class="s3">False</span>
            <span class="s1">_q = q_.flat[index]</span>
            <span class="s3">if </span><span class="s1">c &gt; n // </span><span class="s4">2</span><span class="s1">:</span>
                <span class="s1">c = n - c</span>
                <span class="s1">reverse = </span><span class="s3">True</span>
                <span class="s1">_q = </span><span class="s4">1 </span><span class="s1">- _q</span>
            <span class="s1">func = func_factory(c</span><span class="s3">, </span><span class="s1">n)</span>
            <span class="s3">if </span><span class="s1">c == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">ci_low.flat[index] = </span><span class="s4">0.0</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">lower_bnd = _bound_proportion_confint(func</span><span class="s3">, </span><span class="s1">_q</span><span class="s3">, </span><span class="s1">lower=</span><span class="s3">True</span><span class="s1">)</span>
                <span class="s1">val</span><span class="s3">, </span><span class="s1">_z = optimize.brentq(</span>
                    <span class="s1">func</span><span class="s3">, </span><span class="s1">lower_bnd</span><span class="s3">, </span><span class="s1">_q</span><span class="s3">, </span><span class="s1">full_output=</span><span class="s3">True</span>
                <span class="s1">)</span>
                <span class="s3">if </span><span class="s1">func(val) &gt; </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s1">power = </span><span class="s4">10</span>
                    <span class="s1">new_lb = val - (val - lower_bnd) / </span><span class="s4">2</span><span class="s1">**power</span>
                    <span class="s3">while </span><span class="s1">func(new_lb) &gt; </span><span class="s4">0 </span><span class="s3">and </span><span class="s1">power &gt;= </span><span class="s4">0</span><span class="s1">:</span>
                        <span class="s1">power -= </span><span class="s4">1</span>
                        <span class="s1">new_lb = val - (val - lower_bnd) / </span><span class="s4">2</span><span class="s1">**power</span>
                    <span class="s1">val</span><span class="s3">, </span><span class="s1">_ = _bisection_search_conservative(func</span><span class="s3">, </span><span class="s1">new_lb</span><span class="s3">, </span><span class="s1">_q)</span>
                <span class="s1">ci_low.flat[index] = val</span>
            <span class="s3">if </span><span class="s1">c == n:</span>
                <span class="s1">ci_upp.flat[index] = </span><span class="s4">1.0</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">upper_bnd = _bound_proportion_confint(func</span><span class="s3">, </span><span class="s1">_q</span><span class="s3">, </span><span class="s1">lower=</span><span class="s3">False</span><span class="s1">)</span>
                <span class="s1">val</span><span class="s3">, </span><span class="s1">_z = optimize.brentq(</span>
                    <span class="s1">func</span><span class="s3">, </span><span class="s1">_q</span><span class="s3">, </span><span class="s1">upper_bnd</span><span class="s3">, </span><span class="s1">full_output=</span><span class="s3">True</span>
                <span class="s1">)</span>
                <span class="s3">if </span><span class="s1">func(val) &gt; </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s1">power = </span><span class="s4">10</span>
                    <span class="s1">new_ub = val + (upper_bnd - val) / </span><span class="s4">2</span><span class="s1">**power</span>
                    <span class="s3">while </span><span class="s1">func(new_ub) &gt; </span><span class="s4">0 </span><span class="s3">and </span><span class="s1">power &gt;= </span><span class="s4">0</span><span class="s1">:</span>
                        <span class="s1">power -= </span><span class="s4">1</span>
                        <span class="s1">new_ub = val - (upper_bnd - val) / </span><span class="s4">2</span><span class="s1">**power</span>
                    <span class="s1">val</span><span class="s3">, </span><span class="s1">_ = _bisection_search_conservative(func</span><span class="s3">, </span><span class="s1">_q</span><span class="s3">, </span><span class="s1">new_ub)</span>
                <span class="s1">ci_upp.flat[index] = val</span>
            <span class="s3">if </span><span class="s1">reverse:</span>
                <span class="s1">temp = ci_upp.flat[index]</span>
                <span class="s1">ci_upp.flat[index] = </span><span class="s4">1 </span><span class="s1">- ci_low.flat[index]</span>
                <span class="s1">ci_low.flat[index] = </span><span class="s4">1 </span><span class="s1">- temp</span>
            <span class="s1">index = bcast.index</span>
    <span class="s3">elif </span><span class="s1">method == </span><span class="s5">&quot;beta&quot;</span><span class="s1">:</span>
        <span class="s1">ci_low = stats.beta.ppf(alpha_2</span><span class="s3">, </span><span class="s1">count_a</span><span class="s3">, </span><span class="s1">nobs_a - count_a + </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">ci_upp = stats.beta.isf(alpha_2</span><span class="s3">, </span><span class="s1">count_a + </span><span class="s4">1</span><span class="s3">, </span><span class="s1">nobs_a - count_a)</span>

        <span class="s3">if </span><span class="s1">np.ndim(ci_low) &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">ci_low.flat[q_.flat == </span><span class="s4">0</span><span class="s1">] = </span><span class="s4">0</span>
            <span class="s1">ci_upp.flat[q_.flat == </span><span class="s4">1</span><span class="s1">] = </span><span class="s4">1</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">ci_low = </span><span class="s4">0 </span><span class="s3">if </span><span class="s1">q_ == </span><span class="s4">0 </span><span class="s3">else </span><span class="s1">ci_low</span>
            <span class="s1">ci_upp = </span><span class="s4">1 </span><span class="s3">if </span><span class="s1">q_ == </span><span class="s4">1 </span><span class="s3">else </span><span class="s1">ci_upp</span>
    <span class="s3">elif </span><span class="s1">method == </span><span class="s5">&quot;agresti_coull&quot;</span><span class="s1">:</span>
        <span class="s1">crit = stats.norm.isf(alpha / </span><span class="s4">2.0</span><span class="s1">)</span>
        <span class="s1">nobs_c = nobs_a + crit**</span><span class="s4">2</span>
        <span class="s1">q_c = (count_a + crit**</span><span class="s4">2 </span><span class="s1">/ </span><span class="s4">2.0</span><span class="s1">) / nobs_c</span>
        <span class="s1">std_c = np.sqrt(q_c * (</span><span class="s4">1.0 </span><span class="s1">- q_c) / nobs_c)</span>
        <span class="s1">dist = crit * std_c</span>
        <span class="s1">ci_low = q_c - dist</span>
        <span class="s1">ci_upp = q_c + dist</span>
    <span class="s3">elif </span><span class="s1">method == </span><span class="s5">&quot;wilson&quot;</span><span class="s1">:</span>
        <span class="s1">crit = stats.norm.isf(alpha / </span><span class="s4">2.0</span><span class="s1">)</span>
        <span class="s1">crit2 = crit**</span><span class="s4">2</span>
        <span class="s1">denom = </span><span class="s4">1 </span><span class="s1">+ crit2 / nobs_a</span>
        <span class="s1">center = (q_ + crit2 / (</span><span class="s4">2 </span><span class="s1">* nobs_a)) / denom</span>
        <span class="s1">dist = crit * np.sqrt(</span>
            <span class="s1">q_ * (</span><span class="s4">1.0 </span><span class="s1">- q_) / nobs_a + crit2 / (</span><span class="s4">4.0 </span><span class="s1">* nobs_a**</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s1">dist /= denom</span>
        <span class="s1">ci_low = center - dist</span>
        <span class="s1">ci_upp = center + dist</span>
    <span class="s0"># method adjusted to be more forgiving of misspellings or incorrect option name</span>
    <span class="s3">elif </span><span class="s1">method[:</span><span class="s4">4</span><span class="s1">] == </span><span class="s5">&quot;jeff&quot;</span><span class="s1">:</span>
        <span class="s1">ci_low</span><span class="s3">, </span><span class="s1">ci_upp = stats.beta.interval(</span>
            <span class="s4">1 </span><span class="s1">- alpha</span><span class="s3">, </span><span class="s1">count_a + </span><span class="s4">0.5</span><span class="s3">, </span><span class="s1">nobs_a - count_a + </span><span class="s4">0.5</span>
        <span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s5">f&quot;method </span><span class="s3">{</span><span class="s1">method</span><span class="s3">} </span><span class="s5">is not available&quot;</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">method </span><span class="s3">in </span><span class="s1">[</span><span class="s5">&quot;normal&quot;</span><span class="s3">, </span><span class="s5">&quot;agresti_coull&quot;</span><span class="s1">]:</span>
        <span class="s1">ci_low = np.clip(ci_low</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">ci_upp = np.clip(ci_upp</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">is_pandas:</span>
        <span class="s1">container = pd.Series </span><span class="s3">if </span><span class="s1">isinstance(count</span><span class="s3">, </span><span class="s1">pd.Series) </span><span class="s3">else </span><span class="s1">pd.DataFrame</span>
        <span class="s1">ci_low = container(ci_low</span><span class="s3">, </span><span class="s1">index=count.index)</span>
        <span class="s1">ci_upp = container(ci_upp</span><span class="s3">, </span><span class="s1">index=count.index)</span>
    <span class="s3">if </span><span class="s1">is_scalar:</span>
        <span class="s3">return </span><span class="s1">float(ci_low)</span><span class="s3">, </span><span class="s1">float(ci_upp)</span>
    <span class="s3">return </span><span class="s1">ci_low</span><span class="s3">, </span><span class="s1">ci_upp</span>


<span class="s3">def </span><span class="s1">multinomial_proportions_confint(counts</span><span class="s3">, </span><span class="s1">alpha=</span><span class="s4">0.05</span><span class="s3">, </span><span class="s1">method=</span><span class="s5">'goodman'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Confidence intervals for multinomial proportions. 
 
    Parameters 
    ---------- 
    counts : array_like of int, 1-D 
        Number of observations in each category. 
    alpha : float in (0, 1), optional 
        Significance level, defaults to 0.05. 
    method : {'goodman', 'sison-glaz'}, optional 
        Method to use to compute the confidence intervals; available methods 
        are: 
 
         - `goodman`: based on a chi-squared approximation, valid if all 
           values in `counts` are greater or equal to 5 [2]_ 
         - `sison-glaz`: less conservative than `goodman`, but only valid if 
           `counts` has 7 or more categories (``len(counts) &gt;= 7``) [3]_ 
 
    Returns 
    ------- 
    confint : ndarray, 2-D 
        Array of [lower, upper] confidence levels for each category, such that 
        overall coverage is (approximately) `1-alpha`. 
 
    Raises 
    ------ 
    ValueError 
        If `alpha` is not in `(0, 1)` (bounds excluded), or if the values in 
        `counts` are not all positive or null. 
    NotImplementedError 
        If `method` is not kown. 
    Exception 
        When ``method == 'sison-glaz'``, if for some reason `c` cannot be 
        computed; this signals a bug and should be reported. 
 
    Notes 
    ----- 
    The `goodman` method [2]_ is based on approximating a statistic based on 
    the multinomial as a chi-squared random variable. The usual recommendation 
    is that this is valid if all the values in `counts` are greater than or 
    equal to 5. There is no condition on the number of categories for this 
    method. 
 
    The `sison-glaz` method [3]_ approximates the multinomial probabilities, 
    and evaluates that with a maximum-likelihood estimator. The first 
    approximation is an Edgeworth expansion that converges when the number of 
    categories goes to infinity, and the maximum-likelihood estimator converges 
    when the number of observations (``sum(counts)``) goes to infinity. In 
    their paper, Sison &amp; Glaz demo their method with at least 7 categories, so 
    ``len(counts) &gt;= 7`` with all values in `counts` at or above 5 can be used 
    as a rule of thumb for the validity of this method. This method is less 
    conservative than the `goodman` method (i.e. it will yield confidence 
    intervals closer to the desired significance level), but produces 
    confidence intervals of uniform width over all categories (except when the 
    intervals reach 0 or 1, in which case they are truncated), which makes it 
    most useful when proportions are of similar magnitude. 
 
    Aside from the original sources ([1]_, [2]_, and [3]_), the implementation 
    uses the formulas (though not the code) presented in [4]_ and [5]_. 
 
    References 
    ---------- 
    .. [1] Levin, Bruce, &quot;A representation for multinomial cumulative 
           distribution functions,&quot; The Annals of Statistics, Vol. 9, No. 5, 
           1981, pp. 1123-1126. 
 
    .. [2] Goodman, L.A., &quot;On simultaneous confidence intervals for multinomial 
           proportions,&quot; Technometrics, Vol. 7, No. 2, 1965, pp. 247-254. 
 
    .. [3] Sison, Cristina P., and Joseph Glaz, &quot;Simultaneous Confidence 
           Intervals and Sample Size Determination for Multinomial 
           Proportions,&quot; Journal of the American Statistical Association, 
           Vol. 90, No. 429, 1995, pp. 366-369. 
 
    .. [4] May, Warren L., and William D. Johnson, &quot;A SAS® macro for 
           constructing simultaneous confidence intervals  for multinomial 
           proportions,&quot; Computer methods and programs in Biomedicine, Vol. 53, 
           No. 3, 1997, pp. 153-162. 
 
    .. [5] May, Warren L., and William D. Johnson, &quot;Constructing two-sided 
           simultaneous confidence intervals for multinomial proportions for 
           small counts in a large number of cells,&quot; Journal of Statistical 
           Software, Vol. 5, No. 6, 2000, pp. 1-24. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">alpha &lt;= </span><span class="s4">0 </span><span class="s3">or </span><span class="s1">alpha &gt;= </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'alpha must be in (0, 1), bounds excluded'</span><span class="s1">)</span>
    <span class="s1">counts = np.array(counts</span><span class="s3">, </span><span class="s1">dtype=float)</span>
    <span class="s3">if </span><span class="s1">(counts &lt; </span><span class="s4">0</span><span class="s1">).any():</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'counts must be &gt;= 0'</span><span class="s1">)</span>

    <span class="s1">n = counts.sum()</span>
    <span class="s1">k = len(counts)</span>
    <span class="s1">proportions = counts / n</span>
    <span class="s3">if </span><span class="s1">method == </span><span class="s5">'goodman'</span><span class="s1">:</span>
        <span class="s1">chi2 = stats.chi2.ppf(</span><span class="s4">1 </span><span class="s1">- alpha / k</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">delta = chi2 ** </span><span class="s4">2 </span><span class="s1">+ (</span><span class="s4">4 </span><span class="s1">* n * proportions * chi2 * (</span><span class="s4">1 </span><span class="s1">- proportions))</span>
        <span class="s1">region = ((</span><span class="s4">2 </span><span class="s1">* n * proportions + chi2 +</span>
                   <span class="s1">np.array([- np.sqrt(delta)</span><span class="s3">, </span><span class="s1">np.sqrt(delta)])) /</span>
                  <span class="s1">(</span><span class="s4">2 </span><span class="s1">* (chi2 + n))).T</span>
    <span class="s3">elif </span><span class="s1">method[:</span><span class="s4">5</span><span class="s1">] == </span><span class="s5">'sison'</span><span class="s1">:  </span><span class="s0"># We accept any name starting with 'sison'</span>
        <span class="s0"># Define a few functions we'll use a lot.</span>
        <span class="s3">def </span><span class="s1">poisson_interval(interval</span><span class="s3">, </span><span class="s1">p):</span>
            <span class="s2">&quot;&quot;&quot; 
            Compute P(b &lt;= Z &lt;= a) where Z ~ Poisson(p) and 
            `interval = (b, a)`. 
            &quot;&quot;&quot;</span>
            <span class="s1">b</span><span class="s3">, </span><span class="s1">a = interval</span>
            <span class="s1">prob = stats.poisson.cdf(a</span><span class="s3">, </span><span class="s1">p) - stats.poisson.cdf(b - </span><span class="s4">1</span><span class="s3">, </span><span class="s1">p)</span>
            <span class="s3">return </span><span class="s1">prob</span>

        <span class="s3">def </span><span class="s1">truncated_poisson_factorial_moment(interval</span><span class="s3">, </span><span class="s1">r</span><span class="s3">, </span><span class="s1">p):</span>
            <span class="s2">&quot;&quot;&quot; 
            Compute mu_r, the r-th factorial moment of a poisson random 
            variable of parameter `p` truncated to `interval = (b, a)`. 
            &quot;&quot;&quot;</span>
            <span class="s1">b</span><span class="s3">, </span><span class="s1">a = interval</span>
            <span class="s3">return </span><span class="s1">p ** r * (</span><span class="s4">1 </span><span class="s1">- ((poisson_interval((a - r + </span><span class="s4">1</span><span class="s3">, </span><span class="s1">a)</span><span class="s3">, </span><span class="s1">p) -</span>
                                   <span class="s1">poisson_interval((b - r</span><span class="s3">, </span><span class="s1">b - </span><span class="s4">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">p)) /</span>
                                  <span class="s1">poisson_interval((b</span><span class="s3">, </span><span class="s1">a)</span><span class="s3">, </span><span class="s1">p)))</span>

        <span class="s3">def </span><span class="s1">edgeworth(intervals):</span>
            <span class="s2">&quot;&quot;&quot; 
            Compute the Edgeworth expansion term of Sison &amp; Glaz's formula 
            (1) (approximated probability for multinomial proportions in a 
            given box). 
            &quot;&quot;&quot;</span>
            <span class="s0"># Compute means and central moments of the truncated poisson</span>
            <span class="s0"># variables.</span>
            <span class="s1">mu_r1</span><span class="s3">, </span><span class="s1">mu_r2</span><span class="s3">, </span><span class="s1">mu_r3</span><span class="s3">, </span><span class="s1">mu_r4 = [</span>
                <span class="s1">np.array([truncated_poisson_factorial_moment(interval</span><span class="s3">, </span><span class="s1">r</span><span class="s3">, </span><span class="s1">p)</span>
                          <span class="s3">for </span><span class="s1">(interval</span><span class="s3">, </span><span class="s1">p) </span><span class="s3">in </span><span class="s1">zip(intervals</span><span class="s3">, </span><span class="s1">counts)])</span>
                <span class="s3">for </span><span class="s1">r </span><span class="s3">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s3">, </span><span class="s4">5</span><span class="s1">)</span>
            <span class="s1">]</span>
            <span class="s1">mu = mu_r1</span>
            <span class="s1">mu2 = mu_r2 + mu - mu ** </span><span class="s4">2</span>
            <span class="s1">mu3 = mu_r3 + mu_r2 * (</span><span class="s4">3 </span><span class="s1">- </span><span class="s4">3 </span><span class="s1">* mu) + mu - </span><span class="s4">3 </span><span class="s1">* mu ** </span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">2 </span><span class="s1">* mu ** </span><span class="s4">3</span>
            <span class="s1">mu4 = (mu_r4 + mu_r3 * (</span><span class="s4">6 </span><span class="s1">- </span><span class="s4">4 </span><span class="s1">* mu) +</span>
                   <span class="s1">mu_r2 * (</span><span class="s4">7 </span><span class="s1">- </span><span class="s4">12 </span><span class="s1">* mu + </span><span class="s4">6 </span><span class="s1">* mu ** </span><span class="s4">2</span><span class="s1">) +</span>
                   <span class="s1">mu - </span><span class="s4">4 </span><span class="s1">* mu ** </span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">6 </span><span class="s1">* mu ** </span><span class="s4">3 </span><span class="s1">- </span><span class="s4">3 </span><span class="s1">* mu ** </span><span class="s4">4</span><span class="s1">)</span>

            <span class="s0"># Compute expansion factors, gamma_1 and gamma_2.</span>
            <span class="s1">g1 = mu3.sum() / mu2.sum() ** </span><span class="s4">1.5</span>
            <span class="s1">g2 = (mu4.sum() - </span><span class="s4">3 </span><span class="s1">* (mu2 ** </span><span class="s4">2</span><span class="s1">).sum()) / mu2.sum() ** </span><span class="s4">2</span>

            <span class="s0"># Compute the expansion itself.</span>
            <span class="s1">x = (n - mu.sum()) / np.sqrt(mu2.sum())</span>
            <span class="s1">phi = np.exp(- x ** </span><span class="s4">2 </span><span class="s1">/ </span><span class="s4">2</span><span class="s1">) / np.sqrt(</span><span class="s4">2 </span><span class="s1">* np.pi)</span>
            <span class="s1">H3 = x ** </span><span class="s4">3 </span><span class="s1">- </span><span class="s4">3 </span><span class="s1">* x</span>
            <span class="s1">H4 = x ** </span><span class="s4">4 </span><span class="s1">- </span><span class="s4">6 </span><span class="s1">* x ** </span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">3</span>
            <span class="s1">H6 = x ** </span><span class="s4">6 </span><span class="s1">- </span><span class="s4">15 </span><span class="s1">* x ** </span><span class="s4">4 </span><span class="s1">+ </span><span class="s4">45 </span><span class="s1">* x ** </span><span class="s4">2 </span><span class="s1">- </span><span class="s4">15</span>
            <span class="s1">f = phi * (</span><span class="s4">1 </span><span class="s1">+ g1 * H3 / </span><span class="s4">6 </span><span class="s1">+ g2 * H4 / </span><span class="s4">24 </span><span class="s1">+ g1 ** </span><span class="s4">2 </span><span class="s1">* H6 / </span><span class="s4">72</span><span class="s1">)</span>
            <span class="s3">return </span><span class="s1">f / np.sqrt(mu2.sum())</span>


        <span class="s3">def </span><span class="s1">approximated_multinomial_interval(intervals):</span>
            <span class="s2">&quot;&quot;&quot; 
            Compute approximated probability for Multinomial(n, proportions) 
            to be in `intervals` (Sison &amp; Glaz's formula (1)). 
            &quot;&quot;&quot;</span>
            <span class="s3">return </span><span class="s1">np.exp(</span>
                <span class="s1">np.sum(np.log([poisson_interval(interval</span><span class="s3">, </span><span class="s1">p)</span>
                               <span class="s3">for </span><span class="s1">(interval</span><span class="s3">, </span><span class="s1">p) </span><span class="s3">in </span><span class="s1">zip(intervals</span><span class="s3">, </span><span class="s1">counts)])) +</span>
                <span class="s1">np.log(edgeworth(intervals)) -</span>
                <span class="s1">np.log(stats.poisson._pmf(n</span><span class="s3">, </span><span class="s1">n))</span>
            <span class="s1">)</span>

        <span class="s3">def </span><span class="s1">nu(c):</span>
            <span class="s2">&quot;&quot;&quot; 
            Compute interval coverage for a given `c` (Sison &amp; Glaz's 
            formula (7)). 
            &quot;&quot;&quot;</span>
            <span class="s3">return </span><span class="s1">approximated_multinomial_interval(</span>
                <span class="s1">[(np.maximum(count - c</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">np.minimum(count + c</span><span class="s3">, </span><span class="s1">n))</span>
                 <span class="s3">for </span><span class="s1">count </span><span class="s3">in </span><span class="s1">counts])</span>

        <span class="s0"># Find the value of `c` that will give us the confidence intervals</span>
        <span class="s0"># (solving nu(c) &lt;= 1 - alpha &lt; nu(c + 1).</span>
        <span class="s1">c = </span><span class="s4">1.0</span>
        <span class="s1">nuc = nu(c)</span>
        <span class="s1">nucp1 = nu(c + </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s3">while not </span><span class="s1">(nuc &lt;= (</span><span class="s4">1 </span><span class="s1">- alpha) &lt; nucp1):</span>
            <span class="s3">if </span><span class="s1">c &gt; n:</span>
                <span class="s3">raise </span><span class="s1">Exception(</span><span class="s5">&quot;Couldn't find a value for `c` that &quot;</span>
                                <span class="s5">&quot;solves nu(c) &lt;= 1 - alpha &lt; nu(c + 1)&quot;</span><span class="s1">)</span>
            <span class="s1">c += </span><span class="s4">1</span>
            <span class="s1">nuc = nucp1</span>
            <span class="s1">nucp1 = nu(c + </span><span class="s4">1</span><span class="s1">)</span>

        <span class="s0"># Compute gamma and the corresponding confidence intervals.</span>
        <span class="s1">g = (</span><span class="s4">1 </span><span class="s1">- alpha - nuc) / (nucp1 - nuc)</span>
        <span class="s1">ci_lower = np.maximum(proportions - c / n</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">ci_upper = np.minimum(proportions + (c + </span><span class="s4">2 </span><span class="s1">* g) / n</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">region = np.array([ci_lower</span><span class="s3">, </span><span class="s1">ci_upper]).T</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s5">'method &quot;%s&quot; is not available' </span><span class="s1">% method)</span>
    <span class="s3">return </span><span class="s1">region</span>


<span class="s3">def </span><span class="s1">samplesize_confint_proportion(proportion</span><span class="s3">, </span><span class="s1">half_length</span><span class="s3">, </span><span class="s1">alpha=</span><span class="s4">0.05</span><span class="s3">,</span>
                                  <span class="s1">method=</span><span class="s5">'normal'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Find sample size to get desired confidence interval length 
 
    Parameters 
    ---------- 
    proportion : float in (0, 1) 
        proportion or quantile 
    half_length : float in (0, 1) 
        desired half length of the confidence interval 
    alpha : float in (0, 1) 
        significance level, default 0.05, 
        coverage of the two-sided interval is (approximately) ``1 - alpha`` 
    method : str in ['normal'] 
        method to use for confidence interval, 
        currently only normal approximation 
 
    Returns 
    ------- 
    n : float 
        sample size to get the desired half length of the confidence interval 
 
    Notes 
    ----- 
    this is mainly to store the formula. 
    possible application: number of replications in bootstrap samples 
 
    &quot;&quot;&quot;</span>
    <span class="s1">q_ = proportion</span>
    <span class="s3">if </span><span class="s1">method == </span><span class="s5">'normal'</span><span class="s1">:</span>
        <span class="s1">n = q_ * (</span><span class="s4">1 </span><span class="s1">- q_) / (half_length / stats.norm.isf(alpha / </span><span class="s4">2.</span><span class="s1">))**</span><span class="s4">2</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s5">'only &quot;normal&quot; is available'</span><span class="s1">)</span>

    <span class="s3">return </span><span class="s1">n</span>


<span class="s3">def </span><span class="s1">proportion_effectsize(prop1</span><span class="s3">, </span><span class="s1">prop2</span><span class="s3">, </span><span class="s1">method=</span><span class="s5">'normal'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Effect size for a test comparing two proportions 
 
    for use in power function 
 
    Parameters 
    ---------- 
    prop1, prop2 : float or array_like 
        The proportion value(s). 
 
    Returns 
    ------- 
    es : float or ndarray 
        effect size for (transformed) prop1 - prop2 
 
    Notes 
    ----- 
    only method='normal' is implemented to match pwr.p2.test 
    see http://www.statmethods.net/stats/power.html 
 
    Effect size for `normal` is defined as :: 
 
        2 * (arcsin(sqrt(prop1)) - arcsin(sqrt(prop2))) 
 
    I think other conversions to normality can be used, but I need to check. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import statsmodels.api as sm 
    &gt;&gt;&gt; sm.stats.proportion_effectsize(0.5, 0.4) 
    0.20135792079033088 
    &gt;&gt;&gt; sm.stats.proportion_effectsize([0.3, 0.4, 0.5], 0.4) 
    array([-0.21015893,  0.        ,  0.20135792]) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">method != </span><span class="s5">'normal'</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'only &quot;normal&quot; is implemented'</span><span class="s1">)</span>

    <span class="s1">es = </span><span class="s4">2 </span><span class="s1">* (np.arcsin(np.sqrt(prop1)) - np.arcsin(np.sqrt(prop2)))</span>
    <span class="s3">return </span><span class="s1">es</span>


<span class="s3">def </span><span class="s1">std_prop(prop</span><span class="s3">, </span><span class="s1">nobs):</span>
    <span class="s2">&quot;&quot;&quot; 
    Standard error for the estimate of a proportion 
 
    This is just ``np.sqrt(p * (1. - p) / nobs)`` 
 
    Parameters 
    ---------- 
    prop : array_like 
        proportion 
    nobs : int, array_like 
        number of observations 
 
    Returns 
    ------- 
    std : array_like 
        standard error for a proportion of nobs independent observations 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">np.sqrt(prop * (</span><span class="s4">1. </span><span class="s1">- prop) / nobs)</span>


<span class="s3">def </span><span class="s1">_std_diff_prop(p1</span><span class="s3">, </span><span class="s1">p2</span><span class="s3">, </span><span class="s1">ratio=</span><span class="s4">1</span><span class="s1">):</span>
    <span class="s3">return </span><span class="s1">np.sqrt(p1 * (</span><span class="s4">1 </span><span class="s1">- p1) + p2 * (</span><span class="s4">1 </span><span class="s1">- p2) / ratio)</span>


<span class="s3">def </span><span class="s1">_power_ztost(mean_low</span><span class="s3">, </span><span class="s1">var_low</span><span class="s3">, </span><span class="s1">mean_upp</span><span class="s3">, </span><span class="s1">var_upp</span><span class="s3">, </span><span class="s1">mean_alt</span><span class="s3">, </span><span class="s1">var_alt</span><span class="s3">,</span>
                 <span class="s1">alpha=</span><span class="s4">0.05</span><span class="s3">, </span><span class="s1">discrete=</span><span class="s3">True, </span><span class="s1">dist=</span><span class="s5">'norm'</span><span class="s3">, </span><span class="s1">nobs=</span><span class="s3">None,</span>
                 <span class="s1">continuity=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">critval_continuity=</span><span class="s4">0</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Generic statistical power function for normal based equivalence test 
 
    This includes options to adjust the normal approximation and can use 
    the binomial to evaluate the probability of the rejection region 
 
    see power_ztost_prob for a description of the options 
    &quot;&quot;&quot;</span>
    <span class="s0"># TODO: refactor structure, separate norm and binom better</span>
    <span class="s3">if not </span><span class="s1">isinstance(continuity</span><span class="s3">, </span><span class="s1">tuple):</span>
        <span class="s1">continuity = (continuity</span><span class="s3">, </span><span class="s1">continuity)</span>
    <span class="s1">crit = stats.norm.isf(alpha)</span>
    <span class="s1">k_low = mean_low + np.sqrt(var_low) * crit</span>
    <span class="s1">k_upp = mean_upp - np.sqrt(var_upp) * crit</span>
    <span class="s3">if </span><span class="s1">discrete </span><span class="s3">or </span><span class="s1">dist == </span><span class="s5">'binom'</span><span class="s1">:</span>
        <span class="s1">k_low = np.ceil(k_low * nobs + </span><span class="s4">0.5 </span><span class="s1">* critval_continuity)</span>
        <span class="s1">k_upp = np.trunc(k_upp * nobs - </span><span class="s4">0.5 </span><span class="s1">* critval_continuity)</span>
        <span class="s3">if </span><span class="s1">dist == </span><span class="s5">'norm'</span><span class="s1">:</span>
            <span class="s0">#need proportion</span>
            <span class="s1">k_low = (k_low) * </span><span class="s4">1. </span><span class="s1">/ nobs </span><span class="s0">#-1 to match PASS</span>
            <span class="s1">k_upp = k_upp * </span><span class="s4">1. </span><span class="s1">/ nobs</span>
<span class="s0">#    else:</span>
<span class="s0">#        if dist == 'binom':</span>
<span class="s0">#            #need counts</span>
<span class="s0">#            k_low *= nobs</span>
<span class="s0">#            k_upp *= nobs</span>
    <span class="s0">#print mean_low, np.sqrt(var_low), crit, var_low</span>
    <span class="s0">#print mean_upp, np.sqrt(var_upp), crit, var_upp</span>
    <span class="s3">if </span><span class="s1">np.any(k_low &gt; k_upp):   </span><span class="s0">#vectorize</span>
        <span class="s3">import </span><span class="s1">warnings</span>
        <span class="s1">warnings.warn(</span><span class="s5">&quot;no overlap, power is zero&quot;</span><span class="s3">, </span><span class="s1">HypothesisTestWarning)</span>
    <span class="s1">std_alt = np.sqrt(var_alt)</span>
    <span class="s1">z_low = (k_low - mean_alt - continuity[</span><span class="s4">0</span><span class="s1">] * </span><span class="s4">0.5 </span><span class="s1">/ nobs) / std_alt</span>
    <span class="s1">z_upp = (k_upp - mean_alt + continuity[</span><span class="s4">1</span><span class="s1">] * </span><span class="s4">0.5 </span><span class="s1">/ nobs) / std_alt</span>
    <span class="s3">if </span><span class="s1">dist == </span><span class="s5">'norm'</span><span class="s1">:</span>
        <span class="s1">power = stats.norm.cdf(z_upp) - stats.norm.cdf(z_low)</span>
    <span class="s3">elif </span><span class="s1">dist == </span><span class="s5">'binom'</span><span class="s1">:</span>
        <span class="s1">power = (stats.binom.cdf(k_upp</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">mean_alt) -</span>
                     <span class="s1">stats.binom.cdf(k_low-</span><span class="s4">1</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">mean_alt))</span>
    <span class="s3">return </span><span class="s1">power</span><span class="s3">, </span><span class="s1">(k_low</span><span class="s3">, </span><span class="s1">k_upp</span><span class="s3">, </span><span class="s1">z_low</span><span class="s3">, </span><span class="s1">z_upp)</span>


<span class="s3">def </span><span class="s1">binom_tost(count</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">low</span><span class="s3">, </span><span class="s1">upp):</span>
    <span class="s2">&quot;&quot;&quot; 
    Exact TOST test for one proportion using binomial distribution 
 
    Parameters 
    ---------- 
    count : {int, array_like} 
        the number of successes in nobs trials. 
    nobs : int 
        the number of trials or observations. 
    low, upp : floats 
        lower and upper limit of equivalence region 
 
    Returns 
    ------- 
    pvalue : float 
        p-value of equivalence test 
    pval_low, pval_upp : floats 
        p-values of lower and upper one-sided tests 
 
    &quot;&quot;&quot;</span>
    <span class="s0"># binom_test_stat only returns pval</span>
    <span class="s1">tt1 = binom_test(count</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">alternative=</span><span class="s5">'larger'</span><span class="s3">, </span><span class="s1">prop=low)</span>
    <span class="s1">tt2 = binom_test(count</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">alternative=</span><span class="s5">'smaller'</span><span class="s3">, </span><span class="s1">prop=upp)</span>
    <span class="s3">return </span><span class="s1">np.maximum(tt1</span><span class="s3">, </span><span class="s1">tt2)</span><span class="s3">, </span><span class="s1">tt1</span><span class="s3">, </span><span class="s1">tt2</span><span class="s3">,</span>


<span class="s3">def </span><span class="s1">binom_tost_reject_interval(low</span><span class="s3">, </span><span class="s1">upp</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">alpha=</span><span class="s4">0.05</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Rejection region for binomial TOST 
 
    The interval includes the end points, 
    `reject` if and only if `r_low &lt;= x &lt;= r_upp`. 
 
    The interval might be empty with `r_upp &lt; r_low`. 
 
    Parameters 
    ---------- 
    low, upp : floats 
        lower and upper limit of equivalence region 
    nobs : int 
        the number of trials or observations. 
 
    Returns 
    ------- 
    x_low, x_upp : float 
        lower and upper bound of rejection region 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x_low = stats.binom.isf(alpha</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">low) + </span><span class="s4">1</span>
    <span class="s1">x_upp = stats.binom.ppf(alpha</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">upp) - </span><span class="s4">1</span>
    <span class="s3">return </span><span class="s1">x_low</span><span class="s3">, </span><span class="s1">x_upp</span>


<span class="s3">def </span><span class="s1">binom_test_reject_interval(value</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">alpha=</span><span class="s4">0.05</span><span class="s3">, </span><span class="s1">alternative=</span><span class="s5">'two-sided'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Rejection region for binomial test for one sample proportion 
 
    The interval includes the end points of the rejection region. 
 
    Parameters 
    ---------- 
    value : float 
        proportion under the Null hypothesis 
    nobs : int 
        the number of trials or observations. 
 
    Returns 
    ------- 
    x_low, x_upp : int 
        lower and upper bound of rejection region 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">alternative </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'2s'</span><span class="s3">, </span><span class="s5">'two-sided'</span><span class="s1">]:</span>
        <span class="s1">alternative = </span><span class="s5">'2s'  </span><span class="s0"># normalize alternative name</span>
        <span class="s1">alpha = alpha / </span><span class="s4">2</span>

    <span class="s3">if </span><span class="s1">alternative </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'2s'</span><span class="s3">, </span><span class="s5">'smaller'</span><span class="s1">]:</span>
        <span class="s1">x_low = stats.binom.ppf(alpha</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">value) - </span><span class="s4">1</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">x_low = </span><span class="s4">0</span>
    <span class="s3">if </span><span class="s1">alternative </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'2s'</span><span class="s3">, </span><span class="s5">'larger'</span><span class="s1">]:</span>
        <span class="s1">x_upp = stats.binom.isf(alpha</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">value) + </span><span class="s4">1</span>
    <span class="s3">else </span><span class="s1">:</span>
        <span class="s1">x_upp = nobs</span>

    <span class="s3">return </span><span class="s1">int(x_low)</span><span class="s3">, </span><span class="s1">int(x_upp)</span>


<span class="s3">def </span><span class="s1">binom_test(count</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">prop=</span><span class="s4">0.5</span><span class="s3">, </span><span class="s1">alternative=</span><span class="s5">'two-sided'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Perform a test that the probability of success is p. 
 
    This is an exact, two-sided test of the null hypothesis 
    that the probability of success in a Bernoulli experiment 
    is `p`. 
 
    Parameters 
    ---------- 
    count : {int, array_like} 
        the number of successes in nobs trials. 
    nobs : int 
        the number of trials or observations. 
    prop : float, optional 
        The probability of success under the null hypothesis, 
        `0 &lt;= prop &lt;= 1`. The default value is `prop = 0.5` 
    alternative : str in ['two-sided', 'smaller', 'larger'] 
        alternative hypothesis, which can be two-sided or either one of the 
        one-sided tests. 
 
    Returns 
    ------- 
    p-value : float 
        The p-value of the hypothesis test 
 
    Notes 
    ----- 
    This uses scipy.stats.binom_test for the two-sided alternative. 
    &quot;&quot;&quot;</span>

    <span class="s3">if </span><span class="s1">np.any(prop &gt; </span><span class="s4">1.0</span><span class="s1">) </span><span class="s3">or </span><span class="s1">np.any(prop &lt; </span><span class="s4">0.0</span><span class="s1">):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;p must be in range [0,1]&quot;</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">alternative </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'2s'</span><span class="s3">, </span><span class="s5">'two-sided'</span><span class="s1">]:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">pval = stats.binomtest(count</span><span class="s3">, </span><span class="s1">n=nobs</span><span class="s3">, </span><span class="s1">p=prop).pvalue</span>
        <span class="s3">except </span><span class="s1">AttributeError:</span>
            <span class="s0"># Remove after min SciPy &gt;= 1.7</span>
            <span class="s1">pval = stats.binom_test(count</span><span class="s3">, </span><span class="s1">n=nobs</span><span class="s3">, </span><span class="s1">p=prop)</span>
    <span class="s3">elif </span><span class="s1">alternative </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'l'</span><span class="s3">, </span><span class="s5">'larger'</span><span class="s1">]:</span>
        <span class="s1">pval = stats.binom.sf(count-</span><span class="s4">1</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">prop)</span>
    <span class="s3">elif </span><span class="s1">alternative </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'s'</span><span class="s3">, </span><span class="s5">'smaller'</span><span class="s1">]:</span>
        <span class="s1">pval = stats.binom.cdf(count</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">prop)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'alternative not recognized</span><span class="s3">\n</span><span class="s5">'</span>
                         <span class="s5">'should be two-sided, larger or smaller'</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">pval</span>


<span class="s3">def </span><span class="s1">power_binom_tost(low</span><span class="s3">, </span><span class="s1">upp</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">p_alt=</span><span class="s3">None, </span><span class="s1">alpha=</span><span class="s4">0.05</span><span class="s1">):</span>
    <span class="s3">if </span><span class="s1">p_alt </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">p_alt = </span><span class="s4">0.5 </span><span class="s1">* (low + upp)</span>
    <span class="s1">x_low</span><span class="s3">, </span><span class="s1">x_upp = binom_tost_reject_interval(low</span><span class="s3">, </span><span class="s1">upp</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">alpha=alpha)</span>
    <span class="s1">power = (stats.binom.cdf(x_upp</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">p_alt) -</span>
                     <span class="s1">stats.binom.cdf(x_low-</span><span class="s4">1</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">p_alt))</span>
    <span class="s3">return </span><span class="s1">power</span>


<span class="s3">def </span><span class="s1">power_ztost_prop(low</span><span class="s3">, </span><span class="s1">upp</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">p_alt</span><span class="s3">, </span><span class="s1">alpha=</span><span class="s4">0.05</span><span class="s3">, </span><span class="s1">dist=</span><span class="s5">'norm'</span><span class="s3">,</span>
                     <span class="s1">variance_prop=</span><span class="s3">None, </span><span class="s1">discrete=</span><span class="s3">True, </span><span class="s1">continuity=</span><span class="s4">0</span><span class="s3">,</span>
                     <span class="s1">critval_continuity=</span><span class="s4">0</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Power of proportions equivalence test based on normal distribution 
 
    Parameters 
    ---------- 
    low, upp : floats 
        lower and upper limit of equivalence region 
    nobs : int 
        number of observations 
    p_alt : float in (0,1) 
        proportion under the alternative 
    alpha : float in (0,1) 
        significance level of the test 
    dist : str in ['norm', 'binom'] 
        This defines the distribution to evaluate the power of the test. The 
        critical values of the TOST test are always based on the normal 
        approximation, but the distribution for the power can be either the 
        normal (default) or the binomial (exact) distribution. 
    variance_prop : None or float in (0,1) 
        If this is None, then the variances for the two one sided tests are 
        based on the proportions equal to the equivalence limits. 
        If variance_prop is given, then it is used to calculate the variance 
        for the TOST statistics. If this is based on an sample, then the 
        estimated proportion can be used. 
    discrete : bool 
        If true, then the critical values of the rejection region are converted 
        to integers. If dist is &quot;binom&quot;, this is automatically assumed. 
        If discrete is false, then the TOST critical values are used as 
        floating point numbers, and the power is calculated based on the 
        rejection region that is not discretized. 
    continuity : bool or float 
        adjust the rejection region for the normal power probability. This has 
        and effect only if ``dist='norm'`` 
    critval_continuity : bool or float 
        If this is non-zero, then the critical values of the tost rejection 
        region are adjusted before converting to integers. This affects both 
        distributions, ``dist='norm'`` and ``dist='binom'``. 
 
    Returns 
    ------- 
    power : float 
        statistical power of the equivalence test. 
    (k_low, k_upp, z_low, z_upp) : tuple of floats 
        critical limits in intermediate steps 
        temporary return, will be changed 
 
    Notes 
    ----- 
    In small samples the power for the ``discrete`` version, has a sawtooth 
    pattern as a function of the number of observations. As a consequence, 
    small changes in the number of observations or in the normal approximation 
    can have a large effect on the power. 
 
    ``continuity`` and ``critval_continuity`` are added to match some results 
    of PASS, and are mainly to investigate the sensitivity of the ztost power 
    to small changes in the rejection region. From my interpretation of the 
    equations in the SAS manual, both are zero in SAS. 
 
    works vectorized 
 
    **verification:** 
 
    The ``dist='binom'`` results match PASS, 
    The ``dist='norm'`` results look reasonable, but no benchmark is available. 
 
    References 
    ---------- 
    SAS Manual: Chapter 68: The Power Procedure, Computational Resources 
    PASS Chapter 110: Equivalence Tests for One Proportion. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">mean_low = low</span>
    <span class="s1">var_low = std_prop(low</span><span class="s3">, </span><span class="s1">nobs)**</span><span class="s4">2</span>
    <span class="s1">mean_upp = upp</span>
    <span class="s1">var_upp = std_prop(upp</span><span class="s3">, </span><span class="s1">nobs)**</span><span class="s4">2</span>
    <span class="s1">mean_alt = p_alt</span>
    <span class="s1">var_alt = std_prop(p_alt</span><span class="s3">, </span><span class="s1">nobs)**</span><span class="s4">2</span>
    <span class="s3">if </span><span class="s1">variance_prop </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">var_low = var_upp = std_prop(variance_prop</span><span class="s3">, </span><span class="s1">nobs)**</span><span class="s4">2</span>
    <span class="s1">power = _power_ztost(mean_low</span><span class="s3">, </span><span class="s1">var_low</span><span class="s3">, </span><span class="s1">mean_upp</span><span class="s3">, </span><span class="s1">var_upp</span><span class="s3">, </span><span class="s1">mean_alt</span><span class="s3">, </span><span class="s1">var_alt</span><span class="s3">,</span>
                 <span class="s1">alpha=alpha</span><span class="s3">, </span><span class="s1">discrete=discrete</span><span class="s3">, </span><span class="s1">dist=dist</span><span class="s3">, </span><span class="s1">nobs=nobs</span><span class="s3">,</span>
                 <span class="s1">continuity=continuity</span><span class="s3">, </span><span class="s1">critval_continuity=critval_continuity)</span>
    <span class="s3">return </span><span class="s1">np.maximum(power[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">power[</span><span class="s4">1</span><span class="s1">:]</span>


<span class="s3">def </span><span class="s1">_table_proportion(count</span><span class="s3">, </span><span class="s1">nobs):</span>
    <span class="s2">&quot;&quot;&quot; 
    Create a k by 2 contingency table for proportion 
 
    helper function for proportions_chisquare 
 
    Parameters 
    ---------- 
    count : {int, array_like} 
        the number of successes in nobs trials. 
    nobs : int 
        the number of trials or observations. 
 
    Returns 
    ------- 
    table : ndarray 
        (k, 2) contingency table 
 
    Notes 
    ----- 
    recent scipy has more elaborate contingency table functions 
 
    &quot;&quot;&quot;</span>
    <span class="s1">count = np.asarray(count)</span>
    <span class="s1">dt = np.promote_types(count.dtype</span><span class="s3">, </span><span class="s1">np.float64)</span>
    <span class="s1">count = np.asarray(count</span><span class="s3">, </span><span class="s1">dtype=dt)</span>
    <span class="s1">table = np.column_stack((count</span><span class="s3">, </span><span class="s1">nobs - count))</span>
    <span class="s1">expected = table.sum(</span><span class="s4">0</span><span class="s1">) * table.sum(</span><span class="s4">1</span><span class="s1">)[:</span><span class="s3">, None</span><span class="s1">] * </span><span class="s4">1. </span><span class="s1">/ table.sum()</span>
    <span class="s1">n_rows = table.shape[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s3">return </span><span class="s1">table</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">, </span><span class="s1">n_rows</span>


<span class="s3">def </span><span class="s1">proportions_ztest(count</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">value=</span><span class="s3">None, </span><span class="s1">alternative=</span><span class="s5">'two-sided'</span><span class="s3">,</span>
                      <span class="s1">prop_var=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Test for proportions based on normal (z) test 
 
    Parameters 
    ---------- 
    count : {int, array_like} 
        the number of successes in nobs trials. If this is array_like, then 
        the assumption is that this represents the number of successes for 
        each independent sample 
    nobs : {int, array_like} 
        the number of trials or observations, with the same length as 
        count. 
    value : float, array_like or None, optional 
        This is the value of the null hypothesis equal to the proportion in the 
        case of a one sample test. In the case of a two-sample test, the 
        null hypothesis is that prop[0] - prop[1] = value, where prop is the 
        proportion in the two samples. If not provided value = 0 and the null 
        is prop[0] = prop[1] 
    alternative : str in ['two-sided', 'smaller', 'larger'] 
        The alternative hypothesis can be either two-sided or one of the one- 
        sided tests, smaller means that the alternative hypothesis is 
        ``prop &lt; value`` and larger means ``prop &gt; value``. In the two sample 
        test, smaller means that the alternative hypothesis is ``p1 &lt; p2`` and 
        larger means ``p1 &gt; p2`` where ``p1`` is the proportion of the first 
        sample and ``p2`` of the second one. 
    prop_var : False or float in (0, 1) 
        If prop_var is false, then the variance of the proportion estimate is 
        calculated based on the sample proportion. Alternatively, a proportion 
        can be specified to calculate this variance. Common use case is to 
        use the proportion under the Null hypothesis to specify the variance 
        of the proportion estimate. 
 
    Returns 
    ------- 
    zstat : float 
        test statistic for the z-test 
    p-value : float 
        p-value for the z-test 
 
    Examples 
    -------- 
    &gt;&gt;&gt; count = 5 
    &gt;&gt;&gt; nobs = 83 
    &gt;&gt;&gt; value = .05 
    &gt;&gt;&gt; stat, pval = proportions_ztest(count, nobs, value) 
    &gt;&gt;&gt; print('{0:0.3f}'.format(pval)) 
    0.695 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from statsmodels.stats.proportion import proportions_ztest 
    &gt;&gt;&gt; count = np.array([5, 12]) 
    &gt;&gt;&gt; nobs = np.array([83, 99]) 
    &gt;&gt;&gt; stat, pval = proportions_ztest(count, nobs) 
    &gt;&gt;&gt; print('{0:0.3f}'.format(pval)) 
    0.159 
 
    Notes 
    ----- 
    This uses a simple normal test for proportions. It should be the same as 
    running the mean z-test on the data encoded 1 for event and 0 for no event 
    so that the sum corresponds to the count. 
 
    In the one and two sample cases with two-sided alternative, this test 
    produces the same p-value as ``proportions_chisquare``, since the 
    chisquare is the distribution of the square of a standard normal 
    distribution. 
    &quot;&quot;&quot;</span>
    <span class="s0"># TODO: verify that this really holds</span>
    <span class="s0"># TODO: add continuity correction or other improvements for small samples</span>
    <span class="s0"># TODO: change options similar to propotion_ztost ?</span>

    <span class="s1">count = np.asarray(count)</span>
    <span class="s1">nobs = np.asarray(nobs)</span>

    <span class="s3">if </span><span class="s1">nobs.size == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">nobs = nobs * np.ones_like(count)</span>

    <span class="s1">prop = count * </span><span class="s4">1. </span><span class="s1">/ nobs</span>
    <span class="s1">k_sample = np.size(prop)</span>
    <span class="s3">if </span><span class="s1">value </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">k_sample == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'value must be provided for a 1-sample test'</span><span class="s1">)</span>
        <span class="s1">value = </span><span class="s4">0</span>
    <span class="s3">if </span><span class="s1">k_sample == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">diff = prop - value</span>
    <span class="s3">elif </span><span class="s1">k_sample == </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s1">diff = prop[</span><span class="s4">0</span><span class="s1">] - prop[</span><span class="s4">1</span><span class="s1">] - value</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">msg = </span><span class="s5">'more than two samples are not implemented yet'</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(msg)</span>

    <span class="s1">p_pooled = np.sum(count) * </span><span class="s4">1. </span><span class="s1">/ np.sum(nobs)</span>

    <span class="s1">nobs_fact = np.sum(</span><span class="s4">1. </span><span class="s1">/ nobs)</span>
    <span class="s3">if </span><span class="s1">prop_var:</span>
        <span class="s1">p_pooled = prop_var</span>
    <span class="s1">var_ = p_pooled * (</span><span class="s4">1 </span><span class="s1">- p_pooled) * nobs_fact</span>
    <span class="s1">std_diff = np.sqrt(var_)</span>
    <span class="s3">from </span><span class="s1">statsmodels.stats.weightstats </span><span class="s3">import </span><span class="s1">_zstat_generic2</span>
    <span class="s3">return </span><span class="s1">_zstat_generic2(diff</span><span class="s3">, </span><span class="s1">std_diff</span><span class="s3">, </span><span class="s1">alternative)</span>


<span class="s3">def </span><span class="s1">proportions_ztost(count</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">low</span><span class="s3">, </span><span class="s1">upp</span><span class="s3">, </span><span class="s1">prop_var=</span><span class="s5">'sample'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Equivalence test based on normal distribution 
 
    Parameters 
    ---------- 
    count : {int, array_like} 
        the number of successes in nobs trials. If this is array_like, then 
        the assumption is that this represents the number of successes for 
        each independent sample 
    nobs : int 
        the number of trials or observations, with the same length as 
        count. 
    low, upp : float 
        equivalence interval low &lt; prop1 - prop2 &lt; upp 
    prop_var : str or float in (0, 1) 
        prop_var determines which proportion is used for the calculation 
        of the standard deviation of the proportion estimate 
        The available options for string are 'sample' (default), 'null' and 
        'limits'. If prop_var is a float, then it is used directly. 
 
    Returns 
    ------- 
    pvalue : float 
        pvalue of the non-equivalence test 
    t1, pv1 : tuple of floats 
        test statistic and pvalue for lower threshold test 
    t2, pv2 : tuple of floats 
        test statistic and pvalue for upper threshold test 
 
    Notes 
    ----- 
    checked only for 1 sample case 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">prop_var == </span><span class="s5">'limits'</span><span class="s1">:</span>
        <span class="s1">prop_var_low = low</span>
        <span class="s1">prop_var_upp = upp</span>
    <span class="s3">elif </span><span class="s1">prop_var == </span><span class="s5">'sample'</span><span class="s1">:</span>
        <span class="s1">prop_var_low = prop_var_upp = </span><span class="s3">False  </span><span class="s0">#ztest uses sample</span>
    <span class="s3">elif </span><span class="s1">prop_var == </span><span class="s5">'null'</span><span class="s1">:</span>
        <span class="s1">prop_var_low = prop_var_upp = </span><span class="s4">0.5 </span><span class="s1">* (low + upp)</span>
    <span class="s3">elif </span><span class="s1">np.isreal(prop_var):</span>
        <span class="s1">prop_var_low = prop_var_upp = prop_var</span>

    <span class="s1">tt1 = proportions_ztest(count</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">alternative=</span><span class="s5">'larger'</span><span class="s3">,</span>
                            <span class="s1">prop_var=prop_var_low</span><span class="s3">, </span><span class="s1">value=low)</span>
    <span class="s1">tt2 = proportions_ztest(count</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">alternative=</span><span class="s5">'smaller'</span><span class="s3">,</span>
                            <span class="s1">prop_var=prop_var_upp</span><span class="s3">, </span><span class="s1">value=upp)</span>
    <span class="s3">return </span><span class="s1">np.maximum(tt1[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">tt2[</span><span class="s4">1</span><span class="s1">])</span><span class="s3">, </span><span class="s1">tt1</span><span class="s3">, </span><span class="s1">tt2</span><span class="s3">,</span>


<span class="s3">def </span><span class="s1">proportions_chisquare(count</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">value=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Test for proportions based on chisquare test 
 
    Parameters 
    ---------- 
    count : {int, array_like} 
        the number of successes in nobs trials. If this is array_like, then 
        the assumption is that this represents the number of successes for 
        each independent sample 
    nobs : int 
        the number of trials or observations, with the same length as 
        count. 
    value : None or float or array_like 
 
    Returns 
    ------- 
    chi2stat : float 
        test statistic for the chisquare test 
    p-value : float 
        p-value for the chisquare test 
    (table, expected) 
        table is a (k, 2) contingency table, ``expected`` is the corresponding 
        table of counts that are expected under independence with given 
        margins 
 
    Notes 
    ----- 
    Recent version of scipy.stats have a chisquare test for independence in 
    contingency tables. 
 
    This function provides a similar interface to chisquare tests as 
    ``prop.test`` in R, however without the option for Yates continuity 
    correction. 
 
    count can be the count for the number of events for a single proportion, 
    or the counts for several independent proportions. If value is given, then 
    all proportions are jointly tested against this value. If value is not 
    given and count and nobs are not scalar, then the null hypothesis is 
    that all samples have the same proportion. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">nobs = np.atleast_1d(nobs)</span>
    <span class="s1">table</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">, </span><span class="s1">n_rows = _table_proportion(count</span><span class="s3">, </span><span class="s1">nobs)</span>
    <span class="s3">if </span><span class="s1">value </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">expected = np.column_stack((nobs * value</span><span class="s3">, </span><span class="s1">nobs * (</span><span class="s4">1 </span><span class="s1">- value)))</span>
        <span class="s1">ddof = n_rows - </span><span class="s4">1</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">ddof = n_rows</span>

    <span class="s0">#print table, expected</span>
    <span class="s1">chi2stat</span><span class="s3">, </span><span class="s1">pval = stats.chisquare(table.ravel()</span><span class="s3">, </span><span class="s1">expected.ravel()</span><span class="s3">,</span>
                                     <span class="s1">ddof=ddof)</span>
    <span class="s3">return </span><span class="s1">chi2stat</span><span class="s3">, </span><span class="s1">pval</span><span class="s3">, </span><span class="s1">(table</span><span class="s3">, </span><span class="s1">expected)</span>


<span class="s3">def </span><span class="s1">proportions_chisquare_allpairs(count</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">multitest_method=</span><span class="s5">'hs'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Chisquare test of proportions for all pairs of k samples 
 
    Performs a chisquare test for proportions for all pairwise comparisons. 
    The alternative is two-sided 
 
    Parameters 
    ---------- 
    count : {int, array_like} 
        the number of successes in nobs trials. 
    nobs : int 
        the number of trials or observations. 
    multitest_method : str 
        This chooses the method for the multiple testing p-value correction, 
        that is used as default in the results. 
        It can be any method that is available in  ``multipletesting``. 
        The default is Holm-Sidak 'hs'. 
 
    Returns 
    ------- 
    result : AllPairsResults instance 
        The returned results instance has several statistics, such as p-values, 
        attached, and additional methods for using a non-default 
        ``multitest_method``. 
 
    Notes 
    ----- 
    Yates continuity correction is not available. 
    &quot;&quot;&quot;</span>
    <span class="s0">#all_pairs = lmap(list, lzip(*np.triu_indices(4, 1)))</span>
    <span class="s1">all_pairs = lzip(*np.triu_indices(len(count)</span><span class="s3">, </span><span class="s4">1</span><span class="s1">))</span>
    <span class="s1">pvals = [proportions_chisquare(count[list(pair)]</span><span class="s3">, </span><span class="s1">nobs[list(pair)])[</span><span class="s4">1</span><span class="s1">]</span>
               <span class="s3">for </span><span class="s1">pair </span><span class="s3">in </span><span class="s1">all_pairs]</span>
    <span class="s3">return </span><span class="s1">AllPairsResults(pvals</span><span class="s3">, </span><span class="s1">all_pairs</span><span class="s3">, </span><span class="s1">multitest_method=multitest_method)</span>


<span class="s3">def </span><span class="s1">proportions_chisquare_pairscontrol(count</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">value=</span><span class="s3">None,</span>
                               <span class="s1">multitest_method=</span><span class="s5">'hs'</span><span class="s3">, </span><span class="s1">alternative=</span><span class="s5">'two-sided'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Chisquare test of proportions for pairs of k samples compared to control 
 
    Performs a chisquare test for proportions for pairwise comparisons with a 
    control (Dunnet's test). The control is assumed to be the first element 
    of ``count`` and ``nobs``. The alternative is two-sided, larger or 
    smaller. 
 
    Parameters 
    ---------- 
    count : {int, array_like} 
        the number of successes in nobs trials. 
    nobs : int 
        the number of trials or observations. 
    multitest_method : str 
        This chooses the method for the multiple testing p-value correction, 
        that is used as default in the results. 
        It can be any method that is available in  ``multipletesting``. 
        The default is Holm-Sidak 'hs'. 
    alternative : str in ['two-sided', 'smaller', 'larger'] 
        alternative hypothesis, which can be two-sided or either one of the 
        one-sided tests. 
 
    Returns 
    ------- 
    result : AllPairsResults instance 
        The returned results instance has several statistics, such as p-values, 
        attached, and additional methods for using a non-default 
        ``multitest_method``. 
 
 
    Notes 
    ----- 
    Yates continuity correction is not available. 
 
    ``value`` and ``alternative`` options are not yet implemented. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">(value </span><span class="s3">is not None</span><span class="s1">) </span><span class="s3">or </span><span class="s1">(alternative </span><span class="s3">not in </span><span class="s1">[</span><span class="s5">'two-sided'</span><span class="s3">, </span><span class="s5">'2s'</span><span class="s1">]):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span>
    <span class="s0">#all_pairs = lmap(list, lzip(*np.triu_indices(4, 1)))</span>
    <span class="s1">all_pairs = [(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">k) </span><span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">len(count))]</span>
    <span class="s1">pvals = [proportions_chisquare(count[list(pair)]</span><span class="s3">, </span><span class="s1">nobs[list(pair)]</span><span class="s3">,</span>
                                   <span class="s0">#alternative=alternative)[1]</span>
                                   <span class="s1">)[</span><span class="s4">1</span><span class="s1">]</span>
               <span class="s3">for </span><span class="s1">pair </span><span class="s3">in </span><span class="s1">all_pairs]</span>
    <span class="s3">return </span><span class="s1">AllPairsResults(pvals</span><span class="s3">, </span><span class="s1">all_pairs</span><span class="s3">, </span><span class="s1">multitest_method=multitest_method)</span>


<span class="s3">def </span><span class="s1">confint_proportions_2indep(count1</span><span class="s3">, </span><span class="s1">nobs1</span><span class="s3">, </span><span class="s1">count2</span><span class="s3">, </span><span class="s1">nobs2</span><span class="s3">, </span><span class="s1">method=</span><span class="s3">None,</span>
                               <span class="s1">compare=</span><span class="s5">'diff'</span><span class="s3">, </span><span class="s1">alpha=</span><span class="s4">0.05</span><span class="s3">, </span><span class="s1">correction=</span><span class="s3">True</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Confidence intervals for comparing two independent proportions. 
 
    This assumes that we have two independent binomial samples. 
 
    Parameters 
    ---------- 
    count1, nobs1 : float 
        Count and sample size for first sample. 
    count2, nobs2 : float 
        Count and sample size for the second sample. 
    method : str 
        Method for computing confidence interval. If method is None, then a 
        default method is used. The default might change as more methods are 
        added. 
 
        diff: 
         - 'wald', 
         - 'agresti-caffo' 
         - 'newcomb' (default) 
         - 'score' 
 
        ratio: 
         - 'log' 
         - 'log-adjusted' (default) 
         - 'score' 
 
        odds-ratio: 
         - 'logit' 
         - 'logit-adjusted' (default) 
         - 'score' 
 
    compare : string in ['diff', 'ratio' 'odds-ratio'] 
        If compare is diff, then the confidence interval is for diff = p1 - p2. 
        If compare is ratio, then the confidence interval is for the risk ratio 
        defined by ratio = p1 / p2. 
        If compare is odds-ratio, then the confidence interval is for the 
        odds-ratio defined by or = p1 / (1 - p1) / (p2 / (1 - p2). 
    alpha : float 
        Significance level for the confidence interval, default is 0.05. 
        The nominal coverage probability is 1 - alpha. 
 
    Returns 
    ------- 
    low, upp 
 
    See Also 
    -------- 
    test_proportions_2indep 
    tost_proportions_2indep 
 
    Notes 
    ----- 
    Status: experimental, API and defaults might still change. 
        more ``methods`` will be added. 
 
    References 
    ---------- 
    .. [1] Fagerland, Morten W., Stian Lydersen, and Petter Laake. 2015. 
       “Recommended Confidence Intervals for Two Independent Binomial 
       Proportions.” Statistical Methods in Medical Research 24 (2): 224–54. 
       https://doi.org/10.1177/0962280211415469. 
    .. [2] Koopman, P. A. R. 1984. “Confidence Intervals for the Ratio of Two 
       Binomial Proportions.” Biometrics 40 (2): 513–17. 
       https://doi.org/10.2307/2531405. 
    .. [3] Miettinen, Olli, and Markku Nurminen. &quot;Comparative analysis of two 
       rates.&quot; Statistics in medicine 4, no. 2 (1985): 213-226. 
    .. [4] Newcombe, Robert G. 1998. “Interval Estimation for the Difference 
       between Independent Proportions: Comparison of Eleven Methods.” 
       Statistics in Medicine 17 (8): 873–90. 
       https://doi.org/10.1002/(SICI)1097-0258(19980430)17:8&lt;873::AID- 
       SIM779&gt;3.0.CO;2-I. 
    .. [5] Newcombe, Robert G., and Markku M. Nurminen. 2011. “In Defence of 
       Score Intervals for Proportions and Their Differences.” Communications 
       in Statistics - Theory and Methods 40 (7): 1271–82. 
       https://doi.org/10.1080/03610920903576580. 
    &quot;&quot;&quot;</span>
    <span class="s1">method_default = {</span><span class="s5">'diff'</span><span class="s1">: </span><span class="s5">'newcomb'</span><span class="s3">,</span>
                      <span class="s5">'ratio'</span><span class="s1">: </span><span class="s5">'log-adjusted'</span><span class="s3">,</span>
                      <span class="s5">'odds-ratio'</span><span class="s1">: </span><span class="s5">'logit-adjusted'</span><span class="s1">}</span>
    <span class="s0"># normalize compare name</span>
    <span class="s3">if </span><span class="s1">compare.lower() == </span><span class="s5">'or'</span><span class="s1">:</span>
        <span class="s1">compare = </span><span class="s5">'odds-ratio'</span>
    <span class="s3">if </span><span class="s1">method </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">method = method_default[compare]</span>

    <span class="s1">method = method.lower()</span>
    <span class="s3">if </span><span class="s1">method.startswith(</span><span class="s5">'agr'</span><span class="s1">):</span>
        <span class="s1">method = </span><span class="s5">'agresti-caffo'</span>

    <span class="s1">p1 = count1 / nobs1</span>
    <span class="s1">p2 = count2 / nobs2</span>
    <span class="s1">diff = p1 - p2</span>
    <span class="s1">addone = </span><span class="s4">1 </span><span class="s3">if </span><span class="s1">method == </span><span class="s5">'agresti-caffo' </span><span class="s3">else </span><span class="s4">0</span>

    <span class="s3">if </span><span class="s1">compare == </span><span class="s5">'diff'</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">method </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'wald'</span><span class="s3">, </span><span class="s5">'agresti-caffo'</span><span class="s1">]:</span>
            <span class="s1">count1_</span><span class="s3">, </span><span class="s1">nobs1_ = count1 + addone</span><span class="s3">, </span><span class="s1">nobs1 + </span><span class="s4">2 </span><span class="s1">* addone</span>
            <span class="s1">count2_</span><span class="s3">, </span><span class="s1">nobs2_ = count2 + addone</span><span class="s3">, </span><span class="s1">nobs2 + </span><span class="s4">2 </span><span class="s1">* addone</span>
            <span class="s1">p1_ = count1_ / nobs1_</span>
            <span class="s1">p2_ = count2_ / nobs2_</span>
            <span class="s1">diff_ = p1_ - p2_</span>
            <span class="s1">var = p1_ * (</span><span class="s4">1 </span><span class="s1">- p1_) / nobs1_ + p2_ * (</span><span class="s4">1 </span><span class="s1">- p2_) / nobs2_</span>
            <span class="s1">z = stats.norm.isf(alpha / </span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">d_wald = z * np.sqrt(var)</span>
            <span class="s1">low = diff_ - d_wald</span>
            <span class="s1">upp = diff_ + d_wald</span>

        <span class="s3">elif </span><span class="s1">method.startswith(</span><span class="s5">'newcomb'</span><span class="s1">):</span>
            <span class="s1">low1</span><span class="s3">, </span><span class="s1">upp1 = proportion_confint(count1</span><span class="s3">, </span><span class="s1">nobs1</span><span class="s3">,</span>
                                            <span class="s1">method=</span><span class="s5">'wilson'</span><span class="s3">, </span><span class="s1">alpha=alpha)</span>
            <span class="s1">low2</span><span class="s3">, </span><span class="s1">upp2 = proportion_confint(count2</span><span class="s3">, </span><span class="s1">nobs2</span><span class="s3">,</span>
                                            <span class="s1">method=</span><span class="s5">'wilson'</span><span class="s3">, </span><span class="s1">alpha=alpha)</span>
            <span class="s1">d_low = np.sqrt((p1 - low1)**</span><span class="s4">2 </span><span class="s1">+ (upp2 - p2)**</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">d_upp = np.sqrt((p2 - low2)**</span><span class="s4">2 </span><span class="s1">+ (upp1 - p1)**</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">low = diff - d_low</span>
            <span class="s1">upp = diff + d_upp</span>

        <span class="s3">elif </span><span class="s1">method == </span><span class="s5">&quot;score&quot;</span><span class="s1">:</span>
            <span class="s1">low</span><span class="s3">, </span><span class="s1">upp = _score_confint_inversion(count1</span><span class="s3">, </span><span class="s1">nobs1</span><span class="s3">, </span><span class="s1">count2</span><span class="s3">, </span><span class="s1">nobs2</span><span class="s3">,</span>
                                                <span class="s1">compare=compare</span><span class="s3">, </span><span class="s1">alpha=alpha</span><span class="s3">,</span>
                                                <span class="s1">correction=correction)</span>

        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'method not recognized'</span><span class="s1">)</span>

    <span class="s3">elif </span><span class="s1">compare == </span><span class="s5">'ratio'</span><span class="s1">:</span>
        <span class="s0"># ratio = p1 / p2</span>
        <span class="s3">if </span><span class="s1">method </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'log'</span><span class="s3">, </span><span class="s5">'log-adjusted'</span><span class="s1">]:</span>
            <span class="s1">addhalf = </span><span class="s4">0.5 </span><span class="s3">if </span><span class="s1">method == </span><span class="s5">'log-adjusted' </span><span class="s3">else </span><span class="s4">0</span>
            <span class="s1">count1_</span><span class="s3">, </span><span class="s1">nobs1_ = count1 + addhalf</span><span class="s3">, </span><span class="s1">nobs1 + addhalf</span>
            <span class="s1">count2_</span><span class="s3">, </span><span class="s1">nobs2_ = count2 + addhalf</span><span class="s3">, </span><span class="s1">nobs2 + addhalf</span>
            <span class="s1">p1_ = count1_ / nobs1_</span>
            <span class="s1">p2_ = count2_ / nobs2_</span>
            <span class="s1">ratio_ = p1_ / p2_</span>
            <span class="s1">var = (</span><span class="s4">1 </span><span class="s1">/ count1_) - </span><span class="s4">1 </span><span class="s1">/ nobs1_ + </span><span class="s4">1 </span><span class="s1">/ count2_ - </span><span class="s4">1 </span><span class="s1">/ nobs2_</span>
            <span class="s1">z = stats.norm.isf(alpha / </span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">d_log = z * np.sqrt(var)</span>
            <span class="s1">low = np.exp(np.log(ratio_) - d_log)</span>
            <span class="s1">upp = np.exp(np.log(ratio_) + d_log)</span>

        <span class="s3">elif </span><span class="s1">method == </span><span class="s5">'score'</span><span class="s1">:</span>
            <span class="s1">res = _confint_riskratio_koopman(count1</span><span class="s3">, </span><span class="s1">nobs1</span><span class="s3">, </span><span class="s1">count2</span><span class="s3">, </span><span class="s1">nobs2</span><span class="s3">,</span>
                                             <span class="s1">alpha=alpha</span><span class="s3">,</span>
                                             <span class="s1">correction=correction)</span>
            <span class="s1">low</span><span class="s3">, </span><span class="s1">upp = res.confint</span>

        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'method not recognized'</span><span class="s1">)</span>

    <span class="s3">elif </span><span class="s1">compare == </span><span class="s5">'odds-ratio'</span><span class="s1">:</span>
        <span class="s0"># odds_ratio = p1 / (1 - p1) / p2 * (1 - p2)</span>
        <span class="s3">if </span><span class="s1">method </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'logit'</span><span class="s3">, </span><span class="s5">'logit-adjusted'</span><span class="s3">, </span><span class="s5">'logit-smoothed'</span><span class="s1">]:</span>
            <span class="s3">if </span><span class="s1">method </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'logit-smoothed'</span><span class="s1">]:</span>
                <span class="s1">adjusted = _shrink_prob(count1</span><span class="s3">, </span><span class="s1">nobs1</span><span class="s3">, </span><span class="s1">count2</span><span class="s3">, </span><span class="s1">nobs2</span><span class="s3">,</span>
                                        <span class="s1">shrink_factor=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">return_corr=</span><span class="s3">False</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s1">count1_</span><span class="s3">, </span><span class="s1">nobs1_</span><span class="s3">, </span><span class="s1">count2_</span><span class="s3">, </span><span class="s1">nobs2_ = adjusted</span>

            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">addhalf = </span><span class="s4">0.5 </span><span class="s3">if </span><span class="s1">method == </span><span class="s5">'logit-adjusted' </span><span class="s3">else </span><span class="s4">0</span>
                <span class="s1">count1_</span><span class="s3">, </span><span class="s1">nobs1_ = count1 + addhalf</span><span class="s3">, </span><span class="s1">nobs1 + </span><span class="s4">2 </span><span class="s1">* addhalf</span>
                <span class="s1">count2_</span><span class="s3">, </span><span class="s1">nobs2_ = count2 + addhalf</span><span class="s3">, </span><span class="s1">nobs2 + </span><span class="s4">2 </span><span class="s1">* addhalf</span>
            <span class="s1">p1_ = count1_ / nobs1_</span>
            <span class="s1">p2_ = count2_ / nobs2_</span>
            <span class="s1">odds_ratio_ = p1_ / (</span><span class="s4">1 </span><span class="s1">- p1_) / p2_ * (</span><span class="s4">1 </span><span class="s1">- p2_)</span>
            <span class="s1">var = (</span><span class="s4">1 </span><span class="s1">/ count1_ + </span><span class="s4">1 </span><span class="s1">/ (nobs1_ - count1_) +</span>
                   <span class="s4">1 </span><span class="s1">/ count2_ + </span><span class="s4">1 </span><span class="s1">/ (nobs2_ - count2_))</span>
            <span class="s1">z = stats.norm.isf(alpha / </span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">d_log = z * np.sqrt(var)</span>
            <span class="s1">low = np.exp(np.log(odds_ratio_) - d_log)</span>
            <span class="s1">upp = np.exp(np.log(odds_ratio_) + d_log)</span>

        <span class="s3">elif </span><span class="s1">method == </span><span class="s5">&quot;score&quot;</span><span class="s1">:</span>
            <span class="s1">low</span><span class="s3">, </span><span class="s1">upp = _score_confint_inversion(count1</span><span class="s3">, </span><span class="s1">nobs1</span><span class="s3">, </span><span class="s1">count2</span><span class="s3">, </span><span class="s1">nobs2</span><span class="s3">,</span>
                                                <span class="s1">compare=compare</span><span class="s3">, </span><span class="s1">alpha=alpha</span><span class="s3">,</span>
                                                <span class="s1">correction=correction)</span>

        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'method not recognized'</span><span class="s1">)</span>

    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'compare not recognized'</span><span class="s1">)</span>

    <span class="s3">return </span><span class="s1">low</span><span class="s3">, </span><span class="s1">upp</span>


<span class="s3">def </span><span class="s1">_shrink_prob(count1</span><span class="s3">, </span><span class="s1">nobs1</span><span class="s3">, </span><span class="s1">count2</span><span class="s3">, </span><span class="s1">nobs2</span><span class="s3">, </span><span class="s1">shrink_factor=</span><span class="s4">2</span><span class="s3">,</span>
                 <span class="s1">return_corr=</span><span class="s3">True</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Shrink observed counts towards independence 
 
    Helper function for 'logit-smoothed' inference for the odds-ratio of two 
    independent proportions. 
 
    Parameters 
    ---------- 
    count1, nobs1 : float or int 
        count and sample size for first sample 
    count2, nobs2 : float or int 
        count and sample size for the second sample 
    shrink_factor : float 
        This corresponds to the number of observations that are added in total 
        proportional to the probabilities under independence. 
    return_corr : bool 
        If true, then only the correction term is returned 
        If false, then the corrected counts, i.e. original counts plus 
        correction term, are returned. 
 
    Returns 
    ------- 
    count1_corr, nobs1_corr, count2_corr, nobs2_corr : float 
        correction or corrected counts 
    prob_indep : 
        TODO/Warning : this will change most likely 
        probabilities under independence, only returned if return_corr is 
        false. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">vectorized = any(np.size(i) &gt; </span><span class="s4">1 </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">[count1</span><span class="s3">, </span><span class="s1">nobs1</span><span class="s3">, </span><span class="s1">count2</span><span class="s3">, </span><span class="s1">nobs2])</span>
    <span class="s3">if </span><span class="s1">vectorized:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;function is not vectorized&quot;</span><span class="s1">)</span>
    <span class="s1">nobs_col = np.array([count1 + count2</span><span class="s3">, </span><span class="s1">nobs1 - count1 + nobs2 - count2])</span>
    <span class="s1">nobs_row = np.array([nobs1</span><span class="s3">, </span><span class="s1">nobs2])</span>
    <span class="s1">nobs = nobs1 + nobs2</span>
    <span class="s1">prob_indep = (nobs_col * nobs_row[:</span><span class="s3">, None</span><span class="s1">]) / nobs**</span><span class="s4">2</span>
    <span class="s1">corr = shrink_factor * prob_indep</span>
    <span class="s3">if </span><span class="s1">return_corr:</span>
        <span class="s3">return </span><span class="s1">(corr[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">corr[</span><span class="s4">0</span><span class="s1">].sum()</span><span class="s3">, </span><span class="s1">corr[</span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">corr[</span><span class="s4">1</span><span class="s1">].sum())</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">(count1 + corr[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">nobs1 + corr[</span><span class="s4">0</span><span class="s1">].sum()</span><span class="s3">,</span>
                <span class="s1">count2 + corr[</span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">nobs2 + corr[</span><span class="s4">1</span><span class="s1">].sum())</span><span class="s3">, </span><span class="s1">prob_indep</span>


<span class="s3">def </span><span class="s1">score_test_proportions_2indep(count1</span><span class="s3">, </span><span class="s1">nobs1</span><span class="s3">, </span><span class="s1">count2</span><span class="s3">, </span><span class="s1">nobs2</span><span class="s3">, </span><span class="s1">value=</span><span class="s3">None,</span>
                                  <span class="s1">compare=</span><span class="s5">'diff'</span><span class="s3">, </span><span class="s1">alternative=</span><span class="s5">'two-sided'</span><span class="s3">,</span>
                                  <span class="s1">correction=</span><span class="s3">True, </span><span class="s1">return_results=</span><span class="s3">True</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Score test for two independent proportions 
 
    This uses the constrained estimate of the proportions to compute 
    the variance under the Null hypothesis. 
 
    Parameters 
    ---------- 
    count1, nobs1 : 
        count and sample size for first sample 
    count2, nobs2 : 
        count and sample size for the second sample 
    value : float 
        diff, ratio or odds-ratio under the null hypothesis. If value is None, 
        then equality of proportions under the Null is assumed, 
        i.e. value=0 for 'diff' or value=1 for either rate or odds-ratio. 
    compare : string in ['diff', 'ratio' 'odds-ratio'] 
        If compare is diff, then the confidence interval is for diff = p1 - p2. 
        If compare is ratio, then the confidence interval is for the risk ratio 
        defined by ratio = p1 / p2. 
        If compare is odds-ratio, then the confidence interval is for the 
        odds-ratio defined by or = p1 / (1 - p1) / (p2 / (1 - p2) 
    return_results : bool 
        If true, then a results instance with extra information is returned, 
        otherwise a tuple with statistic and pvalue is returned. 
 
    Returns 
    ------- 
    results : results instance or tuple 
        If return_results is True, then a results instance with the 
        information in attributes is returned. 
        If return_results is False, then only ``statistic`` and ``pvalue`` 
        are returned. 
 
        statistic : float 
            test statistic asymptotically normal distributed N(0, 1) 
        pvalue : float 
            p-value based on normal distribution 
        other attributes : 
            additional information about the hypothesis test 
 
    Notes 
    ----- 
    Status: experimental, the type or extra information in the return might 
    change. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">value_default = </span><span class="s4">0 </span><span class="s3">if </span><span class="s1">compare == </span><span class="s5">'diff' </span><span class="s3">else </span><span class="s4">1</span>
    <span class="s3">if </span><span class="s1">value </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s0"># TODO: odds ratio does not work if value=1</span>
        <span class="s1">value = value_default</span>

    <span class="s1">nobs = nobs1 + nobs2</span>
    <span class="s1">count = count1 + count2</span>
    <span class="s1">p1 = count1 / nobs1</span>
    <span class="s1">p2 = count2 / nobs2</span>
    <span class="s3">if </span><span class="s1">value == value_default:</span>
        <span class="s0"># use pooled estimator if equality test</span>
        <span class="s0"># shortcut, but required for odds ratio</span>
        <span class="s1">prop0 = prop1 = count / nobs</span>
    <span class="s0"># this uses index 0 from Miettinen Nurminned 1985</span>
    <span class="s1">count0</span><span class="s3">, </span><span class="s1">nobs0 = count2</span><span class="s3">, </span><span class="s1">nobs2</span>
    <span class="s1">p0 = p2</span>

    <span class="s3">if </span><span class="s1">compare == </span><span class="s5">'diff'</span><span class="s1">:</span>
        <span class="s1">diff = value  </span><span class="s0"># hypothesis value</span>

        <span class="s3">if </span><span class="s1">diff != </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">tmp3 = nobs</span>
            <span class="s1">tmp2 = (nobs1 + </span><span class="s4">2 </span><span class="s1">* nobs0) * diff - nobs - count</span>
            <span class="s1">tmp1 = (count0 * diff - nobs - </span><span class="s4">2 </span><span class="s1">* count0) * diff + count</span>
            <span class="s1">tmp0 = count0 * diff * (</span><span class="s4">1 </span><span class="s1">- diff)</span>
            <span class="s1">q = ((tmp2 / (</span><span class="s4">3 </span><span class="s1">* tmp3))**</span><span class="s4">3 </span><span class="s1">- tmp1 * tmp2 / (</span><span class="s4">6 </span><span class="s1">* tmp3**</span><span class="s4">2</span><span class="s1">) +</span>
                 <span class="s1">tmp0 / (</span><span class="s4">2 </span><span class="s1">* tmp3))</span>
            <span class="s1">p = np.sign(q) * np.sqrt((tmp2 / (</span><span class="s4">3 </span><span class="s1">* tmp3))**</span><span class="s4">2 </span><span class="s1">-</span>
                                     <span class="s1">tmp1 / (</span><span class="s4">3 </span><span class="s1">* tmp3))</span>
            <span class="s1">a = (np.pi + np.arccos(q / p**</span><span class="s4">3</span><span class="s1">)) / </span><span class="s4">3</span>

            <span class="s1">prop0 = </span><span class="s4">2 </span><span class="s1">* p * np.cos(a) - tmp2 / (</span><span class="s4">3 </span><span class="s1">* tmp3)</span>
            <span class="s1">prop1 = prop0 + diff</span>

        <span class="s1">var = prop1 * (</span><span class="s4">1 </span><span class="s1">- prop1) / nobs1 + prop0 * (</span><span class="s4">1 </span><span class="s1">- prop0) / nobs0</span>
        <span class="s3">if </span><span class="s1">correction:</span>
            <span class="s1">var *= nobs / (nobs - </span><span class="s4">1</span><span class="s1">)</span>

        <span class="s1">diff_stat = (p1 - p0 - diff)</span>

    <span class="s3">elif </span><span class="s1">compare == </span><span class="s5">'ratio'</span><span class="s1">:</span>
        <span class="s0"># risk ratio</span>
        <span class="s1">ratio = value</span>

        <span class="s3">if </span><span class="s1">ratio != </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">a = nobs * ratio</span>
            <span class="s1">b = -(nobs1 * ratio + count1 + nobs2 + count0 * ratio)</span>
            <span class="s1">c = count</span>
            <span class="s1">prop0 = (-b - np.sqrt(b**</span><span class="s4">2 </span><span class="s1">- </span><span class="s4">4 </span><span class="s1">* a * c)) / (</span><span class="s4">2 </span><span class="s1">* a)</span>
            <span class="s1">prop1 = prop0 * ratio</span>

        <span class="s1">var = (prop1 * (</span><span class="s4">1 </span><span class="s1">- prop1) / nobs1 +</span>
               <span class="s1">ratio**</span><span class="s4">2 </span><span class="s1">* prop0 * (</span><span class="s4">1 </span><span class="s1">- prop0) / nobs0)</span>
        <span class="s3">if </span><span class="s1">correction:</span>
            <span class="s1">var *= nobs / (nobs - </span><span class="s4">1</span><span class="s1">)</span>

        <span class="s0"># NCSS looks incorrect for var, but it is what should be reported</span>
        <span class="s0"># diff_stat = (p1 / p0 - ratio)   # NCSS/PASS</span>
        <span class="s1">diff_stat = (p1 - ratio * p0)  </span><span class="s0"># Miettinen Nurminen</span>

    <span class="s3">elif </span><span class="s1">compare </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'or'</span><span class="s3">, </span><span class="s5">'odds-ratio'</span><span class="s1">]:</span>
        <span class="s0"># odds ratio</span>
        <span class="s1">oratio = value</span>

        <span class="s3">if </span><span class="s1">oratio != </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s0"># Note the constraint estimator does not handle odds-ratio = 1</span>
            <span class="s1">a = nobs0 * (oratio - </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">b = nobs1 * oratio + nobs0 - count * (oratio - </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">c = -count</span>
            <span class="s1">prop0 = (-b + np.sqrt(b**</span><span class="s4">2 </span><span class="s1">- </span><span class="s4">4 </span><span class="s1">* a * c)) / (</span><span class="s4">2 </span><span class="s1">* a)</span>
            <span class="s1">prop1 = prop0 * oratio / (</span><span class="s4">1 </span><span class="s1">+ prop0 * (oratio - </span><span class="s4">1</span><span class="s1">))</span>

        <span class="s0"># try to avoid 0 and 1 proportions,</span>
        <span class="s0"># those raise Zero Division Runtime Warnings</span>
        <span class="s1">eps = </span><span class="s4">1e-10</span>
        <span class="s1">prop0 = np.clip(prop0</span><span class="s3">, </span><span class="s1">eps</span><span class="s3">, </span><span class="s4">1 </span><span class="s1">- eps)</span>
        <span class="s1">prop1 = np.clip(prop1</span><span class="s3">, </span><span class="s1">eps</span><span class="s3">, </span><span class="s4">1 </span><span class="s1">- eps)</span>

        <span class="s1">var = (</span><span class="s4">1 </span><span class="s1">/ (prop1 * (</span><span class="s4">1 </span><span class="s1">- prop1) * nobs1) +</span>
               <span class="s4">1 </span><span class="s1">/ (prop0 * (</span><span class="s4">1 </span><span class="s1">- prop0) * nobs0))</span>
        <span class="s3">if </span><span class="s1">correction:</span>
            <span class="s1">var *= nobs / (nobs - </span><span class="s4">1</span><span class="s1">)</span>

        <span class="s1">diff_stat = ((p1 - prop1) / (prop1 * (</span><span class="s4">1 </span><span class="s1">- prop1)) -</span>
                     <span class="s1">(p0 - prop0) / (prop0 * (</span><span class="s4">1 </span><span class="s1">- prop0)))</span>

    <span class="s1">statistic</span><span class="s3">, </span><span class="s1">pvalue = _zstat_generic2(diff_stat</span><span class="s3">, </span><span class="s1">np.sqrt(var)</span><span class="s3">,</span>
                                        <span class="s1">alternative=alternative)</span>

    <span class="s3">if </span><span class="s1">return_results:</span>
        <span class="s1">res = HolderTuple(statistic=statistic</span><span class="s3">,</span>
                          <span class="s1">pvalue=pvalue</span><span class="s3">,</span>
                          <span class="s1">compare=compare</span><span class="s3">,</span>
                          <span class="s1">method=</span><span class="s5">'score'</span><span class="s3">,</span>
                          <span class="s1">variance=var</span><span class="s3">,</span>
                          <span class="s1">alternative=alternative</span><span class="s3">,</span>
                          <span class="s1">prop1_null=prop1</span><span class="s3">,</span>
                          <span class="s1">prop2_null=prop0</span><span class="s3">,</span>
                          <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">res</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">statistic</span><span class="s3">, </span><span class="s1">pvalue</span>


<span class="s3">def </span><span class="s1">test_proportions_2indep(count1</span><span class="s3">, </span><span class="s1">nobs1</span><span class="s3">, </span><span class="s1">count2</span><span class="s3">, </span><span class="s1">nobs2</span><span class="s3">, </span><span class="s1">value=</span><span class="s3">None,</span>
                            <span class="s1">method=</span><span class="s3">None, </span><span class="s1">compare=</span><span class="s5">'diff'</span><span class="s3">,</span>
                            <span class="s1">alternative=</span><span class="s5">'two-sided'</span><span class="s3">, </span><span class="s1">correction=</span><span class="s3">True,</span>
                            <span class="s1">return_results=</span><span class="s3">True</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Hypothesis test for comparing two independent proportions 
 
    This assumes that we have two independent binomial samples. 
 
    The Null and alternative hypothesis are 
 
    for compare = 'diff' 
 
    - H0: prop1 - prop2 - value = 0 
    - H1: prop1 - prop2 - value != 0  if alternative = 'two-sided' 
    - H1: prop1 - prop2 - value &gt; 0   if alternative = 'larger' 
    - H1: prop1 - prop2 - value &lt; 0   if alternative = 'smaller' 
 
    for compare = 'ratio' 
 
    - H0: prop1 / prop2 - value = 0 
    - H1: prop1 / prop2 - value != 0  if alternative = 'two-sided' 
    - H1: prop1 / prop2 - value &gt; 0   if alternative = 'larger' 
    - H1: prop1 / prop2 - value &lt; 0   if alternative = 'smaller' 
 
    for compare = 'odds-ratio' 
 
    - H0: or - value = 0 
    - H1: or - value != 0  if alternative = 'two-sided' 
    - H1: or - value &gt; 0   if alternative = 'larger' 
    - H1: or - value &lt; 0   if alternative = 'smaller' 
 
    where odds-ratio or = prop1 / (1 - prop1) / (prop2 / (1 - prop2)) 
 
    Parameters 
    ---------- 
    count1 : int 
        Count for first sample. 
    nobs1 : int 
        Sample size for first sample. 
    count2 : int 
        Count for the second sample. 
    nobs2 : int 
        Sample size for the second sample. 
    value : float 
        Value of the difference, risk ratio or odds ratio of 2 independent 
        proportions under the null hypothesis. 
        Default is equal proportions, 0 for diff and 1 for risk-ratio and for 
        odds-ratio. 
    method : string 
        Method for computing the hypothesis test. If method is None, then a 
        default method is used. The default might change as more methods are 
        added. 
 
        diff: 
 
        - 'wald', 
        - 'agresti-caffo' 
        - 'score' if correction is True, then this uses the degrees of freedom 
           correction ``nobs / (nobs - 1)`` as in Miettinen Nurminen 1985 
 
        ratio: 
 
        - 'log': wald test using log transformation 
        - 'log-adjusted': wald test using log transformation, 
           adds 0.5 to counts 
        - 'score': if correction is True, then this uses the degrees of freedom 
           correction ``nobs / (nobs - 1)`` as in Miettinen Nurminen 1985 
 
        odds-ratio: 
 
        - 'logit': wald test using logit transformation 
        - 'logit-adjusted': wald test using logit transformation, 
           adds 0.5 to counts 
        - 'logit-smoothed': wald test using logit transformation, biases 
           cell counts towards independence by adding two observations in 
           total. 
        - 'score' if correction is True, then this uses the degrees of freedom 
           correction ``nobs / (nobs - 1)`` as in Miettinen Nurminen 1985 
 
    compare : {'diff', 'ratio' 'odds-ratio'} 
        If compare is `diff`, then the hypothesis test is for the risk 
        difference diff = p1 - p2. 
        If compare is `ratio`, then the hypothesis test is for the 
        risk ratio defined by ratio = p1 / p2. 
        If compare is `odds-ratio`, then the hypothesis test is for the 
        odds-ratio defined by or = p1 / (1 - p1) / (p2 / (1 - p2) 
    alternative : {'two-sided', 'smaller', 'larger'} 
        alternative hypothesis, which can be two-sided or either one of the 
        one-sided tests. 
    correction : bool 
        If correction is True (default), then the Miettinen and Nurminen 
        small sample correction to the variance nobs / (nobs - 1) is used. 
        Applies only if method='score'. 
    return_results : bool 
        If true, then a results instance with extra information is returned, 
        otherwise a tuple with statistic and pvalue is returned. 
 
    Returns 
    ------- 
    results : results instance or tuple 
        If return_results is True, then a results instance with the 
        information in attributes is returned. 
        If return_results is False, then only ``statistic`` and ``pvalue`` 
        are returned. 
 
        statistic : float 
            test statistic asymptotically normal distributed N(0, 1) 
        pvalue : float 
            p-value based on normal distribution 
        other attributes : 
            additional information about the hypothesis test 
 
    See Also 
    -------- 
    tost_proportions_2indep 
    confint_proportions_2indep 
 
    Notes 
    ----- 
    Status: experimental, API and defaults might still change. 
        More ``methods`` will be added. 
 
    The current default methods are 
 
    - 'diff': 'agresti-caffo', 
    - 'ratio': 'log-adjusted', 
    - 'odds-ratio': 'logit-adjusted' 
 
    &quot;&quot;&quot;</span>
    <span class="s1">method_default = {</span><span class="s5">'diff'</span><span class="s1">: </span><span class="s5">'agresti-caffo'</span><span class="s3">,</span>
                      <span class="s5">'ratio'</span><span class="s1">: </span><span class="s5">'log-adjusted'</span><span class="s3">,</span>
                      <span class="s5">'odds-ratio'</span><span class="s1">: </span><span class="s5">'logit-adjusted'</span><span class="s1">}</span>
    <span class="s0"># normalize compare name</span>
    <span class="s3">if </span><span class="s1">compare.lower() == </span><span class="s5">'or'</span><span class="s1">:</span>
        <span class="s1">compare = </span><span class="s5">'odds-ratio'</span>
    <span class="s3">if </span><span class="s1">method </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">method = method_default[compare]</span>

    <span class="s1">method = method.lower()</span>
    <span class="s3">if </span><span class="s1">method.startswith(</span><span class="s5">'agr'</span><span class="s1">):</span>
        <span class="s1">method = </span><span class="s5">'agresti-caffo'</span>

    <span class="s3">if </span><span class="s1">value </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s0"># TODO: odds ratio does not work if value=1 for score test</span>
        <span class="s1">value = </span><span class="s4">0 </span><span class="s3">if </span><span class="s1">compare == </span><span class="s5">'diff' </span><span class="s3">else </span><span class="s4">1</span>

    <span class="s1">count1</span><span class="s3">, </span><span class="s1">nobs1</span><span class="s3">, </span><span class="s1">count2</span><span class="s3">, </span><span class="s1">nobs2 = map(np.asarray</span><span class="s3">,</span>
                                       <span class="s1">[count1</span><span class="s3">, </span><span class="s1">nobs1</span><span class="s3">, </span><span class="s1">count2</span><span class="s3">, </span><span class="s1">nobs2])</span>

    <span class="s1">p1 = count1 / nobs1</span>
    <span class="s1">p2 = count2 / nobs2</span>
    <span class="s1">diff = p1 - p2</span>
    <span class="s1">ratio = p1 / p2</span>
    <span class="s1">odds_ratio = p1 / (</span><span class="s4">1 </span><span class="s1">- p1) / p2 * (</span><span class="s4">1 </span><span class="s1">- p2)</span>
    <span class="s1">res = </span><span class="s3">None</span>

    <span class="s3">if </span><span class="s1">compare == </span><span class="s5">'diff'</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">method </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'wald'</span><span class="s3">, </span><span class="s5">'agresti-caffo'</span><span class="s1">]:</span>
            <span class="s1">addone = </span><span class="s4">1 </span><span class="s3">if </span><span class="s1">method == </span><span class="s5">'agresti-caffo' </span><span class="s3">else </span><span class="s4">0</span>
            <span class="s1">count1_</span><span class="s3">, </span><span class="s1">nobs1_ = count1 + addone</span><span class="s3">, </span><span class="s1">nobs1 + </span><span class="s4">2 </span><span class="s1">* addone</span>
            <span class="s1">count2_</span><span class="s3">, </span><span class="s1">nobs2_ = count2 + addone</span><span class="s3">, </span><span class="s1">nobs2 + </span><span class="s4">2 </span><span class="s1">* addone</span>
            <span class="s1">p1_ = count1_ / nobs1_</span>
            <span class="s1">p2_ = count2_ / nobs2_</span>
            <span class="s1">diff_stat = p1_ - p2_ - value</span>
            <span class="s1">var = p1_ * (</span><span class="s4">1 </span><span class="s1">- p1_) / nobs1_ + p2_ * (</span><span class="s4">1 </span><span class="s1">- p2_) / nobs2_</span>
            <span class="s1">statistic = diff_stat / np.sqrt(var)</span>
            <span class="s1">distr = </span><span class="s5">'normal'</span>

        <span class="s3">elif </span><span class="s1">method.startswith(</span><span class="s5">'newcomb'</span><span class="s1">):</span>
            <span class="s1">msg = </span><span class="s5">'newcomb not available for hypothesis test'</span>
            <span class="s3">raise </span><span class="s1">NotImplementedError(msg)</span>

        <span class="s3">elif </span><span class="s1">method == </span><span class="s5">'score'</span><span class="s1">:</span>
            <span class="s0"># Note score part is the same call for all compare</span>
            <span class="s1">res = score_test_proportions_2indep(count1</span><span class="s3">, </span><span class="s1">nobs1</span><span class="s3">, </span><span class="s1">count2</span><span class="s3">, </span><span class="s1">nobs2</span><span class="s3">,</span>
                                                <span class="s1">value=value</span><span class="s3">, </span><span class="s1">compare=compare</span><span class="s3">,</span>
                                                <span class="s1">alternative=alternative</span><span class="s3">,</span>
                                                <span class="s1">correction=correction</span><span class="s3">,</span>
                                                <span class="s1">return_results=return_results)</span>
            <span class="s3">if </span><span class="s1">return_results </span><span class="s3">is False</span><span class="s1">:</span>
                <span class="s1">statistic</span><span class="s3">, </span><span class="s1">pvalue = res[:</span><span class="s4">2</span><span class="s1">]</span>
            <span class="s1">distr = </span><span class="s5">'normal'</span>
            <span class="s0"># TODO/Note score_test_proportion_2samp returns statistic  and</span>
            <span class="s0">#     not diff_stat</span>
            <span class="s1">diff_stat = </span><span class="s3">None</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'method not recognized'</span><span class="s1">)</span>

    <span class="s3">elif </span><span class="s1">compare == </span><span class="s5">'ratio'</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">method </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'log'</span><span class="s3">, </span><span class="s5">'log-adjusted'</span><span class="s1">]:</span>
            <span class="s1">addhalf = </span><span class="s4">0.5 </span><span class="s3">if </span><span class="s1">method == </span><span class="s5">'log-adjusted' </span><span class="s3">else </span><span class="s4">0</span>
            <span class="s1">count1_</span><span class="s3">, </span><span class="s1">nobs1_ = count1 + addhalf</span><span class="s3">, </span><span class="s1">nobs1 + addhalf</span>
            <span class="s1">count2_</span><span class="s3">, </span><span class="s1">nobs2_ = count2 + addhalf</span><span class="s3">, </span><span class="s1">nobs2 + addhalf</span>
            <span class="s1">p1_ = count1_ / nobs1_</span>
            <span class="s1">p2_ = count2_ / nobs2_</span>
            <span class="s1">ratio_ = p1_ / p2_</span>
            <span class="s1">var = (</span><span class="s4">1 </span><span class="s1">/ count1_) - </span><span class="s4">1 </span><span class="s1">/ nobs1_ + </span><span class="s4">1 </span><span class="s1">/ count2_ - </span><span class="s4">1 </span><span class="s1">/ nobs2_</span>
            <span class="s1">diff_stat = np.log(ratio_) - np.log(value)</span>
            <span class="s1">statistic = diff_stat / np.sqrt(var)</span>
            <span class="s1">distr = </span><span class="s5">'normal'</span>

        <span class="s3">elif </span><span class="s1">method == </span><span class="s5">'score'</span><span class="s1">:</span>
            <span class="s1">res = score_test_proportions_2indep(count1</span><span class="s3">, </span><span class="s1">nobs1</span><span class="s3">, </span><span class="s1">count2</span><span class="s3">, </span><span class="s1">nobs2</span><span class="s3">,</span>
                                                <span class="s1">value=value</span><span class="s3">, </span><span class="s1">compare=compare</span><span class="s3">,</span>
                                                <span class="s1">alternative=alternative</span><span class="s3">,</span>
                                                <span class="s1">correction=correction</span><span class="s3">,</span>
                                                <span class="s1">return_results=return_results)</span>
            <span class="s3">if </span><span class="s1">return_results </span><span class="s3">is False</span><span class="s1">:</span>
                <span class="s1">statistic</span><span class="s3">, </span><span class="s1">pvalue = res[:</span><span class="s4">2</span><span class="s1">]</span>
            <span class="s1">distr = </span><span class="s5">'normal'</span>
            <span class="s1">diff_stat = </span><span class="s3">None</span>

        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'method not recognized'</span><span class="s1">)</span>

    <span class="s3">elif </span><span class="s1">compare == </span><span class="s5">&quot;odds-ratio&quot;</span><span class="s1">:</span>

        <span class="s3">if </span><span class="s1">method </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'logit'</span><span class="s3">, </span><span class="s5">'logit-adjusted'</span><span class="s3">, </span><span class="s5">'logit-smoothed'</span><span class="s1">]:</span>
            <span class="s3">if </span><span class="s1">method </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'logit-smoothed'</span><span class="s1">]:</span>
                <span class="s1">adjusted = _shrink_prob(count1</span><span class="s3">, </span><span class="s1">nobs1</span><span class="s3">, </span><span class="s1">count2</span><span class="s3">, </span><span class="s1">nobs2</span><span class="s3">,</span>
                                        <span class="s1">shrink_factor=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">return_corr=</span><span class="s3">False</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s1">count1_</span><span class="s3">, </span><span class="s1">nobs1_</span><span class="s3">, </span><span class="s1">count2_</span><span class="s3">, </span><span class="s1">nobs2_ = adjusted</span>

            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">addhalf = </span><span class="s4">0.5 </span><span class="s3">if </span><span class="s1">method == </span><span class="s5">'logit-adjusted' </span><span class="s3">else </span><span class="s4">0</span>
                <span class="s1">count1_</span><span class="s3">, </span><span class="s1">nobs1_ = count1 + addhalf</span><span class="s3">, </span><span class="s1">nobs1 + </span><span class="s4">2 </span><span class="s1">* addhalf</span>
                <span class="s1">count2_</span><span class="s3">, </span><span class="s1">nobs2_ = count2 + addhalf</span><span class="s3">, </span><span class="s1">nobs2 + </span><span class="s4">2 </span><span class="s1">* addhalf</span>
            <span class="s1">p1_ = count1_ / nobs1_</span>
            <span class="s1">p2_ = count2_ / nobs2_</span>
            <span class="s1">odds_ratio_ = p1_ / (</span><span class="s4">1 </span><span class="s1">- p1_) / p2_ * (</span><span class="s4">1 </span><span class="s1">- p2_)</span>
            <span class="s1">var = (</span><span class="s4">1 </span><span class="s1">/ count1_ + </span><span class="s4">1 </span><span class="s1">/ (nobs1_ - count1_) +</span>
                   <span class="s4">1 </span><span class="s1">/ count2_ + </span><span class="s4">1 </span><span class="s1">/ (nobs2_ - count2_))</span>

            <span class="s1">diff_stat = np.log(odds_ratio_) - np.log(value)</span>
            <span class="s1">statistic = diff_stat / np.sqrt(var)</span>
            <span class="s1">distr = </span><span class="s5">'normal'</span>

        <span class="s3">elif </span><span class="s1">method == </span><span class="s5">'score'</span><span class="s1">:</span>
            <span class="s1">res = score_test_proportions_2indep(count1</span><span class="s3">, </span><span class="s1">nobs1</span><span class="s3">, </span><span class="s1">count2</span><span class="s3">, </span><span class="s1">nobs2</span><span class="s3">,</span>
                                                <span class="s1">value=value</span><span class="s3">, </span><span class="s1">compare=compare</span><span class="s3">,</span>
                                                <span class="s1">alternative=alternative</span><span class="s3">,</span>
                                                <span class="s1">correction=correction</span><span class="s3">,</span>
                                                <span class="s1">return_results=return_results)</span>
            <span class="s3">if </span><span class="s1">return_results </span><span class="s3">is False</span><span class="s1">:</span>
                <span class="s1">statistic</span><span class="s3">, </span><span class="s1">pvalue = res[:</span><span class="s4">2</span><span class="s1">]</span>
            <span class="s1">distr = </span><span class="s5">'normal'</span>
            <span class="s1">diff_stat = </span><span class="s3">None</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'method &quot;%s&quot; not recognized' </span><span class="s1">% method)</span>

    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'compare &quot;%s&quot; not recognized' </span><span class="s1">% compare)</span>

    <span class="s3">if </span><span class="s1">distr == </span><span class="s5">'normal' </span><span class="s3">and </span><span class="s1">diff_stat </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">statistic</span><span class="s3">, </span><span class="s1">pvalue = _zstat_generic2(diff_stat</span><span class="s3">, </span><span class="s1">np.sqrt(var)</span><span class="s3">,</span>
                                            <span class="s1">alternative=alternative)</span>

    <span class="s3">if </span><span class="s1">return_results:</span>
        <span class="s3">if </span><span class="s1">res </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">res = HolderTuple(statistic=statistic</span><span class="s3">,</span>
                              <span class="s1">pvalue=pvalue</span><span class="s3">,</span>
                              <span class="s1">compare=compare</span><span class="s3">,</span>
                              <span class="s1">method=method</span><span class="s3">,</span>
                              <span class="s1">diff=diff</span><span class="s3">,</span>
                              <span class="s1">ratio=ratio</span><span class="s3">,</span>
                              <span class="s1">odds_ratio=odds_ratio</span><span class="s3">,</span>
                              <span class="s1">variance=var</span><span class="s3">,</span>
                              <span class="s1">alternative=alternative</span><span class="s3">,</span>
                              <span class="s1">value=value</span><span class="s3">,</span>
                              <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># we already have a return result from score test</span>
            <span class="s0"># add missing attributes</span>
            <span class="s1">res.diff = diff</span>
            <span class="s1">res.ratio = ratio</span>
            <span class="s1">res.odds_ratio = odds_ratio</span>
            <span class="s1">res.value = value</span>
        <span class="s3">return </span><span class="s1">res</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">statistic</span><span class="s3">, </span><span class="s1">pvalue</span>


<span class="s3">def </span><span class="s1">tost_proportions_2indep(count1</span><span class="s3">, </span><span class="s1">nobs1</span><span class="s3">, </span><span class="s1">count2</span><span class="s3">, </span><span class="s1">nobs2</span><span class="s3">, </span><span class="s1">low</span><span class="s3">, </span><span class="s1">upp</span><span class="s3">,</span>
                            <span class="s1">method=</span><span class="s3">None, </span><span class="s1">compare=</span><span class="s5">'diff'</span><span class="s3">, </span><span class="s1">correction=</span><span class="s3">True</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Equivalence test based on two one-sided `test_proportions_2indep` 
 
    This assumes that we have two independent binomial samples. 
 
    The Null and alternative hypothesis for equivalence testing are 
 
    for compare = 'diff' 
 
    - H0: prop1 - prop2 &lt;= low or upp &lt;= prop1 - prop2 
    - H1: low &lt; prop1 - prop2 &lt; upp 
 
    for compare = 'ratio' 
 
    - H0: prop1 / prop2 &lt;= low or upp &lt;= prop1 / prop2 
    - H1: low &lt; prop1 / prop2 &lt; upp 
 
 
    for compare = 'odds-ratio' 
 
    - H0: or &lt;= low or upp &lt;= or 
    - H1: low &lt; or &lt; upp 
 
    where odds-ratio or = prop1 / (1 - prop1) / (prop2 / (1 - prop2)) 
 
    Parameters 
    ---------- 
    count1, nobs1 : 
        count and sample size for first sample 
    count2, nobs2 : 
        count and sample size for the second sample 
    low, upp : 
        equivalence margin for diff, risk ratio or odds ratio 
    method : string 
        method for computing the hypothesis test. If method is None, then a 
        default method is used. The default might change as more methods are 
        added. 
 
        diff: 
         - 'wald', 
         - 'agresti-caffo' 
         - 'score' if correction is True, then this uses the degrees of freedom 
           correction ``nobs / (nobs - 1)`` as in Miettinen Nurminen 1985. 
 
        ratio: 
         - 'log': wald test using log transformation 
         - 'log-adjusted': wald test using log transformation, 
            adds 0.5 to counts 
         - 'score' if correction is True, then this uses the degrees of freedom 
           correction ``nobs / (nobs - 1)`` as in Miettinen Nurminen 1985. 
 
        odds-ratio: 
         - 'logit': wald test using logit transformation 
         - 'logit-adjusted': : wald test using logit transformation, 
            adds 0.5 to counts 
         - 'logit-smoothed': : wald test using logit transformation, biases 
            cell counts towards independence by adding two observations in 
            total. 
         - 'score' if correction is True, then this uses the degrees of freedom 
            correction ``nobs / (nobs - 1)`` as in Miettinen Nurminen 1985 
 
    compare : string in ['diff', 'ratio' 'odds-ratio'] 
        If compare is `diff`, then the hypothesis test is for 
        diff = p1 - p2. 
        If compare is `ratio`, then the hypothesis test is for the 
        risk ratio defined by ratio = p1 / p2. 
        If compare is `odds-ratio`, then the hypothesis test is for the 
        odds-ratio defined by or = p1 / (1 - p1) / (p2 / (1 - p2). 
    correction : bool 
        If correction is True (default), then the Miettinen and Nurminen 
        small sample correction to the variance nobs / (nobs - 1) is used. 
        Applies only if method='score'. 
 
    Returns 
    ------- 
    pvalue : float 
        p-value is the max of the pvalues of the two one-sided tests 
    t1 : test results 
        results instance for one-sided hypothesis at the lower margin 
    t1 : test results 
        results instance for one-sided hypothesis at the upper margin 
 
    See Also 
    -------- 
    test_proportions_2indep 
    confint_proportions_2indep 
 
    Notes 
    ----- 
    Status: experimental, API and defaults might still change. 
 
    The TOST equivalence test delegates to `test_proportions_2indep` and has 
    the same method and comparison options. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">tt1 = test_proportions_2indep(count1</span><span class="s3">, </span><span class="s1">nobs1</span><span class="s3">, </span><span class="s1">count2</span><span class="s3">, </span><span class="s1">nobs2</span><span class="s3">, </span><span class="s1">value=low</span><span class="s3">,</span>
                                  <span class="s1">method=method</span><span class="s3">, </span><span class="s1">compare=compare</span><span class="s3">,</span>
                                  <span class="s1">alternative=</span><span class="s5">'larger'</span><span class="s3">,</span>
                                  <span class="s1">correction=correction</span><span class="s3">,</span>
                                  <span class="s1">return_results=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s1">tt2 = test_proportions_2indep(count1</span><span class="s3">, </span><span class="s1">nobs1</span><span class="s3">, </span><span class="s1">count2</span><span class="s3">, </span><span class="s1">nobs2</span><span class="s3">, </span><span class="s1">value=upp</span><span class="s3">,</span>
                                  <span class="s1">method=method</span><span class="s3">, </span><span class="s1">compare=compare</span><span class="s3">,</span>
                                  <span class="s1">alternative=</span><span class="s5">'smaller'</span><span class="s3">,</span>
                                  <span class="s1">correction=correction</span><span class="s3">,</span>
                                  <span class="s1">return_results=</span><span class="s3">True</span><span class="s1">)</span>

    <span class="s0"># idx_max = 1 if t1.pvalue &lt; t2.pvalue else 0</span>
    <span class="s1">idx_max = np.asarray(tt1.pvalue &lt; tt2.pvalue</span><span class="s3">, </span><span class="s1">int)</span>
    <span class="s1">statistic = np.choose(idx_max</span><span class="s3">, </span><span class="s1">[tt1.statistic</span><span class="s3">, </span><span class="s1">tt2.statistic])</span>
    <span class="s1">pvalue = np.choose(idx_max</span><span class="s3">, </span><span class="s1">[tt1.pvalue</span><span class="s3">, </span><span class="s1">tt2.pvalue])</span>

    <span class="s1">res = HolderTuple(statistic=statistic</span><span class="s3">,</span>
                      <span class="s1">pvalue=pvalue</span><span class="s3">,</span>
                      <span class="s1">compare=compare</span><span class="s3">,</span>
                      <span class="s1">method=method</span><span class="s3">,</span>
                      <span class="s1">results_larger=tt1</span><span class="s3">,</span>
                      <span class="s1">results_smaller=tt2</span><span class="s3">,</span>
                      <span class="s1">title=</span><span class="s5">&quot;Equivalence test for 2 independent proportions&quot;</span>
                      <span class="s1">)</span>

    <span class="s3">return </span><span class="s1">res</span>


<span class="s3">def </span><span class="s1">_std_2prop_power(diff</span><span class="s3">, </span><span class="s1">p2</span><span class="s3">, </span><span class="s1">ratio=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">alpha=</span><span class="s4">0.05</span><span class="s3">, </span><span class="s1">value=</span><span class="s4">0</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute standard error under null and alternative for 2 proportions 
 
    helper function for power and sample size computation 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">value != </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">msg = </span><span class="s5">'non-zero diff under null, value, is not yet implemented'</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(msg)</span>

    <span class="s1">nobs_ratio = ratio</span>
    <span class="s1">p1 = p2 + diff</span>
    <span class="s0"># The following contains currently redundant variables that will</span>
    <span class="s0"># be useful for different options for the null variance</span>
    <span class="s1">p_pooled = (p1 + p2 * ratio) / (</span><span class="s4">1 </span><span class="s1">+ ratio)</span>
    <span class="s0"># probabilities for the variance for the null statistic</span>
    <span class="s1">p1_vnull</span><span class="s3">, </span><span class="s1">p2_vnull = p_pooled</span><span class="s3">, </span><span class="s1">p_pooled</span>
    <span class="s1">p2_alt = p2</span>
    <span class="s1">p1_alt = p2_alt + diff</span>

    <span class="s1">std_null = _std_diff_prop(p1_vnull</span><span class="s3">, </span><span class="s1">p2_vnull</span><span class="s3">, </span><span class="s1">ratio=nobs_ratio)</span>
    <span class="s1">std_alt = _std_diff_prop(p1_alt</span><span class="s3">, </span><span class="s1">p2_alt</span><span class="s3">, </span><span class="s1">ratio=nobs_ratio)</span>
    <span class="s3">return </span><span class="s1">p_pooled</span><span class="s3">, </span><span class="s1">std_null</span><span class="s3">, </span><span class="s1">std_alt</span>


<span class="s3">def </span><span class="s1">power_proportions_2indep(diff</span><span class="s3">, </span><span class="s1">prop2</span><span class="s3">, </span><span class="s1">nobs1</span><span class="s3">, </span><span class="s1">ratio=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">alpha=</span><span class="s4">0.05</span><span class="s3">,</span>
                             <span class="s1">value=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">alternative=</span><span class="s5">'two-sided'</span><span class="s3">,</span>
                             <span class="s1">return_results=</span><span class="s3">True</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Power for ztest that two independent proportions are equal 
 
    This assumes that the variance is based on the pooled proportion 
    under the null and the non-pooled variance under the alternative 
 
    Parameters 
    ---------- 
    diff : float 
        difference between proportion 1 and 2 under the alternative 
    prop2 : float 
        proportion for the reference case, prop2, proportions for the 
        first case will be computed using p2 and diff 
        p1 = p2 + diff 
    nobs1 : float or int 
        number of observations in sample 1 
    ratio : float 
        sample size ratio, nobs2 = ratio * nobs1 
    alpha : float in interval (0,1) 
        Significance level, e.g. 0.05, is the probability of a type I 
        error, that is wrong rejections if the Null Hypothesis is true. 
    value : float 
        currently only `value=0`, i.e. equality testing, is supported 
    alternative : string, 'two-sided' (default), 'larger', 'smaller' 
        Alternative hypothesis whether the power is calculated for a 
        two-sided (default) or one sided test. The one-sided test can be 
        either 'larger', 'smaller'. 
    return_results : bool 
        If true, then a results instance with extra information is returned, 
        otherwise only the computed power is returned. 
 
    Returns 
    ------- 
    results : results instance or float 
        If return_results is True, then a results instance with the 
        information in attributes is returned. 
        If return_results is False, then only the power is returned. 
 
        power : float 
            Power of the test, e.g. 0.8, is one minus the probability of a 
            type II error. Power is the probability that the test correctly 
            rejects the Null Hypothesis if the Alternative Hypothesis is true. 
 
        Other attributes in results instance include : 
 
        p_pooled 
            pooled proportion, used for std_null 
        std_null 
            standard error of difference under the null hypothesis (without 
            sqrt(nobs1)) 
        std_alt 
            standard error of difference under the alternative hypothesis 
            (without sqrt(nobs1)) 
    &quot;&quot;&quot;</span>
    <span class="s0"># TODO: avoid possible circular import, check if needed</span>
    <span class="s3">from </span><span class="s1">statsmodels.stats.power </span><span class="s3">import </span><span class="s1">normal_power_het</span>

    <span class="s1">p_pooled</span><span class="s3">, </span><span class="s1">std_null</span><span class="s3">, </span><span class="s1">std_alt = _std_2prop_power(diff</span><span class="s3">, </span><span class="s1">prop2</span><span class="s3">, </span><span class="s1">ratio=ratio</span><span class="s3">,</span>
                                                   <span class="s1">alpha=alpha</span><span class="s3">, </span><span class="s1">value=value)</span>

    <span class="s1">pow_ = normal_power_het(diff</span><span class="s3">, </span><span class="s1">nobs1</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">std_null=std_null</span><span class="s3">,</span>
                            <span class="s1">std_alternative=std_alt</span><span class="s3">,</span>
                            <span class="s1">alternative=alternative)</span>

    <span class="s3">if </span><span class="s1">return_results:</span>
        <span class="s1">res = Holder(power=pow_</span><span class="s3">,</span>
                     <span class="s1">p_pooled=p_pooled</span><span class="s3">,</span>
                     <span class="s1">std_null=std_null</span><span class="s3">,</span>
                     <span class="s1">std_alt=std_alt</span><span class="s3">,</span>
                     <span class="s1">nobs1=nobs1</span><span class="s3">,</span>
                     <span class="s1">nobs2=ratio * nobs1</span><span class="s3">,</span>
                     <span class="s1">nobs_ratio=ratio</span><span class="s3">,</span>
                     <span class="s1">alpha=alpha</span><span class="s3">,</span>
                     <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">res</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">pow_</span>


<span class="s3">def </span><span class="s1">samplesize_proportions_2indep_onetail(diff</span><span class="s3">, </span><span class="s1">prop2</span><span class="s3">, </span><span class="s1">power</span><span class="s3">, </span><span class="s1">ratio=</span><span class="s4">1</span><span class="s3">,</span>
                                          <span class="s1">alpha=</span><span class="s4">0.05</span><span class="s3">, </span><span class="s1">value=</span><span class="s4">0</span><span class="s3">,</span>
                                          <span class="s1">alternative=</span><span class="s5">'two-sided'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Required sample size assuming normal distribution based on one tail 
 
    This uses an explicit computation for the sample size that is required 
    to achieve a given power corresponding to the appropriate tails of the 
    normal distribution. This ignores the far tail in a two-sided test 
    which is negligible in the common case when alternative and null are 
    far apart. 
 
    Parameters 
    ---------- 
    diff : float 
        Difference between proportion 1 and 2 under the alternative 
    prop2 : float 
        proportion for the reference case, prop2, proportions for the 
        first case will be computing using p2 and diff 
        p1 = p2 + diff 
    power : float 
        Power for which sample size is computed. 
    ratio : float 
        Sample size ratio, nobs2 = ratio * nobs1 
    alpha : float in interval (0,1) 
        Significance level, e.g. 0.05, is the probability of a type I 
        error, that is wrong rejections if the Null Hypothesis is true. 
    value : float 
        Currently only `value=0`, i.e. equality testing, is supported 
    alternative : string, 'two-sided' (default), 'larger', 'smaller' 
        Alternative hypothesis whether the power is calculated for a 
        two-sided (default) or one sided test. In the case of a one-sided 
        alternative, it is assumed that the test is in the appropriate tail. 
 
    Returns 
    ------- 
    nobs1 : float 
        Number of observations in sample 1. 
    &quot;&quot;&quot;</span>
    <span class="s0"># TODO: avoid possible circular import, check if needed</span>
    <span class="s3">from </span><span class="s1">statsmodels.stats.power </span><span class="s3">import </span><span class="s1">normal_sample_size_one_tail</span>

    <span class="s3">if </span><span class="s1">alternative </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'two-sided'</span><span class="s3">, </span><span class="s5">'2s'</span><span class="s1">]:</span>
        <span class="s1">alpha = alpha / </span><span class="s4">2</span>

    <span class="s1">_</span><span class="s3">, </span><span class="s1">std_null</span><span class="s3">, </span><span class="s1">std_alt = _std_2prop_power(diff</span><span class="s3">, </span><span class="s1">prop2</span><span class="s3">, </span><span class="s1">ratio=ratio</span><span class="s3">,</span>
                                            <span class="s1">alpha=alpha</span><span class="s3">, </span><span class="s1">value=value)</span>

    <span class="s1">nobs = normal_sample_size_one_tail(diff</span><span class="s3">, </span><span class="s1">power</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">std_null=std_null</span><span class="s3">,</span>
                                       <span class="s1">std_alternative=std_alt)</span>
    <span class="s3">return </span><span class="s1">nobs</span>


<span class="s3">def </span><span class="s1">_score_confint_inversion(count1</span><span class="s3">, </span><span class="s1">nobs1</span><span class="s3">, </span><span class="s1">count2</span><span class="s3">, </span><span class="s1">nobs2</span><span class="s3">, </span><span class="s1">compare=</span><span class="s5">'diff'</span><span class="s3">,</span>
                             <span class="s1">alpha=</span><span class="s4">0.05</span><span class="s3">, </span><span class="s1">correction=</span><span class="s3">True</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute score confidence interval by inverting score test 
 
    Parameters 
    ---------- 
    count1, nobs1 : 
        Count and sample size for first sample. 
    count2, nobs2 : 
        Count and sample size for the second sample. 
    compare : string in ['diff', 'ratio' 'odds-ratio'] 
        If compare is `diff`, then the confidence interval is for 
        diff = p1 - p2. 
        If compare is `ratio`, then the confidence interval is for the 
        risk ratio defined by ratio = p1 / p2. 
        If compare is `odds-ratio`, then the confidence interval is for the 
        odds-ratio defined by or = p1 / (1 - p1) / (p2 / (1 - p2). 
    alpha : float in interval (0,1) 
        Significance level, e.g. 0.05, is the probability of a type I 
        error, that is wrong rejections if the Null Hypothesis is true. 
    correction : bool 
        If correction is True (default), then the Miettinen and Nurminen 
        small sample correction to the variance nobs / (nobs - 1) is used. 
        Applies only if method='score'. 
 
    Returns 
    ------- 
    low : float 
        Lower confidence bound. 
    upp : float 
        Upper confidence bound. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">func(v):</span>
        <span class="s1">r = test_proportions_2indep(count1</span><span class="s3">, </span><span class="s1">nobs1</span><span class="s3">, </span><span class="s1">count2</span><span class="s3">, </span><span class="s1">nobs2</span><span class="s3">,</span>
                                    <span class="s1">value=v</span><span class="s3">, </span><span class="s1">compare=compare</span><span class="s3">, </span><span class="s1">method=</span><span class="s5">'score'</span><span class="s3">,</span>
                                    <span class="s1">correction=correction</span><span class="s3">,</span>
                                    <span class="s1">alternative=</span><span class="s5">&quot;two-sided&quot;</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">r.pvalue - alpha</span>

    <span class="s1">rt0 = test_proportions_2indep(count1</span><span class="s3">, </span><span class="s1">nobs1</span><span class="s3">, </span><span class="s1">count2</span><span class="s3">, </span><span class="s1">nobs2</span><span class="s3">,</span>
                                  <span class="s1">value=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">compare=compare</span><span class="s3">, </span><span class="s1">method=</span><span class="s5">'score'</span><span class="s3">,</span>
                                  <span class="s1">correction=correction</span><span class="s3">,</span>
                                  <span class="s1">alternative=</span><span class="s5">&quot;two-sided&quot;</span><span class="s1">)</span>

    <span class="s0"># use default method to get starting values</span>
    <span class="s0"># this will not work if score confint becomes default</span>
    <span class="s0"># maybe use &quot;wald&quot; as alias that works for all compare statistics</span>
    <span class="s1">use_method = {</span><span class="s5">&quot;diff&quot;</span><span class="s1">: </span><span class="s5">&quot;wald&quot;</span><span class="s3">, </span><span class="s5">&quot;ratio&quot;</span><span class="s1">: </span><span class="s5">&quot;log&quot;</span><span class="s3">, </span><span class="s5">&quot;odds-ratio&quot;</span><span class="s1">: </span><span class="s5">&quot;logit&quot;</span><span class="s1">}</span>
    <span class="s1">rci0 = confint_proportions_2indep(count1</span><span class="s3">, </span><span class="s1">nobs1</span><span class="s3">, </span><span class="s1">count2</span><span class="s3">, </span><span class="s1">nobs2</span><span class="s3">,</span>
                                      <span class="s1">method=use_method[compare]</span><span class="s3">,</span>
                                      <span class="s1">compare=compare</span><span class="s3">, </span><span class="s1">alpha=alpha)</span>

    <span class="s0"># Note diff might be negative</span>
    <span class="s1">ub = rci0[</span><span class="s4">1</span><span class="s1">] + np.abs(rci0[</span><span class="s4">1</span><span class="s1">]) * </span><span class="s4">0.5</span>
    <span class="s1">lb = rci0[</span><span class="s4">0</span><span class="s1">] - np.abs(rci0[</span><span class="s4">0</span><span class="s1">]) * </span><span class="s4">0.25</span>
    <span class="s3">if </span><span class="s1">compare == </span><span class="s5">'diff'</span><span class="s1">:</span>
        <span class="s1">param = rt0.diff</span>
        <span class="s0"># 1 might not be the correct upper bound because</span>
        <span class="s0">#     rootfinding is for the `diff` and not for a probability.</span>
        <span class="s1">ub = min(ub</span><span class="s3">, </span><span class="s4">0.99999</span><span class="s1">)</span>
    <span class="s3">elif </span><span class="s1">compare == </span><span class="s5">'ratio'</span><span class="s1">:</span>
        <span class="s1">param = rt0.ratio</span>
        <span class="s1">ub *= </span><span class="s4">2  </span><span class="s0"># add more buffer</span>
    <span class="s3">if </span><span class="s1">compare == </span><span class="s5">'odds-ratio'</span><span class="s1">:</span>
        <span class="s1">param = rt0.odds_ratio</span>

    <span class="s0"># root finding for confint bounds</span>
    <span class="s1">upp = optimize.brentq(func</span><span class="s3">, </span><span class="s1">param</span><span class="s3">, </span><span class="s1">ub)</span>
    <span class="s1">low = optimize.brentq(func</span><span class="s3">, </span><span class="s1">lb</span><span class="s3">, </span><span class="s1">param)</span>
    <span class="s3">return </span><span class="s1">low</span><span class="s3">, </span><span class="s1">upp</span>


<span class="s3">def </span><span class="s1">_confint_riskratio_koopman(count1</span><span class="s3">, </span><span class="s1">nobs1</span><span class="s3">, </span><span class="s1">count2</span><span class="s3">, </span><span class="s1">nobs2</span><span class="s3">, </span><span class="s1">alpha=</span><span class="s4">0.05</span><span class="s3">,</span>
                               <span class="s1">correction=</span><span class="s3">True</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Score confidence interval for ratio or proportions, Koopman/Nam 
 
    signature not consistent with other functions 
 
    When correction is True, then the small sample correction nobs / (nobs - 1) 
    by Miettinen/Nurminen is used. 
    &quot;&quot;&quot;</span>
    <span class="s0"># The names below follow Nam</span>
    <span class="s1">x0</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">n0</span><span class="s3">, </span><span class="s1">n1 = count2</span><span class="s3">, </span><span class="s1">count1</span><span class="s3">, </span><span class="s1">nobs2</span><span class="s3">, </span><span class="s1">nobs1</span>
    <span class="s1">x = x0 + x1</span>
    <span class="s1">n = n0 + n1</span>
    <span class="s1">z = stats.norm.isf(alpha / </span><span class="s4">2</span><span class="s1">)**</span><span class="s4">2</span>
    <span class="s3">if </span><span class="s1">correction:</span>
        <span class="s0"># Mietinnen/Nurminen small sample correction</span>
        <span class="s1">z *= n / (n - </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s0"># z = stats.chi2.isf(alpha, 1)</span>
    <span class="s0"># equ 6 in Nam 1995</span>
    <span class="s1">a1 = n0 * (n0 * n * x1 + n1 * (n0 + x1) * z)</span>
    <span class="s1">a2 = - n0 * (n0 * n1 * x + </span><span class="s4">2 </span><span class="s1">* n * x0 * x1 + n1 * (n0 + x0 + </span><span class="s4">2 </span><span class="s1">* x1) * z)</span>
    <span class="s1">a3 = </span><span class="s4">2 </span><span class="s1">* n0 * n1 * x0 * x + n * x0 * x0 * x1 + n0 * n1 * x * z</span>
    <span class="s1">a4 = - n1 * x0 * x0 * x</span>

    <span class="s1">p_roots_ = np.sort(np.roots([a1</span><span class="s3">, </span><span class="s1">a2</span><span class="s3">, </span><span class="s1">a3</span><span class="s3">, </span><span class="s1">a4]))</span>
    <span class="s1">p_roots = p_roots_[:</span><span class="s4">2</span><span class="s1">][::-</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s0"># equ 5</span>
    <span class="s1">ci = (</span><span class="s4">1 </span><span class="s1">- (n1 - x1) * (</span><span class="s4">1 </span><span class="s1">- p_roots) / (x0 + n1 - n * p_roots)) / p_roots</span>

    <span class="s1">res = Holder()</span>
    <span class="s1">res.confint = ci</span>
    <span class="s1">res._p_roots = p_roots_  </span><span class="s0"># for unit tests, can be dropped</span>
    <span class="s3">return </span><span class="s1">res</span>


<span class="s3">def </span><span class="s1">_confint_riskratio_paired_nam(table</span><span class="s3">, </span><span class="s1">alpha=</span><span class="s4">0.05</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Confidence interval for marginal risk ratio for matched pairs 
 
    need full table 
 
             success fail  marginal 
    success    x11    x10  x1. 
    fail       x01    x00  x0. 
    marginal   x.1    x.0   n 
 
    The confidence interval is for the ratio p1 / p0 where 
    p1 = x1. / n and 
    p0 - x.1 / n 
    Todo: rename p1 to pa and p2 to pb, so we have a, b for treatment and 
    0, 1 for success/failure 
 
    current namings follow Nam 2009 
 
    status 
    testing: 
    compared to example in Nam 2009 
    internal polynomial coefficients in calculation correspond at around 
        4 decimals 
    confidence interval agrees only at 2 decimals 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x11</span><span class="s3">, </span><span class="s1">x10</span><span class="s3">, </span><span class="s1">x01</span><span class="s3">, </span><span class="s1">x00 = np.ravel(table)</span>
    <span class="s1">n = np.sum(table)  </span><span class="s0"># nobs</span>
    <span class="s1">p10</span><span class="s3">, </span><span class="s1">p01 = x10 / n</span><span class="s3">, </span><span class="s1">x01 / n</span>
    <span class="s1">p1 = (x11 + x10) / n</span>
    <span class="s1">p0 = (x11 + x01) / n</span>
    <span class="s1">q00 = </span><span class="s4">1 </span><span class="s1">- x00 / n</span>

    <span class="s1">z2 = stats.norm.isf(alpha / </span><span class="s4">2</span><span class="s1">)**</span><span class="s4">2</span>
    <span class="s0"># z = stats.chi2.isf(alpha, 1)</span>
    <span class="s0"># before equ 3 in Nam 2009</span>

    <span class="s1">g1 = (n * p0 + z2 / </span><span class="s4">2</span><span class="s1">) * p0</span>
    <span class="s1">g2 = - (</span><span class="s4">2 </span><span class="s1">* n * p1 * p0 + z2 * q00)</span>
    <span class="s1">g3 = (n * p1 + z2 / </span><span class="s4">2</span><span class="s1">) * p1</span>

    <span class="s1">a0 = g1**</span><span class="s4">2 </span><span class="s1">- (z2 * p0 / </span><span class="s4">2</span><span class="s1">)**</span><span class="s4">2</span>
    <span class="s1">a1 = </span><span class="s4">2 </span><span class="s1">* g1 * g2</span>
    <span class="s1">a2 = g2**</span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">2 </span><span class="s1">* g1 * g3 + z2**</span><span class="s4">2 </span><span class="s1">* (p1 * p0 - </span><span class="s4">2 </span><span class="s1">* p10 * p01) / </span><span class="s4">2</span>
    <span class="s1">a3 = </span><span class="s4">2 </span><span class="s1">* g2 * g3</span>
    <span class="s1">a4 = g3**</span><span class="s4">2 </span><span class="s1">- (z2 * p1 / </span><span class="s4">2</span><span class="s1">)**</span><span class="s4">2</span>

    <span class="s1">p_roots = np.sort(np.roots([a0</span><span class="s3">, </span><span class="s1">a1</span><span class="s3">, </span><span class="s1">a2</span><span class="s3">, </span><span class="s1">a3</span><span class="s3">, </span><span class="s1">a4]))</span>
    <span class="s0"># p_roots = np.sort(np.roots([1, a1 / a0, a2 / a0, a3 / a0, a4 / a0]))</span>

    <span class="s1">ci = [p_roots.min()</span><span class="s3">, </span><span class="s1">p_roots.max()]</span>
    <span class="s1">res = Holder()</span>
    <span class="s1">res.confint = ci</span>
    <span class="s1">res.p = p1</span><span class="s3">, </span><span class="s1">p0</span>
    <span class="s1">res._p_roots = p_roots  </span><span class="s0"># for unit tests, can be dropped</span>
    <span class="s3">return </span><span class="s1">res</span>
</pre>
</body>
</html>