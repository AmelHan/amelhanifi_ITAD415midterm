<html>
<head>
<title>test_impulse_responses.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_impulse_responses.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Tests for impulse responses of time series 
 
Author: Chad Fulton 
License: Simplified-BSD 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">from </span><span class="s1">scipy.stats </span><span class="s2">import </span><span class="s1">ortho_group</span>
<span class="s2">import </span><span class="s1">pytest</span>
<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">assert_</span><span class="s2">, </span><span class="s1">assert_allclose</span>

<span class="s2">from </span><span class="s1">statsmodels.tools.sm_exceptions </span><span class="s2">import </span><span class="s1">EstimationWarning</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace </span><span class="s2">import </span><span class="s1">(mlemodel</span><span class="s2">, </span><span class="s1">sarimax</span><span class="s2">, </span><span class="s1">structural</span><span class="s2">, </span><span class="s1">varmax</span><span class="s2">,</span>
                                        <span class="s1">dynamic_factor)</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.vector_ar.tests.test_var </span><span class="s2">import </span><span class="s1">get_macrodata</span>


<span class="s2">def </span><span class="s1">test_sarimax():</span>
    <span class="s3"># AR(1)</span>
    <span class="s1">mod = sarimax.SARIMAX([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>
    <span class="s1">phi = </span><span class="s4">0.5</span>
    <span class="s1">actual = mod.impulse_responses([phi</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">steps=</span><span class="s4">10</span><span class="s1">)</span>
    <span class="s1">desired = np.r_[[phi**i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">11</span><span class="s1">)]]</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># MA(1)</span>
    <span class="s1">mod = sarimax.SARIMAX([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>
    <span class="s1">theta = </span><span class="s4">0.5</span>
    <span class="s1">actual = mod.impulse_responses([theta</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">steps=</span><span class="s4">10</span><span class="s1">)</span>
    <span class="s1">desired = np.r_[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">theta</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s1">]*</span><span class="s4">9</span><span class="s1">]</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># ARMA(2, 2) + constant</span>
    <span class="s3"># Stata:</span>
    <span class="s3"># webuse lutkepohl2</span>
    <span class="s3"># arima dln_inc, arima(2, 0, 2)</span>
    <span class="s3"># irf create irf1, set(irf1) step(10)</span>
    <span class="s3"># irf table irf</span>
    <span class="s1">params = [</span><span class="s4">.01928228</span><span class="s2">, </span><span class="s1">-</span><span class="s4">.03656216</span><span class="s2">, </span><span class="s4">.7588994</span><span class="s2">,</span>
              <span class="s4">.27070341</span><span class="s2">, </span><span class="s1">-</span><span class="s4">.72928328</span><span class="s2">, </span><span class="s4">.01122177</span><span class="s1">**</span><span class="s4">0.5</span><span class="s1">]</span>
    <span class="s1">mod = sarimax.SARIMAX([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'c'</span><span class="s1">)</span>
    <span class="s1">actual = mod.impulse_responses(params</span><span class="s2">, </span><span class="s1">steps=</span><span class="s4">10</span><span class="s1">)</span>
    <span class="s1">desired = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">.234141</span><span class="s2">, </span><span class="s4">.021055</span><span class="s2">, </span><span class="s4">.17692</span><span class="s2">, </span><span class="s4">.00951</span><span class="s2">, </span><span class="s4">.133917</span><span class="s2">, </span><span class="s4">.002321</span><span class="s2">, </span><span class="s4">.101544</span><span class="s2">,</span>
               <span class="s1">-</span><span class="s4">.001951</span><span class="s2">, </span><span class="s4">.077133</span><span class="s2">, </span><span class="s1">-</span><span class="s4">.004301</span><span class="s1">]</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-6</span><span class="s1">)</span>

    <span class="s3"># SARIMAX(1,1,1)x(1,0,1,4) + constant + exog</span>
    <span class="s3"># Stata:</span>
    <span class="s3"># webuse lutkepohl2</span>
    <span class="s3"># gen exog = _n^2</span>
    <span class="s3"># arima inc exog, arima(1,1,1) sarima(1,0,1,4)</span>
    <span class="s3"># irf create irf2, set(irf2) step(10)</span>
    <span class="s3"># irf table irf</span>
    <span class="s1">params = [</span><span class="s4">.12853289</span><span class="s2">, </span><span class="s4">12.207156</span><span class="s2">, </span><span class="s4">.86384742</span><span class="s2">, </span><span class="s1">-</span><span class="s4">.71463236</span><span class="s2">,</span>
              <span class="s4">.81878967</span><span class="s2">, </span><span class="s1">-</span><span class="s4">.9533955</span><span class="s2">, </span><span class="s4">14.043884</span><span class="s1">**</span><span class="s4">0.5</span><span class="s1">]</span>
    <span class="s1">exog = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">92</span><span class="s1">)**</span><span class="s4">2</span>
    <span class="s1">mod = sarimax.SARIMAX(np.zeros(</span><span class="s4">91</span><span class="s1">)</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">seasonal_order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'c'</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">,</span>
                          <span class="s1">simple_differencing=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">actual = mod.impulse_responses(params</span><span class="s2">, </span><span class="s1">steps=</span><span class="s4">10</span><span class="s1">)</span>
    <span class="s1">desired = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">.149215</span><span class="s2">, </span><span class="s4">.128899</span><span class="s2">, </span><span class="s4">.111349</span><span class="s2">, </span><span class="s1">-</span><span class="s4">.038417</span><span class="s2">, </span><span class="s4">.063007</span><span class="s2">, </span><span class="s4">.054429</span><span class="s2">,</span>
               <span class="s4">.047018</span><span class="s2">, </span><span class="s1">-</span><span class="s4">.069598</span><span class="s2">, </span><span class="s4">.018641</span><span class="s2">, </span><span class="s4">.016103</span><span class="s1">]</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-6</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_structural():</span>
    <span class="s1">steps = </span><span class="s4">10</span>

    <span class="s3"># AR(1)</span>
    <span class="s1">mod = structural.UnobservedComponents([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">autoregressive=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">phi = </span><span class="s4">0.5</span>
    <span class="s1">actual = mod.impulse_responses([</span><span class="s4">1</span><span class="s2">, </span><span class="s1">phi]</span><span class="s2">, </span><span class="s1">steps)</span>
    <span class="s1">desired = np.r_[[phi**i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(steps + </span><span class="s4">1</span><span class="s1">)]]</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># ARX(1)</span>
    <span class="s3"># This is adequately tested in test_simulate.py, since in the time-varying</span>
    <span class="s3"># case `impulse_responses` just calls `simulate`</span>

    <span class="s3"># Irregular</span>
    <span class="s1">mod = structural.UnobservedComponents([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'irregular'</span><span class="s1">)</span>
    <span class="s1">actual = mod.impulse_responses([</span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">steps)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s3"># Fixed intercept</span>
    <span class="s3"># (in practice this is a deterministic constant, because an irregular</span>
    <span class="s3">#  component must be added)</span>
    <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
        <span class="s1">warnings.simplefilter(</span><span class="s5">&quot;ignore&quot;</span><span class="s1">)</span>
        <span class="s1">mod = structural.UnobservedComponents([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'fixed intercept'</span><span class="s1">)</span>
    <span class="s1">actual = mod.impulse_responses([</span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">steps)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s3"># Deterministic constant</span>
    <span class="s1">mod = structural.UnobservedComponents([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'deterministic constant'</span><span class="s1">)</span>
    <span class="s1">actual = mod.impulse_responses([</span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">steps)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s3"># Local level</span>
    <span class="s1">mod = structural.UnobservedComponents([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'local level'</span><span class="s1">)</span>
    <span class="s1">actual = mod.impulse_responses([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">steps)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s3"># Random walk</span>
    <span class="s1">mod = structural.UnobservedComponents([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'random walk'</span><span class="s1">)</span>
    <span class="s1">actual = mod.impulse_responses([</span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">steps)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s3"># Fixed slope</span>
    <span class="s3"># (in practice this is a deterministic trend, because an irregular</span>
    <span class="s3">#  component must be added)</span>
    <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
        <span class="s1">warnings.simplefilter(</span><span class="s5">&quot;ignore&quot;</span><span class="s1">)</span>
        <span class="s1">mod = structural.UnobservedComponents([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'fixed slope'</span><span class="s1">)</span>
    <span class="s1">actual = mod.impulse_responses([</span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">steps)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s3"># Deterministic trend</span>
    <span class="s1">mod = structural.UnobservedComponents([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'deterministic trend'</span><span class="s1">)</span>
    <span class="s1">actual = mod.impulse_responses([</span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">steps)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s3"># Local linear deterministic trend</span>
    <span class="s1">mod = structural.UnobservedComponents(</span>
        <span class="s1">[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'local linear deterministic trend'</span><span class="s1">)</span>
    <span class="s1">actual = mod.impulse_responses([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">steps)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s3"># Random walk with drift</span>
    <span class="s1">mod = structural.UnobservedComponents([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'random walk with drift'</span><span class="s1">)</span>
    <span class="s1">actual = mod.impulse_responses([</span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">steps)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s3"># Local linear trend</span>
    <span class="s1">mod = structural.UnobservedComponents([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'local linear trend'</span><span class="s1">)</span>
    <span class="s3"># - shock the level</span>
    <span class="s1">actual = mod.impulse_responses([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">steps)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s3"># - shock the trend</span>
    <span class="s1">actual = mod.impulse_responses([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">steps</span><span class="s2">, </span><span class="s1">impulse=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">np.arange(steps + </span><span class="s4">1</span><span class="s1">))</span>

    <span class="s3"># Smooth trend</span>
    <span class="s1">mod = structural.UnobservedComponents([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'smooth trend'</span><span class="s1">)</span>
    <span class="s1">actual = mod.impulse_responses([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">steps)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">np.arange(steps + </span><span class="s4">1</span><span class="s1">))</span>

    <span class="s3"># Random trend</span>
    <span class="s1">mod = structural.UnobservedComponents([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'random trend'</span><span class="s1">)</span>
    <span class="s1">actual = mod.impulse_responses([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">steps)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">np.arange(steps + </span><span class="s4">1</span><span class="s1">))</span>

    <span class="s3"># Seasonal (deterministic)</span>
    <span class="s1">mod = structural.UnobservedComponents([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'irregular'</span><span class="s2">, </span><span class="s1">seasonal=</span><span class="s4">2</span><span class="s2">,</span>
                                          <span class="s1">stochastic_seasonal=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">actual = mod.impulse_responses([</span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">steps)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s3"># Seasonal (stochastic)</span>
    <span class="s1">mod = structural.UnobservedComponents([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'irregular'</span><span class="s2">, </span><span class="s1">seasonal=</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">actual = mod.impulse_responses([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">steps)</span>
    <span class="s1">desired = np.r_[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">np.tile([-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">steps // </span><span class="s4">2</span><span class="s1">)]</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Cycle (deterministic)</span>
    <span class="s1">mod = structural.UnobservedComponents([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'irregular'</span><span class="s2">, </span><span class="s1">cycle=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">actual = mod.impulse_responses([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">steps)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s3"># Cycle (stochastic)</span>
    <span class="s1">mod = structural.UnobservedComponents([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'irregular'</span><span class="s2">, </span><span class="s1">cycle=</span><span class="s2">True,</span>
                                          <span class="s1">stochastic_cycle=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">actual = mod.impulse_responses([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">steps=</span><span class="s4">10</span><span class="s1">)</span>
    <span class="s1">x1 = [np.cos(</span><span class="s4">1.2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.sin(</span><span class="s4">1.2</span><span class="s1">)]</span>
    <span class="s1">x2 = [-np.sin(</span><span class="s4">1.2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.cos(</span><span class="s4">1.2</span><span class="s1">)]</span>
    <span class="s1">T = np.array([x1</span><span class="s2">, </span><span class="s1">x2])</span>
    <span class="s1">desired = np.zeros(steps + </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">states = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(steps + </span><span class="s4">1</span><span class="s1">):</span>
        <span class="s1">desired[i] += states[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">states = np.dot(T</span><span class="s2">, </span><span class="s1">states)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>


<span class="s2">def </span><span class="s1">test_varmax():</span>
    <span class="s1">steps = </span><span class="s4">10</span>

    <span class="s3"># Clear warnings</span>
    <span class="s1">varmax.__warningregistry__ = {}</span>

    <span class="s3"># VAR(2) - single series</span>
    <span class="s1">mod1 = varmax.VARMAX([[</span><span class="s4">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'n'</span><span class="s1">)</span>
    <span class="s1">mod2 = sarimax.SARIMAX([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>
    <span class="s1">actual = mod1.impulse_responses([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">steps)</span>
    <span class="s1">desired = mod2.impulse_responses([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">steps)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># VMA(2) - single series</span>
    <span class="s1">mod1 = varmax.VARMAX([[</span><span class="s4">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'n'</span><span class="s1">)</span>
    <span class="s1">mod2 = sarimax.SARIMAX([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
    <span class="s1">actual = mod1.impulse_responses([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">steps)</span>
    <span class="s1">desired = mod2.impulse_responses([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">steps)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># VARMA(2, 2) - single series</span>
    <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
        <span class="s1">warnings.simplefilter(</span><span class="s5">&quot;ignore&quot;</span><span class="s1">)</span>
        <span class="s1">mod1 = varmax.VARMAX([[</span><span class="s4">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'n'</span><span class="s1">)</span>
    <span class="s1">mod2 = sarimax.SARIMAX([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
    <span class="s1">actual = mod1.impulse_responses([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">steps)</span>
    <span class="s1">desired = mod2.impulse_responses([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">steps)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># VARMA(2, 2) + trend - single series</span>
    <span class="s1">warning = EstimationWarning</span>
    <span class="s1">match = </span><span class="s5">r'VARMA\(p,q\) models is not'</span>
    <span class="s2">with </span><span class="s1">pytest.warns(warning</span><span class="s2">, </span><span class="s1">match=match):</span>
        <span class="s1">mod1 = varmax.VARMAX([[</span><span class="s4">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'c'</span><span class="s1">)</span>
    <span class="s1">mod2 = sarimax.SARIMAX([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'c'</span><span class="s1">)</span>
    <span class="s1">actual = mod1.impulse_responses([</span><span class="s4">10</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">steps)</span>
    <span class="s1">desired = mod2.impulse_responses([</span><span class="s4">10</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">steps)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># VAR(2) + constant</span>
    <span class="s3"># Stata:</span>
    <span class="s3"># webuse lutkepohl2</span>
    <span class="s3"># var dln_inv dln_inc, lags(1/2)</span>
    <span class="s3"># irf create irf3, set(irf3) step(10)</span>
    <span class="s3"># irf table irf</span>
    <span class="s3"># irf table oirf</span>
    <span class="s1">params = [-</span><span class="s4">.00122728</span><span class="s2">, </span><span class="s4">.01503679</span><span class="s2">,</span>
              <span class="s1">-</span><span class="s4">.22741923</span><span class="s2">, </span><span class="s4">.71030531</span><span class="s2">, </span><span class="s1">-</span><span class="s4">.11596357</span><span class="s2">, </span><span class="s4">.51494891</span><span class="s2">,</span>
              <span class="s4">.05974659</span><span class="s2">, </span><span class="s4">.02094608</span><span class="s2">, </span><span class="s4">.05635125</span><span class="s2">, </span><span class="s4">.08332519</span><span class="s2">,</span>
              <span class="s4">.04297918</span><span class="s2">, </span><span class="s4">.00159473</span><span class="s2">, </span><span class="s4">.01096298</span><span class="s1">]</span>
    <span class="s1">irf_00 = [</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">.227419</span><span class="s2">, </span><span class="s1">-</span><span class="s4">.021806</span><span class="s2">, </span><span class="s4">.093362</span><span class="s2">, </span><span class="s1">-</span><span class="s4">.001875</span><span class="s2">, </span><span class="s1">-</span><span class="s4">.00906</span><span class="s2">, </span><span class="s4">.009605</span><span class="s2">,</span>
              <span class="s4">.001323</span><span class="s2">, </span><span class="s1">-</span><span class="s4">.001041</span><span class="s2">, </span><span class="s4">.000769</span><span class="s2">, </span><span class="s4">.00032</span><span class="s1">]</span>
    <span class="s1">irf_01 = [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">.059747</span><span class="s2">, </span><span class="s4">.044015</span><span class="s2">, </span><span class="s1">-</span><span class="s4">.008218</span><span class="s2">, </span><span class="s4">.007845</span><span class="s2">, </span><span class="s4">.004629</span><span class="s2">, </span><span class="s4">.000104</span><span class="s2">,</span>
              <span class="s4">.000451</span><span class="s2">, </span><span class="s4">.000638</span><span class="s2">, </span><span class="s4">.000063</span><span class="s2">, </span><span class="s4">.000042</span><span class="s1">]</span>
    <span class="s1">irf_10 = [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">.710305</span><span class="s2">, </span><span class="s4">.36829</span><span class="s2">, </span><span class="s1">-</span><span class="s4">.065697</span><span class="s2">, </span><span class="s4">.084398</span><span class="s2">, </span><span class="s4">.043038</span><span class="s2">, </span><span class="s4">.000533</span><span class="s2">,</span>
              <span class="s4">.005755</span><span class="s2">, </span><span class="s4">.006051</span><span class="s2">, </span><span class="s4">.000548</span><span class="s2">, </span><span class="s4">.000526</span><span class="s1">]</span>
    <span class="s1">irf_11 = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">.020946</span><span class="s2">, </span><span class="s4">.126202</span><span class="s2">, </span><span class="s4">.066419</span><span class="s2">, </span><span class="s4">.028735</span><span class="s2">, </span><span class="s4">.007477</span><span class="s2">, </span><span class="s4">.009878</span><span class="s2">,</span>
              <span class="s4">.003287</span><span class="s2">, </span><span class="s4">.001266</span><span class="s2">, </span><span class="s4">.000986</span><span class="s2">, </span><span class="s4">.0005</span><span class="s1">]</span>
    <span class="s1">oirf_00 = [</span><span class="s4">0.042979</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.008642</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.00035</span><span class="s2">, </span><span class="s4">0.003908</span><span class="s2">, </span><span class="s4">0.000054</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.000321</span><span class="s2">,</span>
               <span class="s4">0.000414</span><span class="s2">, </span><span class="s4">0.000066</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.000035</span><span class="s2">, </span><span class="s4">0.000034</span><span class="s2">, </span><span class="s4">0.000015</span><span class="s1">]</span>
    <span class="s1">oirf_01 = [</span><span class="s4">0.001595</span><span class="s2">, </span><span class="s4">0.002601</span><span class="s2">, </span><span class="s4">0.002093</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.000247</span><span class="s2">, </span><span class="s4">0.000383</span><span class="s2">, </span><span class="s4">0.000211</span><span class="s2">,</span>
               <span class="s4">0.00002</span><span class="s2">, </span><span class="s4">0.000025</span><span class="s2">, </span><span class="s4">0.000029</span><span class="s2">, </span><span class="s4">4.30E-06</span><span class="s2">, </span><span class="s4">2.60E-06</span><span class="s1">]</span>
    <span class="s1">oirf_10 = [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.007787</span><span class="s2">, </span><span class="s4">0.004037</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.00072</span><span class="s2">, </span><span class="s4">0.000925</span><span class="s2">, </span><span class="s4">0.000472</span><span class="s2">, </span><span class="s4">5.80E-06</span><span class="s2">,</span>
               <span class="s4">0.000063</span><span class="s2">, </span><span class="s4">0.000066</span><span class="s2">, </span><span class="s4">6.00E-06</span><span class="s2">, </span><span class="s4">5.80E-06</span><span class="s1">]</span>
    <span class="s1">oirf_11 = [</span><span class="s4">0.010963</span><span class="s2">, </span><span class="s4">0.00023</span><span class="s2">, </span><span class="s4">0.001384</span><span class="s2">, </span><span class="s4">0.000728</span><span class="s2">, </span><span class="s4">0.000315</span><span class="s2">, </span><span class="s4">0.000082</span><span class="s2">,</span>
               <span class="s4">0.000108</span><span class="s2">, </span><span class="s4">0.000036</span><span class="s2">, </span><span class="s4">0.000014</span><span class="s2">, </span><span class="s4">0.000011</span><span class="s2">, </span><span class="s4">5.50E-06</span><span class="s1">]</span>

    <span class="s1">mod = varmax.VARMAX([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'c'</span><span class="s1">)</span>

    <span class="s3"># IRFs</span>
    <span class="s1">actual = mod.impulse_responses(params</span><span class="s2">, </span><span class="s1">steps</span><span class="s2">, </span><span class="s1">impulse=</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">np.c_[irf_00</span><span class="s2">, </span><span class="s1">irf_01]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-6</span><span class="s1">)</span>

    <span class="s1">actual = mod.impulse_responses(params</span><span class="s2">, </span><span class="s1">steps</span><span class="s2">, </span><span class="s1">impulse=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">np.c_[irf_10</span><span class="s2">, </span><span class="s1">irf_11]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-6</span><span class="s1">)</span>

    <span class="s3"># Orthogonalized IRFs</span>
    <span class="s1">actual = mod.impulse_responses(params</span><span class="s2">, </span><span class="s1">steps</span><span class="s2">, </span><span class="s1">impulse=</span><span class="s4">0</span><span class="s2">,</span>
                                   <span class="s1">orthogonalized=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">np.c_[oirf_00</span><span class="s2">, </span><span class="s1">oirf_01]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-6</span><span class="s1">)</span>

    <span class="s1">actual = mod.impulse_responses(params</span><span class="s2">, </span><span class="s1">steps</span><span class="s2">, </span><span class="s1">impulse=</span><span class="s4">1</span><span class="s2">,</span>
                                   <span class="s1">orthogonalized=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">np.c_[oirf_10</span><span class="s2">, </span><span class="s1">oirf_11]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-6</span><span class="s1">)</span>

    <span class="s3"># Impulse response passing column name</span>
    <span class="s1">data = get_macrodata().view((float</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">type=np.ndarray)</span>

    <span class="s1">df = pd.DataFrame({</span>
        <span class="s5">&quot;a&quot;</span><span class="s1">: data[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s5">&quot;b&quot;</span><span class="s1">: data[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s5">&quot;c&quot;</span><span class="s1">: data[:</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]})</span>

    <span class="s1">mod1 = varmax.VARMAX(df</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'c'</span><span class="s1">)</span>
    <span class="s1">mod1_result = mod1.fit()</span>
    <span class="s1">mod2 = varmax.VARMAX(data</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'c'</span><span class="s1">)</span>
    <span class="s1">mod2_result = mod2.fit()</span>

    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s5">'Endog must be pd.DataFrame.'</span><span class="s1">):</span>
        <span class="s1">mod2_result.impulse_responses(</span><span class="s4">6</span><span class="s2">, </span><span class="s1">impulse=</span><span class="s5">&quot;b&quot;</span><span class="s1">)</span>

    <span class="s1">response1 = mod1_result.impulse_responses(</span><span class="s4">6</span><span class="s2">, </span><span class="s1">impulse=</span><span class="s5">&quot;b&quot;</span><span class="s1">)</span>
    <span class="s1">response2 = mod1_result.impulse_responses(</span><span class="s4">6</span><span class="s2">, </span><span class="s1">impulse=[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">assert_allclose(response1</span><span class="s2">, </span><span class="s1">response2)</span>

    <span class="s3"># VARMA(2, 2) + trend + exog</span>
    <span class="s3"># TODO: This is just a smoke test</span>
    <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
        <span class="s1">warnings.simplefilter(</span><span class="s5">&quot;ignore&quot;</span><span class="s1">)</span>
        <span class="s1">mod = varmax.VARMAX(</span>
            <span class="s1">np.random.normal(size=(steps</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'c'</span><span class="s2">,</span>
            <span class="s1">exog=np.ones(steps)</span><span class="s2">, </span><span class="s1">enforce_stationarity=</span><span class="s2">False,</span>
            <span class="s1">enforce_invertibility=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">mod.impulse_responses(mod.start_params</span><span class="s2">, </span><span class="s1">steps)</span>


<span class="s2">def </span><span class="s1">test_dynamic_factor():</span>
    <span class="s1">steps = </span><span class="s4">10</span>
    <span class="s1">exog = np.random.normal(size=steps)</span>

    <span class="s3"># DFM: 2 series, AR(2) factor</span>
    <span class="s1">mod1 = dynamic_factor.DynamicFactor([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">mod2 = sarimax.SARIMAX([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>
    <span class="s1">actual = mod1.impulse_responses([-</span><span class="s4">0.9</span><span class="s2">, </span><span class="s4">0.8</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">steps)</span>
    <span class="s1">desired = mod2.impulse_responses([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">steps)</span>
    <span class="s1">assert_allclose(actual[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.9 </span><span class="s1">* desired)</span>
    <span class="s1">assert_allclose(actual[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0.8 </span><span class="s1">* desired)</span>

    <span class="s3"># DFM: 2 series, AR(2) factor, exog</span>
    <span class="s1">mod1 = dynamic_factor.DynamicFactor(np.zeros((steps</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s4">1</span><span class="s2">,</span>
                                        <span class="s1">factor_order=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">exog=exog)</span>
    <span class="s1">mod2 = sarimax.SARIMAX([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>
    <span class="s1">actual = mod1.impulse_responses(</span>
        <span class="s1">[-</span><span class="s4">0.9</span><span class="s2">, </span><span class="s4">0.8</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">steps)</span>
    <span class="s1">desired = mod2.impulse_responses([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">steps)</span>
    <span class="s1">assert_allclose(actual[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.9 </span><span class="s1">* desired)</span>
    <span class="s1">assert_allclose(actual[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0.8 </span><span class="s1">* desired)</span>

    <span class="s3"># DFM, 3 series, VAR(2) factor, exog, error VAR</span>
    <span class="s3"># TODO: This is just a smoke test</span>
    <span class="s1">mod = dynamic_factor.DynamicFactor(np.random.normal(size=(steps</span><span class="s2">, </span><span class="s4">3</span><span class="s1">))</span><span class="s2">,</span>
                                       <span class="s1">k_factors=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">,</span>
                                       <span class="s1">error_order=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">error_var=</span><span class="s2">True,</span>
                                       <span class="s1">enforce_stationarity=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">mod.impulse_responses(mod.start_params</span><span class="s2">, </span><span class="s1">steps)</span>


<span class="s2">def </span><span class="s1">test_time_varying_ssm():</span>
    <span class="s3"># Create an ad-hoc time-varying model</span>
    <span class="s1">mod = sarimax.SARIMAX([</span><span class="s4">0</span><span class="s1">] * </span><span class="s4">11</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>
    <span class="s1">mod.update([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">])</span>
    <span class="s1">T = np.zeros((</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">11</span><span class="s1">))</span>
    <span class="s1">T[...</span><span class="s2">, </span><span class="s1">:</span><span class="s4">5</span><span class="s1">] = </span><span class="s4">0.5</span>
    <span class="s1">T[...</span><span class="s2">, </span><span class="s4">5</span><span class="s1">:] = </span><span class="s4">0.2</span>
    <span class="s1">mod[</span><span class="s5">'transition'</span><span class="s1">] = T</span>

    <span class="s1">irfs = mod.ssm.impulse_responses()</span>
    <span class="s1">desired = np.cumprod(np.r_[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.5</span><span class="s1">] * </span><span class="s4">4</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.2</span><span class="s1">] * </span><span class="s4">5</span><span class="s1">]).reshape(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">assert_allclose(irfs</span><span class="s2">, </span><span class="s1">desired)</span>


<span class="s2">class </span><span class="s1">TVSS(mlemodel.MLEModel):</span>
    <span class="s0">&quot;&quot;&quot; 
    Time-varying state space model for testing 
 
    This creates a state space model with randomly generated time-varying 
    system matrices. When used in a test, that test should use 
    `reset_randomstate` to ensure consistent test runs. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">endog</span><span class="s2">, </span><span class="s1">_k_states=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">k_states = </span><span class="s4">2</span>
        <span class="s1">k_posdef = </span><span class="s4">2</span>
        <span class="s3"># Allow subcasses to add additional states</span>
        <span class="s2">if </span><span class="s1">_k_states </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">_k_states = k_states</span>
        <span class="s1">super(TVSS</span><span class="s2">, </span><span class="s1">self).__init__(endog</span><span class="s2">, </span><span class="s1">k_states=_k_states</span><span class="s2">,</span>
                                   <span class="s1">k_posdef=k_posdef</span><span class="s2">, </span><span class="s1">initialization=</span><span class="s5">'diffuse'</span><span class="s1">)</span>

        <span class="s1">self[</span><span class="s5">'obs_intercept'</span><span class="s1">] = np.random.normal(</span>
            <span class="s1">size=(self.k_endog</span><span class="s2">, </span><span class="s1">self.nobs))</span>
        <span class="s1">self[</span><span class="s5">'design'</span><span class="s1">] = np.zeros((self.k_endog</span><span class="s2">, </span><span class="s1">self.k_states</span><span class="s2">, </span><span class="s1">self.nobs))</span>
        <span class="s1">self[</span><span class="s5">'transition'</span><span class="s1">] = np.zeros(</span>
            <span class="s1">(self.k_states</span><span class="s2">, </span><span class="s1">self.k_states</span><span class="s2">, </span><span class="s1">self.nobs))</span>
        <span class="s1">self[</span><span class="s5">'selection'</span><span class="s1">] = np.zeros(</span>
            <span class="s1">(self.k_states</span><span class="s2">, </span><span class="s1">self.ssm.k_posdef</span><span class="s2">, </span><span class="s1">self.nobs))</span>
        <span class="s1">self[</span><span class="s5">'design'</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:k_states</span><span class="s2">, </span><span class="s1">:] = np.random.normal(</span>
            <span class="s1">size=(self.k_endog</span><span class="s2">, </span><span class="s1">k_states</span><span class="s2">, </span><span class="s1">self.nobs))</span>
        <span class="s3"># For the transition matrices, enforce eigenvalues not too far outside</span>
        <span class="s3"># unit circle. Otherwise, the random draws will often lead to large</span>
        <span class="s3"># eigenvalues that cause the covariance matrices to blow up to huge</span>
        <span class="s3"># values during long periods of missing data, which leads to numerical</span>
        <span class="s3"># problems and essentially spurious test failures</span>
        <span class="s1">D = [np.diag(d)</span>
             <span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">np.random.uniform(-</span><span class="s4">1.1</span><span class="s2">, </span><span class="s4">1.1</span><span class="s2">, </span><span class="s1">size=(self.nobs</span><span class="s2">, </span><span class="s1">k_states))]</span>
        <span class="s1">Q = ortho_group.rvs(k_states</span><span class="s2">, </span><span class="s1">size=self.nobs)</span>
        <span class="s1">self[</span><span class="s5">'transition'</span><span class="s2">, </span><span class="s1">:k_states</span><span class="s2">, </span><span class="s1">:k_states</span><span class="s2">, </span><span class="s1">:] = (</span>
            <span class="s1">Q @ D @ Q.transpose(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)).transpose(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self[</span><span class="s5">'selection'</span><span class="s2">, </span><span class="s1">:k_states</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:] = np.random.normal(</span>
            <span class="s1">size=(k_states</span><span class="s2">, </span><span class="s1">self.ssm.k_posdef</span><span class="s2">, </span><span class="s1">self.nobs))</span>

        <span class="s3"># Need to make sure the covariances are positive definite</span>
        <span class="s1">H05 = np.random.normal(size=(self.k_endog</span><span class="s2">, </span><span class="s1">self.k_endog</span><span class="s2">, </span><span class="s1">self.nobs))</span>
        <span class="s1">Q05 = np.random.normal(</span>
            <span class="s1">size=(self.ssm.k_posdef</span><span class="s2">, </span><span class="s1">self.ssm.k_posdef</span><span class="s2">, </span><span class="s1">self.nobs))</span>
        <span class="s1">H = np.zeros_like(H05)</span>
        <span class="s1">Q = np.zeros_like(Q05)</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">range(self.nobs):</span>
            <span class="s1">H[...</span><span class="s2">, </span><span class="s1">t] = np.dot(H05[...</span><span class="s2">, </span><span class="s1">t]</span><span class="s2">, </span><span class="s1">H05[...</span><span class="s2">, </span><span class="s1">t].T)</span>
            <span class="s1">Q[...</span><span class="s2">, </span><span class="s1">t] = np.dot(Q05[...</span><span class="s2">, </span><span class="s1">t]</span><span class="s2">, </span><span class="s1">Q05[...</span><span class="s2">, </span><span class="s1">t].T)</span>
        <span class="s1">self[</span><span class="s5">'obs_cov'</span><span class="s1">] = H</span>
        <span class="s1">self[</span><span class="s5">'state_cov'</span><span class="s1">] = Q</span>

    <span class="s2">def </span><span class="s1">clone(self</span><span class="s2">, </span><span class="s1">endog</span><span class="s2">, </span><span class="s1">exog=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s1">mod = self.__class__(endog</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">self.ssm.shapes.keys():</span>
            <span class="s2">if </span><span class="s1">key </span><span class="s2">in </span><span class="s1">[</span><span class="s5">'obs'</span><span class="s2">, </span><span class="s5">'state_intercept'</span><span class="s1">]:</span>
                <span class="s2">continue</span>
            <span class="s1">n = min(self.nobs</span><span class="s2">, </span><span class="s1">mod.nobs)</span>
            <span class="s1">mod[key</span><span class="s2">, </span><span class="s1">...</span><span class="s2">, </span><span class="s1">:n] = self.ssm[key</span><span class="s2">, </span><span class="s1">...</span><span class="s2">, </span><span class="s1">:n]</span>

        <span class="s2">return </span><span class="s1">mod</span>


<span class="s2">def </span><span class="s1">test_time_varying_in_sample(reset_randomstate):</span>
    <span class="s1">mod = TVSS(np.zeros((</span><span class="s4">10</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)))</span>

    <span class="s3"># Compute the max number of in-sample IRFs</span>
    <span class="s1">irfs = mod.impulse_responses([]</span><span class="s2">, </span><span class="s1">steps=mod.nobs - </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s3"># Compute the same thing, but now with explicit anchor argument</span>
    <span class="s1">irfs_anchor = mod.impulse_responses([]</span><span class="s2">, </span><span class="s1">steps=mod.nobs - </span><span class="s4">1</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s3"># Cumulative IRFs</span>
    <span class="s1">cirfs = mod.impulse_responses([]</span><span class="s2">, </span><span class="s1">steps=mod.nobs - </span><span class="s4">1</span><span class="s2">, </span><span class="s1">cumulative=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s3"># Orthogonalized IRFs</span>
    <span class="s1">oirfs = mod.impulse_responses([]</span><span class="s2">, </span><span class="s1">steps=mod.nobs - </span><span class="s4">1</span><span class="s2">, </span><span class="s1">orthogonalized=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s3"># Cumulative, orthogonalized IRFs</span>
    <span class="s1">coirfs = mod.impulse_responses([]</span><span class="s2">, </span><span class="s1">steps=mod.nobs - </span><span class="s4">1</span><span class="s2">, </span><span class="s1">cumulative=</span><span class="s2">True,</span>
                                   <span class="s1">orthogonalized=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s3"># Compute IRFs manually</span>
    <span class="s1">Z = mod[</span><span class="s5">'design'</span><span class="s1">]</span>
    <span class="s1">T = mod[</span><span class="s5">'transition'</span><span class="s1">]</span>
    <span class="s1">R = mod[</span><span class="s5">'selection'</span><span class="s1">]</span>
    <span class="s1">Q = mod[</span><span class="s5">'state_cov'</span><span class="s2">, </span><span class="s1">...</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">L = np.linalg.cholesky(Q)</span>

    <span class="s1">desired_irfs = np.zeros((mod.nobs - </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)) * np.nan</span>
    <span class="s1">desired_oirfs = np.zeros((mod.nobs - </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)) * np.nan</span>
    <span class="s1">tmp = R[...</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">mod.nobs):</span>
        <span class="s1">desired_irfs[i - </span><span class="s4">1</span><span class="s1">] = Z[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">i].dot(tmp)[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">desired_oirfs[i - </span><span class="s4">1</span><span class="s1">] = Z[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">i].dot(tmp).dot(L)[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">tmp = T[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">i].dot(tmp)</span>

    <span class="s1">assert_allclose(irfs</span><span class="s2">, </span><span class="s1">desired_irfs)</span>
    <span class="s1">assert_allclose(irfs_anchor</span><span class="s2">, </span><span class="s1">desired_irfs)</span>

    <span class="s1">assert_allclose(cirfs</span><span class="s2">, </span><span class="s1">np.cumsum(desired_irfs</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">))</span>
    <span class="s1">assert_allclose(oirfs</span><span class="s2">, </span><span class="s1">desired_oirfs)</span>
    <span class="s1">assert_allclose(coirfs</span><span class="s2">, </span><span class="s1">np.cumsum(desired_oirfs</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">test_time_varying_out_of_sample(reset_randomstate):</span>
    <span class="s1">mod = TVSS(np.zeros((</span><span class="s4">10</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)))</span>

    <span class="s3"># Compute all in-sample IRFs and also one out-of-sample IRF</span>
    <span class="s1">new_Z = np.random.normal(size=mod[</span><span class="s5">'design'</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">].shape)</span>
    <span class="s1">new_T = np.random.normal(size=mod[</span><span class="s5">'transition'</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">].shape)</span>
    <span class="s1">irfs = mod.impulse_responses(</span>
        <span class="s1">[]</span><span class="s2">, </span><span class="s1">steps=mod.nobs</span><span class="s2">, </span><span class="s1">design=new_Z[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">transition=new_T[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, None</span><span class="s1">])</span>
    <span class="s3"># Compute the same thing, but now with explicit anchor argument</span>
    <span class="s1">irfs_anchor = mod.impulse_responses(</span>
        <span class="s1">[]</span><span class="s2">, </span><span class="s1">steps=mod.nobs</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">design=new_Z[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">transition=new_T[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, None</span><span class="s1">])</span>

    <span class="s3"># Cumulative IRFs</span>
    <span class="s1">cirfs = mod.impulse_responses([]</span><span class="s2">, </span><span class="s1">steps=mod.nobs</span><span class="s2">, </span><span class="s1">design=new_Z[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
                                  <span class="s1">transition=new_T[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
                                  <span class="s1">cumulative=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s3"># Orthogonalized IRFs</span>
    <span class="s1">oirfs = mod.impulse_responses([]</span><span class="s2">, </span><span class="s1">steps=mod.nobs</span><span class="s2">, </span><span class="s1">design=new_Z[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
                                  <span class="s1">transition=new_T[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
                                  <span class="s1">orthogonalized=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s3"># Cumulative, orthogonalized IRFs</span>
    <span class="s1">coirfs = mod.impulse_responses(</span>
        <span class="s1">[]</span><span class="s2">, </span><span class="s1">steps=mod.nobs</span><span class="s2">, </span><span class="s1">design=new_Z[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">transition=new_T[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">cumulative=</span><span class="s2">True, </span><span class="s1">orthogonalized=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s3"># Compute IRFs manually</span>
    <span class="s1">Z = mod[</span><span class="s5">'design'</span><span class="s1">]</span>
    <span class="s1">T = mod[</span><span class="s5">'transition'</span><span class="s1">]</span>
    <span class="s1">R = mod[</span><span class="s5">'selection'</span><span class="s1">]</span>
    <span class="s1">Q = mod[</span><span class="s5">'state_cov'</span><span class="s2">, </span><span class="s1">...</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">L = np.linalg.cholesky(Q)</span>

    <span class="s1">desired_irfs = np.zeros((mod.nobs</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)) * np.nan</span>
    <span class="s1">desired_oirfs = np.zeros((mod.nobs</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)) * np.nan</span>
    <span class="s1">tmp = R[...</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">mod.nobs):</span>
        <span class="s1">desired_irfs[i - </span><span class="s4">1</span><span class="s1">] = Z[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">i].dot(tmp)[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">desired_oirfs[i - </span><span class="s4">1</span><span class="s1">] = Z[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">i].dot(tmp).dot(L)[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">tmp = T[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">i].dot(tmp)</span>
    <span class="s1">desired_irfs[mod.nobs - </span><span class="s4">1</span><span class="s1">] = new_Z.dot(tmp)[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">desired_oirfs[mod.nobs - </span><span class="s4">1</span><span class="s1">] = new_Z.dot(tmp).dot(L)[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>

    <span class="s1">assert_allclose(irfs</span><span class="s2">, </span><span class="s1">desired_irfs)</span>
    <span class="s1">assert_allclose(irfs_anchor</span><span class="s2">, </span><span class="s1">desired_irfs)</span>

    <span class="s1">assert_allclose(cirfs</span><span class="s2">, </span><span class="s1">np.cumsum(desired_irfs</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">))</span>
    <span class="s1">assert_allclose(oirfs</span><span class="s2">, </span><span class="s1">desired_oirfs)</span>
    <span class="s1">assert_allclose(coirfs</span><span class="s2">, </span><span class="s1">np.cumsum(desired_oirfs</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">test_time_varying_in_sample_anchored(reset_randomstate):</span>
    <span class="s1">mod = TVSS(np.zeros((</span><span class="s4">10</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)))</span>

    <span class="s3"># Compute the max number of in-sample IRFs</span>
    <span class="s1">anchor = </span><span class="s4">2</span>
    <span class="s1">irfs = mod.impulse_responses(</span>
        <span class="s1">[]</span><span class="s2">, </span><span class="s1">steps=mod.nobs - </span><span class="s4">1 </span><span class="s1">- anchor</span><span class="s2">, </span><span class="s1">anchor=anchor)</span>

    <span class="s3"># Cumulative IRFs</span>
    <span class="s1">cirfs = mod.impulse_responses(</span>
        <span class="s1">[]</span><span class="s2">, </span><span class="s1">steps=mod.nobs - </span><span class="s4">1 </span><span class="s1">- anchor</span><span class="s2">, </span><span class="s1">anchor=anchor</span><span class="s2">,</span>
        <span class="s1">cumulative=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s3"># Orthogonalized IRFs</span>
    <span class="s1">oirfs = mod.impulse_responses(</span>
        <span class="s1">[]</span><span class="s2">, </span><span class="s1">steps=mod.nobs - </span><span class="s4">1 </span><span class="s1">- anchor</span><span class="s2">, </span><span class="s1">anchor=anchor</span><span class="s2">,</span>
        <span class="s1">orthogonalized=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s3"># Cumulative, orthogonalized IRFs</span>
    <span class="s1">coirfs = mod.impulse_responses(</span>
        <span class="s1">[]</span><span class="s2">, </span><span class="s1">steps=mod.nobs - </span><span class="s4">1 </span><span class="s1">- anchor</span><span class="s2">, </span><span class="s1">anchor=anchor</span><span class="s2">,</span>
        <span class="s1">cumulative=</span><span class="s2">True, </span><span class="s1">orthogonalized=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s3"># Compute IRFs manually</span>
    <span class="s1">Z = mod[</span><span class="s5">'design'</span><span class="s1">]</span>
    <span class="s1">T = mod[</span><span class="s5">'transition'</span><span class="s1">]</span>
    <span class="s1">R = mod[</span><span class="s5">'selection'</span><span class="s1">]</span>
    <span class="s1">Q = mod[</span><span class="s5">'state_cov'</span><span class="s2">, </span><span class="s1">...</span><span class="s2">, </span><span class="s1">anchor]</span>
    <span class="s1">L = np.linalg.cholesky(Q)</span>

    <span class="s1">desired_irfs = np.zeros((mod.nobs - anchor - </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)) * np.nan</span>
    <span class="s1">desired_oirfs = np.zeros((mod.nobs - anchor - </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)) * np.nan</span>
    <span class="s1">tmp = R[...</span><span class="s2">, </span><span class="s1">anchor]</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">mod.nobs - anchor):</span>
        <span class="s1">desired_irfs[i - </span><span class="s4">1</span><span class="s1">] = Z[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">i + anchor].dot(tmp)[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">desired_oirfs[i - </span><span class="s4">1</span><span class="s1">] = Z[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">i + anchor].dot(tmp).dot(L)[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">tmp = T[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">i + anchor].dot(tmp)</span>

    <span class="s1">assert_allclose(irfs</span><span class="s2">, </span><span class="s1">desired_irfs)</span>

    <span class="s1">assert_allclose(cirfs</span><span class="s2">, </span><span class="s1">np.cumsum(desired_irfs</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">))</span>
    <span class="s1">assert_allclose(oirfs</span><span class="s2">, </span><span class="s1">desired_oirfs)</span>
    <span class="s1">assert_allclose(coirfs</span><span class="s2">, </span><span class="s1">np.cumsum(desired_oirfs</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">test_time_varying_out_of_sample_anchored(reset_randomstate):</span>
    <span class="s1">mod = TVSS(np.zeros((</span><span class="s4">10</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)))</span>

    <span class="s3"># Compute all in-sample IRFs and also one out-of-sample IRF</span>
    <span class="s1">anchor = </span><span class="s4">2</span>

    <span class="s1">new_Z = mod[</span><span class="s5">'design'</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">new_T = mod[</span><span class="s5">'transition'</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">irfs = mod.impulse_responses(</span>
        <span class="s1">[]</span><span class="s2">, </span><span class="s1">steps=mod.nobs - anchor</span><span class="s2">, </span><span class="s1">anchor=anchor</span><span class="s2">, </span><span class="s1">design=new_Z[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">transition=new_T[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, None</span><span class="s1">])</span>

    <span class="s3"># Cumulative IRFs</span>
    <span class="s1">cirfs = mod.impulse_responses(</span>
        <span class="s1">[]</span><span class="s2">, </span><span class="s1">steps=mod.nobs - anchor</span><span class="s2">, </span><span class="s1">anchor=anchor</span><span class="s2">,</span>
        <span class="s1">design=new_Z[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">transition=new_T[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">cumulative=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s3"># Orthogonalized IRFs</span>
    <span class="s1">oirfs = mod.impulse_responses(</span>
        <span class="s1">[]</span><span class="s2">, </span><span class="s1">steps=mod.nobs - anchor</span><span class="s2">, </span><span class="s1">anchor=anchor</span><span class="s2">,</span>
        <span class="s1">design=new_Z[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">transition=new_T[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">orthogonalized=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s3"># Cumulative, orthogonalized IRFs</span>
    <span class="s1">coirfs = mod.impulse_responses(</span>
        <span class="s1">[]</span><span class="s2">, </span><span class="s1">steps=mod.nobs - anchor</span><span class="s2">, </span><span class="s1">anchor=anchor</span><span class="s2">,</span>
        <span class="s1">design=new_Z[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">transition=new_T[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">cumulative=</span><span class="s2">True, </span><span class="s1">orthogonalized=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s3"># Compute IRFs manually</span>
    <span class="s1">Z = mod[</span><span class="s5">'design'</span><span class="s1">]</span>
    <span class="s1">T = mod[</span><span class="s5">'transition'</span><span class="s1">]</span>
    <span class="s1">R = mod[</span><span class="s5">'selection'</span><span class="s1">]</span>
    <span class="s1">Q = mod[</span><span class="s5">'state_cov'</span><span class="s2">, </span><span class="s1">...</span><span class="s2">, </span><span class="s1">anchor]</span>
    <span class="s1">L = np.linalg.cholesky(Q)</span>

    <span class="s1">desired_irfs = np.zeros((mod.nobs - anchor</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)) * np.nan</span>
    <span class="s1">desired_oirfs = np.zeros((mod.nobs - anchor</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)) * np.nan</span>
    <span class="s1">tmp = R[...</span><span class="s2">, </span><span class="s1">anchor]</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">mod.nobs - anchor):</span>
        <span class="s1">desired_irfs[i - </span><span class="s4">1</span><span class="s1">] = Z[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">i + anchor].dot(tmp)[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">desired_oirfs[i - </span><span class="s4">1</span><span class="s1">] = Z[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">i + anchor].dot(tmp).dot(L)[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">tmp = T[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">i + anchor].dot(tmp)</span>
    <span class="s1">desired_irfs[mod.nobs - anchor - </span><span class="s4">1</span><span class="s1">] = new_Z.dot(tmp)[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">desired_oirfs[mod.nobs - anchor - </span><span class="s4">1</span><span class="s1">] = new_Z.dot(tmp).dot(L)[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>

    <span class="s1">assert_allclose(irfs</span><span class="s2">, </span><span class="s1">desired_irfs)</span>

    <span class="s1">assert_allclose(cirfs</span><span class="s2">, </span><span class="s1">np.cumsum(desired_irfs</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">))</span>
    <span class="s1">assert_allclose(oirfs</span><span class="s2">, </span><span class="s1">desired_oirfs)</span>
    <span class="s1">assert_allclose(coirfs</span><span class="s2">, </span><span class="s1">np.cumsum(desired_oirfs</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">test_time_varying_out_of_sample_anchored_end(reset_randomstate):</span>
    <span class="s1">mod = TVSS(np.zeros((</span><span class="s4">10</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)))</span>

    <span class="s3"># Cannot compute the any in-sample IRFs when anchoring at the end</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s5">'Model has time-varying'</span><span class="s1">):</span>
        <span class="s1">mod.impulse_responses([]</span><span class="s2">, </span><span class="s1">steps=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s1">)</span>

    <span class="s3"># Compute two out-of-sample IRFs</span>
    <span class="s1">new_Z = np.random.normal(size=mod[</span><span class="s5">'design'</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s1">:].shape)</span>
    <span class="s1">new_T = np.random.normal(size=mod[</span><span class="s5">'transition'</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s1">:].shape)</span>
    <span class="s1">irfs = mod.impulse_responses([]</span><span class="s2">, </span><span class="s1">steps=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
                                 <span class="s1">design=new_Z</span><span class="s2">, </span><span class="s1">transition=new_T)</span>

    <span class="s3"># Cumulative IRFs</span>
    <span class="s1">cirfs = mod.impulse_responses(</span>
        <span class="s1">[]</span><span class="s2">, </span><span class="s1">steps=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">, </span><span class="s1">design=new_Z</span><span class="s2">, </span><span class="s1">transition=new_T</span><span class="s2">,</span>
        <span class="s1">cumulative=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s3"># Orthogonalized IRFs</span>
    <span class="s1">oirfs = mod.impulse_responses(</span>
        <span class="s1">[]</span><span class="s2">, </span><span class="s1">steps=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">, </span><span class="s1">design=new_Z</span><span class="s2">, </span><span class="s1">transition=new_T</span><span class="s2">,</span>
        <span class="s1">orthogonalized=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s3"># Cumulative, orthogonalized IRFs</span>
    <span class="s1">coirfs = mod.impulse_responses(</span>
        <span class="s1">[]</span><span class="s2">, </span><span class="s1">steps=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">, </span><span class="s1">design=new_Z</span><span class="s2">, </span><span class="s1">transition=new_T</span><span class="s2">,</span>
        <span class="s1">cumulative=</span><span class="s2">True, </span><span class="s1">orthogonalized=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s3"># Compute IRFs manually</span>
    <span class="s1">R = mod[</span><span class="s5">'selection'</span><span class="s1">]</span>
    <span class="s1">Q = mod[</span><span class="s5">'state_cov'</span><span class="s2">, </span><span class="s1">...</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">L = np.linalg.cholesky(Q)</span>

    <span class="s1">desired_irfs = np.zeros((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)) * np.nan</span>
    <span class="s1">desired_oirfs = np.zeros((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)) * np.nan</span>
    <span class="s3"># desired[0] = 0</span>
    <span class="s3"># Z_{T+1} R_T</span>
    <span class="s1">tmp = R[...</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">desired_irfs[</span><span class="s4">0</span><span class="s1">] = new_Z[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">].dot(tmp)[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">desired_oirfs[</span><span class="s4">0</span><span class="s1">] = new_Z[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">].dot(tmp).dot(L)[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
    <span class="s3"># T_{T+1} R_T</span>
    <span class="s1">tmp = new_T[...</span><span class="s2">, </span><span class="s4">0</span><span class="s1">].dot(tmp)</span>
    <span class="s3"># Z_{T+2} T_{T+1} R_T</span>
    <span class="s1">desired_irfs[</span><span class="s4">1</span><span class="s1">] = new_Z[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">].dot(tmp)[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">desired_oirfs[</span><span class="s4">1</span><span class="s1">] = new_Z[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">].dot(tmp).dot(L)[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>

    <span class="s1">assert_allclose(irfs</span><span class="s2">, </span><span class="s1">desired_irfs)</span>

    <span class="s1">assert_allclose(cirfs</span><span class="s2">, </span><span class="s1">np.cumsum(desired_irfs</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">))</span>
    <span class="s1">assert_allclose(oirfs</span><span class="s2">, </span><span class="s1">desired_oirfs)</span>
    <span class="s1">assert_allclose(coirfs</span><span class="s2">, </span><span class="s1">np.cumsum(desired_oirfs</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">test_pandas_univariate_rangeindex():</span>
    <span class="s3"># Impulse responses have RangeIndex</span>
    <span class="s1">endog = pd.Series(np.zeros(</span><span class="s4">1</span><span class="s1">))</span>
    <span class="s1">mod = sarimax.SARIMAX(endog)</span>
    <span class="s1">res = mod.filter([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s1">actual = res.impulse_responses(</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">desired = pd.Series([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.25</span><span class="s1">])</span>
    <span class="s1">assert_allclose(res.impulse_responses(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">desired)</span>
    <span class="s1">assert_(actual.index.equals(desired.index))</span>


<span class="s2">def </span><span class="s1">test_pandas_univariate_dateindex():</span>
    <span class="s3"># Impulse responses still have RangeIndex (i.e. aren't wrapped with dates)</span>
    <span class="s1">ix = pd.date_range(start=</span><span class="s5">'2000'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">'M'</span><span class="s1">)</span>
    <span class="s1">endog = pd.Series(np.zeros(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">index=ix)</span>
    <span class="s1">mod = sarimax.SARIMAX(endog)</span>
    <span class="s1">res = mod.filter([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s1">actual = res.impulse_responses(</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">desired = pd.Series([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.25</span><span class="s1">])</span>
    <span class="s1">assert_allclose(res.impulse_responses(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">desired)</span>
    <span class="s1">assert_(actual.index.equals(desired.index))</span>


<span class="s2">def </span><span class="s1">test_pandas_multivariate_rangeindex():</span>
    <span class="s3"># Impulse responses have RangeIndex</span>
    <span class="s1">endog = pd.DataFrame(np.zeros((</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)))</span>
    <span class="s1">mod = varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'n'</span><span class="s1">)</span>
    <span class="s1">res = mod.filter([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s1">actual = res.impulse_responses(</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">desired = pd.DataFrame([[</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.25</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">]]).T</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>
    <span class="s1">assert_(actual.index.equals(desired.index))</span>


<span class="s2">def </span><span class="s1">test_pandas_multivariate_dateindex():</span>
    <span class="s3"># Impulse responses still have RangeIndex (i.e. aren't wrapped with dates)</span>
    <span class="s1">ix = pd.date_range(start=</span><span class="s5">'2000'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">'M'</span><span class="s1">)</span>
    <span class="s1">endog = pd.DataFrame(np.zeros((</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span><span class="s2">, </span><span class="s1">index=ix)</span>
    <span class="s1">mod = varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'n'</span><span class="s1">)</span>
    <span class="s1">res = mod.filter([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s1">actual = res.impulse_responses(</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">desired = pd.DataFrame([[</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.25</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">]]).T</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>
    <span class="s1">assert_(actual.index.equals(desired.index))</span>


<span class="s2">def </span><span class="s1">test_pandas_anchor():</span>
    <span class="s3"># Test that anchor with dates works</span>
    <span class="s1">ix = pd.date_range(start=</span><span class="s5">'2000'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">'M'</span><span class="s1">)</span>
    <span class="s1">endog = pd.DataFrame(np.zeros((</span><span class="s4">10</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span><span class="s2">, </span><span class="s1">index=ix)</span>
    <span class="s1">mod = TVSS(endog)</span>
    <span class="s1">res = mod.filter([])</span>

    <span class="s1">desired = res.impulse_responses(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s3"># Anchor to date</span>
    <span class="s1">actual = res.impulse_responses(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">anchor=ix[</span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>
    <span class="s1">assert_(actual.index.equals(desired.index))</span>

    <span class="s3"># Anchor to negative index</span>
    <span class="s1">actual = res.impulse_responses(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">anchor=-</span><span class="s4">9</span><span class="s1">)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>
    <span class="s1">assert_(actual.index.equals(desired.index))</span>
</pre>
</body>
</html>