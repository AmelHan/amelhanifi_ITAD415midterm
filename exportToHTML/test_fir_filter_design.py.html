<html>
<head>
<title>test_fir_filter_design.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_fir_filter_design.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">(assert_almost_equal</span><span class="s0">, </span><span class="s1">assert_array_almost_equal</span><span class="s0">,</span>
                           <span class="s1">assert_equal</span><span class="s0">, </span><span class="s1">assert_</span><span class="s0">,</span>
                           <span class="s1">assert_allclose</span><span class="s0">, </span><span class="s1">assert_warns)</span>
<span class="s0">from </span><span class="s1">pytest </span><span class="s0">import </span><span class="s1">raises </span><span class="s0">as </span><span class="s1">assert_raises</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">from </span><span class="s1">scipy.fft </span><span class="s0">import </span><span class="s1">fft</span>
<span class="s0">from </span><span class="s1">scipy.special </span><span class="s0">import </span><span class="s1">sinc</span>
<span class="s0">from </span><span class="s1">scipy.signal </span><span class="s0">import </span><span class="s1">kaiser_beta</span><span class="s0">, </span><span class="s1">kaiser_atten</span><span class="s0">, </span><span class="s1">kaiserord</span><span class="s0">, </span><span class="s1">\</span>
    <span class="s1">firwin</span><span class="s0">, </span><span class="s1">firwin2</span><span class="s0">, </span><span class="s1">freqz</span><span class="s0">, </span><span class="s1">remez</span><span class="s0">, </span><span class="s1">firls</span><span class="s0">, </span><span class="s1">minimum_phase</span>


<span class="s0">def </span><span class="s1">test_kaiser_beta():</span>
    <span class="s1">b = kaiser_beta(</span><span class="s2">58.7</span><span class="s1">)</span>
    <span class="s1">assert_almost_equal(b</span><span class="s0">, </span><span class="s2">0.1102 </span><span class="s1">* </span><span class="s2">50.0</span><span class="s1">)</span>
    <span class="s1">b = kaiser_beta(</span><span class="s2">22.0</span><span class="s1">)</span>
    <span class="s1">assert_almost_equal(b</span><span class="s0">, </span><span class="s2">0.5842 </span><span class="s1">+ </span><span class="s2">0.07886</span><span class="s1">)</span>
    <span class="s1">b = kaiser_beta(</span><span class="s2">21.0</span><span class="s1">)</span>
    <span class="s1">assert_equal(b</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">)</span>
    <span class="s1">b = kaiser_beta(</span><span class="s2">10.0</span><span class="s1">)</span>
    <span class="s1">assert_equal(b</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_kaiser_atten():</span>
    <span class="s1">a = kaiser_atten(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">)</span>
    <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s2">7.95</span><span class="s1">)</span>
    <span class="s1">a = kaiser_atten(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">/np.pi)</span>
    <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s2">2.285 </span><span class="s1">+ </span><span class="s2">7.95</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_kaiserord():</span>
    <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">kaiserord</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">)</span>
    <span class="s1">numtaps</span><span class="s0">, </span><span class="s1">beta = kaiserord(</span><span class="s2">2.285 </span><span class="s1">+ </span><span class="s2">7.95 </span><span class="s1">- </span><span class="s2">0.001</span><span class="s0">, </span><span class="s2">1</span><span class="s1">/np.pi)</span>
    <span class="s1">assert_equal((numtaps</span><span class="s0">, </span><span class="s1">beta)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">))</span>


<span class="s0">class </span><span class="s1">TestFirwin:</span>

    <span class="s0">def </span><span class="s1">check_response(self</span><span class="s0">, </span><span class="s1">h</span><span class="s0">, </span><span class="s1">expected_response</span><span class="s0">, </span><span class="s1">tol=</span><span class="s2">.05</span><span class="s1">):</span>
        <span class="s1">N = len(h)</span>
        <span class="s1">alpha = </span><span class="s2">0.5 </span><span class="s1">* (N-</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">m = np.arange(</span><span class="s2">0</span><span class="s0">,</span><span class="s1">N) - alpha   </span><span class="s3"># time indices of taps</span>
        <span class="s0">for </span><span class="s1">freq</span><span class="s0">, </span><span class="s1">expected </span><span class="s0">in </span><span class="s1">expected_response:</span>
            <span class="s1">actual = abs(np.sum(h*np.exp(-</span><span class="s2">1.j</span><span class="s1">*np.pi*m*freq)))</span>
            <span class="s1">mse = abs(actual-expected)**</span><span class="s2">2</span>
            <span class="s1">assert_(mse &lt; tol</span><span class="s0">, </span><span class="s4">'response not as expected, mse=%g &gt; %g'</span>
               <span class="s1">% (mse</span><span class="s0">, </span><span class="s1">tol))</span>

    <span class="s0">def </span><span class="s1">test_response(self):</span>
        <span class="s1">N = </span><span class="s2">51</span>
        <span class="s1">f = </span><span class="s2">.5</span>
        <span class="s3"># increase length just to try even/odd</span>
        <span class="s1">h = firwin(N</span><span class="s0">, </span><span class="s1">f)  </span><span class="s3"># low-pass from 0 to f</span>
        <span class="s1">self.check_response(h</span><span class="s0">, </span><span class="s1">[(</span><span class="s2">.25</span><span class="s0">,</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">.75</span><span class="s0">,</span><span class="s2">0</span><span class="s1">)])</span>

        <span class="s1">h = firwin(N+</span><span class="s2">1</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">window=</span><span class="s4">'nuttall'</span><span class="s1">)  </span><span class="s3"># specific window</span>
        <span class="s1">self.check_response(h</span><span class="s0">, </span><span class="s1">[(</span><span class="s2">.25</span><span class="s0">,</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">.75</span><span class="s0">,</span><span class="s2">0</span><span class="s1">)])</span>

        <span class="s1">h = firwin(N+</span><span class="s2">2</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">pass_zero=</span><span class="s0">False</span><span class="s1">)  </span><span class="s3"># stop from 0 to f --&gt; high-pass</span>
        <span class="s1">self.check_response(h</span><span class="s0">, </span><span class="s1">[(</span><span class="s2">.25</span><span class="s0">,</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">.75</span><span class="s0">,</span><span class="s2">1</span><span class="s1">)])</span>

        <span class="s1">f1</span><span class="s0">, </span><span class="s1">f2</span><span class="s0">, </span><span class="s1">f3</span><span class="s0">, </span><span class="s1">f4 = </span><span class="s2">.2</span><span class="s0">, </span><span class="s2">.4</span><span class="s0">, </span><span class="s2">.6</span><span class="s0">, </span><span class="s2">.8</span>
        <span class="s1">h = firwin(N+</span><span class="s2">3</span><span class="s0">, </span><span class="s1">[f1</span><span class="s0">, </span><span class="s1">f2]</span><span class="s0">, </span><span class="s1">pass_zero=</span><span class="s0">False</span><span class="s1">)  </span><span class="s3"># band-pass filter</span>
        <span class="s1">self.check_response(h</span><span class="s0">, </span><span class="s1">[(</span><span class="s2">.1</span><span class="s0">,</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">.3</span><span class="s0">,</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">.5</span><span class="s0">,</span><span class="s2">0</span><span class="s1">)])</span>

        <span class="s1">h = firwin(N+</span><span class="s2">4</span><span class="s0">, </span><span class="s1">[f1</span><span class="s0">, </span><span class="s1">f2])  </span><span class="s3"># band-stop filter</span>
        <span class="s1">self.check_response(h</span><span class="s0">, </span><span class="s1">[(</span><span class="s2">.1</span><span class="s0">,</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">.3</span><span class="s0">,</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">.5</span><span class="s0">,</span><span class="s2">1</span><span class="s1">)])</span>

        <span class="s1">h = firwin(N+</span><span class="s2">5</span><span class="s0">, </span><span class="s1">[f1</span><span class="s0">, </span><span class="s1">f2</span><span class="s0">, </span><span class="s1">f3</span><span class="s0">, </span><span class="s1">f4]</span><span class="s0">, </span><span class="s1">pass_zero=</span><span class="s0">False, </span><span class="s1">scale=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">self.check_response(h</span><span class="s0">, </span><span class="s1">[(</span><span class="s2">.1</span><span class="s0">,</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">.3</span><span class="s0">,</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">.5</span><span class="s0">,</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">.7</span><span class="s0">,</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">.9</span><span class="s0">,</span><span class="s2">0</span><span class="s1">)])</span>

        <span class="s1">h = firwin(N+</span><span class="s2">6</span><span class="s0">, </span><span class="s1">[f1</span><span class="s0">, </span><span class="s1">f2</span><span class="s0">, </span><span class="s1">f3</span><span class="s0">, </span><span class="s1">f4])  </span><span class="s3"># multiband filter</span>
        <span class="s1">self.check_response(h</span><span class="s0">, </span><span class="s1">[(</span><span class="s2">.1</span><span class="s0">,</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">.3</span><span class="s0">,</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">.5</span><span class="s0">,</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">.7</span><span class="s0">,</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">.9</span><span class="s0">,</span><span class="s2">1</span><span class="s1">)])</span>

        <span class="s1">h = firwin(N+</span><span class="s2">7</span><span class="s0">, </span><span class="s2">0.1</span><span class="s0">, </span><span class="s1">width=</span><span class="s2">.03</span><span class="s1">)  </span><span class="s3"># low-pass</span>
        <span class="s1">self.check_response(h</span><span class="s0">, </span><span class="s1">[(</span><span class="s2">.05</span><span class="s0">,</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">.75</span><span class="s0">,</span><span class="s2">0</span><span class="s1">)])</span>

        <span class="s1">h = firwin(N+</span><span class="s2">8</span><span class="s0">, </span><span class="s2">0.1</span><span class="s0">, </span><span class="s1">pass_zero=</span><span class="s0">False</span><span class="s1">)  </span><span class="s3"># high-pass</span>
        <span class="s1">self.check_response(h</span><span class="s0">, </span><span class="s1">[(</span><span class="s2">.05</span><span class="s0">,</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">.75</span><span class="s0">,</span><span class="s2">1</span><span class="s1">)])</span>

    <span class="s0">def </span><span class="s1">mse(self</span><span class="s0">, </span><span class="s1">h</span><span class="s0">, </span><span class="s1">bands):</span>
        <span class="s5">&quot;&quot;&quot;Compute mean squared error versus ideal response across frequency 
        band. 
          h -- coefficients 
          bands -- list of (left, right) tuples relative to 1==Nyquist of 
            passbands 
        &quot;&quot;&quot;</span>
        <span class="s1">w</span><span class="s0">, </span><span class="s1">H = freqz(h</span><span class="s0">, </span><span class="s1">worN=</span><span class="s2">1024</span><span class="s1">)</span>
        <span class="s1">f = w/np.pi</span>
        <span class="s1">passIndicator = np.zeros(len(w)</span><span class="s0">, </span><span class="s1">bool)</span>
        <span class="s0">for </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right </span><span class="s0">in </span><span class="s1">bands:</span>
            <span class="s1">passIndicator |= (f &gt;= left) &amp; (f &lt; right)</span>
        <span class="s1">Hideal = np.where(passIndicator</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">mse = np.mean(abs(abs(H)-Hideal)**</span><span class="s2">2</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">mse</span>

    <span class="s0">def </span><span class="s1">test_scaling(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        For one lowpass, bandpass, and highpass example filter, this test 
        checks two things: 
          - the mean squared error over the frequency domain of the unscaled 
            filter is smaller than the scaled filter (true for rectangular 
            window) 
          - the response of the scaled filter is exactly unity at the center 
            of the first passband 
        &quot;&quot;&quot;</span>
        <span class="s1">N = </span><span class="s2">11</span>
        <span class="s1">cases = [</span>
            <span class="s1">([</span><span class="s2">.5</span><span class="s1">]</span><span class="s0">, True, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">([</span><span class="s2">0.2</span><span class="s0">, </span><span class="s2">.6</span><span class="s1">]</span><span class="s0">, False, </span><span class="s1">(</span><span class="s2">.4</span><span class="s0">, </span><span class="s2">1</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">([</span><span class="s2">.5</span><span class="s1">]</span><span class="s0">, False, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">]</span>
        <span class="s0">for </span><span class="s1">cutoff</span><span class="s0">, </span><span class="s1">pass_zero</span><span class="s0">, </span><span class="s1">expected_response </span><span class="s0">in </span><span class="s1">cases:</span>
            <span class="s1">h = firwin(N</span><span class="s0">, </span><span class="s1">cutoff</span><span class="s0">, </span><span class="s1">scale=</span><span class="s0">False, </span><span class="s1">pass_zero=pass_zero</span><span class="s0">, </span><span class="s1">window=</span><span class="s4">'ones'</span><span class="s1">)</span>
            <span class="s1">hs = firwin(N</span><span class="s0">, </span><span class="s1">cutoff</span><span class="s0">, </span><span class="s1">scale=</span><span class="s0">True, </span><span class="s1">pass_zero=pass_zero</span><span class="s0">, </span><span class="s1">window=</span><span class="s4">'ones'</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">len(cutoff) == </span><span class="s2">1</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">pass_zero:</span>
                    <span class="s1">cutoff = [</span><span class="s2">0</span><span class="s1">] + cutoff</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">cutoff = cutoff + [</span><span class="s2">1</span><span class="s1">]</span>
            <span class="s1">assert_(self.mse(h</span><span class="s0">, </span><span class="s1">[cutoff]) &lt; self.mse(hs</span><span class="s0">, </span><span class="s1">[cutoff])</span><span class="s0">,</span>
                <span class="s4">'least squares violation'</span><span class="s1">)</span>
            <span class="s1">self.check_response(hs</span><span class="s0">, </span><span class="s1">[expected_response]</span><span class="s0">, </span><span class="s2">1e-12</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestFirWinMore:</span>
    <span class="s5">&quot;&quot;&quot;Different author, different style, different tests...&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">test_lowpass(self):</span>
        <span class="s1">width = </span><span class="s2">0.04</span>
        <span class="s1">ntaps</span><span class="s0">, </span><span class="s1">beta = kaiserord(</span><span class="s2">120</span><span class="s0">, </span><span class="s1">width)</span>
        <span class="s1">kwargs = dict(cutoff=</span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">window=(</span><span class="s4">'kaiser'</span><span class="s0">, </span><span class="s1">beta)</span><span class="s0">, </span><span class="s1">scale=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">taps = firwin(ntaps</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s3"># Check the symmetry of taps.</span>
        <span class="s1">assert_array_almost_equal(taps[:ntaps//</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">taps[ntaps:ntaps-ntaps//</span><span class="s2">2</span><span class="s1">-</span><span class="s2">1</span><span class="s1">:-</span><span class="s2">1</span><span class="s1">])</span>

        <span class="s3"># Check the gain at a few samples where we know it should be approximately 0 or 1.</span>
        <span class="s1">freq_samples = np.array([</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.25</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">-width/</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">+width/</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0.75</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">freqs</span><span class="s0">, </span><span class="s1">response = freqz(taps</span><span class="s0">, </span><span class="s1">worN=np.pi*freq_samples)</span>
        <span class="s1">assert_array_almost_equal(np.abs(response)</span><span class="s0">,</span>
                                    <span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">5</span><span class="s1">)</span>

        <span class="s1">taps_str = firwin(ntaps</span><span class="s0">, </span><span class="s1">pass_zero=</span><span class="s4">'lowpass'</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">assert_allclose(taps</span><span class="s0">, </span><span class="s1">taps_str)</span>

    <span class="s0">def </span><span class="s1">test_highpass(self):</span>
        <span class="s1">width = </span><span class="s2">0.04</span>
        <span class="s1">ntaps</span><span class="s0">, </span><span class="s1">beta = kaiserord(</span><span class="s2">120</span><span class="s0">, </span><span class="s1">width)</span>

        <span class="s3"># Ensure that ntaps is odd.</span>
        <span class="s1">ntaps |= </span><span class="s2">1</span>

        <span class="s1">kwargs = dict(cutoff=</span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">window=(</span><span class="s4">'kaiser'</span><span class="s0">, </span><span class="s1">beta)</span><span class="s0">, </span><span class="s1">scale=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">taps = firwin(ntaps</span><span class="s0">, </span><span class="s1">pass_zero=</span><span class="s0">False, </span><span class="s1">**kwargs)</span>

        <span class="s3"># Check the symmetry of taps.</span>
        <span class="s1">assert_array_almost_equal(taps[:ntaps//</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">taps[ntaps:ntaps-ntaps//</span><span class="s2">2</span><span class="s1">-</span><span class="s2">1</span><span class="s1">:-</span><span class="s2">1</span><span class="s1">])</span>

        <span class="s3"># Check the gain at a few samples where we know it should be approximately 0 or 1.</span>
        <span class="s1">freq_samples = np.array([</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.25</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">-width/</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">+width/</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0.75</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">freqs</span><span class="s0">, </span><span class="s1">response = freqz(taps</span><span class="s0">, </span><span class="s1">worN=np.pi*freq_samples)</span>
        <span class="s1">assert_array_almost_equal(np.abs(response)</span><span class="s0">,</span>
                                    <span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">5</span><span class="s1">)</span>

        <span class="s1">taps_str = firwin(ntaps</span><span class="s0">, </span><span class="s1">pass_zero=</span><span class="s4">'highpass'</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">assert_allclose(taps</span><span class="s0">, </span><span class="s1">taps_str)</span>

    <span class="s0">def </span><span class="s1">test_bandpass(self):</span>
        <span class="s1">width = </span><span class="s2">0.04</span>
        <span class="s1">ntaps</span><span class="s0">, </span><span class="s1">beta = kaiserord(</span><span class="s2">120</span><span class="s0">, </span><span class="s1">width)</span>
        <span class="s1">kwargs = dict(cutoff=[</span><span class="s2">0.3</span><span class="s0">, </span><span class="s2">0.7</span><span class="s1">]</span><span class="s0">, </span><span class="s1">window=(</span><span class="s4">'kaiser'</span><span class="s0">, </span><span class="s1">beta)</span><span class="s0">, </span><span class="s1">scale=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">taps = firwin(ntaps</span><span class="s0">, </span><span class="s1">pass_zero=</span><span class="s0">False, </span><span class="s1">**kwargs)</span>

        <span class="s3"># Check the symmetry of taps.</span>
        <span class="s1">assert_array_almost_equal(taps[:ntaps//</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">taps[ntaps:ntaps-ntaps//</span><span class="s2">2</span><span class="s1">-</span><span class="s2">1</span><span class="s1">:-</span><span class="s2">1</span><span class="s1">])</span>

        <span class="s3"># Check the gain at a few samples where we know it should be approximately 0 or 1.</span>
        <span class="s1">freq_samples = np.array([</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.2</span><span class="s0">, </span><span class="s2">0.3</span><span class="s1">-width/</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0.3</span><span class="s1">+width/</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">,</span>
                                <span class="s2">0.7</span><span class="s1">-width/</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0.7</span><span class="s1">+width/</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0.8</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">freqs</span><span class="s0">, </span><span class="s1">response = freqz(taps</span><span class="s0">, </span><span class="s1">worN=np.pi*freq_samples)</span>
        <span class="s1">assert_array_almost_equal(np.abs(response)</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">5</span><span class="s1">)</span>

        <span class="s1">taps_str = firwin(ntaps</span><span class="s0">, </span><span class="s1">pass_zero=</span><span class="s4">'bandpass'</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">assert_allclose(taps</span><span class="s0">, </span><span class="s1">taps_str)</span>

    <span class="s0">def </span><span class="s1">test_bandstop_multi(self):</span>
        <span class="s1">width = </span><span class="s2">0.04</span>
        <span class="s1">ntaps</span><span class="s0">, </span><span class="s1">beta = kaiserord(</span><span class="s2">120</span><span class="s0">, </span><span class="s1">width)</span>
        <span class="s1">kwargs = dict(cutoff=[</span><span class="s2">0.2</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.8</span><span class="s1">]</span><span class="s0">, </span><span class="s1">window=(</span><span class="s4">'kaiser'</span><span class="s0">, </span><span class="s1">beta)</span><span class="s0">,</span>
                      <span class="s1">scale=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">taps = firwin(ntaps</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s3"># Check the symmetry of taps.</span>
        <span class="s1">assert_array_almost_equal(taps[:ntaps//</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">taps[ntaps:ntaps-ntaps//</span><span class="s2">2</span><span class="s1">-</span><span class="s2">1</span><span class="s1">:-</span><span class="s2">1</span><span class="s1">])</span>

        <span class="s3"># Check the gain at a few samples where we know it should be approximately 0 or 1.</span>
        <span class="s1">freq_samples = np.array([</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">0.2</span><span class="s1">-width/</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0.2</span><span class="s1">+width/</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0.35</span><span class="s0">,</span>
                                <span class="s2">0.5</span><span class="s1">-width/</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">+width/</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0.65</span><span class="s0">,</span>
                                <span class="s2">0.8</span><span class="s1">-width/</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0.8</span><span class="s1">+width/</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0.9</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">freqs</span><span class="s0">, </span><span class="s1">response = freqz(taps</span><span class="s0">, </span><span class="s1">worN=np.pi*freq_samples)</span>
        <span class="s1">assert_array_almost_equal(np.abs(response)</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">decimal=</span><span class="s2">5</span><span class="s1">)</span>

        <span class="s1">taps_str = firwin(ntaps</span><span class="s0">, </span><span class="s1">pass_zero=</span><span class="s4">'bandstop'</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">assert_allclose(taps</span><span class="s0">, </span><span class="s1">taps_str)</span>

    <span class="s0">def </span><span class="s1">test_fs_nyq(self):</span>
        <span class="s5">&quot;&quot;&quot;Test the fs and nyq keywords.&quot;&quot;&quot;</span>
        <span class="s1">nyquist = </span><span class="s2">1000</span>
        <span class="s1">width = </span><span class="s2">40.0</span>
        <span class="s1">relative_width = width/nyquist</span>
        <span class="s1">ntaps</span><span class="s0">, </span><span class="s1">beta = kaiserord(</span><span class="s2">120</span><span class="s0">, </span><span class="s1">relative_width)</span>
        <span class="s1">taps = firwin(ntaps</span><span class="s0">, </span><span class="s1">cutoff=[</span><span class="s2">300</span><span class="s0">, </span><span class="s2">700</span><span class="s1">]</span><span class="s0">, </span><span class="s1">window=(</span><span class="s4">'kaiser'</span><span class="s0">, </span><span class="s1">beta)</span><span class="s0">,</span>
                        <span class="s1">pass_zero=</span><span class="s0">False, </span><span class="s1">scale=</span><span class="s0">False, </span><span class="s1">fs=</span><span class="s2">2</span><span class="s1">*nyquist)</span>

        <span class="s3"># Check the symmetry of taps.</span>
        <span class="s1">assert_array_almost_equal(taps[:ntaps//</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">taps[ntaps:ntaps-ntaps//</span><span class="s2">2</span><span class="s1">-</span><span class="s2">1</span><span class="s1">:-</span><span class="s2">1</span><span class="s1">])</span>

        <span class="s3"># Check the gain at a few samples where we know it should be approximately 0 or 1.</span>
        <span class="s1">freq_samples = np.array([</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">200</span><span class="s0">, </span><span class="s2">300</span><span class="s1">-width/</span><span class="s2">2</span><span class="s0">, </span><span class="s2">300</span><span class="s1">+width/</span><span class="s2">2</span><span class="s0">, </span><span class="s2">500</span><span class="s0">,</span>
                                <span class="s2">700</span><span class="s1">-width/</span><span class="s2">2</span><span class="s0">, </span><span class="s2">700</span><span class="s1">+width/</span><span class="s2">2</span><span class="s0">, </span><span class="s2">800</span><span class="s0">, </span><span class="s2">1000</span><span class="s1">])</span>
        <span class="s1">freqs</span><span class="s0">, </span><span class="s1">response = freqz(taps</span><span class="s0">, </span><span class="s1">worN=np.pi*freq_samples/nyquist)</span>
        <span class="s1">assert_array_almost_equal(np.abs(response)</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">5</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">np.testing.suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(DeprecationWarning</span><span class="s0">, </span><span class="s4">&quot;Keyword argument 'nyq'&quot;</span><span class="s1">)</span>
            <span class="s1">taps2 = firwin(ntaps</span><span class="s0">, </span><span class="s1">cutoff=[</span><span class="s2">300</span><span class="s0">, </span><span class="s2">700</span><span class="s1">]</span><span class="s0">, </span><span class="s1">window=(</span><span class="s4">'kaiser'</span><span class="s0">, </span><span class="s1">beta)</span><span class="s0">,</span>
                           <span class="s1">pass_zero=</span><span class="s0">False, </span><span class="s1">scale=</span><span class="s0">False, </span><span class="s1">nyq=nyquist)</span>
        <span class="s1">assert_allclose(taps2</span><span class="s0">, </span><span class="s1">taps)</span>

    <span class="s0">def </span><span class="s1">test_bad_cutoff(self):</span>
        <span class="s5">&quot;&quot;&quot;Test that invalid cutoff argument raises ValueError.&quot;&quot;&quot;</span>
        <span class="s3"># cutoff values must be greater than 0 and less than 1.</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">firwin</span><span class="s0">, </span><span class="s2">99</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.5</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">firwin</span><span class="s0">, </span><span class="s2">99</span><span class="s0">, </span><span class="s2">1.5</span><span class="s1">)</span>
        <span class="s3"># Don't allow 0 or 1 in cutoff.</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">firwin</span><span class="s0">, </span><span class="s2">99</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">firwin</span><span class="s0">, </span><span class="s2">99</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s3"># cutoff values must be strictly increasing.</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">firwin</span><span class="s0">, </span><span class="s2">99</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.2</span><span class="s1">])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">firwin</span><span class="s0">, </span><span class="s2">99</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">])</span>
        <span class="s3"># Must have at least one cutoff value.</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">firwin</span><span class="s0">, </span><span class="s2">99</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s3"># 2D array not allowed.</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">firwin</span><span class="s0">, </span><span class="s2">99</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">0.2</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">0.3</span><span class="s0">, </span><span class="s2">0.4</span><span class="s1">]])</span>
        <span class="s3"># cutoff values must be less than nyq.</span>
        <span class="s0">with </span><span class="s1">np.testing.suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(DeprecationWarning</span><span class="s0">, </span><span class="s4">&quot;Keyword argument 'nyq'&quot;</span><span class="s1">)</span>
            <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">firwin</span><span class="s0">, </span><span class="s2">99</span><span class="s0">, </span><span class="s2">50.0</span><span class="s0">, </span><span class="s1">nyq=</span><span class="s2">40</span><span class="s1">)</span>
            <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">firwin</span><span class="s0">, </span><span class="s2">99</span><span class="s0">, </span><span class="s1">[</span><span class="s2">10</span><span class="s0">, </span><span class="s2">20</span><span class="s0">, </span><span class="s2">30</span><span class="s1">]</span><span class="s0">, </span><span class="s1">nyq=</span><span class="s2">25</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">firwin</span><span class="s0">, </span><span class="s2">99</span><span class="s0">, </span><span class="s2">50.0</span><span class="s0">, </span><span class="s1">fs=</span><span class="s2">80</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">firwin</span><span class="s0">, </span><span class="s2">99</span><span class="s0">, </span><span class="s1">[</span><span class="s2">10</span><span class="s0">, </span><span class="s2">20</span><span class="s0">, </span><span class="s2">30</span><span class="s1">]</span><span class="s0">, </span><span class="s1">fs=</span><span class="s2">50</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_even_highpass_raises_value_error(self):</span>
        <span class="s5">&quot;&quot;&quot;Test that attempt to create a highpass filter with an even number 
        of taps raises a ValueError exception.&quot;&quot;&quot;</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">firwin</span><span class="s0">, </span><span class="s2">40</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">pass_zero=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">firwin</span><span class="s0">, </span><span class="s2">40</span><span class="s0">, </span><span class="s1">[</span><span class="s2">.25</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_bad_pass_zero(self):</span>
        <span class="s5">&quot;&quot;&quot;Test degenerate pass_zero cases.&quot;&quot;&quot;</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'pass_zero must be'</span><span class="s1">):</span>
            <span class="s1">firwin(</span><span class="s2">41</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">pass_zero=</span><span class="s4">'foo'</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'cannot be interpreted'</span><span class="s1">):</span>
            <span class="s1">firwin(</span><span class="s2">41</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">pass_zero=</span><span class="s2">1.</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">pass_zero </span><span class="s0">in </span><span class="s1">(</span><span class="s4">'lowpass'</span><span class="s0">, </span><span class="s4">'highpass'</span><span class="s1">):</span>
            <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'cutoff must have one'</span><span class="s1">):</span>
                <span class="s1">firwin(</span><span class="s2">41</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">pass_zero=pass_zero)</span>
        <span class="s0">for </span><span class="s1">pass_zero </span><span class="s0">in </span><span class="s1">(</span><span class="s4">'bandpass'</span><span class="s0">, </span><span class="s4">'bandstop'</span><span class="s1">):</span>
            <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'must have at least two'</span><span class="s1">):</span>
                <span class="s1">firwin(</span><span class="s2">41</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">pass_zero=pass_zero)</span>

    <span class="s0">def </span><span class="s1">test_nyq_deprecation(self):</span>
        <span class="s0">with </span><span class="s1">pytest.warns(DeprecationWarning</span><span class="s0">,</span>
                          <span class="s1">match=</span><span class="s4">&quot;Keyword argument 'nyq' is deprecated in &quot;</span>
                          <span class="s1">):</span>
            <span class="s1">firwin(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">nyq=</span><span class="s2">10</span><span class="s1">)</span>

<span class="s0">class </span><span class="s1">TestFirwin2:</span>

    <span class="s0">def </span><span class="s1">test_invalid_args(self):</span>
        <span class="s3"># `freq` and `gain` have different lengths.</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'must be of same length'</span><span class="s1">):</span>
            <span class="s1">firwin2(</span><span class="s2">50</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s3"># `nfreqs` is less than `ntaps`.</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'ntaps must be less than nfreqs'</span><span class="s1">):</span>
            <span class="s1">firwin2(</span><span class="s2">50</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">nfreqs=</span><span class="s2">33</span><span class="s1">)</span>
        <span class="s3"># Decreasing value in `freq`</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'must be nondecreasing'</span><span class="s1">):</span>
            <span class="s1">firwin2(</span><span class="s2">50</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.4</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">.25</span><span class="s0">, </span><span class="s2">.5</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s3"># Value in `freq` repeated more than once.</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'must not occur more than twice'</span><span class="s1">):</span>
            <span class="s1">firwin2(</span><span class="s2">50</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">.1</span><span class="s0">, </span><span class="s2">.1</span><span class="s0">, </span><span class="s2">.1</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.75</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s3"># `freq` does not start at 0.0.</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'start with 0'</span><span class="s1">):</span>
            <span class="s1">firwin2(</span><span class="s2">50</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s3"># `freq` does not end at fs/2.</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'end with fs/2'</span><span class="s1">):</span>
            <span class="s1">firwin2(</span><span class="s2">50</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s3"># Value 0 is repeated in `freq`</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'0 must not be repeated'</span><span class="s1">):</span>
            <span class="s1">firwin2(</span><span class="s2">50</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">])</span>
        <span class="s3"># Value fs/2 is repeated in `freq`</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'fs/2 must not be repeated'</span><span class="s1">):</span>
            <span class="s1">firwin2(</span><span class="s2">50</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">])</span>
        <span class="s3"># Value in `freq` that is too close to a repeated number</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'cannot contain numbers '</span>
                                             <span class="s4">'that are too close'</span><span class="s1">):</span>
            <span class="s1">firwin2(</span><span class="s2">50</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.5 </span><span class="s1">- np.finfo(float).eps * </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">,</span>
                        <span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">])</span>

        <span class="s3"># Type II filter, but the gain at nyquist frequency is not zero.</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'Type II filter'</span><span class="s1">):</span>
            <span class="s1">firwin2(</span><span class="s2">16</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>

        <span class="s3"># Type III filter, but the gains at nyquist and zero rate are not zero.</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'Type III filter'</span><span class="s1">):</span>
            <span class="s1">firwin2(</span><span class="s2">17</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">antisymmetric=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'Type III filter'</span><span class="s1">):</span>
            <span class="s1">firwin2(</span><span class="s2">17</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">antisymmetric=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'Type III filter'</span><span class="s1">):</span>
            <span class="s1">firwin2(</span><span class="s2">17</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">antisymmetric=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s3"># Type IV filter, but the gain at zero rate is not zero.</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'Type IV filter'</span><span class="s1">):</span>
            <span class="s1">firwin2(</span><span class="s2">16</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">antisymmetric=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test01(self):</span>
        <span class="s1">width = </span><span class="s2">0.04</span>
        <span class="s1">beta = </span><span class="s2">12.0</span>
        <span class="s1">ntaps = </span><span class="s2">400</span>
        <span class="s3"># Filter is 1 from w=0 to w=0.5, then decreases linearly from 1 to 0 as w</span>
        <span class="s3"># increases from w=0.5 to w=1  (w=1 is the Nyquist frequency).</span>
        <span class="s1">freq = [</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span>
        <span class="s1">gain = [</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span>
        <span class="s1">taps = firwin2(ntaps</span><span class="s0">, </span><span class="s1">freq</span><span class="s0">, </span><span class="s1">gain</span><span class="s0">, </span><span class="s1">window=(</span><span class="s4">'kaiser'</span><span class="s0">, </span><span class="s1">beta))</span>
        <span class="s1">freq_samples = np.array([</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.25</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">-width/</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">+width/</span><span class="s2">2</span><span class="s0">,</span>
                                                        <span class="s2">0.75</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">-width/</span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">freqs</span><span class="s0">, </span><span class="s1">response = freqz(taps</span><span class="s0">, </span><span class="s1">worN=np.pi*freq_samples)</span>
        <span class="s1">assert_array_almost_equal(np.abs(response)</span><span class="s0">,</span>
                        <span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">-width</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">width]</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">5</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test02(self):</span>
        <span class="s1">width = </span><span class="s2">0.04</span>
        <span class="s1">beta = </span><span class="s2">12.0</span>
        <span class="s3"># ntaps must be odd for positive gain at Nyquist.</span>
        <span class="s1">ntaps = </span><span class="s2">401</span>
        <span class="s3"># An ideal highpass filter.</span>
        <span class="s1">freq = [</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span>
        <span class="s1">gain = [</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span>
        <span class="s1">taps = firwin2(ntaps</span><span class="s0">, </span><span class="s1">freq</span><span class="s0">, </span><span class="s1">gain</span><span class="s0">, </span><span class="s1">window=(</span><span class="s4">'kaiser'</span><span class="s0">, </span><span class="s1">beta))</span>
        <span class="s1">freq_samples = np.array([</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.25</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">-width</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">+width</span><span class="s0">, </span><span class="s2">0.75</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">freqs</span><span class="s0">, </span><span class="s1">response = freqz(taps</span><span class="s0">, </span><span class="s1">worN=np.pi*freq_samples)</span>
        <span class="s1">assert_array_almost_equal(np.abs(response)</span><span class="s0">,</span>
                                <span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">5</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test03(self):</span>
        <span class="s1">width = </span><span class="s2">0.02</span>
        <span class="s1">ntaps</span><span class="s0">, </span><span class="s1">beta = kaiserord(</span><span class="s2">120</span><span class="s0">, </span><span class="s1">width)</span>
        <span class="s3"># ntaps must be odd for positive gain at Nyquist.</span>
        <span class="s1">ntaps = int(ntaps) | </span><span class="s2">1</span>
        <span class="s1">freq = [</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.4</span><span class="s0">, </span><span class="s2">0.4</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span>
        <span class="s1">gain = [</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span>
        <span class="s1">taps = firwin2(ntaps</span><span class="s0">, </span><span class="s1">freq</span><span class="s0">, </span><span class="s1">gain</span><span class="s0">, </span><span class="s1">window=(</span><span class="s4">'kaiser'</span><span class="s0">, </span><span class="s1">beta))</span>
        <span class="s1">freq_samples = np.array([</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.4</span><span class="s1">-width</span><span class="s0">, </span><span class="s2">0.4</span><span class="s1">+width</span><span class="s0">, </span><span class="s2">0.45</span><span class="s0">,</span>
                                    <span class="s2">0.5</span><span class="s1">-width</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">+width</span><span class="s0">, </span><span class="s2">0.75</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">freqs</span><span class="s0">, </span><span class="s1">response = freqz(taps</span><span class="s0">, </span><span class="s1">worN=np.pi*freq_samples)</span>
        <span class="s1">assert_array_almost_equal(np.abs(response)</span><span class="s0">,</span>
                    <span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">5</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test04(self):</span>
        <span class="s5">&quot;&quot;&quot;Test firwin2 when window=None.&quot;&quot;&quot;</span>
        <span class="s1">ntaps = </span><span class="s2">5</span>
        <span class="s3"># Ideal lowpass: gain is 1 on [0,0.5], and 0 on [0.5, 1.0]</span>
        <span class="s1">freq = [</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span>
        <span class="s1">gain = [</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span>
        <span class="s1">taps = firwin2(ntaps</span><span class="s0">, </span><span class="s1">freq</span><span class="s0">, </span><span class="s1">gain</span><span class="s0">, </span><span class="s1">window=</span><span class="s0">None, </span><span class="s1">nfreqs=</span><span class="s2">8193</span><span class="s1">)</span>
        <span class="s1">alpha = </span><span class="s2">0.5 </span><span class="s1">* (ntaps - </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">m = np.arange(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">ntaps) - alpha</span>
        <span class="s1">h = </span><span class="s2">0.5 </span><span class="s1">* sinc(</span><span class="s2">0.5 </span><span class="s1">* m)</span>
        <span class="s1">assert_array_almost_equal(h</span><span class="s0">, </span><span class="s1">taps)</span>

    <span class="s0">def </span><span class="s1">test05(self):</span>
        <span class="s5">&quot;&quot;&quot;Test firwin2 for calculating Type IV filters&quot;&quot;&quot;</span>
        <span class="s1">ntaps = </span><span class="s2">1500</span>

        <span class="s1">freq = [</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span>
        <span class="s1">gain = [</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span>
        <span class="s1">taps = firwin2(ntaps</span><span class="s0">, </span><span class="s1">freq</span><span class="s0">, </span><span class="s1">gain</span><span class="s0">, </span><span class="s1">window=</span><span class="s0">None, </span><span class="s1">antisymmetric=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(taps[: ntaps // </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-taps[ntaps // </span><span class="s2">2</span><span class="s1">:][::-</span><span class="s2">1</span><span class="s1">])</span>

        <span class="s1">freqs</span><span class="s0">, </span><span class="s1">response = freqz(taps</span><span class="s0">, </span><span class="s1">worN=</span><span class="s2">2048</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(abs(response)</span><span class="s0">, </span><span class="s1">freqs / np.pi</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">4</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test06(self):</span>
        <span class="s5">&quot;&quot;&quot;Test firwin2 for calculating Type III filters&quot;&quot;&quot;</span>
        <span class="s1">ntaps = </span><span class="s2">1501</span>

        <span class="s1">freq = [</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.55</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span>
        <span class="s1">gain = [</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span>
        <span class="s1">taps = firwin2(ntaps</span><span class="s0">, </span><span class="s1">freq</span><span class="s0">, </span><span class="s1">gain</span><span class="s0">, </span><span class="s1">window=</span><span class="s0">None, </span><span class="s1">antisymmetric=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">assert_equal(taps[ntaps // </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(taps[: ntaps // </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-taps[ntaps // </span><span class="s2">2 </span><span class="s1">+ </span><span class="s2">1</span><span class="s1">:][::-</span><span class="s2">1</span><span class="s1">])</span>

        <span class="s1">freqs</span><span class="s0">, </span><span class="s1">response1 = freqz(taps</span><span class="s0">, </span><span class="s1">worN=</span><span class="s2">2048</span><span class="s1">)</span>
        <span class="s1">response2 = np.interp(freqs / np.pi</span><span class="s0">, </span><span class="s1">freq</span><span class="s0">, </span><span class="s1">gain)</span>
        <span class="s1">assert_array_almost_equal(abs(response1)</span><span class="s0">, </span><span class="s1">response2</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">3</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_fs_nyq(self):</span>
        <span class="s1">taps1 = firwin2(</span><span class="s2">80</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">])</span>
        <span class="s1">taps2 = firwin2(</span><span class="s2">80</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">30.0</span><span class="s0">, </span><span class="s2">60.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">fs=</span><span class="s2">120.0</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(taps1</span><span class="s0">, </span><span class="s1">taps2)</span>
        <span class="s0">with </span><span class="s1">np.testing.suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(DeprecationWarning</span><span class="s0">, </span><span class="s4">&quot;Keyword argument 'nyq'&quot;</span><span class="s1">)</span>
            <span class="s1">taps2 = firwin2(</span><span class="s2">80</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">30.0</span><span class="s0">, </span><span class="s2">60.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">nyq=</span><span class="s2">60.0</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(taps1</span><span class="s0">, </span><span class="s1">taps2)</span>

    <span class="s0">def </span><span class="s1">test_tuple(self):</span>
        <span class="s1">taps1 = firwin2(</span><span class="s2">150</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">))</span>
        <span class="s1">taps2 = firwin2(</span><span class="s2">150</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">])</span>
        <span class="s1">assert_array_almost_equal(taps1</span><span class="s0">, </span><span class="s1">taps2)</span>

    <span class="s0">def </span><span class="s1">test_input_modyfication(self):</span>
        <span class="s1">freq1 = np.array([</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">freq2 = np.array(freq1)</span>
        <span class="s1">firwin2(</span><span class="s2">80</span><span class="s0">, </span><span class="s1">freq1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">])</span>
        <span class="s1">assert_equal(freq1</span><span class="s0">, </span><span class="s1">freq2)</span>

    <span class="s0">def </span><span class="s1">test_nyq_deprecation(self):</span>
        <span class="s0">with </span><span class="s1">pytest.warns(DeprecationWarning</span><span class="s0">,</span>
                          <span class="s1">match=</span><span class="s4">&quot;Keyword argument 'nyq' is deprecated in &quot;</span>
                          <span class="s1">):</span>
            <span class="s1">firwin2(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">10</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">nyq=</span><span class="s2">10</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestRemez:</span>

    <span class="s0">def </span><span class="s1">test_bad_args(self):</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">remez</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">0.4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">type=</span><span class="s4">'pooka'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_hilbert(self):</span>
        <span class="s1">N = </span><span class="s2">11  </span><span class="s3"># number of taps in the filter</span>
        <span class="s1">a = </span><span class="s2">0.1  </span><span class="s3"># width of the transition band</span>

        <span class="s3"># design an unity gain hilbert bandpass filter from w to 0.5-w</span>
        <span class="s1">h = remez(</span><span class="s2">11</span><span class="s0">, </span><span class="s1">[a</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">-a]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">type=</span><span class="s4">'hilbert'</span><span class="s1">)</span>

        <span class="s3"># make sure the filter has correct # of taps</span>
        <span class="s1">assert_(len(h) == N</span><span class="s0">, </span><span class="s4">&quot;Number of Taps&quot;</span><span class="s1">)</span>

        <span class="s3"># make sure it is type III (anti-symmetric tap coefficients)</span>
        <span class="s1">assert_array_almost_equal(h[:(N-</span><span class="s2">1</span><span class="s1">)//</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-h[:-(N-</span><span class="s2">1</span><span class="s1">)//</span><span class="s2">2</span><span class="s1">-</span><span class="s2">1</span><span class="s1">:-</span><span class="s2">1</span><span class="s1">])</span>

        <span class="s3"># Since the requested response is symmetric, all even coefficients</span>
        <span class="s3"># should be zero (or in this case really small)</span>
        <span class="s1">assert_((abs(h[</span><span class="s2">1</span><span class="s1">::</span><span class="s2">2</span><span class="s1">]) &lt; </span><span class="s2">1e-15</span><span class="s1">).all()</span><span class="s0">, </span><span class="s4">&quot;Even Coefficients Equal Zero&quot;</span><span class="s1">)</span>

        <span class="s3"># now check the frequency response</span>
        <span class="s1">w</span><span class="s0">, </span><span class="s1">H = freqz(h</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">f = w/</span><span class="s2">2</span><span class="s1">/np.pi</span>
        <span class="s1">Hmag = abs(H)</span>

        <span class="s3"># should have a zero at 0 and pi (in this case close to zero)</span>
        <span class="s1">assert_((Hmag[[</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]] &lt; </span><span class="s2">0.02</span><span class="s1">).all()</span><span class="s0">, </span><span class="s4">&quot;Zero at zero and pi&quot;</span><span class="s1">)</span>

        <span class="s3"># check that the pass band is close to unity</span>
        <span class="s1">idx = np.logical_and(f &gt; a</span><span class="s0">, </span><span class="s1">f &lt; </span><span class="s2">0.5</span><span class="s1">-a)</span>
        <span class="s1">assert_((abs(Hmag[idx] - </span><span class="s2">1</span><span class="s1">) &lt; </span><span class="s2">0.015</span><span class="s1">).all()</span><span class="s0">, </span><span class="s4">&quot;Pass Band Close To Unity&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_compare(self):</span>
        <span class="s3"># test comparison to MATLAB</span>
        <span class="s1">k = [</span><span class="s2">0.024590270518440</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.041314581814658</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.075943803756711</span><span class="s0">,</span>
             <span class="s1">-</span><span class="s2">0.003530911231040</span><span class="s0">, </span><span class="s2">0.193140296954975</span><span class="s0">, </span><span class="s2">0.373400753484939</span><span class="s0">,</span>
             <span class="s2">0.373400753484939</span><span class="s0">, </span><span class="s2">0.193140296954975</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.003530911231040</span><span class="s0">,</span>
             <span class="s1">-</span><span class="s2">0.075943803756711</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.041314581814658</span><span class="s0">, </span><span class="s2">0.024590270518440</span><span class="s1">]</span>
        <span class="s0">with </span><span class="s1">np.testing.suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(DeprecationWarning</span><span class="s0">, </span><span class="s4">&quot;'remez'&quot;</span><span class="s1">)</span>
            <span class="s1">h = remez(</span><span class="s2">12</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0.3</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">Hz=</span><span class="s2">2.</span><span class="s1">)</span>
        <span class="s1">assert_allclose(h</span><span class="s0">, </span><span class="s1">k)</span>
        <span class="s1">h = remez(</span><span class="s2">12</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0.3</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">fs=</span><span class="s2">2.</span><span class="s1">)</span>
        <span class="s1">assert_allclose(h</span><span class="s0">, </span><span class="s1">k)</span>

        <span class="s1">h = [-</span><span class="s2">0.038976016082299</span><span class="s0">, </span><span class="s2">0.018704846485491</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.014644062687875</span><span class="s0">,</span>
             <span class="s2">0.002879152556419</span><span class="s0">, </span><span class="s2">0.016849978528150</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.043276706138248</span><span class="s0">,</span>
             <span class="s2">0.073641298245579</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.103908158578635</span><span class="s0">, </span><span class="s2">0.129770906801075</span><span class="s0">,</span>
             <span class="s1">-</span><span class="s2">0.147163447297124</span><span class="s0">, </span><span class="s2">0.153302248456347</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.147163447297124</span><span class="s0">,</span>
             <span class="s2">0.129770906801075</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.103908158578635</span><span class="s0">, </span><span class="s2">0.073641298245579</span><span class="s0">,</span>
             <span class="s1">-</span><span class="s2">0.043276706138248</span><span class="s0">, </span><span class="s2">0.016849978528150</span><span class="s0">, </span><span class="s2">0.002879152556419</span><span class="s0">,</span>
             <span class="s1">-</span><span class="s2">0.014644062687875</span><span class="s0">, </span><span class="s2">0.018704846485491</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.038976016082299</span><span class="s1">]</span>
        <span class="s0">with </span><span class="s1">np.testing.suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(DeprecationWarning</span><span class="s0">, </span><span class="s4">&quot;'remez'&quot;</span><span class="s1">)</span>
            <span class="s1">assert_allclose(remez(</span><span class="s2">21</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0.8</span><span class="s0">, </span><span class="s2">0.9</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">Hz=</span><span class="s2">2.</span><span class="s1">)</span><span class="s0">, </span><span class="s1">h)</span>
        <span class="s1">assert_allclose(remez(</span><span class="s2">21</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0.8</span><span class="s0">, </span><span class="s2">0.9</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">fs=</span><span class="s2">2.</span><span class="s1">)</span><span class="s0">, </span><span class="s1">h)</span>

    <span class="s0">def </span><span class="s1">test_Hz_deprecation(self):</span>
        <span class="s0">with </span><span class="s1">pytest.warns(DeprecationWarning</span><span class="s0">,</span>
                          <span class="s1">match=</span><span class="s4">&quot;'remez' keyword argument 'Hz'&quot;</span>
                          <span class="s1">):</span>
            <span class="s1">remez(</span><span class="s2">12</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0.3</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">Hz=</span><span class="s2">2.</span><span class="s1">)</span>

<span class="s0">class </span><span class="s1">TestFirls:</span>

    <span class="s0">def </span><span class="s1">test_bad_args(self):</span>
        <span class="s3"># even numtaps</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">firls</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">0.2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
        <span class="s3"># odd bands</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">firls</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">0.2</span><span class="s0">, </span><span class="s2">0.4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
        <span class="s3"># len(bands) != len(desired)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">firls</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">0.2</span><span class="s0">, </span><span class="s2">0.3</span><span class="s0">, </span><span class="s2">0.4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
        <span class="s3"># non-monotonic bands</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">firls</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.2</span><span class="s0">, </span><span class="s2">0.1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">firls</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">0.2</span><span class="s0">, </span><span class="s2">0.3</span><span class="s0">, </span><span class="s2">0.3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">] * </span><span class="s2">4</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">firls</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.3</span><span class="s0">, </span><span class="s2">0.4</span><span class="s0">, </span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">0.2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">] * </span><span class="s2">4</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">firls</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">0.3</span><span class="s0">, </span><span class="s2">0.2</span><span class="s0">, </span><span class="s2">0.4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">] * </span><span class="s2">4</span><span class="s1">)</span>
        <span class="s3"># negative desired</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">firls</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">0.2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s3"># len(weight) != len(pairs)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">firls</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">0.2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
        <span class="s3"># negative weight</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">firls</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">0.2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_firls(self):</span>
        <span class="s1">N = </span><span class="s2">11  </span><span class="s3"># number of taps in the filter</span>
        <span class="s1">a = </span><span class="s2">0.1  </span><span class="s3"># width of the transition band</span>

        <span class="s3"># design a halfband symmetric low-pass filter</span>
        <span class="s1">h = firls(</span><span class="s2">11</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">-a</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">fs=</span><span class="s2">1.0</span><span class="s1">)</span>

        <span class="s3"># make sure the filter has correct # of taps</span>
        <span class="s1">assert_equal(len(h)</span><span class="s0">, </span><span class="s1">N)</span>

        <span class="s3"># make sure it is symmetric</span>
        <span class="s1">midx = (N-</span><span class="s2">1</span><span class="s1">) // </span><span class="s2">2</span>
        <span class="s1">assert_array_almost_equal(h[:midx]</span><span class="s0">, </span><span class="s1">h[:-midx-</span><span class="s2">1</span><span class="s1">:-</span><span class="s2">1</span><span class="s1">])</span>

        <span class="s3"># make sure the center tap is 0.5</span>
        <span class="s1">assert_almost_equal(h[midx]</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">)</span>

        <span class="s3"># For halfband symmetric, odd coefficients (except the center)</span>
        <span class="s3"># should be zero (really small)</span>
        <span class="s1">hodd = np.hstack((h[</span><span class="s2">1</span><span class="s1">:midx:</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">h[-midx+</span><span class="s2">1</span><span class="s1">::</span><span class="s2">2</span><span class="s1">]))</span>
        <span class="s1">assert_array_almost_equal(hodd</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

        <span class="s3"># now check the frequency response</span>
        <span class="s1">w</span><span class="s0">, </span><span class="s1">H = freqz(h</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">f = w/</span><span class="s2">2</span><span class="s1">/np.pi</span>
        <span class="s1">Hmag = np.abs(H)</span>

        <span class="s3"># check that the pass band is close to unity</span>
        <span class="s1">idx = np.logical_and(f &gt; </span><span class="s2">0</span><span class="s0">, </span><span class="s1">f &lt; a)</span>
        <span class="s1">assert_array_almost_equal(Hmag[idx]</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">3</span><span class="s1">)</span>

        <span class="s3"># check that the stop band is close to zero</span>
        <span class="s1">idx = np.logical_and(f &gt; </span><span class="s2">0.5</span><span class="s1">-a</span><span class="s0">, </span><span class="s1">f &lt; </span><span class="s2">0.5</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(Hmag[idx]</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">3</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_compare(self):</span>
        <span class="s3"># compare to OCTAVE output</span>
        <span class="s1">taps = firls(</span><span class="s2">9</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.55</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
        <span class="s3"># &gt;&gt; taps = firls(8, [0 0.5 0.55 1], [1 1 0 0], [1, 2]);</span>
        <span class="s1">known_taps = [-</span><span class="s2">6.26930101730182e-04</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.03354450635036e-01</span><span class="s0">,</span>
                      <span class="s1">-</span><span class="s2">9.81576747564301e-03</span><span class="s0">, </span><span class="s2">3.17271686090449e-01</span><span class="s0">,</span>
                      <span class="s2">5.11409425599933e-01</span><span class="s0">, </span><span class="s2">3.17271686090449e-01</span><span class="s0">,</span>
                      <span class="s1">-</span><span class="s2">9.81576747564301e-03</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.03354450635036e-01</span><span class="s0">,</span>
                      <span class="s1">-</span><span class="s2">6.26930101730182e-04</span><span class="s1">]</span>
        <span class="s1">assert_allclose(taps</span><span class="s0">, </span><span class="s1">known_taps)</span>

        <span class="s3"># compare to MATLAB output</span>
        <span class="s1">taps = firls(</span><span class="s2">11</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
        <span class="s3"># &gt;&gt; taps = firls(10, [0 0.5 0.5 1], [1 1 0 0], [1, 2]);</span>
        <span class="s1">known_taps = [</span>
            <span class="s2">0.058545300496815</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.014233383714318</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.104688258464392</span><span class="s0">,</span>
            <span class="s2">0.012403323025279</span><span class="s0">, </span><span class="s2">0.317930861136062</span><span class="s0">, </span><span class="s2">0.488047220029700</span><span class="s0">,</span>
            <span class="s2">0.317930861136062</span><span class="s0">, </span><span class="s2">0.012403323025279</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.104688258464392</span><span class="s0">,</span>
            <span class="s1">-</span><span class="s2">0.014233383714318</span><span class="s0">, </span><span class="s2">0.058545300496815</span><span class="s1">]</span>
        <span class="s1">assert_allclose(taps</span><span class="s0">, </span><span class="s1">known_taps)</span>

        <span class="s3"># With linear changes:</span>
        <span class="s1">taps = firls(</span><span class="s2">7</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">fs=</span><span class="s2">20</span><span class="s1">)</span>
        <span class="s3"># &gt;&gt; taps = firls(6, [0, 0.1, 0.2, 0.3, 0.4, 0.5], [1, 0, 0, 1, 1, 0])</span>
        <span class="s1">known_taps = [</span>
            <span class="s2">1.156090832768218</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4.1385894727395849</span><span class="s0">, </span><span class="s2">7.5288619164321826</span><span class="s0">,</span>
            <span class="s1">-</span><span class="s2">8.5530572592947856</span><span class="s0">, </span><span class="s2">7.5288619164321826</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4.1385894727395849</span><span class="s0">,</span>
            <span class="s2">1.156090832768218</span><span class="s1">]</span>
        <span class="s1">assert_allclose(taps</span><span class="s0">, </span><span class="s1">known_taps)</span>

        <span class="s0">with </span><span class="s1">np.testing.suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(DeprecationWarning</span><span class="s0">, </span><span class="s4">&quot;Keyword argument 'nyq'&quot;</span><span class="s1">)</span>
            <span class="s1">taps = firls(</span><span class="s2">7</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">nyq=</span><span class="s2">10</span><span class="s1">)</span>
            <span class="s1">assert_allclose(taps</span><span class="s0">, </span><span class="s1">known_taps)</span>

            <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'between 0 and 1'</span><span class="s1">):</span>
                <span class="s1">firls(</span><span class="s2">7</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">nyq=</span><span class="s2">0.5</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_rank_deficient(self):</span>
        <span class="s3"># solve() runs but warns (only sometimes, so here we don't use match)</span>
        <span class="s1">x = firls(</span><span class="s2">21</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">0.9</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">w</span><span class="s0">, </span><span class="s1">h = freqz(x</span><span class="s0">, </span><span class="s1">fs=</span><span class="s2">2.</span><span class="s1">)</span>
        <span class="s1">assert_allclose(np.abs(h[:</span><span class="s2">2</span><span class="s1">])</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-5</span><span class="s1">)</span>
        <span class="s1">assert_allclose(np.abs(h[-</span><span class="s2">2</span><span class="s1">:])</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-6</span><span class="s1">)</span>
        <span class="s3"># switch to pinvh (tolerances could be higher with longer</span>
        <span class="s3"># filters, but using shorter ones is faster computationally and</span>
        <span class="s3"># the idea is the same)</span>
        <span class="s1">x = firls(</span><span class="s2">101</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0.01</span><span class="s0">, </span><span class="s2">0.99</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">w</span><span class="s0">, </span><span class="s1">h = freqz(x</span><span class="s0">, </span><span class="s1">fs=</span><span class="s2">2.</span><span class="s1">)</span>
        <span class="s1">mask = w &lt; </span><span class="s2">0.01</span>
        <span class="s0">assert </span><span class="s1">mask.sum() &gt; </span><span class="s2">3</span>
        <span class="s1">assert_allclose(np.abs(h[mask])</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-4</span><span class="s1">)</span>
        <span class="s1">mask = w &gt; </span><span class="s2">0.99</span>
        <span class="s0">assert </span><span class="s1">mask.sum() &gt; </span><span class="s2">3</span>
        <span class="s1">assert_allclose(np.abs(h[mask])</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-4</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_nyq_deprecation(self):</span>
        <span class="s0">with </span><span class="s1">pytest.warns(DeprecationWarning</span><span class="s0">,</span>
                          <span class="s1">match=</span><span class="s4">&quot;Keyword argument 'nyq' is deprecated in &quot;</span>
                          <span class="s1">):</span>
            <span class="s1">firls(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">nyq=</span><span class="s2">10</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestMinimumPhase:</span>

    <span class="s0">def </span><span class="s1">test_bad_args(self):</span>
        <span class="s3"># not enough taps</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">minimum_phase</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.</span><span class="s1">])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">minimum_phase</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">1.</span><span class="s1">])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">minimum_phase</span><span class="s0">, </span><span class="s1">np.full(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">1j</span><span class="s1">))</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">minimum_phase</span><span class="s0">, </span><span class="s4">'foo'</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">minimum_phase</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s2">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">n_fft=</span><span class="s2">8</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">minimum_phase</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s2">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'foo'</span><span class="s1">)</span>
        <span class="s1">assert_warns(RuntimeWarning</span><span class="s0">, </span><span class="s1">minimum_phase</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s2">3</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_homomorphic(self):</span>
        <span class="s3"># check that it can recover frequency responses of arbitrary</span>
        <span class="s3"># linear-phase filters</span>

        <span class="s3"># for some cases we can get the actual filter back</span>
        <span class="s1">h = [</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span>
        <span class="s1">h_new = minimum_phase(np.convolve(h</span><span class="s0">, </span><span class="s1">h[::-</span><span class="s2">1</span><span class="s1">]))</span>
        <span class="s1">assert_allclose(h_new</span><span class="s0">, </span><span class="s1">h</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">0.05</span><span class="s1">)</span>

        <span class="s3"># but in general we only guarantee we get the magnitude back</span>
        <span class="s1">rng = np.random.RandomState(</span><span class="s2">0</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s2">15</span><span class="s0">, </span><span class="s2">16</span><span class="s0">, </span><span class="s2">17</span><span class="s0">, </span><span class="s2">20</span><span class="s0">, </span><span class="s2">21</span><span class="s0">, </span><span class="s2">100</span><span class="s0">, </span><span class="s2">101</span><span class="s1">):</span>
            <span class="s1">h = rng.randn(n)</span>
            <span class="s1">h_new = minimum_phase(np.convolve(h</span><span class="s0">, </span><span class="s1">h[::-</span><span class="s2">1</span><span class="s1">]))</span>
            <span class="s1">assert_allclose(np.abs(fft(h_new))</span><span class="s0">,</span>
                            <span class="s1">np.abs(fft(h))</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-4</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_hilbert(self):</span>
        <span class="s3"># compare to MATLAB output of reference implementation</span>

        <span class="s3"># f=[0 0.3 0.5 1];</span>
        <span class="s3"># a=[1 1 0 0];</span>
        <span class="s3"># h=remez(11,f,a);</span>
        <span class="s1">h = remez(</span><span class="s2">12</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0.3</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">fs=</span><span class="s2">2.</span><span class="s1">)</span>
        <span class="s1">k = [</span><span class="s2">0.349585548646686</span><span class="s0">, </span><span class="s2">0.373552164395447</span><span class="s0">, </span><span class="s2">0.326082685363438</span><span class="s0">,</span>
             <span class="s2">0.077152207480935</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.129943946349364</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.059355880509749</span><span class="s1">]</span>
        <span class="s1">m = minimum_phase(h</span><span class="s0">, </span><span class="s4">'hilbert'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(m</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">5e-3</span><span class="s1">)</span>

        <span class="s3"># f=[0 0.8 0.9 1];</span>
        <span class="s3"># a=[0 0 1 1];</span>
        <span class="s3"># h=remez(20,f,a);</span>
        <span class="s1">h = remez(</span><span class="s2">21</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0.8</span><span class="s0">, </span><span class="s2">0.9</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">fs=</span><span class="s2">2.</span><span class="s1">)</span>
        <span class="s1">k = [</span><span class="s2">0.232486803906329</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.133551833687071</span><span class="s0">, </span><span class="s2">0.151871456867244</span><span class="s0">,</span>
             <span class="s1">-</span><span class="s2">0.157957283165866</span><span class="s0">, </span><span class="s2">0.151739294892963</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.129293146705090</span><span class="s0">,</span>
             <span class="s2">0.100787844523204</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.065832656741252</span><span class="s0">, </span><span class="s2">0.035361328741024</span><span class="s0">,</span>
             <span class="s1">-</span><span class="s2">0.014977068692269</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.158416139047557</span><span class="s1">]</span>
        <span class="s1">m = minimum_phase(h</span><span class="s0">, </span><span class="s4">'hilbert'</span><span class="s0">, </span><span class="s1">n_fft=</span><span class="s2">2</span><span class="s1">**</span><span class="s2">19</span><span class="s1">)</span>
        <span class="s1">assert_allclose(m</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">2e-3</span><span class="s1">)</span>
</pre>
</body>
</html>