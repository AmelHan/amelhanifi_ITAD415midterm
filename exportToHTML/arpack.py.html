<html>
<head>
<title>arpack.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
arpack.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Find a few eigenvectors and eigenvalues of a matrix. 
 
 
Uses ARPACK: https://github.com/opencollab/arpack-ng 
 
&quot;&quot;&quot;</span>
<span class="s2"># Wrapper implementation notes</span>
<span class="s2">#</span>
<span class="s2"># ARPACK Entry Points</span>
<span class="s2"># -------------------</span>
<span class="s2"># The entry points to ARPACK are</span>
<span class="s2"># - (s,d)seupd : single and double precision symmetric matrix</span>
<span class="s2"># - (s,d,c,z)neupd: single,double,complex,double complex general matrix</span>
<span class="s2"># This wrapper puts the *neupd (general matrix) interfaces in eigs()</span>
<span class="s2"># and the *seupd (symmetric matrix) in eigsh().</span>
<span class="s2"># There is no specialized interface for complex Hermitian matrices.</span>
<span class="s2"># To find eigenvalues of a complex Hermitian matrix you</span>
<span class="s2"># may use eigsh(), but eigsh() will simply call eigs()</span>
<span class="s2"># and return the real part of the eigenvalues thus obtained.</span>

<span class="s2"># Number of eigenvalues returned and complex eigenvalues</span>
<span class="s2"># ------------------------------------------------------</span>
<span class="s2"># The ARPACK nonsymmetric real and double interface (s,d)naupd return</span>
<span class="s2"># eigenvalues and eigenvectors in real (float,double) arrays.</span>
<span class="s2"># Since the eigenvalues and eigenvectors are, in general, complex</span>
<span class="s2"># ARPACK puts the real and imaginary parts in consecutive entries</span>
<span class="s2"># in real-valued arrays.   This wrapper puts the real entries</span>
<span class="s2"># into complex data types and attempts to return the requested eigenvalues</span>
<span class="s2"># and eigenvectors.</span>


<span class="s2"># Solver modes</span>
<span class="s2"># ------------</span>
<span class="s2"># ARPACK and handle shifted and shift-inverse computations</span>
<span class="s2"># for eigenvalues by providing a shift (sigma) and a solver.</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">import </span><span class="s1">warnings</span>
<span class="s3">from </span><span class="s1">scipy.sparse.linalg._interface </span><span class="s3">import </span><span class="s1">aslinearoperator</span><span class="s3">, </span><span class="s1">LinearOperator</span>
<span class="s3">from </span><span class="s1">scipy.sparse </span><span class="s3">import </span><span class="s1">eye</span><span class="s3">, </span><span class="s1">issparse</span>
<span class="s3">from </span><span class="s1">scipy.linalg </span><span class="s3">import </span><span class="s1">eig</span><span class="s3">, </span><span class="s1">eigh</span><span class="s3">, </span><span class="s1">lu_factor</span><span class="s3">, </span><span class="s1">lu_solve</span>
<span class="s3">from </span><span class="s1">scipy.sparse._sputils </span><span class="s3">import </span><span class="s1">isdense</span><span class="s3">, </span><span class="s1">is_pydata_spmatrix</span>
<span class="s3">from </span><span class="s1">scipy.sparse.linalg </span><span class="s3">import </span><span class="s1">gmres</span><span class="s3">, </span><span class="s1">splu</span>
<span class="s3">from </span><span class="s1">scipy._lib._util </span><span class="s3">import </span><span class="s1">_aligned_zeros</span>
<span class="s3">from </span><span class="s1">scipy._lib._threadsafety </span><span class="s3">import </span><span class="s1">ReentrancyLock</span>

<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">_arpack</span>
<span class="s1">arpack_int = _arpack.timing.nbx.dtype</span>

<span class="s1">__docformat__ = </span><span class="s4">&quot;restructuredtext en&quot;</span>

<span class="s1">__all__ = [</span><span class="s4">'eigs'</span><span class="s3">, </span><span class="s4">'eigsh'</span><span class="s3">, </span><span class="s4">'ArpackError'</span><span class="s3">, </span><span class="s4">'ArpackNoConvergence'</span><span class="s1">]</span>


<span class="s1">_type_conv = {</span><span class="s4">'f'</span><span class="s1">: </span><span class="s4">'s'</span><span class="s3">, </span><span class="s4">'d'</span><span class="s1">: </span><span class="s4">'d'</span><span class="s3">, </span><span class="s4">'F'</span><span class="s1">: </span><span class="s4">'c'</span><span class="s3">, </span><span class="s4">'D'</span><span class="s1">: </span><span class="s4">'z'</span><span class="s1">}</span>
<span class="s1">_ndigits = {</span><span class="s4">'f'</span><span class="s1">: </span><span class="s5">5</span><span class="s3">, </span><span class="s4">'d'</span><span class="s1">: </span><span class="s5">12</span><span class="s3">, </span><span class="s4">'F'</span><span class="s1">: </span><span class="s5">5</span><span class="s3">, </span><span class="s4">'D'</span><span class="s1">: </span><span class="s5">12</span><span class="s1">}</span>

<span class="s1">DNAUPD_ERRORS = {</span>
    <span class="s5">0</span><span class="s1">: </span><span class="s4">&quot;Normal exit.&quot;</span><span class="s3">,</span>
    <span class="s5">1</span><span class="s1">: </span><span class="s4">&quot;Maximum number of iterations taken. &quot;</span>
       <span class="s4">&quot;All possible eigenvalues of OP has been found. IPARAM(5) &quot;</span>
       <span class="s4">&quot;returns the number of wanted converged Ritz values.&quot;</span><span class="s3">,</span>
    <span class="s5">2</span><span class="s1">: </span><span class="s4">&quot;No longer an informational error. Deprecated starting &quot;</span>
       <span class="s4">&quot;with release 2 of ARPACK.&quot;</span><span class="s3">,</span>
    <span class="s5">3</span><span class="s1">: </span><span class="s4">&quot;No shifts could be applied during a cycle of the &quot;</span>
       <span class="s4">&quot;Implicitly restarted Arnoldi iteration. One possibility &quot;</span>
       <span class="s4">&quot;is to increase the size of NCV relative to NEV. &quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">1</span><span class="s1">: </span><span class="s4">&quot;N must be positive.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">2</span><span class="s1">: </span><span class="s4">&quot;NEV must be positive.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">3</span><span class="s1">: </span><span class="s4">&quot;NCV-NEV &gt;= 2 and less than or equal to N.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">4</span><span class="s1">: </span><span class="s4">&quot;The maximum number of Arnoldi update iterations allowed &quot;</span>
        <span class="s4">&quot;must be greater than zero.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">5</span><span class="s1">: </span><span class="s4">&quot; WHICH must be one of 'LM', 'SM', 'LR', 'SR', 'LI', 'SI'&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">6</span><span class="s1">: </span><span class="s4">&quot;BMAT must be one of 'I' or 'G'.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">7</span><span class="s1">: </span><span class="s4">&quot;Length of private work array WORKL is not sufficient.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">8</span><span class="s1">: </span><span class="s4">&quot;Error return from LAPACK eigenvalue calculation;&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">9</span><span class="s1">: </span><span class="s4">&quot;Starting vector is zero.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">10</span><span class="s1">: </span><span class="s4">&quot;IPARAM(7) must be 1,2,3,4.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">11</span><span class="s1">: </span><span class="s4">&quot;IPARAM(7) = 1 and BMAT = 'G' are incompatible.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">12</span><span class="s1">: </span><span class="s4">&quot;IPARAM(1) must be equal to 0 or 1.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">13</span><span class="s1">: </span><span class="s4">&quot;NEV and WHICH = 'BE' are incompatible.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">9999</span><span class="s1">: </span><span class="s4">&quot;Could not build an Arnoldi factorization. &quot;</span>
           <span class="s4">&quot;IPARAM(5) returns the size of the current Arnoldi &quot;</span>
           <span class="s4">&quot;factorization. The user is advised to check that &quot;</span>
           <span class="s4">&quot;enough workspace and array storage has been allocated.&quot;</span>
<span class="s1">}</span>

<span class="s1">SNAUPD_ERRORS = DNAUPD_ERRORS</span>

<span class="s1">ZNAUPD_ERRORS = DNAUPD_ERRORS.copy()</span>
<span class="s1">ZNAUPD_ERRORS[-</span><span class="s5">10</span><span class="s1">] = </span><span class="s4">&quot;IPARAM(7) must be 1,2,3.&quot;</span>

<span class="s1">CNAUPD_ERRORS = ZNAUPD_ERRORS</span>

<span class="s1">DSAUPD_ERRORS = {</span>
    <span class="s5">0</span><span class="s1">: </span><span class="s4">&quot;Normal exit.&quot;</span><span class="s3">,</span>
    <span class="s5">1</span><span class="s1">: </span><span class="s4">&quot;Maximum number of iterations taken. &quot;</span>
       <span class="s4">&quot;All possible eigenvalues of OP has been found.&quot;</span><span class="s3">,</span>
    <span class="s5">2</span><span class="s1">: </span><span class="s4">&quot;No longer an informational error. Deprecated starting with &quot;</span>
       <span class="s4">&quot;release 2 of ARPACK.&quot;</span><span class="s3">,</span>
    <span class="s5">3</span><span class="s1">: </span><span class="s4">&quot;No shifts could be applied during a cycle of the Implicitly &quot;</span>
       <span class="s4">&quot;restarted Arnoldi iteration. One possibility is to increase &quot;</span>
       <span class="s4">&quot;the size of NCV relative to NEV. &quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">1</span><span class="s1">: </span><span class="s4">&quot;N must be positive.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">2</span><span class="s1">: </span><span class="s4">&quot;NEV must be positive.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">3</span><span class="s1">: </span><span class="s4">&quot;NCV must be greater than NEV and less than or equal to N.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">4</span><span class="s1">: </span><span class="s4">&quot;The maximum number of Arnoldi update iterations allowed &quot;</span>
        <span class="s4">&quot;must be greater than zero.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">5</span><span class="s1">: </span><span class="s4">&quot;WHICH must be one of 'LM', 'SM', 'LA', 'SA' or 'BE'.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">6</span><span class="s1">: </span><span class="s4">&quot;BMAT must be one of 'I' or 'G'.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">7</span><span class="s1">: </span><span class="s4">&quot;Length of private work array WORKL is not sufficient.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">8</span><span class="s1">: </span><span class="s4">&quot;Error return from trid. eigenvalue calculation; &quot;</span>
        <span class="s4">&quot;Informational error from LAPACK routine dsteqr .&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">9</span><span class="s1">: </span><span class="s4">&quot;Starting vector is zero.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">10</span><span class="s1">: </span><span class="s4">&quot;IPARAM(7) must be 1,2,3,4,5.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">11</span><span class="s1">: </span><span class="s4">&quot;IPARAM(7) = 1 and BMAT = 'G' are incompatible.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">12</span><span class="s1">: </span><span class="s4">&quot;IPARAM(1) must be equal to 0 or 1.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">13</span><span class="s1">: </span><span class="s4">&quot;NEV and WHICH = 'BE' are incompatible. &quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">9999</span><span class="s1">: </span><span class="s4">&quot;Could not build an Arnoldi factorization. &quot;</span>
           <span class="s4">&quot;IPARAM(5) returns the size of the current Arnoldi &quot;</span>
           <span class="s4">&quot;factorization. The user is advised to check that &quot;</span>
           <span class="s4">&quot;enough workspace and array storage has been allocated.&quot;</span><span class="s3">,</span>
<span class="s1">}</span>

<span class="s1">SSAUPD_ERRORS = DSAUPD_ERRORS</span>

<span class="s1">DNEUPD_ERRORS = {</span>
    <span class="s5">0</span><span class="s1">: </span><span class="s4">&quot;Normal exit.&quot;</span><span class="s3">,</span>
    <span class="s5">1</span><span class="s1">: </span><span class="s4">&quot;The Schur form computed by LAPACK routine dlahqr &quot;</span>
       <span class="s4">&quot;could not be reordered by LAPACK routine dtrsen. &quot;</span>
       <span class="s4">&quot;Re-enter subroutine dneupd  with IPARAM(5)NCV and &quot;</span>
       <span class="s4">&quot;increase the size of the arrays DR and DI to have &quot;</span>
       <span class="s4">&quot;dimension at least dimension NCV and allocate at least NCV &quot;</span>
       <span class="s4">&quot;columns for Z. NOTE: Not necessary if Z and V share &quot;</span>
       <span class="s4">&quot;the same space. Please notify the authors if this error&quot;</span>
       <span class="s4">&quot;occurs.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">1</span><span class="s1">: </span><span class="s4">&quot;N must be positive.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">2</span><span class="s1">: </span><span class="s4">&quot;NEV must be positive.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">3</span><span class="s1">: </span><span class="s4">&quot;NCV-NEV &gt;= 2 and less than or equal to N.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">5</span><span class="s1">: </span><span class="s4">&quot;WHICH must be one of 'LM', 'SM', 'LR', 'SR', 'LI', 'SI'&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">6</span><span class="s1">: </span><span class="s4">&quot;BMAT must be one of 'I' or 'G'.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">7</span><span class="s1">: </span><span class="s4">&quot;Length of private work WORKL array is not sufficient.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">8</span><span class="s1">: </span><span class="s4">&quot;Error return from calculation of a real Schur form. &quot;</span>
        <span class="s4">&quot;Informational error from LAPACK routine dlahqr .&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">9</span><span class="s1">: </span><span class="s4">&quot;Error return from calculation of eigenvectors. &quot;</span>
        <span class="s4">&quot;Informational error from LAPACK routine dtrevc.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">10</span><span class="s1">: </span><span class="s4">&quot;IPARAM(7) must be 1,2,3,4.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">11</span><span class="s1">: </span><span class="s4">&quot;IPARAM(7) = 1 and BMAT = 'G' are incompatible.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">12</span><span class="s1">: </span><span class="s4">&quot;HOWMNY = 'S' not yet implemented&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">13</span><span class="s1">: </span><span class="s4">&quot;HOWMNY must be one of 'A' or 'P' if RVEC = .true.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">14</span><span class="s1">: </span><span class="s4">&quot;DNAUPD  did not find any eigenvalues to sufficient &quot;</span>
         <span class="s4">&quot;accuracy.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">15</span><span class="s1">: </span><span class="s4">&quot;DNEUPD got a different count of the number of converged &quot;</span>
         <span class="s4">&quot;Ritz values than DNAUPD got.  This indicates the user &quot;</span>
         <span class="s4">&quot;probably made an error in passing data from DNAUPD to &quot;</span>
         <span class="s4">&quot;DNEUPD or that the data was modified before entering &quot;</span>
         <span class="s4">&quot;DNEUPD&quot;</span><span class="s3">,</span>
<span class="s1">}</span>

<span class="s1">SNEUPD_ERRORS = DNEUPD_ERRORS.copy()</span>
<span class="s1">SNEUPD_ERRORS[</span><span class="s5">1</span><span class="s1">] = (</span><span class="s4">&quot;The Schur form computed by LAPACK routine slahqr &quot;</span>
                    <span class="s4">&quot;could not be reordered by LAPACK routine strsen . &quot;</span>
                    <span class="s4">&quot;Re-enter subroutine dneupd  with IPARAM(5)=NCV and &quot;</span>
                    <span class="s4">&quot;increase the size of the arrays DR and DI to have &quot;</span>
                    <span class="s4">&quot;dimension at least dimension NCV and allocate at least &quot;</span>
                    <span class="s4">&quot;NCV columns for Z. NOTE: Not necessary if Z and V share &quot;</span>
                    <span class="s4">&quot;the same space. Please notify the authors if this error &quot;</span>
                    <span class="s4">&quot;occurs.&quot;</span><span class="s1">)</span>
<span class="s1">SNEUPD_ERRORS[-</span><span class="s5">14</span><span class="s1">] = (</span><span class="s4">&quot;SNAUPD did not find any eigenvalues to sufficient &quot;</span>
                      <span class="s4">&quot;accuracy.&quot;</span><span class="s1">)</span>
<span class="s1">SNEUPD_ERRORS[-</span><span class="s5">15</span><span class="s1">] = (</span><span class="s4">&quot;SNEUPD got a different count of the number of &quot;</span>
                      <span class="s4">&quot;converged Ritz values than SNAUPD got.  This indicates &quot;</span>
                      <span class="s4">&quot;the user probably made an error in passing data from &quot;</span>
                      <span class="s4">&quot;SNAUPD to SNEUPD or that the data was modified before &quot;</span>
                      <span class="s4">&quot;entering SNEUPD&quot;</span><span class="s1">)</span>

<span class="s1">ZNEUPD_ERRORS = {</span><span class="s5">0</span><span class="s1">: </span><span class="s4">&quot;Normal exit.&quot;</span><span class="s3">,</span>
                 <span class="s5">1</span><span class="s1">: </span><span class="s4">&quot;The Schur form computed by LAPACK routine csheqr &quot;</span>
                    <span class="s4">&quot;could not be reordered by LAPACK routine ztrsen. &quot;</span>
                    <span class="s4">&quot;Re-enter subroutine zneupd with IPARAM(5)=NCV and &quot;</span>
                    <span class="s4">&quot;increase the size of the array D to have &quot;</span>
                    <span class="s4">&quot;dimension at least dimension NCV and allocate at least &quot;</span>
                    <span class="s4">&quot;NCV columns for Z. NOTE: Not necessary if Z and V share &quot;</span>
                    <span class="s4">&quot;the same space. Please notify the authors if this error &quot;</span>
                    <span class="s4">&quot;occurs.&quot;</span><span class="s3">,</span>
                 <span class="s1">-</span><span class="s5">1</span><span class="s1">: </span><span class="s4">&quot;N must be positive.&quot;</span><span class="s3">,</span>
                 <span class="s1">-</span><span class="s5">2</span><span class="s1">: </span><span class="s4">&quot;NEV must be positive.&quot;</span><span class="s3">,</span>
                 <span class="s1">-</span><span class="s5">3</span><span class="s1">: </span><span class="s4">&quot;NCV-NEV &gt;= 1 and less than or equal to N.&quot;</span><span class="s3">,</span>
                 <span class="s1">-</span><span class="s5">5</span><span class="s1">: </span><span class="s4">&quot;WHICH must be one of 'LM', 'SM', 'LR', 'SR', 'LI', 'SI'&quot;</span><span class="s3">,</span>
                 <span class="s1">-</span><span class="s5">6</span><span class="s1">: </span><span class="s4">&quot;BMAT must be one of 'I' or 'G'.&quot;</span><span class="s3">,</span>
                 <span class="s1">-</span><span class="s5">7</span><span class="s1">: </span><span class="s4">&quot;Length of private work WORKL array is not sufficient.&quot;</span><span class="s3">,</span>
                 <span class="s1">-</span><span class="s5">8</span><span class="s1">: </span><span class="s4">&quot;Error return from LAPACK eigenvalue calculation. &quot;</span>
                     <span class="s4">&quot;This should never happened.&quot;</span><span class="s3">,</span>
                 <span class="s1">-</span><span class="s5">9</span><span class="s1">: </span><span class="s4">&quot;Error return from calculation of eigenvectors. &quot;</span>
                     <span class="s4">&quot;Informational error from LAPACK routine ztrevc.&quot;</span><span class="s3">,</span>
                 <span class="s1">-</span><span class="s5">10</span><span class="s1">: </span><span class="s4">&quot;IPARAM(7) must be 1,2,3&quot;</span><span class="s3">,</span>
                 <span class="s1">-</span><span class="s5">11</span><span class="s1">: </span><span class="s4">&quot;IPARAM(7) = 1 and BMAT = 'G' are incompatible.&quot;</span><span class="s3">,</span>
                 <span class="s1">-</span><span class="s5">12</span><span class="s1">: </span><span class="s4">&quot;HOWMNY = 'S' not yet implemented&quot;</span><span class="s3">,</span>
                 <span class="s1">-</span><span class="s5">13</span><span class="s1">: </span><span class="s4">&quot;HOWMNY must be one of 'A' or 'P' if RVEC = .true.&quot;</span><span class="s3">,</span>
                 <span class="s1">-</span><span class="s5">14</span><span class="s1">: </span><span class="s4">&quot;ZNAUPD did not find any eigenvalues to sufficient &quot;</span>
                      <span class="s4">&quot;accuracy.&quot;</span><span class="s3">,</span>
                 <span class="s1">-</span><span class="s5">15</span><span class="s1">: </span><span class="s4">&quot;ZNEUPD got a different count of the number of &quot;</span>
                      <span class="s4">&quot;converged Ritz values than ZNAUPD got.  This &quot;</span>
                      <span class="s4">&quot;indicates the user probably made an error in passing &quot;</span>
                      <span class="s4">&quot;data from ZNAUPD to ZNEUPD or that the data was &quot;</span>
                      <span class="s4">&quot;modified before entering ZNEUPD&quot;</span>
                 <span class="s1">}</span>

<span class="s1">CNEUPD_ERRORS = ZNEUPD_ERRORS.copy()</span>
<span class="s1">CNEUPD_ERRORS[-</span><span class="s5">14</span><span class="s1">] = (</span><span class="s4">&quot;CNAUPD did not find any eigenvalues to sufficient &quot;</span>
                      <span class="s4">&quot;accuracy.&quot;</span><span class="s1">)</span>
<span class="s1">CNEUPD_ERRORS[-</span><span class="s5">15</span><span class="s1">] = (</span><span class="s4">&quot;CNEUPD got a different count of the number of &quot;</span>
                      <span class="s4">&quot;converged Ritz values than CNAUPD got.  This indicates &quot;</span>
                      <span class="s4">&quot;the user probably made an error in passing data from &quot;</span>
                      <span class="s4">&quot;CNAUPD to CNEUPD or that the data was modified before &quot;</span>
                      <span class="s4">&quot;entering CNEUPD&quot;</span><span class="s1">)</span>

<span class="s1">DSEUPD_ERRORS = {</span>
    <span class="s5">0</span><span class="s1">: </span><span class="s4">&quot;Normal exit.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">1</span><span class="s1">: </span><span class="s4">&quot;N must be positive.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">2</span><span class="s1">: </span><span class="s4">&quot;NEV must be positive.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">3</span><span class="s1">: </span><span class="s4">&quot;NCV must be greater than NEV and less than or equal to N.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">5</span><span class="s1">: </span><span class="s4">&quot;WHICH must be one of 'LM', 'SM', 'LA', 'SA' or 'BE'.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">6</span><span class="s1">: </span><span class="s4">&quot;BMAT must be one of 'I' or 'G'.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">7</span><span class="s1">: </span><span class="s4">&quot;Length of private work WORKL array is not sufficient.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">8</span><span class="s1">: (</span><span class="s4">&quot;Error return from trid. eigenvalue calculation; &quot;</span>
         <span class="s4">&quot;Information error from LAPACK routine dsteqr.&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">9</span><span class="s1">: </span><span class="s4">&quot;Starting vector is zero.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">10</span><span class="s1">: </span><span class="s4">&quot;IPARAM(7) must be 1,2,3,4,5.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">11</span><span class="s1">: </span><span class="s4">&quot;IPARAM(7) = 1 and BMAT = 'G' are incompatible.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">12</span><span class="s1">: </span><span class="s4">&quot;NEV and WHICH = 'BE' are incompatible.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">14</span><span class="s1">: </span><span class="s4">&quot;DSAUPD  did not find any eigenvalues to sufficient accuracy.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">15</span><span class="s1">: </span><span class="s4">&quot;HOWMNY must be one of 'A' or 'S' if RVEC = .true.&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">16</span><span class="s1">: </span><span class="s4">&quot;HOWMNY = 'S' not yet implemented&quot;</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">17</span><span class="s1">: (</span><span class="s4">&quot;DSEUPD  got a different count of the number of converged &quot;</span>
          <span class="s4">&quot;Ritz values than DSAUPD  got.  This indicates the user &quot;</span>
          <span class="s4">&quot;probably made an error in passing data from DSAUPD  to &quot;</span>
          <span class="s4">&quot;DSEUPD  or that the data was modified before entering  &quot;</span>
          <span class="s4">&quot;DSEUPD.&quot;</span><span class="s1">)</span>
<span class="s1">}</span>

<span class="s1">SSEUPD_ERRORS = DSEUPD_ERRORS.copy()</span>
<span class="s1">SSEUPD_ERRORS[-</span><span class="s5">14</span><span class="s1">] = (</span><span class="s4">&quot;SSAUPD  did not find any eigenvalues &quot;</span>
                      <span class="s4">&quot;to sufficient accuracy.&quot;</span><span class="s1">)</span>
<span class="s1">SSEUPD_ERRORS[-</span><span class="s5">17</span><span class="s1">] = (</span><span class="s4">&quot;SSEUPD  got a different count of the number of &quot;</span>
                      <span class="s4">&quot;converged &quot;</span>
                      <span class="s4">&quot;Ritz values than SSAUPD  got.  This indicates the user &quot;</span>
                      <span class="s4">&quot;probably made an error in passing data from SSAUPD  to &quot;</span>
                      <span class="s4">&quot;SSEUPD  or that the data was modified before entering  &quot;</span>
                      <span class="s4">&quot;SSEUPD.&quot;</span><span class="s1">)</span>

<span class="s1">_SAUPD_ERRORS = {</span><span class="s4">'d'</span><span class="s1">: DSAUPD_ERRORS</span><span class="s3">,</span>
                 <span class="s4">'s'</span><span class="s1">: SSAUPD_ERRORS}</span>
<span class="s1">_NAUPD_ERRORS = {</span><span class="s4">'d'</span><span class="s1">: DNAUPD_ERRORS</span><span class="s3">,</span>
                 <span class="s4">'s'</span><span class="s1">: SNAUPD_ERRORS</span><span class="s3">,</span>
                 <span class="s4">'z'</span><span class="s1">: ZNAUPD_ERRORS</span><span class="s3">,</span>
                 <span class="s4">'c'</span><span class="s1">: CNAUPD_ERRORS}</span>
<span class="s1">_SEUPD_ERRORS = {</span><span class="s4">'d'</span><span class="s1">: DSEUPD_ERRORS</span><span class="s3">,</span>
                 <span class="s4">'s'</span><span class="s1">: SSEUPD_ERRORS}</span>
<span class="s1">_NEUPD_ERRORS = {</span><span class="s4">'d'</span><span class="s1">: DNEUPD_ERRORS</span><span class="s3">,</span>
                 <span class="s4">'s'</span><span class="s1">: SNEUPD_ERRORS</span><span class="s3">,</span>
                 <span class="s4">'z'</span><span class="s1">: ZNEUPD_ERRORS</span><span class="s3">,</span>
                 <span class="s4">'c'</span><span class="s1">: CNEUPD_ERRORS}</span>

<span class="s2"># accepted values of parameter WHICH in _SEUPD</span>
<span class="s1">_SEUPD_WHICH = [</span><span class="s4">'LM'</span><span class="s3">, </span><span class="s4">'SM'</span><span class="s3">, </span><span class="s4">'LA'</span><span class="s3">, </span><span class="s4">'SA'</span><span class="s3">, </span><span class="s4">'BE'</span><span class="s1">]</span>

<span class="s2"># accepted values of parameter WHICH in _NAUPD</span>
<span class="s1">_NEUPD_WHICH = [</span><span class="s4">'LM'</span><span class="s3">, </span><span class="s4">'SM'</span><span class="s3">, </span><span class="s4">'LR'</span><span class="s3">, </span><span class="s4">'SR'</span><span class="s3">, </span><span class="s4">'LI'</span><span class="s3">, </span><span class="s4">'SI'</span><span class="s1">]</span>


<span class="s3">class </span><span class="s1">ArpackError(RuntimeError):</span>
    <span class="s0">&quot;&quot;&quot; 
    ARPACK error 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">info</span><span class="s3">, </span><span class="s1">infodict=_NAUPD_ERRORS):</span>
        <span class="s1">msg = infodict.get(info</span><span class="s3">, </span><span class="s4">&quot;Unknown error&quot;</span><span class="s1">)</span>
        <span class="s1">RuntimeError.__init__(self</span><span class="s3">, </span><span class="s4">&quot;ARPACK error %d: %s&quot; </span><span class="s1">% (info</span><span class="s3">, </span><span class="s1">msg))</span>


<span class="s3">class </span><span class="s1">ArpackNoConvergence(ArpackError):</span>
    <span class="s0">&quot;&quot;&quot; 
    ARPACK iteration did not converge 
 
    Attributes 
    ---------- 
    eigenvalues : ndarray 
        Partial result. Converged eigenvalues. 
    eigenvectors : ndarray 
        Partial result. Converged eigenvectors. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, </span><span class="s1">eigenvalues</span><span class="s3">, </span><span class="s1">eigenvectors):</span>
        <span class="s1">ArpackError.__init__(self</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">{-</span><span class="s5">1</span><span class="s1">: msg})</span>
        <span class="s1">self.eigenvalues = eigenvalues</span>
        <span class="s1">self.eigenvectors = eigenvectors</span>


<span class="s3">def </span><span class="s1">choose_ncv(k):</span>
    <span class="s0">&quot;&quot;&quot; 
    Choose number of lanczos vectors based on target number 
    of singular/eigen values and vectors to compute, k. 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">max(</span><span class="s5">2 </span><span class="s1">* k + </span><span class="s5">1</span><span class="s3">, </span><span class="s5">20</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">_ArpackParams:</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">mode=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">sigma=</span><span class="s3">None,</span>
                 <span class="s1">ncv=</span><span class="s3">None, </span><span class="s1">v0=</span><span class="s3">None, </span><span class="s1">maxiter=</span><span class="s3">None, </span><span class="s1">which=</span><span class="s4">&quot;LM&quot;</span><span class="s3">, </span><span class="s1">tol=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">k &lt;= </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;k must be positive, k=%d&quot; </span><span class="s1">% k)</span>

        <span class="s3">if </span><span class="s1">maxiter </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">maxiter = n * </span><span class="s5">10</span>
        <span class="s3">if </span><span class="s1">maxiter &lt;= </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;maxiter must be positive, maxiter=%d&quot; </span><span class="s1">% maxiter)</span>

        <span class="s3">if </span><span class="s1">tp </span><span class="s3">not in </span><span class="s4">'fdFD'</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;matrix type must be 'f', 'd', 'F', or 'D'&quot;</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">v0 </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s2"># ARPACK overwrites its initial resid,  make a copy</span>
            <span class="s1">self.resid = np.array(v0</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">True</span><span class="s1">)</span>
            <span class="s1">info = </span><span class="s5">1</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s2"># ARPACK will use a random initial vector.</span>
            <span class="s1">self.resid = np.zeros(n</span><span class="s3">, </span><span class="s1">tp)</span>
            <span class="s1">info = </span><span class="s5">0</span>

        <span class="s3">if </span><span class="s1">sigma </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s2">#sigma not used</span>
            <span class="s1">self.sigma = </span><span class="s5">0</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.sigma = sigma</span>

        <span class="s3">if </span><span class="s1">ncv </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">ncv = choose_ncv(k)</span>
        <span class="s1">ncv = min(ncv</span><span class="s3">, </span><span class="s1">n)</span>

        <span class="s1">self.v = np.zeros((n</span><span class="s3">, </span><span class="s1">ncv)</span><span class="s3">, </span><span class="s1">tp)  </span><span class="s2"># holds Ritz vectors</span>
        <span class="s1">self.iparam = np.zeros(</span><span class="s5">11</span><span class="s3">, </span><span class="s1">arpack_int)</span>

        <span class="s2"># set solver mode and parameters</span>
        <span class="s1">ishfts = </span><span class="s5">1</span>
        <span class="s1">self.mode = mode</span>
        <span class="s1">self.iparam[</span><span class="s5">0</span><span class="s1">] = ishfts</span>
        <span class="s1">self.iparam[</span><span class="s5">2</span><span class="s1">] = maxiter</span>
        <span class="s1">self.iparam[</span><span class="s5">3</span><span class="s1">] = </span><span class="s5">1</span>
        <span class="s1">self.iparam[</span><span class="s5">6</span><span class="s1">] = mode</span>

        <span class="s1">self.n = n</span>
        <span class="s1">self.tol = tol</span>
        <span class="s1">self.k = k</span>
        <span class="s1">self.maxiter = maxiter</span>
        <span class="s1">self.ncv = ncv</span>
        <span class="s1">self.which = which</span>
        <span class="s1">self.tp = tp</span>
        <span class="s1">self.info = info</span>

        <span class="s1">self.converged = </span><span class="s3">False</span>
        <span class="s1">self.ido = </span><span class="s5">0</span>

    <span class="s3">def </span><span class="s1">_raise_no_convergence(self):</span>
        <span class="s1">msg = </span><span class="s4">&quot;No convergence (%d iterations, %d/%d eigenvectors converged)&quot;</span>
        <span class="s1">k_ok = self.iparam[</span><span class="s5">4</span><span class="s1">]</span>
        <span class="s1">num_iter = self.iparam[</span><span class="s5">2</span><span class="s1">]</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">ev</span><span class="s3">, </span><span class="s1">vec = self.extract(</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s3">except </span><span class="s1">ArpackError </span><span class="s3">as </span><span class="s1">err:</span>
            <span class="s1">msg = </span><span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">msg</span><span class="s3">} </span><span class="s4">[</span><span class="s3">{</span><span class="s1">err</span><span class="s3">}</span><span class="s4">]&quot;</span>
            <span class="s1">ev = np.zeros((</span><span class="s5">0</span><span class="s3">,</span><span class="s1">))</span>
            <span class="s1">vec = np.zeros((self.n</span><span class="s3">, </span><span class="s5">0</span><span class="s1">))</span>
            <span class="s1">k_ok = </span><span class="s5">0</span>
        <span class="s3">raise </span><span class="s1">ArpackNoConvergence(msg % (num_iter</span><span class="s3">, </span><span class="s1">k_ok</span><span class="s3">, </span><span class="s1">self.k)</span><span class="s3">, </span><span class="s1">ev</span><span class="s3">, </span><span class="s1">vec)</span>


<span class="s3">class </span><span class="s1">_SymmetricArpackParams(_ArpackParams):</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">matvec</span><span class="s3">, </span><span class="s1">mode=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">M_matvec=</span><span class="s3">None,</span>
                 <span class="s1">Minv_matvec=</span><span class="s3">None, </span><span class="s1">sigma=</span><span class="s3">None,</span>
                 <span class="s1">ncv=</span><span class="s3">None, </span><span class="s1">v0=</span><span class="s3">None, </span><span class="s1">maxiter=</span><span class="s3">None, </span><span class="s1">which=</span><span class="s4">&quot;LM&quot;</span><span class="s3">, </span><span class="s1">tol=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s2"># The following modes are supported:</span>
        <span class="s2">#  mode = 1:</span>
        <span class="s2">#    Solve the standard eigenvalue problem:</span>
        <span class="s2">#      A*x = lambda*x :</span>
        <span class="s2">#       A - symmetric</span>
        <span class="s2">#    Arguments should be</span>
        <span class="s2">#       matvec      = left multiplication by A</span>
        <span class="s2">#       M_matvec    = None [not used]</span>
        <span class="s2">#       Minv_matvec = None [not used]</span>
        <span class="s2">#</span>
        <span class="s2">#  mode = 2:</span>
        <span class="s2">#    Solve the general eigenvalue problem:</span>
        <span class="s2">#      A*x = lambda*M*x</span>
        <span class="s2">#       A - symmetric</span>
        <span class="s2">#       M - symmetric positive definite</span>
        <span class="s2">#    Arguments should be</span>
        <span class="s2">#       matvec      = left multiplication by A</span>
        <span class="s2">#       M_matvec    = left multiplication by M</span>
        <span class="s2">#       Minv_matvec = left multiplication by M^-1</span>
        <span class="s2">#</span>
        <span class="s2">#  mode = 3:</span>
        <span class="s2">#    Solve the general eigenvalue problem in shift-invert mode:</span>
        <span class="s2">#      A*x = lambda*M*x</span>
        <span class="s2">#       A - symmetric</span>
        <span class="s2">#       M - symmetric positive semi-definite</span>
        <span class="s2">#    Arguments should be</span>
        <span class="s2">#       matvec      = None [not used]</span>
        <span class="s2">#       M_matvec    = left multiplication by M</span>
        <span class="s2">#                     or None, if M is the identity</span>
        <span class="s2">#       Minv_matvec = left multiplication by [A-sigma*M]^-1</span>
        <span class="s2">#</span>
        <span class="s2">#  mode = 4:</span>
        <span class="s2">#    Solve the general eigenvalue problem in Buckling mode:</span>
        <span class="s2">#      A*x = lambda*AG*x</span>
        <span class="s2">#       A  - symmetric positive semi-definite</span>
        <span class="s2">#       AG - symmetric indefinite</span>
        <span class="s2">#    Arguments should be</span>
        <span class="s2">#       matvec      = left multiplication by A</span>
        <span class="s2">#       M_matvec    = None [not used]</span>
        <span class="s2">#       Minv_matvec = left multiplication by [A-sigma*AG]^-1</span>
        <span class="s2">#</span>
        <span class="s2">#  mode = 5:</span>
        <span class="s2">#    Solve the general eigenvalue problem in Cayley-transformed mode:</span>
        <span class="s2">#      A*x = lambda*M*x</span>
        <span class="s2">#       A - symmetric</span>
        <span class="s2">#       M - symmetric positive semi-definite</span>
        <span class="s2">#    Arguments should be</span>
        <span class="s2">#       matvec      = left multiplication by A</span>
        <span class="s2">#       M_matvec    = left multiplication by M</span>
        <span class="s2">#                     or None, if M is the identity</span>
        <span class="s2">#       Minv_matvec = left multiplication by [A-sigma*M]^-1</span>
        <span class="s3">if </span><span class="s1">mode == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">matvec </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;matvec must be specified for mode=1&quot;</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">M_matvec </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;M_matvec cannot be specified for mode=1&quot;</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">Minv_matvec </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Minv_matvec cannot be specified for mode=1&quot;</span><span class="s1">)</span>

            <span class="s1">self.OP = matvec</span>
            <span class="s1">self.B = </span><span class="s3">lambda </span><span class="s1">x: x</span>
            <span class="s1">self.bmat = </span><span class="s4">'I'</span>
        <span class="s3">elif </span><span class="s1">mode == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">matvec </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;matvec must be specified for mode=2&quot;</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">M_matvec </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;M_matvec must be specified for mode=2&quot;</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">Minv_matvec </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Minv_matvec must be specified for mode=2&quot;</span><span class="s1">)</span>

            <span class="s1">self.OP = </span><span class="s3">lambda </span><span class="s1">x: Minv_matvec(matvec(x))</span>
            <span class="s1">self.OPa = Minv_matvec</span>
            <span class="s1">self.OPb = matvec</span>
            <span class="s1">self.B = M_matvec</span>
            <span class="s1">self.bmat = </span><span class="s4">'G'</span>
        <span class="s3">elif </span><span class="s1">mode == </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">matvec </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;matvec must not be specified for mode=3&quot;</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">Minv_matvec </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Minv_matvec must be specified for mode=3&quot;</span><span class="s1">)</span>

            <span class="s3">if </span><span class="s1">M_matvec </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">self.OP = Minv_matvec</span>
                <span class="s1">self.OPa = Minv_matvec</span>
                <span class="s1">self.B = </span><span class="s3">lambda </span><span class="s1">x: x</span>
                <span class="s1">self.bmat = </span><span class="s4">'I'</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self.OP = </span><span class="s3">lambda </span><span class="s1">x: Minv_matvec(M_matvec(x))</span>
                <span class="s1">self.OPa = Minv_matvec</span>
                <span class="s1">self.B = M_matvec</span>
                <span class="s1">self.bmat = </span><span class="s4">'G'</span>
        <span class="s3">elif </span><span class="s1">mode == </span><span class="s5">4</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">matvec </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;matvec must be specified for mode=4&quot;</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">M_matvec </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;M_matvec must not be specified for mode=4&quot;</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">Minv_matvec </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Minv_matvec must be specified for mode=4&quot;</span><span class="s1">)</span>
            <span class="s1">self.OPa = Minv_matvec</span>
            <span class="s1">self.OP = </span><span class="s3">lambda </span><span class="s1">x: self.OPa(matvec(x))</span>
            <span class="s1">self.B = matvec</span>
            <span class="s1">self.bmat = </span><span class="s4">'G'</span>
        <span class="s3">elif </span><span class="s1">mode == </span><span class="s5">5</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">matvec </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;matvec must be specified for mode=5&quot;</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">Minv_matvec </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Minv_matvec must be specified for mode=5&quot;</span><span class="s1">)</span>

            <span class="s1">self.OPa = Minv_matvec</span>
            <span class="s1">self.A_matvec = matvec</span>

            <span class="s3">if </span><span class="s1">M_matvec </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">self.OP = </span><span class="s3">lambda </span><span class="s1">x: Minv_matvec(matvec(x) + sigma * x)</span>
                <span class="s1">self.B = </span><span class="s3">lambda </span><span class="s1">x: x</span>
                <span class="s1">self.bmat = </span><span class="s4">'I'</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self.OP = </span><span class="s3">lambda </span><span class="s1">x: Minv_matvec(matvec(x)</span>
                                                <span class="s1">+ sigma * M_matvec(x))</span>
                <span class="s1">self.B = M_matvec</span>
                <span class="s1">self.bmat = </span><span class="s4">'G'</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;mode=%i not implemented&quot; </span><span class="s1">% mode)</span>

        <span class="s3">if </span><span class="s1">which </span><span class="s3">not in </span><span class="s1">_SEUPD_WHICH:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;which must be one of %s&quot;</span>
                             <span class="s1">% </span><span class="s4">' '</span><span class="s1">.join(_SEUPD_WHICH))</span>
        <span class="s3">if </span><span class="s1">k &gt;= n:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;k must be less than ndim(A), k=%d&quot; </span><span class="s1">% k)</span>

        <span class="s1">_ArpackParams.__init__(self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">sigma</span><span class="s3">,</span>
                               <span class="s1">ncv</span><span class="s3">, </span><span class="s1">v0</span><span class="s3">, </span><span class="s1">maxiter</span><span class="s3">, </span><span class="s1">which</span><span class="s3">, </span><span class="s1">tol)</span>

        <span class="s3">if </span><span class="s1">self.ncv &gt; n </span><span class="s3">or </span><span class="s1">self.ncv &lt;= k:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;ncv must be k&lt;ncv&lt;=n, ncv=%s&quot; </span><span class="s1">% self.ncv)</span>

        <span class="s2"># Use _aligned_zeros to work around a f2py bug in Numpy 1.9.1</span>
        <span class="s1">self.workd = _aligned_zeros(</span><span class="s5">3 </span><span class="s1">* n</span><span class="s3">, </span><span class="s1">self.tp)</span>
        <span class="s1">self.workl = _aligned_zeros(self.ncv * (self.ncv + </span><span class="s5">8</span><span class="s1">)</span><span class="s3">, </span><span class="s1">self.tp)</span>

        <span class="s1">ltr = _type_conv[self.tp]</span>
        <span class="s3">if </span><span class="s1">ltr </span><span class="s3">not in </span><span class="s1">[</span><span class="s4">&quot;s&quot;</span><span class="s3">, </span><span class="s4">&quot;d&quot;</span><span class="s1">]:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Input matrix is not real-valued.&quot;</span><span class="s1">)</span>

        <span class="s1">self._arpack_solver = _arpack.__dict__[ltr + </span><span class="s4">'saupd'</span><span class="s1">]</span>
        <span class="s1">self._arpack_extract = _arpack.__dict__[ltr + </span><span class="s4">'seupd'</span><span class="s1">]</span>

        <span class="s1">self.iterate_infodict = _SAUPD_ERRORS[ltr]</span>
        <span class="s1">self.extract_infodict = _SEUPD_ERRORS[ltr]</span>

        <span class="s1">self.ipntr = np.zeros(</span><span class="s5">11</span><span class="s3">, </span><span class="s1">arpack_int)</span>

    <span class="s3">def </span><span class="s1">iterate(self):</span>
        <span class="s1">self.ido</span><span class="s3">, </span><span class="s1">self.tol</span><span class="s3">, </span><span class="s1">self.resid</span><span class="s3">, </span><span class="s1">self.v</span><span class="s3">, </span><span class="s1">self.iparam</span><span class="s3">, </span><span class="s1">self.ipntr</span><span class="s3">, </span><span class="s1">self.info = \</span>
            <span class="s1">self._arpack_solver(self.ido</span><span class="s3">, </span><span class="s1">self.bmat</span><span class="s3">, </span><span class="s1">self.which</span><span class="s3">, </span><span class="s1">self.k</span><span class="s3">,</span>
                                <span class="s1">self.tol</span><span class="s3">, </span><span class="s1">self.resid</span><span class="s3">, </span><span class="s1">self.v</span><span class="s3">, </span><span class="s1">self.iparam</span><span class="s3">,</span>
                                <span class="s1">self.ipntr</span><span class="s3">, </span><span class="s1">self.workd</span><span class="s3">, </span><span class="s1">self.workl</span><span class="s3">, </span><span class="s1">self.info)</span>

        <span class="s1">xslice = slice(self.ipntr[</span><span class="s5">0</span><span class="s1">] - </span><span class="s5">1</span><span class="s3">, </span><span class="s1">self.ipntr[</span><span class="s5">0</span><span class="s1">] - </span><span class="s5">1 </span><span class="s1">+ self.n)</span>
        <span class="s1">yslice = slice(self.ipntr[</span><span class="s5">1</span><span class="s1">] - </span><span class="s5">1</span><span class="s3">, </span><span class="s1">self.ipntr[</span><span class="s5">1</span><span class="s1">] - </span><span class="s5">1 </span><span class="s1">+ self.n)</span>
        <span class="s3">if </span><span class="s1">self.ido == -</span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2"># initialization</span>
            <span class="s1">self.workd[yslice] = self.OP(self.workd[xslice])</span>
        <span class="s3">elif </span><span class="s1">self.ido == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2"># compute y = Op*x</span>
            <span class="s3">if </span><span class="s1">self.mode == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">self.workd[yslice] = self.OP(self.workd[xslice])</span>
            <span class="s3">elif </span><span class="s1">self.mode == </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s1">self.workd[xslice] = self.OPb(self.workd[xslice])</span>
                <span class="s1">self.workd[yslice] = self.OPa(self.workd[xslice])</span>
            <span class="s3">elif </span><span class="s1">self.mode == </span><span class="s5">5</span><span class="s1">:</span>
                <span class="s1">Bxslice = slice(self.ipntr[</span><span class="s5">2</span><span class="s1">] - </span><span class="s5">1</span><span class="s3">, </span><span class="s1">self.ipntr[</span><span class="s5">2</span><span class="s1">] - </span><span class="s5">1 </span><span class="s1">+ self.n)</span>
                <span class="s1">Ax = self.A_matvec(self.workd[xslice])</span>
                <span class="s1">self.workd[yslice] = self.OPa(Ax + (self.sigma *</span>
                                                    <span class="s1">self.workd[Bxslice]))</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">Bxslice = slice(self.ipntr[</span><span class="s5">2</span><span class="s1">] - </span><span class="s5">1</span><span class="s3">, </span><span class="s1">self.ipntr[</span><span class="s5">2</span><span class="s1">] - </span><span class="s5">1 </span><span class="s1">+ self.n)</span>
                <span class="s1">self.workd[yslice] = self.OPa(self.workd[Bxslice])</span>
        <span class="s3">elif </span><span class="s1">self.ido == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">self.workd[yslice] = self.B(self.workd[xslice])</span>
        <span class="s3">elif </span><span class="s1">self.ido == </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;ARPACK requested user shifts.  Assure ISHIFT==0&quot;</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.converged = </span><span class="s3">True</span>

            <span class="s3">if </span><span class="s1">self.info == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s3">pass</span>
            <span class="s3">elif </span><span class="s1">self.info == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">self._raise_no_convergence()</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ArpackError(self.info</span><span class="s3">, </span><span class="s1">infodict=self.iterate_infodict)</span>

    <span class="s3">def </span><span class="s1">extract(self</span><span class="s3">, </span><span class="s1">return_eigenvectors):</span>
        <span class="s1">rvec = return_eigenvectors</span>
        <span class="s1">ierr = </span><span class="s5">0</span>
        <span class="s1">howmny = </span><span class="s4">'A'  </span><span class="s2"># return all eigenvectors</span>
        <span class="s1">sselect = np.zeros(self.ncv</span><span class="s3">, </span><span class="s4">'int'</span><span class="s1">)  </span><span class="s2"># unused</span>
        <span class="s1">d</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">ierr = self._arpack_extract(rvec</span><span class="s3">, </span><span class="s1">howmny</span><span class="s3">, </span><span class="s1">sselect</span><span class="s3">, </span><span class="s1">self.sigma</span><span class="s3">,</span>
                                          <span class="s1">self.bmat</span><span class="s3">, </span><span class="s1">self.which</span><span class="s3">, </span><span class="s1">self.k</span><span class="s3">,</span>
                                          <span class="s1">self.tol</span><span class="s3">, </span><span class="s1">self.resid</span><span class="s3">, </span><span class="s1">self.v</span><span class="s3">,</span>
                                          <span class="s1">self.iparam[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">7</span><span class="s1">]</span><span class="s3">, </span><span class="s1">self.ipntr</span><span class="s3">,</span>
                                          <span class="s1">self.workd[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">2 </span><span class="s1">* self.n]</span><span class="s3">,</span>
                                          <span class="s1">self.workl</span><span class="s3">, </span><span class="s1">ierr)</span>
        <span class="s3">if </span><span class="s1">ierr != </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ArpackError(ierr</span><span class="s3">, </span><span class="s1">infodict=self.extract_infodict)</span>
        <span class="s1">k_ok = self.iparam[</span><span class="s5">4</span><span class="s1">]</span>
        <span class="s1">d = d[:k_ok]</span>
        <span class="s1">z = z[:</span><span class="s3">, </span><span class="s1">:k_ok]</span>

        <span class="s3">if </span><span class="s1">return_eigenvectors:</span>
            <span class="s3">return </span><span class="s1">d</span><span class="s3">, </span><span class="s1">z</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">d</span>


<span class="s3">class </span><span class="s1">_UnsymmetricArpackParams(_ArpackParams):</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">matvec</span><span class="s3">, </span><span class="s1">mode=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">M_matvec=</span><span class="s3">None,</span>
                 <span class="s1">Minv_matvec=</span><span class="s3">None, </span><span class="s1">sigma=</span><span class="s3">None,</span>
                 <span class="s1">ncv=</span><span class="s3">None, </span><span class="s1">v0=</span><span class="s3">None, </span><span class="s1">maxiter=</span><span class="s3">None, </span><span class="s1">which=</span><span class="s4">&quot;LM&quot;</span><span class="s3">, </span><span class="s1">tol=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s2"># The following modes are supported:</span>
        <span class="s2">#  mode = 1:</span>
        <span class="s2">#    Solve the standard eigenvalue problem:</span>
        <span class="s2">#      A*x = lambda*x</span>
        <span class="s2">#       A - square matrix</span>
        <span class="s2">#    Arguments should be</span>
        <span class="s2">#       matvec      = left multiplication by A</span>
        <span class="s2">#       M_matvec    = None [not used]</span>
        <span class="s2">#       Minv_matvec = None [not used]</span>
        <span class="s2">#</span>
        <span class="s2">#  mode = 2:</span>
        <span class="s2">#    Solve the generalized eigenvalue problem:</span>
        <span class="s2">#      A*x = lambda*M*x</span>
        <span class="s2">#       A - square matrix</span>
        <span class="s2">#       M - symmetric, positive semi-definite</span>
        <span class="s2">#    Arguments should be</span>
        <span class="s2">#       matvec      = left multiplication by A</span>
        <span class="s2">#       M_matvec    = left multiplication by M</span>
        <span class="s2">#       Minv_matvec = left multiplication by M^-1</span>
        <span class="s2">#</span>
        <span class="s2">#  mode = 3,4:</span>
        <span class="s2">#    Solve the general eigenvalue problem in shift-invert mode:</span>
        <span class="s2">#      A*x = lambda*M*x</span>
        <span class="s2">#       A - square matrix</span>
        <span class="s2">#       M - symmetric, positive semi-definite</span>
        <span class="s2">#    Arguments should be</span>
        <span class="s2">#       matvec      = None [not used]</span>
        <span class="s2">#       M_matvec    = left multiplication by M</span>
        <span class="s2">#                     or None, if M is the identity</span>
        <span class="s2">#       Minv_matvec = left multiplication by [A-sigma*M]^-1</span>
        <span class="s2">#    if A is real and mode==3, use the real part of Minv_matvec</span>
        <span class="s2">#    if A is real and mode==4, use the imag part of Minv_matvec</span>
        <span class="s2">#    if A is complex and mode==3,</span>
        <span class="s2">#       use real and imag parts of Minv_matvec</span>
        <span class="s3">if </span><span class="s1">mode == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">matvec </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;matvec must be specified for mode=1&quot;</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">M_matvec </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;M_matvec cannot be specified for mode=1&quot;</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">Minv_matvec </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Minv_matvec cannot be specified for mode=1&quot;</span><span class="s1">)</span>

            <span class="s1">self.OP = matvec</span>
            <span class="s1">self.B = </span><span class="s3">lambda </span><span class="s1">x: x</span>
            <span class="s1">self.bmat = </span><span class="s4">'I'</span>
        <span class="s3">elif </span><span class="s1">mode == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">matvec </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;matvec must be specified for mode=2&quot;</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">M_matvec </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;M_matvec must be specified for mode=2&quot;</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">Minv_matvec </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Minv_matvec must be specified for mode=2&quot;</span><span class="s1">)</span>

            <span class="s1">self.OP = </span><span class="s3">lambda </span><span class="s1">x: Minv_matvec(matvec(x))</span>
            <span class="s1">self.OPa = Minv_matvec</span>
            <span class="s1">self.OPb = matvec</span>
            <span class="s1">self.B = M_matvec</span>
            <span class="s1">self.bmat = </span><span class="s4">'G'</span>
        <span class="s3">elif </span><span class="s1">mode </span><span class="s3">in </span><span class="s1">(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s1">):</span>
            <span class="s3">if </span><span class="s1">matvec </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;matvec must be specified &quot;</span>
                                 <span class="s4">&quot;for mode in (3,4)&quot;</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">Minv_matvec </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Minv_matvec must be specified &quot;</span>
                                 <span class="s4">&quot;for mode in (3,4)&quot;</span><span class="s1">)</span>

            <span class="s1">self.matvec = matvec</span>
            <span class="s3">if </span><span class="s1">tp </span><span class="s3">in </span><span class="s4">'DF'</span><span class="s1">:  </span><span class="s2"># complex type</span>
                <span class="s3">if </span><span class="s1">mode == </span><span class="s5">3</span><span class="s1">:</span>
                    <span class="s1">self.OPa = Minv_matvec</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;mode=4 invalid for complex A&quot;</span><span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:  </span><span class="s2"># real type</span>
                <span class="s3">if </span><span class="s1">mode == </span><span class="s5">3</span><span class="s1">:</span>
                    <span class="s1">self.OPa = </span><span class="s3">lambda </span><span class="s1">x: np.real(Minv_matvec(x))</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">self.OPa = </span><span class="s3">lambda </span><span class="s1">x: np.imag(Minv_matvec(x))</span>
            <span class="s3">if </span><span class="s1">M_matvec </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">self.B = </span><span class="s3">lambda </span><span class="s1">x: x</span>
                <span class="s1">self.bmat = </span><span class="s4">'I'</span>
                <span class="s1">self.OP = self.OPa</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self.B = M_matvec</span>
                <span class="s1">self.bmat = </span><span class="s4">'G'</span>
                <span class="s1">self.OP = </span><span class="s3">lambda </span><span class="s1">x: self.OPa(M_matvec(x))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;mode=%i not implemented&quot; </span><span class="s1">% mode)</span>

        <span class="s3">if </span><span class="s1">which </span><span class="s3">not in </span><span class="s1">_NEUPD_WHICH:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Parameter which must be one of %s&quot;</span>
                             <span class="s1">% </span><span class="s4">' '</span><span class="s1">.join(_NEUPD_WHICH))</span>
        <span class="s3">if </span><span class="s1">k &gt;= n - </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;k must be less than ndim(A)-1, k=%d&quot; </span><span class="s1">% k)</span>

        <span class="s1">_ArpackParams.__init__(self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">sigma</span><span class="s3">,</span>
                               <span class="s1">ncv</span><span class="s3">, </span><span class="s1">v0</span><span class="s3">, </span><span class="s1">maxiter</span><span class="s3">, </span><span class="s1">which</span><span class="s3">, </span><span class="s1">tol)</span>

        <span class="s3">if </span><span class="s1">self.ncv &gt; n </span><span class="s3">or </span><span class="s1">self.ncv &lt;= k + </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;ncv must be k+1&lt;ncv&lt;=n, ncv=%s&quot; </span><span class="s1">% self.ncv)</span>

        <span class="s2"># Use _aligned_zeros to work around a f2py bug in Numpy 1.9.1</span>
        <span class="s1">self.workd = _aligned_zeros(</span><span class="s5">3 </span><span class="s1">* n</span><span class="s3">, </span><span class="s1">self.tp)</span>
        <span class="s1">self.workl = _aligned_zeros(</span><span class="s5">3 </span><span class="s1">* self.ncv * (self.ncv + </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">self.tp)</span>

        <span class="s1">ltr = _type_conv[self.tp]</span>
        <span class="s1">self._arpack_solver = _arpack.__dict__[ltr + </span><span class="s4">'naupd'</span><span class="s1">]</span>
        <span class="s1">self._arpack_extract = _arpack.__dict__[ltr + </span><span class="s4">'neupd'</span><span class="s1">]</span>

        <span class="s1">self.iterate_infodict = _NAUPD_ERRORS[ltr]</span>
        <span class="s1">self.extract_infodict = _NEUPD_ERRORS[ltr]</span>

        <span class="s1">self.ipntr = np.zeros(</span><span class="s5">14</span><span class="s3">, </span><span class="s1">arpack_int)</span>

        <span class="s3">if </span><span class="s1">self.tp </span><span class="s3">in </span><span class="s4">'FD'</span><span class="s1">:</span>
            <span class="s2"># Use _aligned_zeros to work around a f2py bug in Numpy 1.9.1</span>
            <span class="s1">self.rwork = _aligned_zeros(self.ncv</span><span class="s3">, </span><span class="s1">self.tp.lower())</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.rwork = </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">iterate(self):</span>
        <span class="s3">if </span><span class="s1">self.tp </span><span class="s3">in </span><span class="s4">'fd'</span><span class="s1">:</span>
            <span class="s1">self.ido</span><span class="s3">, </span><span class="s1">self.tol</span><span class="s3">, </span><span class="s1">self.resid</span><span class="s3">, </span><span class="s1">self.v</span><span class="s3">, </span><span class="s1">self.iparam</span><span class="s3">, </span><span class="s1">self.ipntr</span><span class="s3">, </span><span class="s1">self.info =\</span>
                <span class="s1">self._arpack_solver(self.ido</span><span class="s3">, </span><span class="s1">self.bmat</span><span class="s3">, </span><span class="s1">self.which</span><span class="s3">, </span><span class="s1">self.k</span><span class="s3">,</span>
                                    <span class="s1">self.tol</span><span class="s3">, </span><span class="s1">self.resid</span><span class="s3">, </span><span class="s1">self.v</span><span class="s3">, </span><span class="s1">self.iparam</span><span class="s3">,</span>
                                    <span class="s1">self.ipntr</span><span class="s3">, </span><span class="s1">self.workd</span><span class="s3">, </span><span class="s1">self.workl</span><span class="s3">,</span>
                                    <span class="s1">self.info)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.ido</span><span class="s3">, </span><span class="s1">self.tol</span><span class="s3">, </span><span class="s1">self.resid</span><span class="s3">, </span><span class="s1">self.v</span><span class="s3">, </span><span class="s1">self.iparam</span><span class="s3">, </span><span class="s1">self.ipntr</span><span class="s3">, </span><span class="s1">self.info =\</span>
                <span class="s1">self._arpack_solver(self.ido</span><span class="s3">, </span><span class="s1">self.bmat</span><span class="s3">, </span><span class="s1">self.which</span><span class="s3">, </span><span class="s1">self.k</span><span class="s3">,</span>
                                    <span class="s1">self.tol</span><span class="s3">, </span><span class="s1">self.resid</span><span class="s3">, </span><span class="s1">self.v</span><span class="s3">, </span><span class="s1">self.iparam</span><span class="s3">,</span>
                                    <span class="s1">self.ipntr</span><span class="s3">, </span><span class="s1">self.workd</span><span class="s3">, </span><span class="s1">self.workl</span><span class="s3">,</span>
                                    <span class="s1">self.rwork</span><span class="s3">, </span><span class="s1">self.info)</span>

        <span class="s1">xslice = slice(self.ipntr[</span><span class="s5">0</span><span class="s1">] - </span><span class="s5">1</span><span class="s3">, </span><span class="s1">self.ipntr[</span><span class="s5">0</span><span class="s1">] - </span><span class="s5">1 </span><span class="s1">+ self.n)</span>
        <span class="s1">yslice = slice(self.ipntr[</span><span class="s5">1</span><span class="s1">] - </span><span class="s5">1</span><span class="s3">, </span><span class="s1">self.ipntr[</span><span class="s5">1</span><span class="s1">] - </span><span class="s5">1 </span><span class="s1">+ self.n)</span>
        <span class="s3">if </span><span class="s1">self.ido == -</span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2"># initialization</span>
            <span class="s1">self.workd[yslice] = self.OP(self.workd[xslice])</span>
        <span class="s3">elif </span><span class="s1">self.ido == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2"># compute y = Op*x</span>
            <span class="s3">if </span><span class="s1">self.mode </span><span class="s3">in </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">):</span>
                <span class="s1">self.workd[yslice] = self.OP(self.workd[xslice])</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">Bxslice = slice(self.ipntr[</span><span class="s5">2</span><span class="s1">] - </span><span class="s5">1</span><span class="s3">, </span><span class="s1">self.ipntr[</span><span class="s5">2</span><span class="s1">] - </span><span class="s5">1 </span><span class="s1">+ self.n)</span>
                <span class="s1">self.workd[yslice] = self.OPa(self.workd[Bxslice])</span>
        <span class="s3">elif </span><span class="s1">self.ido == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">self.workd[yslice] = self.B(self.workd[xslice])</span>
        <span class="s3">elif </span><span class="s1">self.ido == </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;ARPACK requested user shifts.  Assure ISHIFT==0&quot;</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.converged = </span><span class="s3">True</span>

            <span class="s3">if </span><span class="s1">self.info == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s3">pass</span>
            <span class="s3">elif </span><span class="s1">self.info == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">self._raise_no_convergence()</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ArpackError(self.info</span><span class="s3">, </span><span class="s1">infodict=self.iterate_infodict)</span>

    <span class="s3">def </span><span class="s1">extract(self</span><span class="s3">, </span><span class="s1">return_eigenvectors):</span>
        <span class="s1">k</span><span class="s3">, </span><span class="s1">n = self.k</span><span class="s3">, </span><span class="s1">self.n</span>

        <span class="s1">ierr = </span><span class="s5">0</span>
        <span class="s1">howmny = </span><span class="s4">'A'  </span><span class="s2"># return all eigenvectors</span>
        <span class="s1">sselect = np.zeros(self.ncv</span><span class="s3">, </span><span class="s4">'int'</span><span class="s1">)  </span><span class="s2"># unused</span>
        <span class="s1">sigmar = np.real(self.sigma)</span>
        <span class="s1">sigmai = np.imag(self.sigma)</span>
        <span class="s1">workev = np.zeros(</span><span class="s5">3 </span><span class="s1">* self.ncv</span><span class="s3">, </span><span class="s1">self.tp)</span>

        <span class="s3">if </span><span class="s1">self.tp </span><span class="s3">in </span><span class="s4">'fd'</span><span class="s1">:</span>
            <span class="s1">dr = np.zeros(k + </span><span class="s5">1</span><span class="s3">, </span><span class="s1">self.tp)</span>
            <span class="s1">di = np.zeros(k + </span><span class="s5">1</span><span class="s3">, </span><span class="s1">self.tp)</span>
            <span class="s1">zr = np.zeros((n</span><span class="s3">, </span><span class="s1">k + </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">self.tp)</span>
            <span class="s1">dr</span><span class="s3">, </span><span class="s1">di</span><span class="s3">, </span><span class="s1">zr</span><span class="s3">, </span><span class="s1">ierr = \</span>
                <span class="s1">self._arpack_extract(return_eigenvectors</span><span class="s3">,</span>
                       <span class="s1">howmny</span><span class="s3">, </span><span class="s1">sselect</span><span class="s3">, </span><span class="s1">sigmar</span><span class="s3">, </span><span class="s1">sigmai</span><span class="s3">, </span><span class="s1">workev</span><span class="s3">,</span>
                       <span class="s1">self.bmat</span><span class="s3">, </span><span class="s1">self.which</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">self.tol</span><span class="s3">, </span><span class="s1">self.resid</span><span class="s3">,</span>
                       <span class="s1">self.v</span><span class="s3">, </span><span class="s1">self.iparam</span><span class="s3">, </span><span class="s1">self.ipntr</span><span class="s3">,</span>
                       <span class="s1">self.workd</span><span class="s3">, </span><span class="s1">self.workl</span><span class="s3">, </span><span class="s1">self.info)</span>
            <span class="s3">if </span><span class="s1">ierr != </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ArpackError(ierr</span><span class="s3">, </span><span class="s1">infodict=self.extract_infodict)</span>
            <span class="s1">nreturned = self.iparam[</span><span class="s5">4</span><span class="s1">]  </span><span class="s2"># number of good eigenvalues returned</span>

            <span class="s2"># Build complex eigenvalues from real and imaginary parts</span>
            <span class="s1">d = dr + </span><span class="s5">1.0j </span><span class="s1">* di</span>

            <span class="s2"># Arrange the eigenvectors: complex eigenvectors are stored as</span>
            <span class="s2"># real,imaginary in consecutive columns</span>
            <span class="s1">z = zr.astype(self.tp.upper())</span>

            <span class="s2"># The ARPACK nonsymmetric real and double interface (s,d)naupd</span>
            <span class="s2"># return eigenvalues and eigenvectors in real (float,double)</span>
            <span class="s2"># arrays.</span>

            <span class="s2"># Efficiency: this should check that return_eigenvectors == True</span>
            <span class="s2">#  before going through this construction.</span>
            <span class="s3">if </span><span class="s1">sigmai == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">i = </span><span class="s5">0</span>
                <span class="s3">while </span><span class="s1">i &lt;= k:</span>
                    <span class="s2"># check if complex</span>
                    <span class="s3">if </span><span class="s1">abs(d[i].imag) != </span><span class="s5">0</span><span class="s1">:</span>
                        <span class="s2"># this is a complex conjugate pair with eigenvalues</span>
                        <span class="s2"># in consecutive columns</span>
                        <span class="s3">if </span><span class="s1">i &lt; k:</span>
                            <span class="s1">z[:</span><span class="s3">, </span><span class="s1">i] = zr[:</span><span class="s3">, </span><span class="s1">i] + </span><span class="s5">1.0j </span><span class="s1">* zr[:</span><span class="s3">, </span><span class="s1">i + </span><span class="s5">1</span><span class="s1">]</span>
                            <span class="s1">z[:</span><span class="s3">, </span><span class="s1">i + </span><span class="s5">1</span><span class="s1">] = z[:</span><span class="s3">, </span><span class="s1">i].conjugate()</span>
                            <span class="s1">i += </span><span class="s5">1</span>
                        <span class="s3">else</span><span class="s1">:</span>
                            <span class="s2">#last eigenvalue is complex: the imaginary part of</span>
                            <span class="s2"># the eigenvector has not been returned</span>
                            <span class="s2">#this can only happen if nreturned &gt; k, so we'll</span>
                            <span class="s2"># throw out this case.</span>
                            <span class="s1">nreturned -= </span><span class="s5">1</span>
                    <span class="s1">i += </span><span class="s5">1</span>

            <span class="s3">else</span><span class="s1">:</span>
                <span class="s2"># real matrix, mode 3 or 4, imag(sigma) is nonzero:</span>
                <span class="s2"># see remark 3 in &lt;s,d&gt;neupd.f</span>
                <span class="s2"># Build complex eigenvalues from real and imaginary parts</span>
                <span class="s1">i = </span><span class="s5">0</span>
                <span class="s3">while </span><span class="s1">i &lt;= k:</span>
                    <span class="s3">if </span><span class="s1">abs(d[i].imag) == </span><span class="s5">0</span><span class="s1">:</span>
                        <span class="s1">d[i] = np.dot(zr[:</span><span class="s3">, </span><span class="s1">i]</span><span class="s3">, </span><span class="s1">self.matvec(zr[:</span><span class="s3">, </span><span class="s1">i]))</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s3">if </span><span class="s1">i &lt; k:</span>
                            <span class="s1">z[:</span><span class="s3">, </span><span class="s1">i] = zr[:</span><span class="s3">, </span><span class="s1">i] + </span><span class="s5">1.0j </span><span class="s1">* zr[:</span><span class="s3">, </span><span class="s1">i + </span><span class="s5">1</span><span class="s1">]</span>
                            <span class="s1">z[:</span><span class="s3">, </span><span class="s1">i + </span><span class="s5">1</span><span class="s1">] = z[:</span><span class="s3">, </span><span class="s1">i].conjugate()</span>
                            <span class="s1">d[i] = ((np.dot(zr[:</span><span class="s3">, </span><span class="s1">i]</span><span class="s3">,</span>
                                            <span class="s1">self.matvec(zr[:</span><span class="s3">, </span><span class="s1">i]))</span>
                                     <span class="s1">+ np.dot(zr[:</span><span class="s3">, </span><span class="s1">i + </span><span class="s5">1</span><span class="s1">]</span><span class="s3">,</span>
                                              <span class="s1">self.matvec(zr[:</span><span class="s3">, </span><span class="s1">i + </span><span class="s5">1</span><span class="s1">])))</span>
                                    <span class="s1">+ </span><span class="s5">1j </span><span class="s1">* (np.dot(zr[:</span><span class="s3">, </span><span class="s1">i]</span><span class="s3">,</span>
                                                   <span class="s1">self.matvec(zr[:</span><span class="s3">, </span><span class="s1">i + </span><span class="s5">1</span><span class="s1">]))</span>
                                            <span class="s1">- np.dot(zr[:</span><span class="s3">, </span><span class="s1">i + </span><span class="s5">1</span><span class="s1">]</span><span class="s3">,</span>
                                                     <span class="s1">self.matvec(zr[:</span><span class="s3">, </span><span class="s1">i]))))</span>
                            <span class="s1">d[i + </span><span class="s5">1</span><span class="s1">] = d[i].conj()</span>
                            <span class="s1">i += </span><span class="s5">1</span>
                        <span class="s3">else</span><span class="s1">:</span>
                            <span class="s2">#last eigenvalue is complex: the imaginary part of</span>
                            <span class="s2"># the eigenvector has not been returned</span>
                            <span class="s2">#this can only happen if nreturned &gt; k, so we'll</span>
                            <span class="s2"># throw out this case.</span>
                            <span class="s1">nreturned -= </span><span class="s5">1</span>
                    <span class="s1">i += </span><span class="s5">1</span>

            <span class="s2"># Now we have k+1 possible eigenvalues and eigenvectors</span>
            <span class="s2"># Return the ones specified by the keyword &quot;which&quot;</span>

            <span class="s3">if </span><span class="s1">nreturned &lt;= k:</span>
                <span class="s2"># we got less or equal as many eigenvalues we wanted</span>
                <span class="s1">d = d[:nreturned]</span>
                <span class="s1">z = z[:</span><span class="s3">, </span><span class="s1">:nreturned]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s2"># we got one extra eigenvalue (likely a cc pair, but which?)</span>
                <span class="s3">if </span><span class="s1">self.mode </span><span class="s3">in </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">):</span>
                    <span class="s1">rd = d</span>
                <span class="s3">elif </span><span class="s1">self.mode </span><span class="s3">in </span><span class="s1">(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s1">):</span>
                    <span class="s1">rd = </span><span class="s5">1 </span><span class="s1">/ (d - self.sigma)</span>

                <span class="s3">if </span><span class="s1">self.which </span><span class="s3">in </span><span class="s1">[</span><span class="s4">'LR'</span><span class="s3">, </span><span class="s4">'SR'</span><span class="s1">]:</span>
                    <span class="s1">ind = np.argsort(rd.real)</span>
                <span class="s3">elif </span><span class="s1">self.which </span><span class="s3">in </span><span class="s1">[</span><span class="s4">'LI'</span><span class="s3">, </span><span class="s4">'SI'</span><span class="s1">]:</span>
                    <span class="s2"># for LI,SI ARPACK returns largest,smallest</span>
                    <span class="s2"># abs(imaginary) (complex pairs come together)</span>
                    <span class="s1">ind = np.argsort(abs(rd.imag))</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">ind = np.argsort(abs(rd))</span>

                <span class="s3">if </span><span class="s1">self.which </span><span class="s3">in </span><span class="s1">[</span><span class="s4">'LR'</span><span class="s3">, </span><span class="s4">'LM'</span><span class="s3">, </span><span class="s4">'LI'</span><span class="s1">]:</span>
                    <span class="s1">ind = ind[-k:][::-</span><span class="s5">1</span><span class="s1">]</span>
                <span class="s3">elif </span><span class="s1">self.which </span><span class="s3">in </span><span class="s1">[</span><span class="s4">'SR'</span><span class="s3">, </span><span class="s4">'SM'</span><span class="s3">, </span><span class="s4">'SI'</span><span class="s1">]:</span>
                    <span class="s1">ind = ind[:k]</span>

                <span class="s1">d = d[ind]</span>
                <span class="s1">z = z[:</span><span class="s3">, </span><span class="s1">ind]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s2"># complex is so much simpler...</span>
            <span class="s1">d</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">ierr =\</span>
                    <span class="s1">self._arpack_extract(return_eigenvectors</span><span class="s3">,</span>
                           <span class="s1">howmny</span><span class="s3">, </span><span class="s1">sselect</span><span class="s3">, </span><span class="s1">self.sigma</span><span class="s3">, </span><span class="s1">workev</span><span class="s3">,</span>
                           <span class="s1">self.bmat</span><span class="s3">, </span><span class="s1">self.which</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">self.tol</span><span class="s3">, </span><span class="s1">self.resid</span><span class="s3">,</span>
                           <span class="s1">self.v</span><span class="s3">, </span><span class="s1">self.iparam</span><span class="s3">, </span><span class="s1">self.ipntr</span><span class="s3">,</span>
                           <span class="s1">self.workd</span><span class="s3">, </span><span class="s1">self.workl</span><span class="s3">, </span><span class="s1">self.rwork</span><span class="s3">, </span><span class="s1">ierr)</span>

            <span class="s3">if </span><span class="s1">ierr != </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ArpackError(ierr</span><span class="s3">, </span><span class="s1">infodict=self.extract_infodict)</span>

            <span class="s1">k_ok = self.iparam[</span><span class="s5">4</span><span class="s1">]</span>
            <span class="s1">d = d[:k_ok]</span>
            <span class="s1">z = z[:</span><span class="s3">, </span><span class="s1">:k_ok]</span>

        <span class="s3">if </span><span class="s1">return_eigenvectors:</span>
            <span class="s3">return </span><span class="s1">d</span><span class="s3">, </span><span class="s1">z</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">d</span>


<span class="s3">def </span><span class="s1">_aslinearoperator_with_dtype(m):</span>
    <span class="s1">m = aslinearoperator(m)</span>
    <span class="s3">if not </span><span class="s1">hasattr(m</span><span class="s3">, </span><span class="s4">'dtype'</span><span class="s1">):</span>
        <span class="s1">x = np.zeros(m.shape[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">m.dtype = (m * x).dtype</span>
    <span class="s3">return </span><span class="s1">m</span>


<span class="s3">class </span><span class="s1">SpLuInv(LinearOperator):</span>
    <span class="s0">&quot;&quot;&quot; 
    SpLuInv: 
       helper class to repeatedly solve M*x=b 
       using a sparse LU-decomposition of M 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">M):</span>
        <span class="s1">self.M_lu = splu(M)</span>
        <span class="s1">self.shape = M.shape</span>
        <span class="s1">self.dtype = M.dtype</span>
        <span class="s1">self.isreal = </span><span class="s3">not </span><span class="s1">np.issubdtype(self.dtype</span><span class="s3">, </span><span class="s1">np.complexfloating)</span>

    <span class="s3">def </span><span class="s1">_matvec(self</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s2"># careful here: splu.solve will throw away imaginary</span>
        <span class="s2"># part of x if M is real</span>
        <span class="s1">x = np.asarray(x)</span>
        <span class="s3">if </span><span class="s1">self.isreal </span><span class="s3">and </span><span class="s1">np.issubdtype(x.dtype</span><span class="s3">, </span><span class="s1">np.complexfloating):</span>
            <span class="s3">return </span><span class="s1">(self.M_lu.solve(np.real(x).astype(self.dtype))</span>
                    <span class="s1">+ </span><span class="s5">1j </span><span class="s1">* self.M_lu.solve(np.imag(x).astype(self.dtype)))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.M_lu.solve(x.astype(self.dtype))</span>


<span class="s3">class </span><span class="s1">LuInv(LinearOperator):</span>
    <span class="s0">&quot;&quot;&quot; 
    LuInv: 
       helper class to repeatedly solve M*x=b 
       using an LU-decomposition of M 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">M):</span>
        <span class="s1">self.M_lu = lu_factor(M)</span>
        <span class="s1">self.shape = M.shape</span>
        <span class="s1">self.dtype = M.dtype</span>

    <span class="s3">def </span><span class="s1">_matvec(self</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s3">return </span><span class="s1">lu_solve(self.M_lu</span><span class="s3">, </span><span class="s1">x)</span>


<span class="s3">def </span><span class="s1">gmres_loose(A</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">tol):</span>
    <span class="s0">&quot;&quot;&quot; 
    gmres with looser termination condition. 
    &quot;&quot;&quot;</span>
    <span class="s1">b = np.asarray(b)</span>
    <span class="s1">min_tol = </span><span class="s5">1000 </span><span class="s1">* np.sqrt(b.size) * np.finfo(b.dtype).eps</span>
    <span class="s3">return </span><span class="s1">gmres(A</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">tol=max(tol</span><span class="s3">, </span><span class="s1">min_tol)</span><span class="s3">, </span><span class="s1">atol=</span><span class="s5">0</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">IterInv(LinearOperator):</span>
    <span class="s0">&quot;&quot;&quot; 
    IterInv: 
       helper class to repeatedly solve M*x=b 
       using an iterative method. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">ifunc=gmres_loose</span><span class="s3">, </span><span class="s1">tol=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s1">self.M = M</span>
        <span class="s3">if </span><span class="s1">hasattr(M</span><span class="s3">, </span><span class="s4">'dtype'</span><span class="s1">):</span>
            <span class="s1">self.dtype = M.dtype</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">x = np.zeros(M.shape[</span><span class="s5">1</span><span class="s1">])</span>
            <span class="s1">self.dtype = (M * x).dtype</span>
        <span class="s1">self.shape = M.shape</span>

        <span class="s3">if </span><span class="s1">tol &lt;= </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2"># when tol=0, ARPACK uses machine tolerance as calculated</span>
            <span class="s2"># by LAPACK's _LAMCH function.  We should match this</span>
            <span class="s1">tol = </span><span class="s5">2 </span><span class="s1">* np.finfo(self.dtype).eps</span>
        <span class="s1">self.ifunc = ifunc</span>
        <span class="s1">self.tol = tol</span>

    <span class="s3">def </span><span class="s1">_matvec(self</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s1">b</span><span class="s3">, </span><span class="s1">info = self.ifunc(self.M</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">tol=self.tol)</span>
        <span class="s3">if </span><span class="s1">info != </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Error in inverting M: function &quot;</span>
                             <span class="s4">&quot;%s did not converge (info = %i).&quot;</span>
                             <span class="s1">% (self.ifunc.__name__</span><span class="s3">, </span><span class="s1">info))</span>
        <span class="s3">return </span><span class="s1">b</span>


<span class="s3">class </span><span class="s1">IterOpInv(LinearOperator):</span>
    <span class="s0">&quot;&quot;&quot; 
    IterOpInv: 
       helper class to repeatedly solve [A-sigma*M]*x = b 
       using an iterative method 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">A</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">sigma</span><span class="s3">, </span><span class="s1">ifunc=gmres_loose</span><span class="s3">, </span><span class="s1">tol=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s1">self.A = A</span>
        <span class="s1">self.M = M</span>
        <span class="s1">self.sigma = sigma</span>

        <span class="s3">def </span><span class="s1">mult_func(x):</span>
            <span class="s3">return </span><span class="s1">A.matvec(x) - sigma * M.matvec(x)</span>

        <span class="s3">def </span><span class="s1">mult_func_M_None(x):</span>
            <span class="s3">return </span><span class="s1">A.matvec(x) - sigma * x</span>

        <span class="s1">x = np.zeros(A.shape[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s3">if </span><span class="s1">M </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">dtype = mult_func_M_None(x).dtype</span>
            <span class="s1">self.OP = LinearOperator(self.A.shape</span><span class="s3">,</span>
                                     <span class="s1">mult_func_M_None</span><span class="s3">,</span>
                                     <span class="s1">dtype=dtype)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">dtype = mult_func(x).dtype</span>
            <span class="s1">self.OP = LinearOperator(self.A.shape</span><span class="s3">,</span>
                                     <span class="s1">mult_func</span><span class="s3">,</span>
                                     <span class="s1">dtype=dtype)</span>
        <span class="s1">self.shape = A.shape</span>

        <span class="s3">if </span><span class="s1">tol &lt;= </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2"># when tol=0, ARPACK uses machine tolerance as calculated</span>
            <span class="s2"># by LAPACK's _LAMCH function.  We should match this</span>
            <span class="s1">tol = </span><span class="s5">2 </span><span class="s1">* np.finfo(self.OP.dtype).eps</span>
        <span class="s1">self.ifunc = ifunc</span>
        <span class="s1">self.tol = tol</span>

    <span class="s3">def </span><span class="s1">_matvec(self</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s1">b</span><span class="s3">, </span><span class="s1">info = self.ifunc(self.OP</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">tol=self.tol)</span>
        <span class="s3">if </span><span class="s1">info != </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Error in inverting [A-sigma*M]: function &quot;</span>
                             <span class="s4">&quot;%s did not converge (info = %i).&quot;</span>
                             <span class="s1">% (self.ifunc.__name__</span><span class="s3">, </span><span class="s1">info))</span>
        <span class="s3">return </span><span class="s1">b</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">dtype(self):</span>
        <span class="s3">return </span><span class="s1">self.OP.dtype</span>


<span class="s3">def </span><span class="s1">_fast_spmatrix_to_csc(A</span><span class="s3">, </span><span class="s1">hermitian=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Convert sparse matrix to CSC (by transposing, if possible)&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">(A.format == </span><span class="s4">&quot;csr&quot; </span><span class="s3">and </span><span class="s1">hermitian</span>
            <span class="s3">and not </span><span class="s1">np.issubdtype(A.dtype</span><span class="s3">, </span><span class="s1">np.complexfloating)):</span>
        <span class="s3">return </span><span class="s1">A.T</span>
    <span class="s3">elif </span><span class="s1">is_pydata_spmatrix(A):</span>
        <span class="s2"># No need to convert</span>
        <span class="s3">return </span><span class="s1">A</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">A.tocsc()</span>


<span class="s3">def </span><span class="s1">get_inv_matvec(M</span><span class="s3">, </span><span class="s1">hermitian=</span><span class="s3">False, </span><span class="s1">tol=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s3">if </span><span class="s1">isdense(M):</span>
        <span class="s3">return </span><span class="s1">LuInv(M).matvec</span>
    <span class="s3">elif </span><span class="s1">issparse(M) </span><span class="s3">or </span><span class="s1">is_pydata_spmatrix(M):</span>
        <span class="s1">M = _fast_spmatrix_to_csc(M</span><span class="s3">, </span><span class="s1">hermitian=hermitian)</span>
        <span class="s3">return </span><span class="s1">SpLuInv(M).matvec</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">IterInv(M</span><span class="s3">, </span><span class="s1">tol=tol).matvec</span>


<span class="s3">def </span><span class="s1">get_OPinv_matvec(A</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">sigma</span><span class="s3">, </span><span class="s1">hermitian=</span><span class="s3">False, </span><span class="s1">tol=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s3">if </span><span class="s1">sigma == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">get_inv_matvec(A</span><span class="s3">, </span><span class="s1">hermitian=hermitian</span><span class="s3">, </span><span class="s1">tol=tol)</span>

    <span class="s3">if </span><span class="s1">M </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s2">#M is the identity matrix</span>
        <span class="s3">if </span><span class="s1">isdense(A):</span>
            <span class="s3">if </span><span class="s1">(np.issubdtype(A.dtype</span><span class="s3">, </span><span class="s1">np.complexfloating)</span>
                    <span class="s3">or </span><span class="s1">np.imag(sigma) == </span><span class="s5">0</span><span class="s1">):</span>
                <span class="s1">A = np.copy(A)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">A = A + </span><span class="s5">0j</span>
            <span class="s1">A.flat[::A.shape[</span><span class="s5">1</span><span class="s1">] + </span><span class="s5">1</span><span class="s1">] -= sigma</span>
            <span class="s3">return </span><span class="s1">LuInv(A).matvec</span>
        <span class="s3">elif </span><span class="s1">issparse(A) </span><span class="s3">or </span><span class="s1">is_pydata_spmatrix(A):</span>
            <span class="s1">A = A - sigma * eye(A.shape[</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s1">A = _fast_spmatrix_to_csc(A</span><span class="s3">, </span><span class="s1">hermitian=hermitian)</span>
            <span class="s3">return </span><span class="s1">SpLuInv(A).matvec</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">IterOpInv(_aslinearoperator_with_dtype(A)</span><span class="s3">,</span>
                             <span class="s1">M</span><span class="s3">, </span><span class="s1">sigma</span><span class="s3">, </span><span class="s1">tol=tol).matvec</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">((</span><span class="s3">not </span><span class="s1">isdense(A) </span><span class="s3">and not </span><span class="s1">issparse(A) </span><span class="s3">and not </span><span class="s1">is_pydata_spmatrix(A)) </span><span class="s3">or</span>
                <span class="s1">(</span><span class="s3">not </span><span class="s1">isdense(M) </span><span class="s3">and not </span><span class="s1">issparse(M) </span><span class="s3">and not </span><span class="s1">is_pydata_spmatrix(A))):</span>
            <span class="s3">return </span><span class="s1">IterOpInv(_aslinearoperator_with_dtype(A)</span><span class="s3">,</span>
                             <span class="s1">_aslinearoperator_with_dtype(M)</span><span class="s3">,</span>
                             <span class="s1">sigma</span><span class="s3">, </span><span class="s1">tol=tol).matvec</span>
        <span class="s3">elif </span><span class="s1">isdense(A) </span><span class="s3">or </span><span class="s1">isdense(M):</span>
            <span class="s3">return </span><span class="s1">LuInv(A - sigma * M).matvec</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">OP = A - sigma * M</span>
            <span class="s1">OP = _fast_spmatrix_to_csc(OP</span><span class="s3">, </span><span class="s1">hermitian=hermitian)</span>
            <span class="s3">return </span><span class="s1">SpLuInv(OP).matvec</span>


<span class="s2"># ARPACK is not threadsafe or reentrant (SAVE variables), so we need a</span>
<span class="s2"># lock and a re-entering check.</span>
<span class="s1">_ARPACK_LOCK = ReentrancyLock(</span><span class="s4">&quot;Nested calls to eigs/eighs not allowed: &quot;</span>
                              <span class="s4">&quot;ARPACK is not re-entrant&quot;</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">eigs(A</span><span class="s3">, </span><span class="s1">k=</span><span class="s5">6</span><span class="s3">, </span><span class="s1">M=</span><span class="s3">None, </span><span class="s1">sigma=</span><span class="s3">None, </span><span class="s1">which=</span><span class="s4">'LM'</span><span class="s3">, </span><span class="s1">v0=</span><span class="s3">None,</span>
         <span class="s1">ncv=</span><span class="s3">None, </span><span class="s1">maxiter=</span><span class="s3">None, </span><span class="s1">tol=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">return_eigenvectors=</span><span class="s3">True,</span>
         <span class="s1">Minv=</span><span class="s3">None, </span><span class="s1">OPinv=</span><span class="s3">None, </span><span class="s1">OPpart=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Find k eigenvalues and eigenvectors of the square matrix A. 
 
    Solves ``A @ x[i] = w[i] * x[i]``, the standard eigenvalue problem 
    for w[i] eigenvalues with corresponding eigenvectors x[i]. 
 
    If M is specified, solves ``A @ x[i] = w[i] * M @ x[i]``, the 
    generalized eigenvalue problem for w[i] eigenvalues 
    with corresponding eigenvectors x[i] 
 
    Parameters 
    ---------- 
    A : ndarray, sparse matrix or LinearOperator 
        An array, sparse matrix, or LinearOperator representing 
        the operation ``A @ x``, where A is a real or complex square matrix. 
    k : int, optional 
        The number of eigenvalues and eigenvectors desired. 
        `k` must be smaller than N-1. It is not possible to compute all 
        eigenvectors of a matrix. 
    M : ndarray, sparse matrix or LinearOperator, optional 
        An array, sparse matrix, or LinearOperator representing 
        the operation M@x for the generalized eigenvalue problem 
 
            A @ x = w * M @ x. 
 
        M must represent a real symmetric matrix if A is real, and must 
        represent a complex Hermitian matrix if A is complex. For best 
        results, the data type of M should be the same as that of A. 
        Additionally: 
 
            If `sigma` is None, M is positive definite 
 
            If sigma is specified, M is positive semi-definite 
 
        If sigma is None, eigs requires an operator to compute the solution 
        of the linear equation ``M @ x = b``.  This is done internally via a 
        (sparse) LU decomposition for an explicit matrix M, or via an 
        iterative solver for a general linear operator.  Alternatively, 
        the user can supply the matrix or operator Minv, which gives 
        ``x = Minv @ b = M^-1 @ b``. 
    sigma : real or complex, optional 
        Find eigenvalues near sigma using shift-invert mode.  This requires 
        an operator to compute the solution of the linear system 
        ``[A - sigma * M] @ x = b``, where M is the identity matrix if 
        unspecified. This is computed internally via a (sparse) LU 
        decomposition for explicit matrices A &amp; M, or via an iterative 
        solver if either A or M is a general linear operator. 
        Alternatively, the user can supply the matrix or operator OPinv, 
        which gives ``x = OPinv @ b = [A - sigma * M]^-1 @ b``. 
        For a real matrix A, shift-invert can either be done in imaginary 
        mode or real mode, specified by the parameter OPpart ('r' or 'i'). 
        Note that when sigma is specified, the keyword 'which' (below) 
        refers to the shifted eigenvalues ``w'[i]`` where: 
 
            If A is real and OPpart == 'r' (default), 
              ``w'[i] = 1/2 * [1/(w[i]-sigma) + 1/(w[i]-conj(sigma))]``. 
 
            If A is real and OPpart == 'i', 
              ``w'[i] = 1/2i * [1/(w[i]-sigma) - 1/(w[i]-conj(sigma))]``. 
 
            If A is complex, ``w'[i] = 1/(w[i]-sigma)``. 
 
    v0 : ndarray, optional 
        Starting vector for iteration. 
        Default: random 
    ncv : int, optional 
        The number of Lanczos vectors generated 
        `ncv` must be greater than `k`; it is recommended that ``ncv &gt; 2*k``. 
        Default: ``min(n, max(2*k + 1, 20))`` 
    which : str, ['LM' | 'SM' | 'LR' | 'SR' | 'LI' | 'SI'], optional 
        Which `k` eigenvectors and eigenvalues to find: 
 
            'LM' : largest magnitude 
 
            'SM' : smallest magnitude 
 
            'LR' : largest real part 
 
            'SR' : smallest real part 
 
            'LI' : largest imaginary part 
 
            'SI' : smallest imaginary part 
 
        When sigma != None, 'which' refers to the shifted eigenvalues w'[i] 
        (see discussion in 'sigma', above).  ARPACK is generally better 
        at finding large values than small values.  If small eigenvalues are 
        desired, consider using shift-invert mode for better performance. 
    maxiter : int, optional 
        Maximum number of Arnoldi update iterations allowed 
        Default: ``n*10`` 
    tol : float, optional 
        Relative accuracy for eigenvalues (stopping criterion) 
        The default value of 0 implies machine precision. 
    return_eigenvectors : bool, optional 
        Return eigenvectors (True) in addition to eigenvalues 
    Minv : ndarray, sparse matrix or LinearOperator, optional 
        See notes in M, above. 
    OPinv : ndarray, sparse matrix or LinearOperator, optional 
        See notes in sigma, above. 
    OPpart : {'r' or 'i'}, optional 
        See notes in sigma, above 
 
    Returns 
    ------- 
    w : ndarray 
        Array of k eigenvalues. 
    v : ndarray 
        An array of `k` eigenvectors. 
        ``v[:, i]`` is the eigenvector corresponding to the eigenvalue w[i]. 
 
    Raises 
    ------ 
    ArpackNoConvergence 
        When the requested convergence is not obtained. 
        The currently converged eigenvalues and eigenvectors can be found 
        as ``eigenvalues`` and ``eigenvectors`` attributes of the exception 
        object. 
 
    See Also 
    -------- 
    eigsh : eigenvalues and eigenvectors for symmetric matrix A 
    svds : singular value decomposition for a matrix A 
 
    Notes 
    ----- 
    This function is a wrapper to the ARPACK [1]_ SNEUPD, DNEUPD, CNEUPD, 
    ZNEUPD, functions which use the Implicitly Restarted Arnoldi Method to 
    find the eigenvalues and eigenvectors [2]_. 
 
    References 
    ---------- 
    .. [1] ARPACK Software, https://github.com/opencollab/arpack-ng 
    .. [2] R. B. Lehoucq, D. C. Sorensen, and C. Yang,  ARPACK USERS GUIDE: 
       Solution of Large Scale Eigenvalue Problems by Implicitly Restarted 
       Arnoldi Methods. SIAM, Philadelphia, PA, 1998. 
 
    Examples 
    -------- 
    Find 6 eigenvectors of the identity matrix: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.sparse.linalg import eigs 
    &gt;&gt;&gt; id = np.eye(13) 
    &gt;&gt;&gt; vals, vecs = eigs(id, k=6) 
    &gt;&gt;&gt; vals 
    array([ 1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j]) 
    &gt;&gt;&gt; vecs.shape 
    (13, 6) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">A.shape[</span><span class="s5">0</span><span class="s1">] != A.shape[</span><span class="s5">1</span><span class="s1">]:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f'expected square matrix (shape=</span><span class="s3">{</span><span class="s1">A.shape</span><span class="s3">}</span><span class="s4">)'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">M </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">M.shape != A.shape:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'wrong M dimensions %s, should be %s'</span>
                             <span class="s1">% (M.shape</span><span class="s3">, </span><span class="s1">A.shape))</span>
        <span class="s3">if </span><span class="s1">np.dtype(M.dtype).char.lower() != np.dtype(A.dtype).char.lower():</span>
            <span class="s1">warnings.warn(</span><span class="s4">'M does not have the same type precision as A. '</span>
                          <span class="s4">'This may adversely affect ARPACK convergence'</span><span class="s1">)</span>

    <span class="s1">n = A.shape[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s3">if </span><span class="s1">k &lt;= </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;k=%d must be greater than 0.&quot; </span><span class="s1">% k)</span>

    <span class="s3">if </span><span class="s1">k &gt;= n - </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">warnings.warn(</span><span class="s4">&quot;k &gt;= N - 1 for N * N square matrix. &quot;</span>
                      <span class="s4">&quot;Attempting to use scipy.linalg.eig instead.&quot;</span><span class="s3">,</span>
                      <span class="s1">RuntimeWarning)</span>

        <span class="s3">if </span><span class="s1">issparse(A):</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Cannot use scipy.linalg.eig for sparse A with &quot;</span>
                            <span class="s4">&quot;k &gt;= N - 1. Use scipy.linalg.eig(A.toarray()) or&quot;</span>
                            <span class="s4">&quot; reduce k.&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">isinstance(A</span><span class="s3">, </span><span class="s1">LinearOperator):</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Cannot use scipy.linalg.eig for LinearOperator &quot;</span>
                            <span class="s4">&quot;A with k &gt;= N - 1.&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">isinstance(M</span><span class="s3">, </span><span class="s1">LinearOperator):</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Cannot use scipy.linalg.eig for LinearOperator &quot;</span>
                            <span class="s4">&quot;M with k &gt;= N - 1.&quot;</span><span class="s1">)</span>

        <span class="s3">return </span><span class="s1">eig(A</span><span class="s3">, </span><span class="s1">b=M</span><span class="s3">, </span><span class="s1">right=return_eigenvectors)</span>

    <span class="s3">if </span><span class="s1">sigma </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">matvec = _aslinearoperator_with_dtype(A).matvec</span>

        <span class="s3">if </span><span class="s1">OPinv </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;OPinv should not be specified &quot;</span>
                             <span class="s4">&quot;with sigma = None.&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">OPpart </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;OPpart should not be specified with &quot;</span>
                             <span class="s4">&quot;sigma = None or complex A&quot;</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">M </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s2">#standard eigenvalue problem</span>
            <span class="s1">mode = </span><span class="s5">1</span>
            <span class="s1">M_matvec = </span><span class="s3">None</span>
            <span class="s1">Minv_matvec = </span><span class="s3">None</span>
            <span class="s3">if </span><span class="s1">Minv </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Minv should not be &quot;</span>
                                 <span class="s4">&quot;specified with M = None.&quot;</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s2">#general eigenvalue problem</span>
            <span class="s1">mode = </span><span class="s5">2</span>
            <span class="s3">if </span><span class="s1">Minv </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">Minv_matvec = get_inv_matvec(M</span><span class="s3">, </span><span class="s1">hermitian=</span><span class="s3">True, </span><span class="s1">tol=tol)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">Minv = _aslinearoperator_with_dtype(Minv)</span>
                <span class="s1">Minv_matvec = Minv.matvec</span>
            <span class="s1">M_matvec = _aslinearoperator_with_dtype(M).matvec</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s2">#sigma is not None: shift-invert mode</span>
        <span class="s3">if </span><span class="s1">np.issubdtype(A.dtype</span><span class="s3">, </span><span class="s1">np.complexfloating):</span>
            <span class="s3">if </span><span class="s1">OPpart </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;OPpart should not be specified &quot;</span>
                                 <span class="s4">&quot;with sigma=None or complex A&quot;</span><span class="s1">)</span>
            <span class="s1">mode = </span><span class="s5">3</span>
        <span class="s3">elif </span><span class="s1">OPpart </span><span class="s3">is None or </span><span class="s1">OPpart.lower() == </span><span class="s4">'r'</span><span class="s1">:</span>
            <span class="s1">mode = </span><span class="s5">3</span>
        <span class="s3">elif </span><span class="s1">OPpart.lower() == </span><span class="s4">'i'</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">np.imag(sigma) == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;OPpart cannot be 'i' if sigma is real&quot;</span><span class="s1">)</span>
            <span class="s1">mode = </span><span class="s5">4</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;OPpart must be one of ('r','i')&quot;</span><span class="s1">)</span>

        <span class="s1">matvec = _aslinearoperator_with_dtype(A).matvec</span>
        <span class="s3">if </span><span class="s1">Minv </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Minv should not be specified when sigma is&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">OPinv </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">Minv_matvec = get_OPinv_matvec(A</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">sigma</span><span class="s3">,</span>
                                           <span class="s1">hermitian=</span><span class="s3">False, </span><span class="s1">tol=tol)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">OPinv = _aslinearoperator_with_dtype(OPinv)</span>
            <span class="s1">Minv_matvec = OPinv.matvec</span>
        <span class="s3">if </span><span class="s1">M </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">M_matvec = </span><span class="s3">None</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">M_matvec = _aslinearoperator_with_dtype(M).matvec</span>

    <span class="s1">params = _UnsymmetricArpackParams(n</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">A.dtype.char</span><span class="s3">, </span><span class="s1">matvec</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">,</span>
                                      <span class="s1">M_matvec</span><span class="s3">, </span><span class="s1">Minv_matvec</span><span class="s3">, </span><span class="s1">sigma</span><span class="s3">,</span>
                                      <span class="s1">ncv</span><span class="s3">, </span><span class="s1">v0</span><span class="s3">, </span><span class="s1">maxiter</span><span class="s3">, </span><span class="s1">which</span><span class="s3">, </span><span class="s1">tol)</span>

    <span class="s3">with </span><span class="s1">_ARPACK_LOCK:</span>
        <span class="s3">while not </span><span class="s1">params.converged:</span>
            <span class="s1">params.iterate()</span>

        <span class="s3">return </span><span class="s1">params.extract(return_eigenvectors)</span>


<span class="s3">def </span><span class="s1">eigsh(A</span><span class="s3">, </span><span class="s1">k=</span><span class="s5">6</span><span class="s3">, </span><span class="s1">M=</span><span class="s3">None, </span><span class="s1">sigma=</span><span class="s3">None, </span><span class="s1">which=</span><span class="s4">'LM'</span><span class="s3">, </span><span class="s1">v0=</span><span class="s3">None,</span>
          <span class="s1">ncv=</span><span class="s3">None, </span><span class="s1">maxiter=</span><span class="s3">None, </span><span class="s1">tol=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">return_eigenvectors=</span><span class="s3">True,</span>
          <span class="s1">Minv=</span><span class="s3">None, </span><span class="s1">OPinv=</span><span class="s3">None, </span><span class="s1">mode=</span><span class="s4">'normal'</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Find k eigenvalues and eigenvectors of the real symmetric square matrix 
    or complex Hermitian matrix A. 
 
    Solves ``A @ x[i] = w[i] * x[i]``, the standard eigenvalue problem for 
    w[i] eigenvalues with corresponding eigenvectors x[i]. 
 
    If M is specified, solves ``A @ x[i] = w[i] * M @ x[i]``, the 
    generalized eigenvalue problem for w[i] eigenvalues 
    with corresponding eigenvectors x[i]. 
 
    Note that there is no specialized routine for the case when A is a complex 
    Hermitian matrix. In this case, ``eigsh()`` will call ``eigs()`` and return the 
    real parts of the eigenvalues thus obtained. 
 
    Parameters 
    ---------- 
    A : ndarray, sparse matrix or LinearOperator 
        A square operator representing the operation ``A @ x``, where ``A`` is 
        real symmetric or complex Hermitian. For buckling mode (see below) 
        ``A`` must additionally be positive-definite. 
    k : int, optional 
        The number of eigenvalues and eigenvectors desired. 
        `k` must be smaller than N. It is not possible to compute all 
        eigenvectors of a matrix. 
 
    Returns 
    ------- 
    w : array 
        Array of k eigenvalues. 
    v : array 
        An array representing the `k` eigenvectors.  The column ``v[:, i]`` is 
        the eigenvector corresponding to the eigenvalue ``w[i]``. 
 
    Other Parameters 
    ---------------- 
    M : An N x N matrix, array, sparse matrix, or linear operator representing 
        the operation ``M @ x`` for the generalized eigenvalue problem 
 
            A @ x = w * M @ x. 
 
        M must represent a real symmetric matrix if A is real, and must 
        represent a complex Hermitian matrix if A is complex. For best 
        results, the data type of M should be the same as that of A. 
        Additionally: 
 
            If sigma is None, M is symmetric positive definite. 
 
            If sigma is specified, M is symmetric positive semi-definite. 
 
            In buckling mode, M is symmetric indefinite. 
 
        If sigma is None, eigsh requires an operator to compute the solution 
        of the linear equation ``M @ x = b``. This is done internally via a 
        (sparse) LU decomposition for an explicit matrix M, or via an 
        iterative solver for a general linear operator.  Alternatively, 
        the user can supply the matrix or operator Minv, which gives 
        ``x = Minv @ b = M^-1 @ b``. 
    sigma : real 
        Find eigenvalues near sigma using shift-invert mode.  This requires 
        an operator to compute the solution of the linear system 
        ``[A - sigma * M] x = b``, where M is the identity matrix if 
        unspecified.  This is computed internally via a (sparse) LU 
        decomposition for explicit matrices A &amp; M, or via an iterative 
        solver if either A or M is a general linear operator. 
        Alternatively, the user can supply the matrix or operator OPinv, 
        which gives ``x = OPinv @ b = [A - sigma * M]^-1 @ b``. 
        Note that when sigma is specified, the keyword 'which' refers to 
        the shifted eigenvalues ``w'[i]`` where: 
 
            if mode == 'normal', ``w'[i] = 1 / (w[i] - sigma)``. 
 
            if mode == 'cayley', ``w'[i] = (w[i] + sigma) / (w[i] - sigma)``. 
 
            if mode == 'buckling', ``w'[i] = w[i] / (w[i] - sigma)``. 
 
        (see further discussion in 'mode' below) 
    v0 : ndarray, optional 
        Starting vector for iteration. 
        Default: random 
    ncv : int, optional 
        The number of Lanczos vectors generated ncv must be greater than k and 
        smaller than n; it is recommended that ``ncv &gt; 2*k``. 
        Default: ``min(n, max(2*k + 1, 20))`` 
    which : str ['LM' | 'SM' | 'LA' | 'SA' | 'BE'] 
        If A is a complex Hermitian matrix, 'BE' is invalid. 
        Which `k` eigenvectors and eigenvalues to find: 
 
            'LM' : Largest (in magnitude) eigenvalues. 
 
            'SM' : Smallest (in magnitude) eigenvalues. 
 
            'LA' : Largest (algebraic) eigenvalues. 
 
            'SA' : Smallest (algebraic) eigenvalues. 
 
            'BE' : Half (k/2) from each end of the spectrum. 
 
        When k is odd, return one more (k/2+1) from the high end. 
        When sigma != None, 'which' refers to the shifted eigenvalues ``w'[i]`` 
        (see discussion in 'sigma', above).  ARPACK is generally better 
        at finding large values than small values.  If small eigenvalues are 
        desired, consider using shift-invert mode for better performance. 
    maxiter : int, optional 
        Maximum number of Arnoldi update iterations allowed. 
        Default: ``n*10`` 
    tol : float 
        Relative accuracy for eigenvalues (stopping criterion). 
        The default value of 0 implies machine precision. 
    Minv : N x N matrix, array, sparse matrix, or LinearOperator 
        See notes in M, above. 
    OPinv : N x N matrix, array, sparse matrix, or LinearOperator 
        See notes in sigma, above. 
    return_eigenvectors : bool 
        Return eigenvectors (True) in addition to eigenvalues. 
        This value determines the order in which eigenvalues are sorted. 
        The sort order is also dependent on the `which` variable. 
 
            For which = 'LM' or 'SA': 
                If `return_eigenvectors` is True, eigenvalues are sorted by 
                algebraic value. 
 
                If `return_eigenvectors` is False, eigenvalues are sorted by 
                absolute value. 
 
            For which = 'BE' or 'LA': 
                eigenvalues are always sorted by algebraic value. 
 
            For which = 'SM': 
                If `return_eigenvectors` is True, eigenvalues are sorted by 
                algebraic value. 
 
                If `return_eigenvectors` is False, eigenvalues are sorted by 
                decreasing absolute value. 
 
    mode : string ['normal' | 'buckling' | 'cayley'] 
        Specify strategy to use for shift-invert mode.  This argument applies 
        only for real-valued A and sigma != None.  For shift-invert mode, 
        ARPACK internally solves the eigenvalue problem 
        ``OP @ x'[i] = w'[i] * B @ x'[i]`` 
        and transforms the resulting Ritz vectors x'[i] and Ritz values w'[i] 
        into the desired eigenvectors and eigenvalues of the problem 
        ``A @ x[i] = w[i] * M @ x[i]``. 
        The modes are as follows: 
 
            'normal' : 
                OP = [A - sigma * M]^-1 @ M, 
                B = M, 
                w'[i] = 1 / (w[i] - sigma) 
 
            'buckling' : 
                OP = [A - sigma * M]^-1 @ A, 
                B = A, 
                w'[i] = w[i] / (w[i] - sigma) 
 
            'cayley' : 
                OP = [A - sigma * M]^-1 @ [A + sigma * M], 
                B = M, 
                w'[i] = (w[i] + sigma) / (w[i] - sigma) 
 
        The choice of mode will affect which eigenvalues are selected by 
        the keyword 'which', and can also impact the stability of 
        convergence (see [2] for a discussion). 
 
    Raises 
    ------ 
    ArpackNoConvergence 
        When the requested convergence is not obtained. 
 
        The currently converged eigenvalues and eigenvectors can be found 
        as ``eigenvalues`` and ``eigenvectors`` attributes of the exception 
        object. 
 
    See Also 
    -------- 
    eigs : eigenvalues and eigenvectors for a general (nonsymmetric) matrix A 
    svds : singular value decomposition for a matrix A 
 
    Notes 
    ----- 
    This function is a wrapper to the ARPACK [1]_ SSEUPD and DSEUPD 
    functions which use the Implicitly Restarted Lanczos Method to 
    find the eigenvalues and eigenvectors [2]_. 
 
    References 
    ---------- 
    .. [1] ARPACK Software, https://github.com/opencollab/arpack-ng 
    .. [2] R. B. Lehoucq, D. C. Sorensen, and C. Yang,  ARPACK USERS GUIDE: 
       Solution of Large Scale Eigenvalue Problems by Implicitly Restarted 
       Arnoldi Methods. SIAM, Philadelphia, PA, 1998. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.sparse.linalg import eigsh 
    &gt;&gt;&gt; identity = np.eye(13) 
    &gt;&gt;&gt; eigenvalues, eigenvectors = eigsh(identity, k=6) 
    &gt;&gt;&gt; eigenvalues 
    array([1., 1., 1., 1., 1., 1.]) 
    &gt;&gt;&gt; eigenvectors.shape 
    (13, 6) 
 
    &quot;&quot;&quot;</span>
    <span class="s2"># complex Hermitian matrices should be solved with eigs</span>
    <span class="s3">if </span><span class="s1">np.issubdtype(A.dtype</span><span class="s3">, </span><span class="s1">np.complexfloating):</span>
        <span class="s3">if </span><span class="s1">mode != </span><span class="s4">'normal'</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;mode=%s cannot be used with &quot;</span>
                             <span class="s4">&quot;complex matrix A&quot; </span><span class="s1">% mode)</span>
        <span class="s3">if </span><span class="s1">which == </span><span class="s4">'BE'</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;which='BE' cannot be used with complex matrix A&quot;</span><span class="s1">)</span>
        <span class="s3">elif </span><span class="s1">which == </span><span class="s4">'LA'</span><span class="s1">:</span>
            <span class="s1">which = </span><span class="s4">'LR'</span>
        <span class="s3">elif </span><span class="s1">which == </span><span class="s4">'SA'</span><span class="s1">:</span>
            <span class="s1">which = </span><span class="s4">'SR'</span>
        <span class="s1">ret = eigs(A</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">M=M</span><span class="s3">, </span><span class="s1">sigma=sigma</span><span class="s3">, </span><span class="s1">which=which</span><span class="s3">, </span><span class="s1">v0=v0</span><span class="s3">,</span>
                   <span class="s1">ncv=ncv</span><span class="s3">, </span><span class="s1">maxiter=maxiter</span><span class="s3">, </span><span class="s1">tol=tol</span><span class="s3">,</span>
                   <span class="s1">return_eigenvectors=return_eigenvectors</span><span class="s3">, </span><span class="s1">Minv=Minv</span><span class="s3">,</span>
                   <span class="s1">OPinv=OPinv)</span>

        <span class="s3">if </span><span class="s1">return_eigenvectors:</span>
            <span class="s3">return </span><span class="s1">ret[</span><span class="s5">0</span><span class="s1">].real</span><span class="s3">, </span><span class="s1">ret[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">ret.real</span>

    <span class="s3">if </span><span class="s1">A.shape[</span><span class="s5">0</span><span class="s1">] != A.shape[</span><span class="s5">1</span><span class="s1">]:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f'expected square matrix (shape=</span><span class="s3">{</span><span class="s1">A.shape</span><span class="s3">}</span><span class="s4">)'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">M </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">M.shape != A.shape:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'wrong M dimensions %s, should be %s'</span>
                             <span class="s1">% (M.shape</span><span class="s3">, </span><span class="s1">A.shape))</span>
        <span class="s3">if </span><span class="s1">np.dtype(M.dtype).char.lower() != np.dtype(A.dtype).char.lower():</span>
            <span class="s1">warnings.warn(</span><span class="s4">'M does not have the same type precision as A. '</span>
                          <span class="s4">'This may adversely affect ARPACK convergence'</span><span class="s1">)</span>

    <span class="s1">n = A.shape[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s3">if </span><span class="s1">k &lt;= </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;k must be greater than 0.&quot;</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">k &gt;= n:</span>
        <span class="s1">warnings.warn(</span><span class="s4">&quot;k &gt;= N for N * N square matrix. &quot;</span>
                      <span class="s4">&quot;Attempting to use scipy.linalg.eigh instead.&quot;</span><span class="s3">,</span>
                      <span class="s1">RuntimeWarning)</span>

        <span class="s3">if </span><span class="s1">issparse(A):</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Cannot use scipy.linalg.eigh for sparse A with &quot;</span>
                            <span class="s4">&quot;k &gt;= N. Use scipy.linalg.eigh(A.toarray()) or&quot;</span>
                            <span class="s4">&quot; reduce k.&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">isinstance(A</span><span class="s3">, </span><span class="s1">LinearOperator):</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Cannot use scipy.linalg.eigh for LinearOperator &quot;</span>
                            <span class="s4">&quot;A with k &gt;= N.&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">isinstance(M</span><span class="s3">, </span><span class="s1">LinearOperator):</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Cannot use scipy.linalg.eigh for LinearOperator &quot;</span>
                            <span class="s4">&quot;M with k &gt;= N.&quot;</span><span class="s1">)</span>

        <span class="s3">return </span><span class="s1">eigh(A</span><span class="s3">, </span><span class="s1">b=M</span><span class="s3">, </span><span class="s1">eigvals_only=</span><span class="s3">not </span><span class="s1">return_eigenvectors)</span>

    <span class="s3">if </span><span class="s1">sigma </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">A = _aslinearoperator_with_dtype(A)</span>
        <span class="s1">matvec = A.matvec</span>

        <span class="s3">if </span><span class="s1">OPinv </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;OPinv should not be specified &quot;</span>
                             <span class="s4">&quot;with sigma = None.&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">M </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s2">#standard eigenvalue problem</span>
            <span class="s1">mode = </span><span class="s5">1</span>
            <span class="s1">M_matvec = </span><span class="s3">None</span>
            <span class="s1">Minv_matvec = </span><span class="s3">None</span>
            <span class="s3">if </span><span class="s1">Minv </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Minv should not be &quot;</span>
                                 <span class="s4">&quot;specified with M = None.&quot;</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s2">#general eigenvalue problem</span>
            <span class="s1">mode = </span><span class="s5">2</span>
            <span class="s3">if </span><span class="s1">Minv </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">Minv_matvec = get_inv_matvec(M</span><span class="s3">, </span><span class="s1">hermitian=</span><span class="s3">True, </span><span class="s1">tol=tol)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">Minv = _aslinearoperator_with_dtype(Minv)</span>
                <span class="s1">Minv_matvec = Minv.matvec</span>
            <span class="s1">M_matvec = _aslinearoperator_with_dtype(M).matvec</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s2"># sigma is not None: shift-invert mode</span>
        <span class="s3">if </span><span class="s1">Minv </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Minv should not be specified when sigma is&quot;</span><span class="s1">)</span>

        <span class="s2"># normal mode</span>
        <span class="s3">if </span><span class="s1">mode == </span><span class="s4">'normal'</span><span class="s1">:</span>
            <span class="s1">mode = </span><span class="s5">3</span>
            <span class="s1">matvec = </span><span class="s3">None</span>
            <span class="s3">if </span><span class="s1">OPinv </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">Minv_matvec = get_OPinv_matvec(A</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">sigma</span><span class="s3">,</span>
                                               <span class="s1">hermitian=</span><span class="s3">True, </span><span class="s1">tol=tol)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">OPinv = _aslinearoperator_with_dtype(OPinv)</span>
                <span class="s1">Minv_matvec = OPinv.matvec</span>
            <span class="s3">if </span><span class="s1">M </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">M_matvec = </span><span class="s3">None</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">M = _aslinearoperator_with_dtype(M)</span>
                <span class="s1">M_matvec = M.matvec</span>

        <span class="s2"># buckling mode</span>
        <span class="s3">elif </span><span class="s1">mode == </span><span class="s4">'buckling'</span><span class="s1">:</span>
            <span class="s1">mode = </span><span class="s5">4</span>
            <span class="s3">if </span><span class="s1">OPinv </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">Minv_matvec = get_OPinv_matvec(A</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">sigma</span><span class="s3">,</span>
                                               <span class="s1">hermitian=</span><span class="s3">True, </span><span class="s1">tol=tol)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">Minv_matvec = _aslinearoperator_with_dtype(OPinv).matvec</span>
            <span class="s1">matvec = _aslinearoperator_with_dtype(A).matvec</span>
            <span class="s1">M_matvec = </span><span class="s3">None</span>

        <span class="s2"># cayley-transform mode</span>
        <span class="s3">elif </span><span class="s1">mode == </span><span class="s4">'cayley'</span><span class="s1">:</span>
            <span class="s1">mode = </span><span class="s5">5</span>
            <span class="s1">matvec = _aslinearoperator_with_dtype(A).matvec</span>
            <span class="s3">if </span><span class="s1">OPinv </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">Minv_matvec = get_OPinv_matvec(A</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">sigma</span><span class="s3">,</span>
                                               <span class="s1">hermitian=</span><span class="s3">True, </span><span class="s1">tol=tol)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">Minv_matvec = _aslinearoperator_with_dtype(OPinv).matvec</span>
            <span class="s3">if </span><span class="s1">M </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">M_matvec = </span><span class="s3">None</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">M_matvec = _aslinearoperator_with_dtype(M).matvec</span>

        <span class="s2"># unrecognized mode</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;unrecognized mode '%s'&quot; </span><span class="s1">% mode)</span>

    <span class="s1">params = _SymmetricArpackParams(n</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">A.dtype.char</span><span class="s3">, </span><span class="s1">matvec</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">,</span>
                                    <span class="s1">M_matvec</span><span class="s3">, </span><span class="s1">Minv_matvec</span><span class="s3">, </span><span class="s1">sigma</span><span class="s3">,</span>
                                    <span class="s1">ncv</span><span class="s3">, </span><span class="s1">v0</span><span class="s3">, </span><span class="s1">maxiter</span><span class="s3">, </span><span class="s1">which</span><span class="s3">, </span><span class="s1">tol)</span>

    <span class="s3">with </span><span class="s1">_ARPACK_LOCK:</span>
        <span class="s3">while not </span><span class="s1">params.converged:</span>
            <span class="s1">params.iterate()</span>

        <span class="s3">return </span><span class="s1">params.extract(return_eigenvectors)</span>
</pre>
</body>
</html>