<html>
<head>
<title>discrete.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
discrete.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">scipy.stats </span><span class="s0">import </span><span class="s1">rv_discrete</span><span class="s0">, </span><span class="s1">poisson</span><span class="s0">, </span><span class="s1">nbinom</span>
<span class="s0">from </span><span class="s1">scipy.special </span><span class="s0">import </span><span class="s1">gammaln</span>
<span class="s0">from </span><span class="s1">scipy._lib._util </span><span class="s0">import </span><span class="s1">_lazywhere</span>

<span class="s0">from </span><span class="s1">statsmodels.base.model </span><span class="s0">import </span><span class="s1">GenericLikelihoodModel</span>


<span class="s0">class </span><span class="s1">genpoisson_p_gen(rv_discrete):</span>
    <span class="s2">'''Generalized Poisson distribution 
    '''</span>
    <span class="s0">def </span><span class="s1">_argcheck(self</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p):</span>
        <span class="s0">return </span><span class="s1">(mu &gt;= </span><span class="s3">0</span><span class="s1">) &amp; (alpha==alpha) &amp; (p &gt; </span><span class="s3">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_logpmf(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p):</span>
        <span class="s1">mu_p = mu ** (p - </span><span class="s3">1.</span><span class="s1">)</span>
        <span class="s1">a1 = np.maximum(np.nextafter(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s3">1 </span><span class="s1">+ alpha * mu_p)</span>
        <span class="s1">a2 = np.maximum(np.nextafter(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">mu + (a1 - </span><span class="s3">1.</span><span class="s1">) * x)</span>
        <span class="s1">logpmf_ = np.log(mu) + (x - </span><span class="s3">1.</span><span class="s1">) * np.log(a2)</span>
        <span class="s1">logpmf_ -=  x * np.log(a1) + gammaln(x + </span><span class="s3">1.</span><span class="s1">) + a2 / a1</span>
        <span class="s0">return </span><span class="s1">logpmf_</span>

    <span class="s0">def </span><span class="s1">_pmf(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p):</span>
        <span class="s0">return </span><span class="s1">np.exp(self._logpmf(x</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p))</span>

    <span class="s0">def </span><span class="s1">mean(self</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p):</span>
        <span class="s0">return </span><span class="s1">mu</span>

    <span class="s0">def </span><span class="s1">var(self</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p):</span>
        <span class="s1">dispersion_factor = (</span><span class="s3">1 </span><span class="s1">+ alpha * mu**(p - </span><span class="s3">1</span><span class="s1">))**</span><span class="s3">2</span>
        <span class="s1">var = dispersion_factor * mu</span>
        <span class="s0">return </span><span class="s1">var</span>


<span class="s1">genpoisson_p = genpoisson_p_gen(name=</span><span class="s4">'genpoisson_p'</span><span class="s0">,</span>
                                <span class="s1">longname=</span><span class="s4">'Generalized Poisson'</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">zipoisson_gen(rv_discrete):</span>
    <span class="s2">'''Zero Inflated Poisson distribution 
    '''</span>
    <span class="s0">def </span><span class="s1">_argcheck(self</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">w):</span>
        <span class="s0">return </span><span class="s1">(mu &gt; </span><span class="s3">0</span><span class="s1">) &amp; (w &gt;= </span><span class="s3">0</span><span class="s1">) &amp; (w&lt;=</span><span class="s3">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_logpmf(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">w):</span>
        <span class="s0">return </span><span class="s1">_lazywhere(x != </span><span class="s3">0</span><span class="s0">, </span><span class="s1">(x</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">w)</span><span class="s0">,</span>
                          <span class="s1">(</span><span class="s0">lambda </span><span class="s1">x</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">w: np.log(</span><span class="s3">1. </span><span class="s1">- w) + x * np.log(mu) -</span>
                          <span class="s1">gammaln(x + </span><span class="s3">1.</span><span class="s1">) - mu)</span><span class="s0">,</span>
                          <span class="s1">np.log(w + (</span><span class="s3">1. </span><span class="s1">- w) * np.exp(-mu)))</span>

    <span class="s0">def </span><span class="s1">_pmf(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">w):</span>
        <span class="s0">return </span><span class="s1">np.exp(self._logpmf(x</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">w))</span>

    <span class="s0">def </span><span class="s1">_cdf(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">w):</span>
        <span class="s5"># construct cdf from standard poisson's cdf and the w inflation of zero</span>
        <span class="s0">return </span><span class="s1">w + poisson(mu=mu).cdf(x) * (</span><span class="s3">1 </span><span class="s1">- w)</span>

    <span class="s0">def </span><span class="s1">_ppf(self</span><span class="s0">, </span><span class="s1">q</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">w):</span>
        <span class="s5"># we just translated and stretched q to remove zi</span>
        <span class="s1">q_mod = (q - w) / (</span><span class="s3">1 </span><span class="s1">- w)</span>
        <span class="s1">x = poisson(mu=mu).ppf(q_mod)</span>
        <span class="s5"># set to zero if in the zi range</span>
        <span class="s1">x[q &lt; w] = </span><span class="s3">0</span>
        <span class="s0">return </span><span class="s1">x</span>

    <span class="s0">def </span><span class="s1">mean(self</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">w):</span>
        <span class="s0">return </span><span class="s1">(</span><span class="s3">1 </span><span class="s1">- w) * mu</span>

    <span class="s0">def </span><span class="s1">var(self</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">w):</span>
        <span class="s1">dispersion_factor = </span><span class="s3">1 </span><span class="s1">+ w * mu</span>
        <span class="s1">var = (dispersion_factor * self.mean(mu</span><span class="s0">, </span><span class="s1">w))</span>
        <span class="s0">return </span><span class="s1">var</span>

    <span class="s0">def </span><span class="s1">_moment(self</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">w):</span>
        <span class="s0">return </span><span class="s1">(</span><span class="s3">1 </span><span class="s1">- w) * poisson.moment(n</span><span class="s0">, </span><span class="s1">mu)</span>


<span class="s1">zipoisson = zipoisson_gen(name=</span><span class="s4">'zipoisson'</span><span class="s0">,</span>
                          <span class="s1">longname=</span><span class="s4">'Zero Inflated Poisson'</span><span class="s1">)</span>

<span class="s0">class </span><span class="s1">zigeneralizedpoisson_gen(rv_discrete):</span>
    <span class="s2">'''Zero Inflated Generalized Poisson distribution 
    '''</span>
    <span class="s0">def </span><span class="s1">_argcheck(self</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">w):</span>
        <span class="s0">return </span><span class="s1">(mu &gt; </span><span class="s3">0</span><span class="s1">) &amp; (w &gt;= </span><span class="s3">0</span><span class="s1">) &amp; (w&lt;=</span><span class="s3">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_logpmf(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">w):</span>
        <span class="s0">return </span><span class="s1">_lazywhere(x != </span><span class="s3">0</span><span class="s0">, </span><span class="s1">(x</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">w)</span><span class="s0">,</span>
                          <span class="s1">(</span><span class="s0">lambda </span><span class="s1">x</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">w: np.log(</span><span class="s3">1. </span><span class="s1">- w) +</span>
                          <span class="s1">genpoisson_p.logpmf(x</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p))</span><span class="s0">,</span>
                          <span class="s1">np.log(w + (</span><span class="s3">1. </span><span class="s1">- w) *</span>
                          <span class="s1">genpoisson_p.pmf(x</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p)))</span>

    <span class="s0">def </span><span class="s1">_pmf(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">w):</span>
        <span class="s0">return </span><span class="s1">np.exp(self._logpmf(x</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">w))</span>

    <span class="s0">def </span><span class="s1">mean(self</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">w):</span>
        <span class="s0">return </span><span class="s1">(</span><span class="s3">1 </span><span class="s1">- w) * mu</span>

    <span class="s0">def </span><span class="s1">var(self</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">w):</span>
        <span class="s1">p = p - </span><span class="s3">1</span>
        <span class="s1">dispersion_factor = (</span><span class="s3">1 </span><span class="s1">+ alpha * mu ** p) ** </span><span class="s3">2 </span><span class="s1">+ w * mu</span>
        <span class="s1">var = (dispersion_factor * self.mean(mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">w))</span>
        <span class="s0">return </span><span class="s1">var</span>


<span class="s1">zigenpoisson = zigeneralizedpoisson_gen(</span>
    <span class="s1">name=</span><span class="s4">'zigenpoisson'</span><span class="s0">,</span>
    <span class="s1">longname=</span><span class="s4">'Zero Inflated Generalized Poisson'</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">zinegativebinomial_gen(rv_discrete):</span>
    <span class="s2">'''Zero Inflated Generalized Negative Binomial distribution 
    '''</span>
    <span class="s0">def </span><span class="s1">_argcheck(self</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">w):</span>
        <span class="s0">return </span><span class="s1">(mu &gt; </span><span class="s3">0</span><span class="s1">) &amp; (w &gt;= </span><span class="s3">0</span><span class="s1">) &amp; (w&lt;=</span><span class="s3">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_logpmf(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">w):</span>
        <span class="s1">s</span><span class="s0">, </span><span class="s1">p = self.convert_params(mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p)</span>
        <span class="s0">return </span><span class="s1">_lazywhere(x != </span><span class="s3">0</span><span class="s0">, </span><span class="s1">(x</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">w)</span><span class="s0">,</span>
                          <span class="s1">(</span><span class="s0">lambda </span><span class="s1">x</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">w: np.log(</span><span class="s3">1. </span><span class="s1">- w) +</span>
                          <span class="s1">nbinom.logpmf(x</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">p))</span><span class="s0">,</span>
                          <span class="s1">np.log(w + (</span><span class="s3">1. </span><span class="s1">- w) *</span>
                          <span class="s1">nbinom.pmf(x</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">p)))</span>

    <span class="s0">def </span><span class="s1">_pmf(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">w):</span>
        <span class="s0">return </span><span class="s1">np.exp(self._logpmf(x</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">w))</span>

    <span class="s0">def </span><span class="s1">_cdf(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">w):</span>
        <span class="s1">s</span><span class="s0">, </span><span class="s1">p = self.convert_params(mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p)</span>
        <span class="s5"># construct cdf from standard negative binomial cdf</span>
        <span class="s5"># and the w inflation of zero</span>
        <span class="s0">return </span><span class="s1">w + nbinom.cdf(x</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">p) * (</span><span class="s3">1 </span><span class="s1">- w)</span>

    <span class="s0">def </span><span class="s1">_ppf(self</span><span class="s0">, </span><span class="s1">q</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">w):</span>
        <span class="s1">s</span><span class="s0">, </span><span class="s1">p = self.convert_params(mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p)</span>
        <span class="s5"># we just translated and stretched q to remove zi</span>
        <span class="s1">q_mod = (q - w) / (</span><span class="s3">1 </span><span class="s1">- w)</span>
        <span class="s1">x = nbinom.ppf(q_mod</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">p)</span>
        <span class="s5"># set to zero if in the zi range</span>
        <span class="s1">x[q &lt; w] = </span><span class="s3">0</span>
        <span class="s0">return </span><span class="s1">x</span>

    <span class="s0">def </span><span class="s1">mean(self</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">w):</span>
        <span class="s0">return </span><span class="s1">(</span><span class="s3">1 </span><span class="s1">- w) * mu</span>

    <span class="s0">def </span><span class="s1">var(self</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">w):</span>
        <span class="s1">dispersion_factor = </span><span class="s3">1 </span><span class="s1">+ alpha * mu ** (p - </span><span class="s3">1</span><span class="s1">) + w * mu</span>
        <span class="s1">var = (dispersion_factor * self.mean(mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">w))</span>
        <span class="s0">return </span><span class="s1">var</span>

    <span class="s0">def </span><span class="s1">_moment(self</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">w):</span>
        <span class="s1">s</span><span class="s0">, </span><span class="s1">p = self.convert_params(mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p)</span>
        <span class="s0">return </span><span class="s1">(</span><span class="s3">1 </span><span class="s1">- w) * nbinom.moment(n</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">p)</span>

    <span class="s0">def </span><span class="s1">convert_params(self</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p):</span>
        <span class="s1">size = </span><span class="s3">1. </span><span class="s1">/ alpha * mu**(</span><span class="s3">2</span><span class="s1">-p)</span>
        <span class="s1">prob = size / (size + mu)</span>
        <span class="s0">return </span><span class="s1">(size</span><span class="s0">, </span><span class="s1">prob)</span>

<span class="s1">zinegbin = zinegativebinomial_gen(name=</span><span class="s4">'zinegbin'</span><span class="s0">,</span>
    <span class="s1">longname=</span><span class="s4">'Zero Inflated Generalized Negative Binomial'</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">truncatedpoisson_gen(rv_discrete):</span>
    <span class="s2">'''Truncated Poisson discrete random variable 
    '''</span>
    <span class="s5"># TODO: need cdf, and rvs</span>

    <span class="s0">def </span><span class="s1">_argcheck(self</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">truncation):</span>
        <span class="s5"># this does not work</span>
        <span class="s5"># vector bound breaks some generic methods</span>
        <span class="s5"># self.a = truncation + 1 # max(truncation + 1, 0)</span>
        <span class="s0">return </span><span class="s1">(mu &gt;= </span><span class="s3">0</span><span class="s1">) &amp; (truncation &gt;= -</span><span class="s3">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_get_support(self</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">truncation):</span>
        <span class="s0">return </span><span class="s1">truncation + </span><span class="s3">1</span><span class="s0">, </span><span class="s1">self.b</span>

    <span class="s0">def </span><span class="s1">_logpmf(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">truncation):</span>
        <span class="s1">pmf = </span><span class="s3">0</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(int(np.max(truncation)) + </span><span class="s3">1</span><span class="s1">):</span>
            <span class="s1">pmf += poisson.pmf(i</span><span class="s0">, </span><span class="s1">mu)</span>

        <span class="s1">logpmf_ = poisson.logpmf(x</span><span class="s0">, </span><span class="s1">mu) - np.log(</span><span class="s3">1 </span><span class="s1">- pmf)</span>
        <span class="s5">#logpmf_[x &lt; truncation + 1] = - np.inf</span>
        <span class="s0">return </span><span class="s1">logpmf_</span>

    <span class="s0">def </span><span class="s1">_pmf(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">truncation):</span>
        <span class="s0">return </span><span class="s1">np.exp(self._logpmf(x</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">truncation))</span>

<span class="s1">truncatedpoisson = truncatedpoisson_gen(name=</span><span class="s4">'truncatedpoisson'</span><span class="s0">,</span>
                                        <span class="s1">longname=</span><span class="s4">'Truncated Poisson'</span><span class="s1">)</span>

<span class="s0">class </span><span class="s1">truncatednegbin_gen(rv_discrete):</span>
    <span class="s2">'''Truncated Generalized Negative Binomial (NB-P) discrete random variable 
    '''</span>
    <span class="s0">def </span><span class="s1">_argcheck(self</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">truncation):</span>
        <span class="s0">return </span><span class="s1">(mu &gt;= </span><span class="s3">0</span><span class="s1">) &amp; (truncation &gt;= -</span><span class="s3">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_get_support(self</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">truncation):</span>
        <span class="s0">return </span><span class="s1">truncation + </span><span class="s3">1</span><span class="s0">, </span><span class="s1">self.b</span>

    <span class="s0">def </span><span class="s1">_logpmf(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">truncation):</span>
        <span class="s1">size</span><span class="s0">, </span><span class="s1">prob = self.convert_params(mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p)</span>
        <span class="s1">pmf = </span><span class="s3">0</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(int(np.max(truncation)) + </span><span class="s3">1</span><span class="s1">):</span>
            <span class="s1">pmf += nbinom.pmf(i</span><span class="s0">, </span><span class="s1">size</span><span class="s0">, </span><span class="s1">prob)</span>

        <span class="s1">logpmf_ = nbinom.logpmf(x</span><span class="s0">, </span><span class="s1">size</span><span class="s0">, </span><span class="s1">prob) - np.log(</span><span class="s3">1 </span><span class="s1">- pmf)</span>
        <span class="s5"># logpmf_[x &lt; truncation + 1] = - np.inf</span>
        <span class="s0">return </span><span class="s1">logpmf_</span>

    <span class="s0">def </span><span class="s1">_pmf(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">truncation):</span>
        <span class="s0">return </span><span class="s1">np.exp(self._logpmf(x</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">truncation))</span>

    <span class="s0">def </span><span class="s1">convert_params(self</span><span class="s0">, </span><span class="s1">mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p):</span>
        <span class="s1">size = </span><span class="s3">1. </span><span class="s1">/ alpha * mu**(</span><span class="s3">2</span><span class="s1">-p)</span>
        <span class="s1">prob = size / (size + mu)</span>
        <span class="s0">return </span><span class="s1">(size</span><span class="s0">, </span><span class="s1">prob)</span>

<span class="s1">truncatednegbin = truncatednegbin_gen(name=</span><span class="s4">'truncatednegbin'</span><span class="s0">,</span>
    <span class="s1">longname=</span><span class="s4">'Truncated Generalized Negative Binomial'</span><span class="s1">)</span>

<span class="s0">class </span><span class="s1">DiscretizedCount(rv_discrete):</span>
    <span class="s2">&quot;&quot;&quot;Count distribution based on discretized distribution 
 
    Parameters 
    ---------- 
    distr : distribution instance 
    d_offset : float 
        Offset for integer interval, default is zero. 
        The discrete random variable is ``y = floor(x + offset)`` where x is 
        the continuous random variable. 
        Warning: not verified for all methods. 
    add_scale : bool 
        If True (default), then the scale of the base distribution is added 
        as parameter for the discrete distribution. The scale parameter is in 
        the last position. 
    kwds : keyword arguments 
        The extra keyword arguments are used delegated to the ``__init__`` of 
        the super class. 
        Their usage has not been checked, e.g. currently the support of the 
        distribution is assumed to be all non-negative integers. 
 
    Notes 
    ----- 
    `loc` argument is currently not supported, scale is not available for 
    discrete distributions in scipy. The scale parameter of the underlying 
    continuous distribution is the last shape parameter in this 
    DiscretizedCount distribution if ``add_scale`` is True. 
 
    The implementation was based mainly on [1]_ and [2]_. However, many new 
    discrete distributions have been developed based on the approach that we 
    use here. Note, that in many cases authors reparameterize the distribution, 
    while this class inherits the parameterization from the underlying 
    continuous distribution. 
 
    References 
    ---------- 
    .. [1] Chakraborty, Subrata, and Dhrubajyoti Chakravarty. &quot;Discrete gamma 
       distributions: Properties and parameter estimations.&quot; Communications in 
       Statistics-Theory and Methods 41, no. 18 (2012): 3301-3324. 
 
    .. [2] Alzaatreh, Ayman, Carl Lee, and Felix Famoye. 2012. “On the Discrete 
       Analogues of Continuous Distributions.” Statistical Methodology 9 (6): 
       589–603. 
 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__new__(cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwds):</span>
        <span class="s5"># rv_discrete.__new__ does not allow `kwds`, skip it</span>
        <span class="s5"># only does dispatch to multinomial</span>
        <span class="s0">return </span><span class="s1">super(rv_discrete</span><span class="s0">, </span><span class="s1">cls).__new__(cls)</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">distr</span><span class="s0">, </span><span class="s1">d_offset=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">add_scale=</span><span class="s0">True, </span><span class="s1">**kwds):</span>
        <span class="s5"># kwds are extras in rv_discrete</span>
        <span class="s1">self.distr = distr</span>
        <span class="s1">self.d_offset = d_offset</span>
        <span class="s1">self._ctor_param = distr._ctor_param</span>
        <span class="s1">self.add_scale = add_scale</span>
        <span class="s0">if </span><span class="s1">distr.shapes </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.k_shapes = len(distr.shapes.split(</span><span class="s4">&quot;,&quot;</span><span class="s1">))</span>
            <span class="s0">if </span><span class="s1">add_scale:</span>
                <span class="s1">kwds.update({</span><span class="s4">&quot;shapes&quot;</span><span class="s1">: distr.shapes + </span><span class="s4">&quot;, s&quot;</span><span class="s1">})</span>
                <span class="s1">self.k_shapes += </span><span class="s3">1</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s5"># no shape parameters in underlying distribution</span>
            <span class="s0">if </span><span class="s1">add_scale:</span>
                <span class="s1">kwds.update({</span><span class="s4">&quot;shapes&quot;</span><span class="s1">: </span><span class="s4">&quot;s&quot;</span><span class="s1">})</span>
                <span class="s1">self.k_shapes = </span><span class="s3">1</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.k_shapes = </span><span class="s3">0</span>

        <span class="s1">super().__init__(**kwds)</span>

    <span class="s0">def </span><span class="s1">_updated_ctor_param(self):</span>
        <span class="s1">dic = super()._updated_ctor_param()</span>
        <span class="s1">dic[</span><span class="s4">&quot;distr&quot;</span><span class="s1">] = self.distr</span>
        <span class="s0">return </span><span class="s1">dic</span>

    <span class="s0">def </span><span class="s1">_unpack_args(self</span><span class="s0">, </span><span class="s1">args):</span>
        <span class="s0">if </span><span class="s1">self.add_scale:</span>
            <span class="s1">scale = args[-</span><span class="s3">1</span><span class="s1">]</span>
            <span class="s1">args = args[:-</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">scale = </span><span class="s3">1</span>
        <span class="s0">return </span><span class="s1">args</span><span class="s0">, </span><span class="s1">scale</span>

    <span class="s0">def </span><span class="s1">_rvs(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">size=</span><span class="s0">None, </span><span class="s1">random_state=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">args</span><span class="s0">, </span><span class="s1">scale = self._unpack_args(args)</span>
        <span class="s0">if </span><span class="s1">size </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">size = getattr(self</span><span class="s0">, </span><span class="s4">&quot;_size&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">rv = np.trunc(self.distr.rvs(*args</span><span class="s0">, </span><span class="s1">scale=scale</span><span class="s0">, </span><span class="s1">size=size</span><span class="s0">,</span>
                                     <span class="s1">random_state=random_state) +</span>
                      <span class="s1">self.d_offset)</span>
        <span class="s0">return </span><span class="s1">rv</span>

    <span class="s0">def </span><span class="s1">_pmf(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">*args):</span>
        <span class="s1">distr = self.distr</span>
        <span class="s0">if </span><span class="s1">self.d_offset != </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">x = x + self.d_offset</span>

        <span class="s1">args</span><span class="s0">, </span><span class="s1">scale = self._unpack_args(args)</span>

        <span class="s1">p = (distr.sf(x</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">scale=scale) -</span>
             <span class="s1">distr.sf(x + </span><span class="s3">1</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">scale=scale))</span>
        <span class="s0">return </span><span class="s1">p</span>

    <span class="s0">def </span><span class="s1">_cdf(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">*args):</span>
        <span class="s1">distr = self.distr</span>
        <span class="s1">args</span><span class="s0">, </span><span class="s1">scale = self._unpack_args(args)</span>
        <span class="s0">if </span><span class="s1">self.d_offset != </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">x = x + self.d_offset</span>
        <span class="s1">p = distr.cdf(x + </span><span class="s3">1</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">scale=scale)</span>
        <span class="s0">return </span><span class="s1">p</span>

    <span class="s0">def </span><span class="s1">_sf(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">*args):</span>
        <span class="s1">distr = self.distr</span>
        <span class="s1">args</span><span class="s0">, </span><span class="s1">scale = self._unpack_args(args)</span>
        <span class="s0">if </span><span class="s1">self.d_offset != </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">x = x + self.d_offset</span>
        <span class="s1">p = distr.sf(x + </span><span class="s3">1</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">scale=scale)</span>
        <span class="s0">return </span><span class="s1">p</span>

    <span class="s0">def </span><span class="s1">_ppf(self</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">*args):</span>
        <span class="s1">distr = self.distr</span>
        <span class="s1">args</span><span class="s0">, </span><span class="s1">scale = self._unpack_args(args)</span>

        <span class="s1">qc = distr.ppf(p</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">scale=scale)</span>
        <span class="s0">if </span><span class="s1">self.d_offset != </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">qc = qc + self.d_offset</span>
        <span class="s1">q = np.floor(qc * (</span><span class="s3">1 </span><span class="s1">- </span><span class="s3">1e-15</span><span class="s1">))</span>
        <span class="s0">return </span><span class="s1">q</span>

    <span class="s0">def </span><span class="s1">_isf(self</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">*args):</span>
        <span class="s1">distr = self.distr</span>
        <span class="s1">args</span><span class="s0">, </span><span class="s1">scale = self._unpack_args(args)</span>

        <span class="s1">qc = distr.isf(p</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">scale=scale)</span>
        <span class="s0">if </span><span class="s1">self.d_offset != </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">qc = qc + self.d_offset</span>
        <span class="s1">q = np.floor(qc * (</span><span class="s3">1 </span><span class="s1">- </span><span class="s3">1e-15</span><span class="s1">))</span>
        <span class="s0">return </span><span class="s1">q</span>


<span class="s0">class </span><span class="s1">DiscretizedModel(GenericLikelihoodModel):</span>
    <span class="s2">&quot;&quot;&quot;experimental model to fit discretized distribution 
 
    Count models based on discretized distributions can be used to model 
    data that is under- or over-dispersed relative to Poisson or that has 
    heavier tails. 
 
    Parameters 
    ---------- 
    endog : array_like, 1-D 
        Univariate data for fitting the distribution. 
    exog : None 
        Explanatory variables are not supported. The ``exog`` argument is 
        only included for consistency in the signature across models. 
    distr : DiscretizedCount instance 
        (required) Instance of a DiscretizedCount distribution. 
 
    See Also 
    -------- 
    DiscretizedCount 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; from statsmodels.distributions.discrete import ( 
            DiscretizedCount, DiscretizedModel) 
 
    &gt;&gt;&gt; dd = DiscretizedCount(stats.gamma) 
    &gt;&gt;&gt; mod = DiscretizedModel(y, distr=dd) 
    &gt;&gt;&gt; res = mod.fit() 
    &gt;&gt;&gt; probs = res.predict(which=&quot;probs&quot;, k_max=5) 
 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">endog</span><span class="s0">, </span><span class="s1">exog=</span><span class="s0">None, </span><span class="s1">distr=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">exog </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;exog is not supported&quot;</span><span class="s1">)</span>

        <span class="s1">super().__init__(endog</span><span class="s0">, </span><span class="s1">exog</span><span class="s0">, </span><span class="s1">distr=distr)</span>
        <span class="s1">self._init_keys.append(</span><span class="s4">'distr'</span><span class="s1">)</span>
        <span class="s1">self.df_resid = len(endog) - distr.k_shapes</span>
        <span class="s1">self.df_model = </span><span class="s3">0</span>
        <span class="s1">self.k_extra = distr.k_shapes  </span><span class="s5"># no constant subtracted</span>
        <span class="s1">self.k_constant = </span><span class="s3">0</span>
        <span class="s1">self.nparams = distr.k_shapes  </span><span class="s5"># needed for start_params</span>
        <span class="s1">self.start_params = </span><span class="s3">0.5 </span><span class="s1">* np.ones(self.nparams)</span>

    <span class="s0">def </span><span class="s1">loglike(self</span><span class="s0">, </span><span class="s1">params):</span>

        <span class="s5"># this does not allow exog yet,</span>
        <span class="s5"># model `params` are also distribution `args`</span>
        <span class="s5"># For regression model this needs to be replaced by a conversion method</span>
        <span class="s1">args = params</span>
        <span class="s1">ll = np.log(self.distr._pmf(self.endog</span><span class="s0">, </span><span class="s1">*args))</span>
        <span class="s0">return </span><span class="s1">ll.sum()</span>

    <span class="s0">def </span><span class="s1">predict(self</span><span class="s0">, </span><span class="s1">params</span><span class="s0">, </span><span class="s1">exog=</span><span class="s0">None, </span><span class="s1">which=</span><span class="s0">None, </span><span class="s1">k_max=</span><span class="s3">20</span><span class="s1">):</span>

        <span class="s0">if </span><span class="s1">exog </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;exog is not supported&quot;</span><span class="s1">)</span>

        <span class="s1">args = params</span>
        <span class="s0">if </span><span class="s1">which == </span><span class="s4">&quot;probs&quot;</span><span class="s1">:</span>
            <span class="s1">pr = self.distr.pmf(np.arange(k_max)</span><span class="s0">, </span><span class="s1">*args)</span>
            <span class="s0">return </span><span class="s1">pr</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">'only which=&quot;probs&quot; is currently implemented'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_distr(self</span><span class="s0">, </span><span class="s1">params):</span>
        <span class="s2">&quot;&quot;&quot;frozen distribution instance of the discrete distribution. 
        &quot;&quot;&quot;</span>
        <span class="s1">args = params</span>
        <span class="s1">distr = self.distr(*args)</span>
        <span class="s0">return </span><span class="s1">distr</span>
</pre>
</body>
</html>