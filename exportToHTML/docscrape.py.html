<html>
<head>
<title>docscrape.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
docscrape.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Extract reference documentation from the NumPy source tree. 
 
Copyright (C) 2008 Stefan van der Walt &lt;stefan@mentat.za.net&gt;, Pauli Virtanen &lt;pav@iki.fi&gt; 
 
Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are 
met: 
 
 1. Redistributions of source code must retain the above copyright 
    notice, this list of conditions and the following disclaimer. 
 2. Redistributions in binary form must reproduce the above copyright 
    notice, this list of conditions and the following disclaimer in 
    the documentation and/or other materials provided with the 
    distribution. 
 
THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR 
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, 
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE. 
 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">inspect</span>
<span class="s2">import </span><span class="s1">textwrap</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">pydoc</span>
<span class="s2">from </span><span class="s1">warnings </span><span class="s2">import </span><span class="s1">warn</span>
<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">namedtuple</span>
<span class="s2">from </span><span class="s1">collections.abc </span><span class="s2">import </span><span class="s1">Callable</span><span class="s2">, </span><span class="s1">Mapping</span>
<span class="s2">import </span><span class="s1">copy</span>
<span class="s2">import </span><span class="s1">sys</span>


<span class="s2">def </span><span class="s1">strip_blank_lines(l):</span>
    <span class="s0">&quot;Remove leading and trailing blank lines from a list of lines&quot;</span>
    <span class="s2">while </span><span class="s1">l </span><span class="s2">and not </span><span class="s1">l[</span><span class="s3">0</span><span class="s1">].strip():</span>
        <span class="s2">del </span><span class="s1">l[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s2">while </span><span class="s1">l </span><span class="s2">and not </span><span class="s1">l[-</span><span class="s3">1</span><span class="s1">].strip():</span>
        <span class="s2">del </span><span class="s1">l[-</span><span class="s3">1</span><span class="s1">]</span>
    <span class="s2">return </span><span class="s1">l</span>


<span class="s2">class </span><span class="s1">Reader:</span>
    <span class="s0">&quot;&quot;&quot;A line-based string reader. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        data : str 
           String with lines separated by '\n'. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(data</span><span class="s2">, </span><span class="s1">list):</span>
            <span class="s1">self._str = data</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._str = data.split(</span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s1">)  </span><span class="s5"># store string as list of lines</span>

        <span class="s1">self.reset()</span>

    <span class="s2">def </span><span class="s1">__getitem__(self</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s2">return </span><span class="s1">self._str[n]</span>

    <span class="s2">def </span><span class="s1">reset(self):</span>
        <span class="s1">self._l = </span><span class="s3">0  </span><span class="s5"># current line nr</span>

    <span class="s2">def </span><span class="s1">read(self):</span>
        <span class="s2">if not </span><span class="s1">self.eof():</span>
            <span class="s1">out = self[self._l]</span>
            <span class="s1">self._l += </span><span class="s3">1</span>
            <span class="s2">return </span><span class="s1">out</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s4">''</span>

    <span class="s2">def </span><span class="s1">seek_next_non_empty_line(self):</span>
        <span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">self[self._l:]:</span>
            <span class="s2">if </span><span class="s1">l.strip():</span>
                <span class="s2">break</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self._l += </span><span class="s3">1</span>

    <span class="s2">def </span><span class="s1">eof(self):</span>
        <span class="s2">return </span><span class="s1">self._l &gt;= len(self._str)</span>

    <span class="s2">def </span><span class="s1">read_to_condition(self</span><span class="s2">, </span><span class="s1">condition_func):</span>
        <span class="s1">start = self._l</span>
        <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">self[start:]:</span>
            <span class="s2">if </span><span class="s1">condition_func(line):</span>
                <span class="s2">return </span><span class="s1">self[start:self._l]</span>
            <span class="s1">self._l += </span><span class="s3">1</span>
            <span class="s2">if </span><span class="s1">self.eof():</span>
                <span class="s2">return </span><span class="s1">self[start:self._l+</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">read_to_next_empty_line(self):</span>
        <span class="s1">self.seek_next_non_empty_line()</span>

        <span class="s2">def </span><span class="s1">is_empty(line):</span>
            <span class="s2">return not </span><span class="s1">line.strip()</span>

        <span class="s2">return </span><span class="s1">self.read_to_condition(is_empty)</span>

    <span class="s2">def </span><span class="s1">read_to_next_unindented_line(self):</span>
        <span class="s2">def </span><span class="s1">is_unindented(line):</span>
            <span class="s2">return </span><span class="s1">(line.strip() </span><span class="s2">and </span><span class="s1">(len(line.lstrip()) == len(line)))</span>
        <span class="s2">return </span><span class="s1">self.read_to_condition(is_unindented)</span>

    <span class="s2">def </span><span class="s1">peek(self</span><span class="s2">, </span><span class="s1">n=</span><span class="s3">0</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">self._l + n &lt; len(self._str):</span>
            <span class="s2">return </span><span class="s1">self[self._l + n]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s4">''</span>

    <span class="s2">def </span><span class="s1">is_empty(self):</span>
        <span class="s2">return not </span><span class="s4">''</span><span class="s1">.join(self._str).strip()</span>


<span class="s2">class </span><span class="s1">ParseError(Exception):</span>
    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s1">message = self.args[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s4">'docstring'</span><span class="s1">):</span>
            <span class="s1">message = </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">message</span><span class="s2">} </span><span class="s4">in </span><span class="s2">{</span><span class="s1">self.docstring</span><span class="s2">!r}</span><span class="s4">&quot;</span>
        <span class="s2">return </span><span class="s1">message</span>


<span class="s1">Parameter = namedtuple(</span><span class="s4">'Parameter'</span><span class="s2">, </span><span class="s1">[</span><span class="s4">'name'</span><span class="s2">, </span><span class="s4">'type'</span><span class="s2">, </span><span class="s4">'desc'</span><span class="s1">])</span>


<span class="s2">class </span><span class="s1">NumpyDocString(Mapping):</span>
    <span class="s0">&quot;&quot;&quot;Parses a numpydoc string to an abstract representation 
 
    Instances define a mapping from section title to structured data. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">sections = {</span>
        <span class="s4">'Signature'</span><span class="s1">: </span><span class="s4">''</span><span class="s2">,</span>
        <span class="s4">'Summary'</span><span class="s1">: [</span><span class="s4">''</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s4">'Extended Summary'</span><span class="s1">: []</span><span class="s2">,</span>
        <span class="s4">'Parameters'</span><span class="s1">: []</span><span class="s2">,</span>
        <span class="s4">'Returns'</span><span class="s1">: []</span><span class="s2">,</span>
        <span class="s4">'Yields'</span><span class="s1">: []</span><span class="s2">,</span>
        <span class="s4">'Receives'</span><span class="s1">: []</span><span class="s2">,</span>
        <span class="s4">'Raises'</span><span class="s1">: []</span><span class="s2">,</span>
        <span class="s4">'Warns'</span><span class="s1">: []</span><span class="s2">,</span>
        <span class="s4">'Other Parameters'</span><span class="s1">: []</span><span class="s2">,</span>
        <span class="s4">'Attributes'</span><span class="s1">: []</span><span class="s2">,</span>
        <span class="s4">'Methods'</span><span class="s1">: []</span><span class="s2">,</span>
        <span class="s4">'See Also'</span><span class="s1">: []</span><span class="s2">,</span>
        <span class="s4">'Notes'</span><span class="s1">: []</span><span class="s2">,</span>
        <span class="s4">'Warnings'</span><span class="s1">: []</span><span class="s2">,</span>
        <span class="s4">'References'</span><span class="s1">: </span><span class="s4">''</span><span class="s2">,</span>
        <span class="s4">'Examples'</span><span class="s1">: </span><span class="s4">''</span><span class="s2">,</span>
        <span class="s4">'index'</span><span class="s1">: {}</span>
    <span class="s1">}</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">docstring</span><span class="s2">, </span><span class="s1">config={}):</span>
        <span class="s1">orig_docstring = docstring</span>
        <span class="s1">docstring = textwrap.dedent(docstring).split(</span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s1">)</span>

        <span class="s1">self._doc = Reader(docstring)</span>
        <span class="s1">self._parsed_data = copy.deepcopy(self.sections)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self._parse()</span>
        <span class="s2">except </span><span class="s1">ParseError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s1">e.docstring = orig_docstring</span>
            <span class="s2">raise</span>

    <span class="s2">def </span><span class="s1">__getitem__(self</span><span class="s2">, </span><span class="s1">key):</span>
        <span class="s2">return </span><span class="s1">self._parsed_data[key]</span>

    <span class="s2">def </span><span class="s1">__setitem__(self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">val):</span>
        <span class="s2">if </span><span class="s1">key </span><span class="s2">not in </span><span class="s1">self._parsed_data:</span>
            <span class="s1">self._error_location(</span><span class="s4">f&quot;Unknown section </span><span class="s2">{</span><span class="s1">key</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s2">, </span><span class="s1">error=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._parsed_data[key] = val</span>

    <span class="s2">def </span><span class="s1">__iter__(self):</span>
        <span class="s2">return </span><span class="s1">iter(self._parsed_data)</span>

    <span class="s2">def </span><span class="s1">__len__(self):</span>
        <span class="s2">return </span><span class="s1">len(self._parsed_data)</span>

    <span class="s2">def </span><span class="s1">_is_at_section(self):</span>
        <span class="s1">self._doc.seek_next_non_empty_line()</span>

        <span class="s2">if </span><span class="s1">self._doc.eof():</span>
            <span class="s2">return False</span>

        <span class="s1">l1 = self._doc.peek().strip()  </span><span class="s5"># e.g. Parameters</span>

        <span class="s2">if </span><span class="s1">l1.startswith(</span><span class="s4">'.. index::'</span><span class="s1">):</span>
            <span class="s2">return True</span>

        <span class="s1">l2 = self._doc.peek(</span><span class="s3">1</span><span class="s1">).strip()  </span><span class="s5"># ---------- or ==========</span>
        <span class="s2">return </span><span class="s1">l2.startswith(</span><span class="s4">'-'</span><span class="s1">*len(l1)) </span><span class="s2">or </span><span class="s1">l2.startswith(</span><span class="s4">'='</span><span class="s1">*len(l1))</span>

    <span class="s2">def </span><span class="s1">_strip(self</span><span class="s2">, </span><span class="s1">doc):</span>
        <span class="s1">i = </span><span class="s3">0</span>
        <span class="s1">j = </span><span class="s3">0</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">line </span><span class="s2">in </span><span class="s1">enumerate(doc):</span>
            <span class="s2">if </span><span class="s1">line.strip():</span>
                <span class="s2">break</span>

        <span class="s2">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">line </span><span class="s2">in </span><span class="s1">enumerate(doc[::-</span><span class="s3">1</span><span class="s1">]):</span>
            <span class="s2">if </span><span class="s1">line.strip():</span>
                <span class="s2">break</span>

        <span class="s2">return </span><span class="s1">doc[i:len(doc)-j]</span>

    <span class="s2">def </span><span class="s1">_read_to_next_section(self):</span>
        <span class="s1">section = self._doc.read_to_next_empty_line()</span>

        <span class="s2">while not </span><span class="s1">self._is_at_section() </span><span class="s2">and not </span><span class="s1">self._doc.eof():</span>
            <span class="s2">if not </span><span class="s1">self._doc.peek(-</span><span class="s3">1</span><span class="s1">).strip():  </span><span class="s5"># previous line was empty</span>
                <span class="s1">section += [</span><span class="s4">''</span><span class="s1">]</span>

            <span class="s1">section += self._doc.read_to_next_empty_line()</span>

        <span class="s2">return </span><span class="s1">section</span>

    <span class="s2">def </span><span class="s1">_read_sections(self):</span>
        <span class="s2">while not </span><span class="s1">self._doc.eof():</span>
            <span class="s1">data = self._read_to_next_section()</span>
            <span class="s1">name = data[</span><span class="s3">0</span><span class="s1">].strip()</span>

            <span class="s2">if </span><span class="s1">name.startswith(</span><span class="s4">'..'</span><span class="s1">):  </span><span class="s5"># index section</span>
                <span class="s2">yield </span><span class="s1">name</span><span class="s2">, </span><span class="s1">data[</span><span class="s3">1</span><span class="s1">:]</span>
            <span class="s2">elif </span><span class="s1">len(data) &lt; </span><span class="s3">2</span><span class="s1">:</span>
                <span class="s2">yield </span><span class="s1">StopIteration</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">yield </span><span class="s1">name</span><span class="s2">, </span><span class="s1">self._strip(data[</span><span class="s3">2</span><span class="s1">:])</span>

    <span class="s2">def </span><span class="s1">_parse_param_list(self</span><span class="s2">, </span><span class="s1">content</span><span class="s2">, </span><span class="s1">single_element_is_type=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">r = Reader(content)</span>
        <span class="s1">params = []</span>
        <span class="s2">while not </span><span class="s1">r.eof():</span>
            <span class="s1">header = r.read().strip()</span>
            <span class="s2">if </span><span class="s4">' : ' </span><span class="s2">in </span><span class="s1">header:</span>
                <span class="s1">arg_name</span><span class="s2">, </span><span class="s1">arg_type = header.split(</span><span class="s4">' : '</span><span class="s1">)[:</span><span class="s3">2</span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">single_element_is_type:</span>
                    <span class="s1">arg_name</span><span class="s2">, </span><span class="s1">arg_type = </span><span class="s4">''</span><span class="s2">, </span><span class="s1">header</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">arg_name</span><span class="s2">, </span><span class="s1">arg_type = header</span><span class="s2">, </span><span class="s4">''</span>

            <span class="s1">desc = r.read_to_next_unindented_line()</span>
            <span class="s1">desc = dedent_lines(desc)</span>
            <span class="s1">desc = strip_blank_lines(desc)</span>

            <span class="s1">params.append(Parameter(arg_name</span><span class="s2">, </span><span class="s1">arg_type</span><span class="s2">, </span><span class="s1">desc))</span>

        <span class="s2">return </span><span class="s1">params</span>

    <span class="s5"># See also supports the following formats.</span>
    <span class="s5">#</span>
    <span class="s5"># &lt;FUNCNAME&gt;</span>
    <span class="s5"># &lt;FUNCNAME&gt; SPACE* COLON SPACE+ &lt;DESC&gt; SPACE*</span>
    <span class="s5"># &lt;FUNCNAME&gt; ( COMMA SPACE+ &lt;FUNCNAME&gt;)+ (COMMA | PERIOD)? SPACE*</span>
    <span class="s5"># &lt;FUNCNAME&gt; ( COMMA SPACE+ &lt;FUNCNAME&gt;)* SPACE* COLON SPACE+ &lt;DESC&gt; SPACE*</span>

    <span class="s5"># &lt;FUNCNAME&gt; is one of</span>
    <span class="s5">#   &lt;PLAIN_FUNCNAME&gt;</span>
    <span class="s5">#   COLON &lt;ROLE&gt; COLON BACKTICK &lt;PLAIN_FUNCNAME&gt; BACKTICK</span>
    <span class="s5"># where</span>
    <span class="s5">#   &lt;PLAIN_FUNCNAME&gt; is a legal function name, and</span>
    <span class="s5">#   &lt;ROLE&gt; is any nonempty sequence of word characters.</span>
    <span class="s5"># Examples: func_f1  :meth:`func_h1` :obj:`~baz.obj_r` :class:`class_j`</span>
    <span class="s5"># &lt;DESC&gt; is a string describing the function.</span>

    <span class="s1">_role = </span><span class="s4">r&quot;:(?P&lt;role&gt;\w+):&quot;</span>
    <span class="s1">_funcbacktick = </span><span class="s4">r&quot;`(?P&lt;name&gt;(?:~\w+\.)?[a-zA-Z0-9_\.-]+)`&quot;</span>
    <span class="s1">_funcplain = </span><span class="s4">r&quot;(?P&lt;name2&gt;[a-zA-Z0-9_\.-]+)&quot;</span>
    <span class="s1">_funcname = </span><span class="s4">r&quot;(&quot; </span><span class="s1">+ _role + _funcbacktick + </span><span class="s4">r&quot;|&quot; </span><span class="s1">+ _funcplain + </span><span class="s4">r&quot;)&quot;</span>
    <span class="s1">_funcnamenext = _funcname.replace(</span><span class="s4">'role'</span><span class="s2">, </span><span class="s4">'rolenext'</span><span class="s1">)</span>
    <span class="s1">_funcnamenext = _funcnamenext.replace(</span><span class="s4">'name'</span><span class="s2">, </span><span class="s4">'namenext'</span><span class="s1">)</span>
    <span class="s1">_description = </span><span class="s4">r&quot;(?P&lt;description&gt;\s*:(\s+(?P&lt;desc&gt;\S+.*))?)?\s*$&quot;</span>
    <span class="s1">_func_rgx = re.compile(</span><span class="s4">r&quot;^\s*&quot; </span><span class="s1">+ _funcname + </span><span class="s4">r&quot;\s*&quot;</span><span class="s1">)</span>
    <span class="s1">_line_rgx = re.compile(</span>
        <span class="s4">r&quot;^\s*&quot; </span><span class="s1">+</span>
        <span class="s4">r&quot;(?P&lt;allfuncs&gt;&quot; </span><span class="s1">+        </span><span class="s5"># group for all function names</span>
        <span class="s1">_funcname +</span>
        <span class="s4">r&quot;(?P&lt;morefuncs&gt;([,]\s+&quot; </span><span class="s1">+ _funcnamenext + </span><span class="s4">r&quot;)*)&quot; </span><span class="s1">+</span>
        <span class="s4">r&quot;)&quot; </span><span class="s1">+                     </span><span class="s5"># end of &quot;allfuncs&quot;</span>
        <span class="s4">r&quot;(?P&lt;trailing&gt;[,\.])?&quot; </span><span class="s1">+   </span><span class="s5"># Some function lists have a trailing comma (or period)  '\s*'</span>
        <span class="s1">_description)</span>

    <span class="s5"># Empty &lt;DESC&gt; elements are replaced with '..'</span>
    <span class="s1">empty_description = </span><span class="s4">'..'</span>

    <span class="s2">def </span><span class="s1">_parse_see_also(self</span><span class="s2">, </span><span class="s1">content):</span>
        <span class="s0">&quot;&quot;&quot; 
        func_name : Descriptive text 
            continued text 
        another_func_name : Descriptive text 
        func_name1, func_name2, :meth:`func_name`, func_name3 
 
        &quot;&quot;&quot;</span>

        <span class="s1">items = []</span>

        <span class="s2">def </span><span class="s1">parse_item_name(text):</span>
            <span class="s0">&quot;&quot;&quot;Match ':role:`name`' or 'name'.&quot;&quot;&quot;</span>
            <span class="s1">m = self._func_rgx.match(text)</span>
            <span class="s2">if not </span><span class="s1">m:</span>
                <span class="s2">raise </span><span class="s1">ParseError(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">text</span><span class="s2">} </span><span class="s4">is not a item name&quot;</span><span class="s1">)</span>
            <span class="s1">role = m.group(</span><span class="s4">'role'</span><span class="s1">)</span>
            <span class="s1">name = m.group(</span><span class="s4">'name'</span><span class="s1">) </span><span class="s2">if </span><span class="s1">role </span><span class="s2">else </span><span class="s1">m.group(</span><span class="s4">'name2'</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">name</span><span class="s2">, </span><span class="s1">role</span><span class="s2">, </span><span class="s1">m.end()</span>

        <span class="s1">rest = []</span>
        <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">content:</span>
            <span class="s2">if not </span><span class="s1">line.strip():</span>
                <span class="s2">continue</span>

            <span class="s1">line_match = self._line_rgx.match(line)</span>
            <span class="s1">description = </span><span class="s2">None</span>
            <span class="s2">if </span><span class="s1">line_match:</span>
                <span class="s1">description = line_match.group(</span><span class="s4">'desc'</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">line_match.group(</span><span class="s4">'trailing'</span><span class="s1">) </span><span class="s2">and </span><span class="s1">description:</span>
                    <span class="s1">self._error_location(</span>
                        <span class="s4">'Unexpected comma or period after function list at index %d of '</span>
                        <span class="s4">'line &quot;%s&quot;' </span><span class="s1">% (line_match.end(</span><span class="s4">'trailing'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">line)</span><span class="s2">,</span>
                        <span class="s1">error=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">description </span><span class="s2">and </span><span class="s1">line.startswith(</span><span class="s4">' '</span><span class="s1">):</span>
                <span class="s1">rest.append(line.strip())</span>
            <span class="s2">elif </span><span class="s1">line_match:</span>
                <span class="s1">funcs = []</span>
                <span class="s1">text = line_match.group(</span><span class="s4">'allfuncs'</span><span class="s1">)</span>
                <span class="s2">while True</span><span class="s1">:</span>
                    <span class="s2">if not </span><span class="s1">text.strip():</span>
                        <span class="s2">break</span>
                    <span class="s1">name</span><span class="s2">, </span><span class="s1">role</span><span class="s2">, </span><span class="s1">match_end = parse_item_name(text)</span>
                    <span class="s1">funcs.append((name</span><span class="s2">, </span><span class="s1">role))</span>
                    <span class="s1">text = text[match_end:].strip()</span>
                    <span class="s2">if </span><span class="s1">text </span><span class="s2">and </span><span class="s1">text[</span><span class="s3">0</span><span class="s1">] == </span><span class="s4">','</span><span class="s1">:</span>
                        <span class="s1">text = text[</span><span class="s3">1</span><span class="s1">:].strip()</span>
                <span class="s1">rest = list(filter(</span><span class="s2">None, </span><span class="s1">[description]))</span>
                <span class="s1">items.append((funcs</span><span class="s2">, </span><span class="s1">rest))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ParseError(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">line</span><span class="s2">} </span><span class="s4">is not a item name&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">items</span>

    <span class="s2">def </span><span class="s1">_parse_index(self</span><span class="s2">, </span><span class="s1">section</span><span class="s2">, </span><span class="s1">content):</span>
        <span class="s0">&quot;&quot;&quot; 
        .. index: default 
           :refguide: something, else, and more 
 
        &quot;&quot;&quot;</span>
        <span class="s2">def </span><span class="s1">strip_each_in(lst):</span>
            <span class="s2">return </span><span class="s1">[s.strip() </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">lst]</span>

        <span class="s1">out = {}</span>
        <span class="s1">section = section.split(</span><span class="s4">'::'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">len(section) &gt; </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">out[</span><span class="s4">'default'</span><span class="s1">] = strip_each_in(section[</span><span class="s3">1</span><span class="s1">].split(</span><span class="s4">','</span><span class="s1">))[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">content:</span>
            <span class="s1">line = line.split(</span><span class="s4">':'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">len(line) &gt; </span><span class="s3">2</span><span class="s1">:</span>
                <span class="s1">out[line[</span><span class="s3">1</span><span class="s1">]] = strip_each_in(line[</span><span class="s3">2</span><span class="s1">].split(</span><span class="s4">','</span><span class="s1">))</span>
        <span class="s2">return </span><span class="s1">out</span>

    <span class="s2">def </span><span class="s1">_parse_summary(self):</span>
        <span class="s0">&quot;&quot;&quot;Grab signature (if given) and summary&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._is_at_section():</span>
            <span class="s2">return</span>

        <span class="s5"># If several signatures present, take the last one</span>
        <span class="s2">while True</span><span class="s1">:</span>
            <span class="s1">summary = self._doc.read_to_next_empty_line()</span>
            <span class="s1">summary_str = </span><span class="s4">&quot; &quot;</span><span class="s1">.join([s.strip() </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">summary]).strip()</span>
            <span class="s1">compiled = re.compile(</span><span class="s4">r'^([\w., ]+=)?\s*[\w\.]+\(.*\)$'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">compiled.match(summary_str):</span>
                <span class="s1">self[</span><span class="s4">'Signature'</span><span class="s1">] = summary_str</span>
                <span class="s2">if not </span><span class="s1">self._is_at_section():</span>
                    <span class="s2">continue</span>
            <span class="s2">break</span>

        <span class="s2">if </span><span class="s1">summary </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self[</span><span class="s4">'Summary'</span><span class="s1">] = summary</span>

        <span class="s2">if not </span><span class="s1">self._is_at_section():</span>
            <span class="s1">self[</span><span class="s4">'Extended Summary'</span><span class="s1">] = self._read_to_next_section()</span>

    <span class="s2">def </span><span class="s1">_parse(self):</span>
        <span class="s1">self._doc.reset()</span>
        <span class="s1">self._parse_summary()</span>

        <span class="s1">sections = list(self._read_sections())</span>
        <span class="s1">section_names = {section </span><span class="s2">for </span><span class="s1">section</span><span class="s2">, </span><span class="s1">content </span><span class="s2">in </span><span class="s1">sections}</span>

        <span class="s1">has_returns = </span><span class="s4">'Returns' </span><span class="s2">in </span><span class="s1">section_names</span>
        <span class="s1">has_yields = </span><span class="s4">'Yields' </span><span class="s2">in </span><span class="s1">section_names</span>
        <span class="s5"># We could do more tests, but we are not. Arbitrarily.</span>
        <span class="s2">if </span><span class="s1">has_returns </span><span class="s2">and </span><span class="s1">has_yields:</span>
            <span class="s1">msg = </span><span class="s4">'Docstring contains both a Returns and Yields section.'</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
        <span class="s2">if not </span><span class="s1">has_yields </span><span class="s2">and </span><span class="s4">'Receives' </span><span class="s2">in </span><span class="s1">section_names:</span>
            <span class="s1">msg = </span><span class="s4">'Docstring contains a Receives section but not Yields.'</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

        <span class="s2">for </span><span class="s1">(section</span><span class="s2">, </span><span class="s1">content) </span><span class="s2">in </span><span class="s1">sections:</span>
            <span class="s2">if not </span><span class="s1">section.startswith(</span><span class="s4">'..'</span><span class="s1">):</span>
                <span class="s1">section = (s.capitalize() </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">section.split(</span><span class="s4">' '</span><span class="s1">))</span>
                <span class="s1">section = </span><span class="s4">' '</span><span class="s1">.join(section)</span>
                <span class="s2">if </span><span class="s1">self.get(section):</span>
                    <span class="s1">self._error_location(</span><span class="s4">f&quot;The section </span><span class="s2">{</span><span class="s1">section</span><span class="s2">} </span><span class="s4">appears twice&quot;</span><span class="s1">)</span>

            <span class="s2">if </span><span class="s1">section </span><span class="s2">in </span><span class="s1">(</span><span class="s4">'Parameters'</span><span class="s2">, </span><span class="s4">'Other Parameters'</span><span class="s2">, </span><span class="s4">'Attributes'</span><span class="s2">,</span>
                           <span class="s4">'Methods'</span><span class="s1">):</span>
                <span class="s1">self[section] = self._parse_param_list(content)</span>
            <span class="s2">elif </span><span class="s1">section </span><span class="s2">in </span><span class="s1">(</span><span class="s4">'Returns'</span><span class="s2">, </span><span class="s4">'Yields'</span><span class="s2">, </span><span class="s4">'Raises'</span><span class="s2">, </span><span class="s4">'Warns'</span><span class="s2">, </span><span class="s4">'Receives'</span><span class="s1">):</span>
                <span class="s1">self[section] = self._parse_param_list(</span>
                    <span class="s1">content</span><span class="s2">, </span><span class="s1">single_element_is_type=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">section.startswith(</span><span class="s4">'.. index::'</span><span class="s1">):</span>
                <span class="s1">self[</span><span class="s4">'index'</span><span class="s1">] = self._parse_index(section</span><span class="s2">, </span><span class="s1">content)</span>
            <span class="s2">elif </span><span class="s1">section == </span><span class="s4">'See Also'</span><span class="s1">:</span>
                <span class="s1">self[</span><span class="s4">'See Also'</span><span class="s1">] = self._parse_see_also(content)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self[section] = content</span>

    <span class="s2">def </span><span class="s1">_error_location(self</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">error=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s4">'_obj'</span><span class="s1">):</span>
            <span class="s5"># we know where the docs came from:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">filename = inspect.getsourcefile(self._obj)</span>
            <span class="s2">except </span><span class="s1">TypeError:</span>
                <span class="s1">filename = </span><span class="s2">None</span>
            <span class="s1">msg = msg + </span><span class="s4">f&quot; in the docstring of </span><span class="s2">{</span><span class="s1">self._obj</span><span class="s2">} </span><span class="s4">in </span><span class="s2">{</span><span class="s1">filename</span><span class="s2">}</span><span class="s4">.&quot;</span>
        <span class="s2">if </span><span class="s1">error:</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">warn(msg)</span>

    <span class="s5"># string conversion routines</span>

    <span class="s2">def </span><span class="s1">_str_header(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">symbol=</span><span class="s4">'-'</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">[name</span><span class="s2">, </span><span class="s1">len(name)*symbol]</span>

    <span class="s2">def </span><span class="s1">_str_indent(self</span><span class="s2">, </span><span class="s1">doc</span><span class="s2">, </span><span class="s1">indent=</span><span class="s3">4</span><span class="s1">):</span>
        <span class="s1">out = []</span>
        <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">doc:</span>
            <span class="s1">out += [</span><span class="s4">' '</span><span class="s1">*indent + line]</span>
        <span class="s2">return </span><span class="s1">out</span>

    <span class="s2">def </span><span class="s1">_str_signature(self):</span>
        <span class="s2">if </span><span class="s1">self[</span><span class="s4">'Signature'</span><span class="s1">]:</span>
            <span class="s2">return </span><span class="s1">[self[</span><span class="s4">'Signature'</span><span class="s1">].replace(</span><span class="s4">'*'</span><span class="s2">, </span><span class="s4">r'\*'</span><span class="s1">)] + [</span><span class="s4">''</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[</span><span class="s4">''</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">_str_summary(self):</span>
        <span class="s2">if </span><span class="s1">self[</span><span class="s4">'Summary'</span><span class="s1">]:</span>
            <span class="s2">return </span><span class="s1">self[</span><span class="s4">'Summary'</span><span class="s1">] + [</span><span class="s4">''</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">_str_extended_summary(self):</span>
        <span class="s2">if </span><span class="s1">self[</span><span class="s4">'Extended Summary'</span><span class="s1">]:</span>
            <span class="s2">return </span><span class="s1">self[</span><span class="s4">'Extended Summary'</span><span class="s1">] + [</span><span class="s4">''</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">_str_param_list(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s1">out = []</span>
        <span class="s2">if </span><span class="s1">self[name]:</span>
            <span class="s1">out += self._str_header(name)</span>
            <span class="s2">for </span><span class="s1">param </span><span class="s2">in </span><span class="s1">self[name]:</span>
                <span class="s1">parts = []</span>
                <span class="s2">if </span><span class="s1">param.name:</span>
                    <span class="s1">parts.append(param.name)</span>
                <span class="s2">if </span><span class="s1">param.type:</span>
                    <span class="s1">parts.append(param.type)</span>
                <span class="s1">out += [</span><span class="s4">' : '</span><span class="s1">.join(parts)]</span>
                <span class="s2">if </span><span class="s1">param.desc </span><span class="s2">and </span><span class="s4">''</span><span class="s1">.join(param.desc).strip():</span>
                    <span class="s1">out += self._str_indent(param.desc)</span>
            <span class="s1">out += [</span><span class="s4">''</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">out</span>

    <span class="s2">def </span><span class="s1">_str_section(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s1">out = []</span>
        <span class="s2">if </span><span class="s1">self[name]:</span>
            <span class="s1">out += self._str_header(name)</span>
            <span class="s1">out += self[name]</span>
            <span class="s1">out += [</span><span class="s4">''</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">out</span>

    <span class="s2">def </span><span class="s1">_str_see_also(self</span><span class="s2">, </span><span class="s1">func_role):</span>
        <span class="s2">if not </span><span class="s1">self[</span><span class="s4">'See Also'</span><span class="s1">]:</span>
            <span class="s2">return </span><span class="s1">[]</span>
        <span class="s1">out = []</span>
        <span class="s1">out += self._str_header(</span><span class="s4">&quot;See Also&quot;</span><span class="s1">)</span>
        <span class="s1">out += [</span><span class="s4">''</span><span class="s1">]</span>
        <span class="s1">last_had_desc = </span><span class="s2">True</span>
        <span class="s2">for </span><span class="s1">funcs</span><span class="s2">, </span><span class="s1">desc </span><span class="s2">in </span><span class="s1">self[</span><span class="s4">'See Also'</span><span class="s1">]:</span>
            <span class="s2">assert </span><span class="s1">isinstance(funcs</span><span class="s2">, </span><span class="s1">list)</span>
            <span class="s1">links = []</span>
            <span class="s2">for </span><span class="s1">func</span><span class="s2">, </span><span class="s1">role </span><span class="s2">in </span><span class="s1">funcs:</span>
                <span class="s2">if </span><span class="s1">role:</span>
                    <span class="s1">link = </span><span class="s4">f':</span><span class="s2">{</span><span class="s1">role</span><span class="s2">}</span><span class="s4">:`</span><span class="s2">{</span><span class="s1">func</span><span class="s2">}</span><span class="s4">`'</span>
                <span class="s2">elif </span><span class="s1">func_role:</span>
                    <span class="s1">link = </span><span class="s4">f':</span><span class="s2">{</span><span class="s1">func_role</span><span class="s2">}</span><span class="s4">:`</span><span class="s2">{</span><span class="s1">func</span><span class="s2">}</span><span class="s4">`'</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">link = </span><span class="s4">f&quot;`</span><span class="s2">{</span><span class="s1">func</span><span class="s2">}</span><span class="s4">`_&quot;</span>
                <span class="s1">links.append(link)</span>
            <span class="s1">link = </span><span class="s4">', '</span><span class="s1">.join(links)</span>
            <span class="s1">out += [link]</span>
            <span class="s2">if </span><span class="s1">desc:</span>
                <span class="s1">out += self._str_indent([</span><span class="s4">' '</span><span class="s1">.join(desc)])</span>
                <span class="s1">last_had_desc = </span><span class="s2">True</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">last_had_desc = </span><span class="s2">False</span>
                <span class="s1">out += self._str_indent([self.empty_description])</span>

        <span class="s2">if </span><span class="s1">last_had_desc:</span>
            <span class="s1">out += [</span><span class="s4">''</span><span class="s1">]</span>
        <span class="s1">out += [</span><span class="s4">''</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">out</span>

    <span class="s2">def </span><span class="s1">_str_index(self):</span>
        <span class="s1">idx = self[</span><span class="s4">'index'</span><span class="s1">]</span>
        <span class="s1">out = []</span>
        <span class="s1">output_index = </span><span class="s2">False</span>
        <span class="s1">default_index = idx.get(</span><span class="s4">'default'</span><span class="s2">, </span><span class="s4">''</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">default_index:</span>
            <span class="s1">output_index = </span><span class="s2">True</span>
        <span class="s1">out += [</span><span class="s4">f'.. index:: </span><span class="s2">{</span><span class="s1">default_index</span><span class="s2">}</span><span class="s4">'</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">section</span><span class="s2">, </span><span class="s1">references </span><span class="s2">in </span><span class="s1">idx.items():</span>
            <span class="s2">if </span><span class="s1">section == </span><span class="s4">'default'</span><span class="s1">:</span>
                <span class="s2">continue</span>
            <span class="s1">output_index = </span><span class="s2">True</span>
            <span class="s1">out += [</span><span class="s4">f&quot;   :</span><span class="s2">{</span><span class="s1">section</span><span class="s2">}</span><span class="s4">: </span><span class="s2">{</span><span class="s4">', '</span><span class="s1">.join(references)</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">output_index:</span>
            <span class="s2">return </span><span class="s1">out</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s4">''</span>

    <span class="s2">def </span><span class="s1">__str__(self</span><span class="s2">, </span><span class="s1">func_role=</span><span class="s4">''</span><span class="s1">):</span>
        <span class="s1">out = []</span>
        <span class="s1">out += self._str_signature()</span>
        <span class="s1">out += self._str_summary()</span>
        <span class="s1">out += self._str_extended_summary()</span>
        <span class="s2">for </span><span class="s1">param_list </span><span class="s2">in </span><span class="s1">(</span><span class="s4">'Parameters'</span><span class="s2">, </span><span class="s4">'Returns'</span><span class="s2">, </span><span class="s4">'Yields'</span><span class="s2">, </span><span class="s4">'Receives'</span><span class="s2">,</span>
                           <span class="s4">'Other Parameters'</span><span class="s2">, </span><span class="s4">'Raises'</span><span class="s2">, </span><span class="s4">'Warns'</span><span class="s1">):</span>
            <span class="s1">out += self._str_param_list(param_list)</span>
        <span class="s1">out += self._str_section(</span><span class="s4">'Warnings'</span><span class="s1">)</span>
        <span class="s1">out += self._str_see_also(func_role)</span>
        <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">(</span><span class="s4">'Notes'</span><span class="s2">, </span><span class="s4">'References'</span><span class="s2">, </span><span class="s4">'Examples'</span><span class="s1">):</span>
            <span class="s1">out += self._str_section(s)</span>
        <span class="s2">for </span><span class="s1">param_list </span><span class="s2">in </span><span class="s1">(</span><span class="s4">'Attributes'</span><span class="s2">, </span><span class="s4">'Methods'</span><span class="s1">):</span>
            <span class="s1">out += self._str_param_list(param_list)</span>
        <span class="s1">out += self._str_index()</span>
        <span class="s2">return </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s1">.join(out)</span>


<span class="s2">def </span><span class="s1">indent(str</span><span class="s2">, </span><span class="s1">indent=</span><span class="s3">4</span><span class="s1">):</span>
    <span class="s1">indent_str = </span><span class="s4">' '</span><span class="s1">*indent</span>
    <span class="s2">if </span><span class="s1">str </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">indent_str</span>
    <span class="s1">lines = str.split(</span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s1">.join(indent_str + l </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lines)</span>


<span class="s2">def </span><span class="s1">dedent_lines(lines):</span>
    <span class="s0">&quot;&quot;&quot;Deindent a list of lines maximally&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">textwrap.dedent(</span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s1">.join(lines)).split(</span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">header(text</span><span class="s2">, </span><span class="s1">style=</span><span class="s4">'-'</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">text + </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">' </span><span class="s1">+ style*len(text) + </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span>


<span class="s2">class </span><span class="s1">FunctionDoc(NumpyDocString):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">role=</span><span class="s4">'func'</span><span class="s2">, </span><span class="s1">doc=</span><span class="s2">None, </span><span class="s1">config={}):</span>
        <span class="s1">self._f = func</span>
        <span class="s1">self._role = role  </span><span class="s5"># e.g. &quot;func&quot; or &quot;meth&quot;</span>

        <span class="s2">if </span><span class="s1">doc </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">func </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;No function or docstring given&quot;</span><span class="s1">)</span>
            <span class="s1">doc = inspect.getdoc(func) </span><span class="s2">or </span><span class="s4">''</span>
        <span class="s1">NumpyDocString.__init__(self</span><span class="s2">, </span><span class="s1">doc</span><span class="s2">, </span><span class="s1">config)</span>

        <span class="s2">if not </span><span class="s1">self[</span><span class="s4">'Signature'</span><span class="s1">] </span><span class="s2">and </span><span class="s1">func </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">func</span><span class="s2">, </span><span class="s1">func_name = self.get_func()</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">signature = str(inspect.signature(func))</span>
                <span class="s2">except </span><span class="s1">(AttributeError</span><span class="s2">, </span><span class="s1">ValueError):</span>
                    <span class="s5"># try to read signature, backward compat for older Python</span>
                    <span class="s2">if </span><span class="s1">sys.version_info[</span><span class="s3">0</span><span class="s1">] &gt;= </span><span class="s3">3</span><span class="s1">:</span>
                        <span class="s1">argspec = inspect.getfullargspec(func)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">argspec = inspect.getargspec(func)</span>
                    <span class="s1">signature = inspect.formatargspec(*argspec)</span>
                <span class="s1">signature = </span><span class="s4">f'</span><span class="s2">{</span><span class="s1">func_name</span><span class="s2">}{</span><span class="s1">signature</span><span class="s2">}</span><span class="s4">'</span>
            <span class="s2">except </span><span class="s1">TypeError:</span>
                <span class="s1">signature = </span><span class="s4">f'</span><span class="s2">{</span><span class="s1">func_name</span><span class="s2">}</span><span class="s4">()'</span>
            <span class="s1">self[</span><span class="s4">'Signature'</span><span class="s1">] = signature</span>

    <span class="s2">def </span><span class="s1">get_func(self):</span>
        <span class="s1">func_name = getattr(self._f</span><span class="s2">, </span><span class="s4">'__name__'</span><span class="s2">, </span><span class="s1">self.__class__.__name__)</span>
        <span class="s2">if </span><span class="s1">inspect.isclass(self._f):</span>
            <span class="s1">func = getattr(self._f</span><span class="s2">, </span><span class="s4">'__call__'</span><span class="s2">, </span><span class="s1">self._f.__init__)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">func = self._f</span>
        <span class="s2">return </span><span class="s1">func</span><span class="s2">, </span><span class="s1">func_name</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s1">out = </span><span class="s4">''</span>

        <span class="s1">func</span><span class="s2">, </span><span class="s1">func_name = self.get_func()</span>

        <span class="s1">roles = {</span><span class="s4">'func'</span><span class="s1">: </span><span class="s4">'function'</span><span class="s2">,</span>
                 <span class="s4">'meth'</span><span class="s1">: </span><span class="s4">'method'</span><span class="s1">}</span>

        <span class="s2">if </span><span class="s1">self._role:</span>
            <span class="s2">if </span><span class="s1">self._role </span><span class="s2">not in </span><span class="s1">roles:</span>
                <span class="s1">print(</span><span class="s4">f&quot;Warning: invalid role </span><span class="s2">{</span><span class="s1">self._role</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>
            <span class="s1">out += </span><span class="s4">f&quot;.. </span><span class="s2">{</span><span class="s1">roles.get(self._role</span><span class="s2">, </span><span class="s4">''</span><span class="s1">)</span><span class="s2">}</span><span class="s4">:: </span><span class="s2">{</span><span class="s1">func_name</span><span class="s2">}\n    \n\n</span><span class="s4">&quot;</span>

        <span class="s1">out += super().__str__(func_role=self._role)</span>
        <span class="s2">return </span><span class="s1">out</span>


<span class="s2">class </span><span class="s1">ClassDoc(NumpyDocString):</span>

    <span class="s1">extra_public_methods = [</span><span class="s4">'__call__'</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">, </span><span class="s1">doc=</span><span class="s2">None, </span><span class="s1">modulename=</span><span class="s4">''</span><span class="s2">, </span><span class="s1">func_doc=FunctionDoc</span><span class="s2">,</span>
                 <span class="s1">config={}):</span>
        <span class="s2">if not </span><span class="s1">inspect.isclass(cls) </span><span class="s2">and </span><span class="s1">cls </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Expected a class or None, but got </span><span class="s2">{</span><span class="s1">cls</span><span class="s2">!r}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s1">self._cls = cls</span>

        <span class="s2">if </span><span class="s4">'sphinx' </span><span class="s2">in </span><span class="s1">sys.modules:</span>
            <span class="s2">from </span><span class="s1">sphinx.ext.autodoc </span><span class="s2">import </span><span class="s1">ALL</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">ALL = object()</span>

        <span class="s1">self.show_inherited_members = config.get(</span>
                    <span class="s4">'show_inherited_class_members'</span><span class="s2">, True</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">modulename </span><span class="s2">and not </span><span class="s1">modulename.endswith(</span><span class="s4">'.'</span><span class="s1">):</span>
            <span class="s1">modulename += </span><span class="s4">'.'</span>
        <span class="s1">self._mod = modulename</span>

        <span class="s2">if </span><span class="s1">doc </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">cls </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;No class or documentation string given&quot;</span><span class="s1">)</span>
            <span class="s1">doc = pydoc.getdoc(cls)</span>

        <span class="s1">NumpyDocString.__init__(self</span><span class="s2">, </span><span class="s1">doc)</span>

        <span class="s1">_members = config.get(</span><span class="s4">'members'</span><span class="s2">, </span><span class="s1">[])</span>
        <span class="s2">if </span><span class="s1">_members </span><span class="s2">is </span><span class="s1">ALL:</span>
            <span class="s1">_members = </span><span class="s2">None</span>
        <span class="s1">_exclude = config.get(</span><span class="s4">'exclude-members'</span><span class="s2">, </span><span class="s1">[])</span>

        <span class="s2">if </span><span class="s1">config.get(</span><span class="s4">'show_class_members'</span><span class="s2">, True</span><span class="s1">) </span><span class="s2">and </span><span class="s1">_exclude </span><span class="s2">is not </span><span class="s1">ALL:</span>
            <span class="s2">def </span><span class="s1">splitlines_x(s):</span>
                <span class="s2">if not </span><span class="s1">s:</span>
                    <span class="s2">return </span><span class="s1">[]</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">s.splitlines()</span>
            <span class="s2">for </span><span class="s1">field</span><span class="s2">, </span><span class="s1">items </span><span class="s2">in </span><span class="s1">[(</span><span class="s4">'Methods'</span><span class="s2">, </span><span class="s1">self.methods)</span><span class="s2">,</span>
                                 <span class="s1">(</span><span class="s4">'Attributes'</span><span class="s2">, </span><span class="s1">self.properties)]:</span>
                <span class="s2">if not </span><span class="s1">self[field]:</span>
                    <span class="s1">doc_list = []</span>
                    <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">sorted(items):</span>
                        <span class="s2">if </span><span class="s1">(name </span><span class="s2">in </span><span class="s1">_exclude </span><span class="s2">or</span>
                                <span class="s1">(_members </span><span class="s2">and </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">_members)):</span>
                            <span class="s2">continue</span>
                        <span class="s2">try</span><span class="s1">:</span>
                            <span class="s1">doc_item = pydoc.getdoc(getattr(self._cls</span><span class="s2">, </span><span class="s1">name))</span>
                            <span class="s1">doc_list.append(</span>
                                <span class="s1">Parameter(name</span><span class="s2">, </span><span class="s4">''</span><span class="s2">, </span><span class="s1">splitlines_x(doc_item)))</span>
                        <span class="s2">except </span><span class="s1">AttributeError:</span>
                            <span class="s2">pass  </span><span class="s5"># method doesn't exist</span>
                    <span class="s1">self[field] = doc_list</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">methods(self):</span>
        <span class="s2">if </span><span class="s1">self._cls </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[]</span>
        <span class="s2">return </span><span class="s1">[name </span><span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">func </span><span class="s2">in </span><span class="s1">inspect.getmembers(self._cls)</span>
                <span class="s2">if </span><span class="s1">((</span><span class="s2">not </span><span class="s1">name.startswith(</span><span class="s4">'_'</span><span class="s1">)</span>
                     <span class="s2">or </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.extra_public_methods)</span>
                    <span class="s2">and </span><span class="s1">isinstance(func</span><span class="s2">, </span><span class="s1">Callable)</span>
                    <span class="s2">and </span><span class="s1">self._is_show_member(name))]</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">properties(self):</span>
        <span class="s2">if </span><span class="s1">self._cls </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[]</span>
        <span class="s2">return </span><span class="s1">[name </span><span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">func </span><span class="s2">in </span><span class="s1">inspect.getmembers(self._cls)</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">not </span><span class="s1">name.startswith(</span><span class="s4">'_'</span><span class="s1">) </span><span class="s2">and</span>
                    <span class="s1">(func </span><span class="s2">is None or </span><span class="s1">isinstance(func</span><span class="s2">, </span><span class="s1">property) </span><span class="s2">or</span>
                     <span class="s1">inspect.isdatadescriptor(func))</span>
                    <span class="s2">and </span><span class="s1">self._is_show_member(name))]</span>

    <span class="s2">def </span><span class="s1">_is_show_member(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s2">if </span><span class="s1">self.show_inherited_members:</span>
            <span class="s2">return True  </span><span class="s5"># show all class members</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">self._cls.__dict__:</span>
            <span class="s2">return False  </span><span class="s5"># class member is inherited, we do not show it</span>
        <span class="s2">return True</span>
</pre>
</body>
</html>