<html>
<head>
<title>distance.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6a8759;}
.s4 { color: #cc7832;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
distance.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Distance computations (:mod:`scipy.spatial.distance`) 
===================================================== 
 
.. sectionauthor:: Damian Eads 
 
Function reference 
------------------ 
 
Distance matrix computation from a collection of raw observation vectors 
stored in a rectangular array. 
 
.. autosummary:: 
   :toctree: generated/ 
 
   pdist   -- pairwise distances between observation vectors. 
   cdist   -- distances between two collections of observation vectors 
   squareform -- convert distance matrix to a condensed one and vice versa 
   directed_hausdorff -- directed Hausdorff distance between arrays 
 
Predicates for checking the validity of distance matrices, both 
condensed and redundant. Also contained in this module are functions 
for computing the number of observations in a distance matrix. 
 
.. autosummary:: 
   :toctree: generated/ 
 
   is_valid_dm -- checks for a valid distance matrix 
   is_valid_y  -- checks for a valid condensed distance matrix 
   num_obs_dm  -- # of observations in a distance matrix 
   num_obs_y   -- # of observations in a condensed distance matrix 
 
Distance functions between two numeric vectors ``u`` and ``v``. Computing 
distances over a large collection of vectors is inefficient for these 
functions. Use ``pdist`` for this purpose. 
 
.. autosummary:: 
   :toctree: generated/ 
 
   braycurtis       -- the Bray-Curtis distance. 
   canberra         -- the Canberra distance. 
   chebyshev        -- the Chebyshev distance. 
   cityblock        -- the Manhattan distance. 
   correlation      -- the Correlation distance. 
   cosine           -- the Cosine distance. 
   euclidean        -- the Euclidean distance. 
   jensenshannon    -- the Jensen-Shannon distance. 
   mahalanobis      -- the Mahalanobis distance. 
   minkowski        -- the Minkowski distance. 
   seuclidean       -- the normalized Euclidean distance. 
   sqeuclidean      -- the squared Euclidean distance. 
 
Distance functions between two boolean vectors (representing sets) ``u`` and 
``v``.  As in the case of numerical vectors, ``pdist`` is more efficient for 
computing the distances between all pairs. 
 
.. autosummary:: 
   :toctree: generated/ 
 
   dice             -- the Dice dissimilarity. 
   hamming          -- the Hamming distance. 
   jaccard          -- the Jaccard distance. 
   kulczynski1      -- the Kulczynski 1 distance. 
   rogerstanimoto   -- the Rogers-Tanimoto dissimilarity. 
   russellrao       -- the Russell-Rao dissimilarity. 
   sokalmichener    -- the Sokal-Michener dissimilarity. 
   sokalsneath      -- the Sokal-Sneath dissimilarity. 
   yule             -- the Yule dissimilarity. 
 
:func:`hamming` also operates over discrete numerical vectors. 
&quot;&quot;&quot;</span>

<span class="s2"># Copyright (C) Damian Eads, 2007-2008. New BSD License.</span>

<span class="s1">__all__ = [</span>
    <span class="s3">'braycurtis'</span><span class="s4">,</span>
    <span class="s3">'canberra'</span><span class="s4">,</span>
    <span class="s3">'cdist'</span><span class="s4">,</span>
    <span class="s3">'chebyshev'</span><span class="s4">,</span>
    <span class="s3">'cityblock'</span><span class="s4">,</span>
    <span class="s3">'correlation'</span><span class="s4">,</span>
    <span class="s3">'cosine'</span><span class="s4">,</span>
    <span class="s3">'dice'</span><span class="s4">,</span>
    <span class="s3">'directed_hausdorff'</span><span class="s4">,</span>
    <span class="s3">'euclidean'</span><span class="s4">,</span>
    <span class="s3">'hamming'</span><span class="s4">,</span>
    <span class="s3">'is_valid_dm'</span><span class="s4">,</span>
    <span class="s3">'is_valid_y'</span><span class="s4">,</span>
    <span class="s3">'jaccard'</span><span class="s4">,</span>
    <span class="s3">'jensenshannon'</span><span class="s4">,</span>
    <span class="s3">'kulczynski1'</span><span class="s4">,</span>
    <span class="s3">'mahalanobis'</span><span class="s4">,</span>
    <span class="s3">'minkowski'</span><span class="s4">,</span>
    <span class="s3">'num_obs_dm'</span><span class="s4">,</span>
    <span class="s3">'num_obs_y'</span><span class="s4">,</span>
    <span class="s3">'pdist'</span><span class="s4">,</span>
    <span class="s3">'rogerstanimoto'</span><span class="s4">,</span>
    <span class="s3">'russellrao'</span><span class="s4">,</span>
    <span class="s3">'seuclidean'</span><span class="s4">,</span>
    <span class="s3">'sokalmichener'</span><span class="s4">,</span>
    <span class="s3">'sokalsneath'</span><span class="s4">,</span>
    <span class="s3">'sqeuclidean'</span><span class="s4">,</span>
    <span class="s3">'squareform'</span><span class="s4">,</span>
    <span class="s3">'yule'</span>
<span class="s1">]</span>


<span class="s4">import </span><span class="s1">os</span>
<span class="s4">import </span><span class="s1">warnings</span>
<span class="s4">import </span><span class="s1">numpy </span><span class="s4">as </span><span class="s1">np</span>
<span class="s4">import </span><span class="s1">dataclasses</span>

<span class="s4">from </span><span class="s1">typing </span><span class="s4">import </span><span class="s1">Optional</span><span class="s4">, </span><span class="s1">Callable</span>

<span class="s4">from </span><span class="s1">functools </span><span class="s4">import </span><span class="s1">partial</span>
<span class="s4">from </span><span class="s1">scipy._lib._util </span><span class="s4">import </span><span class="s1">_asarray_validated</span>

<span class="s4">from </span><span class="s1">. </span><span class="s4">import </span><span class="s1">_distance_wrap</span>
<span class="s4">from </span><span class="s1">. </span><span class="s4">import </span><span class="s1">_hausdorff</span>
<span class="s4">from </span><span class="s1">..linalg </span><span class="s4">import </span><span class="s1">norm</span>
<span class="s4">from </span><span class="s1">..special </span><span class="s4">import </span><span class="s1">rel_entr</span>

<span class="s4">from </span><span class="s1">. </span><span class="s4">import </span><span class="s1">_distance_pybind</span>


<span class="s4">def </span><span class="s1">_extra_windows_error_checks(x</span><span class="s4">, </span><span class="s1">out</span><span class="s4">, </span><span class="s1">required_shape</span><span class="s4">, </span><span class="s1">**kwargs):</span>
    <span class="s2"># TODO: remove this function when distutils</span>
    <span class="s2"># build system is removed because pybind11 error</span>
    <span class="s2"># handling should suffice per gh-18108</span>
    <span class="s4">if </span><span class="s1">os.name == </span><span class="s3">&quot;nt&quot; </span><span class="s4">and </span><span class="s1">out </span><span class="s4">is not None</span><span class="s1">:</span>
        <span class="s4">if </span><span class="s1">out.shape != required_shape:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Output array has incorrect shape.&quot;</span><span class="s1">)</span>
        <span class="s4">if not </span><span class="s1">out.flags[</span><span class="s3">&quot;C_CONTIGUOUS&quot;</span><span class="s1">]:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Output array must be C-contiguous.&quot;</span><span class="s1">)</span>
        <span class="s4">if not </span><span class="s1">np.can_cast(x.dtype</span><span class="s4">, </span><span class="s1">out.dtype):</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Wrong out dtype.&quot;</span><span class="s1">)</span>
    <span class="s4">if </span><span class="s1">os.name == </span><span class="s3">&quot;nt&quot; </span><span class="s4">and </span><span class="s3">&quot;w&quot; </span><span class="s4">in </span><span class="s1">kwargs:</span>
        <span class="s1">w = kwargs[</span><span class="s3">&quot;w&quot;</span><span class="s1">]</span>
        <span class="s4">if </span><span class="s1">w </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s4">if </span><span class="s1">(w &lt; </span><span class="s5">0</span><span class="s1">).sum() &gt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Input weights should be all non-negative&quot;</span><span class="s1">)</span>


<span class="s4">def </span><span class="s1">_copy_array_if_base_present(a):</span>
    <span class="s0">&quot;&quot;&quot;Copy the array if its base points to a parent array.&quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">a.base </span><span class="s4">is not None</span><span class="s1">:</span>
        <span class="s4">return </span><span class="s1">a.copy()</span>
    <span class="s4">return </span><span class="s1">a</span>


<span class="s4">def </span><span class="s1">_correlation_cdist_wrap(XA</span><span class="s4">, </span><span class="s1">XB</span><span class="s4">, </span><span class="s1">dm</span><span class="s4">, </span><span class="s1">**kwargs):</span>
    <span class="s1">XA = XA - XA.mean(axis=</span><span class="s5">1</span><span class="s4">, </span><span class="s1">keepdims=</span><span class="s4">True</span><span class="s1">)</span>
    <span class="s1">XB = XB - XB.mean(axis=</span><span class="s5">1</span><span class="s4">, </span><span class="s1">keepdims=</span><span class="s4">True</span><span class="s1">)</span>
    <span class="s1">_distance_wrap.cdist_cosine_double_wrap(XA</span><span class="s4">, </span><span class="s1">XB</span><span class="s4">, </span><span class="s1">dm</span><span class="s4">, </span><span class="s1">**kwargs)</span>


<span class="s4">def </span><span class="s1">_correlation_pdist_wrap(X</span><span class="s4">, </span><span class="s1">dm</span><span class="s4">, </span><span class="s1">**kwargs):</span>
    <span class="s1">X2 = X - X.mean(axis=</span><span class="s5">1</span><span class="s4">, </span><span class="s1">keepdims=</span><span class="s4">True</span><span class="s1">)</span>
    <span class="s1">_distance_wrap.pdist_cosine_double_wrap(X2</span><span class="s4">, </span><span class="s1">dm</span><span class="s4">, </span><span class="s1">**kwargs)</span>


<span class="s4">def </span><span class="s1">_convert_to_type(X</span><span class="s4">, </span><span class="s1">out_type):</span>
    <span class="s4">return </span><span class="s1">np.ascontiguousarray(X</span><span class="s4">, </span><span class="s1">dtype=out_type)</span>


<span class="s4">def </span><span class="s1">_nbool_correspond_all(u</span><span class="s4">, </span><span class="s1">v</span><span class="s4">, </span><span class="s1">w=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s4">if </span><span class="s1">u.dtype == v.dtype == bool </span><span class="s4">and </span><span class="s1">w </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s1">not_u = ~u</span>
        <span class="s1">not_v = ~v</span>
        <span class="s1">nff = (not_u &amp; not_v).sum()</span>
        <span class="s1">nft = (not_u &amp; v).sum()</span>
        <span class="s1">ntf = (u &amp; not_v).sum()</span>
        <span class="s1">ntt = (u &amp; v).sum()</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s1">dtype = np.result_type(int</span><span class="s4">, </span><span class="s1">u.dtype</span><span class="s4">, </span><span class="s1">v.dtype)</span>
        <span class="s1">u = u.astype(dtype)</span>
        <span class="s1">v = v.astype(dtype)</span>
        <span class="s1">not_u = </span><span class="s5">1.0 </span><span class="s1">- u</span>
        <span class="s1">not_v = </span><span class="s5">1.0 </span><span class="s1">- v</span>
        <span class="s4">if </span><span class="s1">w </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">not_u = w * not_u</span>
            <span class="s1">u = w * u</span>
        <span class="s1">nff = (not_u * not_v).sum()</span>
        <span class="s1">nft = (not_u * v).sum()</span>
        <span class="s1">ntf = (u * not_v).sum()</span>
        <span class="s1">ntt = (u * v).sum()</span>
    <span class="s4">return </span><span class="s1">(nff</span><span class="s4">, </span><span class="s1">nft</span><span class="s4">, </span><span class="s1">ntf</span><span class="s4">, </span><span class="s1">ntt)</span>


<span class="s4">def </span><span class="s1">_nbool_correspond_ft_tf(u</span><span class="s4">, </span><span class="s1">v</span><span class="s4">, </span><span class="s1">w=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s4">if </span><span class="s1">u.dtype == v.dtype == bool </span><span class="s4">and </span><span class="s1">w </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s1">not_u = ~u</span>
        <span class="s1">not_v = ~v</span>
        <span class="s1">nft = (not_u &amp; v).sum()</span>
        <span class="s1">ntf = (u &amp; not_v).sum()</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s1">dtype = np.result_type(int</span><span class="s4">, </span><span class="s1">u.dtype</span><span class="s4">, </span><span class="s1">v.dtype)</span>
        <span class="s1">u = u.astype(dtype)</span>
        <span class="s1">v = v.astype(dtype)</span>
        <span class="s1">not_u = </span><span class="s5">1.0 </span><span class="s1">- u</span>
        <span class="s1">not_v = </span><span class="s5">1.0 </span><span class="s1">- v</span>
        <span class="s4">if </span><span class="s1">w </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">not_u = w * not_u</span>
            <span class="s1">u = w * u</span>
        <span class="s1">nft = (not_u * v).sum()</span>
        <span class="s1">ntf = (u * not_v).sum()</span>
    <span class="s4">return </span><span class="s1">(nft</span><span class="s4">, </span><span class="s1">ntf)</span>


<span class="s4">def </span><span class="s1">_validate_cdist_input(XA</span><span class="s4">, </span><span class="s1">XB</span><span class="s4">, </span><span class="s1">mA</span><span class="s4">, </span><span class="s1">mB</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">metric_info</span><span class="s4">, </span><span class="s1">**kwargs):</span>
    <span class="s2"># get supported types</span>
    <span class="s1">types = metric_info.types</span>
    <span class="s2"># choose best type</span>
    <span class="s1">typ = types[types.index(XA.dtype)] </span><span class="s4">if </span><span class="s1">XA.dtype </span><span class="s4">in </span><span class="s1">types </span><span class="s4">else </span><span class="s1">types[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s2"># validate data</span>
    <span class="s1">XA = _convert_to_type(XA</span><span class="s4">, </span><span class="s1">out_type=typ)</span>
    <span class="s1">XB = _convert_to_type(XB</span><span class="s4">, </span><span class="s1">out_type=typ)</span>

    <span class="s2"># validate kwargs</span>
    <span class="s1">_validate_kwargs = metric_info.validator</span>
    <span class="s4">if </span><span class="s1">_validate_kwargs:</span>
        <span class="s1">kwargs = _validate_kwargs((XA</span><span class="s4">, </span><span class="s1">XB)</span><span class="s4">, </span><span class="s1">mA + mB</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">**kwargs)</span>
    <span class="s4">return </span><span class="s1">XA</span><span class="s4">, </span><span class="s1">XB</span><span class="s4">, </span><span class="s1">typ</span><span class="s4">, </span><span class="s1">kwargs</span>


<span class="s4">def </span><span class="s1">_validate_weight_with_size(X</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">**kwargs):</span>
    <span class="s1">w = kwargs.pop(</span><span class="s3">'w'</span><span class="s4">, None</span><span class="s1">)</span>
    <span class="s4">if </span><span class="s1">w </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s4">return </span><span class="s1">kwargs</span>

    <span class="s4">if </span><span class="s1">w.ndim != </span><span class="s5">1 </span><span class="s4">or </span><span class="s1">w.shape[</span><span class="s5">0</span><span class="s1">] != n:</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Weights must have same size as input vector. &quot;</span>
                         <span class="s3">f&quot;</span><span class="s4">{</span><span class="s1">w.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">} </span><span class="s3">vs. </span><span class="s4">{</span><span class="s1">n</span><span class="s4">}</span><span class="s3">&quot;</span><span class="s1">)</span>

    <span class="s1">kwargs[</span><span class="s3">'w'</span><span class="s1">] = _validate_weights(w)</span>
    <span class="s4">return </span><span class="s1">kwargs</span>


<span class="s4">def </span><span class="s1">_validate_hamming_kwargs(X</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">**kwargs):</span>
    <span class="s1">w = kwargs.get(</span><span class="s3">'w'</span><span class="s4">, </span><span class="s1">np.ones((n</span><span class="s4">,</span><span class="s1">)</span><span class="s4">, </span><span class="s1">dtype=</span><span class="s3">'double'</span><span class="s1">))</span>

    <span class="s4">if </span><span class="s1">w.ndim != </span><span class="s5">1 </span><span class="s4">or </span><span class="s1">w.shape[</span><span class="s5">0</span><span class="s1">] != n:</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Weights must have same size as input vector. %d vs. %d&quot; </span><span class="s1">% (w.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">, </span><span class="s1">n))</span>

    <span class="s1">kwargs[</span><span class="s3">'w'</span><span class="s1">] = _validate_weights(w)</span>
    <span class="s4">return </span><span class="s1">kwargs</span>


<span class="s4">def </span><span class="s1">_validate_mahalanobis_kwargs(X</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">**kwargs):</span>
    <span class="s1">VI = kwargs.pop(</span><span class="s3">'VI'</span><span class="s4">, None</span><span class="s1">)</span>
    <span class="s4">if </span><span class="s1">VI </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s4">if </span><span class="s1">m &lt;= n:</span>
            <span class="s2"># There are fewer observations than the dimension of</span>
            <span class="s2"># the observations.</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;The number of observations (%d) is too &quot;</span>
                             <span class="s3">&quot;small; the covariance matrix is &quot;</span>
                             <span class="s3">&quot;singular. For observations with %d &quot;</span>
                             <span class="s3">&quot;dimensions, at least %d observations &quot;</span>
                             <span class="s3">&quot;are required.&quot; </span><span class="s1">% (m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">n + </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s4">if </span><span class="s1">isinstance(X</span><span class="s4">, </span><span class="s1">tuple):</span>
            <span class="s1">X = np.vstack(X)</span>
        <span class="s1">CV = np.atleast_2d(np.cov(X.astype(np.double</span><span class="s4">, </span><span class="s1">copy=</span><span class="s4">False</span><span class="s1">).T))</span>
        <span class="s1">VI = np.linalg.inv(CV).T.copy()</span>
    <span class="s1">kwargs[</span><span class="s3">&quot;VI&quot;</span><span class="s1">] = _convert_to_double(VI)</span>
    <span class="s4">return </span><span class="s1">kwargs</span>


<span class="s4">def </span><span class="s1">_validate_minkowski_kwargs(X</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">**kwargs):</span>
    <span class="s1">kwargs = _validate_weight_with_size(X</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">**kwargs)</span>
    <span class="s4">if </span><span class="s3">'p' </span><span class="s4">not in </span><span class="s1">kwargs:</span>
        <span class="s1">kwargs[</span><span class="s3">'p'</span><span class="s1">] = </span><span class="s5">2.</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s4">if </span><span class="s1">kwargs[</span><span class="s3">'p'</span><span class="s1">] &lt;= </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;p must be greater than 0&quot;</span><span class="s1">)</span>

    <span class="s4">return </span><span class="s1">kwargs</span>


<span class="s4">def </span><span class="s1">_validate_pdist_input(X</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">metric_info</span><span class="s4">, </span><span class="s1">**kwargs):</span>
    <span class="s2"># get supported types</span>
    <span class="s1">types = metric_info.types</span>
    <span class="s2"># choose best type</span>
    <span class="s1">typ = types[types.index(X.dtype)] </span><span class="s4">if </span><span class="s1">X.dtype </span><span class="s4">in </span><span class="s1">types </span><span class="s4">else </span><span class="s1">types[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s2"># validate data</span>
    <span class="s1">X = _convert_to_type(X</span><span class="s4">, </span><span class="s1">out_type=typ)</span>

    <span class="s2"># validate kwargs</span>
    <span class="s1">_validate_kwargs = metric_info.validator</span>
    <span class="s4">if </span><span class="s1">_validate_kwargs:</span>
        <span class="s1">kwargs = _validate_kwargs(X</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">**kwargs)</span>
    <span class="s4">return </span><span class="s1">X</span><span class="s4">, </span><span class="s1">typ</span><span class="s4">, </span><span class="s1">kwargs</span>


<span class="s4">def </span><span class="s1">_validate_seuclidean_kwargs(X</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">**kwargs):</span>
    <span class="s1">V = kwargs.pop(</span><span class="s3">'V'</span><span class="s4">, None</span><span class="s1">)</span>
    <span class="s4">if </span><span class="s1">V </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s4">if </span><span class="s1">isinstance(X</span><span class="s4">, </span><span class="s1">tuple):</span>
            <span class="s1">X = np.vstack(X)</span>
        <span class="s1">V = np.var(X.astype(np.double</span><span class="s4">, </span><span class="s1">copy=</span><span class="s4">False</span><span class="s1">)</span><span class="s4">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s4">, </span><span class="s1">ddof=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s1">V = np.asarray(V</span><span class="s4">, </span><span class="s1">order=</span><span class="s3">'c'</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">len(V.shape) != </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Variance vector V must '</span>
                             <span class="s3">'be one-dimensional.'</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">V.shape[</span><span class="s5">0</span><span class="s1">] != n:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Variance vector V must be of the same '</span>
                             <span class="s3">'dimension as the vectors on which the distances '</span>
                             <span class="s3">'are computed.'</span><span class="s1">)</span>
    <span class="s1">kwargs[</span><span class="s3">'V'</span><span class="s1">] = _convert_to_double(V)</span>
    <span class="s4">return </span><span class="s1">kwargs</span>


<span class="s4">def </span><span class="s1">_validate_vector(u</span><span class="s4">, </span><span class="s1">dtype=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s2"># XXX Is order='c' really necessary?</span>
    <span class="s1">u = np.asarray(u</span><span class="s4">, </span><span class="s1">dtype=dtype</span><span class="s4">, </span><span class="s1">order=</span><span class="s3">'c'</span><span class="s1">)</span>
    <span class="s4">if </span><span class="s1">u.ndim == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s4">return </span><span class="s1">u</span>
    <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Input vector should be 1-D.&quot;</span><span class="s1">)</span>


<span class="s4">def </span><span class="s1">_validate_weights(w</span><span class="s4">, </span><span class="s1">dtype=np.double):</span>
    <span class="s1">w = _validate_vector(w</span><span class="s4">, </span><span class="s1">dtype=dtype)</span>
    <span class="s4">if </span><span class="s1">np.any(w &lt; </span><span class="s5">0</span><span class="s1">):</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Input weights should be all non-negative&quot;</span><span class="s1">)</span>
    <span class="s4">return </span><span class="s1">w</span>


<span class="s4">def </span><span class="s1">directed_hausdorff(u</span><span class="s4">, </span><span class="s1">v</span><span class="s4">, </span><span class="s1">seed=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the directed Hausdorff distance between two 2-D arrays. 
 
    Distances between pairs are calculated using a Euclidean metric. 
 
    Parameters 
    ---------- 
    u : (M,N) array_like 
        Input array. 
    v : (O,N) array_like 
        Input array. 
    seed : int or None 
        Local `numpy.random.RandomState` seed. Default is 0, a random 
        shuffling of u and v that guarantees reproducibility. 
 
    Returns 
    ------- 
    d : double 
        The directed Hausdorff distance between arrays `u` and `v`, 
 
    index_1 : int 
        index of point contributing to Hausdorff pair in `u` 
 
    index_2 : int 
        index of point contributing to Hausdorff pair in `v` 
 
    Raises 
    ------ 
    ValueError 
        An exception is thrown if `u` and `v` do not have 
        the same number of columns. 
 
    See Also 
    -------- 
    scipy.spatial.procrustes : Another similarity test for two data sets 
 
    Notes 
    ----- 
    Uses the early break technique and the random sampling approach 
    described by [1]_. Although worst-case performance is ``O(m * o)`` 
    (as with the brute force algorithm), this is unlikely in practice 
    as the input data would have to require the algorithm to explore 
    every single point interaction, and after the algorithm shuffles 
    the input points at that. The best case performance is O(m), which 
    is satisfied by selecting an inner loop distance that is less than 
    cmax and leads to an early break as often as possible. The authors 
    have formally shown that the average runtime is closer to O(m). 
 
    .. versionadded:: 0.19.0 
 
    References 
    ---------- 
    .. [1] A. A. Taha and A. Hanbury, &quot;An efficient algorithm for 
           calculating the exact Hausdorff distance.&quot; IEEE Transactions On 
           Pattern Analysis And Machine Intelligence, vol. 37 pp. 2153-63, 
           2015. 
 
    Examples 
    -------- 
    Find the directed Hausdorff distance between two 2-D arrays of 
    coordinates: 
 
    &gt;&gt;&gt; from scipy.spatial.distance import directed_hausdorff 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; u = np.array([(1.0, 0.0), 
    ...               (0.0, 1.0), 
    ...               (-1.0, 0.0), 
    ...               (0.0, -1.0)]) 
    &gt;&gt;&gt; v = np.array([(2.0, 0.0), 
    ...               (0.0, 2.0), 
    ...               (-2.0, 0.0), 
    ...               (0.0, -4.0)]) 
 
    &gt;&gt;&gt; directed_hausdorff(u, v)[0] 
    2.23606797749979 
    &gt;&gt;&gt; directed_hausdorff(v, u)[0] 
    3.0 
 
    Find the general (symmetric) Hausdorff distance between two 2-D 
    arrays of coordinates: 
 
    &gt;&gt;&gt; max(directed_hausdorff(u, v)[0], directed_hausdorff(v, u)[0]) 
    3.0 
 
    Find the indices of the points that generate the Hausdorff distance 
    (the Hausdorff pair): 
 
    &gt;&gt;&gt; directed_hausdorff(v, u)[1:] 
    (3, 3) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">u = np.asarray(u</span><span class="s4">, </span><span class="s1">dtype=np.float64</span><span class="s4">, </span><span class="s1">order=</span><span class="s3">'c'</span><span class="s1">)</span>
    <span class="s1">v = np.asarray(v</span><span class="s4">, </span><span class="s1">dtype=np.float64</span><span class="s4">, </span><span class="s1">order=</span><span class="s3">'c'</span><span class="s1">)</span>
    <span class="s4">if </span><span class="s1">u.shape[</span><span class="s5">1</span><span class="s1">] != v.shape[</span><span class="s5">1</span><span class="s1">]:</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'u and v need to have the same '</span>
                         <span class="s3">'number of columns'</span><span class="s1">)</span>
    <span class="s1">result = _hausdorff.directed_hausdorff(u</span><span class="s4">, </span><span class="s1">v</span><span class="s4">, </span><span class="s1">seed)</span>
    <span class="s4">return </span><span class="s1">result</span>


<span class="s4">def </span><span class="s1">minkowski(u</span><span class="s4">, </span><span class="s1">v</span><span class="s4">, </span><span class="s1">p=</span><span class="s5">2</span><span class="s4">, </span><span class="s1">w=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the Minkowski distance between two 1-D arrays. 
 
    The Minkowski distance between 1-D arrays `u` and `v`, 
    is defined as 
 
    .. math:: 
 
       {\\|u-v\\|}_p = (\\sum{|u_i - v_i|^p})^{1/p}. 
 
 
       \\left(\\sum{w_i(|(u_i - v_i)|^p)}\\right)^{1/p}. 
 
    Parameters 
    ---------- 
    u : (N,) array_like 
        Input array. 
    v : (N,) array_like 
        Input array. 
    p : scalar 
        The order of the norm of the difference :math:`{\\|u-v\\|}_p`. Note 
        that for :math:`0 &lt; p &lt; 1`, the triangle inequality only holds with 
        an additional multiplicative factor, i.e. it is only a quasi-metric. 
    w : (N,) array_like, optional 
        The weights for each value in `u` and `v`. Default is None, 
        which gives each value a weight of 1.0 
 
    Returns 
    ------- 
    minkowski : double 
        The Minkowski distance between vectors `u` and `v`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.spatial import distance 
    &gt;&gt;&gt; distance.minkowski([1, 0, 0], [0, 1, 0], 1) 
    2.0 
    &gt;&gt;&gt; distance.minkowski([1, 0, 0], [0, 1, 0], 2) 
    1.4142135623730951 
    &gt;&gt;&gt; distance.minkowski([1, 0, 0], [0, 1, 0], 3) 
    1.2599210498948732 
    &gt;&gt;&gt; distance.minkowski([1, 1, 0], [0, 1, 0], 1) 
    1.0 
    &gt;&gt;&gt; distance.minkowski([1, 1, 0], [0, 1, 0], 2) 
    1.0 
    &gt;&gt;&gt; distance.minkowski([1, 1, 0], [0, 1, 0], 3) 
    1.0 
 
    &quot;&quot;&quot;</span>
    <span class="s1">u = _validate_vector(u)</span>
    <span class="s1">v = _validate_vector(v)</span>
    <span class="s4">if </span><span class="s1">p &lt;= </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;p must be greater than 0&quot;</span><span class="s1">)</span>
    <span class="s1">u_v = u - v</span>
    <span class="s4">if </span><span class="s1">w </span><span class="s4">is not None</span><span class="s1">:</span>
        <span class="s1">w = _validate_weights(w)</span>
        <span class="s4">if </span><span class="s1">p == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">root_w = w</span>
        <span class="s4">elif </span><span class="s1">p == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s2"># better precision and speed</span>
            <span class="s1">root_w = np.sqrt(w)</span>
        <span class="s4">elif </span><span class="s1">p == np.inf:</span>
            <span class="s1">root_w = (w != </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">root_w = np.power(w</span><span class="s4">, </span><span class="s5">1</span><span class="s1">/p)</span>
        <span class="s1">u_v = root_w * u_v</span>
    <span class="s1">dist = norm(u_v</span><span class="s4">, </span><span class="s1">ord=p)</span>
    <span class="s4">return </span><span class="s1">dist</span>


<span class="s4">def </span><span class="s1">euclidean(u</span><span class="s4">, </span><span class="s1">v</span><span class="s4">, </span><span class="s1">w=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Computes the Euclidean distance between two 1-D arrays. 
 
    The Euclidean distance between 1-D arrays `u` and `v`, is defined as 
 
    .. math:: 
 
       {\\|u-v\\|}_2 
 
       \\left(\\sum{(w_i |(u_i - v_i)|^2)}\\right)^{1/2} 
 
    Parameters 
    ---------- 
    u : (N,) array_like 
        Input array. 
    v : (N,) array_like 
        Input array. 
    w : (N,) array_like, optional 
        The weights for each value in `u` and `v`. Default is None, 
        which gives each value a weight of 1.0 
 
    Returns 
    ------- 
    euclidean : double 
        The Euclidean distance between vectors `u` and `v`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.spatial import distance 
    &gt;&gt;&gt; distance.euclidean([1, 0, 0], [0, 1, 0]) 
    1.4142135623730951 
    &gt;&gt;&gt; distance.euclidean([1, 1, 0], [0, 1, 0]) 
    1.0 
 
    &quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">minkowski(u</span><span class="s4">, </span><span class="s1">v</span><span class="s4">, </span><span class="s1">p=</span><span class="s5">2</span><span class="s4">, </span><span class="s1">w=w)</span>


<span class="s4">def </span><span class="s1">sqeuclidean(u</span><span class="s4">, </span><span class="s1">v</span><span class="s4">, </span><span class="s1">w=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the squared Euclidean distance between two 1-D arrays. 
 
    The squared Euclidean distance between `u` and `v` is defined as 
 
    .. math:: 
 
       \\sum_i{w_i |u_i - v_i|^2} 
 
    Parameters 
    ---------- 
    u : (N,) array_like 
        Input array. 
    v : (N,) array_like 
        Input array. 
    w : (N,) array_like, optional 
        The weights for each value in `u` and `v`. Default is None, 
        which gives each value a weight of 1.0 
 
    Returns 
    ------- 
    sqeuclidean : double 
        The squared Euclidean distance between vectors `u` and `v`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.spatial import distance 
    &gt;&gt;&gt; distance.sqeuclidean([1, 0, 0], [0, 1, 0]) 
    2.0 
    &gt;&gt;&gt; distance.sqeuclidean([1, 1, 0], [0, 1, 0]) 
    1.0 
 
    &quot;&quot;&quot;</span>
    <span class="s2"># Preserve float dtypes, but convert everything else to np.float64</span>
    <span class="s2"># for stability.</span>
    <span class="s1">utype</span><span class="s4">, </span><span class="s1">vtype = </span><span class="s4">None, None</span>
    <span class="s4">if not </span><span class="s1">(hasattr(u</span><span class="s4">, </span><span class="s3">&quot;dtype&quot;</span><span class="s1">) </span><span class="s4">and </span><span class="s1">np.issubdtype(u.dtype</span><span class="s4">, </span><span class="s1">np.inexact)):</span>
        <span class="s1">utype = np.float64</span>
    <span class="s4">if not </span><span class="s1">(hasattr(v</span><span class="s4">, </span><span class="s3">&quot;dtype&quot;</span><span class="s1">) </span><span class="s4">and </span><span class="s1">np.issubdtype(v.dtype</span><span class="s4">, </span><span class="s1">np.inexact)):</span>
        <span class="s1">vtype = np.float64</span>

    <span class="s1">u = _validate_vector(u</span><span class="s4">, </span><span class="s1">dtype=utype)</span>
    <span class="s1">v = _validate_vector(v</span><span class="s4">, </span><span class="s1">dtype=vtype)</span>
    <span class="s1">u_v = u - v</span>
    <span class="s1">u_v_w = u_v  </span><span class="s2"># only want weights applied once</span>
    <span class="s4">if </span><span class="s1">w </span><span class="s4">is not None</span><span class="s1">:</span>
        <span class="s1">w = _validate_weights(w)</span>
        <span class="s1">u_v_w = w * u_v</span>
    <span class="s4">return </span><span class="s1">np.dot(u_v</span><span class="s4">, </span><span class="s1">u_v_w)</span>


<span class="s4">def </span><span class="s1">correlation(u</span><span class="s4">, </span><span class="s1">v</span><span class="s4">, </span><span class="s1">w=</span><span class="s4">None, </span><span class="s1">centered=</span><span class="s4">True</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the correlation distance between two 1-D arrays. 
 
    The correlation distance between `u` and `v`, is 
    defined as 
 
    .. math:: 
 
        1 - \\frac{(u - \\bar{u}) \\cdot (v - \\bar{v})} 
                  {{\\|(u - \\bar{u})\\|}_2 {\\|(v - \\bar{v})\\|}_2} 
 
    where :math:`\\bar{u}` is the mean of the elements of `u` 
    and :math:`x \\cdot y` is the dot product of :math:`x` and :math:`y`. 
 
    Parameters 
    ---------- 
    u : (N,) array_like 
        Input array. 
    v : (N,) array_like 
        Input array. 
    w : (N,) array_like, optional 
        The weights for each value in `u` and `v`. Default is None, 
        which gives each value a weight of 1.0 
    centered : bool, optional 
        If True, `u` and `v` will be centered. Default is True. 
 
    Returns 
    ------- 
    correlation : double 
        The correlation distance between 1-D array `u` and `v`. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">u = _validate_vector(u)</span>
    <span class="s1">v = _validate_vector(v)</span>
    <span class="s4">if </span><span class="s1">w </span><span class="s4">is not None</span><span class="s1">:</span>
        <span class="s1">w = _validate_weights(w)</span>
    <span class="s4">if </span><span class="s1">centered:</span>
        <span class="s1">umu = np.average(u</span><span class="s4">, </span><span class="s1">weights=w)</span>
        <span class="s1">vmu = np.average(v</span><span class="s4">, </span><span class="s1">weights=w)</span>
        <span class="s1">u = u - umu</span>
        <span class="s1">v = v - vmu</span>
    <span class="s1">uv = np.average(u * v</span><span class="s4">, </span><span class="s1">weights=w)</span>
    <span class="s1">uu = np.average(np.square(u)</span><span class="s4">, </span><span class="s1">weights=w)</span>
    <span class="s1">vv = np.average(np.square(v)</span><span class="s4">, </span><span class="s1">weights=w)</span>
    <span class="s1">dist = </span><span class="s5">1.0 </span><span class="s1">- uv / np.sqrt(uu * vv)</span>
    <span class="s2"># Return absolute value to avoid small negative value due to rounding</span>
    <span class="s4">return </span><span class="s1">np.abs(dist)</span>


<span class="s4">def </span><span class="s1">cosine(u</span><span class="s4">, </span><span class="s1">v</span><span class="s4">, </span><span class="s1">w=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the Cosine distance between 1-D arrays. 
 
    The Cosine distance between `u` and `v`, is defined as 
 
    .. math:: 
 
        1 - \\frac{u \\cdot v} 
                  {\\|u\\|_2 \\|v\\|_2}. 
 
    where :math:`u \\cdot v` is the dot product of :math:`u` and 
    :math:`v`. 
 
    Parameters 
    ---------- 
    u : (N,) array_like 
        Input array. 
    v : (N,) array_like 
        Input array. 
    w : (N,) array_like, optional 
        The weights for each value in `u` and `v`. Default is None, 
        which gives each value a weight of 1.0 
 
    Returns 
    ------- 
    cosine : double 
        The Cosine distance between vectors `u` and `v`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.spatial import distance 
    &gt;&gt;&gt; distance.cosine([1, 0, 0], [0, 1, 0]) 
    1.0 
    &gt;&gt;&gt; distance.cosine([100, 0, 0], [0, 1, 0]) 
    1.0 
    &gt;&gt;&gt; distance.cosine([1, 1, 0], [0, 1, 0]) 
    0.29289321881345254 
 
    &quot;&quot;&quot;</span>
    <span class="s2"># cosine distance is also referred to as 'uncentered correlation',</span>
    <span class="s2">#   or 'reflective correlation'</span>
    <span class="s2"># clamp the result to 0-2</span>
    <span class="s4">return </span><span class="s1">max(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">min(correlation(u</span><span class="s4">, </span><span class="s1">v</span><span class="s4">, </span><span class="s1">w=w</span><span class="s4">, </span><span class="s1">centered=</span><span class="s4">False</span><span class="s1">)</span><span class="s4">, </span><span class="s5">2.0</span><span class="s1">))</span>


<span class="s4">def </span><span class="s1">hamming(u</span><span class="s4">, </span><span class="s1">v</span><span class="s4">, </span><span class="s1">w=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the Hamming distance between two 1-D arrays. 
 
    The Hamming distance between 1-D arrays `u` and `v`, is simply the 
    proportion of disagreeing components in `u` and `v`. If `u` and `v` are 
    boolean vectors, the Hamming distance is 
 
    .. math:: 
 
       \\frac{c_{01} + c_{10}}{n} 
 
    where :math:`c_{ij}` is the number of occurrences of 
    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for 
    :math:`k &lt; n`. 
 
    Parameters 
    ---------- 
    u : (N,) array_like 
        Input array. 
    v : (N,) array_like 
        Input array. 
    w : (N,) array_like, optional 
        The weights for each value in `u` and `v`. Default is None, 
        which gives each value a weight of 1.0 
 
    Returns 
    ------- 
    hamming : double 
        The Hamming distance between vectors `u` and `v`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.spatial import distance 
    &gt;&gt;&gt; distance.hamming([1, 0, 0], [0, 1, 0]) 
    0.66666666666666663 
    &gt;&gt;&gt; distance.hamming([1, 0, 0], [1, 1, 0]) 
    0.33333333333333331 
    &gt;&gt;&gt; distance.hamming([1, 0, 0], [2, 0, 0]) 
    0.33333333333333331 
    &gt;&gt;&gt; distance.hamming([1, 0, 0], [3, 0, 0]) 
    0.33333333333333331 
 
    &quot;&quot;&quot;</span>
    <span class="s1">u = _validate_vector(u)</span>
    <span class="s1">v = _validate_vector(v)</span>
    <span class="s4">if </span><span class="s1">u.shape != v.shape:</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'The 1d arrays must have equal lengths.'</span><span class="s1">)</span>
    <span class="s1">u_ne_v = u != v</span>
    <span class="s4">if </span><span class="s1">w </span><span class="s4">is not None</span><span class="s1">:</span>
        <span class="s1">w = _validate_weights(w)</span>
        <span class="s4">if </span><span class="s1">w.shape != u.shape:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;'w' should have the same length as 'u' and 'v'.&quot;</span><span class="s1">)</span>
    <span class="s4">return </span><span class="s1">np.average(u_ne_v</span><span class="s4">, </span><span class="s1">weights=w)</span>


<span class="s4">def </span><span class="s1">jaccard(u</span><span class="s4">, </span><span class="s1">v</span><span class="s4">, </span><span class="s1">w=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the Jaccard-Needham dissimilarity between two boolean 1-D arrays. 
 
    The Jaccard-Needham dissimilarity between 1-D boolean arrays `u` and `v`, 
    is defined as 
 
    .. math:: 
 
       \\frac{c_{TF} + c_{FT}} 
            {c_{TT} + c_{FT} + c_{TF}} 
 
    where :math:`c_{ij}` is the number of occurrences of 
    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for 
    :math:`k &lt; n`. 
 
    Parameters 
    ---------- 
    u : (N,) array_like, bool 
        Input array. 
    v : (N,) array_like, bool 
        Input array. 
    w : (N,) array_like, optional 
        The weights for each value in `u` and `v`. Default is None, 
        which gives each value a weight of 1.0 
 
    Returns 
    ------- 
    jaccard : double 
        The Jaccard distance between vectors `u` and `v`. 
 
    Notes 
    ----- 
    When both `u` and `v` lead to a `0/0` division i.e. there is no overlap 
    between the items in the vectors the returned distance is 0. See the 
    Wikipedia page on the Jaccard index [1]_, and this paper [2]_. 
 
    .. versionchanged:: 1.2.0 
        Previously, when `u` and `v` lead to a `0/0` division, the function 
        would return NaN. This was changed to return 0 instead. 
 
    References 
    ---------- 
    .. [1] https://en.wikipedia.org/wiki/Jaccard_index 
    .. [2] S. Kosub, &quot;A note on the triangle inequality for the Jaccard 
       distance&quot;, 2016, :arxiv:`1612.02696` 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.spatial import distance 
    &gt;&gt;&gt; distance.jaccard([1, 0, 0], [0, 1, 0]) 
    1.0 
    &gt;&gt;&gt; distance.jaccard([1, 0, 0], [1, 1, 0]) 
    0.5 
    &gt;&gt;&gt; distance.jaccard([1, 0, 0], [1, 2, 0]) 
    0.5 
    &gt;&gt;&gt; distance.jaccard([1, 0, 0], [1, 1, 1]) 
    0.66666666666666663 
 
    &quot;&quot;&quot;</span>
    <span class="s1">u = _validate_vector(u)</span>
    <span class="s1">v = _validate_vector(v)</span>

    <span class="s1">nonzero = np.bitwise_or(u != </span><span class="s5">0</span><span class="s4">, </span><span class="s1">v != </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">unequal_nonzero = np.bitwise_and((u != v)</span><span class="s4">, </span><span class="s1">nonzero)</span>
    <span class="s4">if </span><span class="s1">w </span><span class="s4">is not None</span><span class="s1">:</span>
        <span class="s1">w = _validate_weights(w)</span>
        <span class="s1">nonzero = w * nonzero</span>
        <span class="s1">unequal_nonzero = w * unequal_nonzero</span>
    <span class="s1">a = np.double(unequal_nonzero.sum())</span>
    <span class="s1">b = np.double(nonzero.sum())</span>
    <span class="s4">return </span><span class="s1">(a / b) </span><span class="s4">if </span><span class="s1">b != </span><span class="s5">0 </span><span class="s4">else </span><span class="s5">0</span>


<span class="s4">def </span><span class="s1">kulczynski1(u</span><span class="s4">, </span><span class="s1">v</span><span class="s4">, </span><span class="s1">*</span><span class="s4">, </span><span class="s1">w=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the Kulczynski 1 dissimilarity between two boolean 1-D arrays. 
 
    The Kulczynski 1 dissimilarity between two boolean 1-D arrays `u` and `v` 
    of length ``n``, is defined as 
 
    .. math:: 
 
         \\frac{c_{11}} 
              {c_{01} + c_{10}} 
 
    where :math:`c_{ij}` is the number of occurrences of 
    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for 
    :math:`k \\in {0, 1, ..., n-1}`. 
 
    Parameters 
    ---------- 
    u : (N,) array_like, bool 
        Input array. 
    v : (N,) array_like, bool 
        Input array. 
    w : (N,) array_like, optional 
        The weights for each value in `u` and `v`. Default is None, 
        which gives each value a weight of 1.0 
 
    Returns 
    ------- 
    kulczynski1 : float 
        The Kulczynski 1 distance between vectors `u` and `v`. 
 
    Notes 
    ----- 
    This measure has a minimum value of 0 and no upper limit. 
    It is un-defined when there are no non-matches. 
 
    .. versionadded:: 1.8.0 
 
    References 
    ---------- 
    .. [1] Kulczynski S. et al. Bulletin 
           International de l'Academie Polonaise des Sciences 
           et des Lettres, Classe des Sciences Mathematiques 
           et Naturelles, Serie B (Sciences Naturelles). 1927; 
           Supplement II: 57-203. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.spatial import distance 
    &gt;&gt;&gt; distance.kulczynski1([1, 0, 0], [0, 1, 0]) 
    0.0 
    &gt;&gt;&gt; distance.kulczynski1([True, False, False], [True, True, False]) 
    1.0 
    &gt;&gt;&gt; distance.kulczynski1([True, False, False], [True]) 
    0.5 
    &gt;&gt;&gt; distance.kulczynski1([1, 0, 0], [3, 1, 0]) 
    -3.0 
 
    &quot;&quot;&quot;</span>
    <span class="s1">u = _validate_vector(u)</span>
    <span class="s1">v = _validate_vector(v)</span>
    <span class="s4">if </span><span class="s1">w </span><span class="s4">is not None</span><span class="s1">:</span>
        <span class="s1">w = _validate_weights(w)</span>
    <span class="s1">(_</span><span class="s4">, </span><span class="s1">nft</span><span class="s4">, </span><span class="s1">ntf</span><span class="s4">, </span><span class="s1">ntt) = _nbool_correspond_all(u</span><span class="s4">, </span><span class="s1">v</span><span class="s4">, </span><span class="s1">w=w)</span>

    <span class="s4">return </span><span class="s1">ntt / (ntf + nft)</span>


<span class="s4">def </span><span class="s1">seuclidean(u</span><span class="s4">, </span><span class="s1">v</span><span class="s4">, </span><span class="s1">V):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the standardized Euclidean distance between two 1-D arrays. 
 
    The standardized Euclidean distance between two n-vectors `u` and `v` is 
 
    .. math:: 
 
       \\sqrt{\\sum\\limits_i \\frac{1}{V_i} \\left(u_i-v_i \\right)^2} 
 
    ``V`` is the variance vector; ``V[I]`` is the variance computed over all the i-th 
    components of the points. If not passed, it is automatically computed. 
 
    Parameters 
    ---------- 
    u : (N,) array_like 
        Input array. 
    v : (N,) array_like 
        Input array. 
    V : (N,) array_like 
        `V` is an 1-D array of component variances. It is usually computed 
        among a larger collection vectors. 
 
    Returns 
    ------- 
    seuclidean : double 
        The standardized Euclidean distance between vectors `u` and `v`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.spatial import distance 
    &gt;&gt;&gt; distance.seuclidean([1, 0, 0], [0, 1, 0], [0.1, 0.1, 0.1]) 
    4.4721359549995796 
    &gt;&gt;&gt; distance.seuclidean([1, 0, 0], [0, 1, 0], [1, 0.1, 0.1]) 
    3.3166247903553998 
    &gt;&gt;&gt; distance.seuclidean([1, 0, 0], [0, 1, 0], [10, 0.1, 0.1]) 
    3.1780497164141406 
 
    &quot;&quot;&quot;</span>
    <span class="s1">u = _validate_vector(u)</span>
    <span class="s1">v = _validate_vector(v)</span>
    <span class="s1">V = _validate_vector(V</span><span class="s4">, </span><span class="s1">dtype=np.float64)</span>
    <span class="s4">if </span><span class="s1">V.shape[</span><span class="s5">0</span><span class="s1">] != u.shape[</span><span class="s5">0</span><span class="s1">] </span><span class="s4">or </span><span class="s1">u.shape[</span><span class="s5">0</span><span class="s1">] != v.shape[</span><span class="s5">0</span><span class="s1">]:</span>
        <span class="s4">raise </span><span class="s1">TypeError(</span><span class="s3">'V must be a 1-D array of the same dimension '</span>
                        <span class="s3">'as u and v.'</span><span class="s1">)</span>
    <span class="s4">return </span><span class="s1">euclidean(u</span><span class="s4">, </span><span class="s1">v</span><span class="s4">, </span><span class="s1">w=</span><span class="s5">1</span><span class="s1">/V)</span>


<span class="s4">def </span><span class="s1">cityblock(u</span><span class="s4">, </span><span class="s1">v</span><span class="s4">, </span><span class="s1">w=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the City Block (Manhattan) distance. 
 
    Computes the Manhattan distance between two 1-D arrays `u` and `v`, 
    which is defined as 
 
    .. math:: 
 
       \\sum_i {\\left| u_i - v_i \\right|}. 
 
    Parameters 
    ---------- 
    u : (N,) array_like 
        Input array. 
    v : (N,) array_like 
        Input array. 
    w : (N,) array_like, optional 
        The weights for each value in `u` and `v`. Default is None, 
        which gives each value a weight of 1.0 
 
    Returns 
    ------- 
    cityblock : double 
        The City Block (Manhattan) distance between vectors `u` and `v`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.spatial import distance 
    &gt;&gt;&gt; distance.cityblock([1, 0, 0], [0, 1, 0]) 
    2 
    &gt;&gt;&gt; distance.cityblock([1, 0, 0], [0, 2, 0]) 
    3 
    &gt;&gt;&gt; distance.cityblock([1, 0, 0], [1, 1, 0]) 
    1 
 
    &quot;&quot;&quot;</span>
    <span class="s1">u = _validate_vector(u)</span>
    <span class="s1">v = _validate_vector(v)</span>
    <span class="s1">l1_diff = abs(u - v)</span>
    <span class="s4">if </span><span class="s1">w </span><span class="s4">is not None</span><span class="s1">:</span>
        <span class="s1">w = _validate_weights(w)</span>
        <span class="s1">l1_diff = w * l1_diff</span>
    <span class="s4">return </span><span class="s1">l1_diff.sum()</span>


<span class="s4">def </span><span class="s1">mahalanobis(u</span><span class="s4">, </span><span class="s1">v</span><span class="s4">, </span><span class="s1">VI):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the Mahalanobis distance between two 1-D arrays. 
 
    The Mahalanobis distance between 1-D arrays `u` and `v`, is defined as 
 
    .. math:: 
 
       \\sqrt{ (u-v) V^{-1} (u-v)^T } 
 
    where ``V`` is the covariance matrix.  Note that the argument `VI` 
    is the inverse of ``V``. 
 
    Parameters 
    ---------- 
    u : (N,) array_like 
        Input array. 
    v : (N,) array_like 
        Input array. 
    VI : array_like 
        The inverse of the covariance matrix. 
 
    Returns 
    ------- 
    mahalanobis : double 
        The Mahalanobis distance between vectors `u` and `v`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.spatial import distance 
    &gt;&gt;&gt; iv = [[1, 0.5, 0.5], [0.5, 1, 0.5], [0.5, 0.5, 1]] 
    &gt;&gt;&gt; distance.mahalanobis([1, 0, 0], [0, 1, 0], iv) 
    1.0 
    &gt;&gt;&gt; distance.mahalanobis([0, 2, 0], [0, 1, 0], iv) 
    1.0 
    &gt;&gt;&gt; distance.mahalanobis([2, 0, 0], [0, 1, 0], iv) 
    1.7320508075688772 
 
    &quot;&quot;&quot;</span>
    <span class="s1">u = _validate_vector(u)</span>
    <span class="s1">v = _validate_vector(v)</span>
    <span class="s1">VI = np.atleast_2d(VI)</span>
    <span class="s1">delta = u - v</span>
    <span class="s1">m = np.dot(np.dot(delta</span><span class="s4">, </span><span class="s1">VI)</span><span class="s4">, </span><span class="s1">delta)</span>
    <span class="s4">return </span><span class="s1">np.sqrt(m)</span>


<span class="s4">def </span><span class="s1">chebyshev(u</span><span class="s4">, </span><span class="s1">v</span><span class="s4">, </span><span class="s1">w=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the Chebyshev distance. 
 
    Computes the Chebyshev distance between two 1-D arrays `u` and `v`, 
    which is defined as 
 
    .. math:: 
 
       \\max_i {|u_i-v_i|}. 
 
    Parameters 
    ---------- 
    u : (N,) array_like 
        Input vector. 
    v : (N,) array_like 
        Input vector. 
    w : (N,) array_like, optional 
        Unused, as 'max' is a weightless operation. Here for API consistency. 
 
    Returns 
    ------- 
    chebyshev : double 
        The Chebyshev distance between vectors `u` and `v`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.spatial import distance 
    &gt;&gt;&gt; distance.chebyshev([1, 0, 0], [0, 1, 0]) 
    1 
    &gt;&gt;&gt; distance.chebyshev([1, 1, 0], [0, 1, 0]) 
    1 
 
    &quot;&quot;&quot;</span>
    <span class="s1">u = _validate_vector(u)</span>
    <span class="s1">v = _validate_vector(v)</span>
    <span class="s4">if </span><span class="s1">w </span><span class="s4">is not None</span><span class="s1">:</span>
        <span class="s1">w = _validate_weights(w)</span>
        <span class="s1">has_weight = w &gt; </span><span class="s5">0</span>
        <span class="s4">if </span><span class="s1">has_weight.sum() &lt; w.size:</span>
            <span class="s1">u = u[has_weight]</span>
            <span class="s1">v = v[has_weight]</span>
    <span class="s4">return </span><span class="s1">max(abs(u - v))</span>


<span class="s4">def </span><span class="s1">braycurtis(u</span><span class="s4">, </span><span class="s1">v</span><span class="s4">, </span><span class="s1">w=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the Bray-Curtis distance between two 1-D arrays. 
 
    Bray-Curtis distance is defined as 
 
    .. math:: 
 
       \\sum{|u_i-v_i|} / \\sum{|u_i+v_i|} 
 
    The Bray-Curtis distance is in the range [0, 1] if all coordinates are 
    positive, and is undefined if the inputs are of length zero. 
 
    Parameters 
    ---------- 
    u : (N,) array_like 
        Input array. 
    v : (N,) array_like 
        Input array. 
    w : (N,) array_like, optional 
        The weights for each value in `u` and `v`. Default is None, 
        which gives each value a weight of 1.0 
 
    Returns 
    ------- 
    braycurtis : double 
        The Bray-Curtis distance between 1-D arrays `u` and `v`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.spatial import distance 
    &gt;&gt;&gt; distance.braycurtis([1, 0, 0], [0, 1, 0]) 
    1.0 
    &gt;&gt;&gt; distance.braycurtis([1, 1, 0], [0, 1, 0]) 
    0.33333333333333331 
 
    &quot;&quot;&quot;</span>
    <span class="s1">u = _validate_vector(u)</span>
    <span class="s1">v = _validate_vector(v</span><span class="s4">, </span><span class="s1">dtype=np.float64)</span>
    <span class="s1">l1_diff = abs(u - v)</span>
    <span class="s1">l1_sum = abs(u + v)</span>
    <span class="s4">if </span><span class="s1">w </span><span class="s4">is not None</span><span class="s1">:</span>
        <span class="s1">w = _validate_weights(w)</span>
        <span class="s1">l1_diff = w * l1_diff</span>
        <span class="s1">l1_sum = w * l1_sum</span>
    <span class="s4">return </span><span class="s1">l1_diff.sum() / l1_sum.sum()</span>


<span class="s4">def </span><span class="s1">canberra(u</span><span class="s4">, </span><span class="s1">v</span><span class="s4">, </span><span class="s1">w=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the Canberra distance between two 1-D arrays. 
 
    The Canberra distance is defined as 
 
    .. math:: 
 
         d(u,v) = \\sum_i \\frac{|u_i-v_i|} 
                              {|u_i|+|v_i|}. 
 
    Parameters 
    ---------- 
    u : (N,) array_like 
        Input array. 
    v : (N,) array_like 
        Input array. 
    w : (N,) array_like, optional 
        The weights for each value in `u` and `v`. Default is None, 
        which gives each value a weight of 1.0 
 
    Returns 
    ------- 
    canberra : double 
        The Canberra distance between vectors `u` and `v`. 
 
    Notes 
    ----- 
    When `u[i]` and `v[i]` are 0 for given i, then the fraction 0/0 = 0 is 
    used in the calculation. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.spatial import distance 
    &gt;&gt;&gt; distance.canberra([1, 0, 0], [0, 1, 0]) 
    2.0 
    &gt;&gt;&gt; distance.canberra([1, 1, 0], [0, 1, 0]) 
    1.0 
 
    &quot;&quot;&quot;</span>
    <span class="s1">u = _validate_vector(u)</span>
    <span class="s1">v = _validate_vector(v</span><span class="s4">, </span><span class="s1">dtype=np.float64)</span>
    <span class="s4">if </span><span class="s1">w </span><span class="s4">is not None</span><span class="s1">:</span>
        <span class="s1">w = _validate_weights(w)</span>
    <span class="s4">with </span><span class="s1">np.errstate(invalid=</span><span class="s3">'ignore'</span><span class="s1">):</span>
        <span class="s1">abs_uv = abs(u - v)</span>
        <span class="s1">abs_u = abs(u)</span>
        <span class="s1">abs_v = abs(v)</span>
        <span class="s1">d = abs_uv / (abs_u + abs_v)</span>
        <span class="s4">if </span><span class="s1">w </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">d = w * d</span>
        <span class="s1">d = np.nansum(d)</span>
    <span class="s4">return </span><span class="s1">d</span>


<span class="s4">def </span><span class="s1">jensenshannon(p</span><span class="s4">, </span><span class="s1">q</span><span class="s4">, </span><span class="s1">base=</span><span class="s4">None, </span><span class="s1">*</span><span class="s4">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s4">, </span><span class="s1">keepdims=</span><span class="s4">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the Jensen-Shannon distance (metric) between 
    two probability arrays. This is the square root 
    of the Jensen-Shannon divergence. 
 
    The Jensen-Shannon distance between two probability 
    vectors `p` and `q` is defined as, 
 
    .. math:: 
 
       \\sqrt{\\frac{D(p \\parallel m) + D(q \\parallel m)}{2}} 
 
    where :math:`m` is the pointwise mean of :math:`p` and :math:`q` 
    and :math:`D` is the Kullback-Leibler divergence. 
 
    This routine will normalize `p` and `q` if they don't sum to 1.0. 
 
    Parameters 
    ---------- 
    p : (N,) array_like 
        left probability vector 
    q : (N,) array_like 
        right probability vector 
    base : double, optional 
        the base of the logarithm used to compute the output 
        if not given, then the routine uses the default base of 
        scipy.stats.entropy. 
    axis : int, optional 
        Axis along which the Jensen-Shannon distances are computed. The default 
        is 0. 
 
        .. versionadded:: 1.7.0 
    keepdims : bool, optional 
        If this is set to `True`, the reduced axes are left in the 
        result as dimensions with size one. With this option, 
        the result will broadcast correctly against the input array. 
        Default is False. 
 
        .. versionadded:: 1.7.0 
 
    Returns 
    ------- 
    js : double or ndarray 
        The Jensen-Shannon distances between `p` and `q` along the `axis`. 
 
    Notes 
    ----- 
 
    .. versionadded:: 1.2.0 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.spatial import distance 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; distance.jensenshannon([1.0, 0.0, 0.0], [0.0, 1.0, 0.0], 2.0) 
    1.0 
    &gt;&gt;&gt; distance.jensenshannon([1.0, 0.0], [0.5, 0.5]) 
    0.46450140402245893 
    &gt;&gt;&gt; distance.jensenshannon([1.0, 0.0, 0.0], [1.0, 0.0, 0.0]) 
    0.0 
    &gt;&gt;&gt; a = np.array([[1, 2, 3, 4], 
    ...               [5, 6, 7, 8], 
    ...               [9, 10, 11, 12]]) 
    &gt;&gt;&gt; b = np.array([[13, 14, 15, 16], 
    ...               [17, 18, 19, 20], 
    ...               [21, 22, 23, 24]]) 
    &gt;&gt;&gt; distance.jensenshannon(a, b, axis=0) 
    array([0.1954288, 0.1447697, 0.1138377, 0.0927636]) 
    &gt;&gt;&gt; distance.jensenshannon(a, b, axis=1) 
    array([0.1402339, 0.0399106, 0.0201815]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">p = np.asarray(p)</span>
    <span class="s1">q = np.asarray(q)</span>
    <span class="s1">p = p / np.sum(p</span><span class="s4">, </span><span class="s1">axis=axis</span><span class="s4">, </span><span class="s1">keepdims=</span><span class="s4">True</span><span class="s1">)</span>
    <span class="s1">q = q / np.sum(q</span><span class="s4">, </span><span class="s1">axis=axis</span><span class="s4">, </span><span class="s1">keepdims=</span><span class="s4">True</span><span class="s1">)</span>
    <span class="s1">m = (p + q) / </span><span class="s5">2.0</span>
    <span class="s1">left = rel_entr(p</span><span class="s4">, </span><span class="s1">m)</span>
    <span class="s1">right = rel_entr(q</span><span class="s4">, </span><span class="s1">m)</span>
    <span class="s1">left_sum = np.sum(left</span><span class="s4">, </span><span class="s1">axis=axis</span><span class="s4">, </span><span class="s1">keepdims=keepdims)</span>
    <span class="s1">right_sum = np.sum(right</span><span class="s4">, </span><span class="s1">axis=axis</span><span class="s4">, </span><span class="s1">keepdims=keepdims)</span>
    <span class="s1">js = left_sum + right_sum</span>
    <span class="s4">if </span><span class="s1">base </span><span class="s4">is not None</span><span class="s1">:</span>
        <span class="s1">js /= np.log(base)</span>
    <span class="s4">return </span><span class="s1">np.sqrt(js / </span><span class="s5">2.0</span><span class="s1">)</span>


<span class="s4">def </span><span class="s1">yule(u</span><span class="s4">, </span><span class="s1">v</span><span class="s4">, </span><span class="s1">w=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the Yule dissimilarity between two boolean 1-D arrays. 
 
    The Yule dissimilarity is defined as 
 
    .. math:: 
 
         \\frac{R}{c_{TT} * c_{FF} + \\frac{R}{2}} 
 
    where :math:`c_{ij}` is the number of occurrences of 
    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for 
    :math:`k &lt; n` and :math:`R = 2.0 * c_{TF} * c_{FT}`. 
 
    Parameters 
    ---------- 
    u : (N,) array_like, bool 
        Input array. 
    v : (N,) array_like, bool 
        Input array. 
    w : (N,) array_like, optional 
        The weights for each value in `u` and `v`. Default is None, 
        which gives each value a weight of 1.0 
 
    Returns 
    ------- 
    yule : double 
        The Yule dissimilarity between vectors `u` and `v`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.spatial import distance 
    &gt;&gt;&gt; distance.yule([1, 0, 0], [0, 1, 0]) 
    2.0 
    &gt;&gt;&gt; distance.yule([1, 1, 0], [0, 1, 0]) 
    0.0 
 
    &quot;&quot;&quot;</span>
    <span class="s1">u = _validate_vector(u)</span>
    <span class="s1">v = _validate_vector(v)</span>
    <span class="s4">if </span><span class="s1">w </span><span class="s4">is not None</span><span class="s1">:</span>
        <span class="s1">w = _validate_weights(w)</span>
    <span class="s1">(nff</span><span class="s4">, </span><span class="s1">nft</span><span class="s4">, </span><span class="s1">ntf</span><span class="s4">, </span><span class="s1">ntt) = _nbool_correspond_all(u</span><span class="s4">, </span><span class="s1">v</span><span class="s4">, </span><span class="s1">w=w)</span>
    <span class="s1">half_R = ntf * nft</span>
    <span class="s4">if </span><span class="s1">half_R == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s4">return </span><span class="s5">0.0</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s4">return </span><span class="s1">float(</span><span class="s5">2.0 </span><span class="s1">* half_R / (ntt * nff + half_R))</span>


<span class="s4">def </span><span class="s1">dice(u</span><span class="s4">, </span><span class="s1">v</span><span class="s4">, </span><span class="s1">w=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the Dice dissimilarity between two boolean 1-D arrays. 
 
    The Dice dissimilarity between `u` and `v`, is 
 
    .. math:: 
 
         \\frac{c_{TF} + c_{FT}} 
              {2c_{TT} + c_{FT} + c_{TF}} 
 
    where :math:`c_{ij}` is the number of occurrences of 
    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for 
    :math:`k &lt; n`. 
 
    Parameters 
    ---------- 
    u : (N,) array_like, bool 
        Input 1-D array. 
    v : (N,) array_like, bool 
        Input 1-D array. 
    w : (N,) array_like, optional 
        The weights for each value in `u` and `v`. Default is None, 
        which gives each value a weight of 1.0 
 
    Returns 
    ------- 
    dice : double 
        The Dice dissimilarity between 1-D arrays `u` and `v`. 
 
    Notes 
    ----- 
    This function computes the Dice dissimilarity index. To compute the 
    Dice similarity index, convert one to the other with similarity = 
    1 - dissimilarity. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.spatial import distance 
    &gt;&gt;&gt; distance.dice([1, 0, 0], [0, 1, 0]) 
    1.0 
    &gt;&gt;&gt; distance.dice([1, 0, 0], [1, 1, 0]) 
    0.3333333333333333 
    &gt;&gt;&gt; distance.dice([1, 0, 0], [2, 0, 0]) 
    -0.3333333333333333 
 
    &quot;&quot;&quot;</span>
    <span class="s1">u = _validate_vector(u)</span>
    <span class="s1">v = _validate_vector(v)</span>
    <span class="s4">if </span><span class="s1">w </span><span class="s4">is not None</span><span class="s1">:</span>
        <span class="s1">w = _validate_weights(w)</span>
    <span class="s4">if </span><span class="s1">u.dtype == v.dtype == bool </span><span class="s4">and </span><span class="s1">w </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s1">ntt = (u &amp; v).sum()</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s1">dtype = np.result_type(int</span><span class="s4">, </span><span class="s1">u.dtype</span><span class="s4">, </span><span class="s1">v.dtype)</span>
        <span class="s1">u = u.astype(dtype)</span>
        <span class="s1">v = v.astype(dtype)</span>
        <span class="s4">if </span><span class="s1">w </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">ntt = (u * v).sum()</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">ntt = (u * v * w).sum()</span>
    <span class="s1">(nft</span><span class="s4">, </span><span class="s1">ntf) = _nbool_correspond_ft_tf(u</span><span class="s4">, </span><span class="s1">v</span><span class="s4">, </span><span class="s1">w=w)</span>
    <span class="s4">return </span><span class="s1">float((ntf + nft) / np.array(</span><span class="s5">2.0 </span><span class="s1">* ntt + ntf + nft))</span>


<span class="s4">def </span><span class="s1">rogerstanimoto(u</span><span class="s4">, </span><span class="s1">v</span><span class="s4">, </span><span class="s1">w=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the Rogers-Tanimoto dissimilarity between two boolean 1-D arrays. 
 
    The Rogers-Tanimoto dissimilarity between two boolean 1-D arrays 
    `u` and `v`, is defined as 
 
    .. math:: 
       \\frac{R} 
            {c_{TT} + c_{FF} + R} 
 
    where :math:`c_{ij}` is the number of occurrences of 
    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for 
    :math:`k &lt; n` and :math:`R = 2(c_{TF} + c_{FT})`. 
 
    Parameters 
    ---------- 
    u : (N,) array_like, bool 
        Input array. 
    v : (N,) array_like, bool 
        Input array. 
    w : (N,) array_like, optional 
        The weights for each value in `u` and `v`. Default is None, 
        which gives each value a weight of 1.0 
 
    Returns 
    ------- 
    rogerstanimoto : double 
        The Rogers-Tanimoto dissimilarity between vectors 
        `u` and `v`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.spatial import distance 
    &gt;&gt;&gt; distance.rogerstanimoto([1, 0, 0], [0, 1, 0]) 
    0.8 
    &gt;&gt;&gt; distance.rogerstanimoto([1, 0, 0], [1, 1, 0]) 
    0.5 
    &gt;&gt;&gt; distance.rogerstanimoto([1, 0, 0], [2, 0, 0]) 
    -1.0 
 
    &quot;&quot;&quot;</span>
    <span class="s1">u = _validate_vector(u)</span>
    <span class="s1">v = _validate_vector(v)</span>
    <span class="s4">if </span><span class="s1">w </span><span class="s4">is not None</span><span class="s1">:</span>
        <span class="s1">w = _validate_weights(w)</span>
    <span class="s1">(nff</span><span class="s4">, </span><span class="s1">nft</span><span class="s4">, </span><span class="s1">ntf</span><span class="s4">, </span><span class="s1">ntt) = _nbool_correspond_all(u</span><span class="s4">, </span><span class="s1">v</span><span class="s4">, </span><span class="s1">w=w)</span>
    <span class="s4">return </span><span class="s1">float(</span><span class="s5">2.0 </span><span class="s1">* (ntf + nft)) / float(ntt + nff + (</span><span class="s5">2.0 </span><span class="s1">* (ntf + nft)))</span>


<span class="s4">def </span><span class="s1">russellrao(u</span><span class="s4">, </span><span class="s1">v</span><span class="s4">, </span><span class="s1">w=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the Russell-Rao dissimilarity between two boolean 1-D arrays. 
 
    The Russell-Rao dissimilarity between two boolean 1-D arrays, `u` and 
    `v`, is defined as 
 
    .. math:: 
 
      \\frac{n - c_{TT}} 
           {n} 
 
    where :math:`c_{ij}` is the number of occurrences of 
    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for 
    :math:`k &lt; n`. 
 
    Parameters 
    ---------- 
    u : (N,) array_like, bool 
        Input array. 
    v : (N,) array_like, bool 
        Input array. 
    w : (N,) array_like, optional 
        The weights for each value in `u` and `v`. Default is None, 
        which gives each value a weight of 1.0 
 
    Returns 
    ------- 
    russellrao : double 
        The Russell-Rao dissimilarity between vectors `u` and `v`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.spatial import distance 
    &gt;&gt;&gt; distance.russellrao([1, 0, 0], [0, 1, 0]) 
    1.0 
    &gt;&gt;&gt; distance.russellrao([1, 0, 0], [1, 1, 0]) 
    0.6666666666666666 
    &gt;&gt;&gt; distance.russellrao([1, 0, 0], [2, 0, 0]) 
    0.3333333333333333 
 
    &quot;&quot;&quot;</span>
    <span class="s1">u = _validate_vector(u)</span>
    <span class="s1">v = _validate_vector(v)</span>
    <span class="s4">if </span><span class="s1">u.dtype == v.dtype == bool </span><span class="s4">and </span><span class="s1">w </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s1">ntt = (u &amp; v).sum()</span>
        <span class="s1">n = float(len(u))</span>
    <span class="s4">elif </span><span class="s1">w </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s1">ntt = (u * v).sum()</span>
        <span class="s1">n = float(len(u))</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s1">w = _validate_weights(w)</span>
        <span class="s1">ntt = (u * v * w).sum()</span>
        <span class="s1">n = w.sum()</span>
    <span class="s4">return </span><span class="s1">float(n - ntt) / n</span>


<span class="s4">def </span><span class="s1">sokalmichener(u</span><span class="s4">, </span><span class="s1">v</span><span class="s4">, </span><span class="s1">w=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the Sokal-Michener dissimilarity between two boolean 1-D arrays. 
 
    The Sokal-Michener dissimilarity between boolean 1-D arrays `u` and `v`, 
    is defined as 
 
    .. math:: 
 
       \\frac{R} 
            {S + R} 
 
    where :math:`c_{ij}` is the number of occurrences of 
    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for 
    :math:`k &lt; n`, :math:`R = 2 * (c_{TF} + c_{FT})` and 
    :math:`S = c_{FF} + c_{TT}`. 
 
    Parameters 
    ---------- 
    u : (N,) array_like, bool 
        Input array. 
    v : (N,) array_like, bool 
        Input array. 
    w : (N,) array_like, optional 
        The weights for each value in `u` and `v`. Default is None, 
        which gives each value a weight of 1.0 
 
    Returns 
    ------- 
    sokalmichener : double 
        The Sokal-Michener dissimilarity between vectors `u` and `v`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.spatial import distance 
    &gt;&gt;&gt; distance.sokalmichener([1, 0, 0], [0, 1, 0]) 
    0.8 
    &gt;&gt;&gt; distance.sokalmichener([1, 0, 0], [1, 1, 0]) 
    0.5 
    &gt;&gt;&gt; distance.sokalmichener([1, 0, 0], [2, 0, 0]) 
    -1.0 
 
    &quot;&quot;&quot;</span>
    <span class="s1">u = _validate_vector(u)</span>
    <span class="s1">v = _validate_vector(v)</span>
    <span class="s4">if </span><span class="s1">w </span><span class="s4">is not None</span><span class="s1">:</span>
        <span class="s1">w = _validate_weights(w)</span>
    <span class="s1">nff</span><span class="s4">, </span><span class="s1">nft</span><span class="s4">, </span><span class="s1">ntf</span><span class="s4">, </span><span class="s1">ntt = _nbool_correspond_all(u</span><span class="s4">, </span><span class="s1">v</span><span class="s4">, </span><span class="s1">w=w)</span>
    <span class="s4">return </span><span class="s1">float(</span><span class="s5">2.0 </span><span class="s1">* (ntf + nft)) / float(ntt + nff + </span><span class="s5">2.0 </span><span class="s1">* (ntf + nft))</span>


<span class="s4">def </span><span class="s1">sokalsneath(u</span><span class="s4">, </span><span class="s1">v</span><span class="s4">, </span><span class="s1">w=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the Sokal-Sneath dissimilarity between two boolean 1-D arrays. 
 
    The Sokal-Sneath dissimilarity between `u` and `v`, 
 
    .. math:: 
 
       \\frac{R} 
            {c_{TT} + R} 
 
    where :math:`c_{ij}` is the number of occurrences of 
    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for 
    :math:`k &lt; n` and :math:`R = 2(c_{TF} + c_{FT})`. 
 
    Parameters 
    ---------- 
    u : (N,) array_like, bool 
        Input array. 
    v : (N,) array_like, bool 
        Input array. 
    w : (N,) array_like, optional 
        The weights for each value in `u` and `v`. Default is None, 
        which gives each value a weight of 1.0 
 
    Returns 
    ------- 
    sokalsneath : double 
        The Sokal-Sneath dissimilarity between vectors `u` and `v`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.spatial import distance 
    &gt;&gt;&gt; distance.sokalsneath([1, 0, 0], [0, 1, 0]) 
    1.0 
    &gt;&gt;&gt; distance.sokalsneath([1, 0, 0], [1, 1, 0]) 
    0.66666666666666663 
    &gt;&gt;&gt; distance.sokalsneath([1, 0, 0], [2, 1, 0]) 
    0.0 
    &gt;&gt;&gt; distance.sokalsneath([1, 0, 0], [3, 1, 0]) 
    -2.0 
 
    &quot;&quot;&quot;</span>
    <span class="s1">u = _validate_vector(u)</span>
    <span class="s1">v = _validate_vector(v)</span>
    <span class="s4">if </span><span class="s1">u.dtype == v.dtype == bool </span><span class="s4">and </span><span class="s1">w </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s1">ntt = (u &amp; v).sum()</span>
    <span class="s4">elif </span><span class="s1">w </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s1">ntt = (u * v).sum()</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s1">w = _validate_weights(w)</span>
        <span class="s1">ntt = (u * v * w).sum()</span>
    <span class="s1">(nft</span><span class="s4">, </span><span class="s1">ntf) = _nbool_correspond_ft_tf(u</span><span class="s4">, </span><span class="s1">v</span><span class="s4">, </span><span class="s1">w=w)</span>
    <span class="s1">denom = np.array(ntt + </span><span class="s5">2.0 </span><span class="s1">* (ntf + nft))</span>
    <span class="s4">if not </span><span class="s1">denom.any():</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Sokal-Sneath dissimilarity is not defined for '</span>
                         <span class="s3">'vectors that are entirely false.'</span><span class="s1">)</span>
    <span class="s4">return </span><span class="s1">float(</span><span class="s5">2.0 </span><span class="s1">* (ntf + nft)) / denom</span>


<span class="s1">_convert_to_double = partial(_convert_to_type</span><span class="s4">, </span><span class="s1">out_type=np.double)</span>
<span class="s1">_convert_to_bool = partial(_convert_to_type</span><span class="s4">, </span><span class="s1">out_type=bool)</span>

<span class="s2"># adding python-only wrappers to _distance_wrap module</span>
<span class="s1">_distance_wrap.pdist_correlation_double_wrap = _correlation_pdist_wrap</span>
<span class="s1">_distance_wrap.cdist_correlation_double_wrap = _correlation_cdist_wrap</span>


<span class="s1">@dataclasses.dataclass(frozen=</span><span class="s4">True</span><span class="s1">)</span>
<span class="s4">class </span><span class="s1">CDistMetricWrapper:</span>
    <span class="s1">metric_name: str</span>

    <span class="s4">def </span><span class="s1">__call__(self</span><span class="s4">, </span><span class="s1">XA</span><span class="s4">, </span><span class="s1">XB</span><span class="s4">, </span><span class="s1">*</span><span class="s4">, </span><span class="s1">out=</span><span class="s4">None, </span><span class="s1">**kwargs):</span>
        <span class="s1">XA = np.ascontiguousarray(XA)</span>
        <span class="s1">XB = np.ascontiguousarray(XB)</span>
        <span class="s1">mA</span><span class="s4">, </span><span class="s1">n = XA.shape</span>
        <span class="s1">mB</span><span class="s4">, </span><span class="s1">_ = XB.shape</span>
        <span class="s1">metric_name = self.metric_name</span>
        <span class="s1">metric_info = _METRICS[metric_name]</span>
        <span class="s1">XA</span><span class="s4">, </span><span class="s1">XB</span><span class="s4">, </span><span class="s1">typ</span><span class="s4">, </span><span class="s1">kwargs = _validate_cdist_input(</span>
            <span class="s1">XA</span><span class="s4">, </span><span class="s1">XB</span><span class="s4">, </span><span class="s1">mA</span><span class="s4">, </span><span class="s1">mB</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">metric_info</span><span class="s4">, </span><span class="s1">**kwargs)</span>

        <span class="s1">w = kwargs.pop(</span><span class="s3">'w'</span><span class="s4">, None</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">w </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">metric = metric_info.dist_func</span>
            <span class="s4">return </span><span class="s1">_cdist_callable(</span>
                <span class="s1">XA</span><span class="s4">, </span><span class="s1">XB</span><span class="s4">, </span><span class="s1">metric=metric</span><span class="s4">, </span><span class="s1">out=out</span><span class="s4">, </span><span class="s1">w=w</span><span class="s4">, </span><span class="s1">**kwargs)</span>

        <span class="s1">dm = _prepare_out_argument(out</span><span class="s4">, </span><span class="s1">np.double</span><span class="s4">, </span><span class="s1">(mA</span><span class="s4">, </span><span class="s1">mB))</span>
        <span class="s2"># get cdist wrapper</span>
        <span class="s1">cdist_fn = getattr(_distance_wrap</span><span class="s4">, </span><span class="s3">f'cdist_</span><span class="s4">{</span><span class="s1">metric_name</span><span class="s4">}</span><span class="s3">_</span><span class="s4">{</span><span class="s1">typ</span><span class="s4">}</span><span class="s3">_wrap'</span><span class="s1">)</span>
        <span class="s1">cdist_fn(XA</span><span class="s4">, </span><span class="s1">XB</span><span class="s4">, </span><span class="s1">dm</span><span class="s4">, </span><span class="s1">**kwargs)</span>
        <span class="s4">return </span><span class="s1">dm</span>


<span class="s1">@dataclasses.dataclass(frozen=</span><span class="s4">True</span><span class="s1">)</span>
<span class="s4">class </span><span class="s1">CDistWeightedMetricWrapper:</span>
    <span class="s1">metric_name: str</span>
    <span class="s1">weighted_metric: str</span>

    <span class="s4">def </span><span class="s1">__call__(self</span><span class="s4">, </span><span class="s1">XA</span><span class="s4">, </span><span class="s1">XB</span><span class="s4">, </span><span class="s1">*</span><span class="s4">, </span><span class="s1">out=</span><span class="s4">None, </span><span class="s1">**kwargs):</span>
        <span class="s1">XA = np.ascontiguousarray(XA)</span>
        <span class="s1">XB = np.ascontiguousarray(XB)</span>
        <span class="s1">mA</span><span class="s4">, </span><span class="s1">n = XA.shape</span>
        <span class="s1">mB</span><span class="s4">, </span><span class="s1">_ = XB.shape</span>
        <span class="s1">metric_name = self.metric_name</span>
        <span class="s1">XA</span><span class="s4">, </span><span class="s1">XB</span><span class="s4">, </span><span class="s1">typ</span><span class="s4">, </span><span class="s1">kwargs = _validate_cdist_input(</span>
            <span class="s1">XA</span><span class="s4">, </span><span class="s1">XB</span><span class="s4">, </span><span class="s1">mA</span><span class="s4">, </span><span class="s1">mB</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">_METRICS[metric_name]</span><span class="s4">, </span><span class="s1">**kwargs)</span>
        <span class="s1">dm = _prepare_out_argument(out</span><span class="s4">, </span><span class="s1">np.double</span><span class="s4">, </span><span class="s1">(mA</span><span class="s4">, </span><span class="s1">mB))</span>

        <span class="s1">w = kwargs.pop(</span><span class="s3">'w'</span><span class="s4">, None</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">w </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">metric_name = self.weighted_metric</span>
            <span class="s1">kwargs[</span><span class="s3">'w'</span><span class="s1">] = w</span>

        <span class="s2"># get cdist wrapper</span>
        <span class="s1">cdist_fn = getattr(_distance_wrap</span><span class="s4">, </span><span class="s3">f'cdist_</span><span class="s4">{</span><span class="s1">metric_name</span><span class="s4">}</span><span class="s3">_</span><span class="s4">{</span><span class="s1">typ</span><span class="s4">}</span><span class="s3">_wrap'</span><span class="s1">)</span>
        <span class="s1">cdist_fn(XA</span><span class="s4">, </span><span class="s1">XB</span><span class="s4">, </span><span class="s1">dm</span><span class="s4">, </span><span class="s1">**kwargs)</span>
        <span class="s4">return </span><span class="s1">dm</span>


<span class="s1">@dataclasses.dataclass(frozen=</span><span class="s4">True</span><span class="s1">)</span>
<span class="s4">class </span><span class="s1">PDistMetricWrapper:</span>
    <span class="s1">metric_name: str</span>

    <span class="s4">def </span><span class="s1">__call__(self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">*</span><span class="s4">, </span><span class="s1">out=</span><span class="s4">None, </span><span class="s1">**kwargs):</span>
        <span class="s1">X = np.ascontiguousarray(X)</span>
        <span class="s1">m</span><span class="s4">, </span><span class="s1">n = X.shape</span>
        <span class="s1">metric_name = self.metric_name</span>
        <span class="s1">metric_info = _METRICS[metric_name]</span>
        <span class="s1">X</span><span class="s4">, </span><span class="s1">typ</span><span class="s4">, </span><span class="s1">kwargs = _validate_pdist_input(</span>
            <span class="s1">X</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">metric_info</span><span class="s4">, </span><span class="s1">**kwargs)</span>
        <span class="s1">out_size = (m * (m - </span><span class="s5">1</span><span class="s1">)) // </span><span class="s5">2</span>
        <span class="s1">w = kwargs.pop(</span><span class="s3">'w'</span><span class="s4">, None</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">w </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">metric = metric_info.dist_func</span>
            <span class="s4">return </span><span class="s1">_pdist_callable(</span>
                <span class="s1">X</span><span class="s4">, </span><span class="s1">metric=metric</span><span class="s4">, </span><span class="s1">out=out</span><span class="s4">, </span><span class="s1">w=w</span><span class="s4">, </span><span class="s1">**kwargs)</span>

        <span class="s1">dm = _prepare_out_argument(out</span><span class="s4">, </span><span class="s1">np.double</span><span class="s4">, </span><span class="s1">(out_size</span><span class="s4">,</span><span class="s1">))</span>
        <span class="s2"># get pdist wrapper</span>
        <span class="s1">pdist_fn = getattr(_distance_wrap</span><span class="s4">, </span><span class="s3">f'pdist_</span><span class="s4">{</span><span class="s1">metric_name</span><span class="s4">}</span><span class="s3">_</span><span class="s4">{</span><span class="s1">typ</span><span class="s4">}</span><span class="s3">_wrap'</span><span class="s1">)</span>
        <span class="s1">pdist_fn(X</span><span class="s4">, </span><span class="s1">dm</span><span class="s4">, </span><span class="s1">**kwargs)</span>
        <span class="s4">return </span><span class="s1">dm</span>


<span class="s1">@dataclasses.dataclass(frozen=</span><span class="s4">True</span><span class="s1">)</span>
<span class="s4">class </span><span class="s1">PDistWeightedMetricWrapper:</span>
    <span class="s1">metric_name: str</span>
    <span class="s1">weighted_metric: str</span>

    <span class="s4">def </span><span class="s1">__call__(self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">*</span><span class="s4">, </span><span class="s1">out=</span><span class="s4">None, </span><span class="s1">**kwargs):</span>
        <span class="s1">X = np.ascontiguousarray(X)</span>
        <span class="s1">m</span><span class="s4">, </span><span class="s1">n = X.shape</span>
        <span class="s1">metric_name = self.metric_name</span>
        <span class="s1">X</span><span class="s4">, </span><span class="s1">typ</span><span class="s4">, </span><span class="s1">kwargs = _validate_pdist_input(</span>
            <span class="s1">X</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">_METRICS[metric_name]</span><span class="s4">, </span><span class="s1">**kwargs)</span>
        <span class="s1">out_size = (m * (m - </span><span class="s5">1</span><span class="s1">)) // </span><span class="s5">2</span>
        <span class="s1">dm = _prepare_out_argument(out</span><span class="s4">, </span><span class="s1">np.double</span><span class="s4">, </span><span class="s1">(out_size</span><span class="s4">,</span><span class="s1">))</span>

        <span class="s1">w = kwargs.pop(</span><span class="s3">'w'</span><span class="s4">, None</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">w </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">metric_name = self.weighted_metric</span>
            <span class="s1">kwargs[</span><span class="s3">'w'</span><span class="s1">] = w</span>

        <span class="s2"># get pdist wrapper</span>
        <span class="s1">pdist_fn = getattr(_distance_wrap</span><span class="s4">, </span><span class="s3">f'pdist_</span><span class="s4">{</span><span class="s1">metric_name</span><span class="s4">}</span><span class="s3">_</span><span class="s4">{</span><span class="s1">typ</span><span class="s4">}</span><span class="s3">_wrap'</span><span class="s1">)</span>
        <span class="s1">pdist_fn(X</span><span class="s4">, </span><span class="s1">dm</span><span class="s4">, </span><span class="s1">**kwargs)</span>
        <span class="s4">return </span><span class="s1">dm</span>


<span class="s1">@dataclasses.dataclass(frozen=</span><span class="s4">True</span><span class="s1">)</span>
<span class="s4">class </span><span class="s1">MetricInfo:</span>
    <span class="s2"># Name of python distance function</span>
    <span class="s1">canonical_name: str</span>
    <span class="s2"># All aliases, including canonical_name</span>
    <span class="s1">aka: set[str]</span>
    <span class="s2"># unvectorized distance function</span>
    <span class="s1">dist_func: Callable</span>
    <span class="s2"># Optimized cdist function</span>
    <span class="s1">cdist_func: Callable</span>
    <span class="s2"># Optimized pdist function</span>
    <span class="s1">pdist_func: Callable</span>
    <span class="s2"># function that checks kwargs and computes default values:</span>
    <span class="s2"># f(X, m, n, **kwargs)</span>
    <span class="s1">validator: Optional[Callable] = </span><span class="s4">None</span>
    <span class="s2"># list of supported types:</span>
    <span class="s2"># X (pdist) and XA (cdist) are used to choose the type. if there is no</span>
    <span class="s2"># match the first type is used. Default double</span>
    <span class="s1">types: list[str] = dataclasses.field(default_factory=</span><span class="s4">lambda</span><span class="s1">: [</span><span class="s3">'double'</span><span class="s1">])</span>
    <span class="s2"># true if out array must be C-contiguous</span>
    <span class="s1">requires_contiguous_out: bool = </span><span class="s4">True</span>


<span class="s2"># Registry of implemented metrics:</span>
<span class="s1">_METRIC_INFOS = [</span>
    <span class="s1">MetricInfo(</span>
        <span class="s1">canonical_name=</span><span class="s3">'braycurtis'</span><span class="s4">,</span>
        <span class="s1">aka={</span><span class="s3">'braycurtis'</span><span class="s1">}</span><span class="s4">,</span>
        <span class="s1">dist_func=braycurtis</span><span class="s4">,</span>
        <span class="s1">cdist_func=_distance_pybind.cdist_braycurtis</span><span class="s4">,</span>
        <span class="s1">pdist_func=_distance_pybind.pdist_braycurtis</span><span class="s4">,</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">MetricInfo(</span>
        <span class="s1">canonical_name=</span><span class="s3">'canberra'</span><span class="s4">,</span>
        <span class="s1">aka={</span><span class="s3">'canberra'</span><span class="s1">}</span><span class="s4">,</span>
        <span class="s1">dist_func=canberra</span><span class="s4">,</span>
        <span class="s1">cdist_func=_distance_pybind.cdist_canberra</span><span class="s4">,</span>
        <span class="s1">pdist_func=_distance_pybind.pdist_canberra</span><span class="s4">,</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">MetricInfo(</span>
        <span class="s1">canonical_name=</span><span class="s3">'chebyshev'</span><span class="s4">,</span>
        <span class="s1">aka={</span><span class="s3">'chebychev'</span><span class="s4">, </span><span class="s3">'chebyshev'</span><span class="s4">, </span><span class="s3">'cheby'</span><span class="s4">, </span><span class="s3">'cheb'</span><span class="s4">, </span><span class="s3">'ch'</span><span class="s1">}</span><span class="s4">,</span>
        <span class="s1">dist_func=chebyshev</span><span class="s4">,</span>
        <span class="s1">cdist_func=_distance_pybind.cdist_chebyshev</span><span class="s4">,</span>
        <span class="s1">pdist_func=_distance_pybind.pdist_chebyshev</span><span class="s4">,</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">MetricInfo(</span>
        <span class="s1">canonical_name=</span><span class="s3">'cityblock'</span><span class="s4">,</span>
        <span class="s1">aka={</span><span class="s3">'cityblock'</span><span class="s4">, </span><span class="s3">'cblock'</span><span class="s4">, </span><span class="s3">'cb'</span><span class="s4">, </span><span class="s3">'c'</span><span class="s1">}</span><span class="s4">,</span>
        <span class="s1">dist_func=cityblock</span><span class="s4">,</span>
        <span class="s1">cdist_func=_distance_pybind.cdist_cityblock</span><span class="s4">,</span>
        <span class="s1">pdist_func=_distance_pybind.pdist_cityblock</span><span class="s4">,</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">MetricInfo(</span>
        <span class="s1">canonical_name=</span><span class="s3">'correlation'</span><span class="s4">,</span>
        <span class="s1">aka={</span><span class="s3">'correlation'</span><span class="s4">, </span><span class="s3">'co'</span><span class="s1">}</span><span class="s4">,</span>
        <span class="s1">dist_func=correlation</span><span class="s4">,</span>
        <span class="s1">cdist_func=CDistMetricWrapper(</span><span class="s3">'correlation'</span><span class="s1">)</span><span class="s4">,</span>
        <span class="s1">pdist_func=PDistMetricWrapper(</span><span class="s3">'correlation'</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">MetricInfo(</span>
        <span class="s1">canonical_name=</span><span class="s3">'cosine'</span><span class="s4">,</span>
        <span class="s1">aka={</span><span class="s3">'cosine'</span><span class="s4">, </span><span class="s3">'cos'</span><span class="s1">}</span><span class="s4">,</span>
        <span class="s1">dist_func=cosine</span><span class="s4">,</span>
        <span class="s1">cdist_func=CDistMetricWrapper(</span><span class="s3">'cosine'</span><span class="s1">)</span><span class="s4">,</span>
        <span class="s1">pdist_func=PDistMetricWrapper(</span><span class="s3">'cosine'</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">MetricInfo(</span>
        <span class="s1">canonical_name=</span><span class="s3">'dice'</span><span class="s4">,</span>
        <span class="s1">aka={</span><span class="s3">'dice'</span><span class="s1">}</span><span class="s4">,</span>
        <span class="s1">types=[</span><span class="s3">'bool'</span><span class="s1">]</span><span class="s4">,</span>
        <span class="s1">dist_func=dice</span><span class="s4">,</span>
        <span class="s1">cdist_func=_distance_pybind.cdist_dice</span><span class="s4">,</span>
        <span class="s1">pdist_func=_distance_pybind.pdist_dice</span><span class="s4">,</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">MetricInfo(</span>
        <span class="s1">canonical_name=</span><span class="s3">'euclidean'</span><span class="s4">,</span>
        <span class="s1">aka={</span><span class="s3">'euclidean'</span><span class="s4">, </span><span class="s3">'euclid'</span><span class="s4">, </span><span class="s3">'eu'</span><span class="s4">, </span><span class="s3">'e'</span><span class="s1">}</span><span class="s4">,</span>
        <span class="s1">dist_func=euclidean</span><span class="s4">,</span>
        <span class="s1">cdist_func=_distance_pybind.cdist_euclidean</span><span class="s4">,</span>
        <span class="s1">pdist_func=_distance_pybind.pdist_euclidean</span><span class="s4">,</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">MetricInfo(</span>
        <span class="s1">canonical_name=</span><span class="s3">'hamming'</span><span class="s4">,</span>
        <span class="s1">aka={</span><span class="s3">'matching'</span><span class="s4">, </span><span class="s3">'hamming'</span><span class="s4">, </span><span class="s3">'hamm'</span><span class="s4">, </span><span class="s3">'ha'</span><span class="s4">, </span><span class="s3">'h'</span><span class="s1">}</span><span class="s4">,</span>
        <span class="s1">types=[</span><span class="s3">'double'</span><span class="s4">, </span><span class="s3">'bool'</span><span class="s1">]</span><span class="s4">,</span>
        <span class="s1">validator=_validate_hamming_kwargs</span><span class="s4">,</span>
        <span class="s1">dist_func=hamming</span><span class="s4">,</span>
        <span class="s1">cdist_func=_distance_pybind.cdist_hamming</span><span class="s4">,</span>
        <span class="s1">pdist_func=_distance_pybind.pdist_hamming</span><span class="s4">,</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">MetricInfo(</span>
        <span class="s1">canonical_name=</span><span class="s3">'jaccard'</span><span class="s4">,</span>
        <span class="s1">aka={</span><span class="s3">'jaccard'</span><span class="s4">, </span><span class="s3">'jacc'</span><span class="s4">, </span><span class="s3">'ja'</span><span class="s4">, </span><span class="s3">'j'</span><span class="s1">}</span><span class="s4">,</span>
        <span class="s1">types=[</span><span class="s3">'double'</span><span class="s4">, </span><span class="s3">'bool'</span><span class="s1">]</span><span class="s4">,</span>
        <span class="s1">dist_func=jaccard</span><span class="s4">,</span>
        <span class="s1">cdist_func=_distance_pybind.cdist_jaccard</span><span class="s4">,</span>
        <span class="s1">pdist_func=_distance_pybind.pdist_jaccard</span><span class="s4">,</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">MetricInfo(</span>
        <span class="s1">canonical_name=</span><span class="s3">'jensenshannon'</span><span class="s4">,</span>
        <span class="s1">aka={</span><span class="s3">'jensenshannon'</span><span class="s4">, </span><span class="s3">'js'</span><span class="s1">}</span><span class="s4">,</span>
        <span class="s1">dist_func=jensenshannon</span><span class="s4">,</span>
        <span class="s1">cdist_func=CDistMetricWrapper(</span><span class="s3">'jensenshannon'</span><span class="s1">)</span><span class="s4">,</span>
        <span class="s1">pdist_func=PDistMetricWrapper(</span><span class="s3">'jensenshannon'</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">MetricInfo(</span>
        <span class="s1">canonical_name=</span><span class="s3">'kulczynski1'</span><span class="s4">,</span>
        <span class="s1">aka={</span><span class="s3">'kulczynski1'</span><span class="s1">}</span><span class="s4">,</span>
        <span class="s1">types=[</span><span class="s3">'bool'</span><span class="s1">]</span><span class="s4">,</span>
        <span class="s1">dist_func=kulczynski1</span><span class="s4">,</span>
        <span class="s1">cdist_func=_distance_pybind.cdist_kulczynski1</span><span class="s4">,</span>
        <span class="s1">pdist_func=_distance_pybind.pdist_kulczynski1</span><span class="s4">,</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">MetricInfo(</span>
        <span class="s1">canonical_name=</span><span class="s3">'mahalanobis'</span><span class="s4">,</span>
        <span class="s1">aka={</span><span class="s3">'mahalanobis'</span><span class="s4">, </span><span class="s3">'mahal'</span><span class="s4">, </span><span class="s3">'mah'</span><span class="s1">}</span><span class="s4">,</span>
        <span class="s1">validator=_validate_mahalanobis_kwargs</span><span class="s4">,</span>
        <span class="s1">dist_func=mahalanobis</span><span class="s4">,</span>
        <span class="s1">cdist_func=CDistMetricWrapper(</span><span class="s3">'mahalanobis'</span><span class="s1">)</span><span class="s4">,</span>
        <span class="s1">pdist_func=PDistMetricWrapper(</span><span class="s3">'mahalanobis'</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">MetricInfo(</span>
        <span class="s1">canonical_name=</span><span class="s3">'minkowski'</span><span class="s4">,</span>
        <span class="s1">aka={</span><span class="s3">'minkowski'</span><span class="s4">, </span><span class="s3">'mi'</span><span class="s4">, </span><span class="s3">'m'</span><span class="s4">, </span><span class="s3">'pnorm'</span><span class="s1">}</span><span class="s4">,</span>
        <span class="s1">validator=_validate_minkowski_kwargs</span><span class="s4">,</span>
        <span class="s1">dist_func=minkowski</span><span class="s4">,</span>
        <span class="s1">cdist_func=_distance_pybind.cdist_minkowski</span><span class="s4">,</span>
        <span class="s1">pdist_func=_distance_pybind.pdist_minkowski</span><span class="s4">,</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">MetricInfo(</span>
        <span class="s1">canonical_name=</span><span class="s3">'rogerstanimoto'</span><span class="s4">,</span>
        <span class="s1">aka={</span><span class="s3">'rogerstanimoto'</span><span class="s1">}</span><span class="s4">,</span>
        <span class="s1">types=[</span><span class="s3">'bool'</span><span class="s1">]</span><span class="s4">,</span>
        <span class="s1">dist_func=rogerstanimoto</span><span class="s4">,</span>
        <span class="s1">cdist_func=_distance_pybind.cdist_rogerstanimoto</span><span class="s4">,</span>
        <span class="s1">pdist_func=_distance_pybind.pdist_rogerstanimoto</span><span class="s4">,</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">MetricInfo(</span>
        <span class="s1">canonical_name=</span><span class="s3">'russellrao'</span><span class="s4">,</span>
        <span class="s1">aka={</span><span class="s3">'russellrao'</span><span class="s1">}</span><span class="s4">,</span>
        <span class="s1">types=[</span><span class="s3">'bool'</span><span class="s1">]</span><span class="s4">,</span>
        <span class="s1">dist_func=russellrao</span><span class="s4">,</span>
        <span class="s1">cdist_func=_distance_pybind.cdist_russellrao</span><span class="s4">,</span>
        <span class="s1">pdist_func=_distance_pybind.pdist_russellrao</span><span class="s4">,</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">MetricInfo(</span>
        <span class="s1">canonical_name=</span><span class="s3">'seuclidean'</span><span class="s4">,</span>
        <span class="s1">aka={</span><span class="s3">'seuclidean'</span><span class="s4">, </span><span class="s3">'se'</span><span class="s4">, </span><span class="s3">'s'</span><span class="s1">}</span><span class="s4">,</span>
        <span class="s1">validator=_validate_seuclidean_kwargs</span><span class="s4">,</span>
        <span class="s1">dist_func=seuclidean</span><span class="s4">,</span>
        <span class="s1">cdist_func=CDistMetricWrapper(</span><span class="s3">'seuclidean'</span><span class="s1">)</span><span class="s4">,</span>
        <span class="s1">pdist_func=PDistMetricWrapper(</span><span class="s3">'seuclidean'</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">MetricInfo(</span>
        <span class="s1">canonical_name=</span><span class="s3">'sokalmichener'</span><span class="s4">,</span>
        <span class="s1">aka={</span><span class="s3">'sokalmichener'</span><span class="s1">}</span><span class="s4">,</span>
        <span class="s1">types=[</span><span class="s3">'bool'</span><span class="s1">]</span><span class="s4">,</span>
        <span class="s1">dist_func=sokalmichener</span><span class="s4">,</span>
        <span class="s1">cdist_func=_distance_pybind.cdist_sokalmichener</span><span class="s4">,</span>
        <span class="s1">pdist_func=_distance_pybind.pdist_sokalmichener</span><span class="s4">,</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">MetricInfo(</span>
        <span class="s1">canonical_name=</span><span class="s3">'sokalsneath'</span><span class="s4">,</span>
        <span class="s1">aka={</span><span class="s3">'sokalsneath'</span><span class="s1">}</span><span class="s4">,</span>
        <span class="s1">types=[</span><span class="s3">'bool'</span><span class="s1">]</span><span class="s4">,</span>
        <span class="s1">dist_func=sokalsneath</span><span class="s4">,</span>
        <span class="s1">cdist_func=_distance_pybind.cdist_sokalsneath</span><span class="s4">,</span>
        <span class="s1">pdist_func=_distance_pybind.pdist_sokalsneath</span><span class="s4">,</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">MetricInfo(</span>
        <span class="s1">canonical_name=</span><span class="s3">'sqeuclidean'</span><span class="s4">,</span>
        <span class="s1">aka={</span><span class="s3">'sqeuclidean'</span><span class="s4">, </span><span class="s3">'sqe'</span><span class="s4">, </span><span class="s3">'sqeuclid'</span><span class="s1">}</span><span class="s4">,</span>
        <span class="s1">dist_func=sqeuclidean</span><span class="s4">,</span>
        <span class="s1">cdist_func=_distance_pybind.cdist_sqeuclidean</span><span class="s4">,</span>
        <span class="s1">pdist_func=_distance_pybind.pdist_sqeuclidean</span><span class="s4">,</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">MetricInfo(</span>
        <span class="s1">canonical_name=</span><span class="s3">'yule'</span><span class="s4">,</span>
        <span class="s1">aka={</span><span class="s3">'yule'</span><span class="s1">}</span><span class="s4">,</span>
        <span class="s1">types=[</span><span class="s3">'bool'</span><span class="s1">]</span><span class="s4">,</span>
        <span class="s1">dist_func=yule</span><span class="s4">,</span>
        <span class="s1">cdist_func=_distance_pybind.cdist_yule</span><span class="s4">,</span>
        <span class="s1">pdist_func=_distance_pybind.pdist_yule</span><span class="s4">,</span>
    <span class="s1">)</span><span class="s4">,</span>
<span class="s1">]</span>

<span class="s1">_METRICS = {info.canonical_name: info </span><span class="s4">for </span><span class="s1">info </span><span class="s4">in </span><span class="s1">_METRIC_INFOS}</span>
<span class="s1">_METRIC_ALIAS = {alias: info</span>
                     <span class="s4">for </span><span class="s1">info </span><span class="s4">in </span><span class="s1">_METRIC_INFOS</span>
                     <span class="s4">for </span><span class="s1">alias </span><span class="s4">in </span><span class="s1">info.aka}</span>

<span class="s1">_METRICS_NAMES = list(_METRICS.keys())</span>

<span class="s1">_TEST_METRICS = {</span><span class="s3">'test_' </span><span class="s1">+ info.canonical_name: info </span><span class="s4">for </span><span class="s1">info </span><span class="s4">in </span><span class="s1">_METRIC_INFOS}</span>


<span class="s4">def </span><span class="s1">pdist(X</span><span class="s4">, </span><span class="s1">metric=</span><span class="s3">'euclidean'</span><span class="s4">, </span><span class="s1">*</span><span class="s4">, </span><span class="s1">out=</span><span class="s4">None, </span><span class="s1">**kwargs):</span>
    <span class="s0">&quot;&quot;&quot; 
    Pairwise distances between observations in n-dimensional space. 
 
    See Notes for common calling conventions. 
 
    Parameters 
    ---------- 
    X : array_like 
        An m by n array of m original observations in an 
        n-dimensional space. 
    metric : str or function, optional 
        The distance metric to use. The distance function can 
        be 'braycurtis', 'canberra', 'chebyshev', 'cityblock', 
        'correlation', 'cosine', 'dice', 'euclidean', 'hamming', 
        'jaccard', 'jensenshannon', 'kulczynski1', 
        'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto', 
        'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 
        'sqeuclidean', 'yule'. 
    out : ndarray 
        The output array. 
        If not None, condensed distance matrix Y is stored in this array. 
    **kwargs : dict, optional 
        Extra arguments to `metric`: refer to each metric documentation for a 
        list of all possible arguments. 
 
        Some possible arguments: 
 
        p : scalar 
        The p-norm to apply for Minkowski, weighted and unweighted. 
        Default: 2. 
 
        w : ndarray 
        The weight vector for metrics that support weights (e.g., Minkowski). 
 
        V : ndarray 
        The variance vector for standardized Euclidean. 
        Default: var(X, axis=0, ddof=1) 
 
        VI : ndarray 
        The inverse of the covariance matrix for Mahalanobis. 
        Default: inv(cov(X.T)).T 
 
    Returns 
    ------- 
    Y : ndarray 
        Returns a condensed distance matrix Y. For each :math:`i` and :math:`j` 
        (where :math:`i&lt;j&lt;m`),where m is the number of original observations. 
        The metric ``dist(u=X[i], v=X[j])`` is computed and stored in entry ``m 
        * i + j - ((i + 2) * (i + 1)) // 2``. 
 
    See Also 
    -------- 
    squareform : converts between condensed distance matrices and 
                 square distance matrices. 
 
    Notes 
    ----- 
    See ``squareform`` for information on how to calculate the index of 
    this entry or to convert the condensed distance matrix to a 
    redundant square matrix. 
 
    The following are common calling conventions. 
 
    1. ``Y = pdist(X, 'euclidean')`` 
 
       Computes the distance between m points using Euclidean distance 
       (2-norm) as the distance metric between the points. The points 
       are arranged as m n-dimensional row vectors in the matrix X. 
 
    2. ``Y = pdist(X, 'minkowski', p=2.)`` 
 
       Computes the distances using the Minkowski distance 
       :math:`\\|u-v\\|_p` (:math:`p`-norm) where :math:`p &gt; 0` (note 
       that this is only a quasi-metric if :math:`0 &lt; p &lt; 1`). 
 
    3. ``Y = pdist(X, 'cityblock')`` 
 
       Computes the city block or Manhattan distance between the 
       points. 
 
    4. ``Y = pdist(X, 'seuclidean', V=None)`` 
 
       Computes the standardized Euclidean distance. The standardized 
       Euclidean distance between two n-vectors ``u`` and ``v`` is 
 
       .. math:: 
 
          \\sqrt{\\sum {(u_i-v_i)^2 / V[x_i]}} 
 
 
       V is the variance vector; V[i] is the variance computed over all 
       the i'th components of the points.  If not passed, it is 
       automatically computed. 
 
    5. ``Y = pdist(X, 'sqeuclidean')`` 
 
       Computes the squared Euclidean distance :math:`\\|u-v\\|_2^2` between 
       the vectors. 
 
    6. ``Y = pdist(X, 'cosine')`` 
 
       Computes the cosine distance between vectors u and v, 
 
       .. math:: 
 
          1 - \\frac{u \\cdot v} 
                   {{\\|u\\|}_2 {\\|v\\|}_2} 
 
       where :math:`\\|*\\|_2` is the 2-norm of its argument ``*``, and 
       :math:`u \\cdot v` is the dot product of ``u`` and ``v``. 
 
    7. ``Y = pdist(X, 'correlation')`` 
 
       Computes the correlation distance between vectors u and v. This is 
 
       .. math:: 
 
          1 - \\frac{(u - \\bar{u}) \\cdot (v - \\bar{v})} 
                   {{\\|(u - \\bar{u})\\|}_2 {\\|(v - \\bar{v})\\|}_2} 
 
       where :math:`\\bar{v}` is the mean of the elements of vector v, 
       and :math:`x \\cdot y` is the dot product of :math:`x` and :math:`y`. 
 
    8. ``Y = pdist(X, 'hamming')`` 
 
       Computes the normalized Hamming distance, or the proportion of 
       those vector elements between two n-vectors ``u`` and ``v`` 
       which disagree. To save memory, the matrix ``X`` can be of type 
       boolean. 
 
    9. ``Y = pdist(X, 'jaccard')`` 
 
       Computes the Jaccard distance between the points. Given two 
       vectors, ``u`` and ``v``, the Jaccard distance is the 
       proportion of those elements ``u[i]`` and ``v[i]`` that 
       disagree. 
 
    10. ``Y = pdist(X, 'jensenshannon')`` 
 
        Computes the Jensen-Shannon distance between two probability arrays. 
        Given two probability vectors, :math:`p` and :math:`q`, the 
        Jensen-Shannon distance is 
 
        .. math:: 
 
           \\sqrt{\\frac{D(p \\parallel m) + D(q \\parallel m)}{2}} 
 
        where :math:`m` is the pointwise mean of :math:`p` and :math:`q` 
        and :math:`D` is the Kullback-Leibler divergence. 
 
    11. ``Y = pdist(X, 'chebyshev')`` 
 
        Computes the Chebyshev distance between the points. The 
        Chebyshev distance between two n-vectors ``u`` and ``v`` is the 
        maximum norm-1 distance between their respective elements. More 
        precisely, the distance is given by 
 
        .. math:: 
 
           d(u,v) = \\max_i {|u_i-v_i|} 
 
    12. ``Y = pdist(X, 'canberra')`` 
 
        Computes the Canberra distance between the points. The 
        Canberra distance between two points ``u`` and ``v`` is 
 
        .. math:: 
 
          d(u,v) = \\sum_i \\frac{|u_i-v_i|} 
                               {|u_i|+|v_i|} 
 
 
    13. ``Y = pdist(X, 'braycurtis')`` 
 
        Computes the Bray-Curtis distance between the points. The 
        Bray-Curtis distance between two points ``u`` and ``v`` is 
 
 
        .. math:: 
 
             d(u,v) = \\frac{\\sum_i {|u_i-v_i|}} 
                            {\\sum_i {|u_i+v_i|}} 
 
    14. ``Y = pdist(X, 'mahalanobis', VI=None)`` 
 
        Computes the Mahalanobis distance between the points. The 
        Mahalanobis distance between two points ``u`` and ``v`` is 
        :math:`\\sqrt{(u-v)(1/V)(u-v)^T}` where :math:`(1/V)` (the ``VI`` 
        variable) is the inverse covariance. If ``VI`` is not None, 
        ``VI`` will be used as the inverse covariance matrix. 
 
    15. ``Y = pdist(X, 'yule')`` 
 
        Computes the Yule distance between each pair of boolean 
        vectors. (see yule function documentation) 
 
    16. ``Y = pdist(X, 'matching')`` 
 
        Synonym for 'hamming'. 
 
    17. ``Y = pdist(X, 'dice')`` 
 
        Computes the Dice distance between each pair of boolean 
        vectors. (see dice function documentation) 
 
    18. ``Y = pdist(X, 'kulczynski1')`` 
 
        Computes the kulczynski1 distance between each pair of 
        boolean vectors. (see kulczynski1 function documentation) 
 
    19. ``Y = pdist(X, 'rogerstanimoto')`` 
 
        Computes the Rogers-Tanimoto distance between each pair of 
        boolean vectors. (see rogerstanimoto function documentation) 
 
    20. ``Y = pdist(X, 'russellrao')`` 
 
        Computes the Russell-Rao distance between each pair of 
        boolean vectors. (see russellrao function documentation) 
 
    21. ``Y = pdist(X, 'sokalmichener')`` 
 
        Computes the Sokal-Michener distance between each pair of 
        boolean vectors. (see sokalmichener function documentation) 
 
    22. ``Y = pdist(X, 'sokalsneath')`` 
 
        Computes the Sokal-Sneath distance between each pair of 
        boolean vectors. (see sokalsneath function documentation) 
 
    23. ``Y = pdist(X, 'kulczynski1')`` 
 
        Computes the Kulczynski 1 distance between each pair of 
        boolean vectors. (see kulczynski1 function documentation) 
 
    24. ``Y = pdist(X, f)`` 
 
        Computes the distance between all pairs of vectors in X 
        using the user supplied 2-arity function f. For example, 
        Euclidean distance between the vectors could be computed 
        as follows:: 
 
          dm = pdist(X, lambda u, v: np.sqrt(((u-v)**2).sum())) 
 
        Note that you should avoid passing a reference to one of 
        the distance functions defined in this library. For example,:: 
 
          dm = pdist(X, sokalsneath) 
 
        would calculate the pair-wise distances between the vectors in 
        X using the Python function sokalsneath. This would result in 
        sokalsneath being called :math:`{n \\choose 2}` times, which 
        is inefficient. Instead, the optimized C version is more 
        efficient, and we call it using the following syntax.:: 
 
          dm = pdist(X, 'sokalsneath') 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.spatial.distance import pdist 
 
    ``x`` is an array of five points in three-dimensional space. 
 
    &gt;&gt;&gt; x = np.array([[2, 0, 2], [2, 2, 3], [-2, 4, 5], [0, 1, 9], [2, 2, 4]]) 
 
    ``pdist(x)`` with no additional arguments computes the 10 pairwise 
    Euclidean distances: 
 
    &gt;&gt;&gt; pdist(x) 
    array([2.23606798, 6.40312424, 7.34846923, 2.82842712, 4.89897949, 
           6.40312424, 1.        , 5.38516481, 4.58257569, 5.47722558]) 
 
    The following computes the pairwise Minkowski distances with ``p = 3.5``: 
 
    &gt;&gt;&gt; pdist(x, metric='minkowski', p=3.5) 
    array([2.04898923, 5.1154929 , 7.02700737, 2.43802731, 4.19042714, 
           6.03956994, 1.        , 4.45128103, 4.10636143, 5.0619695 ]) 
 
    The pairwise city block or Manhattan distances: 
 
    &gt;&gt;&gt; pdist(x, metric='cityblock') 
    array([ 3., 11., 10.,  4.,  8.,  9.,  1.,  9.,  7.,  8.]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2"># You can also call this as:</span>
    <span class="s2">#     Y = pdist(X, 'test_abc')</span>
    <span class="s2"># where 'abc' is the metric being tested.  This computes the distance</span>
    <span class="s2"># between all pairs of vectors in X using the distance metric 'abc' but</span>
    <span class="s2"># with a more succinct, verifiable, but less efficient implementation.</span>

    <span class="s1">X = _asarray_validated(X</span><span class="s4">, </span><span class="s1">sparse_ok=</span><span class="s4">False, </span><span class="s1">objects_ok=</span><span class="s4">True, </span><span class="s1">mask_ok=</span><span class="s4">True,</span>
                           <span class="s1">check_finite=</span><span class="s4">False</span><span class="s1">)</span>

    <span class="s1">s = X.shape</span>
    <span class="s4">if </span><span class="s1">len(s) != </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'A 2-dimensional array must be passed.'</span><span class="s1">)</span>

    <span class="s1">m</span><span class="s4">, </span><span class="s1">n = s</span>

    <span class="s4">if </span><span class="s1">callable(metric):</span>
        <span class="s1">mstr = getattr(metric</span><span class="s4">, </span><span class="s3">'__name__'</span><span class="s4">, </span><span class="s3">'UnknownCustomMetric'</span><span class="s1">)</span>
        <span class="s1">metric_info = _METRIC_ALIAS.get(mstr</span><span class="s4">, None</span><span class="s1">)</span>

        <span class="s4">if </span><span class="s1">metric_info </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">X</span><span class="s4">, </span><span class="s1">typ</span><span class="s4">, </span><span class="s1">kwargs = _validate_pdist_input(</span>
                <span class="s1">X</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">metric_info</span><span class="s4">, </span><span class="s1">**kwargs)</span>

        <span class="s4">return </span><span class="s1">_pdist_callable(X</span><span class="s4">, </span><span class="s1">metric=metric</span><span class="s4">, </span><span class="s1">out=out</span><span class="s4">, </span><span class="s1">**kwargs)</span>
    <span class="s4">elif </span><span class="s1">isinstance(metric</span><span class="s4">, </span><span class="s1">str):</span>
        <span class="s1">mstr = metric.lower()</span>
        <span class="s1">metric_info = _METRIC_ALIAS.get(mstr</span><span class="s4">, None</span><span class="s1">)</span>

        <span class="s4">if </span><span class="s1">metric_info </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">pdist_fn = metric_info.pdist_func</span>
            <span class="s1">_extra_windows_error_checks(X</span><span class="s4">, </span><span class="s1">out</span><span class="s4">, </span><span class="s1">(m * (m - </span><span class="s5">1</span><span class="s1">) / </span><span class="s5">2</span><span class="s4">,</span><span class="s1">)</span><span class="s4">, </span><span class="s1">**kwargs)</span>
            <span class="s4">return </span><span class="s1">pdist_fn(X</span><span class="s4">, </span><span class="s1">out=out</span><span class="s4">, </span><span class="s1">**kwargs)</span>
        <span class="s4">elif </span><span class="s1">mstr.startswith(</span><span class="s3">&quot;test_&quot;</span><span class="s1">):</span>
            <span class="s1">metric_info = _TEST_METRICS.get(mstr</span><span class="s4">, None</span><span class="s1">)</span>
            <span class="s4">if </span><span class="s1">metric_info </span><span class="s4">is None</span><span class="s1">:</span>
                <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">f'Unknown &quot;Test&quot; Distance Metric: </span><span class="s4">{</span><span class="s1">mstr[</span><span class="s5">5</span><span class="s1">:]</span><span class="s4">}</span><span class="s3">'</span><span class="s1">)</span>
            <span class="s1">X</span><span class="s4">, </span><span class="s1">typ</span><span class="s4">, </span><span class="s1">kwargs = _validate_pdist_input(</span>
                <span class="s1">X</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">metric_info</span><span class="s4">, </span><span class="s1">**kwargs)</span>
            <span class="s4">return </span><span class="s1">_pdist_callable(</span>
                <span class="s1">X</span><span class="s4">, </span><span class="s1">metric=metric_info.dist_func</span><span class="s4">, </span><span class="s1">out=out</span><span class="s4">, </span><span class="s1">**kwargs)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Unknown Distance Metric: %s' </span><span class="s1">% mstr)</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s4">raise </span><span class="s1">TypeError(</span><span class="s3">'2nd argument metric must be a string identifier '</span>
                        <span class="s3">'or a function.'</span><span class="s1">)</span>


<span class="s4">def </span><span class="s1">squareform(X</span><span class="s4">, </span><span class="s1">force=</span><span class="s3">&quot;no&quot;</span><span class="s4">, </span><span class="s1">checks=</span><span class="s4">True</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert a vector-form distance vector to a square-form distance 
    matrix, and vice-versa. 
 
    Parameters 
    ---------- 
    X : array_like 
        Either a condensed or redundant distance matrix. 
    force : str, optional 
        As with MATLAB(TM), if force is equal to ``'tovector'`` or 
        ``'tomatrix'``, the input will be treated as a distance matrix or 
        distance vector respectively. 
    checks : bool, optional 
        If set to False, no checks will be made for matrix 
        symmetry nor zero diagonals. This is useful if it is known that 
        ``X - X.T1`` is small and ``diag(X)`` is close to zero. 
        These values are ignored any way so they do not disrupt the 
        squareform transformation. 
 
    Returns 
    ------- 
    Y : ndarray 
        If a condensed distance matrix is passed, a redundant one is 
        returned, or if a redundant one is passed, a condensed distance 
        matrix is returned. 
 
    Notes 
    ----- 
    1. ``v = squareform(X)`` 
 
       Given a square n-by-n symmetric distance matrix ``X``, 
       ``v = squareform(X)`` returns a ``n * (n-1) / 2`` 
       (i.e. binomial coefficient n choose 2) sized vector `v` 
       where :math:`v[{n \\choose 2} - {n-i \\choose 2} + (j-i-1)]` 
       is the distance between distinct points ``i`` and ``j``. 
       If ``X`` is non-square or asymmetric, an error is raised. 
 
    2. ``X = squareform(v)`` 
 
       Given a ``n * (n-1) / 2`` sized vector ``v`` 
       for some integer ``n &gt;= 1`` encoding distances as described, 
       ``X = squareform(v)`` returns a n-by-n distance matrix ``X``. 
       The ``X[i, j]`` and ``X[j, i]`` values are set to 
       :math:`v[{n \\choose 2} - {n-i \\choose 2} + (j-i-1)]` 
       and all diagonal elements are zero. 
 
    In SciPy 0.19.0, ``squareform`` stopped casting all input types to 
    float64, and started returning arrays of the same dtype as the input. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.spatial.distance import pdist, squareform 
 
    ``x`` is an array of five points in three-dimensional space. 
 
    &gt;&gt;&gt; x = np.array([[2, 0, 2], [2, 2, 3], [-2, 4, 5], [0, 1, 9], [2, 2, 4]]) 
 
    ``pdist(x)`` computes the Euclidean distances between each pair of 
    points in ``x``.  The distances are returned in a one-dimensional 
    array with length ``5*(5 - 1)/2 = 10``. 
 
    &gt;&gt;&gt; distvec = pdist(x) 
    &gt;&gt;&gt; distvec 
    array([2.23606798, 6.40312424, 7.34846923, 2.82842712, 4.89897949, 
           6.40312424, 1.        , 5.38516481, 4.58257569, 5.47722558]) 
 
    ``squareform(distvec)`` returns the 5x5 distance matrix. 
 
    &gt;&gt;&gt; m = squareform(distvec) 
    &gt;&gt;&gt; m 
    array([[0.        , 2.23606798, 6.40312424, 7.34846923, 2.82842712], 
           [2.23606798, 0.        , 4.89897949, 6.40312424, 1.        ], 
           [6.40312424, 4.89897949, 0.        , 5.38516481, 4.58257569], 
           [7.34846923, 6.40312424, 5.38516481, 0.        , 5.47722558], 
           [2.82842712, 1.        , 4.58257569, 5.47722558, 0.        ]]) 
 
    When given a square distance matrix ``m``, ``squareform(m)`` returns 
    the one-dimensional condensed distance vector associated with the 
    matrix.  In this case, we recover ``distvec``. 
 
    &gt;&gt;&gt; squareform(m) 
    array([2.23606798, 6.40312424, 7.34846923, 2.82842712, 4.89897949, 
           6.40312424, 1.        , 5.38516481, 4.58257569, 5.47722558]) 
    &quot;&quot;&quot;</span>
    <span class="s1">X = np.ascontiguousarray(X)</span>

    <span class="s1">s = X.shape</span>

    <span class="s4">if </span><span class="s1">force.lower() == </span><span class="s3">'tomatrix'</span><span class="s1">:</span>
        <span class="s4">if </span><span class="s1">len(s) != </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Forcing 'tomatrix' but input X is not a &quot;</span>
                             <span class="s3">&quot;distance vector.&quot;</span><span class="s1">)</span>
    <span class="s4">elif </span><span class="s1">force.lower() == </span><span class="s3">'tovector'</span><span class="s1">:</span>
        <span class="s4">if </span><span class="s1">len(s) != </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Forcing 'tovector' but input X is not a &quot;</span>
                             <span class="s3">&quot;distance matrix.&quot;</span><span class="s1">)</span>

    <span class="s2"># X = squareform(v)</span>
    <span class="s4">if </span><span class="s1">len(s) == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s4">if </span><span class="s1">s[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">np.zeros((</span><span class="s5">1</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">, </span><span class="s1">dtype=X.dtype)</span>

        <span class="s2"># Grab the closest value to the square root of the number</span>
        <span class="s2"># of elements times 2 to see if the number of elements</span>
        <span class="s2"># is indeed a binomial coefficient.</span>
        <span class="s1">d = int(np.ceil(np.sqrt(s[</span><span class="s5">0</span><span class="s1">] * </span><span class="s5">2</span><span class="s1">)))</span>

        <span class="s2"># Check that v is of valid dimensions.</span>
        <span class="s4">if </span><span class="s1">d * (d - </span><span class="s5">1</span><span class="s1">) != s[</span><span class="s5">0</span><span class="s1">] * </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Incompatible vector size. It must be a binomial '</span>
                             <span class="s3">'coefficient n choose 2 for some integer n &gt;= 2.'</span><span class="s1">)</span>

        <span class="s2"># Allocate memory for the distance matrix.</span>
        <span class="s1">M = np.zeros((d</span><span class="s4">, </span><span class="s1">d)</span><span class="s4">, </span><span class="s1">dtype=X.dtype)</span>

        <span class="s2"># Since the C code does not support striding using strides.</span>
        <span class="s2"># The dimensions are used instead.</span>
        <span class="s1">X = _copy_array_if_base_present(X)</span>

        <span class="s2"># Fill in the values of the distance matrix.</span>
        <span class="s1">_distance_wrap.to_squareform_from_vector_wrap(M</span><span class="s4">, </span><span class="s1">X)</span>

        <span class="s2"># Return the distance matrix.</span>
        <span class="s4">return </span><span class="s1">M</span>
    <span class="s4">elif </span><span class="s1">len(s) == </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s4">if </span><span class="s1">s[</span><span class="s5">0</span><span class="s1">] != s[</span><span class="s5">1</span><span class="s1">]:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'The matrix argument must be square.'</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">checks:</span>
            <span class="s1">is_valid_dm(X</span><span class="s4">, </span><span class="s1">throw=</span><span class="s4">True, </span><span class="s1">name=</span><span class="s3">'X'</span><span class="s1">)</span>

        <span class="s2"># One-side of the dimensions is set here.</span>
        <span class="s1">d = s[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s4">if </span><span class="s1">d &lt;= </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">np.array([]</span><span class="s4">, </span><span class="s1">dtype=X.dtype)</span>

        <span class="s2"># Create a vector.</span>
        <span class="s1">v = np.zeros((d * (d - </span><span class="s5">1</span><span class="s1">)) // </span><span class="s5">2</span><span class="s4">, </span><span class="s1">dtype=X.dtype)</span>

        <span class="s2"># Since the C code does not support striding using strides.</span>
        <span class="s2"># The dimensions are used instead.</span>
        <span class="s1">X = _copy_array_if_base_present(X)</span>

        <span class="s2"># Convert the vector to squareform.</span>
        <span class="s1">_distance_wrap.to_vector_from_squareform_wrap(X</span><span class="s4">, </span><span class="s1">v)</span>
        <span class="s4">return </span><span class="s1">v</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s4">raise </span><span class="s1">ValueError((</span><span class="s3">'The first argument must be one or two dimensional '</span>
                          <span class="s3">'array. A %d-dimensional array is not '</span>
                          <span class="s3">'permitted'</span><span class="s1">) % len(s))</span>


<span class="s4">def </span><span class="s1">is_valid_dm(D</span><span class="s4">, </span><span class="s1">tol=</span><span class="s5">0.0</span><span class="s4">, </span><span class="s1">throw=</span><span class="s4">False, </span><span class="s1">name=</span><span class="s3">&quot;D&quot;</span><span class="s4">, </span><span class="s1">warning=</span><span class="s4">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return True if input array is a valid distance matrix. 
 
    Distance matrices must be 2-dimensional numpy arrays. 
    They must have a zero-diagonal, and they must be symmetric. 
 
    Parameters 
    ---------- 
    D : array_like 
        The candidate object to test for validity. 
    tol : float, optional 
        The distance matrix should be symmetric. `tol` is the maximum 
        difference between entries ``ij`` and ``ji`` for the distance 
        metric to be considered symmetric. 
    throw : bool, optional 
        An exception is thrown if the distance matrix passed is not valid. 
    name : str, optional 
        The name of the variable to checked. This is useful if 
        throw is set to True so the offending variable can be identified 
        in the exception message when an exception is thrown. 
    warning : bool, optional 
        Instead of throwing an exception, a warning message is 
        raised. 
 
    Returns 
    ------- 
    valid : bool 
        True if the variable `D` passed is a valid distance matrix. 
 
    Notes 
    ----- 
    Small numerical differences in `D` and `D.T` and non-zeroness of 
    the diagonal are ignored if they are within the tolerance specified 
    by `tol`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.spatial.distance import is_valid_dm 
 
    This matrix is a valid distance matrix. 
 
    &gt;&gt;&gt; d = np.array([[0.0, 1.1, 1.2, 1.3], 
    ...               [1.1, 0.0, 1.0, 1.4], 
    ...               [1.2, 1.0, 0.0, 1.5], 
    ...               [1.3, 1.4, 1.5, 0.0]]) 
    &gt;&gt;&gt; is_valid_dm(d) 
    True 
 
    In the following examples, the input is not a valid distance matrix. 
 
    Not square: 
 
    &gt;&gt;&gt; is_valid_dm([[0, 2, 2], [2, 0, 2]]) 
    False 
 
    Nonzero diagonal element: 
 
    &gt;&gt;&gt; is_valid_dm([[0, 1, 1], [1, 2, 3], [1, 3, 0]]) 
    False 
 
    Not symmetric: 
 
    &gt;&gt;&gt; is_valid_dm([[0, 1, 3], [2, 0, 1], [3, 1, 0]]) 
    False 
 
    &quot;&quot;&quot;</span>
    <span class="s1">D = np.asarray(D</span><span class="s4">, </span><span class="s1">order=</span><span class="s3">'c'</span><span class="s1">)</span>
    <span class="s1">valid = </span><span class="s4">True</span>
    <span class="s4">try</span><span class="s1">:</span>
        <span class="s1">s = D.shape</span>
        <span class="s4">if </span><span class="s1">len(D.shape) != </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s4">if </span><span class="s1">name:</span>
                <span class="s4">raise </span><span class="s1">ValueError((</span><span class="s3">'Distance matrix </span><span class="s4">\'</span><span class="s3">%s</span><span class="s4">\' </span><span class="s3">must have shape=2 '</span>
                                  <span class="s3">'(i.e. be two-dimensional).'</span><span class="s1">) % name)</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Distance matrix must have shape=2 (i.e. '</span>
                                 <span class="s3">'be two-dimensional).'</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">tol == </span><span class="s5">0.0</span><span class="s1">:</span>
            <span class="s4">if not </span><span class="s1">(D == D.T).all():</span>
                <span class="s4">if </span><span class="s1">name:</span>
                    <span class="s4">raise </span><span class="s1">ValueError((</span><span class="s3">'Distance matrix </span><span class="s4">\'</span><span class="s3">%s</span><span class="s4">\' </span><span class="s3">must be '</span>
                                     <span class="s3">'symmetric.'</span><span class="s1">) % name)</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Distance matrix must be symmetric.'</span><span class="s1">)</span>
            <span class="s4">if not </span><span class="s1">(D[range(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">s[</span><span class="s5">0</span><span class="s1">])</span><span class="s4">, </span><span class="s1">range(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">s[</span><span class="s5">0</span><span class="s1">])] == </span><span class="s5">0</span><span class="s1">).all():</span>
                <span class="s4">if </span><span class="s1">name:</span>
                    <span class="s4">raise </span><span class="s1">ValueError((</span><span class="s3">'Distance matrix </span><span class="s4">\'</span><span class="s3">%s</span><span class="s4">\' </span><span class="s3">diagonal must '</span>
                                      <span class="s3">'be zero.'</span><span class="s1">) % name)</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Distance matrix diagonal must be zero.'</span><span class="s1">)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">if not </span><span class="s1">(D - D.T &lt;= tol).all():</span>
                <span class="s4">if </span><span class="s1">name:</span>
                    <span class="s4">raise </span><span class="s1">ValueError((</span><span class="s3">'Distance matrix </span><span class="s4">\'</span><span class="s3">%s</span><span class="s4">\' </span><span class="s3">must be '</span>
                                      <span class="s3">'symmetric within tolerance %5.5f.'</span><span class="s1">)</span>
                                     <span class="s1">% (name</span><span class="s4">, </span><span class="s1">tol))</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Distance matrix must be symmetric within'</span>
                                     <span class="s3">' tolerance %5.5f.' </span><span class="s1">% tol)</span>
            <span class="s4">if not </span><span class="s1">(D[range(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">s[</span><span class="s5">0</span><span class="s1">])</span><span class="s4">, </span><span class="s1">range(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">s[</span><span class="s5">0</span><span class="s1">])] &lt;= tol).all():</span>
                <span class="s4">if </span><span class="s1">name:</span>
                    <span class="s4">raise </span><span class="s1">ValueError((</span><span class="s3">'Distance matrix </span><span class="s4">\'</span><span class="s3">%s</span><span class="s4">\' </span><span class="s3">diagonal must be'</span>
                                      <span class="s3">' close to zero within tolerance %5.5f.'</span><span class="s1">)</span>
                                     <span class="s1">% (name</span><span class="s4">, </span><span class="s1">tol))</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s4">raise </span><span class="s1">ValueError((</span><span class="s3">'Distance matrix </span><span class="s4">\'</span><span class="s3">%s</span><span class="s4">\' </span><span class="s3">diagonal must be'</span>
                                      <span class="s3">' close to zero within tolerance %5.5f.'</span><span class="s1">)</span>
                                     <span class="s1">% tol)</span>
    <span class="s4">except </span><span class="s1">Exception </span><span class="s4">as </span><span class="s1">e:</span>
        <span class="s4">if </span><span class="s1">throw:</span>
            <span class="s4">raise</span>
        <span class="s4">if </span><span class="s1">warning:</span>
            <span class="s1">warnings.warn(str(e))</span>
        <span class="s1">valid = </span><span class="s4">False</span>
    <span class="s4">return </span><span class="s1">valid</span>


<span class="s4">def </span><span class="s1">is_valid_y(y</span><span class="s4">, </span><span class="s1">warning=</span><span class="s4">False, </span><span class="s1">throw=</span><span class="s4">False, </span><span class="s1">name=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return True if the input array is a valid condensed distance matrix. 
 
    Condensed distance matrices must be 1-dimensional numpy arrays. 
    Their length must be a binomial coefficient :math:`{n \\choose 2}` 
    for some positive integer n. 
 
    Parameters 
    ---------- 
    y : array_like 
        The condensed distance matrix. 
    warning : bool, optional 
        Invokes a warning if the variable passed is not a valid 
        condensed distance matrix. The warning message explains why 
        the distance matrix is not valid.  `name` is used when 
        referencing the offending variable. 
    throw : bool, optional 
        Throws an exception if the variable passed is not a valid 
        condensed distance matrix. 
    name : bool, optional 
        Used when referencing the offending variable in the 
        warning or exception message. 
 
    Returns 
    ------- 
    bool 
        True if the input array is a valid condensed distance matrix, 
        False otherwise. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.spatial.distance import is_valid_y 
 
    This vector is a valid condensed distance matrix.  The length is 6, 
    which corresponds to ``n = 4``, since ``4*(4 - 1)/2`` is 6. 
 
    &gt;&gt;&gt; v = [1.0, 1.2, 1.0, 0.5, 1.3, 0.9] 
    &gt;&gt;&gt; is_valid_y(v) 
    True 
 
    An input vector with length, say, 7, is not a valid condensed distance 
    matrix. 
 
    &gt;&gt;&gt; is_valid_y([1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7]) 
    False 
 
    &quot;&quot;&quot;</span>
    <span class="s1">y = np.asarray(y</span><span class="s4">, </span><span class="s1">order=</span><span class="s3">'c'</span><span class="s1">)</span>
    <span class="s1">valid = </span><span class="s4">True</span>
    <span class="s4">try</span><span class="s1">:</span>
        <span class="s4">if </span><span class="s1">len(y.shape) != </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4">if </span><span class="s1">name:</span>
                <span class="s4">raise </span><span class="s1">ValueError((</span><span class="s3">'Condensed distance matrix </span><span class="s4">\'</span><span class="s3">%s</span><span class="s4">\' </span><span class="s3">must '</span>
                                  <span class="s3">'have shape=1 (i.e. be one-dimensional).'</span><span class="s1">)</span>
                                 <span class="s1">% name)</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Condensed distance matrix must have shape=1 '</span>
                                 <span class="s3">'(i.e. be one-dimensional).'</span><span class="s1">)</span>
        <span class="s1">n = y.shape[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">d = int(np.ceil(np.sqrt(n * </span><span class="s5">2</span><span class="s1">)))</span>
        <span class="s4">if </span><span class="s1">(d * (d - </span><span class="s5">1</span><span class="s1">) / </span><span class="s5">2</span><span class="s1">) != n:</span>
            <span class="s4">if </span><span class="s1">name:</span>
                <span class="s4">raise </span><span class="s1">ValueError((</span><span class="s3">'Length n of condensed distance matrix '</span>
                                  <span class="s3">'</span><span class="s4">\'</span><span class="s3">%s</span><span class="s4">\' </span><span class="s3">must be a binomial coefficient, i.e.'</span>
                                  <span class="s3">'there must be a k such that '</span>
                                  <span class="s3">'(k </span><span class="s4">\\</span><span class="s3">choose 2)=n)!'</span><span class="s1">) % name)</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Length n of condensed distance matrix must '</span>
                                 <span class="s3">'be a binomial coefficient, i.e. there must '</span>
                                 <span class="s3">'be a k such that (k </span><span class="s4">\\</span><span class="s3">choose 2)=n)!'</span><span class="s1">)</span>
    <span class="s4">except </span><span class="s1">Exception </span><span class="s4">as </span><span class="s1">e:</span>
        <span class="s4">if </span><span class="s1">throw:</span>
            <span class="s4">raise</span>
        <span class="s4">if </span><span class="s1">warning:</span>
            <span class="s1">warnings.warn(str(e))</span>
        <span class="s1">valid = </span><span class="s4">False</span>
    <span class="s4">return </span><span class="s1">valid</span>


<span class="s4">def </span><span class="s1">num_obs_dm(d):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the number of original observations that correspond to a 
    square, redundant distance matrix. 
 
    Parameters 
    ---------- 
    d : array_like 
        The target distance matrix. 
 
    Returns 
    ------- 
    num_obs_dm : int 
        The number of observations in the redundant distance matrix. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">d = np.asarray(d</span><span class="s4">, </span><span class="s1">order=</span><span class="s3">'c'</span><span class="s1">)</span>
    <span class="s1">is_valid_dm(d</span><span class="s4">, </span><span class="s1">tol=np.inf</span><span class="s4">, </span><span class="s1">throw=</span><span class="s4">True, </span><span class="s1">name=</span><span class="s3">'d'</span><span class="s1">)</span>
    <span class="s4">return </span><span class="s1">d.shape[</span><span class="s5">0</span><span class="s1">]</span>


<span class="s4">def </span><span class="s1">num_obs_y(Y):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the number of original observations that correspond to a 
    condensed distance matrix. 
 
    Parameters 
    ---------- 
    Y : array_like 
        Condensed distance matrix. 
 
    Returns 
    ------- 
    n : int 
        The number of observations in the condensed distance matrix `Y`. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">Y = np.asarray(Y</span><span class="s4">, </span><span class="s1">order=</span><span class="s3">'c'</span><span class="s1">)</span>
    <span class="s1">is_valid_y(Y</span><span class="s4">, </span><span class="s1">throw=</span><span class="s4">True, </span><span class="s1">name=</span><span class="s3">'Y'</span><span class="s1">)</span>
    <span class="s1">k = Y.shape[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s4">if </span><span class="s1">k == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;The number of observations cannot be determined on &quot;</span>
                         <span class="s3">&quot;an empty distance matrix.&quot;</span><span class="s1">)</span>
    <span class="s1">d = int(np.ceil(np.sqrt(k * </span><span class="s5">2</span><span class="s1">)))</span>
    <span class="s4">if </span><span class="s1">(d * (d - </span><span class="s5">1</span><span class="s1">) / </span><span class="s5">2</span><span class="s1">) != k:</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Invalid condensed distance matrix passed. Must be &quot;</span>
                         <span class="s3">&quot;some k where k=(n choose 2) for some n &gt;= 2.&quot;</span><span class="s1">)</span>
    <span class="s4">return </span><span class="s1">d</span>


<span class="s4">def </span><span class="s1">_prepare_out_argument(out</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">expected_shape):</span>
    <span class="s4">if </span><span class="s1">out </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s4">return </span><span class="s1">np.empty(expected_shape</span><span class="s4">, </span><span class="s1">dtype=dtype)</span>

    <span class="s4">if </span><span class="s1">out.shape != expected_shape:</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Output array has incorrect shape.&quot;</span><span class="s1">)</span>
    <span class="s4">if not </span><span class="s1">out.flags.c_contiguous:</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Output array must be C-contiguous.&quot;</span><span class="s1">)</span>
    <span class="s4">if </span><span class="s1">out.dtype != np.double:</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Output array must be double type.&quot;</span><span class="s1">)</span>
    <span class="s4">return </span><span class="s1">out</span>


<span class="s4">def </span><span class="s1">_pdist_callable(X</span><span class="s4">, </span><span class="s1">*</span><span class="s4">, </span><span class="s1">out</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">, </span><span class="s1">**kwargs):</span>
    <span class="s1">n = X.shape[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">out_size = (n * (n - </span><span class="s5">1</span><span class="s1">)) // </span><span class="s5">2</span>
    <span class="s1">dm = _prepare_out_argument(out</span><span class="s4">, </span><span class="s1">np.double</span><span class="s4">, </span><span class="s1">(out_size</span><span class="s4">,</span><span class="s1">))</span>
    <span class="s1">k = </span><span class="s5">0</span>
    <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(X.shape[</span><span class="s5">0</span><span class="s1">] - </span><span class="s5">1</span><span class="s1">):</span>
        <span class="s4">for </span><span class="s1">j </span><span class="s4">in </span><span class="s1">range(i + </span><span class="s5">1</span><span class="s4">, </span><span class="s1">X.shape[</span><span class="s5">0</span><span class="s1">]):</span>
            <span class="s1">dm[k] = metric(X[i]</span><span class="s4">, </span><span class="s1">X[j]</span><span class="s4">, </span><span class="s1">**kwargs)</span>
            <span class="s1">k += </span><span class="s5">1</span>
    <span class="s4">return </span><span class="s1">dm</span>


<span class="s4">def </span><span class="s1">_cdist_callable(XA</span><span class="s4">, </span><span class="s1">XB</span><span class="s4">, </span><span class="s1">*</span><span class="s4">, </span><span class="s1">out</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">, </span><span class="s1">**kwargs):</span>
    <span class="s1">mA = XA.shape[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">mB = XB.shape[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">dm = _prepare_out_argument(out</span><span class="s4">, </span><span class="s1">np.double</span><span class="s4">, </span><span class="s1">(mA</span><span class="s4">, </span><span class="s1">mB))</span>
    <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(mA):</span>
        <span class="s4">for </span><span class="s1">j </span><span class="s4">in </span><span class="s1">range(mB):</span>
            <span class="s1">dm[i</span><span class="s4">, </span><span class="s1">j] = metric(XA[i]</span><span class="s4">, </span><span class="s1">XB[j]</span><span class="s4">, </span><span class="s1">**kwargs)</span>
    <span class="s4">return </span><span class="s1">dm</span>


<span class="s4">def </span><span class="s1">cdist(XA</span><span class="s4">, </span><span class="s1">XB</span><span class="s4">, </span><span class="s1">metric=</span><span class="s3">'euclidean'</span><span class="s4">, </span><span class="s1">*</span><span class="s4">, </span><span class="s1">out=</span><span class="s4">None, </span><span class="s1">**kwargs):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute distance between each pair of the two collections of inputs. 
 
    See Notes for common calling conventions. 
 
    Parameters 
    ---------- 
    XA : array_like 
        An :math:`m_A` by :math:`n` array of :math:`m_A` 
        original observations in an :math:`n`-dimensional space. 
        Inputs are converted to float type. 
    XB : array_like 
        An :math:`m_B` by :math:`n` array of :math:`m_B` 
        original observations in an :math:`n`-dimensional space. 
        Inputs are converted to float type. 
    metric : str or callable, optional 
        The distance metric to use. If a string, the distance function can be 
        'braycurtis', 'canberra', 'chebyshev', 'cityblock', 'correlation', 
        'cosine', 'dice', 'euclidean', 'hamming', 'jaccard', 'jensenshannon', 
        'kulczynski1', 'mahalanobis', 'matching', 'minkowski', 
        'rogerstanimoto', 'russellrao', 'seuclidean', 'sokalmichener', 
        'sokalsneath', 'sqeuclidean', 'yule'. 
    **kwargs : dict, optional 
        Extra arguments to `metric`: refer to each metric documentation for a 
        list of all possible arguments. 
 
        Some possible arguments: 
 
        p : scalar 
        The p-norm to apply for Minkowski, weighted and unweighted. 
        Default: 2. 
 
        w : array_like 
        The weight vector for metrics that support weights (e.g., Minkowski). 
 
        V : array_like 
        The variance vector for standardized Euclidean. 
        Default: var(vstack([XA, XB]), axis=0, ddof=1) 
 
        VI : array_like 
        The inverse of the covariance matrix for Mahalanobis. 
        Default: inv(cov(vstack([XA, XB].T))).T 
 
        out : ndarray 
        The output array 
        If not None, the distance matrix Y is stored in this array. 
 
    Returns 
    ------- 
    Y : ndarray 
        A :math:`m_A` by :math:`m_B` distance matrix is returned. 
        For each :math:`i` and :math:`j`, the metric 
        ``dist(u=XA[i], v=XB[j])`` is computed and stored in the 
        :math:`ij` th entry. 
 
    Raises 
    ------ 
    ValueError 
        An exception is thrown if `XA` and `XB` do not have 
        the same number of columns. 
 
    Notes 
    ----- 
    The following are common calling conventions: 
 
    1. ``Y = cdist(XA, XB, 'euclidean')`` 
 
       Computes the distance between :math:`m` points using 
       Euclidean distance (2-norm) as the distance metric between the 
       points. The points are arranged as :math:`m` 
       :math:`n`-dimensional row vectors in the matrix X. 
 
    2. ``Y = cdist(XA, XB, 'minkowski', p=2.)`` 
 
       Computes the distances using the Minkowski distance 
       :math:`\\|u-v\\|_p` (:math:`p`-norm) where :math:`p &gt; 0` (note 
       that this is only a quasi-metric if :math:`0 &lt; p &lt; 1`). 
 
    3. ``Y = cdist(XA, XB, 'cityblock')`` 
 
       Computes the city block or Manhattan distance between the 
       points. 
 
    4. ``Y = cdist(XA, XB, 'seuclidean', V=None)`` 
 
       Computes the standardized Euclidean distance. The standardized 
       Euclidean distance between two n-vectors ``u`` and ``v`` is 
 
       .. math:: 
 
          \\sqrt{\\sum {(u_i-v_i)^2 / V[x_i]}}. 
 
       V is the variance vector; V[i] is the variance computed over all 
       the i'th components of the points. If not passed, it is 
       automatically computed. 
 
    5. ``Y = cdist(XA, XB, 'sqeuclidean')`` 
 
       Computes the squared Euclidean distance :math:`\\|u-v\\|_2^2` between 
       the vectors. 
 
    6. ``Y = cdist(XA, XB, 'cosine')`` 
 
       Computes the cosine distance between vectors u and v, 
 
       .. math:: 
 
          1 - \\frac{u \\cdot v} 
                   {{\\|u\\|}_2 {\\|v\\|}_2} 
 
       where :math:`\\|*\\|_2` is the 2-norm of its argument ``*``, and 
       :math:`u \\cdot v` is the dot product of :math:`u` and :math:`v`. 
 
    7. ``Y = cdist(XA, XB, 'correlation')`` 
 
       Computes the correlation distance between vectors u and v. This is 
 
       .. math:: 
 
          1 - \\frac{(u - \\bar{u}) \\cdot (v - \\bar{v})} 
                   {{\\|(u - \\bar{u})\\|}_2 {\\|(v - \\bar{v})\\|}_2} 
 
       where :math:`\\bar{v}` is the mean of the elements of vector v, 
       and :math:`x \\cdot y` is the dot product of :math:`x` and :math:`y`. 
 
 
    8. ``Y = cdist(XA, XB, 'hamming')`` 
 
       Computes the normalized Hamming distance, or the proportion of 
       those vector elements between two n-vectors ``u`` and ``v`` 
       which disagree. To save memory, the matrix ``X`` can be of type 
       boolean. 
 
    9. ``Y = cdist(XA, XB, 'jaccard')`` 
 
       Computes the Jaccard distance between the points. Given two 
       vectors, ``u`` and ``v``, the Jaccard distance is the 
       proportion of those elements ``u[i]`` and ``v[i]`` that 
       disagree where at least one of them is non-zero. 
 
    10. ``Y = cdist(XA, XB, 'jensenshannon')`` 
 
        Computes the Jensen-Shannon distance between two probability arrays. 
        Given two probability vectors, :math:`p` and :math:`q`, the 
        Jensen-Shannon distance is 
 
        .. math:: 
 
           \\sqrt{\\frac{D(p \\parallel m) + D(q \\parallel m)}{2}} 
 
        where :math:`m` is the pointwise mean of :math:`p` and :math:`q` 
        and :math:`D` is the Kullback-Leibler divergence. 
 
    11. ``Y = cdist(XA, XB, 'chebyshev')`` 
 
        Computes the Chebyshev distance between the points. The 
        Chebyshev distance between two n-vectors ``u`` and ``v`` is the 
        maximum norm-1 distance between their respective elements. More 
        precisely, the distance is given by 
 
        .. math:: 
 
           d(u,v) = \\max_i {|u_i-v_i|}. 
 
    12. ``Y = cdist(XA, XB, 'canberra')`` 
 
        Computes the Canberra distance between the points. The 
        Canberra distance between two points ``u`` and ``v`` is 
 
        .. math:: 
 
          d(u,v) = \\sum_i \\frac{|u_i-v_i|} 
                               {|u_i|+|v_i|}. 
 
    13. ``Y = cdist(XA, XB, 'braycurtis')`` 
 
        Computes the Bray-Curtis distance between the points. The 
        Bray-Curtis distance between two points ``u`` and ``v`` is 
 
 
        .. math:: 
 
             d(u,v) = \\frac{\\sum_i (|u_i-v_i|)} 
                           {\\sum_i (|u_i+v_i|)} 
 
    14. ``Y = cdist(XA, XB, 'mahalanobis', VI=None)`` 
 
        Computes the Mahalanobis distance between the points. The 
        Mahalanobis distance between two points ``u`` and ``v`` is 
        :math:`\\sqrt{(u-v)(1/V)(u-v)^T}` where :math:`(1/V)` (the ``VI`` 
        variable) is the inverse covariance. If ``VI`` is not None, 
        ``VI`` will be used as the inverse covariance matrix. 
 
    15. ``Y = cdist(XA, XB, 'yule')`` 
 
        Computes the Yule distance between the boolean 
        vectors. (see `yule` function documentation) 
 
    16. ``Y = cdist(XA, XB, 'matching')`` 
 
        Synonym for 'hamming'. 
 
    17. ``Y = cdist(XA, XB, 'dice')`` 
 
        Computes the Dice distance between the boolean vectors. (see 
        `dice` function documentation) 
 
    18. ``Y = cdist(XA, XB, 'kulczynski1')`` 
 
        Computes the kulczynski distance between the boolean 
        vectors. (see `kulczynski1` function documentation) 
 
    19. ``Y = cdist(XA, XB, 'rogerstanimoto')`` 
 
        Computes the Rogers-Tanimoto distance between the boolean 
        vectors. (see `rogerstanimoto` function documentation) 
 
    20. ``Y = cdist(XA, XB, 'russellrao')`` 
 
        Computes the Russell-Rao distance between the boolean 
        vectors. (see `russellrao` function documentation) 
 
    21. ``Y = cdist(XA, XB, 'sokalmichener')`` 
 
        Computes the Sokal-Michener distance between the boolean 
        vectors. (see `sokalmichener` function documentation) 
 
    22. ``Y = cdist(XA, XB, 'sokalsneath')`` 
 
        Computes the Sokal-Sneath distance between the vectors. (see 
        `sokalsneath` function documentation) 
 
    23. ``Y = cdist(XA, XB, f)`` 
 
        Computes the distance between all pairs of vectors in X 
        using the user supplied 2-arity function f. For example, 
        Euclidean distance between the vectors could be computed 
        as follows:: 
 
          dm = cdist(XA, XB, lambda u, v: np.sqrt(((u-v)**2).sum())) 
 
        Note that you should avoid passing a reference to one of 
        the distance functions defined in this library. For example,:: 
 
          dm = cdist(XA, XB, sokalsneath) 
 
        would calculate the pair-wise distances between the vectors in 
        X using the Python function `sokalsneath`. This would result in 
        sokalsneath being called :math:`{n \\choose 2}` times, which 
        is inefficient. Instead, the optimized C version is more 
        efficient, and we call it using the following syntax:: 
 
          dm = cdist(XA, XB, 'sokalsneath') 
 
    Examples 
    -------- 
    Find the Euclidean distances between four 2-D coordinates: 
 
    &gt;&gt;&gt; from scipy.spatial import distance 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; coords = [(35.0456, -85.2672), 
    ...           (35.1174, -89.9711), 
    ...           (35.9728, -83.9422), 
    ...           (36.1667, -86.7833)] 
    &gt;&gt;&gt; distance.cdist(coords, coords, 'euclidean') 
    array([[ 0.    ,  4.7044,  1.6172,  1.8856], 
           [ 4.7044,  0.    ,  6.0893,  3.3561], 
           [ 1.6172,  6.0893,  0.    ,  2.8477], 
           [ 1.8856,  3.3561,  2.8477,  0.    ]]) 
 
 
    Find the Manhattan distance from a 3-D point to the corners of the unit 
    cube: 
 
    &gt;&gt;&gt; a = np.array([[0, 0, 0], 
    ...               [0, 0, 1], 
    ...               [0, 1, 0], 
    ...               [0, 1, 1], 
    ...               [1, 0, 0], 
    ...               [1, 0, 1], 
    ...               [1, 1, 0], 
    ...               [1, 1, 1]]) 
    &gt;&gt;&gt; b = np.array([[ 0.1,  0.2,  0.4]]) 
    &gt;&gt;&gt; distance.cdist(a, b, 'cityblock') 
    array([[ 0.7], 
           [ 0.9], 
           [ 1.3], 
           [ 1.5], 
           [ 1.5], 
           [ 1.7], 
           [ 2.1], 
           [ 2.3]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2"># You can also call this as:</span>
    <span class="s2">#     Y = cdist(XA, XB, 'test_abc')</span>
    <span class="s2"># where 'abc' is the metric being tested.  This computes the distance</span>
    <span class="s2"># between all pairs of vectors in XA and XB using the distance metric 'abc'</span>
    <span class="s2"># but with a more succinct, verifiable, but less efficient implementation.</span>

    <span class="s1">XA = np.asarray(XA)</span>
    <span class="s1">XB = np.asarray(XB)</span>

    <span class="s1">s = XA.shape</span>
    <span class="s1">sB = XB.shape</span>

    <span class="s4">if </span><span class="s1">len(s) != </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'XA must be a 2-dimensional array.'</span><span class="s1">)</span>
    <span class="s4">if </span><span class="s1">len(sB) != </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'XB must be a 2-dimensional array.'</span><span class="s1">)</span>
    <span class="s4">if </span><span class="s1">s[</span><span class="s5">1</span><span class="s1">] != sB[</span><span class="s5">1</span><span class="s1">]:</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'XA and XB must have the same number of columns '</span>
                         <span class="s3">'(i.e. feature dimension.)'</span><span class="s1">)</span>

    <span class="s1">mA = s[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">mB = sB[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">n = s[</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s4">if </span><span class="s1">callable(metric):</span>
        <span class="s1">mstr = getattr(metric</span><span class="s4">, </span><span class="s3">'__name__'</span><span class="s4">, </span><span class="s3">'Unknown'</span><span class="s1">)</span>
        <span class="s1">metric_info = _METRIC_ALIAS.get(mstr</span><span class="s4">, None</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">metric_info </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">XA</span><span class="s4">, </span><span class="s1">XB</span><span class="s4">, </span><span class="s1">typ</span><span class="s4">, </span><span class="s1">kwargs = _validate_cdist_input(</span>
                <span class="s1">XA</span><span class="s4">, </span><span class="s1">XB</span><span class="s4">, </span><span class="s1">mA</span><span class="s4">, </span><span class="s1">mB</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">metric_info</span><span class="s4">, </span><span class="s1">**kwargs)</span>
        <span class="s4">return </span><span class="s1">_cdist_callable(XA</span><span class="s4">, </span><span class="s1">XB</span><span class="s4">, </span><span class="s1">metric=metric</span><span class="s4">, </span><span class="s1">out=out</span><span class="s4">, </span><span class="s1">**kwargs)</span>
    <span class="s4">elif </span><span class="s1">isinstance(metric</span><span class="s4">, </span><span class="s1">str):</span>
        <span class="s1">mstr = metric.lower()</span>
        <span class="s1">metric_info = _METRIC_ALIAS.get(mstr</span><span class="s4">, None</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">metric_info </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">cdist_fn = metric_info.cdist_func</span>
            <span class="s1">_extra_windows_error_checks(XA</span><span class="s4">, </span><span class="s1">out</span><span class="s4">, </span><span class="s1">(mA</span><span class="s4">, </span><span class="s1">mB)</span><span class="s4">, </span><span class="s1">**kwargs)</span>
            <span class="s4">return </span><span class="s1">cdist_fn(XA</span><span class="s4">, </span><span class="s1">XB</span><span class="s4">, </span><span class="s1">out=out</span><span class="s4">, </span><span class="s1">**kwargs)</span>
        <span class="s4">elif </span><span class="s1">mstr.startswith(</span><span class="s3">&quot;test_&quot;</span><span class="s1">):</span>
            <span class="s1">metric_info = _TEST_METRICS.get(mstr</span><span class="s4">, None</span><span class="s1">)</span>
            <span class="s4">if </span><span class="s1">metric_info </span><span class="s4">is None</span><span class="s1">:</span>
                <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">f'Unknown &quot;Test&quot; Distance Metric: </span><span class="s4">{</span><span class="s1">mstr[</span><span class="s5">5</span><span class="s1">:]</span><span class="s4">}</span><span class="s3">'</span><span class="s1">)</span>
            <span class="s1">XA</span><span class="s4">, </span><span class="s1">XB</span><span class="s4">, </span><span class="s1">typ</span><span class="s4">, </span><span class="s1">kwargs = _validate_cdist_input(</span>
                <span class="s1">XA</span><span class="s4">, </span><span class="s1">XB</span><span class="s4">, </span><span class="s1">mA</span><span class="s4">, </span><span class="s1">mB</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">metric_info</span><span class="s4">, </span><span class="s1">**kwargs)</span>
            <span class="s4">return </span><span class="s1">_cdist_callable(</span>
                <span class="s1">XA</span><span class="s4">, </span><span class="s1">XB</span><span class="s4">, </span><span class="s1">metric=metric_info.dist_func</span><span class="s4">, </span><span class="s1">out=out</span><span class="s4">, </span><span class="s1">**kwargs)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Unknown Distance Metric: %s' </span><span class="s1">% mstr)</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s4">raise </span><span class="s1">TypeError(</span><span class="s3">'2nd argument metric must be a string identifier '</span>
                        <span class="s3">'or a function.'</span><span class="s1">)</span>
</pre>
</body>
</html>