<html>
<head>
<title>summary.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
summary.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">statsmodels.compat.python </span><span class="s0">import </span><span class="s1">lmap</span><span class="s0">, </span><span class="s1">lrange</span><span class="s0">, </span><span class="s1">lzip</span>

<span class="s0">import </span><span class="s1">copy</span>
<span class="s0">from </span><span class="s1">itertools </span><span class="s0">import </span><span class="s1">zip_longest</span>
<span class="s0">import </span><span class="s1">time</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">statsmodels.iolib.table </span><span class="s0">import </span><span class="s1">SimpleTable</span>
<span class="s0">from </span><span class="s1">statsmodels.iolib.tableformatting </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">fmt_2</span><span class="s0">,</span>
    <span class="s1">fmt_2cols</span><span class="s0">,</span>
    <span class="s1">fmt_params</span><span class="s0">,</span>
    <span class="s1">gen_fmt</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">from </span><span class="s1">.summary2 </span><span class="s0">import </span><span class="s1">_model_types</span>


<span class="s0">def </span><span class="s1">forg(x</span><span class="s0">, </span><span class="s1">prec=</span><span class="s2">3</span><span class="s1">):</span>
    <span class="s1">x = np.squeeze(x)</span>
    <span class="s0">if </span><span class="s1">prec == </span><span class="s2">3</span><span class="s1">:</span>
        <span class="s3"># for 3 decimals</span>
        <span class="s0">if </span><span class="s1">(abs(x) &gt;= </span><span class="s2">1e4</span><span class="s1">) </span><span class="s0">or </span><span class="s1">(abs(x) &lt; </span><span class="s2">1e-4</span><span class="s1">):</span>
            <span class="s0">return </span><span class="s4">'%9.3g' </span><span class="s1">% x</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s4">'%9.3f' </span><span class="s1">% x</span>
    <span class="s0">elif </span><span class="s1">prec == </span><span class="s2">4</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">(abs(x) &gt;= </span><span class="s2">1e4</span><span class="s1">) </span><span class="s0">or </span><span class="s1">(abs(x) &lt; </span><span class="s2">1e-4</span><span class="s1">):</span>
            <span class="s0">return </span><span class="s4">'%10.4g' </span><span class="s1">% x</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s4">'%10.4f' </span><span class="s1">% x</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;`prec` argument must be either 3 or 4, not {prec}&quot;</span>
                         <span class="s1">.format(prec=prec))</span>


<span class="s0">def </span><span class="s1">d_or_f(x</span><span class="s0">, </span><span class="s1">width=</span><span class="s2">6</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot;convert number to string with either integer of float formatting 
 
    This is used internally for nobs and degrees of freedom which are usually 
    integers but can be float in some cases. 
 
    Parameters 
    ---------- 
    x : int or float 
    width : int 
        only used if x is nan 
 
    Returns 
    ------- 
    str : str 
        number as formatted string 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">np.isnan(x):</span>
        <span class="s0">return </span><span class="s1">(width - </span><span class="s2">3</span><span class="s1">) * </span><span class="s4">' ' </span><span class="s1">+ </span><span class="s4">'NaN'</span>

    <span class="s0">if </span><span class="s1">x // </span><span class="s2">1 </span><span class="s1">== x:</span>
        <span class="s0">return </span><span class="s4">&quot;%#6d&quot; </span><span class="s1">% x</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s4">&quot;%#8.2f&quot; </span><span class="s1">% x</span>


<span class="s0">def </span><span class="s1">summary(self</span><span class="s0">, </span><span class="s1">yname=</span><span class="s0">None, </span><span class="s1">xname=</span><span class="s0">None, </span><span class="s1">title=</span><span class="s2">0</span><span class="s0">, </span><span class="s1">alpha=</span><span class="s2">.05</span><span class="s0">,</span>
            <span class="s1">returns=</span><span class="s4">'text'</span><span class="s0">, </span><span class="s1">model_info=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Parameters 
    ---------- 
    yname : str 
            optional, Default is `Y` 
    xname : list[str] 
            optional, Default is `X.#` for # in p the number of regressors 
    Confidance interval : (0,1) not implimented 
    title : str 
            optional, Defualt is 'Generalized linear model' 
    returns : str 
              'text', 'table', 'csv', 'latex', 'html' 
 
    Returns 
    ------- 
    Default : 
    returns='print' 
            Prints the summarirized results 
 
    Option : 
    returns='text' 
            Prints the summarirized results 
 
    Option : 
    returns='table' 
             SimpleTable instance : summarizing the fit of a linear model. 
 
    Option : 
    returns='csv' 
            returns a string of csv of the results, to import into a spreadsheet 
 
    Option : 
    returns='latex' 
    Not implimented yet 
 
    Option : 
    returns='HTML' 
    Not implimented yet 
 
 
    Examples (needs updating) 
    -------- 
    &gt;&gt;&gt; import statsmodels as sm 
    &gt;&gt;&gt; data = sm.datasets.longley.load() 
    &gt;&gt;&gt; data.exog = sm.add_constant(data.exog) 
    &gt;&gt;&gt; ols_results = sm.OLS(data.endog, data.exog).results 
    &gt;&gt;&gt; print ols_results.summary() 
    ... 
 
    Notes 
    ----- 
    conf_int calculated from normal dist. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">title == </span><span class="s2">0</span><span class="s1">:</span>
        <span class="s1">title = _model_types[self.model.__class__.__name__]</span>

    <span class="s0">if </span><span class="s1">xname </span><span class="s0">is not None and </span><span class="s1">len(xname) != len(self.params):</span>
        <span class="s3"># GH 2298</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">'User supplied xnames must have the same number of '</span>
                         <span class="s4">'entries as the number of model parameters '</span>
                         <span class="s4">'({0})'</span><span class="s1">.format(len(self.params)))</span>

    <span class="s1">yname</span><span class="s0">, </span><span class="s1">xname = _getnames(self</span><span class="s0">, </span><span class="s1">yname</span><span class="s0">, </span><span class="s1">xname)</span>

    <span class="s1">time_now = time.localtime()</span>
    <span class="s1">time_of_day = [time.strftime(</span><span class="s4">&quot;%H:%M:%S&quot;</span><span class="s0">, </span><span class="s1">time_now)]</span>
    <span class="s1">date = time.strftime(</span><span class="s4">&quot;%a, %d %b %Y&quot;</span><span class="s0">, </span><span class="s1">time_now)</span>
    <span class="s1">modeltype = self.model.__class__.__name__</span>
    <span class="s1">nobs = self.nobs</span>
    <span class="s1">df_model = self.df_model</span>
    <span class="s1">df_resid = self.df_resid</span>

    <span class="s3">#General part of the summary table, Applicable to all? models</span>
    <span class="s3">#------------------------------------------------------------</span>
    <span class="s3"># TODO: define this generically, overwrite in model classes</span>
    <span class="s3">#replace definition of stubs data by single list</span>
    <span class="s3">#e.g.</span>
    <span class="s1">gen_left = [(</span><span class="s4">'Model type:'</span><span class="s0">, </span><span class="s1">[modeltype])</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s4">'Date:'</span><span class="s0">, </span><span class="s1">[date])</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s4">'Dependent Variable:'</span><span class="s0">, </span><span class="s1">yname)</span><span class="s0">,  </span><span class="s3"># TODO: What happens with multiple names?</span>
                <span class="s1">(</span><span class="s4">'df model'</span><span class="s0">, </span><span class="s1">[df_model])</span>
                <span class="s1">]</span>
    <span class="s1">gen_stubs_left</span><span class="s0">, </span><span class="s1">gen_data_left = zip_longest(*gen_left) </span><span class="s3">#transpose row col</span>

    <span class="s1">gen_title = title</span>
    <span class="s1">gen_header = </span><span class="s0">None</span>
    <span class="s1">gen_table_left = SimpleTable(gen_data_left</span><span class="s0">,</span>
                                 <span class="s1">gen_header</span><span class="s0">,</span>
                                 <span class="s1">gen_stubs_left</span><span class="s0">,</span>
                                 <span class="s1">title=gen_title</span><span class="s0">,</span>
                                 <span class="s1">txt_fmt=gen_fmt</span>
                                 <span class="s1">)</span>

    <span class="s1">gen_stubs_right = (</span><span class="s4">'Method:'</span><span class="s0">,</span>
                       <span class="s4">'Time:'</span><span class="s0">,</span>
                       <span class="s4">'Number of Obs:'</span><span class="s0">,</span>
                       <span class="s4">'df resid'</span><span class="s1">)</span>
    <span class="s1">gen_data_right = ([modeltype]</span><span class="s0">, </span><span class="s3">#was dist family need to look at more</span>
                      <span class="s1">time_of_day</span><span class="s0">,</span>
                      <span class="s1">[nobs]</span><span class="s0">,</span>
                      <span class="s1">[df_resid]</span>
                      <span class="s1">)</span>
    <span class="s1">gen_table_right = SimpleTable(gen_data_right</span><span class="s0">,</span>
                                  <span class="s1">gen_header</span><span class="s0">,</span>
                                  <span class="s1">gen_stubs_right</span><span class="s0">,</span>
                                  <span class="s1">title=gen_title</span><span class="s0">,</span>
                                  <span class="s1">txt_fmt=gen_fmt</span>
                                  <span class="s1">)</span>
    <span class="s1">gen_table_left.extend_right(gen_table_right)</span>
    <span class="s1">general_table = gen_table_left</span>

    <span class="s3"># Parameters part of the summary table</span>
    <span class="s3"># ------------------------------------</span>
    <span class="s3"># Note: this is not necessary since we standardized names,</span>
    <span class="s3">#  only t versus normal</span>
    <span class="s1">tstats = {</span><span class="s4">'OLS'</span><span class="s1">: self.t()</span><span class="s0">,</span>
              <span class="s4">'GLS'</span><span class="s1">: self.t()</span><span class="s0">,</span>
              <span class="s4">'GLSAR'</span><span class="s1">: self.t()</span><span class="s0">,</span>
              <span class="s4">'WLS'</span><span class="s1">: self.t()</span><span class="s0">,</span>
              <span class="s4">'RLM'</span><span class="s1">: self.t()</span><span class="s0">,</span>
              <span class="s4">'GLM'</span><span class="s1">: self.t()}</span>
    <span class="s1">prob_stats = {</span><span class="s4">'OLS'</span><span class="s1">: self.pvalues</span><span class="s0">,</span>
                  <span class="s4">'GLS'</span><span class="s1">: self.pvalues</span><span class="s0">,</span>
                  <span class="s4">'GLSAR'</span><span class="s1">: self.pvalues</span><span class="s0">,</span>
                  <span class="s4">'WLS'</span><span class="s1">: self.pvalues</span><span class="s0">,</span>
                  <span class="s4">'RLM'</span><span class="s1">: self.pvalues</span><span class="s0">,</span>
                  <span class="s4">'GLM'</span><span class="s1">: self.pvalues</span>
                  <span class="s1">}</span>
    <span class="s3"># Dictionary to store the header names for the parameter part of the</span>
    <span class="s3"># summary table. look up by modeltype</span>
    <span class="s1">alp = str((</span><span class="s2">1</span><span class="s1">-alpha)*</span><span class="s2">100</span><span class="s1">)+</span><span class="s4">'%'</span>
    <span class="s1">param_header = {</span>
         <span class="s4">'OLS'   </span><span class="s1">: [</span><span class="s4">'coef'</span><span class="s0">, </span><span class="s4">'std err'</span><span class="s0">, </span><span class="s4">'t'</span><span class="s0">, </span><span class="s4">'P&gt;|t|'</span><span class="s0">, </span><span class="s1">alp + </span><span class="s4">' Conf. Interval'</span><span class="s1">]</span><span class="s0">,</span>
         <span class="s4">'GLS'   </span><span class="s1">: [</span><span class="s4">'coef'</span><span class="s0">, </span><span class="s4">'std err'</span><span class="s0">, </span><span class="s4">'t'</span><span class="s0">, </span><span class="s4">'P&gt;|t|'</span><span class="s0">, </span><span class="s1">alp + </span><span class="s4">' Conf. Interval'</span><span class="s1">]</span><span class="s0">,</span>
         <span class="s4">'GLSAR' </span><span class="s1">: [</span><span class="s4">'coef'</span><span class="s0">, </span><span class="s4">'std err'</span><span class="s0">, </span><span class="s4">'t'</span><span class="s0">, </span><span class="s4">'P&gt;|t|'</span><span class="s0">, </span><span class="s1">alp + </span><span class="s4">' Conf. Interval'</span><span class="s1">]</span><span class="s0">,</span>
         <span class="s4">'WLS'   </span><span class="s1">: [</span><span class="s4">'coef'</span><span class="s0">, </span><span class="s4">'std err'</span><span class="s0">, </span><span class="s4">'t'</span><span class="s0">, </span><span class="s4">'P&gt;|t|'</span><span class="s0">, </span><span class="s1">alp + </span><span class="s4">' Conf. Interval'</span><span class="s1">]</span><span class="s0">,</span>
         <span class="s4">'GLM'   </span><span class="s1">: [</span><span class="s4">'coef'</span><span class="s0">, </span><span class="s4">'std err'</span><span class="s0">, </span><span class="s4">'t'</span><span class="s0">, </span><span class="s4">'P&gt;|t|'</span><span class="s0">, </span><span class="s1">alp + </span><span class="s4">' Conf. Interval'</span><span class="s1">]</span><span class="s0">, </span><span class="s3">#glm uses t-distribution</span>
         <span class="s4">'RLM'   </span><span class="s1">: [</span><span class="s4">'coef'</span><span class="s0">, </span><span class="s4">'std err'</span><span class="s0">, </span><span class="s4">'z'</span><span class="s0">, </span><span class="s4">'P&gt;|z|'</span><span class="s0">, </span><span class="s1">alp + </span><span class="s4">' Conf. Interval'</span><span class="s1">]  </span><span class="s3">#checke z</span>
                   <span class="s1">}</span>
    <span class="s1">params_stubs = xname</span>
    <span class="s1">params = self.params</span>
    <span class="s1">conf_int = self.conf_int(alpha)</span>
    <span class="s1">std_err = self.bse</span>
    <span class="s1">exog_len = lrange(len(xname))</span>
    <span class="s1">tstat = tstats[modeltype]</span>
    <span class="s1">prob_stat = prob_stats[modeltype]</span>

    <span class="s3"># Simpletable should be able to handle the formating</span>
    <span class="s1">params_data = lzip([</span><span class="s4">&quot;%#6.4g&quot; </span><span class="s1">% (params[i]) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">exog_len]</span><span class="s0">,</span>
                       <span class="s1">[</span><span class="s4">&quot;%#6.4f&quot; </span><span class="s1">% (std_err[i]) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">exog_len]</span><span class="s0">,</span>
                       <span class="s1">[</span><span class="s4">&quot;%#6.4f&quot; </span><span class="s1">% (tstat[i]) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">exog_len]</span><span class="s0">,</span>
                       <span class="s1">[</span><span class="s4">&quot;%#6.4f&quot; </span><span class="s1">% (prob_stat[i]) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">exog_len]</span><span class="s0">,</span>
                       <span class="s1">[</span><span class="s4">&quot;(%#5g, %#5g)&quot; </span><span class="s1">% tuple(conf_int[i]) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">exog_len])</span>
    <span class="s1">parameter_table = SimpleTable(params_data</span><span class="s0">,</span>
                                  <span class="s1">param_header[modeltype]</span><span class="s0">,</span>
                                  <span class="s1">params_stubs</span><span class="s0">,</span>
                                  <span class="s1">title=</span><span class="s0">None,</span>
                                  <span class="s1">txt_fmt=fmt_2</span>
                                  <span class="s1">)</span>

    <span class="s3">#special table</span>
    <span class="s3">#-------------</span>
    <span class="s3">#TODO: exists in linear_model, what about other models</span>
    <span class="s3">#residual diagnostics</span>

    <span class="s3">#output options</span>
    <span class="s3">#--------------</span>
    <span class="s3">#TODO: JP the rest needs to be fixed, similar to summary in linear_model</span>

    <span class="s0">def </span><span class="s1">ols_printer():</span>
        <span class="s5">&quot;&quot;&quot; 
        print summary table for ols models 
        &quot;&quot;&quot;</span>
        <span class="s1">table = str(general_table)+</span><span class="s4">'</span><span class="s0">\n</span><span class="s4">'</span><span class="s1">+str(parameter_table)</span>
        <span class="s0">return </span><span class="s1">table</span>

    <span class="s0">def </span><span class="s1">glm_printer():</span>
        <span class="s1">table = str(general_table)+</span><span class="s4">'</span><span class="s0">\n</span><span class="s4">'</span><span class="s1">+str(parameter_table)</span>
        <span class="s0">return </span><span class="s1">table</span>

    <span class="s1">printers = {</span><span class="s4">'OLS'</span><span class="s1">: ols_printer</span><span class="s0">, </span><span class="s4">'GLM'</span><span class="s1">: glm_printer}</span>

    <span class="s0">if </span><span class="s1">returns == </span><span class="s4">'print'</span><span class="s1">:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">printers[modeltype]()</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s0">return </span><span class="s1">printers[</span><span class="s4">'OLS'</span><span class="s1">]()</span>


<span class="s0">def </span><span class="s1">_getnames(self</span><span class="s0">, </span><span class="s1">yname=</span><span class="s0">None, </span><span class="s1">xname=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s5">'''extract names from model or construct names 
    '''</span>
    <span class="s0">if </span><span class="s1">yname </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">getattr(self.model</span><span class="s0">, </span><span class="s4">'endog_names'</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">yname = self.model.endog_names</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">yname = </span><span class="s4">'y'</span>

    <span class="s0">if </span><span class="s1">xname </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">getattr(self.model</span><span class="s0">, </span><span class="s4">'exog_names'</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">xname = self.model.exog_names</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">xname = [</span><span class="s4">'var_%d' </span><span class="s1">% i </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(self.params))]</span>

    <span class="s0">return </span><span class="s1">yname</span><span class="s0">, </span><span class="s1">xname</span>


<span class="s0">def </span><span class="s1">summary_top(results</span><span class="s0">, </span><span class="s1">title=</span><span class="s0">None, </span><span class="s1">gleft=</span><span class="s0">None, </span><span class="s1">gright=</span><span class="s0">None, </span><span class="s1">yname=</span><span class="s0">None, </span><span class="s1">xname=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s5">'''generate top table(s) 
 
 
    TODO: this still uses predefined model_methods 
    ? allow gleft, gright to be 1 element tuples instead of filling with None? 
 
    '''</span>
    <span class="s3">#change of names ?</span>
    <span class="s1">gen_left</span><span class="s0">, </span><span class="s1">gen_right = gleft</span><span class="s0">, </span><span class="s1">gright</span>

    <span class="s3"># time and names are always included</span>
    <span class="s1">time_now = time.localtime()</span>
    <span class="s1">time_of_day = [time.strftime(</span><span class="s4">&quot;%H:%M:%S&quot;</span><span class="s0">, </span><span class="s1">time_now)]</span>
    <span class="s1">date = time.strftime(</span><span class="s4">&quot;%a, %d %b %Y&quot;</span><span class="s0">, </span><span class="s1">time_now)</span>

    <span class="s1">yname</span><span class="s0">, </span><span class="s1">xname = _getnames(results</span><span class="s0">, </span><span class="s1">yname=yname</span><span class="s0">, </span><span class="s1">xname=xname)</span>

    <span class="s3"># create dictionary with default</span>
    <span class="s3"># use lambdas because some values raise exception if they are not available</span>
    <span class="s1">default_items = dict([</span>
          <span class="s1">(</span><span class="s4">'Dependent Variable:'</span><span class="s0">, lambda</span><span class="s1">: [yname])</span><span class="s0">,</span>
          <span class="s1">(</span><span class="s4">'Dep. Variable:'</span><span class="s0">, lambda</span><span class="s1">: [yname])</span><span class="s0">,</span>
          <span class="s1">(</span><span class="s4">'Model:'</span><span class="s0">, lambda</span><span class="s1">: [results.model.__class__.__name__])</span><span class="s0">,</span>
          <span class="s1">(</span><span class="s4">'Date:'</span><span class="s0">, lambda</span><span class="s1">: [date])</span><span class="s0">,</span>
          <span class="s1">(</span><span class="s4">'Time:'</span><span class="s0">, lambda</span><span class="s1">: time_of_day)</span><span class="s0">,</span>
          <span class="s1">(</span><span class="s4">'Number of Obs:'</span><span class="s0">, lambda</span><span class="s1">: [results.nobs])</span><span class="s0">,</span>
          <span class="s1">(</span><span class="s4">'No. Observations:'</span><span class="s0">, lambda</span><span class="s1">: [d_or_f(results.nobs)])</span><span class="s0">,</span>
          <span class="s1">(</span><span class="s4">'Df Model:'</span><span class="s0">, lambda</span><span class="s1">: [d_or_f(results.df_model)])</span><span class="s0">,</span>
          <span class="s1">(</span><span class="s4">'Df Residuals:'</span><span class="s0">, lambda</span><span class="s1">: [d_or_f(results.df_resid)])</span><span class="s0">,</span>
          <span class="s1">(</span><span class="s4">'Log-Likelihood:'</span><span class="s0">, lambda</span><span class="s1">: [</span><span class="s4">&quot;%#8.5g&quot; </span><span class="s1">% results.llf])  </span><span class="s3"># does not exist for RLM - exception</span>
    <span class="s1">])</span>

    <span class="s0">if </span><span class="s1">title </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">title = results.model.__class__.__name__ + </span><span class="s4">'Regression Results'</span>

    <span class="s0">if </span><span class="s1">gen_left </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s3"># default: General part of the summary table, Applicable to all? models</span>
        <span class="s1">gen_left = [(</span><span class="s4">'Dep. Variable:'</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">(</span><span class="s4">'Model type:'</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">(</span><span class="s4">'Date:'</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">(</span><span class="s4">'No. Observations:'</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">(</span><span class="s4">'Df model:'</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">(</span><span class="s4">'Df resid:'</span><span class="s0">, None</span><span class="s1">)]</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">llf = results.llf  </span><span class="s3"># noqa: F841</span>
            <span class="s1">gen_left.append((</span><span class="s4">'Log-Likelihood'</span><span class="s0">, None</span><span class="s1">))</span>
        <span class="s0">except</span><span class="s1">: </span><span class="s3"># AttributeError, NotImplementedError</span>
            <span class="s0">pass</span>

        <span class="s1">gen_right = []</span>

    <span class="s1">gen_title = title</span>
    <span class="s1">gen_header = </span><span class="s0">None</span>

    <span class="s3"># replace missing (None) values with default values</span>
    <span class="s1">gen_left_ = []</span>
    <span class="s0">for </span><span class="s1">item</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">gen_left:</span>
        <span class="s0">if </span><span class="s1">value </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">value = default_items[item]()  </span><span class="s3"># let KeyErrors raise exception</span>
        <span class="s1">gen_left_.append((item</span><span class="s0">, </span><span class="s1">value))</span>
    <span class="s1">gen_left = gen_left_</span>

    <span class="s0">if </span><span class="s1">gen_right:</span>
        <span class="s1">gen_right_ = []</span>
        <span class="s0">for </span><span class="s1">item</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">gen_right:</span>
            <span class="s0">if </span><span class="s1">value </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">value = default_items[item]()  </span><span class="s3"># let KeyErrors raise exception</span>
            <span class="s1">gen_right_.append((item</span><span class="s0">, </span><span class="s1">value))</span>
        <span class="s1">gen_right = gen_right_</span>

    <span class="s3"># check nothing was missed</span>
    <span class="s1">missing_values = [k </span><span class="s0">for </span><span class="s1">k</span><span class="s0">,</span><span class="s1">v </span><span class="s0">in </span><span class="s1">gen_left + gen_right </span><span class="s0">if </span><span class="s1">v </span><span class="s0">is None</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">missing_values == []</span><span class="s0">, </span><span class="s1">missing_values</span>

    <span class="s3"># pad both tables to equal number of rows</span>
    <span class="s0">if </span><span class="s1">gen_right:</span>
        <span class="s0">if </span><span class="s1">len(gen_right) &lt; len(gen_left):</span>
            <span class="s3"># fill up with blank lines to same length</span>
            <span class="s1">gen_right += [(</span><span class="s4">' '</span><span class="s0">, </span><span class="s4">' '</span><span class="s1">)] * (len(gen_left) - len(gen_right))</span>
        <span class="s0">elif </span><span class="s1">len(gen_right) &gt; len(gen_left):</span>
            <span class="s3"># fill up with blank lines to same length, just to keep it symmetric</span>
            <span class="s1">gen_left += [(</span><span class="s4">' '</span><span class="s0">, </span><span class="s4">' '</span><span class="s1">)] * (len(gen_right) - len(gen_left))</span>

        <span class="s3"># padding in SimpleTable does not work like I want</span>
        <span class="s3">#force extra spacing and exact string length in right table</span>
        <span class="s1">gen_right = [(</span><span class="s4">'%-21s' </span><span class="s1">% (</span><span class="s4">'  '</span><span class="s1">+k)</span><span class="s0">, </span><span class="s1">v) </span><span class="s0">for </span><span class="s1">k</span><span class="s0">,</span><span class="s1">v </span><span class="s0">in </span><span class="s1">gen_right]</span>
        <span class="s1">gen_stubs_right</span><span class="s0">, </span><span class="s1">gen_data_right = zip_longest(*gen_right) </span><span class="s3">#transpose row col</span>
        <span class="s1">gen_table_right = SimpleTable(gen_data_right</span><span class="s0">,</span>
                                      <span class="s1">gen_header</span><span class="s0">,</span>
                                      <span class="s1">gen_stubs_right</span><span class="s0">,</span>
                                      <span class="s1">title=gen_title</span><span class="s0">,</span>
                                      <span class="s1">txt_fmt=fmt_2cols</span>
                                      <span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">gen_table_right = []  </span><span class="s3">#because .extend_right seems works with []</span>

    <span class="s3">#moved below so that we can pad if needed to match length of gen_right</span>
    <span class="s3">#transpose rows and columns, `unzip`</span>
    <span class="s1">gen_stubs_left</span><span class="s0">, </span><span class="s1">gen_data_left = zip_longest(*gen_left) </span><span class="s3">#transpose row col</span>

    <span class="s1">gen_table_left = SimpleTable(gen_data_left</span><span class="s0">,</span>
                                 <span class="s1">gen_header</span><span class="s0">,</span>
                                 <span class="s1">gen_stubs_left</span><span class="s0">,</span>
                                 <span class="s1">title=gen_title</span><span class="s0">,</span>
                                 <span class="s1">txt_fmt=fmt_2cols</span>
                                 <span class="s1">)</span>

    <span class="s1">gen_table_left.extend_right(gen_table_right)</span>
    <span class="s1">general_table = gen_table_left</span>

    <span class="s0">return </span><span class="s1">general_table</span>


<span class="s0">def </span><span class="s1">summary_params(results</span><span class="s0">, </span><span class="s1">yname=</span><span class="s0">None, </span><span class="s1">xname=</span><span class="s0">None, </span><span class="s1">alpha=</span><span class="s2">.05</span><span class="s0">, </span><span class="s1">use_t=</span><span class="s0">True,</span>
                   <span class="s1">skip_header=</span><span class="s0">False, </span><span class="s1">title=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s5">'''create a summary table for the parameters 
 
    Parameters 
    ---------- 
    res : results instance 
        some required information is directly taken from the result 
        instance 
    yname : {str, None} 
        optional name for the endogenous variable, default is &quot;y&quot; 
    xname : {list[str], None} 
        optional names for the exogenous variables, default is &quot;var_xx&quot; 
    alpha : float 
        significance level for the confidence intervals 
    use_t : bool 
        indicator whether the p-values are based on the Student-t 
        distribution (if True) or on the normal distribution (if False) 
    skip_headers : bool 
        If false (default), then the header row is added. If true, then no 
        header row is added. 
 
    Returns 
    ------- 
    params_table : SimpleTable instance 
    '''</span>

    <span class="s3"># Parameters part of the summary table</span>
    <span class="s3"># ------------------------------------</span>
    <span class="s3"># Note: this is not necessary since we standardized names,</span>
    <span class="s3">#   only t versus normal</span>

    <span class="s0">if </span><span class="s1">isinstance(results</span><span class="s0">, </span><span class="s1">tuple):</span>
        <span class="s3"># for multivariate endog</span>
        <span class="s3"># TODO: check whether I do not want to refactor this</span>
        <span class="s3">#we need to give parameter alpha to conf_int</span>
        <span class="s1">results</span><span class="s0">, </span><span class="s1">params</span><span class="s0">, </span><span class="s1">std_err</span><span class="s0">, </span><span class="s1">tvalues</span><span class="s0">, </span><span class="s1">pvalues</span><span class="s0">, </span><span class="s1">conf_int = results</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">params = results.params</span>
        <span class="s1">std_err = results.bse</span>
        <span class="s1">tvalues = results.tvalues  </span><span class="s3"># is this sometimes called zvalues</span>
        <span class="s1">pvalues = results.pvalues</span>
        <span class="s1">conf_int = results.conf_int(alpha)</span>
    <span class="s0">if </span><span class="s1">params.size == </span><span class="s2">0</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">SimpleTable([[</span><span class="s4">'No Model Parameters'</span><span class="s1">]])</span>
    <span class="s3"># Dictionary to store the header names for the parameter part of the</span>
    <span class="s3"># summary table. look up by modeltype</span>
    <span class="s0">if </span><span class="s1">use_t:</span>
        <span class="s1">param_header = [</span><span class="s4">'coef'</span><span class="s0">, </span><span class="s4">'std err'</span><span class="s0">, </span><span class="s4">'t'</span><span class="s0">, </span><span class="s4">'P&gt;|t|'</span><span class="s0">,</span>
                        <span class="s4">'[' </span><span class="s1">+ str(alpha/</span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">str(</span><span class="s2">1</span><span class="s1">-alpha/</span><span class="s2">2</span><span class="s1">) + </span><span class="s4">']'</span><span class="s1">]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">param_header = [</span><span class="s4">'coef'</span><span class="s0">, </span><span class="s4">'std err'</span><span class="s0">, </span><span class="s4">'z'</span><span class="s0">, </span><span class="s4">'P&gt;|z|'</span><span class="s0">,</span>
                        <span class="s4">'[' </span><span class="s1">+ str(alpha/</span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">str(</span><span class="s2">1</span><span class="s1">-alpha/</span><span class="s2">2</span><span class="s1">) + </span><span class="s4">']'</span><span class="s1">]</span>

    <span class="s0">if </span><span class="s1">skip_header:</span>
        <span class="s1">param_header = </span><span class="s0">None</span>

    <span class="s1">_</span><span class="s0">, </span><span class="s1">xname = _getnames(results</span><span class="s0">, </span><span class="s1">yname=yname</span><span class="s0">, </span><span class="s1">xname=xname)</span>

    <span class="s0">if </span><span class="s1">len(xname) != len(params):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">'xnames and params do not have the same length'</span><span class="s1">)</span>

    <span class="s1">params_stubs = xname</span>

    <span class="s1">exog_idx = lrange(len(xname))</span>

    <span class="s1">params_data = lzip([forg(params[i]</span><span class="s0">, </span><span class="s1">prec=</span><span class="s2">4</span><span class="s1">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">exog_idx]</span><span class="s0">,</span>
                       <span class="s1">[forg(std_err[i]) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">exog_idx]</span><span class="s0">,</span>
                       <span class="s1">[forg(tvalues[i]) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">exog_idx]</span><span class="s0">,</span>
                       <span class="s1">[</span><span class="s4">&quot;%#6.3f&quot; </span><span class="s1">% (pvalues[i]) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">exog_idx]</span><span class="s0">,</span>
                       <span class="s1">[forg(conf_int[i</span><span class="s0">,</span><span class="s2">0</span><span class="s1">]) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">exog_idx]</span><span class="s0">,</span>
                       <span class="s1">[forg(conf_int[i</span><span class="s0">,</span><span class="s2">1</span><span class="s1">]) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">exog_idx])</span>
    <span class="s1">parameter_table = SimpleTable(params_data</span><span class="s0">,</span>
                                  <span class="s1">param_header</span><span class="s0">,</span>
                                  <span class="s1">params_stubs</span><span class="s0">,</span>
                                  <span class="s1">title=title</span><span class="s0">,</span>
                                  <span class="s1">txt_fmt=fmt_params</span>
                                  <span class="s1">)</span>

    <span class="s0">return </span><span class="s1">parameter_table</span>


<span class="s0">def </span><span class="s1">summary_params_frame(results</span><span class="s0">, </span><span class="s1">yname=</span><span class="s0">None, </span><span class="s1">xname=</span><span class="s0">None, </span><span class="s1">alpha=</span><span class="s2">.05</span><span class="s0">,</span>
                         <span class="s1">use_t=</span><span class="s0">True</span><span class="s1">):</span>
    <span class="s5">'''create a summary table for the parameters 
 
    Parameters 
    ---------- 
    res : results instance 
        some required information is directly taken from the result 
        instance 
    yname : {str, None} 
        optional name for the endogenous variable, default is &quot;y&quot; 
    xname : {list[str], None} 
        optional names for the exogenous variables, default is &quot;var_xx&quot; 
    alpha : float 
        significance level for the confidence intervals 
    use_t : bool 
        indicator whether the p-values are based on the Student-t 
        distribution (if True) or on the normal distribution (if False) 
    skip_headers : bool 
        If false (default), then the header row is added. If true, then no 
        header row is added. 
 
    Returns 
    ------- 
    params_table : SimpleTable instance 
    '''</span>

    <span class="s3"># Parameters part of the summary table</span>
    <span class="s3"># ------------------------------------</span>
    <span class="s3"># Note: this is not necessary since we standardized names,</span>
    <span class="s3">#   only t versus normal</span>

    <span class="s0">if </span><span class="s1">isinstance(results</span><span class="s0">, </span><span class="s1">tuple):</span>
        <span class="s3"># for multivariate endog</span>
        <span class="s3"># TODO: check whether I do not want to refactor this</span>
        <span class="s3">#we need to give parameter alpha to conf_int</span>
        <span class="s1">results</span><span class="s0">, </span><span class="s1">params</span><span class="s0">, </span><span class="s1">std_err</span><span class="s0">, </span><span class="s1">tvalues</span><span class="s0">, </span><span class="s1">pvalues</span><span class="s0">, </span><span class="s1">conf_int = results</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">params = results.params</span>
        <span class="s1">std_err = results.bse</span>
        <span class="s1">tvalues = results.tvalues  </span><span class="s3">#is this sometimes called zvalues</span>
        <span class="s1">pvalues = results.pvalues</span>
        <span class="s1">conf_int = results.conf_int(alpha)</span>

    <span class="s3"># Dictionary to store the header names for the parameter part of the</span>
    <span class="s3"># summary table. look up by modeltype</span>
    <span class="s0">if </span><span class="s1">use_t:</span>
        <span class="s1">param_header = [</span><span class="s4">'coef'</span><span class="s0">, </span><span class="s4">'std err'</span><span class="s0">, </span><span class="s4">'t'</span><span class="s0">, </span><span class="s4">'P&gt;|t|'</span><span class="s0">,</span>
                        <span class="s4">'Conf. Int. Low'</span><span class="s0">, </span><span class="s4">'Conf. Int. Upp.'</span><span class="s1">]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">param_header = [</span><span class="s4">'coef'</span><span class="s0">, </span><span class="s4">'std err'</span><span class="s0">, </span><span class="s4">'z'</span><span class="s0">, </span><span class="s4">'P&gt;|z|'</span><span class="s0">,</span>
                        <span class="s4">'Conf. Int. Low'</span><span class="s0">, </span><span class="s4">'Conf. Int. Upp.'</span><span class="s1">]</span>

    <span class="s1">_</span><span class="s0">, </span><span class="s1">xname = _getnames(results</span><span class="s0">, </span><span class="s1">yname=yname</span><span class="s0">, </span><span class="s1">xname=xname)</span>

    <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">DataFrame</span>
    <span class="s1">table = np.column_stack((params</span><span class="s0">, </span><span class="s1">std_err</span><span class="s0">, </span><span class="s1">tvalues</span><span class="s0">, </span><span class="s1">pvalues</span><span class="s0">, </span><span class="s1">conf_int))</span>
    <span class="s0">return </span><span class="s1">DataFrame(table</span><span class="s0">, </span><span class="s1">columns=param_header</span><span class="s0">, </span><span class="s1">index=xname)</span>


<span class="s0">def </span><span class="s1">summary_params_2d(result</span><span class="s0">, </span><span class="s1">extras=</span><span class="s0">None, </span><span class="s1">endog_names=</span><span class="s0">None, </span><span class="s1">exog_names=</span><span class="s0">None,</span>
                      <span class="s1">title=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s5">'''create summary table of regression parameters with several equations 
 
    This allows interleaving of parameters with bse and/or tvalues 
 
    Parameters 
    ---------- 
    result : result instance 
        the result instance with params and attributes in extras 
    extras : list[str] 
        additional attributes to add below a parameter row, e.g. bse or tvalues 
    endog_names : {list[str], None} 
        names for rows of the parameter array (multivariate endog) 
    exog_names : {list[str], None} 
        names for columns of the parameter array (exog) 
    alpha : float 
        level for confidence intervals, default 0.95 
    title : None or string 
 
    Returns 
    ------- 
    tables : list of SimpleTable 
        this contains a list of all seperate Subtables 
    table_all : SimpleTable 
        the merged table with results concatenated for each row of the parameter 
        array 
 
    '''</span>
    <span class="s0">if </span><span class="s1">endog_names </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s3"># TODO: note the [1:] is specific to current MNLogit</span>
        <span class="s1">endog_names = [</span><span class="s4">'endog_%d' </span><span class="s1">% i </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in</span>
                       <span class="s1">np.unique(result.model.endog)[</span><span class="s2">1</span><span class="s1">:]]</span>
    <span class="s0">if </span><span class="s1">exog_names </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">exog_names = [</span><span class="s4">'var%d' </span><span class="s1">% i </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(result.params))]</span>

    <span class="s3"># TODO: check formatting options with different values</span>
    <span class="s1">res_params = [[forg(item</span><span class="s0">, </span><span class="s1">prec=</span><span class="s2">4</span><span class="s1">) </span><span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">row] </span><span class="s0">for </span><span class="s1">row </span><span class="s0">in </span><span class="s1">result.params]</span>
    <span class="s0">if </span><span class="s1">extras:</span>
        <span class="s1">extras_list = [[[</span><span class="s4">'%10s' </span><span class="s1">% (</span><span class="s4">'(' </span><span class="s1">+ forg(v</span><span class="s0">, </span><span class="s1">prec=</span><span class="s2">3</span><span class="s1">).strip() + </span><span class="s4">')'</span><span class="s1">)</span>
                         <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">col]</span>
                        <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">getattr(result</span><span class="s0">, </span><span class="s1">what)]</span>
                       <span class="s0">for </span><span class="s1">what </span><span class="s0">in </span><span class="s1">extras</span>
                       <span class="s1">]</span>
        <span class="s1">data = lzip(res_params</span><span class="s0">, </span><span class="s1">*extras_list)</span>
        <span class="s1">data = [i </span><span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">data </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">j]  </span><span class="s3">#flatten</span>
        <span class="s1">stubs = lzip(endog_names</span><span class="s0">, </span><span class="s1">*[[</span><span class="s4">''</span><span class="s1">]*len(endog_names)]*len(extras))</span>
        <span class="s1">stubs = [i </span><span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">stubs </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">j] </span><span class="s3">#flatten</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">data = res_params</span>
        <span class="s1">stubs = endog_names</span>

    <span class="s1">txt_fmt = copy.deepcopy(fmt_params)</span>
    <span class="s1">txt_fmt[</span><span class="s4">&quot;data_fmts&quot;</span><span class="s1">] = [</span><span class="s4">&quot;%s&quot;</span><span class="s1">]*result.params.shape[</span><span class="s2">1</span><span class="s1">]</span>

    <span class="s0">return </span><span class="s1">SimpleTable(data</span><span class="s0">, </span><span class="s1">headers=exog_names</span><span class="s0">,</span>
                             <span class="s1">stubs=stubs</span><span class="s0">,</span>
                             <span class="s1">title=title</span><span class="s0">,</span>
                             <span class="s1">txt_fmt=txt_fmt)</span>


<span class="s0">def </span><span class="s1">summary_params_2dflat(result</span><span class="s0">, </span><span class="s1">endog_names=</span><span class="s0">None, </span><span class="s1">exog_names=</span><span class="s0">None, </span><span class="s1">alpha=</span><span class="s2">0.05</span><span class="s0">,</span>
                          <span class="s1">use_t=</span><span class="s0">True, </span><span class="s1">keep_headers=</span><span class="s0">True, </span><span class="s1">endog_cols=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s5">'''summary table for parameters that are 2d, e.g. multi-equation models 
 
    Parameters 
    ---------- 
    result : result instance 
        the result instance with params, bse, tvalues and conf_int 
    endog_names : {list[str], None} 
        names for rows of the parameter array (multivariate endog) 
    exog_names : {list[str], None} 
        names for columns of the parameter array (exog) 
    alpha : float 
        level for confidence intervals, default 0.95 
    use_t : bool 
        indicator whether the p-values are based on the Student-t 
        distribution (if True) or on the normal distribution (if False) 
    keep_headers : bool 
        If true (default), then sub-tables keep their headers. If false, then 
        only the first headers are kept, the other headerse are blanked out 
    endog_cols : bool 
        If false (default) then params and other result statistics have 
        equations by rows. If true, then equations are assumed to be in columns. 
        Not implemented yet. 
 
    Returns 
    ------- 
    tables : list of SimpleTable 
        this contains a list of all seperate Subtables 
    table_all : SimpleTable 
        the merged table with results concatenated for each row of the parameter 
        array 
 
    '''</span>

    <span class="s1">res = result</span>
    <span class="s1">params = res.params</span>
    <span class="s0">if </span><span class="s1">params.ndim == </span><span class="s2">2</span><span class="s1">:  </span><span class="s3"># we've got multiple equations</span>
        <span class="s1">n_equ = params.shape[</span><span class="s2">1</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">len(endog_names) != params.shape[</span><span class="s2">1</span><span class="s1">]:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">'endog_names has wrong length'</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">len(endog_names) != len(params):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">'endog_names has wrong length'</span><span class="s1">)</span>
        <span class="s1">n_equ = </span><span class="s2">1</span>

    <span class="s3">#VAR does not have conf_int</span>
    <span class="s3">#params = res.params.T # this is a convention for multi-eq models</span>

    <span class="s3"># check that we have the right length of names</span>
    <span class="s0">if not </span><span class="s1">isinstance(endog_names</span><span class="s0">, </span><span class="s1">list):</span>
        <span class="s3"># TODO: this might be specific to multinomial logit type, move?</span>
        <span class="s0">if </span><span class="s1">endog_names </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">endog_basename = </span><span class="s4">'endog'</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">endog_basename = endog_names</span>
        <span class="s3"># TODO: note, the [1:] is specific to current MNLogit</span>
        <span class="s1">endog_names = res.model.endog_names[</span><span class="s2">1</span><span class="s1">:]</span>

    <span class="s1">tables = []</span>
    <span class="s0">for </span><span class="s1">eq </span><span class="s0">in </span><span class="s1">range(n_equ):</span>
        <span class="s1">restup = (res</span><span class="s0">, </span><span class="s1">res.params[:</span><span class="s0">,</span><span class="s1">eq]</span><span class="s0">, </span><span class="s1">res.bse[:</span><span class="s0">,</span><span class="s1">eq]</span><span class="s0">, </span><span class="s1">res.tvalues[:</span><span class="s0">,</span><span class="s1">eq]</span><span class="s0">,</span>
                  <span class="s1">res.pvalues[:</span><span class="s0">,</span><span class="s1">eq]</span><span class="s0">, </span><span class="s1">res.conf_int(alpha)[eq])</span>

        <span class="s1">skiph = </span><span class="s0">False</span>
        <span class="s1">tble = summary_params(restup</span><span class="s0">, </span><span class="s1">yname=endog_names[eq]</span><span class="s0">,</span>
                              <span class="s1">xname=exog_names</span><span class="s0">, </span><span class="s1">alpha=alpha</span><span class="s0">, </span><span class="s1">use_t=use_t</span><span class="s0">,</span>
                              <span class="s1">skip_header=skiph)</span>

        <span class="s1">tables.append(tble)</span>

    <span class="s3"># add titles, they will be moved to header lines in table_extend</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(endog_names)):</span>
        <span class="s1">tables[i].title = endog_names[i]</span>

    <span class="s1">table_all = table_extend(tables</span><span class="s0">, </span><span class="s1">keep_headers=keep_headers)</span>

    <span class="s0">return </span><span class="s1">tables</span><span class="s0">, </span><span class="s1">table_all</span>


<span class="s0">def </span><span class="s1">table_extend(tables</span><span class="s0">, </span><span class="s1">keep_headers=</span><span class="s0">True</span><span class="s1">):</span>
    <span class="s5">'''extend a list of SimpleTables, adding titles to header of subtables 
 
    This function returns the merged table as a deepcopy, in contrast to the 
    SimpleTable extend method. 
 
    Parameters 
    ---------- 
    tables : list of SimpleTable instances 
    keep_headers : bool 
        If true, then all headers are kept. If falls, then the headers of 
        subtables are blanked out. 
 
    Returns 
    ------- 
    table_all : SimpleTable 
        merged tables as a single SimpleTable instance 
 
    '''</span>
    <span class="s0">from </span><span class="s1">copy </span><span class="s0">import </span><span class="s1">deepcopy</span>
    <span class="s0">for </span><span class="s1">ii</span><span class="s0">, </span><span class="s1">t </span><span class="s0">in </span><span class="s1">enumerate(tables[:]): </span><span class="s3">#[1:]:</span>
        <span class="s1">t = deepcopy(t)</span>

        <span class="s3">#move title to first cell of header</span>
        <span class="s3"># TODO: check if we have multiline headers</span>
        <span class="s0">if </span><span class="s1">t[</span><span class="s2">0</span><span class="s1">].datatype == </span><span class="s4">'header'</span><span class="s1">:</span>
            <span class="s1">t[</span><span class="s2">0</span><span class="s1">][</span><span class="s2">0</span><span class="s1">].data = t.title</span>
            <span class="s1">t[</span><span class="s2">0</span><span class="s1">][</span><span class="s2">0</span><span class="s1">]._datatype = </span><span class="s0">None</span>
            <span class="s1">t[</span><span class="s2">0</span><span class="s1">][</span><span class="s2">0</span><span class="s1">].row = t[</span><span class="s2">0</span><span class="s1">][</span><span class="s2">1</span><span class="s1">].row</span>
            <span class="s0">if not </span><span class="s1">keep_headers </span><span class="s0">and </span><span class="s1">(ii &gt; </span><span class="s2">0</span><span class="s1">):</span>
                <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">t[</span><span class="s2">0</span><span class="s1">][</span><span class="s2">1</span><span class="s1">:]:</span>
                    <span class="s1">c.data = </span><span class="s4">''</span>

        <span class="s3"># add separating line and extend tables</span>
        <span class="s0">if </span><span class="s1">ii == </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s1">table_all = t</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">r1 = table_all[-</span><span class="s2">1</span><span class="s1">]</span>
            <span class="s1">r1.add_format(</span><span class="s4">'txt'</span><span class="s0">, </span><span class="s1">row_dec_below=</span><span class="s4">'-'</span><span class="s1">)</span>
            <span class="s1">table_all.extend(t)</span>

    <span class="s1">table_all.title = </span><span class="s0">None</span>
    <span class="s0">return </span><span class="s1">table_all</span>


<span class="s0">def </span><span class="s1">summary_return(tables</span><span class="s0">, </span><span class="s1">return_fmt=</span><span class="s4">'text'</span><span class="s1">):</span>
    <span class="s3"># join table parts then print</span>
    <span class="s0">if </span><span class="s1">return_fmt == </span><span class="s4">'text'</span><span class="s1">:</span>
        <span class="s1">strdrop = </span><span class="s0">lambda </span><span class="s1">x: str(x).rsplit(</span><span class="s4">'</span><span class="s0">\n</span><span class="s4">'</span><span class="s0">,</span><span class="s2">1</span><span class="s1">)[</span><span class="s2">0</span><span class="s1">]</span>
        <span class="s3"># convert to string drop last line</span>
        <span class="s0">return </span><span class="s4">'</span><span class="s0">\n</span><span class="s4">'</span><span class="s1">.join(lmap(strdrop</span><span class="s0">, </span><span class="s1">tables[:-</span><span class="s2">1</span><span class="s1">]) + [str(tables[-</span><span class="s2">1</span><span class="s1">])])</span>
    <span class="s0">elif </span><span class="s1">return_fmt == </span><span class="s4">'tables'</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">tables</span>
    <span class="s0">elif </span><span class="s1">return_fmt == </span><span class="s4">'csv'</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s4">'</span><span class="s0">\n</span><span class="s4">'</span><span class="s1">.join(x.as_csv() </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">tables)</span>
    <span class="s0">elif </span><span class="s1">return_fmt == </span><span class="s4">'latex'</span><span class="s1">:</span>
        <span class="s3"># TODO: insert \hline after updating SimpleTable</span>
        <span class="s1">table = copy.deepcopy(tables[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s0">for </span><span class="s1">part </span><span class="s0">in </span><span class="s1">tables[</span><span class="s2">1</span><span class="s1">:]:</span>
            <span class="s1">table.extend(part)</span>
        <span class="s0">return </span><span class="s1">table.as_latex_tabular()</span>
    <span class="s0">elif </span><span class="s1">return_fmt == </span><span class="s4">'html'</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot;</span><span class="s1">.join(table.as_html() </span><span class="s0">for </span><span class="s1">table </span><span class="s0">in </span><span class="s1">tables)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">'available output formats are text, csv, latex, html'</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">Summary:</span>
    <span class="s5">&quot;&quot;&quot; 
    Result summary 
 
    Construction does not take any parameters. Tables and text can be added 
    with the `add_` methods. 
 
    Attributes 
    ---------- 
    tables : list of tables 
        Contains the list of SimpleTable instances, horizontally concatenated 
        tables are not saved separately. 
    extra_txt : str 
        extra lines that are added to the text output, used for warnings 
        and explanations. 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self.tables = []</span>
        <span class="s1">self.extra_txt = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">__str__(self):</span>
        <span class="s0">return </span><span class="s1">self.as_text()</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s1">str(type(self)) + </span><span class="s4">'</span><span class="s0">\n</span><span class="s4">&quot;&quot;&quot;</span><span class="s0">\n</span><span class="s4">' </span><span class="s1">+ self.__str__() + </span><span class="s4">'</span><span class="s0">\n</span><span class="s4">&quot;&quot;&quot;'</span>

    <span class="s0">def </span><span class="s1">_repr_html_(self):</span>
        <span class="s5">'''Display as HTML in IPython notebook.'''</span>
        <span class="s0">return </span><span class="s1">self.as_html()</span>

    <span class="s0">def </span><span class="s1">_repr_latex_(self):</span>
        <span class="s5">'''Display as LaTeX when converting IPython notebook to PDF.'''</span>
        <span class="s0">return </span><span class="s1">self.as_latex()</span>

    <span class="s0">def </span><span class="s1">add_table_2cols(self</span><span class="s0">, </span><span class="s1">res</span><span class="s0">,  </span><span class="s1">title=</span><span class="s0">None, </span><span class="s1">gleft=</span><span class="s0">None, </span><span class="s1">gright=</span><span class="s0">None,</span>
                        <span class="s1">yname=</span><span class="s0">None, </span><span class="s1">xname=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Add a double table, 2 tables with one column merged horizontally 
 
        Parameters 
        ---------- 
        res : results instance 
            some required information is directly taken from the result 
            instance 
        title : str, optional 
            if None, then a default title is used. 
        gleft : list[tuple], optional 
            elements for the left table, tuples are (name, value) pairs 
            If gleft is None, then a default table is created 
        gright : list[tuple], optional 
            elements for the right table, tuples are (name, value) pairs 
        yname : str, optional 
            optional name for the endogenous variable, default is &quot;y&quot; 
        xname : list[str], optional 
            optional names for the exogenous variables, default is &quot;var_xx&quot;. 
            Must match the number of parameters in the model. 
        &quot;&quot;&quot;</span>

        <span class="s1">table = summary_top(res</span><span class="s0">, </span><span class="s1">title=title</span><span class="s0">, </span><span class="s1">gleft=gleft</span><span class="s0">, </span><span class="s1">gright=gright</span><span class="s0">,</span>
                            <span class="s1">yname=yname</span><span class="s0">, </span><span class="s1">xname=xname)</span>
        <span class="s1">self.tables.append(table)</span>

    <span class="s0">def </span><span class="s1">add_table_params(self</span><span class="s0">, </span><span class="s1">res</span><span class="s0">, </span><span class="s1">yname=</span><span class="s0">None, </span><span class="s1">xname=</span><span class="s0">None, </span><span class="s1">alpha=</span><span class="s2">.05</span><span class="s0">,</span>
                         <span class="s1">use_t=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s5">'''create and add a table for the parameter estimates 
 
        Parameters 
        ---------- 
        res : results instance 
            some required information is directly taken from the result 
            instance 
        yname : {str, None} 
            optional name for the endogenous variable, default is &quot;y&quot; 
        xname : {list[str], None} 
            optional names for the exogenous variables, default is &quot;var_xx&quot; 
        alpha : float 
            significance level for the confidence intervals 
        use_t : bool 
            indicator whether the p-values are based on the Student-t 
            distribution (if True) or on the normal distribution (if False) 
 
        Returns 
        ------- 
        None : table is attached 
 
        '''</span>
        <span class="s0">if </span><span class="s1">res.params.ndim == </span><span class="s2">1</span><span class="s1">:</span>
            <span class="s1">table = summary_params(res</span><span class="s0">, </span><span class="s1">yname=yname</span><span class="s0">, </span><span class="s1">xname=xname</span><span class="s0">, </span><span class="s1">alpha=alpha</span><span class="s0">,</span>
                                   <span class="s1">use_t=use_t)</span>
        <span class="s0">elif </span><span class="s1">res.params.ndim == </span><span class="s2">2</span><span class="s1">:</span>
            <span class="s1">_</span><span class="s0">, </span><span class="s1">table = summary_params_2dflat(res</span><span class="s0">, </span><span class="s1">endog_names=yname</span><span class="s0">,</span>
                                             <span class="s1">exog_names=xname</span><span class="s0">,</span>
                                             <span class="s1">alpha=alpha</span><span class="s0">, </span><span class="s1">use_t=use_t)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">'params has to be 1d or 2d'</span><span class="s1">)</span>
        <span class="s1">self.tables.append(table)</span>

    <span class="s0">def </span><span class="s1">add_extra_txt(self</span><span class="s0">, </span><span class="s1">etext):</span>
        <span class="s5">'''add additional text that will be added at the end in text format 
 
        Parameters 
        ---------- 
        etext : list[str] 
            string with lines that are added to the text output. 
 
        '''</span>
        <span class="s1">self.extra_txt = </span><span class="s4">'</span><span class="s0">\n</span><span class="s4">'</span><span class="s1">.join(etext)</span>

    <span class="s0">def </span><span class="s1">as_text(self):</span>
        <span class="s5">'''return tables as string 
 
        Returns 
        ------- 
        txt : str 
            summary tables and extra text as one string 
 
        '''</span>
        <span class="s1">txt = summary_return(self.tables</span><span class="s0">, </span><span class="s1">return_fmt=</span><span class="s4">'text'</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">self.extra_txt </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">txt = txt + </span><span class="s4">'</span><span class="s0">\n\n</span><span class="s4">' </span><span class="s1">+ self.extra_txt</span>
        <span class="s0">return </span><span class="s1">txt</span>

    <span class="s0">def </span><span class="s1">as_latex(self):</span>
        <span class="s5">'''return tables as string 
 
        Returns 
        ------- 
        latex : str 
            summary tables and extra text as string of Latex 
 
        Notes 
        ----- 
        This currently merges tables with different number of columns. 
        It is recommended to use `as_latex_tabular` directly on the individual 
        tables. 
 
        '''</span>
        <span class="s1">latex = summary_return(self.tables</span><span class="s0">, </span><span class="s1">return_fmt=</span><span class="s4">'latex'</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">self.extra_txt </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">latex = latex + </span><span class="s4">'</span><span class="s0">\n\n</span><span class="s4">' </span><span class="s1">+ self.extra_txt.replace(</span><span class="s4">'</span><span class="s0">\n</span><span class="s4">'</span><span class="s0">, </span><span class="s4">' </span><span class="s0">\\</span><span class="s4">newline</span><span class="s0">\n </span><span class="s4">'</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">latex</span>

    <span class="s0">def </span><span class="s1">as_csv(self):</span>
        <span class="s5">'''return tables as string 
 
        Returns 
        ------- 
        csv : str 
            concatenated summary tables in comma delimited format 
 
        '''</span>
        <span class="s1">csv = summary_return(self.tables</span><span class="s0">, </span><span class="s1">return_fmt=</span><span class="s4">'csv'</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">self.extra_txt </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">csv = csv + </span><span class="s4">'</span><span class="s0">\n\n</span><span class="s4">' </span><span class="s1">+ self.extra_txt</span>
        <span class="s0">return </span><span class="s1">csv</span>

    <span class="s0">def </span><span class="s1">as_html(self):</span>
        <span class="s5">'''return tables as string 
 
        Returns 
        ------- 
        html : str 
            concatenated summary tables in HTML format 
 
        '''</span>
        <span class="s1">html = summary_return(self.tables</span><span class="s0">, </span><span class="s1">return_fmt=</span><span class="s4">'html'</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">self.extra_txt </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">html = html + </span><span class="s4">'&lt;br/&gt;&lt;br/&gt;' </span><span class="s1">+ self.extra_txt.replace(</span><span class="s4">'</span><span class="s0">\n</span><span class="s4">'</span><span class="s0">, </span><span class="s4">'&lt;br/&gt;'</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">html</span>
</pre>
</body>
</html>