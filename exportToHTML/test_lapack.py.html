<html>
<head>
<title>test_lapack.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_lapack.py</font>
</center></td></tr></table>
<pre><span class="s0">#</span>
<span class="s0"># Created by: Pearu Peterson, September 2002</span>
<span class="s0">#</span>

<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">reduce</span>

<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">(assert_equal</span><span class="s2">, </span><span class="s1">assert_array_almost_equal</span><span class="s2">, </span><span class="s1">assert_</span><span class="s2">,</span>
                           <span class="s1">assert_allclose</span><span class="s2">, </span><span class="s1">assert_almost_equal</span><span class="s2">,</span>
                           <span class="s1">assert_array_equal)</span>
<span class="s2">import </span><span class="s1">pytest</span>
<span class="s2">from </span><span class="s1">pytest </span><span class="s2">import </span><span class="s1">raises </span><span class="s2">as </span><span class="s1">assert_raises</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy </span><span class="s2">import </span><span class="s1">(eye</span><span class="s2">, </span><span class="s1">ones</span><span class="s2">, </span><span class="s1">zeros</span><span class="s2">, </span><span class="s1">zeros_like</span><span class="s2">, </span><span class="s1">triu</span><span class="s2">, </span><span class="s1">tril</span><span class="s2">, </span><span class="s1">tril_indices</span><span class="s2">,</span>
                   <span class="s1">triu_indices)</span>

<span class="s2">from </span><span class="s1">numpy.random </span><span class="s2">import </span><span class="s1">rand</span><span class="s2">, </span><span class="s1">randint</span><span class="s2">, </span><span class="s1">seed</span>

<span class="s2">from </span><span class="s1">scipy.linalg </span><span class="s2">import </span><span class="s1">(_flapack </span><span class="s2">as </span><span class="s1">flapack</span><span class="s2">, </span><span class="s1">lapack</span><span class="s2">, </span><span class="s1">inv</span><span class="s2">, </span><span class="s1">svd</span><span class="s2">, </span><span class="s1">cholesky</span><span class="s2">,</span>
                          <span class="s1">solve</span><span class="s2">, </span><span class="s1">ldl</span><span class="s2">, </span><span class="s1">norm</span><span class="s2">, </span><span class="s1">block_diag</span><span class="s2">, </span><span class="s1">qr</span><span class="s2">, </span><span class="s1">eigh)</span>

<span class="s2">from </span><span class="s1">scipy.linalg.lapack </span><span class="s2">import </span><span class="s1">_compute_lwork</span>
<span class="s2">from </span><span class="s1">scipy.stats </span><span class="s2">import </span><span class="s1">ortho_group</span><span class="s2">, </span><span class="s1">unitary_group</span>

<span class="s2">import </span><span class="s1">scipy.sparse </span><span class="s2">as </span><span class="s1">sps</span>
<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">from </span><span class="s1">scipy.__config__ </span><span class="s2">import </span><span class="s1">CONFIG</span>
<span class="s2">except </span><span class="s1">ImportError:</span>
    <span class="s1">CONFIG = </span><span class="s2">None</span>

<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">from </span><span class="s1">scipy.linalg </span><span class="s2">import </span><span class="s1">_clapack </span><span class="s2">as </span><span class="s1">clapack</span>
<span class="s2">except </span><span class="s1">ImportError:</span>
    <span class="s1">clapack = </span><span class="s2">None</span>
<span class="s2">from </span><span class="s1">scipy.linalg.lapack </span><span class="s2">import </span><span class="s1">get_lapack_funcs</span>
<span class="s2">from </span><span class="s1">scipy.linalg.blas </span><span class="s2">import </span><span class="s1">get_blas_funcs</span>

<span class="s1">REAL_DTYPES = [np.float32</span><span class="s2">, </span><span class="s1">np.float64]</span>
<span class="s1">COMPLEX_DTYPES = [np.complex64</span><span class="s2">, </span><span class="s1">np.complex128]</span>
<span class="s1">DTYPES = REAL_DTYPES + COMPLEX_DTYPES</span>

<span class="s1">blas_provider = blas_version = </span><span class="s2">None</span>
<span class="s2">if </span><span class="s1">CONFIG </span><span class="s2">is not None</span><span class="s1">:</span>
    <span class="s1">blas_provider = CONFIG[</span><span class="s3">'Build Dependencies'</span><span class="s1">][</span><span class="s3">'blas'</span><span class="s1">][</span><span class="s3">'name'</span><span class="s1">]</span>
    <span class="s1">blas_version = CONFIG[</span><span class="s3">'Build Dependencies'</span><span class="s1">][</span><span class="s3">'blas'</span><span class="s1">][</span><span class="s3">'version'</span><span class="s1">]</span>


<span class="s2">def </span><span class="s1">generate_random_dtype_array(shape</span><span class="s2">, </span><span class="s1">dtype):</span>
    <span class="s0"># generates a random matrix of desired data type of shape</span>
    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">COMPLEX_DTYPES:</span>
        <span class="s2">return </span><span class="s1">(np.random.rand(*shape)</span>
                <span class="s1">+ np.random.rand(*shape)*</span><span class="s4">1.0j</span><span class="s1">).astype(dtype)</span>
    <span class="s2">return </span><span class="s1">np.random.rand(*shape).astype(dtype)</span>


<span class="s2">def </span><span class="s1">test_lapack_documented():</span>
    <span class="s5">&quot;&quot;&quot;Test that all entries are in the doc.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">lapack.__doc__ </span><span class="s2">is None</span><span class="s1">:  </span><span class="s0"># just in case there is a python -OO</span>
        <span class="s1">pytest.skip(</span><span class="s3">'lapack.__doc__ is None'</span><span class="s1">)</span>
    <span class="s1">names = set(lapack.__doc__.split())</span>
    <span class="s1">ignore_list = {</span>
        <span class="s3">'absolute_import'</span><span class="s2">, </span><span class="s3">'clapack'</span><span class="s2">, </span><span class="s3">'division'</span><span class="s2">, </span><span class="s3">'find_best_lapack_type'</span><span class="s2">,</span>
        <span class="s3">'flapack'</span><span class="s2">, </span><span class="s3">'print_function'</span><span class="s2">, </span><span class="s3">'HAS_ILP64'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">missing = list()</span>
    <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">dir(lapack):</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">not </span><span class="s1">name.startswith(</span><span class="s3">'_'</span><span class="s1">) </span><span class="s2">and </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">ignore_list </span><span class="s2">and</span>
                <span class="s1">name </span><span class="s2">not in </span><span class="s1">names):</span>
            <span class="s1">missing.append(name)</span>
    <span class="s2">assert </span><span class="s1">missing == []</span><span class="s2">, </span><span class="s3">'Name(s) missing from lapack.__doc__ or ignore_list'</span>


<span class="s2">class </span><span class="s1">TestFlapackSimple:</span>

    <span class="s2">def </span><span class="s1">test_gebal(self):</span>
        <span class="s1">a = [[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">7</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">9</span><span class="s1">]]</span>
        <span class="s1">a1 = [[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">3e-4</span><span class="s1">]</span><span class="s2">,</span>
              <span class="s1">[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2e-3</span><span class="s1">]</span><span class="s2">,</span>
              <span class="s1">[</span><span class="s4">7</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
              <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]]</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s3">'sdzc'</span><span class="s1">:</span>
            <span class="s1">f = getattr(flapack</span><span class="s2">, </span><span class="s1">p+</span><span class="s3">'gebal'</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">f </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">continue</span>
            <span class="s1">ba</span><span class="s2">, </span><span class="s1">lo</span><span class="s2">, </span><span class="s1">hi</span><span class="s2">, </span><span class="s1">pivscale</span><span class="s2">, </span><span class="s1">info = f(a)</span>
            <span class="s1">assert_(</span><span class="s2">not </span><span class="s1">info</span><span class="s2">, </span><span class="s1">repr(info))</span>
            <span class="s1">assert_array_almost_equal(ba</span><span class="s2">, </span><span class="s1">a)</span>
            <span class="s1">assert_equal((lo</span><span class="s2">, </span><span class="s1">hi)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">len(a[</span><span class="s4">0</span><span class="s1">])-</span><span class="s4">1</span><span class="s1">))</span>
            <span class="s1">assert_array_almost_equal(pivscale</span><span class="s2">, </span><span class="s1">np.ones(len(a)))</span>

            <span class="s1">ba</span><span class="s2">, </span><span class="s1">lo</span><span class="s2">, </span><span class="s1">hi</span><span class="s2">, </span><span class="s1">pivscale</span><span class="s2">, </span><span class="s1">info = f(a1</span><span class="s2">, </span><span class="s1">permute=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">assert_(</span><span class="s2">not </span><span class="s1">info</span><span class="s2">, </span><span class="s1">repr(info))</span>
            <span class="s0"># print(a1)</span>
            <span class="s0"># print(ba, lo, hi, pivscale)</span>

    <span class="s2">def </span><span class="s1">test_gehrd(self):</span>
        <span class="s1">a = [[-</span><span class="s4">149</span><span class="s2">, </span><span class="s1">-</span><span class="s4">50</span><span class="s2">, </span><span class="s1">-</span><span class="s4">154</span><span class="s1">]</span><span class="s2">,</span>
             <span class="s1">[</span><span class="s4">537</span><span class="s2">, </span><span class="s4">180</span><span class="s2">, </span><span class="s4">546</span><span class="s1">]</span><span class="s2">,</span>
             <span class="s1">[-</span><span class="s4">27</span><span class="s2">, </span><span class="s1">-</span><span class="s4">9</span><span class="s2">, </span><span class="s1">-</span><span class="s4">25</span><span class="s1">]]</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s3">'d'</span><span class="s1">:</span>
            <span class="s1">f = getattr(flapack</span><span class="s2">, </span><span class="s1">p+</span><span class="s3">'gehrd'</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">f </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">continue</span>
            <span class="s1">ht</span><span class="s2">, </span><span class="s1">tau</span><span class="s2">, </span><span class="s1">info = f(a)</span>
            <span class="s1">assert_(</span><span class="s2">not </span><span class="s1">info</span><span class="s2">, </span><span class="s1">repr(info))</span>

    <span class="s2">def </span><span class="s1">test_trsyl(self):</span>
        <span class="s1">a = np.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]])</span>
        <span class="s1">b = np.array([[</span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">8</span><span class="s1">]])</span>
        <span class="s1">c = np.array([[</span><span class="s4">9</span><span class="s2">, </span><span class="s4">10</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">11</span><span class="s2">, </span><span class="s4">12</span><span class="s1">]])</span>
        <span class="s1">trans = </span><span class="s3">'T'</span>

        <span class="s0"># Test single and double implementations, including most</span>
        <span class="s0"># of the options</span>
        <span class="s2">for </span><span class="s1">dtype </span><span class="s2">in </span><span class="s3">'fdFD'</span><span class="s1">:</span>
            <span class="s1">a1</span><span class="s2">, </span><span class="s1">b1</span><span class="s2">, </span><span class="s1">c1 = a.astype(dtype)</span><span class="s2">, </span><span class="s1">b.astype(dtype)</span><span class="s2">, </span><span class="s1">c.astype(dtype)</span>
            <span class="s1">trsyl</span><span class="s2">, </span><span class="s1">= get_lapack_funcs((</span><span class="s3">'trsyl'</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(a1</span><span class="s2">,</span><span class="s1">))</span>
            <span class="s2">if </span><span class="s1">dtype.isupper():  </span><span class="s0"># is complex dtype</span>
                <span class="s1">a1[</span><span class="s4">0</span><span class="s1">] += </span><span class="s4">1j</span>
                <span class="s1">trans = </span><span class="s3">'C'</span>

            <span class="s1">x</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">info = trsyl(a1</span><span class="s2">, </span><span class="s1">b1</span><span class="s2">, </span><span class="s1">c1)</span>
            <span class="s1">assert_array_almost_equal(np.dot(a1</span><span class="s2">, </span><span class="s1">x) + np.dot(x</span><span class="s2">, </span><span class="s1">b1)</span><span class="s2">,</span>
                                      <span class="s1">scale * c1)</span>

            <span class="s1">x</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">info = trsyl(a1</span><span class="s2">, </span><span class="s1">b1</span><span class="s2">, </span><span class="s1">c1</span><span class="s2">, </span><span class="s1">trana=trans</span><span class="s2">, </span><span class="s1">tranb=trans)</span>
            <span class="s1">assert_array_almost_equal(</span>
                    <span class="s1">np.dot(a1.conjugate().T</span><span class="s2">, </span><span class="s1">x) + np.dot(x</span><span class="s2">, </span><span class="s1">b1.conjugate().T)</span><span class="s2">,</span>
                    <span class="s1">scale * c1</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">4</span><span class="s1">)</span>

            <span class="s1">x</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">info = trsyl(a1</span><span class="s2">, </span><span class="s1">b1</span><span class="s2">, </span><span class="s1">c1</span><span class="s2">, </span><span class="s1">isgn=-</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">assert_array_almost_equal(np.dot(a1</span><span class="s2">, </span><span class="s1">x) - np.dot(x</span><span class="s2">, </span><span class="s1">b1)</span><span class="s2">,</span>
                                      <span class="s1">scale * c1</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">4</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_lange(self):</span>
        <span class="s1">a = np.array([</span>
            <span class="s1">[-</span><span class="s4">149</span><span class="s2">, </span><span class="s1">-</span><span class="s4">50</span><span class="s2">, </span><span class="s1">-</span><span class="s4">154</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s4">537</span><span class="s2">, </span><span class="s4">180</span><span class="s2">, </span><span class="s4">546</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[-</span><span class="s4">27</span><span class="s2">, </span><span class="s1">-</span><span class="s4">9</span><span class="s2">, </span><span class="s1">-</span><span class="s4">25</span><span class="s1">]])</span>

        <span class="s2">for </span><span class="s1">dtype </span><span class="s2">in </span><span class="s3">'fdFD'</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">norm_str </span><span class="s2">in </span><span class="s3">'Mm1OoIiFfEe'</span><span class="s1">:</span>
                <span class="s1">a1 = a.astype(dtype)</span>
                <span class="s2">if </span><span class="s1">dtype.isupper():</span>
                    <span class="s0"># is complex dtype</span>
                    <span class="s1">a1[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] += </span><span class="s4">1j</span>

                <span class="s1">lange</span><span class="s2">, </span><span class="s1">= get_lapack_funcs((</span><span class="s3">'lange'</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(a1</span><span class="s2">,</span><span class="s1">))</span>
                <span class="s1">value = lange(norm_str</span><span class="s2">, </span><span class="s1">a1)</span>

                <span class="s2">if </span><span class="s1">norm_str </span><span class="s2">in </span><span class="s3">'FfEe'</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">in </span><span class="s3">'Ff'</span><span class="s1">:</span>
                        <span class="s1">decimal = </span><span class="s4">3</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">decimal = </span><span class="s4">7</span>
                    <span class="s1">ref = np.sqrt(np.sum(np.square(np.abs(a1))))</span>
                    <span class="s1">assert_almost_equal(value</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">decimal)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">norm_str </span><span class="s2">in </span><span class="s3">'Mm'</span><span class="s1">:</span>
                        <span class="s1">ref = np.max(np.abs(a1))</span>
                    <span class="s2">elif </span><span class="s1">norm_str </span><span class="s2">in </span><span class="s3">'1Oo'</span><span class="s1">:</span>
                        <span class="s1">ref = np.max(np.sum(np.abs(a1)</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">))</span>
                    <span class="s2">elif </span><span class="s1">norm_str </span><span class="s2">in </span><span class="s3">'Ii'</span><span class="s1">:</span>
                        <span class="s1">ref = np.max(np.sum(np.abs(a1)</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">))</span>

                    <span class="s1">assert_equal(value</span><span class="s2">, </span><span class="s1">ref)</span>


<span class="s2">class </span><span class="s1">TestLapack:</span>

    <span class="s2">def </span><span class="s1">test_flapack(self):</span>
        <span class="s2">if </span><span class="s1">hasattr(flapack</span><span class="s2">, </span><span class="s3">'empty_module'</span><span class="s1">):</span>
            <span class="s0"># flapack module is empty</span>
            <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_clapack(self):</span>
        <span class="s2">if </span><span class="s1">hasattr(clapack</span><span class="s2">, </span><span class="s3">'empty_module'</span><span class="s1">):</span>
            <span class="s0"># clapack module is empty</span>
            <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestLeastSquaresSolvers:</span>

    <span class="s2">def </span><span class="s1">test_gels(self):</span>
        <span class="s1">seed(</span><span class="s4">1234</span><span class="s1">)</span>
        <span class="s0"># Test fat/tall matrix argument handling - gh-issue #8329</span>
        <span class="s2">for </span><span class="s1">ind</span><span class="s2">, </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">enumerate(DTYPES):</span>
            <span class="s1">m = </span><span class="s4">10</span>
            <span class="s1">n = </span><span class="s4">20</span>
            <span class="s1">nrhs = </span><span class="s4">1</span>
            <span class="s1">a1 = rand(m</span><span class="s2">, </span><span class="s1">n).astype(dtype)</span>
            <span class="s1">b1 = rand(n).astype(dtype)</span>
            <span class="s1">gls</span><span class="s2">, </span><span class="s1">glslw = get_lapack_funcs((</span><span class="s3">'gels'</span><span class="s2">, </span><span class="s3">'gels_lwork'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

            <span class="s0"># Request of sizes</span>
            <span class="s1">lwork = _compute_lwork(glslw</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">nrhs)</span>
            <span class="s1">_</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">info = gls(a1</span><span class="s2">, </span><span class="s1">b1</span><span class="s2">, </span><span class="s1">lwork=lwork)</span>
            <span class="s1">assert_(info &gt;= </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">_</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">info = gls(a1</span><span class="s2">, </span><span class="s1">b1</span><span class="s2">, </span><span class="s1">trans=</span><span class="s3">'TTCC'</span><span class="s1">[ind]</span><span class="s2">, </span><span class="s1">lwork=lwork)</span>
            <span class="s1">assert_(info &gt;= </span><span class="s4">0</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">REAL_DTYPES:</span>
            <span class="s1">a1 = np.array([[</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">]</span><span class="s2">,</span>
                           <span class="s1">[</span><span class="s4">4.0</span><span class="s2">, </span><span class="s4">5.0</span><span class="s1">]</span><span class="s2">,</span>
                           <span class="s1">[</span><span class="s4">7.0</span><span class="s2">, </span><span class="s4">8.0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">b1 = np.array([</span><span class="s4">16.0</span><span class="s2">, </span><span class="s4">17.0</span><span class="s2">, </span><span class="s4">20.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">gels</span><span class="s2">, </span><span class="s1">gels_lwork</span><span class="s2">, </span><span class="s1">geqrf = get_lapack_funcs(</span>
                    <span class="s1">(</span><span class="s3">'gels'</span><span class="s2">, </span><span class="s3">'gels_lwork'</span><span class="s2">, </span><span class="s3">'geqrf'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(a1</span><span class="s2">, </span><span class="s1">b1))</span>

            <span class="s1">m</span><span class="s2">, </span><span class="s1">n = a1.shape</span>
            <span class="s2">if </span><span class="s1">len(b1.shape) == </span><span class="s4">2</span><span class="s1">:</span>
                <span class="s1">nrhs = b1.shape[</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">nrhs = </span><span class="s4">1</span>

            <span class="s0"># Request of sizes</span>
            <span class="s1">lwork = _compute_lwork(gels_lwork</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">nrhs)</span>

            <span class="s1">lqr</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">info = gels(a1</span><span class="s2">, </span><span class="s1">b1</span><span class="s2">, </span><span class="s1">lwork=lwork)</span>
            <span class="s1">assert_allclose(x[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.array([-</span><span class="s4">14.333333333333323</span><span class="s2">,</span>
                                              <span class="s4">14.999999999999991</span><span class="s1">]</span><span class="s2">,</span>
                                             <span class="s1">dtype=dtype)</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s4">25</span><span class="s1">*np.finfo(dtype).eps)</span>
            <span class="s1">lqr_truth</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_ = geqrf(a1)</span>
            <span class="s1">assert_array_equal(lqr</span><span class="s2">, </span><span class="s1">lqr_truth)</span>

        <span class="s2">for </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">COMPLEX_DTYPES:</span>
            <span class="s1">a1 = np.array([[</span><span class="s4">1.0</span><span class="s1">+</span><span class="s4">4.0j</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">]</span><span class="s2">,</span>
                           <span class="s1">[</span><span class="s4">4.0</span><span class="s1">+</span><span class="s4">0.5j</span><span class="s2">, </span><span class="s4">5.0</span><span class="s1">-</span><span class="s4">3.0j</span><span class="s1">]</span><span class="s2">,</span>
                           <span class="s1">[</span><span class="s4">7.0</span><span class="s1">-</span><span class="s4">2.0j</span><span class="s2">, </span><span class="s4">8.0</span><span class="s1">+</span><span class="s4">0.7j</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">b1 = np.array([</span><span class="s4">16.0</span><span class="s2">, </span><span class="s4">17.0</span><span class="s1">+</span><span class="s4">2.0j</span><span class="s2">, </span><span class="s4">20.0</span><span class="s1">-</span><span class="s4">4.0j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">gels</span><span class="s2">, </span><span class="s1">gels_lwork</span><span class="s2">, </span><span class="s1">geqrf = get_lapack_funcs(</span>
                    <span class="s1">(</span><span class="s3">'gels'</span><span class="s2">, </span><span class="s3">'gels_lwork'</span><span class="s2">, </span><span class="s3">'geqrf'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(a1</span><span class="s2">, </span><span class="s1">b1))</span>

            <span class="s1">m</span><span class="s2">, </span><span class="s1">n = a1.shape</span>
            <span class="s2">if </span><span class="s1">len(b1.shape) == </span><span class="s4">2</span><span class="s1">:</span>
                <span class="s1">nrhs = b1.shape[</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">nrhs = </span><span class="s4">1</span>

            <span class="s0"># Request of sizes</span>
            <span class="s1">lwork = _compute_lwork(gels_lwork</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">nrhs)</span>

            <span class="s1">lqr</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">info = gels(a1</span><span class="s2">, </span><span class="s1">b1</span><span class="s2">, </span><span class="s1">lwork=lwork)</span>
            <span class="s1">assert_allclose(x[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">np.array([</span><span class="s4">1.161753632288328</span><span class="s1">-</span><span class="s4">1.901075709391912j</span><span class="s2">,</span>
                                      <span class="s4">1.735882340522193</span><span class="s1">+</span><span class="s4">1.521240901196909j</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">dtype=dtype)</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">25</span><span class="s1">*np.finfo(dtype).eps)</span>
            <span class="s1">lqr_truth</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_ = geqrf(a1)</span>
            <span class="s1">assert_array_equal(lqr</span><span class="s2">, </span><span class="s1">lqr_truth)</span>

    <span class="s2">def </span><span class="s1">test_gelsd(self):</span>
        <span class="s2">for </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">REAL_DTYPES:</span>
            <span class="s1">a1 = np.array([[</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">]</span><span class="s2">,</span>
                           <span class="s1">[</span><span class="s4">4.0</span><span class="s2">, </span><span class="s4">5.0</span><span class="s1">]</span><span class="s2">,</span>
                           <span class="s1">[</span><span class="s4">7.0</span><span class="s2">, </span><span class="s4">8.0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">b1 = np.array([</span><span class="s4">16.0</span><span class="s2">, </span><span class="s4">17.0</span><span class="s2">, </span><span class="s4">20.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">gelsd</span><span class="s2">, </span><span class="s1">gelsd_lwork = get_lapack_funcs((</span><span class="s3">'gelsd'</span><span class="s2">, </span><span class="s3">'gelsd_lwork'</span><span class="s1">)</span><span class="s2">,</span>
                                                  <span class="s1">(a1</span><span class="s2">, </span><span class="s1">b1))</span>

            <span class="s1">m</span><span class="s2">, </span><span class="s1">n = a1.shape</span>
            <span class="s2">if </span><span class="s1">len(b1.shape) == </span><span class="s4">2</span><span class="s1">:</span>
                <span class="s1">nrhs = b1.shape[</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">nrhs = </span><span class="s4">1</span>

            <span class="s0"># Request of sizes</span>
            <span class="s1">work</span><span class="s2">, </span><span class="s1">iwork</span><span class="s2">, </span><span class="s1">info = gelsd_lwork(m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">nrhs</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">lwork = int(np.real(work))</span>
            <span class="s1">iwork_size = iwork</span>

            <span class="s1">x</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">rank</span><span class="s2">, </span><span class="s1">info = gelsd(a1</span><span class="s2">, </span><span class="s1">b1</span><span class="s2">, </span><span class="s1">lwork</span><span class="s2">, </span><span class="s1">iwork_size</span><span class="s2">,</span>
                                     <span class="s1">-</span><span class="s4">1</span><span class="s2">, False, False</span><span class="s1">)</span>
            <span class="s1">assert_allclose(x[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.array([-</span><span class="s4">14.333333333333323</span><span class="s2">,</span>
                                              <span class="s4">14.999999999999991</span><span class="s1">]</span><span class="s2">,</span>
                                             <span class="s1">dtype=dtype)</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s4">25</span><span class="s1">*np.finfo(dtype).eps)</span>
            <span class="s1">assert_allclose(s</span><span class="s2">, </span><span class="s1">np.array([</span><span class="s4">12.596017180511966</span><span class="s2">,</span>
                                         <span class="s4">0.583396253199685</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s4">25</span><span class="s1">*np.finfo(dtype).eps)</span>

        <span class="s2">for </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">COMPLEX_DTYPES:</span>
            <span class="s1">a1 = np.array([[</span><span class="s4">1.0</span><span class="s1">+</span><span class="s4">4.0j</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">]</span><span class="s2">,</span>
                           <span class="s1">[</span><span class="s4">4.0</span><span class="s1">+</span><span class="s4">0.5j</span><span class="s2">, </span><span class="s4">5.0</span><span class="s1">-</span><span class="s4">3.0j</span><span class="s1">]</span><span class="s2">,</span>
                           <span class="s1">[</span><span class="s4">7.0</span><span class="s1">-</span><span class="s4">2.0j</span><span class="s2">, </span><span class="s4">8.0</span><span class="s1">+</span><span class="s4">0.7j</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">b1 = np.array([</span><span class="s4">16.0</span><span class="s2">, </span><span class="s4">17.0</span><span class="s1">+</span><span class="s4">2.0j</span><span class="s2">, </span><span class="s4">20.0</span><span class="s1">-</span><span class="s4">4.0j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">gelsd</span><span class="s2">, </span><span class="s1">gelsd_lwork = get_lapack_funcs((</span><span class="s3">'gelsd'</span><span class="s2">, </span><span class="s3">'gelsd_lwork'</span><span class="s1">)</span><span class="s2">,</span>
                                                  <span class="s1">(a1</span><span class="s2">, </span><span class="s1">b1))</span>

            <span class="s1">m</span><span class="s2">, </span><span class="s1">n = a1.shape</span>
            <span class="s2">if </span><span class="s1">len(b1.shape) == </span><span class="s4">2</span><span class="s1">:</span>
                <span class="s1">nrhs = b1.shape[</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">nrhs = </span><span class="s4">1</span>

            <span class="s0"># Request of sizes</span>
            <span class="s1">work</span><span class="s2">, </span><span class="s1">rwork</span><span class="s2">, </span><span class="s1">iwork</span><span class="s2">, </span><span class="s1">info = gelsd_lwork(m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">nrhs</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">lwork = int(np.real(work))</span>
            <span class="s1">rwork_size = int(rwork)</span>
            <span class="s1">iwork_size = iwork</span>

            <span class="s1">x</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">rank</span><span class="s2">, </span><span class="s1">info = gelsd(a1</span><span class="s2">, </span><span class="s1">b1</span><span class="s2">, </span><span class="s1">lwork</span><span class="s2">, </span><span class="s1">rwork_size</span><span class="s2">, </span><span class="s1">iwork_size</span><span class="s2">,</span>
                                     <span class="s1">-</span><span class="s4">1</span><span class="s2">, False, False</span><span class="s1">)</span>
            <span class="s1">assert_allclose(x[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">np.array([</span><span class="s4">1.161753632288328</span><span class="s1">-</span><span class="s4">1.901075709391912j</span><span class="s2">,</span>
                                      <span class="s4">1.735882340522193</span><span class="s1">+</span><span class="s4">1.521240901196909j</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">dtype=dtype)</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">25</span><span class="s1">*np.finfo(dtype).eps)</span>
            <span class="s1">assert_allclose(s</span><span class="s2">,</span>
                            <span class="s1">np.array([</span><span class="s4">13.035514762572043</span><span class="s2">, </span><span class="s4">4.337666985231382</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">dtype=dtype)</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">25</span><span class="s1">*np.finfo(dtype).eps)</span>

    <span class="s2">def </span><span class="s1">test_gelss(self):</span>

        <span class="s2">for </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">REAL_DTYPES:</span>
            <span class="s1">a1 = np.array([[</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">]</span><span class="s2">,</span>
                           <span class="s1">[</span><span class="s4">4.0</span><span class="s2">, </span><span class="s4">5.0</span><span class="s1">]</span><span class="s2">,</span>
                           <span class="s1">[</span><span class="s4">7.0</span><span class="s2">, </span><span class="s4">8.0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">b1 = np.array([</span><span class="s4">16.0</span><span class="s2">, </span><span class="s4">17.0</span><span class="s2">, </span><span class="s4">20.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">gelss</span><span class="s2">, </span><span class="s1">gelss_lwork = get_lapack_funcs((</span><span class="s3">'gelss'</span><span class="s2">, </span><span class="s3">'gelss_lwork'</span><span class="s1">)</span><span class="s2">,</span>
                                                  <span class="s1">(a1</span><span class="s2">, </span><span class="s1">b1))</span>

            <span class="s1">m</span><span class="s2">, </span><span class="s1">n = a1.shape</span>
            <span class="s2">if </span><span class="s1">len(b1.shape) == </span><span class="s4">2</span><span class="s1">:</span>
                <span class="s1">nrhs = b1.shape[</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">nrhs = </span><span class="s4">1</span>

            <span class="s0"># Request of sizes</span>
            <span class="s1">work</span><span class="s2">, </span><span class="s1">info = gelss_lwork(m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">nrhs</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">lwork = int(np.real(work))</span>

            <span class="s1">v</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">rank</span><span class="s2">, </span><span class="s1">work</span><span class="s2">, </span><span class="s1">info = gelss(a1</span><span class="s2">, </span><span class="s1">b1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">lwork</span><span class="s2">, False, False</span><span class="s1">)</span>
            <span class="s1">assert_allclose(x[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.array([-</span><span class="s4">14.333333333333323</span><span class="s2">,</span>
                                              <span class="s4">14.999999999999991</span><span class="s1">]</span><span class="s2">,</span>
                                             <span class="s1">dtype=dtype)</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s4">25</span><span class="s1">*np.finfo(dtype).eps)</span>
            <span class="s1">assert_allclose(s</span><span class="s2">, </span><span class="s1">np.array([</span><span class="s4">12.596017180511966</span><span class="s2">,</span>
                                         <span class="s4">0.583396253199685</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s4">25</span><span class="s1">*np.finfo(dtype).eps)</span>

        <span class="s2">for </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">COMPLEX_DTYPES:</span>
            <span class="s1">a1 = np.array([[</span><span class="s4">1.0</span><span class="s1">+</span><span class="s4">4.0j</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">]</span><span class="s2">,</span>
                           <span class="s1">[</span><span class="s4">4.0</span><span class="s1">+</span><span class="s4">0.5j</span><span class="s2">, </span><span class="s4">5.0</span><span class="s1">-</span><span class="s4">3.0j</span><span class="s1">]</span><span class="s2">,</span>
                           <span class="s1">[</span><span class="s4">7.0</span><span class="s1">-</span><span class="s4">2.0j</span><span class="s2">, </span><span class="s4">8.0</span><span class="s1">+</span><span class="s4">0.7j</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">b1 = np.array([</span><span class="s4">16.0</span><span class="s2">, </span><span class="s4">17.0</span><span class="s1">+</span><span class="s4">2.0j</span><span class="s2">, </span><span class="s4">20.0</span><span class="s1">-</span><span class="s4">4.0j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">gelss</span><span class="s2">, </span><span class="s1">gelss_lwork = get_lapack_funcs((</span><span class="s3">'gelss'</span><span class="s2">, </span><span class="s3">'gelss_lwork'</span><span class="s1">)</span><span class="s2">,</span>
                                                  <span class="s1">(a1</span><span class="s2">, </span><span class="s1">b1))</span>

            <span class="s1">m</span><span class="s2">, </span><span class="s1">n = a1.shape</span>
            <span class="s2">if </span><span class="s1">len(b1.shape) == </span><span class="s4">2</span><span class="s1">:</span>
                <span class="s1">nrhs = b1.shape[</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">nrhs = </span><span class="s4">1</span>

            <span class="s0"># Request of sizes</span>
            <span class="s1">work</span><span class="s2">, </span><span class="s1">info = gelss_lwork(m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">nrhs</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">lwork = int(np.real(work))</span>

            <span class="s1">v</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">rank</span><span class="s2">, </span><span class="s1">work</span><span class="s2">, </span><span class="s1">info = gelss(a1</span><span class="s2">, </span><span class="s1">b1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">lwork</span><span class="s2">, False, False</span><span class="s1">)</span>
            <span class="s1">assert_allclose(x[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">np.array([</span><span class="s4">1.161753632288328</span><span class="s1">-</span><span class="s4">1.901075709391912j</span><span class="s2">,</span>
                                      <span class="s4">1.735882340522193</span><span class="s1">+</span><span class="s4">1.521240901196909j</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">dtype=dtype)</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s4">25</span><span class="s1">*np.finfo(dtype).eps)</span>
            <span class="s1">assert_allclose(s</span><span class="s2">, </span><span class="s1">np.array([</span><span class="s4">13.035514762572043</span><span class="s2">,</span>
                                         <span class="s4">4.337666985231382</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s4">25</span><span class="s1">*np.finfo(dtype).eps)</span>

    <span class="s2">def </span><span class="s1">test_gelsy(self):</span>

        <span class="s2">for </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">REAL_DTYPES:</span>
            <span class="s1">a1 = np.array([[</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">]</span><span class="s2">,</span>
                           <span class="s1">[</span><span class="s4">4.0</span><span class="s2">, </span><span class="s4">5.0</span><span class="s1">]</span><span class="s2">,</span>
                           <span class="s1">[</span><span class="s4">7.0</span><span class="s2">, </span><span class="s4">8.0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">b1 = np.array([</span><span class="s4">16.0</span><span class="s2">, </span><span class="s4">17.0</span><span class="s2">, </span><span class="s4">20.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">gelsy</span><span class="s2">, </span><span class="s1">gelsy_lwork = get_lapack_funcs((</span><span class="s3">'gelsy'</span><span class="s2">, </span><span class="s3">'gelss_lwork'</span><span class="s1">)</span><span class="s2">,</span>
                                                  <span class="s1">(a1</span><span class="s2">, </span><span class="s1">b1))</span>

            <span class="s1">m</span><span class="s2">, </span><span class="s1">n = a1.shape</span>
            <span class="s2">if </span><span class="s1">len(b1.shape) == </span><span class="s4">2</span><span class="s1">:</span>
                <span class="s1">nrhs = b1.shape[</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">nrhs = </span><span class="s4">1</span>

            <span class="s0"># Request of sizes</span>
            <span class="s1">work</span><span class="s2">, </span><span class="s1">info = gelsy_lwork(m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">nrhs</span><span class="s2">, </span><span class="s4">10</span><span class="s1">*np.finfo(dtype).eps)</span>
            <span class="s1">lwork = int(np.real(work))</span>

            <span class="s1">jptv = np.zeros((a1.shape[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.int32)</span>
            <span class="s1">v</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">rank</span><span class="s2">, </span><span class="s1">info = gelsy(a1</span><span class="s2">, </span><span class="s1">b1</span><span class="s2">, </span><span class="s1">jptv</span><span class="s2">, </span><span class="s1">np.finfo(dtype).eps</span><span class="s2">,</span>
                                        <span class="s1">lwork</span><span class="s2">, False, False</span><span class="s1">)</span>
            <span class="s1">assert_allclose(x[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.array([-</span><span class="s4">14.333333333333323</span><span class="s2">,</span>
                                              <span class="s4">14.999999999999991</span><span class="s1">]</span><span class="s2">,</span>
                                             <span class="s1">dtype=dtype)</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s4">25</span><span class="s1">*np.finfo(dtype).eps)</span>

        <span class="s2">for </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">COMPLEX_DTYPES:</span>
            <span class="s1">a1 = np.array([[</span><span class="s4">1.0</span><span class="s1">+</span><span class="s4">4.0j</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">]</span><span class="s2">,</span>
                           <span class="s1">[</span><span class="s4">4.0</span><span class="s1">+</span><span class="s4">0.5j</span><span class="s2">, </span><span class="s4">5.0</span><span class="s1">-</span><span class="s4">3.0j</span><span class="s1">]</span><span class="s2">,</span>
                           <span class="s1">[</span><span class="s4">7.0</span><span class="s1">-</span><span class="s4">2.0j</span><span class="s2">, </span><span class="s4">8.0</span><span class="s1">+</span><span class="s4">0.7j</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">b1 = np.array([</span><span class="s4">16.0</span><span class="s2">, </span><span class="s4">17.0</span><span class="s1">+</span><span class="s4">2.0j</span><span class="s2">, </span><span class="s4">20.0</span><span class="s1">-</span><span class="s4">4.0j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">gelsy</span><span class="s2">, </span><span class="s1">gelsy_lwork = get_lapack_funcs((</span><span class="s3">'gelsy'</span><span class="s2">, </span><span class="s3">'gelss_lwork'</span><span class="s1">)</span><span class="s2">,</span>
                                                  <span class="s1">(a1</span><span class="s2">, </span><span class="s1">b1))</span>

            <span class="s1">m</span><span class="s2">, </span><span class="s1">n = a1.shape</span>
            <span class="s2">if </span><span class="s1">len(b1.shape) == </span><span class="s4">2</span><span class="s1">:</span>
                <span class="s1">nrhs = b1.shape[</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">nrhs = </span><span class="s4">1</span>

            <span class="s0"># Request of sizes</span>
            <span class="s1">work</span><span class="s2">, </span><span class="s1">info = gelsy_lwork(m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">nrhs</span><span class="s2">, </span><span class="s4">10</span><span class="s1">*np.finfo(dtype).eps)</span>
            <span class="s1">lwork = int(np.real(work))</span>

            <span class="s1">jptv = np.zeros((a1.shape[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.int32)</span>
            <span class="s1">v</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">rank</span><span class="s2">, </span><span class="s1">info = gelsy(a1</span><span class="s2">, </span><span class="s1">b1</span><span class="s2">, </span><span class="s1">jptv</span><span class="s2">, </span><span class="s1">np.finfo(dtype).eps</span><span class="s2">,</span>
                                        <span class="s1">lwork</span><span class="s2">, False, False</span><span class="s1">)</span>
            <span class="s1">assert_allclose(x[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">np.array([</span><span class="s4">1.161753632288328</span><span class="s1">-</span><span class="s4">1.901075709391912j</span><span class="s2">,</span>
                                      <span class="s4">1.735882340522193</span><span class="s1">+</span><span class="s4">1.521240901196909j</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">dtype=dtype)</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s4">25</span><span class="s1">*np.finfo(dtype).eps)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'dtype'</span><span class="s2">, </span><span class="s1">DTYPES)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'shape'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">5</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2</span><span class="s1">**</span><span class="s4">18</span><span class="s2">, </span><span class="s4">2</span><span class="s1">**</span><span class="s4">18</span><span class="s1">)])</span>
<span class="s2">def </span><span class="s1">test_geqrf_lwork(dtype</span><span class="s2">, </span><span class="s1">shape):</span>
    <span class="s1">geqrf_lwork = get_lapack_funcs((</span><span class="s3">'geqrf_lwork'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">m</span><span class="s2">, </span><span class="s1">n = shape</span>
    <span class="s1">lwork</span><span class="s2">, </span><span class="s1">info = geqrf_lwork(m=m</span><span class="s2">, </span><span class="s1">n=n)</span>
    <span class="s1">assert_equal(info</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestRegression:</span>

    <span class="s2">def </span><span class="s1">test_ticket_1645(self):</span>
        <span class="s0"># Check that RQ routines have correct lwork</span>
        <span class="s2">for </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">DTYPES:</span>
            <span class="s1">a = np.zeros((</span><span class="s4">300</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

            <span class="s1">gerqf</span><span class="s2">, </span><span class="s1">= get_lapack_funcs([</span><span class="s3">'gerqf'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[a])</span>
            <span class="s1">assert_raises(Exception</span><span class="s2">, </span><span class="s1">gerqf</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">lwork=</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">rq</span><span class="s2">, </span><span class="s1">tau</span><span class="s2">, </span><span class="s1">work</span><span class="s2">, </span><span class="s1">info = gerqf(a)</span>

            <span class="s2">if </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">REAL_DTYPES:</span>
                <span class="s1">orgrq</span><span class="s2">, </span><span class="s1">= get_lapack_funcs([</span><span class="s3">'orgrq'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[a])</span>
                <span class="s1">assert_raises(Exception</span><span class="s2">, </span><span class="s1">orgrq</span><span class="s2">, </span><span class="s1">rq[-</span><span class="s4">2</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">tau</span><span class="s2">, </span><span class="s1">lwork=</span><span class="s4">1</span><span class="s1">)</span>
                <span class="s1">orgrq(rq[-</span><span class="s4">2</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">tau</span><span class="s2">, </span><span class="s1">lwork=</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">COMPLEX_DTYPES:</span>
                <span class="s1">ungrq</span><span class="s2">, </span><span class="s1">= get_lapack_funcs([</span><span class="s3">'ungrq'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[a])</span>
                <span class="s1">assert_raises(Exception</span><span class="s2">, </span><span class="s1">ungrq</span><span class="s2">, </span><span class="s1">rq[-</span><span class="s4">2</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">tau</span><span class="s2">, </span><span class="s1">lwork=</span><span class="s4">1</span><span class="s1">)</span>
                <span class="s1">ungrq(rq[-</span><span class="s4">2</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">tau</span><span class="s2">, </span><span class="s1">lwork=</span><span class="s4">2</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestDpotr:</span>
    <span class="s2">def </span><span class="s1">test_gh_2691(self):</span>
        <span class="s0"># 'lower' argument of dportf/dpotri</span>
        <span class="s2">for </span><span class="s1">lower </span><span class="s2">in </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">]:</span>
            <span class="s2">for </span><span class="s1">clean </span><span class="s2">in </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">]:</span>
                <span class="s1">np.random.seed(</span><span class="s4">42</span><span class="s1">)</span>
                <span class="s1">x = np.random.normal(size=(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s1">))</span>
                <span class="s1">a = x.dot(x.T)</span>

                <span class="s1">dpotrf</span><span class="s2">, </span><span class="s1">dpotri = get_lapack_funcs((</span><span class="s3">&quot;potrf&quot;</span><span class="s2">, </span><span class="s3">&quot;potri&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(a</span><span class="s2">, </span><span class="s1">))</span>

                <span class="s1">c</span><span class="s2">, </span><span class="s1">info = dpotrf(a</span><span class="s2">, </span><span class="s1">lower</span><span class="s2">, </span><span class="s1">clean=clean)</span>
                <span class="s1">dpt = dpotri(c</span><span class="s2">, </span><span class="s1">lower)[</span><span class="s4">0</span><span class="s1">]</span>

                <span class="s2">if </span><span class="s1">lower:</span>
                    <span class="s1">assert_allclose(np.tril(dpt)</span><span class="s2">, </span><span class="s1">np.tril(inv(a)))</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">assert_allclose(np.triu(dpt)</span><span class="s2">, </span><span class="s1">np.triu(inv(a)))</span>


<span class="s2">class </span><span class="s1">TestDlasd4:</span>
    <span class="s2">def </span><span class="s1">test_sing_val_update(self):</span>

        <span class="s1">sigmas = np.array([</span><span class="s4">4.</span><span class="s2">, </span><span class="s4">3.</span><span class="s2">, </span><span class="s4">2.</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">m_vec = np.array([</span><span class="s4">3.12</span><span class="s2">, </span><span class="s4">5.7</span><span class="s2">, </span><span class="s1">-</span><span class="s4">4.8</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2.2</span><span class="s1">])</span>

        <span class="s1">M = np.hstack((np.vstack((np.diag(sigmas[</span><span class="s4">0</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">])</span><span class="s2">,</span>
                                  <span class="s1">np.zeros((</span><span class="s4">1</span><span class="s2">, </span><span class="s1">len(m_vec) - </span><span class="s4">1</span><span class="s1">))))</span><span class="s2">,</span>
                       <span class="s1">m_vec[:</span><span class="s2">, </span><span class="s1">np.newaxis]))</span>
        <span class="s1">SM = svd(M</span><span class="s2">, </span><span class="s1">full_matrices=</span><span class="s2">False, </span><span class="s1">compute_uv=</span><span class="s2">False, </span><span class="s1">overwrite_a=</span><span class="s2">False,</span>
                 <span class="s1">check_finite=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">it_len = len(sigmas)</span>
        <span class="s1">sgm = np.concatenate((sigmas[::-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[sigmas[</span><span class="s4">0</span><span class="s1">] + it_len*norm(m_vec)]))</span>
        <span class="s1">mvc = np.concatenate((m_vec[::-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">,</span><span class="s1">)))</span>

        <span class="s1">lasd4 = get_lapack_funcs(</span><span class="s3">'lasd4'</span><span class="s2">, </span><span class="s1">(sigmas</span><span class="s2">,</span><span class="s1">))</span>

        <span class="s1">roots = []</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">it_len):</span>
            <span class="s1">res = lasd4(i</span><span class="s2">, </span><span class="s1">sgm</span><span class="s2">, </span><span class="s1">mvc)</span>
            <span class="s1">roots.append(res[</span><span class="s4">1</span><span class="s1">])</span>

            <span class="s1">assert_((res[</span><span class="s4">3</span><span class="s1">] &lt;= </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;LAPACK root finding dlasd4 failed to find </span><span class="s2">\ 
                                    </span><span class="s3">the singular value %i&quot; </span><span class="s1">% i)</span>
        <span class="s1">roots = np.array(roots)[::-</span><span class="s4">1</span><span class="s1">]</span>

        <span class="s1">assert_((</span><span class="s2">not </span><span class="s1">np.any(np.isnan(roots))</span><span class="s2">, </span><span class="s3">&quot;There are NaN roots&quot;</span><span class="s1">))</span>
        <span class="s1">assert_allclose(SM</span><span class="s2">, </span><span class="s1">roots</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">100</span><span class="s1">*np.finfo(np.float64).eps</span><span class="s2">,</span>
                        <span class="s1">rtol=</span><span class="s4">100</span><span class="s1">*np.finfo(np.float64).eps)</span>


<span class="s2">class </span><span class="s1">TestTbtrs:</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'dtype'</span><span class="s2">, </span><span class="s1">DTYPES)</span>
    <span class="s2">def </span><span class="s1">test_nag_example_f07vef_f07vsf(self</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s5">&quot;&quot;&quot;Test real (f07vef) and complex (f07vsf) examples from NAG 
 
        Examples available from: 
        * https://www.nag.com/numeric/fl/nagdoc_latest/html/f07/f07vef.html 
        * https://www.nag.com/numeric/fl/nagdoc_latest/html/f07/f07vsf.html 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">REAL_DTYPES:</span>
            <span class="s1">ab = np.array([[-</span><span class="s4">4.16</span><span class="s2">, </span><span class="s4">4.78</span><span class="s2">, </span><span class="s4">6.32</span><span class="s2">, </span><span class="s4">0.16</span><span class="s1">]</span><span class="s2">,</span>
                           <span class="s1">[-</span><span class="s4">2.25</span><span class="s2">, </span><span class="s4">5.86</span><span class="s2">, </span><span class="s1">-</span><span class="s4">4.82</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]]</span><span class="s2">,</span>
                          <span class="s1">dtype=dtype)</span>
            <span class="s1">b = np.array([[-</span><span class="s4">16.64</span><span class="s2">, </span><span class="s1">-</span><span class="s4">4.16</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">[-</span><span class="s4">13.78</span><span class="s2">, </span><span class="s1">-</span><span class="s4">16.59</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">[</span><span class="s4">13.10</span><span class="s2">, </span><span class="s1">-</span><span class="s4">4.94</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">[-</span><span class="s4">14.14</span><span class="s2">, </span><span class="s1">-</span><span class="s4">9.96</span><span class="s1">]]</span><span class="s2">,</span>
                         <span class="s1">dtype=dtype)</span>
            <span class="s1">x_out = np.array([[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s1">]]</span><span class="s2">,</span>
                             <span class="s1">dtype=dtype)</span>
        <span class="s2">elif </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">COMPLEX_DTYPES:</span>
            <span class="s1">ab = np.array([[-</span><span class="s4">1.94</span><span class="s1">+</span><span class="s4">4.43j</span><span class="s2">, </span><span class="s4">4.12</span><span class="s1">-</span><span class="s4">4.27j</span><span class="s2">, </span><span class="s4">0.43</span><span class="s1">-</span><span class="s4">2.66j</span><span class="s2">, </span><span class="s4">0.44</span><span class="s1">+</span><span class="s4">0.1j</span><span class="s1">]</span><span class="s2">,</span>
                           <span class="s1">[-</span><span class="s4">3.39</span><span class="s1">+</span><span class="s4">3.44j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.84</span><span class="s1">+</span><span class="s4">5.52j</span><span class="s2">, </span><span class="s4">1.74 </span><span class="s1">- </span><span class="s4">0.04j</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                           <span class="s1">[</span><span class="s4">1.62</span><span class="s1">+</span><span class="s4">3.68j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2.77</span><span class="s1">-</span><span class="s4">1.93j</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]]</span><span class="s2">,</span>
                          <span class="s1">dtype=dtype)</span>
            <span class="s1">b = np.array([[-</span><span class="s4">8.86 </span><span class="s1">- </span><span class="s4">3.88j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">24.09 </span><span class="s1">- </span><span class="s4">5.27j</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">[-</span><span class="s4">15.57 </span><span class="s1">- </span><span class="s4">23.41j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">57.97 </span><span class="s1">+ </span><span class="s4">8.14j</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">[-</span><span class="s4">7.63 </span><span class="s1">+ </span><span class="s4">22.78j</span><span class="s2">, </span><span class="s4">19.09 </span><span class="s1">- </span><span class="s4">29.51j</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">[-</span><span class="s4">14.74 </span><span class="s1">- </span><span class="s4">2.40j</span><span class="s2">, </span><span class="s4">19.17 </span><span class="s1">+ </span><span class="s4">21.33j</span><span class="s1">]]</span><span class="s2">,</span>
                         <span class="s1">dtype=dtype)</span>
            <span class="s1">x_out = np.array([[</span><span class="s4">2j</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">5j</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s4">1 </span><span class="s1">- </span><span class="s4">3j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">7 </span><span class="s1">- </span><span class="s4">2j</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[-</span><span class="s4">4.001887 </span><span class="s1">- </span><span class="s4">4.988417j</span><span class="s2">, </span><span class="s4">3.026830 </span><span class="s1">+ </span><span class="s4">4.003182j</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s4">1.996158 </span><span class="s1">- </span><span class="s4">1.045105j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">6.103357 </span><span class="s1">- </span><span class="s4">8.986653j</span><span class="s1">]]</span><span class="s2">,</span>
                             <span class="s1">dtype=dtype)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;Datatype </span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">} </span><span class="s3">not understood.&quot;</span><span class="s1">)</span>

        <span class="s1">tbtrs = get_lapack_funcs((</span><span class="s3">'tbtrs'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">info = tbtrs(ab=ab</span><span class="s2">, </span><span class="s1">b=b</span><span class="s2">, </span><span class="s1">uplo=</span><span class="s3">'L'</span><span class="s1">)</span>
        <span class="s1">assert_equal(info</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(x</span><span class="s2">, </span><span class="s1">x_out</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-5</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'dtype,trans'</span><span class="s2">,</span>
                             <span class="s1">[(dtype</span><span class="s2">, </span><span class="s1">trans)</span>
                              <span class="s2">for </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">DTYPES </span><span class="s2">for </span><span class="s1">trans </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'N'</span><span class="s2">, </span><span class="s3">'T'</span><span class="s2">, </span><span class="s3">'C'</span><span class="s1">]</span>
                              <span class="s2">if not </span><span class="s1">(trans == </span><span class="s3">'C' </span><span class="s2">and </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">REAL_DTYPES)])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'uplo'</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'U'</span><span class="s2">, </span><span class="s3">'L'</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'diag'</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'N'</span><span class="s2">, </span><span class="s3">'U'</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_random_matrices(self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">trans</span><span class="s2">, </span><span class="s1">uplo</span><span class="s2">, </span><span class="s1">diag):</span>
        <span class="s1">seed(</span><span class="s4">1724</span><span class="s1">)</span>
        <span class="s0"># n, nrhs, kd are used to specify A and b.</span>
        <span class="s0"># A is of shape n x n with kd super/sub-diagonals</span>
        <span class="s0"># b is of shape n x nrhs matrix</span>
        <span class="s1">n</span><span class="s2">, </span><span class="s1">nrhs</span><span class="s2">, </span><span class="s1">kd = </span><span class="s4">4</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span>
        <span class="s1">tbtrs = get_lapack_funcs(</span><span class="s3">'tbtrs'</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

        <span class="s1">is_upper = (uplo == </span><span class="s3">'U'</span><span class="s1">)</span>
        <span class="s1">ku = kd * is_upper</span>
        <span class="s1">kl = kd - ku</span>

        <span class="s0"># Construct the diagonal and kd super/sub diagonals of A with</span>
        <span class="s0"># the corresponding offsets.</span>
        <span class="s1">band_offsets = range(ku</span><span class="s2">, </span><span class="s1">-kl - </span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">band_widths = [n - abs(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">band_offsets]</span>
        <span class="s1">bands = [generate_random_dtype_array((width</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype)</span>
                 <span class="s2">for </span><span class="s1">width </span><span class="s2">in </span><span class="s1">band_widths]</span>

        <span class="s2">if </span><span class="s1">diag == </span><span class="s3">'U'</span><span class="s1">:  </span><span class="s0"># A must be unit triangular</span>
            <span class="s1">bands[ku] = np.ones(n</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

        <span class="s0"># Construct the diagonal banded matrix A from the bands and offsets.</span>
        <span class="s1">a = sps.diags(bands</span><span class="s2">, </span><span class="s1">band_offsets</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">'dia'</span><span class="s1">)</span>

        <span class="s0"># Convert A into banded storage form</span>
        <span class="s1">ab = np.zeros((kd + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">n)</span><span class="s2">, </span><span class="s1">dtype)</span>
        <span class="s2">for </span><span class="s1">row</span><span class="s2">, </span><span class="s1">k </span><span class="s2">in </span><span class="s1">enumerate(band_offsets):</span>
            <span class="s1">ab[row</span><span class="s2">, </span><span class="s1">max(k</span><span class="s2">, </span><span class="s4">0</span><span class="s1">):min(n+k</span><span class="s2">, </span><span class="s1">n)] = a.diagonal(k)</span>

        <span class="s0"># The RHS values.</span>
        <span class="s1">b = generate_random_dtype_array((n</span><span class="s2">, </span><span class="s1">nrhs)</span><span class="s2">, </span><span class="s1">dtype)</span>

        <span class="s1">x</span><span class="s2">, </span><span class="s1">info = tbtrs(ab=ab</span><span class="s2">, </span><span class="s1">b=b</span><span class="s2">, </span><span class="s1">uplo=uplo</span><span class="s2">, </span><span class="s1">trans=trans</span><span class="s2">, </span><span class="s1">diag=diag)</span>
        <span class="s1">assert_equal(info</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">trans == </span><span class="s3">'N'</span><span class="s1">:</span>
            <span class="s1">assert_allclose(a @ x</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">5e-5</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">trans == </span><span class="s3">'T'</span><span class="s1">:</span>
            <span class="s1">assert_allclose(a.T @ x</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">5e-5</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">trans == </span><span class="s3">'C'</span><span class="s1">:</span>
            <span class="s1">assert_allclose(a.H @ x</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">5e-5</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'Invalid trans argument'</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'uplo,trans,diag'</span><span class="s2">,</span>
                             <span class="s1">[[</span><span class="s3">'U'</span><span class="s2">, </span><span class="s3">'N'</span><span class="s2">, </span><span class="s3">'Invalid'</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s3">'U'</span><span class="s2">, </span><span class="s3">'Invalid'</span><span class="s2">, </span><span class="s3">'N'</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s3">'Invalid'</span><span class="s2">, </span><span class="s3">'N'</span><span class="s2">, </span><span class="s3">'N'</span><span class="s1">]])</span>
    <span class="s2">def </span><span class="s1">test_invalid_argument_raises_exception(self</span><span class="s2">, </span><span class="s1">uplo</span><span class="s2">, </span><span class="s1">trans</span><span class="s2">, </span><span class="s1">diag):</span>
        <span class="s5">&quot;&quot;&quot;Test if invalid values of uplo, trans and diag raise exceptions&quot;&quot;&quot;</span>
        <span class="s0"># Argument checks occur independently of used datatype.</span>
        <span class="s0"># This mean we must not parameterize all available datatypes.</span>
        <span class="s1">tbtrs = get_lapack_funcs(</span><span class="s3">'tbtrs'</span><span class="s2">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">ab = rand(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">b = rand(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">assert_raises(Exception</span><span class="s2">, </span><span class="s1">tbtrs</span><span class="s2">, </span><span class="s1">ab</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">uplo</span><span class="s2">, </span><span class="s1">trans</span><span class="s2">, </span><span class="s1">diag)</span>

    <span class="s2">def </span><span class="s1">test_zero_element_in_diagonal(self):</span>
        <span class="s5">&quot;&quot;&quot;Test if a matrix with a zero diagonal element is singular 
 
        If the i-th diagonal of A is zero, ?tbtrs should return `i` in `info` 
        indicating the provided matrix is singular. 
 
        Note that ?tbtrs requires the matrix A to be stored in banded form. 
        In this form the diagonal corresponds to the last row.&quot;&quot;&quot;</span>
        <span class="s1">ab = np.ones((</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=float)</span>
        <span class="s1">b = np.ones(</span><span class="s4">4</span><span class="s2">, </span><span class="s1">dtype=float)</span>
        <span class="s1">tbtrs = get_lapack_funcs(</span><span class="s3">'tbtrs'</span><span class="s2">, </span><span class="s1">dtype=float)</span>

        <span class="s1">ab[-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s1">] = </span><span class="s4">0</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">info = tbtrs(ab=ab</span><span class="s2">, </span><span class="s1">b=b</span><span class="s2">, </span><span class="s1">uplo=</span><span class="s3">'U'</span><span class="s1">)</span>
        <span class="s1">assert_equal(info</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'ldab,n,ldb,nrhs'</span><span class="s2">, </span><span class="s1">[</span>
                              <span class="s1">(</span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span>
    <span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_invalid_matrix_shapes(self</span><span class="s2">, </span><span class="s1">ldab</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">ldb</span><span class="s2">, </span><span class="s1">nrhs):</span>
        <span class="s5">&quot;&quot;&quot;Test ?tbtrs fails correctly if shapes are invalid.&quot;&quot;&quot;</span>
        <span class="s1">ab = np.ones((ldab</span><span class="s2">, </span><span class="s1">n)</span><span class="s2">, </span><span class="s1">dtype=float)</span>
        <span class="s1">b = np.ones((ldb</span><span class="s2">, </span><span class="s1">nrhs)</span><span class="s2">, </span><span class="s1">dtype=float)</span>
        <span class="s1">tbtrs = get_lapack_funcs(</span><span class="s3">'tbtrs'</span><span class="s2">, </span><span class="s1">dtype=float)</span>
        <span class="s1">assert_raises(Exception</span><span class="s2">, </span><span class="s1">tbtrs</span><span class="s2">, </span><span class="s1">ab</span><span class="s2">, </span><span class="s1">b)</span>


<span class="s2">def </span><span class="s1">test_lartg():</span>
    <span class="s2">for </span><span class="s1">dtype </span><span class="s2">in </span><span class="s3">'fdFD'</span><span class="s1">:</span>
        <span class="s1">lartg = get_lapack_funcs(</span><span class="s3">'lartg'</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

        <span class="s1">f = np.array(</span><span class="s4">3</span><span class="s2">, </span><span class="s1">dtype)</span>
        <span class="s1">g = np.array(</span><span class="s4">4</span><span class="s2">, </span><span class="s1">dtype)</span>

        <span class="s2">if </span><span class="s1">np.iscomplexobj(g):</span>
            <span class="s1">g *= </span><span class="s4">1j</span>

        <span class="s1">cs</span><span class="s2">, </span><span class="s1">sn</span><span class="s2">, </span><span class="s1">r = lartg(f</span><span class="s2">, </span><span class="s1">g)</span>

        <span class="s1">assert_allclose(cs</span><span class="s2">, </span><span class="s4">3.0</span><span class="s1">/</span><span class="s4">5.0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(r</span><span class="s2">, </span><span class="s4">5.0</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">np.iscomplexobj(g):</span>
            <span class="s1">assert_allclose(sn</span><span class="s2">, </span><span class="s1">-</span><span class="s4">4.0j</span><span class="s1">/</span><span class="s4">5.0</span><span class="s1">)</span>
            <span class="s1">assert_(type(r) == complex)</span>
            <span class="s1">assert_(type(cs) == float)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">assert_allclose(sn</span><span class="s2">, </span><span class="s4">4.0</span><span class="s1">/</span><span class="s4">5.0</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_rot():</span>
    <span class="s0"># srot, drot from blas and crot and zrot from lapack.</span>

    <span class="s2">for </span><span class="s1">dtype </span><span class="s2">in </span><span class="s3">'fdFD'</span><span class="s1">:</span>
        <span class="s1">c = </span><span class="s4">0.6</span>
        <span class="s1">s = </span><span class="s4">0.8</span>

        <span class="s1">u = np.full(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">dtype)</span>
        <span class="s1">v = np.full(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s1">dtype)</span>
        <span class="s1">atol = </span><span class="s4">10</span><span class="s1">**-(np.finfo(dtype).precision-</span><span class="s4">1</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">dtype </span><span class="s2">in </span><span class="s3">'fd'</span><span class="s1">:</span>
            <span class="s1">rot = get_blas_funcs(</span><span class="s3">'rot'</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">f = </span><span class="s4">4</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">rot = get_lapack_funcs(</span><span class="s3">'rot'</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">s *= -</span><span class="s4">1j</span>
            <span class="s1">v *= </span><span class="s4">1j</span>
            <span class="s1">f = </span><span class="s4">4j</span>

        <span class="s1">assert_allclose(rot(u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">s)</span><span class="s2">, </span><span class="s1">[[</span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span><span class="s2">,</span>
                                          <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">atol=atol)</span>
        <span class="s1">assert_allclose(rot(u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">n=</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">[[</span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">,</span>
                                               <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">f]]</span><span class="s2">, </span><span class="s1">atol=atol)</span>
        <span class="s1">assert_allclose(rot(u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">offx=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">offy=</span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">[[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[f</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">atol=atol)</span>
        <span class="s1">assert_allclose(rot(u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">incx=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">offy=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">n=</span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">[[</span><span class="s4">5</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[f</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">atol=atol)</span>
        <span class="s1">assert_allclose(rot(u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">offx=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">incy=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">n=</span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">[[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">f]]</span><span class="s2">, </span><span class="s1">atol=atol)</span>
        <span class="s1">assert_allclose(rot(u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">offx=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">incx=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">offy=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">incy=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">n=</span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">[[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[f</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">f]]</span><span class="s2">, </span><span class="s1">atol=atol)</span>
        <span class="s1">assert_allclose(rot(u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">incx=-</span><span class="s4">2</span><span class="s2">, </span><span class="s1">incy=-</span><span class="s4">2</span><span class="s2">, </span><span class="s1">n=</span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">[[</span><span class="s4">5</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">f]]</span><span class="s2">, </span><span class="s1">atol=atol)</span>

        <span class="s1">a</span><span class="s2">, </span><span class="s1">b = rot(u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">overwrite_x=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">overwrite_y=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_(a </span><span class="s2">is </span><span class="s1">u)</span>
        <span class="s1">assert_(b </span><span class="s2">is </span><span class="s1">v)</span>
        <span class="s1">assert_allclose(a</span><span class="s2">, </span><span class="s1">[</span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=atol)</span>
        <span class="s1">assert_allclose(b</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=atol)</span>


<span class="s2">def </span><span class="s1">test_larfg_larf():</span>
    <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>
    <span class="s1">a0 = np.random.random((</span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s1">))</span>
    <span class="s1">a0 = a0.T.dot(a0)</span>

    <span class="s1">a0j = np.random.random((</span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)) + </span><span class="s4">1j</span><span class="s1">*np.random.random((</span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s1">))</span>
    <span class="s1">a0j = a0j.T.conj().dot(a0j)</span>

    <span class="s0"># our test here will be to do one step of reducing a hermetian matrix to</span>
    <span class="s0"># tridiagonal form using householder transforms.</span>

    <span class="s2">for </span><span class="s1">dtype </span><span class="s2">in </span><span class="s3">'fdFD'</span><span class="s1">:</span>
        <span class="s1">larfg</span><span class="s2">, </span><span class="s1">larf = get_lapack_funcs([</span><span class="s3">'larfg'</span><span class="s2">, </span><span class="s3">'larf'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

        <span class="s2">if </span><span class="s1">dtype </span><span class="s2">in </span><span class="s3">'FD'</span><span class="s1">:</span>
            <span class="s1">a = a0j.copy()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">a = a0.copy()</span>

        <span class="s0"># generate a householder transform to clear a[2:,0]</span>
        <span class="s1">alpha</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">tau = larfg(a.shape[</span><span class="s4">0</span><span class="s1">]-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">a[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">a[</span><span class="s4">2</span><span class="s1">:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>

        <span class="s0"># create expected output</span>
        <span class="s1">expected = np.zeros_like(a[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">expected[</span><span class="s4">0</span><span class="s1">] = a[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">expected[</span><span class="s4">1</span><span class="s1">] = alpha</span>

        <span class="s0"># assemble householder vector</span>
        <span class="s1">v = np.zeros_like(a[</span><span class="s4">1</span><span class="s1">:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">v[</span><span class="s4">0</span><span class="s1">] = </span><span class="s4">1.0</span>
        <span class="s1">v[</span><span class="s4">1</span><span class="s1">:] = x</span>

        <span class="s0"># apply transform from the left</span>
        <span class="s1">a[</span><span class="s4">1</span><span class="s1">:</span><span class="s2">, </span><span class="s1">:] = larf(v</span><span class="s2">, </span><span class="s1">tau.conjugate()</span><span class="s2">, </span><span class="s1">a[</span><span class="s4">1</span><span class="s1">:</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">np.zeros(a.shape[</span><span class="s4">1</span><span class="s1">]))</span>

        <span class="s0"># apply transform from the right</span>
        <span class="s1">a[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">:] = larf(v</span><span class="s2">, </span><span class="s1">tau</span><span class="s2">, </span><span class="s1">a[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">np.zeros(a.shape[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">, </span><span class="s1">side=</span><span class="s3">'R'</span><span class="s1">)</span>

        <span class="s1">assert_allclose(a[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-5</span><span class="s1">)</span>
        <span class="s1">assert_allclose(a[</span><span class="s4">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-5</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_sgesdd_lwork_bug_workaround():</span>
    <span class="s0"># Test that SGESDD lwork is sufficiently large for LAPACK.</span>
    <span class="s0">#</span>
    <span class="s0"># This checks that _compute_lwork() correctly works around a bug in</span>
    <span class="s0"># LAPACK versions older than 3.10.1.</span>

    <span class="s1">sgesdd_lwork = get_lapack_funcs(</span><span class="s3">'gesdd_lwork'</span><span class="s2">, </span><span class="s1">dtype=np.float32</span><span class="s2">,</span>
                                    <span class="s1">ilp64=</span><span class="s3">'preferred'</span><span class="s1">)</span>
    <span class="s1">n = </span><span class="s4">9537</span>
    <span class="s1">lwork = _compute_lwork(sgesdd_lwork</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">n</span><span class="s2">,</span>
                           <span class="s1">compute_uv=</span><span class="s2">True, </span><span class="s1">full_matrices=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s0"># If we called the Fortran function SGESDD directly with IWORK=-1, the</span>
    <span class="s0"># LAPACK bug would result in lwork being 272929856, which was too small.</span>
    <span class="s0"># (The result was returned in a single precision float, which does not</span>
    <span class="s0"># have sufficient precision to represent the exact integer value that it</span>
    <span class="s0"># computed internally.)  The work-around implemented in _compute_lwork()</span>
    <span class="s0"># will convert that to 272929888.  If we are using LAPACK 3.10.1 or later</span>
    <span class="s0"># (such as in OpenBLAS 0.3.21 or later), the work-around will return</span>
    <span class="s0"># 272929920, because it does not know which version of LAPACK is being</span>
    <span class="s0"># used, so it always applies the correction to whatever it is given.  We</span>
    <span class="s0"># will accept either 272929888 or 272929920.</span>
    <span class="s0"># Note that the acceptable values are a LAPACK implementation detail.</span>
    <span class="s0"># If a future version of LAPACK changes how SGESDD works, and therefore</span>
    <span class="s0"># changes the required LWORK size, the acceptable values might have to</span>
    <span class="s0"># be updated.</span>
    <span class="s2">assert </span><span class="s1">lwork == </span><span class="s4">272929888 </span><span class="s2">or </span><span class="s1">lwork == </span><span class="s4">272929920</span>


<span class="s2">class </span><span class="s1">TestSytrd:</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'dtype'</span><span class="s2">, </span><span class="s1">REAL_DTYPES)</span>
    <span class="s2">def </span><span class="s1">test_sytrd_with_zero_dim_array(self</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s0"># Assert that a 0x0 matrix raises an error</span>
        <span class="s1">A = np.zeros((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">sytrd = get_lapack_funcs(</span><span class="s3">'sytrd'</span><span class="s2">, </span><span class="s1">(A</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">sytrd</span><span class="s2">, </span><span class="s1">A)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'dtype'</span><span class="s2">, </span><span class="s1">REAL_DTYPES)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'n'</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s1">))</span>
    <span class="s2">def </span><span class="s1">test_sytrd(self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s1">A = np.zeros((n</span><span class="s2">, </span><span class="s1">n)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

        <span class="s1">sytrd</span><span class="s2">, </span><span class="s1">sytrd_lwork = \</span>
            <span class="s1">get_lapack_funcs((</span><span class="s3">'sytrd'</span><span class="s2">, </span><span class="s3">'sytrd_lwork'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(A</span><span class="s2">,</span><span class="s1">))</span>

        <span class="s0"># some upper triangular array</span>
        <span class="s1">A[np.triu_indices_from(A)] = \</span>
            <span class="s1">np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">n*(n+</span><span class="s4">1</span><span class="s1">)//</span><span class="s4">2</span><span class="s1">+</span><span class="s4">1</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

        <span class="s0"># query lwork</span>
        <span class="s1">lwork</span><span class="s2">, </span><span class="s1">info = sytrd_lwork(n)</span>
        <span class="s1">assert_equal(info</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

        <span class="s0"># check lower=1 behavior (shouldn't do much since the matrix is</span>
        <span class="s0"># upper triangular)</span>
        <span class="s1">data</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">tau</span><span class="s2">, </span><span class="s1">info = sytrd(A</span><span class="s2">, </span><span class="s1">lower=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">lwork=lwork)</span>
        <span class="s1">assert_equal(info</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">assert_allclose(data</span><span class="s2">, </span><span class="s1">A</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">5</span><span class="s1">*np.finfo(dtype).eps</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1.0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(d</span><span class="s2">, </span><span class="s1">np.diag(A))</span>
        <span class="s1">assert_allclose(e</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(tau</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>

        <span class="s0"># and now for the proper test (lower=0 is the default)</span>
        <span class="s1">data</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">tau</span><span class="s2">, </span><span class="s1">info = sytrd(A</span><span class="s2">, </span><span class="s1">lwork=lwork)</span>
        <span class="s1">assert_equal(info</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

        <span class="s0"># assert Q^T*A*Q = tridiag(e, d, e)</span>

        <span class="s0"># build tridiagonal matrix</span>
        <span class="s1">T = np.zeros_like(A</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">k = np.arange(A.shape[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">T[k</span><span class="s2">, </span><span class="s1">k] = d</span>
        <span class="s1">k2 = np.arange(A.shape[</span><span class="s4">0</span><span class="s1">]-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">T[k2+</span><span class="s4">1</span><span class="s2">, </span><span class="s1">k2] = e</span>
        <span class="s1">T[k2</span><span class="s2">, </span><span class="s1">k2+</span><span class="s4">1</span><span class="s1">] = e</span>

        <span class="s0"># build Q</span>
        <span class="s1">Q = np.eye(n</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(n-</span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">v = np.zeros(n</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">v[:i] = data[:i</span><span class="s2">, </span><span class="s1">i+</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">v[i] = </span><span class="s4">1.0</span>
            <span class="s1">H = np.eye(n</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">dtype=dtype) - tau[i] * np.outer(v</span><span class="s2">, </span><span class="s1">v)</span>
            <span class="s1">Q = np.dot(H</span><span class="s2">, </span><span class="s1">Q)</span>

        <span class="s0"># Make matrix fully symmetric</span>
        <span class="s1">i_lower = np.tril_indices(n</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">A[i_lower] = A.T[i_lower]</span>

        <span class="s1">QTAQ = np.dot(Q.T</span><span class="s2">, </span><span class="s1">np.dot(A</span><span class="s2">, </span><span class="s1">Q))</span>

        <span class="s0"># disable rtol here since some values in QTAQ and T are very close</span>
        <span class="s0"># to 0.</span>
        <span class="s1">assert_allclose(QTAQ</span><span class="s2">, </span><span class="s1">T</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">5</span><span class="s1">*np.finfo(dtype).eps</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1.0</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestHetrd:</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'complex_dtype'</span><span class="s2">, </span><span class="s1">COMPLEX_DTYPES)</span>
    <span class="s2">def </span><span class="s1">test_hetrd_with_zero_dim_array(self</span><span class="s2">, </span><span class="s1">complex_dtype):</span>
        <span class="s0"># Assert that a 0x0 matrix raises an error</span>
        <span class="s1">A = np.zeros((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=complex_dtype)</span>
        <span class="s1">hetrd = get_lapack_funcs(</span><span class="s3">'hetrd'</span><span class="s2">, </span><span class="s1">(A</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">hetrd</span><span class="s2">, </span><span class="s1">A)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'real_dtype,complex_dtype'</span><span class="s2">,</span>
                             <span class="s1">zip(REAL_DTYPES</span><span class="s2">, </span><span class="s1">COMPLEX_DTYPES))</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'n'</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s1">))</span>
    <span class="s2">def </span><span class="s1">test_hetrd(self</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">real_dtype</span><span class="s2">, </span><span class="s1">complex_dtype):</span>
        <span class="s1">A = np.zeros((n</span><span class="s2">, </span><span class="s1">n)</span><span class="s2">, </span><span class="s1">dtype=complex_dtype)</span>
        <span class="s1">hetrd</span><span class="s2">, </span><span class="s1">hetrd_lwork = \</span>
            <span class="s1">get_lapack_funcs((</span><span class="s3">'hetrd'</span><span class="s2">, </span><span class="s3">'hetrd_lwork'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(A</span><span class="s2">,</span><span class="s1">))</span>

        <span class="s0"># some upper triangular array</span>
        <span class="s1">A[np.triu_indices_from(A)] = (</span>
            <span class="s1">np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">n*(n+</span><span class="s4">1</span><span class="s1">)//</span><span class="s4">2</span><span class="s1">+</span><span class="s4">1</span><span class="s2">, </span><span class="s1">dtype=real_dtype)</span>
            <span class="s1">+ </span><span class="s4">1j </span><span class="s1">* np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">n*(n+</span><span class="s4">1</span><span class="s1">)//</span><span class="s4">2</span><span class="s1">+</span><span class="s4">1</span><span class="s2">, </span><span class="s1">dtype=real_dtype)</span>
            <span class="s1">)</span>
        <span class="s1">np.fill_diagonal(A</span><span class="s2">, </span><span class="s1">np.real(np.diag(A)))</span>

        <span class="s0"># test query lwork</span>
        <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]:</span>
            <span class="s1">_</span><span class="s2">, </span><span class="s1">info = hetrd_lwork(n</span><span class="s2">, </span><span class="s1">lower=x)</span>
            <span class="s1">assert_equal(info</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s0"># lwork returns complex which segfaults hetrd call (gh-10388)</span>
        <span class="s0"># use the safe and recommended option</span>
        <span class="s1">lwork = _compute_lwork(hetrd_lwork</span><span class="s2">, </span><span class="s1">n)</span>

        <span class="s0"># check lower=1 behavior (shouldn't do much since the matrix is</span>
        <span class="s0"># upper triangular)</span>
        <span class="s1">data</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">tau</span><span class="s2">, </span><span class="s1">info = hetrd(A</span><span class="s2">, </span><span class="s1">lower=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">lwork=lwork)</span>
        <span class="s1">assert_equal(info</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">assert_allclose(data</span><span class="s2">, </span><span class="s1">A</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">5</span><span class="s1">*np.finfo(real_dtype).eps</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1.0</span><span class="s1">)</span>

        <span class="s1">assert_allclose(d</span><span class="s2">, </span><span class="s1">np.real(np.diag(A)))</span>
        <span class="s1">assert_allclose(e</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(tau</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>

        <span class="s0"># and now for the proper test (lower=0 is the default)</span>
        <span class="s1">data</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">tau</span><span class="s2">, </span><span class="s1">info = hetrd(A</span><span class="s2">, </span><span class="s1">lwork=lwork)</span>
        <span class="s1">assert_equal(info</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

        <span class="s0"># assert Q^T*A*Q = tridiag(e, d, e)</span>

        <span class="s0"># build tridiagonal matrix</span>
        <span class="s1">T = np.zeros_like(A</span><span class="s2">, </span><span class="s1">dtype=real_dtype)</span>
        <span class="s1">k = np.arange(A.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=int)</span>
        <span class="s1">T[k</span><span class="s2">, </span><span class="s1">k] = d</span>
        <span class="s1">k2 = np.arange(A.shape[</span><span class="s4">0</span><span class="s1">]-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">dtype=int)</span>
        <span class="s1">T[k2+</span><span class="s4">1</span><span class="s2">, </span><span class="s1">k2] = e</span>
        <span class="s1">T[k2</span><span class="s2">, </span><span class="s1">k2+</span><span class="s4">1</span><span class="s1">] = e</span>

        <span class="s0"># build Q</span>
        <span class="s1">Q = np.eye(n</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">dtype=complex_dtype)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(n-</span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">v = np.zeros(n</span><span class="s2">, </span><span class="s1">dtype=complex_dtype)</span>
            <span class="s1">v[:i] = data[:i</span><span class="s2">, </span><span class="s1">i+</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">v[i] = </span><span class="s4">1.0</span>
            <span class="s1">H = np.eye(n</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">dtype=complex_dtype) \</span>
                <span class="s1">- tau[i] * np.outer(v</span><span class="s2">, </span><span class="s1">np.conj(v))</span>
            <span class="s1">Q = np.dot(H</span><span class="s2">, </span><span class="s1">Q)</span>

        <span class="s0"># Make matrix fully Hermitian</span>
        <span class="s1">i_lower = np.tril_indices(n</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">A[i_lower] = np.conj(A.T[i_lower])</span>

        <span class="s1">QHAQ = np.dot(np.conj(Q.T)</span><span class="s2">, </span><span class="s1">np.dot(A</span><span class="s2">, </span><span class="s1">Q))</span>

        <span class="s0"># disable rtol here since some values in QTAQ and T are very close</span>
        <span class="s0"># to 0.</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">QHAQ</span><span class="s2">, </span><span class="s1">T</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">10</span><span class="s1">*np.finfo(real_dtype).eps</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1.0</span>
            <span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_gglse():</span>
    <span class="s0"># Example data taken from NAG manual</span>
    <span class="s2">for </span><span class="s1">ind</span><span class="s2">, </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">enumerate(DTYPES):</span>
        <span class="s0"># DTYPES = &lt;s,d,c,z&gt; gglse</span>
        <span class="s1">func</span><span class="s2">, </span><span class="s1">func_lwork = get_lapack_funcs((</span><span class="s3">'gglse'</span><span class="s2">, </span><span class="s3">'gglse_lwork'</span><span class="s1">)</span><span class="s2">,</span>
                                            <span class="s1">dtype=dtype)</span>
        <span class="s1">lwork = _compute_lwork(func_lwork</span><span class="s2">, </span><span class="s1">m=</span><span class="s4">6</span><span class="s2">, </span><span class="s1">n=</span><span class="s4">4</span><span class="s2">, </span><span class="s1">p=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s0"># For &lt;s,d&gt;gglse</span>
        <span class="s2">if </span><span class="s1">ind &lt; </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s1">a = np.array([[-</span><span class="s4">0.57</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.28</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.39</span><span class="s2">, </span><span class="s4">0.25</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">[-</span><span class="s4">1.93</span><span class="s2">, </span><span class="s4">1.08</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.31</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2.14</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">[</span><span class="s4">2.30</span><span class="s2">, </span><span class="s4">0.24</span><span class="s2">, </span><span class="s4">0.40</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.35</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">[-</span><span class="s4">1.93</span><span class="s2">, </span><span class="s4">0.64</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.66</span><span class="s2">, </span><span class="s4">0.08</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">[</span><span class="s4">0.15</span><span class="s2">, </span><span class="s4">0.30</span><span class="s2">, </span><span class="s4">0.15</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2.13</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">[-</span><span class="s4">0.02</span><span class="s2">, </span><span class="s4">1.03</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.43</span><span class="s2">, </span><span class="s4">0.50</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">c = np.array([-</span><span class="s4">1.50</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2.14</span><span class="s2">, </span><span class="s4">1.23</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.54</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.68</span><span class="s2">, </span><span class="s4">0.82</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">d = np.array([</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s0"># For &lt;s,d&gt;gglse</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">a = np.array([[</span><span class="s4">0.96</span><span class="s1">-</span><span class="s4">0.81j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.03</span><span class="s1">+</span><span class="s4">0.96j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.91</span><span class="s1">+</span><span class="s4">2.06j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.05</span><span class="s1">+</span><span class="s4">0.41j</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">[-</span><span class="s4">0.98</span><span class="s1">+</span><span class="s4">1.98j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.20</span><span class="s1">+</span><span class="s4">0.19j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.66</span><span class="s1">+</span><span class="s4">0.42j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.81</span><span class="s1">+</span><span class="s4">0.56j</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">[</span><span class="s4">0.62</span><span class="s1">-</span><span class="s4">0.46j</span><span class="s2">, </span><span class="s4">1.01</span><span class="s1">+</span><span class="s4">0.02j</span><span class="s2">, </span><span class="s4">0.63</span><span class="s1">-</span><span class="s4">0.17j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.11</span><span class="s1">+</span><span class="s4">0.60j</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">[</span><span class="s4">0.37</span><span class="s1">+</span><span class="s4">0.38j</span><span class="s2">, </span><span class="s4">0.19</span><span class="s1">-</span><span class="s4">0.54j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.98</span><span class="s1">-</span><span class="s4">0.36j</span><span class="s2">, </span><span class="s4">0.22</span><span class="s1">-</span><span class="s4">0.20j</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">[</span><span class="s4">0.83</span><span class="s1">+</span><span class="s4">0.51j</span><span class="s2">, </span><span class="s4">0.20</span><span class="s1">+</span><span class="s4">0.01j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.17</span><span class="s1">-</span><span class="s4">0.46j</span><span class="s2">, </span><span class="s4">1.47</span><span class="s1">+</span><span class="s4">1.59j</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">[</span><span class="s4">1.08</span><span class="s1">-</span><span class="s4">0.28j</span><span class="s2">, </span><span class="s4">0.20</span><span class="s1">-</span><span class="s4">0.12j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.07</span><span class="s1">+</span><span class="s4">1.23j</span><span class="s2">, </span><span class="s4">0.26</span><span class="s1">+</span><span class="s4">0.26j</span><span class="s1">]])</span>
            <span class="s1">c = np.array([[-</span><span class="s4">2.54</span><span class="s1">+</span><span class="s4">0.09j</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">[</span><span class="s4">1.65</span><span class="s1">-</span><span class="s4">2.26j</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">[-</span><span class="s4">2.11</span><span class="s1">-</span><span class="s4">3.96j</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">[</span><span class="s4">1.82</span><span class="s1">+</span><span class="s4">3.30j</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">[-</span><span class="s4">6.41</span><span class="s1">+</span><span class="s4">3.77j</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">[</span><span class="s4">2.07</span><span class="s1">+</span><span class="s4">0.66j</span><span class="s1">]])</span>
            <span class="s1">d = np.zeros(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

        <span class="s1">b = np.array([[</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

        <span class="s1">_</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, </span><span class="s1">_ = func(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">lwork=lwork)</span>
        <span class="s2">if </span><span class="s1">ind &lt; </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s1">expected = np.array([</span><span class="s4">0.48904455</span><span class="s2">,</span>
                                 <span class="s4">0.99754786</span><span class="s2">,</span>
                                 <span class="s4">0.48904455</span><span class="s2">,</span>
                                 <span class="s4">0.99754786</span><span class="s1">])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">expected = np.array([</span><span class="s4">1.08742917</span><span class="s1">-</span><span class="s4">1.96205783j</span><span class="s2">,</span>
                                 <span class="s1">-</span><span class="s4">0.74093902</span><span class="s1">+</span><span class="s4">3.72973919j</span><span class="s2">,</span>
                                 <span class="s4">1.08742917</span><span class="s1">-</span><span class="s4">1.96205759j</span><span class="s2">,</span>
                                 <span class="s1">-</span><span class="s4">0.74093896</span><span class="s1">+</span><span class="s4">3.72973895j</span><span class="s1">])</span>
        <span class="s1">assert_array_almost_equal(result</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">4</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_sycon_hecon():</span>
    <span class="s1">seed(</span><span class="s4">1234</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">ind</span><span class="s2">, </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">enumerate(DTYPES+COMPLEX_DTYPES):</span>
        <span class="s0"># DTYPES + COMPLEX DTYPES = &lt;s,d,c,z&gt; sycon + &lt;c,z&gt;hecon</span>
        <span class="s1">n = </span><span class="s4">10</span>
        <span class="s0"># For &lt;s,d,c,z&gt;sycon</span>
        <span class="s2">if </span><span class="s1">ind &lt; </span><span class="s4">4</span><span class="s1">:</span>
            <span class="s1">func_lwork = get_lapack_funcs(</span><span class="s3">'sytrf_lwork'</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">funcon</span><span class="s2">, </span><span class="s1">functrf = get_lapack_funcs((</span><span class="s3">'sycon'</span><span class="s2">, </span><span class="s3">'sytrf'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">A = (rand(n</span><span class="s2">, </span><span class="s1">n)).astype(dtype)</span>
        <span class="s0"># For &lt;c,z&gt;hecon</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">func_lwork = get_lapack_funcs(</span><span class="s3">'hetrf_lwork'</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">funcon</span><span class="s2">, </span><span class="s1">functrf = get_lapack_funcs((</span><span class="s3">'hecon'</span><span class="s2">, </span><span class="s3">'hetrf'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">A = (rand(n</span><span class="s2">, </span><span class="s1">n) + rand(n</span><span class="s2">, </span><span class="s1">n)*</span><span class="s4">1j</span><span class="s1">).astype(dtype)</span>

        <span class="s0"># Since sycon only refers to upper/lower part, conj() is safe here.</span>
        <span class="s1">A = (A + A.conj().T)/</span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">2</span><span class="s1">*np.eye(n</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

        <span class="s1">anorm = norm(A</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">lwork = _compute_lwork(func_lwork</span><span class="s2">, </span><span class="s1">n)</span>
        <span class="s1">ldu</span><span class="s2">, </span><span class="s1">ipiv</span><span class="s2">, </span><span class="s1">_ = functrf(A</span><span class="s2">, </span><span class="s1">lwork=lwork</span><span class="s2">, </span><span class="s1">lower=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">rcond</span><span class="s2">, </span><span class="s1">_ = funcon(a=ldu</span><span class="s2">, </span><span class="s1">ipiv=ipiv</span><span class="s2">, </span><span class="s1">anorm=anorm</span><span class="s2">, </span><span class="s1">lower=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s0"># The error is at most 1-fold</span>
        <span class="s1">assert_(abs(</span><span class="s4">1</span><span class="s1">/rcond - np.linalg.cond(A</span><span class="s2">, </span><span class="s1">p=</span><span class="s4">1</span><span class="s1">))*rcond &lt; </span><span class="s4">1</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_sygst():</span>
    <span class="s1">seed(</span><span class="s4">1234</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">ind</span><span class="s2">, </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">enumerate(REAL_DTYPES):</span>
        <span class="s0"># DTYPES = &lt;s,d&gt; sygst</span>
        <span class="s1">n = </span><span class="s4">10</span>

        <span class="s1">potrf</span><span class="s2">, </span><span class="s1">sygst</span><span class="s2">, </span><span class="s1">syevd</span><span class="s2">, </span><span class="s1">sygvd = get_lapack_funcs((</span><span class="s3">'potrf'</span><span class="s2">, </span><span class="s3">'sygst'</span><span class="s2">,</span>
                                                       <span class="s3">'syevd'</span><span class="s2">, </span><span class="s3">'sygvd'</span><span class="s1">)</span><span class="s2">,</span>
                                                      <span class="s1">dtype=dtype)</span>

        <span class="s1">A = rand(n</span><span class="s2">, </span><span class="s1">n).astype(dtype)</span>
        <span class="s1">A = (A + A.T)/</span><span class="s4">2</span>
        <span class="s0"># B must be positive definite</span>
        <span class="s1">B = rand(n</span><span class="s2">, </span><span class="s1">n).astype(dtype)</span>
        <span class="s1">B = (B + B.T)/</span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">2 </span><span class="s1">* np.eye(n</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

        <span class="s0"># Perform eig (sygvd)</span>
        <span class="s1">eig_gvd</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">info = sygvd(A</span><span class="s2">, </span><span class="s1">B)</span>
        <span class="s1">assert_(info == </span><span class="s4">0</span><span class="s1">)</span>

        <span class="s0"># Convert to std problem potrf</span>
        <span class="s1">b</span><span class="s2">, </span><span class="s1">info = potrf(B)</span>
        <span class="s1">assert_(info == </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">info = sygst(A</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s1">assert_(info == </span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">eig</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">info = syevd(a)</span>
        <span class="s1">assert_(info == </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(eig</span><span class="s2">, </span><span class="s1">eig_gvd</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-4</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_hegst():</span>
    <span class="s1">seed(</span><span class="s4">1234</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">ind</span><span class="s2">, </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">enumerate(COMPLEX_DTYPES):</span>
        <span class="s0"># DTYPES = &lt;c,z&gt; hegst</span>
        <span class="s1">n = </span><span class="s4">10</span>

        <span class="s1">potrf</span><span class="s2">, </span><span class="s1">hegst</span><span class="s2">, </span><span class="s1">heevd</span><span class="s2">, </span><span class="s1">hegvd = get_lapack_funcs((</span><span class="s3">'potrf'</span><span class="s2">, </span><span class="s3">'hegst'</span><span class="s2">,</span>
                                                       <span class="s3">'heevd'</span><span class="s2">, </span><span class="s3">'hegvd'</span><span class="s1">)</span><span class="s2">,</span>
                                                      <span class="s1">dtype=dtype)</span>

        <span class="s1">A = rand(n</span><span class="s2">, </span><span class="s1">n).astype(dtype) + </span><span class="s4">1j </span><span class="s1">* rand(n</span><span class="s2">, </span><span class="s1">n).astype(dtype)</span>
        <span class="s1">A = (A + A.conj().T)/</span><span class="s4">2</span>
        <span class="s0"># B must be positive definite</span>
        <span class="s1">B = rand(n</span><span class="s2">, </span><span class="s1">n).astype(dtype) + </span><span class="s4">1j </span><span class="s1">* rand(n</span><span class="s2">, </span><span class="s1">n).astype(dtype)</span>
        <span class="s1">B = (B + B.conj().T)/</span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">2 </span><span class="s1">* np.eye(n</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

        <span class="s0"># Perform eig (hegvd)</span>
        <span class="s1">eig_gvd</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">info = hegvd(A</span><span class="s2">, </span><span class="s1">B)</span>
        <span class="s1">assert_(info == </span><span class="s4">0</span><span class="s1">)</span>

        <span class="s0"># Convert to std problem potrf</span>
        <span class="s1">b</span><span class="s2">, </span><span class="s1">info = potrf(B)</span>
        <span class="s1">assert_(info == </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">info = hegst(A</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s1">assert_(info == </span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">eig</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">info = heevd(a)</span>
        <span class="s1">assert_(info == </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(eig</span><span class="s2">, </span><span class="s1">eig_gvd</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-4</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_tzrzf():</span>
    <span class="s5">&quot;&quot;&quot; 
    This test performs an RZ decomposition in which an m x n upper trapezoidal 
    array M (m &lt;= n) is factorized as M = [R 0] * Z where R is upper triangular 
    and Z is unitary. 
    &quot;&quot;&quot;</span>
    <span class="s1">seed(</span><span class="s4">1234</span><span class="s1">)</span>
    <span class="s1">m</span><span class="s2">, </span><span class="s1">n = </span><span class="s4">10</span><span class="s2">, </span><span class="s4">15</span>
    <span class="s2">for </span><span class="s1">ind</span><span class="s2">, </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">enumerate(DTYPES):</span>
        <span class="s1">tzrzf</span><span class="s2">, </span><span class="s1">tzrzf_lw = get_lapack_funcs((</span><span class="s3">'tzrzf'</span><span class="s2">, </span><span class="s3">'tzrzf_lwork'</span><span class="s1">)</span><span class="s2">,</span>
                                           <span class="s1">dtype=dtype)</span>
        <span class="s1">lwork = _compute_lwork(tzrzf_lw</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">n)</span>

        <span class="s2">if </span><span class="s1">ind &lt; </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s1">A = triu(rand(m</span><span class="s2">, </span><span class="s1">n).astype(dtype))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">A = triu((rand(m</span><span class="s2">, </span><span class="s1">n) + rand(m</span><span class="s2">, </span><span class="s1">n)*</span><span class="s4">1j</span><span class="s1">).astype(dtype))</span>

        <span class="s0"># assert wrong shape arg, f2py returns generic error</span>
        <span class="s1">assert_raises(Exception</span><span class="s2">, </span><span class="s1">tzrzf</span><span class="s2">, </span><span class="s1">A.T)</span>
        <span class="s1">rz</span><span class="s2">, </span><span class="s1">tau</span><span class="s2">, </span><span class="s1">info = tzrzf(A</span><span class="s2">, </span><span class="s1">lwork=lwork)</span>
        <span class="s0"># Check success</span>
        <span class="s1">assert_(info == </span><span class="s4">0</span><span class="s1">)</span>

        <span class="s0"># Get Z manually for comparison</span>
        <span class="s1">R = np.hstack((rz[:</span><span class="s2">, </span><span class="s1">:m]</span><span class="s2">, </span><span class="s1">np.zeros((m</span><span class="s2">, </span><span class="s1">n-m)</span><span class="s2">, </span><span class="s1">dtype=dtype)))</span>
        <span class="s1">V = np.hstack((np.eye(m</span><span class="s2">, </span><span class="s1">dtype=dtype)</span><span class="s2">, </span><span class="s1">rz[:</span><span class="s2">, </span><span class="s1">m:]))</span>
        <span class="s1">Id = np.eye(n</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">ref = [Id-tau[x]*V[[x]</span><span class="s2">, </span><span class="s1">:].T.dot(V[[x]</span><span class="s2">, </span><span class="s1">:].conj()) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">range(m)]</span>
        <span class="s1">Z = reduce(np.dot</span><span class="s2">, </span><span class="s1">ref)</span>
        <span class="s1">assert_allclose(R.dot(Z) - A</span><span class="s2">, </span><span class="s1">zeros_like(A</span><span class="s2">, </span><span class="s1">dtype=dtype)</span><span class="s2">,</span>
                        <span class="s1">atol=</span><span class="s4">10</span><span class="s1">*np.spacing(dtype(</span><span class="s4">1.0</span><span class="s1">).real)</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_tfsm():</span>
    <span class="s5">&quot;&quot;&quot; 
    Test for solving a linear system with the coefficient matrix is a 
    triangular array stored in Full Packed (RFP) format. 
    &quot;&quot;&quot;</span>
    <span class="s1">seed(</span><span class="s4">1234</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">ind</span><span class="s2">, </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">enumerate(DTYPES):</span>
        <span class="s1">n = </span><span class="s4">20</span>
        <span class="s2">if </span><span class="s1">ind &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">A = triu(rand(n</span><span class="s2">, </span><span class="s1">n) + rand(n</span><span class="s2">, </span><span class="s1">n)*</span><span class="s4">1j </span><span class="s1">+ eye(n)).astype(dtype)</span>
            <span class="s1">trans = </span><span class="s3">'C'</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">A = triu(rand(n</span><span class="s2">, </span><span class="s1">n) + eye(n)).astype(dtype)</span>
            <span class="s1">trans = </span><span class="s3">'T'</span>

        <span class="s1">trttf</span><span class="s2">, </span><span class="s1">tfttr</span><span class="s2">, </span><span class="s1">tfsm = get_lapack_funcs((</span><span class="s3">'trttf'</span><span class="s2">, </span><span class="s3">'tfttr'</span><span class="s2">, </span><span class="s3">'tfsm'</span><span class="s1">)</span><span class="s2">,</span>
                                              <span class="s1">dtype=dtype)</span>

        <span class="s1">Afp</span><span class="s2">, </span><span class="s1">_ = trttf(A)</span>
        <span class="s1">B = rand(n</span><span class="s2">, </span><span class="s4">2</span><span class="s1">).astype(dtype)</span>
        <span class="s1">soln = tfsm(-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">Afp</span><span class="s2">, </span><span class="s1">B)</span>
        <span class="s1">assert_array_almost_equal(soln</span><span class="s2">, </span><span class="s1">solve(-A</span><span class="s2">, </span><span class="s1">B)</span><span class="s2">,</span>
                                  <span class="s1">decimal=</span><span class="s4">4 </span><span class="s2">if </span><span class="s1">ind % </span><span class="s4">2 </span><span class="s1">== </span><span class="s4">0 </span><span class="s2">else </span><span class="s4">6</span><span class="s1">)</span>

        <span class="s1">soln = tfsm(-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">Afp</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">trans=trans)</span>
        <span class="s1">assert_array_almost_equal(soln</span><span class="s2">, </span><span class="s1">solve(-A.conj().T</span><span class="s2">, </span><span class="s1">B)</span><span class="s2">,</span>
                                  <span class="s1">decimal=</span><span class="s4">4 </span><span class="s2">if </span><span class="s1">ind % </span><span class="s4">2 </span><span class="s1">== </span><span class="s4">0 </span><span class="s2">else </span><span class="s4">6</span><span class="s1">)</span>

        <span class="s0"># Make A, unit diagonal</span>
        <span class="s1">A[np.arange(n)</span><span class="s2">, </span><span class="s1">np.arange(n)] = dtype(</span><span class="s4">1.</span><span class="s1">)</span>
        <span class="s1">soln = tfsm(-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">Afp</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">trans=trans</span><span class="s2">, </span><span class="s1">diag=</span><span class="s3">'U'</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(soln</span><span class="s2">, </span><span class="s1">solve(-A.conj().T</span><span class="s2">, </span><span class="s1">B)</span><span class="s2">,</span>
                                  <span class="s1">decimal=</span><span class="s4">4 </span><span class="s2">if </span><span class="s1">ind % </span><span class="s4">2 </span><span class="s1">== </span><span class="s4">0 </span><span class="s2">else </span><span class="s4">6</span><span class="s1">)</span>

        <span class="s0"># Change side</span>
        <span class="s1">B2 = rand(</span><span class="s4">3</span><span class="s2">, </span><span class="s1">n).astype(dtype)</span>
        <span class="s1">soln = tfsm(-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">Afp</span><span class="s2">, </span><span class="s1">B2</span><span class="s2">, </span><span class="s1">trans=trans</span><span class="s2">, </span><span class="s1">diag=</span><span class="s3">'U'</span><span class="s2">, </span><span class="s1">side=</span><span class="s3">'R'</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(soln</span><span class="s2">, </span><span class="s1">solve(-A</span><span class="s2">, </span><span class="s1">B2.T).conj().T</span><span class="s2">,</span>
                                  <span class="s1">decimal=</span><span class="s4">4 </span><span class="s2">if </span><span class="s1">ind % </span><span class="s4">2 </span><span class="s1">== </span><span class="s4">0 </span><span class="s2">else </span><span class="s4">6</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_ormrz_unmrz():</span>
    <span class="s5">&quot;&quot;&quot; 
    This test performs a matrix multiplication with an arbitrary m x n matric C 
    and a unitary matrix Q without explicitly forming the array. The array data 
    is encoded in the rectangular part of A which is obtained from ?TZRZF. Q 
    size is inferred by m, n, side keywords. 
    &quot;&quot;&quot;</span>
    <span class="s1">seed(</span><span class="s4">1234</span><span class="s1">)</span>
    <span class="s1">qm</span><span class="s2">, </span><span class="s1">qn</span><span class="s2">, </span><span class="s1">cn = </span><span class="s4">10</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s4">15</span>
    <span class="s2">for </span><span class="s1">ind</span><span class="s2">, </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">enumerate(DTYPES):</span>
        <span class="s1">tzrzf</span><span class="s2">, </span><span class="s1">tzrzf_lw = get_lapack_funcs((</span><span class="s3">'tzrzf'</span><span class="s2">, </span><span class="s3">'tzrzf_lwork'</span><span class="s1">)</span><span class="s2">,</span>
                                           <span class="s1">dtype=dtype)</span>
        <span class="s1">lwork_rz = _compute_lwork(tzrzf_lw</span><span class="s2">, </span><span class="s1">qm</span><span class="s2">, </span><span class="s1">qn)</span>

        <span class="s2">if </span><span class="s1">ind &lt; </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s1">A = triu(rand(qm</span><span class="s2">, </span><span class="s1">qn).astype(dtype))</span>
            <span class="s1">C = rand(cn</span><span class="s2">, </span><span class="s1">cn).astype(dtype)</span>
            <span class="s1">orun_mrz</span><span class="s2">, </span><span class="s1">orun_mrz_lw = get_lapack_funcs((</span><span class="s3">'ormrz'</span><span class="s2">, </span><span class="s3">'ormrz_lwork'</span><span class="s1">)</span><span class="s2">,</span>
                                                     <span class="s1">dtype=dtype)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">A = triu((rand(qm</span><span class="s2">, </span><span class="s1">qn) + rand(qm</span><span class="s2">, </span><span class="s1">qn)*</span><span class="s4">1j</span><span class="s1">).astype(dtype))</span>
            <span class="s1">C = (rand(cn</span><span class="s2">, </span><span class="s1">cn) + rand(cn</span><span class="s2">, </span><span class="s1">cn)*</span><span class="s4">1j</span><span class="s1">).astype(dtype)</span>
            <span class="s1">orun_mrz</span><span class="s2">, </span><span class="s1">orun_mrz_lw = get_lapack_funcs((</span><span class="s3">'unmrz'</span><span class="s2">, </span><span class="s3">'unmrz_lwork'</span><span class="s1">)</span><span class="s2">,</span>
                                                     <span class="s1">dtype=dtype)</span>

        <span class="s1">lwork_mrz = _compute_lwork(orun_mrz_lw</span><span class="s2">, </span><span class="s1">cn</span><span class="s2">, </span><span class="s1">cn)</span>
        <span class="s1">rz</span><span class="s2">, </span><span class="s1">tau</span><span class="s2">, </span><span class="s1">info = tzrzf(A</span><span class="s2">, </span><span class="s1">lwork=lwork_rz)</span>

        <span class="s0"># Get Q manually for comparison</span>
        <span class="s1">V = np.hstack((np.eye(qm</span><span class="s2">, </span><span class="s1">dtype=dtype)</span><span class="s2">, </span><span class="s1">rz[:</span><span class="s2">, </span><span class="s1">qm:]))</span>
        <span class="s1">Id = np.eye(qn</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">ref = [Id-tau[x]*V[[x]</span><span class="s2">, </span><span class="s1">:].T.dot(V[[x]</span><span class="s2">, </span><span class="s1">:].conj()) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">range(qm)]</span>
        <span class="s1">Q = reduce(np.dot</span><span class="s2">, </span><span class="s1">ref)</span>

        <span class="s0"># Now that we have Q, we can test whether lapack results agree with</span>
        <span class="s0"># each case of CQ, CQ^H, QC, and QC^H</span>
        <span class="s1">trans = </span><span class="s3">'T' </span><span class="s2">if </span><span class="s1">ind &lt; </span><span class="s4">2 </span><span class="s2">else </span><span class="s3">'C'</span>
        <span class="s1">tol = </span><span class="s4">10</span><span class="s1">*np.spacing(dtype(</span><span class="s4">1.0</span><span class="s1">).real)</span>

        <span class="s1">cq</span><span class="s2">, </span><span class="s1">info = orun_mrz(rz</span><span class="s2">, </span><span class="s1">tau</span><span class="s2">, </span><span class="s1">C</span><span class="s2">, </span><span class="s1">lwork=lwork_mrz)</span>
        <span class="s1">assert_(info == </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(cq - Q.dot(C)</span><span class="s2">, </span><span class="s1">zeros_like(C)</span><span class="s2">, </span><span class="s1">atol=tol</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.</span><span class="s1">)</span>

        <span class="s1">cq</span><span class="s2">, </span><span class="s1">info = orun_mrz(rz</span><span class="s2">, </span><span class="s1">tau</span><span class="s2">, </span><span class="s1">C</span><span class="s2">, </span><span class="s1">trans=trans</span><span class="s2">, </span><span class="s1">lwork=lwork_mrz)</span>
        <span class="s1">assert_(info == </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(cq - Q.conj().T.dot(C)</span><span class="s2">, </span><span class="s1">zeros_like(C)</span><span class="s2">, </span><span class="s1">atol=tol</span><span class="s2">,</span>
                        <span class="s1">rtol=</span><span class="s4">0.</span><span class="s1">)</span>

        <span class="s1">cq</span><span class="s2">, </span><span class="s1">info = orun_mrz(rz</span><span class="s2">, </span><span class="s1">tau</span><span class="s2">, </span><span class="s1">C</span><span class="s2">, </span><span class="s1">side=</span><span class="s3">'R'</span><span class="s2">, </span><span class="s1">lwork=lwork_mrz)</span>
        <span class="s1">assert_(info == </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(cq - C.dot(Q)</span><span class="s2">, </span><span class="s1">zeros_like(C)</span><span class="s2">, </span><span class="s1">atol=tol</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.</span><span class="s1">)</span>

        <span class="s1">cq</span><span class="s2">, </span><span class="s1">info = orun_mrz(rz</span><span class="s2">, </span><span class="s1">tau</span><span class="s2">, </span><span class="s1">C</span><span class="s2">, </span><span class="s1">side=</span><span class="s3">'R'</span><span class="s2">, </span><span class="s1">trans=trans</span><span class="s2">, </span><span class="s1">lwork=lwork_mrz)</span>
        <span class="s1">assert_(info == </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(cq - C.dot(Q.conj().T)</span><span class="s2">, </span><span class="s1">zeros_like(C)</span><span class="s2">, </span><span class="s1">atol=tol</span><span class="s2">,</span>
                        <span class="s1">rtol=</span><span class="s4">0.</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_tfttr_trttf():</span>
    <span class="s5">&quot;&quot;&quot; 
    Test conversion routines between the Rectengular Full Packed (RFP) format 
    and Standard Triangular Array (TR) 
    &quot;&quot;&quot;</span>
    <span class="s1">seed(</span><span class="s4">1234</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">ind</span><span class="s2">, </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">enumerate(DTYPES):</span>
        <span class="s1">n = </span><span class="s4">20</span>
        <span class="s2">if </span><span class="s1">ind &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">A_full = (rand(n</span><span class="s2">, </span><span class="s1">n) + rand(n</span><span class="s2">, </span><span class="s1">n)*</span><span class="s4">1j</span><span class="s1">).astype(dtype)</span>
            <span class="s1">transr = </span><span class="s3">'C'</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">A_full = (rand(n</span><span class="s2">, </span><span class="s1">n)).astype(dtype)</span>
            <span class="s1">transr = </span><span class="s3">'T'</span>

        <span class="s1">trttf</span><span class="s2">, </span><span class="s1">tfttr = get_lapack_funcs((</span><span class="s3">'trttf'</span><span class="s2">, </span><span class="s3">'tfttr'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">A_tf_U</span><span class="s2">, </span><span class="s1">info = trttf(A_full)</span>
        <span class="s1">assert_(info == </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">A_tf_L</span><span class="s2">, </span><span class="s1">info = trttf(A_full</span><span class="s2">, </span><span class="s1">uplo=</span><span class="s3">'L'</span><span class="s1">)</span>
        <span class="s1">assert_(info == </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">A_tf_U_T</span><span class="s2">, </span><span class="s1">info = trttf(A_full</span><span class="s2">, </span><span class="s1">transr=transr</span><span class="s2">, </span><span class="s1">uplo=</span><span class="s3">'U'</span><span class="s1">)</span>
        <span class="s1">assert_(info == </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">A_tf_L_T</span><span class="s2">, </span><span class="s1">info = trttf(A_full</span><span class="s2">, </span><span class="s1">transr=transr</span><span class="s2">, </span><span class="s1">uplo=</span><span class="s3">'L'</span><span class="s1">)</span>
        <span class="s1">assert_(info == </span><span class="s4">0</span><span class="s1">)</span>

        <span class="s0"># Create the RFP array manually (n is even!)</span>
        <span class="s1">A_tf_U_m = zeros((n+</span><span class="s4">1</span><span class="s2">, </span><span class="s1">n//</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">A_tf_U_m[:-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">:] = triu(A_full)[:</span><span class="s2">, </span><span class="s1">n//</span><span class="s4">2</span><span class="s1">:]</span>
        <span class="s1">A_tf_U_m[n//</span><span class="s4">2</span><span class="s1">+</span><span class="s4">1</span><span class="s1">:</span><span class="s2">, </span><span class="s1">:] += triu(A_full)[:n//</span><span class="s4">2</span><span class="s2">, </span><span class="s1">:n//</span><span class="s4">2</span><span class="s1">].conj().T</span>

        <span class="s1">A_tf_L_m = zeros((n+</span><span class="s4">1</span><span class="s2">, </span><span class="s1">n//</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">A_tf_L_m[</span><span class="s4">1</span><span class="s1">:</span><span class="s2">, </span><span class="s1">:] = tril(A_full)[:</span><span class="s2">, </span><span class="s1">:n//</span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">A_tf_L_m[:n//</span><span class="s4">2</span><span class="s2">, </span><span class="s1">:] += tril(A_full)[n//</span><span class="s4">2</span><span class="s1">:</span><span class="s2">, </span><span class="s1">n//</span><span class="s4">2</span><span class="s1">:].conj().T</span>

        <span class="s1">assert_array_almost_equal(A_tf_U</span><span class="s2">, </span><span class="s1">A_tf_U_m.reshape(-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">'F'</span><span class="s1">))</span>
        <span class="s1">assert_array_almost_equal(A_tf_U_T</span><span class="s2">,</span>
                                  <span class="s1">A_tf_U_m.conj().T.reshape(-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">'F'</span><span class="s1">))</span>

        <span class="s1">assert_array_almost_equal(A_tf_L</span><span class="s2">, </span><span class="s1">A_tf_L_m.reshape(-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">'F'</span><span class="s1">))</span>
        <span class="s1">assert_array_almost_equal(A_tf_L_T</span><span class="s2">,</span>
                                  <span class="s1">A_tf_L_m.conj().T.reshape(-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">'F'</span><span class="s1">))</span>

        <span class="s0"># Get the original array from RFP</span>
        <span class="s1">A_tr_U</span><span class="s2">, </span><span class="s1">info = tfttr(n</span><span class="s2">, </span><span class="s1">A_tf_U)</span>
        <span class="s1">assert_(info == </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">A_tr_L</span><span class="s2">, </span><span class="s1">info = tfttr(n</span><span class="s2">, </span><span class="s1">A_tf_L</span><span class="s2">, </span><span class="s1">uplo=</span><span class="s3">'L'</span><span class="s1">)</span>
        <span class="s1">assert_(info == </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">A_tr_U_T</span><span class="s2">, </span><span class="s1">info = tfttr(n</span><span class="s2">, </span><span class="s1">A_tf_U_T</span><span class="s2">, </span><span class="s1">transr=transr</span><span class="s2">, </span><span class="s1">uplo=</span><span class="s3">'U'</span><span class="s1">)</span>
        <span class="s1">assert_(info == </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">A_tr_L_T</span><span class="s2">, </span><span class="s1">info = tfttr(n</span><span class="s2">, </span><span class="s1">A_tf_L_T</span><span class="s2">, </span><span class="s1">transr=transr</span><span class="s2">, </span><span class="s1">uplo=</span><span class="s3">'L'</span><span class="s1">)</span>
        <span class="s1">assert_(info == </span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">assert_array_almost_equal(A_tr_U</span><span class="s2">, </span><span class="s1">triu(A_full))</span>
        <span class="s1">assert_array_almost_equal(A_tr_U_T</span><span class="s2">, </span><span class="s1">triu(A_full))</span>
        <span class="s1">assert_array_almost_equal(A_tr_L</span><span class="s2">, </span><span class="s1">tril(A_full))</span>
        <span class="s1">assert_array_almost_equal(A_tr_L_T</span><span class="s2">, </span><span class="s1">tril(A_full))</span>


<span class="s2">def </span><span class="s1">test_tpttr_trttp():</span>
    <span class="s5">&quot;&quot;&quot; 
    Test conversion routines between the Rectengular Full Packed (RFP) format 
    and Standard Triangular Array (TR) 
    &quot;&quot;&quot;</span>
    <span class="s1">seed(</span><span class="s4">1234</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">ind</span><span class="s2">, </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">enumerate(DTYPES):</span>
        <span class="s1">n = </span><span class="s4">20</span>
        <span class="s2">if </span><span class="s1">ind &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">A_full = (rand(n</span><span class="s2">, </span><span class="s1">n) + rand(n</span><span class="s2">, </span><span class="s1">n)*</span><span class="s4">1j</span><span class="s1">).astype(dtype)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">A_full = (rand(n</span><span class="s2">, </span><span class="s1">n)).astype(dtype)</span>

        <span class="s1">trttp</span><span class="s2">, </span><span class="s1">tpttr = get_lapack_funcs((</span><span class="s3">'trttp'</span><span class="s2">, </span><span class="s3">'tpttr'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">A_tp_U</span><span class="s2">, </span><span class="s1">info = trttp(A_full)</span>
        <span class="s1">assert_(info == </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">A_tp_L</span><span class="s2">, </span><span class="s1">info = trttp(A_full</span><span class="s2">, </span><span class="s1">uplo=</span><span class="s3">'L'</span><span class="s1">)</span>
        <span class="s1">assert_(info == </span><span class="s4">0</span><span class="s1">)</span>

        <span class="s0"># Create the TP array manually</span>
        <span class="s1">inds = tril_indices(n)</span>
        <span class="s1">A_tp_U_m = zeros(n*(n+</span><span class="s4">1</span><span class="s1">)//</span><span class="s4">2</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">A_tp_U_m[:] = (triu(A_full).T)[inds]</span>

        <span class="s1">inds = triu_indices(n)</span>
        <span class="s1">A_tp_L_m = zeros(n*(n+</span><span class="s4">1</span><span class="s1">)//</span><span class="s4">2</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">A_tp_L_m[:] = (tril(A_full).T)[inds]</span>

        <span class="s1">assert_array_almost_equal(A_tp_U</span><span class="s2">, </span><span class="s1">A_tp_U_m)</span>
        <span class="s1">assert_array_almost_equal(A_tp_L</span><span class="s2">, </span><span class="s1">A_tp_L_m)</span>

        <span class="s0"># Get the original array from TP</span>
        <span class="s1">A_tr_U</span><span class="s2">, </span><span class="s1">info = tpttr(n</span><span class="s2">, </span><span class="s1">A_tp_U)</span>
        <span class="s1">assert_(info == </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">A_tr_L</span><span class="s2">, </span><span class="s1">info = tpttr(n</span><span class="s2">, </span><span class="s1">A_tp_L</span><span class="s2">, </span><span class="s1">uplo=</span><span class="s3">'L'</span><span class="s1">)</span>
        <span class="s1">assert_(info == </span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">assert_array_almost_equal(A_tr_U</span><span class="s2">, </span><span class="s1">triu(A_full))</span>
        <span class="s1">assert_array_almost_equal(A_tr_L</span><span class="s2">, </span><span class="s1">tril(A_full))</span>


<span class="s2">def </span><span class="s1">test_pftrf():</span>
    <span class="s5">&quot;&quot;&quot; 
    Test Cholesky factorization of a positive definite Rectengular Full 
    Packed (RFP) format array 
    &quot;&quot;&quot;</span>
    <span class="s1">seed(</span><span class="s4">1234</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">ind</span><span class="s2">, </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">enumerate(DTYPES):</span>
        <span class="s1">n = </span><span class="s4">20</span>
        <span class="s2">if </span><span class="s1">ind &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">A = (rand(n</span><span class="s2">, </span><span class="s1">n) + rand(n</span><span class="s2">, </span><span class="s1">n)*</span><span class="s4">1j</span><span class="s1">).astype(dtype)</span>
            <span class="s1">A = A + A.conj().T + n*eye(n)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">A = (rand(n</span><span class="s2">, </span><span class="s1">n)).astype(dtype)</span>
            <span class="s1">A = A + A.T + n*eye(n)</span>

        <span class="s1">pftrf</span><span class="s2">, </span><span class="s1">trttf</span><span class="s2">, </span><span class="s1">tfttr = get_lapack_funcs((</span><span class="s3">'pftrf'</span><span class="s2">, </span><span class="s3">'trttf'</span><span class="s2">, </span><span class="s3">'tfttr'</span><span class="s1">)</span><span class="s2">,</span>
                                               <span class="s1">dtype=dtype)</span>

        <span class="s0"># Get the original array from TP</span>
        <span class="s1">Afp</span><span class="s2">, </span><span class="s1">info = trttf(A)</span>
        <span class="s1">Achol_rfp</span><span class="s2">, </span><span class="s1">info = pftrf(n</span><span class="s2">, </span><span class="s1">Afp)</span>
        <span class="s1">assert_(info == </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">A_chol_r</span><span class="s2">, </span><span class="s1">_ = tfttr(n</span><span class="s2">, </span><span class="s1">Achol_rfp)</span>
        <span class="s1">Achol = cholesky(A)</span>
        <span class="s1">assert_array_almost_equal(A_chol_r</span><span class="s2">, </span><span class="s1">Achol)</span>


<span class="s2">def </span><span class="s1">test_pftri():</span>
    <span class="s5">&quot;&quot;&quot; 
    Test Cholesky factorization of a positive definite Rectengular Full 
    Packed (RFP) format array to find its inverse 
    &quot;&quot;&quot;</span>
    <span class="s1">seed(</span><span class="s4">1234</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">ind</span><span class="s2">, </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">enumerate(DTYPES):</span>
        <span class="s1">n = </span><span class="s4">20</span>
        <span class="s2">if </span><span class="s1">ind &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">A = (rand(n</span><span class="s2">, </span><span class="s1">n) + rand(n</span><span class="s2">, </span><span class="s1">n)*</span><span class="s4">1j</span><span class="s1">).astype(dtype)</span>
            <span class="s1">A = A + A.conj().T + n*eye(n)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">A = (rand(n</span><span class="s2">, </span><span class="s1">n)).astype(dtype)</span>
            <span class="s1">A = A + A.T + n*eye(n)</span>

        <span class="s1">pftri</span><span class="s2">, </span><span class="s1">pftrf</span><span class="s2">, </span><span class="s1">trttf</span><span class="s2">, </span><span class="s1">tfttr = get_lapack_funcs((</span><span class="s3">'pftri'</span><span class="s2">,</span>
                                                       <span class="s3">'pftrf'</span><span class="s2">,</span>
                                                       <span class="s3">'trttf'</span><span class="s2">,</span>
                                                       <span class="s3">'tfttr'</span><span class="s1">)</span><span class="s2">,</span>
                                                      <span class="s1">dtype=dtype)</span>

        <span class="s0"># Get the original array from TP</span>
        <span class="s1">Afp</span><span class="s2">, </span><span class="s1">info = trttf(A)</span>
        <span class="s1">A_chol_rfp</span><span class="s2">, </span><span class="s1">info = pftrf(n</span><span class="s2">, </span><span class="s1">Afp)</span>
        <span class="s1">A_inv_rfp</span><span class="s2">, </span><span class="s1">info = pftri(n</span><span class="s2">, </span><span class="s1">A_chol_rfp)</span>
        <span class="s1">assert_(info == </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">A_inv_r</span><span class="s2">, </span><span class="s1">_ = tfttr(n</span><span class="s2">, </span><span class="s1">A_inv_rfp)</span>
        <span class="s1">Ainv = inv(A)</span>
        <span class="s1">assert_array_almost_equal(A_inv_r</span><span class="s2">, </span><span class="s1">triu(Ainv)</span><span class="s2">,</span>
                                  <span class="s1">decimal=</span><span class="s4">4 </span><span class="s2">if </span><span class="s1">ind % </span><span class="s4">2 </span><span class="s1">== </span><span class="s4">0 </span><span class="s2">else </span><span class="s4">6</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_pftrs():</span>
    <span class="s5">&quot;&quot;&quot; 
    Test Cholesky factorization of a positive definite Rectengular Full 
    Packed (RFP) format array and solve a linear system 
    &quot;&quot;&quot;</span>
    <span class="s1">seed(</span><span class="s4">1234</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">ind</span><span class="s2">, </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">enumerate(DTYPES):</span>
        <span class="s1">n = </span><span class="s4">20</span>
        <span class="s2">if </span><span class="s1">ind &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">A = (rand(n</span><span class="s2">, </span><span class="s1">n) + rand(n</span><span class="s2">, </span><span class="s1">n)*</span><span class="s4">1j</span><span class="s1">).astype(dtype)</span>
            <span class="s1">A = A + A.conj().T + n*eye(n)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">A = (rand(n</span><span class="s2">, </span><span class="s1">n)).astype(dtype)</span>
            <span class="s1">A = A + A.T + n*eye(n)</span>

        <span class="s1">B = ones((n</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">Bf1 = ones((n+</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">Bf2 = ones((n-</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">pftrs</span><span class="s2">, </span><span class="s1">pftrf</span><span class="s2">, </span><span class="s1">trttf</span><span class="s2">, </span><span class="s1">tfttr = get_lapack_funcs((</span><span class="s3">'pftrs'</span><span class="s2">,</span>
                                                       <span class="s3">'pftrf'</span><span class="s2">,</span>
                                                       <span class="s3">'trttf'</span><span class="s2">,</span>
                                                       <span class="s3">'tfttr'</span><span class="s1">)</span><span class="s2">,</span>
                                                      <span class="s1">dtype=dtype)</span>

        <span class="s0"># Get the original array from TP</span>
        <span class="s1">Afp</span><span class="s2">, </span><span class="s1">info = trttf(A)</span>
        <span class="s1">A_chol_rfp</span><span class="s2">, </span><span class="s1">info = pftrf(n</span><span class="s2">, </span><span class="s1">Afp)</span>
        <span class="s0"># larger B arrays shouldn't segfault</span>
        <span class="s1">soln</span><span class="s2">, </span><span class="s1">info = pftrs(n</span><span class="s2">, </span><span class="s1">A_chol_rfp</span><span class="s2">, </span><span class="s1">Bf1)</span>
        <span class="s1">assert_(info == </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_raises(Exception</span><span class="s2">, </span><span class="s1">pftrs</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">A_chol_rfp</span><span class="s2">, </span><span class="s1">Bf2)</span>
        <span class="s1">soln</span><span class="s2">, </span><span class="s1">info = pftrs(n</span><span class="s2">, </span><span class="s1">A_chol_rfp</span><span class="s2">, </span><span class="s1">B)</span>
        <span class="s1">assert_(info == </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(solve(A</span><span class="s2">, </span><span class="s1">B)</span><span class="s2">, </span><span class="s1">soln</span><span class="s2">,</span>
                                  <span class="s1">decimal=</span><span class="s4">4 </span><span class="s2">if </span><span class="s1">ind % </span><span class="s4">2 </span><span class="s1">== </span><span class="s4">0 </span><span class="s2">else </span><span class="s4">6</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_sfrk_hfrk():</span>
    <span class="s5">&quot;&quot;&quot; 
    Test for performing a symmetric rank-k operation for matrix in RFP format. 
    &quot;&quot;&quot;</span>
    <span class="s1">seed(</span><span class="s4">1234</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">ind</span><span class="s2">, </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">enumerate(DTYPES):</span>
        <span class="s1">n = </span><span class="s4">20</span>
        <span class="s2">if </span><span class="s1">ind &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">A = (rand(n</span><span class="s2">, </span><span class="s1">n) + rand(n</span><span class="s2">, </span><span class="s1">n)*</span><span class="s4">1j</span><span class="s1">).astype(dtype)</span>
            <span class="s1">A = A + A.conj().T + n*eye(n)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">A = (rand(n</span><span class="s2">, </span><span class="s1">n)).astype(dtype)</span>
            <span class="s1">A = A + A.T + n*eye(n)</span>

        <span class="s1">prefix = </span><span class="s3">'s'</span><span class="s2">if </span><span class="s1">ind &lt; </span><span class="s4">2 </span><span class="s2">else </span><span class="s3">'h'</span>
        <span class="s1">trttf</span><span class="s2">, </span><span class="s1">tfttr</span><span class="s2">, </span><span class="s1">shfrk = get_lapack_funcs((</span><span class="s3">'trttf'</span><span class="s2">, </span><span class="s3">'tfttr'</span><span class="s2">, </span><span class="s3">'{}frk'</span>
                                                <span class="s3">''</span><span class="s1">.format(prefix))</span><span class="s2">,</span>
                                               <span class="s1">dtype=dtype)</span>

        <span class="s1">Afp</span><span class="s2">, </span><span class="s1">_ = trttf(A)</span>
        <span class="s1">C = np.random.rand(n</span><span class="s2">, </span><span class="s4">2</span><span class="s1">).astype(dtype)</span>
        <span class="s1">Afp_out = shfrk(n</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">C</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">Afp)</span>
        <span class="s1">A_out</span><span class="s2">, </span><span class="s1">_ = tfttr(n</span><span class="s2">, </span><span class="s1">Afp_out)</span>
        <span class="s1">assert_array_almost_equal(A_out</span><span class="s2">, </span><span class="s1">triu(-C.dot(C.conj().T) + </span><span class="s4">2</span><span class="s1">*A)</span><span class="s2">,</span>
                                  <span class="s1">decimal=</span><span class="s4">4 </span><span class="s2">if </span><span class="s1">ind % </span><span class="s4">2 </span><span class="s1">== </span><span class="s4">0 </span><span class="s2">else </span><span class="s4">6</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_syconv():</span>
    <span class="s5">&quot;&quot;&quot; 
    Test for going back and forth between the returned format of he/sytrf to 
    L and D factors/permutations. 
    &quot;&quot;&quot;</span>
    <span class="s1">seed(</span><span class="s4">1234</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">ind</span><span class="s2">, </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">enumerate(DTYPES):</span>
        <span class="s1">n = </span><span class="s4">10</span>

        <span class="s2">if </span><span class="s1">ind &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">A = (randint(-</span><span class="s4">30</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s1">(n</span><span class="s2">, </span><span class="s1">n)) +</span>
                 <span class="s1">randint(-</span><span class="s4">30</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s1">(n</span><span class="s2">, </span><span class="s1">n))*</span><span class="s4">1j</span><span class="s1">).astype(dtype)</span>

            <span class="s1">A = A + A.conj().T</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">A = randint(-</span><span class="s4">30</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s1">(n</span><span class="s2">, </span><span class="s1">n)).astype(dtype)</span>
            <span class="s1">A = A + A.T + n*eye(n)</span>

        <span class="s1">tol = </span><span class="s4">100</span><span class="s1">*np.spacing(dtype(</span><span class="s4">1.0</span><span class="s1">).real)</span>
        <span class="s1">syconv</span><span class="s2">, </span><span class="s1">trf</span><span class="s2">, </span><span class="s1">trf_lwork = get_lapack_funcs((</span><span class="s3">'syconv'</span><span class="s2">, </span><span class="s3">'sytrf'</span><span class="s2">,</span>
                                                   <span class="s3">'sytrf_lwork'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">lw = _compute_lwork(trf_lwork</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">lower=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">L</span><span class="s2">, </span><span class="s1">D</span><span class="s2">, </span><span class="s1">perm = ldl(A</span><span class="s2">, </span><span class="s1">lower=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">hermitian=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">lw = _compute_lwork(trf_lwork</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">lower=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">ldu</span><span class="s2">, </span><span class="s1">ipiv</span><span class="s2">, </span><span class="s1">info = trf(A</span><span class="s2">, </span><span class="s1">lower=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">lwork=lw)</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">info = syconv(ldu</span><span class="s2">, </span><span class="s1">ipiv</span><span class="s2">, </span><span class="s1">lower=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(tril(a</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">tril(L[perm</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">atol=tol</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.</span><span class="s1">)</span>

        <span class="s0"># Test also upper</span>
        <span class="s1">U</span><span class="s2">, </span><span class="s1">D</span><span class="s2">, </span><span class="s1">perm = ldl(A</span><span class="s2">, </span><span class="s1">lower=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">hermitian=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">ldu</span><span class="s2">, </span><span class="s1">ipiv</span><span class="s2">, </span><span class="s1">info = trf(A</span><span class="s2">, </span><span class="s1">lower=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">info = syconv(ldu</span><span class="s2">, </span><span class="s1">ipiv</span><span class="s2">, </span><span class="s1">lower=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(triu(a</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">triu(U[perm</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">atol=tol</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestBlockedQR:</span>
    <span class="s5">&quot;&quot;&quot; 
    Tests for the blocked QR factorization, namely through geqrt, gemqrt, tpqrt 
    and tpmqr. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">test_geqrt_gemqrt(self):</span>
        <span class="s1">seed(</span><span class="s4">1234</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">ind</span><span class="s2">, </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">enumerate(DTYPES):</span>
            <span class="s1">n = </span><span class="s4">20</span>

            <span class="s2">if </span><span class="s1">ind &gt; </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">A = (rand(n</span><span class="s2">, </span><span class="s1">n) + rand(n</span><span class="s2">, </span><span class="s1">n)*</span><span class="s4">1j</span><span class="s1">).astype(dtype)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">A = (rand(n</span><span class="s2">, </span><span class="s1">n)).astype(dtype)</span>

            <span class="s1">tol = </span><span class="s4">100</span><span class="s1">*np.spacing(dtype(</span><span class="s4">1.0</span><span class="s1">).real)</span>
            <span class="s1">geqrt</span><span class="s2">, </span><span class="s1">gemqrt = get_lapack_funcs((</span><span class="s3">'geqrt'</span><span class="s2">, </span><span class="s3">'gemqrt'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

            <span class="s1">a</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">info = geqrt(n</span><span class="s2">, </span><span class="s1">A)</span>
            <span class="s2">assert </span><span class="s1">info == </span><span class="s4">0</span>

            <span class="s0"># Extract elementary reflectors from lower triangle, adding the</span>
            <span class="s0"># main diagonal of ones.</span>
            <span class="s1">v = np.tril(a</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">) + np.eye(n</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s0"># Generate the block Householder transform I - VTV^H</span>
            <span class="s1">Q = np.eye(n</span><span class="s2">, </span><span class="s1">dtype=dtype) - v @ t @ v.T.conj()</span>
            <span class="s1">R = np.triu(a)</span>

            <span class="s0"># Test columns of Q are orthogonal</span>
            <span class="s1">assert_allclose(Q.T.conj() @ Q</span><span class="s2">, </span><span class="s1">np.eye(n</span><span class="s2">, </span><span class="s1">dtype=dtype)</span><span class="s2">, </span><span class="s1">atol=tol</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s4">0.</span><span class="s1">)</span>
            <span class="s1">assert_allclose(Q @ R</span><span class="s2">, </span><span class="s1">A</span><span class="s2">, </span><span class="s1">atol=tol</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.</span><span class="s1">)</span>

            <span class="s2">if </span><span class="s1">ind &gt; </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">C = (rand(n</span><span class="s2">, </span><span class="s1">n) + rand(n</span><span class="s2">, </span><span class="s1">n)*</span><span class="s4">1j</span><span class="s1">).astype(dtype)</span>
                <span class="s1">transpose = </span><span class="s3">'C'</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">C = (rand(n</span><span class="s2">, </span><span class="s1">n)).astype(dtype)</span>
                <span class="s1">transpose = </span><span class="s3">'T'</span>

            <span class="s2">for </span><span class="s1">side </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'L'</span><span class="s2">, </span><span class="s3">'R'</span><span class="s1">):</span>
                <span class="s2">for </span><span class="s1">trans </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'N'</span><span class="s2">, </span><span class="s1">transpose):</span>
                    <span class="s1">c</span><span class="s2">, </span><span class="s1">info = gemqrt(a</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">C</span><span class="s2">, </span><span class="s1">side=side</span><span class="s2">, </span><span class="s1">trans=trans)</span>
                    <span class="s2">assert </span><span class="s1">info == </span><span class="s4">0</span>

                    <span class="s2">if </span><span class="s1">trans == transpose:</span>
                        <span class="s1">q = Q.T.conj()</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">q = Q</span>

                    <span class="s2">if </span><span class="s1">side == </span><span class="s3">'L'</span><span class="s1">:</span>
                        <span class="s1">qC = q @ C</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">qC = C @ q</span>

                    <span class="s1">assert_allclose(c</span><span class="s2">, </span><span class="s1">qC</span><span class="s2">, </span><span class="s1">atol=tol</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.</span><span class="s1">)</span>

                    <span class="s0"># Test default arguments</span>
                    <span class="s2">if </span><span class="s1">(side</span><span class="s2">, </span><span class="s1">trans) == (</span><span class="s3">'L'</span><span class="s2">, </span><span class="s3">'N'</span><span class="s1">):</span>
                        <span class="s1">c_default</span><span class="s2">, </span><span class="s1">info = gemqrt(a</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">C)</span>
                        <span class="s2">assert </span><span class="s1">info == </span><span class="s4">0</span>
                        <span class="s1">assert_equal(c_default</span><span class="s2">, </span><span class="s1">c)</span>

            <span class="s0"># Test invalid side/trans</span>
            <span class="s1">assert_raises(Exception</span><span class="s2">, </span><span class="s1">gemqrt</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">C</span><span class="s2">, </span><span class="s1">side=</span><span class="s3">'A'</span><span class="s1">)</span>
            <span class="s1">assert_raises(Exception</span><span class="s2">, </span><span class="s1">gemqrt</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">C</span><span class="s2">, </span><span class="s1">trans=</span><span class="s3">'A'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_tpqrt_tpmqrt(self):</span>
        <span class="s1">seed(</span><span class="s4">1234</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">ind</span><span class="s2">, </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">enumerate(DTYPES):</span>
            <span class="s1">n = </span><span class="s4">20</span>

            <span class="s2">if </span><span class="s1">ind &gt; </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">A = (rand(n</span><span class="s2">, </span><span class="s1">n) + rand(n</span><span class="s2">, </span><span class="s1">n)*</span><span class="s4">1j</span><span class="s1">).astype(dtype)</span>
                <span class="s1">B = (rand(n</span><span class="s2">, </span><span class="s1">n) + rand(n</span><span class="s2">, </span><span class="s1">n)*</span><span class="s4">1j</span><span class="s1">).astype(dtype)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">A = (rand(n</span><span class="s2">, </span><span class="s1">n)).astype(dtype)</span>
                <span class="s1">B = (rand(n</span><span class="s2">, </span><span class="s1">n)).astype(dtype)</span>

            <span class="s1">tol = </span><span class="s4">100</span><span class="s1">*np.spacing(dtype(</span><span class="s4">1.0</span><span class="s1">).real)</span>
            <span class="s1">tpqrt</span><span class="s2">, </span><span class="s1">tpmqrt = get_lapack_funcs((</span><span class="s3">'tpqrt'</span><span class="s2">, </span><span class="s3">'tpmqrt'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

            <span class="s0"># Test for the range of pentagonal B, from square to upper</span>
            <span class="s0"># triangular</span>
            <span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">n // </span><span class="s4">2</span><span class="s2">, </span><span class="s1">n):</span>
                <span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">info = tpqrt(l</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">A</span><span class="s2">, </span><span class="s1">B)</span>
                <span class="s2">assert </span><span class="s1">info == </span><span class="s4">0</span>

                <span class="s0"># Check that lower triangular part of A has not been modified</span>
                <span class="s1">assert_equal(np.tril(a</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.tril(A</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">))</span>
                <span class="s0"># Check that elements not part of the pentagonal portion of B</span>
                <span class="s0"># have not been modified.</span>
                <span class="s1">assert_equal(np.tril(b</span><span class="s2">, </span><span class="s1">l - n - </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.tril(B</span><span class="s2">, </span><span class="s1">l - n - </span><span class="s4">1</span><span class="s1">))</span>

                <span class="s0"># Extract pentagonal portion of B</span>
                <span class="s1">B_pent</span><span class="s2">, </span><span class="s1">b_pent = np.triu(B</span><span class="s2">, </span><span class="s1">l - n)</span><span class="s2">, </span><span class="s1">np.triu(b</span><span class="s2">, </span><span class="s1">l - n)</span>

                <span class="s0"># Generate elementary reflectors</span>
                <span class="s1">v = np.concatenate((np.eye(n</span><span class="s2">, </span><span class="s1">dtype=dtype)</span><span class="s2">, </span><span class="s1">b_pent))</span>
                <span class="s0"># Generate the block Householder transform I - VTV^H</span>
                <span class="s1">Q = np.eye(</span><span class="s4">2 </span><span class="s1">* n</span><span class="s2">, </span><span class="s1">dtype=dtype) - v @ t @ v.T.conj()</span>
                <span class="s1">R = np.concatenate((np.triu(a)</span><span class="s2">, </span><span class="s1">np.zeros_like(a)))</span>

                <span class="s0"># Test columns of Q are orthogonal</span>
                <span class="s1">assert_allclose(Q.T.conj() @ Q</span><span class="s2">, </span><span class="s1">np.eye(</span><span class="s4">2 </span><span class="s1">* n</span><span class="s2">, </span><span class="s1">dtype=dtype)</span><span class="s2">,</span>
                                <span class="s1">atol=tol</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.</span><span class="s1">)</span>
                <span class="s1">assert_allclose(Q @ R</span><span class="s2">, </span><span class="s1">np.concatenate((np.triu(A)</span><span class="s2">, </span><span class="s1">B_pent))</span><span class="s2">,</span>
                                <span class="s1">atol=tol</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.</span><span class="s1">)</span>

                <span class="s2">if </span><span class="s1">ind &gt; </span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s1">C = (rand(n</span><span class="s2">, </span><span class="s1">n) + rand(n</span><span class="s2">, </span><span class="s1">n)*</span><span class="s4">1j</span><span class="s1">).astype(dtype)</span>
                    <span class="s1">D = (rand(n</span><span class="s2">, </span><span class="s1">n) + rand(n</span><span class="s2">, </span><span class="s1">n)*</span><span class="s4">1j</span><span class="s1">).astype(dtype)</span>
                    <span class="s1">transpose = </span><span class="s3">'C'</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">C = (rand(n</span><span class="s2">, </span><span class="s1">n)).astype(dtype)</span>
                    <span class="s1">D = (rand(n</span><span class="s2">, </span><span class="s1">n)).astype(dtype)</span>
                    <span class="s1">transpose = </span><span class="s3">'T'</span>

                <span class="s2">for </span><span class="s1">side </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'L'</span><span class="s2">, </span><span class="s3">'R'</span><span class="s1">):</span>
                    <span class="s2">for </span><span class="s1">trans </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'N'</span><span class="s2">, </span><span class="s1">transpose):</span>
                        <span class="s1">c</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">info = tpmqrt(l</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">C</span><span class="s2">, </span><span class="s1">D</span><span class="s2">, </span><span class="s1">side=side</span><span class="s2">,</span>
                                            <span class="s1">trans=trans)</span>
                        <span class="s2">assert </span><span class="s1">info == </span><span class="s4">0</span>

                        <span class="s2">if </span><span class="s1">trans == transpose:</span>
                            <span class="s1">q = Q.T.conj()</span>
                        <span class="s2">else</span><span class="s1">:</span>
                            <span class="s1">q = Q</span>

                        <span class="s2">if </span><span class="s1">side == </span><span class="s3">'L'</span><span class="s1">:</span>
                            <span class="s1">cd = np.concatenate((c</span><span class="s2">, </span><span class="s1">d)</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>
                            <span class="s1">CD = np.concatenate((C</span><span class="s2">, </span><span class="s1">D)</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>
                            <span class="s1">qCD = q @ CD</span>
                        <span class="s2">else</span><span class="s1">:</span>
                            <span class="s1">cd = np.concatenate((c</span><span class="s2">, </span><span class="s1">d)</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
                            <span class="s1">CD = np.concatenate((C</span><span class="s2">, </span><span class="s1">D)</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
                            <span class="s1">qCD = CD @ q</span>

                        <span class="s1">assert_allclose(cd</span><span class="s2">, </span><span class="s1">qCD</span><span class="s2">, </span><span class="s1">atol=tol</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.</span><span class="s1">)</span>

                        <span class="s2">if </span><span class="s1">(side</span><span class="s2">, </span><span class="s1">trans) == (</span><span class="s3">'L'</span><span class="s2">, </span><span class="s3">'N'</span><span class="s1">):</span>
                            <span class="s1">c_default</span><span class="s2">, </span><span class="s1">d_default</span><span class="s2">, </span><span class="s1">info = tpmqrt(l</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">C</span><span class="s2">, </span><span class="s1">D)</span>
                            <span class="s2">assert </span><span class="s1">info == </span><span class="s4">0</span>
                            <span class="s1">assert_equal(c_default</span><span class="s2">, </span><span class="s1">c)</span>
                            <span class="s1">assert_equal(d_default</span><span class="s2">, </span><span class="s1">d)</span>

                <span class="s0"># Test invalid side/trans</span>
                <span class="s1">assert_raises(Exception</span><span class="s2">, </span><span class="s1">tpmqrt</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">C</span><span class="s2">, </span><span class="s1">D</span><span class="s2">, </span><span class="s1">side=</span><span class="s3">'A'</span><span class="s1">)</span>
                <span class="s1">assert_raises(Exception</span><span class="s2">, </span><span class="s1">tpmqrt</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">C</span><span class="s2">, </span><span class="s1">D</span><span class="s2">, </span><span class="s1">trans=</span><span class="s3">'A'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_pstrf():</span>
    <span class="s1">seed(</span><span class="s4">1234</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">ind</span><span class="s2">, </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">enumerate(DTYPES):</span>
        <span class="s0"># DTYPES = &lt;s, d, c, z&gt; pstrf</span>
        <span class="s1">n = </span><span class="s4">10</span>
        <span class="s1">r = </span><span class="s4">2</span>
        <span class="s1">pstrf = get_lapack_funcs(</span><span class="s3">'pstrf'</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

        <span class="s0"># Create positive semidefinite A</span>
        <span class="s2">if </span><span class="s1">ind &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">A = rand(n</span><span class="s2">, </span><span class="s1">n-r).astype(dtype) + </span><span class="s4">1j </span><span class="s1">* rand(n</span><span class="s2">, </span><span class="s1">n-r).astype(dtype)</span>
            <span class="s1">A = A @ A.conj().T</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">A = rand(n</span><span class="s2">, </span><span class="s1">n-r).astype(dtype)</span>
            <span class="s1">A = A @ A.T</span>

        <span class="s1">c</span><span class="s2">, </span><span class="s1">piv</span><span class="s2">, </span><span class="s1">r_c</span><span class="s2">, </span><span class="s1">info = pstrf(A)</span>
        <span class="s1">U = triu(c)</span>
        <span class="s1">U[r_c - n:</span><span class="s2">, </span><span class="s1">r_c - n:] = </span><span class="s4">0.</span>

        <span class="s1">assert_equal(info</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s0"># python-dbg 3.5.2 runs cause trouble with the following assertion.</span>
        <span class="s0"># assert_equal(r_c, n - r)</span>
        <span class="s1">single_atol = </span><span class="s4">1000 </span><span class="s1">* np.finfo(np.float32).eps</span>
        <span class="s1">double_atol = </span><span class="s4">1000 </span><span class="s1">* np.finfo(np.float64).eps</span>
        <span class="s1">atol = single_atol </span><span class="s2">if </span><span class="s1">ind </span><span class="s2">in </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">] </span><span class="s2">else </span><span class="s1">double_atol</span>
        <span class="s1">assert_allclose(A[piv-</span><span class="s4">1</span><span class="s1">][:</span><span class="s2">, </span><span class="s1">piv-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">U.conj().T @ U</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.</span><span class="s2">, </span><span class="s1">atol=atol)</span>

        <span class="s1">c</span><span class="s2">, </span><span class="s1">piv</span><span class="s2">, </span><span class="s1">r_c</span><span class="s2">, </span><span class="s1">info = pstrf(A</span><span class="s2">, </span><span class="s1">lower=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">L = tril(c)</span>
        <span class="s1">L[r_c - n:</span><span class="s2">, </span><span class="s1">r_c - n:] = </span><span class="s4">0.</span>

        <span class="s1">assert_equal(info</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s0"># assert_equal(r_c, n - r)</span>
        <span class="s1">single_atol = </span><span class="s4">1000 </span><span class="s1">* np.finfo(np.float32).eps</span>
        <span class="s1">double_atol = </span><span class="s4">1000 </span><span class="s1">* np.finfo(np.float64).eps</span>
        <span class="s1">atol = single_atol </span><span class="s2">if </span><span class="s1">ind </span><span class="s2">in </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">] </span><span class="s2">else </span><span class="s1">double_atol</span>
        <span class="s1">assert_allclose(A[piv-</span><span class="s4">1</span><span class="s1">][:</span><span class="s2">, </span><span class="s1">piv-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">L @ L.conj().T</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.</span><span class="s2">, </span><span class="s1">atol=atol)</span>


<span class="s2">def </span><span class="s1">test_pstf2():</span>
    <span class="s1">seed(</span><span class="s4">1234</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">ind</span><span class="s2">, </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">enumerate(DTYPES):</span>
        <span class="s0"># DTYPES = &lt;s, d, c, z&gt; pstf2</span>
        <span class="s1">n = </span><span class="s4">10</span>
        <span class="s1">r = </span><span class="s4">2</span>
        <span class="s1">pstf2 = get_lapack_funcs(</span><span class="s3">'pstf2'</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

        <span class="s0"># Create positive semidefinite A</span>
        <span class="s2">if </span><span class="s1">ind &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">A = rand(n</span><span class="s2">, </span><span class="s1">n-r).astype(dtype) + </span><span class="s4">1j </span><span class="s1">* rand(n</span><span class="s2">, </span><span class="s1">n-r).astype(dtype)</span>
            <span class="s1">A = A @ A.conj().T</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">A = rand(n</span><span class="s2">, </span><span class="s1">n-r).astype(dtype)</span>
            <span class="s1">A = A @ A.T</span>

        <span class="s1">c</span><span class="s2">, </span><span class="s1">piv</span><span class="s2">, </span><span class="s1">r_c</span><span class="s2">, </span><span class="s1">info = pstf2(A)</span>
        <span class="s1">U = triu(c)</span>
        <span class="s1">U[r_c - n:</span><span class="s2">, </span><span class="s1">r_c - n:] = </span><span class="s4">0.</span>

        <span class="s1">assert_equal(info</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s0"># python-dbg 3.5.2 runs cause trouble with the commented assertions.</span>
        <span class="s0"># assert_equal(r_c, n - r)</span>
        <span class="s1">single_atol = </span><span class="s4">1000 </span><span class="s1">* np.finfo(np.float32).eps</span>
        <span class="s1">double_atol = </span><span class="s4">1000 </span><span class="s1">* np.finfo(np.float64).eps</span>
        <span class="s1">atol = single_atol </span><span class="s2">if </span><span class="s1">ind </span><span class="s2">in </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">] </span><span class="s2">else </span><span class="s1">double_atol</span>
        <span class="s1">assert_allclose(A[piv-</span><span class="s4">1</span><span class="s1">][:</span><span class="s2">, </span><span class="s1">piv-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">U.conj().T @ U</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.</span><span class="s2">, </span><span class="s1">atol=atol)</span>

        <span class="s1">c</span><span class="s2">, </span><span class="s1">piv</span><span class="s2">, </span><span class="s1">r_c</span><span class="s2">, </span><span class="s1">info = pstf2(A</span><span class="s2">, </span><span class="s1">lower=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">L = tril(c)</span>
        <span class="s1">L[r_c - n:</span><span class="s2">, </span><span class="s1">r_c - n:] = </span><span class="s4">0.</span>

        <span class="s1">assert_equal(info</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s0"># assert_equal(r_c, n - r)</span>
        <span class="s1">single_atol = </span><span class="s4">1000 </span><span class="s1">* np.finfo(np.float32).eps</span>
        <span class="s1">double_atol = </span><span class="s4">1000 </span><span class="s1">* np.finfo(np.float64).eps</span>
        <span class="s1">atol = single_atol </span><span class="s2">if </span><span class="s1">ind </span><span class="s2">in </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">] </span><span class="s2">else </span><span class="s1">double_atol</span>
        <span class="s1">assert_allclose(A[piv-</span><span class="s4">1</span><span class="s1">][:</span><span class="s2">, </span><span class="s1">piv-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">L @ L.conj().T</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.</span><span class="s2">, </span><span class="s1">atol=atol)</span>


<span class="s2">def </span><span class="s1">test_geequ():</span>
    <span class="s1">desired_real = np.array([[</span><span class="s4">0.6250</span><span class="s2">, </span><span class="s4">1.0000</span><span class="s2">, </span><span class="s4">0.0393</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.4269</span><span class="s1">]</span><span class="s2">,</span>
                             <span class="s1">[</span><span class="s4">1.0000</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.5619</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.0000</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.0000</span><span class="s1">]</span><span class="s2">,</span>
                             <span class="s1">[</span><span class="s4">0.5874</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.0000</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.0596</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.5341</span><span class="s1">]</span><span class="s2">,</span>
                             <span class="s1">[-</span><span class="s4">1.0000</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.5946</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.0294</span><span class="s2">, </span><span class="s4">0.9957</span><span class="s1">]])</span>

    <span class="s1">desired_cplx = np.array([[-</span><span class="s4">0.2816</span><span class="s1">+</span><span class="s4">0.5359</span><span class="s1">*</span><span class="s4">1j</span><span class="s2">,</span>
                              <span class="s4">0.0812</span><span class="s1">+</span><span class="s4">0.9188</span><span class="s1">*</span><span class="s4">1j</span><span class="s2">,</span>
                              <span class="s1">-</span><span class="s4">0.7439</span><span class="s1">-</span><span class="s4">0.2561</span><span class="s1">*</span><span class="s4">1j</span><span class="s1">]</span><span class="s2">,</span>
                             <span class="s1">[-</span><span class="s4">0.3562</span><span class="s1">-</span><span class="s4">0.2954</span><span class="s1">*</span><span class="s4">1j</span><span class="s2">,</span>
                              <span class="s4">0.9566</span><span class="s1">-</span><span class="s4">0.0434</span><span class="s1">*</span><span class="s4">1j</span><span class="s2">,</span>
                              <span class="s1">-</span><span class="s4">0.0174</span><span class="s1">+</span><span class="s4">0.1555</span><span class="s1">*</span><span class="s4">1j</span><span class="s1">]</span><span class="s2">,</span>
                             <span class="s1">[</span><span class="s4">0.8607</span><span class="s1">+</span><span class="s4">0.1393</span><span class="s1">*</span><span class="s4">1j</span><span class="s2">,</span>
                              <span class="s1">-</span><span class="s4">0.2759</span><span class="s1">+</span><span class="s4">0.7241</span><span class="s1">*</span><span class="s4">1j</span><span class="s2">,</span>
                              <span class="s1">-</span><span class="s4">0.1642</span><span class="s1">-</span><span class="s4">0.1365</span><span class="s1">*</span><span class="s4">1j</span><span class="s1">]])</span>

    <span class="s2">for </span><span class="s1">ind</span><span class="s2">, </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">enumerate(DTYPES):</span>
        <span class="s2">if </span><span class="s1">ind &lt; </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s0"># Use examples from the NAG documentation</span>
            <span class="s1">A = np.array([[</span><span class="s4">1.80e+10</span><span class="s2">, </span><span class="s4">2.88e+10</span><span class="s2">, </span><span class="s4">2.05e+00</span><span class="s2">, </span><span class="s1">-</span><span class="s4">8.90e+09</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">[</span><span class="s4">5.25e+00</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2.95e+00</span><span class="s2">, </span><span class="s1">-</span><span class="s4">9.50e-09</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3.80e+00</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">[</span><span class="s4">1.58e+00</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2.69e+00</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2.90e-10</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.04e+00</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">[-</span><span class="s4">1.11e+00</span><span class="s2">, </span><span class="s1">-</span><span class="s4">6.60e-01</span><span class="s2">, </span><span class="s1">-</span><span class="s4">5.90e-11</span><span class="s2">, </span><span class="s4">8.00e-01</span><span class="s1">]])</span>
            <span class="s1">A = A.astype(dtype)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">A = np.array([[-</span><span class="s4">1.34e+00</span><span class="s2">, </span><span class="s4">0.28e+10</span><span class="s2">, </span><span class="s1">-</span><span class="s4">6.39e+00</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">[-</span><span class="s4">1.70e+00</span><span class="s2">, </span><span class="s4">3.31e+10</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.15e+00</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">[</span><span class="s4">2.41e-10</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.56e+00</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.83e-10</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">A += np.array([[</span><span class="s4">2.55e+00</span><span class="s2">, </span><span class="s4">3.17e+10</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2.20e+00</span><span class="s1">]</span><span class="s2">,</span>
                           <span class="s1">[-</span><span class="s4">1.41e+00</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.15e+10</span><span class="s2">, </span><span class="s4">1.34e+00</span><span class="s1">]</span><span class="s2">,</span>
                           <span class="s1">[</span><span class="s4">0.39e-10</span><span class="s2">, </span><span class="s4">1.47e+00</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.69e-10</span><span class="s1">]])*</span><span class="s4">1j</span>

            <span class="s1">A = A.astype(dtype)</span>

        <span class="s1">geequ = get_lapack_funcs(</span><span class="s3">'geequ'</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">r</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">rowcnd</span><span class="s2">, </span><span class="s1">colcnd</span><span class="s2">, </span><span class="s1">amax</span><span class="s2">, </span><span class="s1">info = geequ(A)</span>

        <span class="s2">if </span><span class="s1">ind &lt; </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s1">assert_allclose(desired_real.astype(dtype)</span><span class="s2">, </span><span class="s1">r[:</span><span class="s2">, None</span><span class="s1">]*A*c</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-4</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">assert_allclose(desired_cplx.astype(dtype)</span><span class="s2">, </span><span class="s1">r[:</span><span class="s2">, None</span><span class="s1">]*A*c</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-4</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_syequb():</span>
    <span class="s1">desired_log2s = np.array([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3</span><span class="s1">])</span>

    <span class="s2">for </span><span class="s1">ind</span><span class="s2">, </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">enumerate(DTYPES):</span>
        <span class="s1">A = np.eye(</span><span class="s4">10</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">alpha = dtype(</span><span class="s4">1. </span><span class="s2">if </span><span class="s1">ind &lt; </span><span class="s4">2 </span><span class="s2">else </span><span class="s4">1.j</span><span class="s1">)</span>
        <span class="s1">d = np.array([alpha * </span><span class="s4">2.</span><span class="s1">**x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">range(-</span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">A += np.rot90(np.diag(d))</span>

        <span class="s1">syequb = get_lapack_funcs(</span><span class="s3">'syequb'</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">s</span><span class="s2">, </span><span class="s1">scond</span><span class="s2">, </span><span class="s1">amax</span><span class="s2">, </span><span class="s1">info = syequb(A)</span>

        <span class="s1">assert_equal(np.log2(s).astype(int)</span><span class="s2">, </span><span class="s1">desired_log2s)</span>


<span class="s1">@pytest.mark.skipif(</span><span class="s2">True,</span>
                    <span class="s1">reason=</span><span class="s3">&quot;Failing on some OpenBLAS version, see gh-12276&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_heequb():</span>
    <span class="s0"># zheequb has a bug for versions =&lt; LAPACK 3.9.0</span>
    <span class="s0"># See Reference-LAPACK gh-61 and gh-408</span>
    <span class="s0"># Hence the zheequb test is customized accordingly to avoid</span>
    <span class="s0"># work scaling.</span>
    <span class="s1">A = np.diag([</span><span class="s4">2</span><span class="s1">]*</span><span class="s4">5 </span><span class="s1">+ [</span><span class="s4">1002</span><span class="s1">]*</span><span class="s4">5</span><span class="s1">) + np.diag(np.ones(</span><span class="s4">9</span><span class="s1">)</span><span class="s2">, </span><span class="s1">k=</span><span class="s4">1</span><span class="s1">)*</span><span class="s4">1j</span>
    <span class="s1">s</span><span class="s2">, </span><span class="s1">scond</span><span class="s2">, </span><span class="s1">amax</span><span class="s2">, </span><span class="s1">info = lapack.zheequb(A)</span>
    <span class="s1">assert_equal(info</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">assert_allclose(np.log2(s)</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.</span><span class="s1">]*</span><span class="s4">2 </span><span class="s1">+ [</span><span class="s4">0.</span><span class="s1">] + [-</span><span class="s4">4</span><span class="s1">]*</span><span class="s4">5</span><span class="s1">)</span>

    <span class="s1">A = np.diag(</span><span class="s4">2</span><span class="s1">**np.abs(np.arange(-</span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s1">)) + </span><span class="s4">0j</span><span class="s1">)</span>
    <span class="s1">A[</span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s1">] = </span><span class="s4">1024</span>
    <span class="s1">A[</span><span class="s4">5</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] = </span><span class="s4">16j</span>
    <span class="s1">s</span><span class="s2">, </span><span class="s1">scond</span><span class="s2">, </span><span class="s1">amax</span><span class="s2">, </span><span class="s1">info = lapack.cheequb(A.astype(np.complex64)</span><span class="s2">, </span><span class="s1">lower=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(info</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">assert_allclose(np.log2(s)</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">5</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">test_getc2_gesc2():</span>
    <span class="s1">np.random.seed(</span><span class="s4">42</span><span class="s1">)</span>
    <span class="s1">n = </span><span class="s4">10</span>
    <span class="s1">desired_real = np.random.rand(n)</span>
    <span class="s1">desired_cplx = np.random.rand(n) + np.random.rand(n)*</span><span class="s4">1j</span>

    <span class="s2">for </span><span class="s1">ind</span><span class="s2">, </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">enumerate(DTYPES):</span>
        <span class="s2">if </span><span class="s1">ind &lt; </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s1">A = np.random.rand(n</span><span class="s2">, </span><span class="s1">n)</span>
            <span class="s1">A = A.astype(dtype)</span>
            <span class="s1">b = A @ desired_real</span>
            <span class="s1">b = b.astype(dtype)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">A = np.random.rand(n</span><span class="s2">, </span><span class="s1">n) + np.random.rand(n</span><span class="s2">, </span><span class="s1">n)*</span><span class="s4">1j</span>
            <span class="s1">A = A.astype(dtype)</span>
            <span class="s1">b = A @ desired_cplx</span>
            <span class="s1">b = b.astype(dtype)</span>

        <span class="s1">getc2 = get_lapack_funcs(</span><span class="s3">'getc2'</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">gesc2 = get_lapack_funcs(</span><span class="s3">'gesc2'</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">lu</span><span class="s2">, </span><span class="s1">ipiv</span><span class="s2">, </span><span class="s1">jpiv</span><span class="s2">, </span><span class="s1">info = getc2(A</span><span class="s2">, </span><span class="s1">overwrite_a=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">scale = gesc2(lu</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">ipiv</span><span class="s2">, </span><span class="s1">jpiv</span><span class="s2">, </span><span class="s1">overwrite_rhs=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">ind &lt; </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s1">assert_array_almost_equal(desired_real.astype(dtype)</span><span class="s2">,</span>
                                      <span class="s1">x/scale</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">4</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">assert_array_almost_equal(desired_cplx.astype(dtype)</span><span class="s2">,</span>
                                      <span class="s1">x/scale</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">4</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'size'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">6</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'dtype'</span><span class="s2">, </span><span class="s1">REAL_DTYPES)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'joba'</span><span class="s2">, </span><span class="s1">range(</span><span class="s4">6</span><span class="s1">))  </span><span class="s0"># 'C', 'E', 'F', 'G', 'A', 'R'</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'jobu'</span><span class="s2">, </span><span class="s1">range(</span><span class="s4">4</span><span class="s1">))  </span><span class="s0"># 'U', 'F', 'W', 'N'</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'jobv'</span><span class="s2">, </span><span class="s1">range(</span><span class="s4">4</span><span class="s1">))  </span><span class="s0"># 'V', 'J', 'W', 'N'</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'jobr'</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'jobp'</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_gejsv_general(size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">joba</span><span class="s2">, </span><span class="s1">jobu</span><span class="s2">, </span><span class="s1">jobv</span><span class="s2">, </span><span class="s1">jobr</span><span class="s2">, </span><span class="s1">jobp</span><span class="s2">, </span><span class="s1">jobt=</span><span class="s4">0</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot;Test the lapack routine ?gejsv. 
 
    This function tests that a singular value decomposition can be performed 
    on the random M-by-N matrix A. The test performs the SVD using ?gejsv 
    then performs the following checks: 
 
    * ?gejsv exist successfully (info == 0) 
    * The returned singular values are correct 
    * `A` can be reconstructed from `u`, `SIGMA`, `v` 
    * Ensure that u.T @ u is the identity matrix 
    * Ensure that v.T @ v is the identity matrix 
    * The reported matrix rank 
    * The reported number of singular values 
    * If denormalized floats are required 
 
    Notes 
    ----- 
    joba specifies several choices effecting the calculation's accuracy 
    Although all arguments are tested, the tests only check that the correct 
    solution is returned - NOT that the prescribed actions are performed 
    internally. 
 
    jobt is, as of v3.9.0, still experimental and removed to cut down number of 
    test cases. However keyword itself is tested externally. 
    &quot;&quot;&quot;</span>
    <span class="s1">seed(</span><span class="s4">42</span><span class="s1">)</span>

    <span class="s0"># Define some constants for later use:</span>
    <span class="s1">m</span><span class="s2">, </span><span class="s1">n = size</span>
    <span class="s1">atol = </span><span class="s4">100 </span><span class="s1">* np.finfo(dtype).eps</span>
    <span class="s1">A = generate_random_dtype_array(size</span><span class="s2">, </span><span class="s1">dtype)</span>
    <span class="s1">gejsv = get_lapack_funcs(</span><span class="s3">'gejsv'</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

    <span class="s0"># Set up checks for invalid job? combinations</span>
    <span class="s0"># if an invalid combination occurs we set the appropriate</span>
    <span class="s0"># exit status.</span>
    <span class="s1">lsvec = jobu &lt; </span><span class="s4">2  </span><span class="s0"># Calculate left singular vectors</span>
    <span class="s1">rsvec = jobv &lt; </span><span class="s4">2  </span><span class="s0"># Calculate right singular vectors</span>
    <span class="s1">l2tran = (jobt == </span><span class="s4">1</span><span class="s1">) </span><span class="s2">and </span><span class="s1">(m == n)</span>
    <span class="s1">is_complex = np.iscomplexobj(A)</span>

    <span class="s1">invalid_real_jobv = (jobv == </span><span class="s4">1</span><span class="s1">) </span><span class="s2">and </span><span class="s1">(</span><span class="s2">not </span><span class="s1">lsvec) </span><span class="s2">and </span><span class="s1">(</span><span class="s2">not </span><span class="s1">is_complex)</span>
    <span class="s1">invalid_cplx_jobu = (jobu == </span><span class="s4">2</span><span class="s1">) </span><span class="s2">and not </span><span class="s1">(rsvec </span><span class="s2">and </span><span class="s1">l2tran) </span><span class="s2">and </span><span class="s1">is_complex</span>
    <span class="s1">invalid_cplx_jobv = (jobv == </span><span class="s4">2</span><span class="s1">) </span><span class="s2">and not </span><span class="s1">(lsvec </span><span class="s2">and </span><span class="s1">l2tran) </span><span class="s2">and </span><span class="s1">is_complex</span>

    <span class="s0"># Set the exit status to the expected value.</span>
    <span class="s0"># Here we only check for invalid combinations, not individual</span>
    <span class="s0"># parameters.</span>
    <span class="s2">if </span><span class="s1">invalid_cplx_jobu:</span>
        <span class="s1">exit_status = -</span><span class="s4">2</span>
    <span class="s2">elif </span><span class="s1">invalid_real_jobv </span><span class="s2">or </span><span class="s1">invalid_cplx_jobv:</span>
        <span class="s1">exit_status = -</span><span class="s4">3</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">exit_status = </span><span class="s4">0</span>

    <span class="s2">if </span><span class="s1">(jobu &gt; </span><span class="s4">1</span><span class="s1">) </span><span class="s2">and </span><span class="s1">(jobv == </span><span class="s4">1</span><span class="s1">):</span>
        <span class="s1">assert_raises(Exception</span><span class="s2">, </span><span class="s1">gejsv</span><span class="s2">, </span><span class="s1">A</span><span class="s2">, </span><span class="s1">joba</span><span class="s2">, </span><span class="s1">jobu</span><span class="s2">, </span><span class="s1">jobv</span><span class="s2">, </span><span class="s1">jobr</span><span class="s2">, </span><span class="s1">jobt</span><span class="s2">, </span><span class="s1">jobp)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">sva</span><span class="s2">, </span><span class="s1">u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">work</span><span class="s2">, </span><span class="s1">iwork</span><span class="s2">, </span><span class="s1">info = gejsv(A</span><span class="s2">,</span>
                                             <span class="s1">joba=joba</span><span class="s2">,</span>
                                             <span class="s1">jobu=jobu</span><span class="s2">,</span>
                                             <span class="s1">jobv=jobv</span><span class="s2">,</span>
                                             <span class="s1">jobr=jobr</span><span class="s2">,</span>
                                             <span class="s1">jobt=jobt</span><span class="s2">,</span>
                                             <span class="s1">jobp=jobp)</span>

        <span class="s0"># Check that ?gejsv exited successfully/as expected</span>
        <span class="s1">assert_equal(info</span><span class="s2">, </span><span class="s1">exit_status)</span>

        <span class="s0"># If exit_status is non-zero the combination of jobs is invalid.</span>
        <span class="s0"># We test this above but no calculations are performed.</span>
        <span class="s2">if not </span><span class="s1">exit_status:</span>

            <span class="s0"># Check the returned singular values</span>
            <span class="s1">sigma = (work[</span><span class="s4">0</span><span class="s1">] / work[</span><span class="s4">1</span><span class="s1">]) * sva[:n]</span>
            <span class="s1">assert_allclose(sigma</span><span class="s2">, </span><span class="s1">svd(A</span><span class="s2">, </span><span class="s1">compute_uv=</span><span class="s2">False</span><span class="s1">)</span><span class="s2">, </span><span class="s1">atol=atol)</span>

            <span class="s2">if </span><span class="s1">jobu == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s0"># If JOBU = 'F', then u contains the M-by-M matrix of</span>
                <span class="s0"># the left singular vectors, including an ONB of the orthogonal</span>
                <span class="s0"># complement of the Range(A)</span>
                <span class="s0"># However, to recalculate A we are concerned about the</span>
                <span class="s0"># first n singular values and so can ignore the latter.</span>
                <span class="s0"># TODO: Add a test for ONB?</span>
                <span class="s1">u = u[:</span><span class="s2">, </span><span class="s1">:n]</span>

            <span class="s2">if </span><span class="s1">lsvec </span><span class="s2">and </span><span class="s1">rsvec:</span>
                <span class="s1">assert_allclose(u @ np.diag(sigma) @ v.conj().T</span><span class="s2">, </span><span class="s1">A</span><span class="s2">, </span><span class="s1">atol=atol)</span>
            <span class="s2">if </span><span class="s1">lsvec:</span>
                <span class="s1">assert_allclose(u.conj().T @ u</span><span class="s2">, </span><span class="s1">np.identity(n)</span><span class="s2">, </span><span class="s1">atol=atol)</span>
            <span class="s2">if </span><span class="s1">rsvec:</span>
                <span class="s1">assert_allclose(v.conj().T @ v</span><span class="s2">, </span><span class="s1">np.identity(n)</span><span class="s2">, </span><span class="s1">atol=atol)</span>

            <span class="s1">assert_equal(iwork[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.linalg.matrix_rank(A))</span>
            <span class="s1">assert_equal(iwork[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.count_nonzero(sigma))</span>
            <span class="s0"># iwork[2] is non-zero if requested accuracy is not warranted for</span>
            <span class="s0"># the data. This should never occur for these tests.</span>
            <span class="s1">assert_equal(iwork[</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'dtype'</span><span class="s2">, </span><span class="s1">REAL_DTYPES)</span>
<span class="s2">def </span><span class="s1">test_gejsv_edge_arguments(dtype):</span>
    <span class="s5">&quot;&quot;&quot;Test edge arguments return expected status&quot;&quot;&quot;</span>
    <span class="s1">gejsv = get_lapack_funcs(</span><span class="s3">'gejsv'</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

    <span class="s0"># scalar A</span>
    <span class="s1">sva</span><span class="s2">, </span><span class="s1">u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">work</span><span class="s2">, </span><span class="s1">iwork</span><span class="s2">, </span><span class="s1">info = gejsv(</span><span class="s4">1.</span><span class="s1">)</span>
    <span class="s1">assert_equal(info</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">assert_equal(u.shape</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>
    <span class="s1">assert_equal(v.shape</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>
    <span class="s1">assert_equal(sva</span><span class="s2">, </span><span class="s1">np.array([</span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype))</span>

    <span class="s0"># 1d A</span>
    <span class="s1">A = np.ones((</span><span class="s4">1</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">sva</span><span class="s2">, </span><span class="s1">u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">work</span><span class="s2">, </span><span class="s1">iwork</span><span class="s2">, </span><span class="s1">info = gejsv(A)</span>
    <span class="s1">assert_equal(info</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">assert_equal(u.shape</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>
    <span class="s1">assert_equal(v.shape</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>
    <span class="s1">assert_equal(sva</span><span class="s2">, </span><span class="s1">np.array([</span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype))</span>

    <span class="s0"># 2d empty A</span>
    <span class="s1">A = np.ones((</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">sva</span><span class="s2">, </span><span class="s1">u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">work</span><span class="s2">, </span><span class="s1">iwork</span><span class="s2">, </span><span class="s1">info = gejsv(A)</span>
    <span class="s1">assert_equal(info</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">assert_equal(u.shape</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>
    <span class="s1">assert_equal(v.shape</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>
    <span class="s1">assert_equal(sva</span><span class="s2">, </span><span class="s1">np.array([]</span><span class="s2">, </span><span class="s1">dtype=dtype))</span>

    <span class="s0"># make sure &quot;overwrite_a&quot; is respected - user reported in gh-13191</span>
    <span class="s1">A = np.sin(np.arange(</span><span class="s4">100</span><span class="s1">).reshape(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)).astype(dtype)</span>
    <span class="s1">A = np.asfortranarray(A + A.T)  </span><span class="s0"># make it symmetric and column major</span>
    <span class="s1">Ac = A.copy(</span><span class="s3">'A'</span><span class="s1">)</span>
    <span class="s1">_ = gejsv(A)</span>
    <span class="s1">assert_allclose(A</span><span class="s2">, </span><span class="s1">Ac)</span>


<span class="s1">@pytest.mark.parametrize((</span><span class="s3">'kwargs'</span><span class="s1">)</span><span class="s2">,</span>
                         <span class="s1">({</span><span class="s3">'joba'</span><span class="s1">: </span><span class="s4">9</span><span class="s1">}</span><span class="s2">,</span>
                          <span class="s1">{</span><span class="s3">'jobu'</span><span class="s1">: </span><span class="s4">9</span><span class="s1">}</span><span class="s2">,</span>
                          <span class="s1">{</span><span class="s3">'jobv'</span><span class="s1">: </span><span class="s4">9</span><span class="s1">}</span><span class="s2">,</span>
                          <span class="s1">{</span><span class="s3">'jobr'</span><span class="s1">: </span><span class="s4">9</span><span class="s1">}</span><span class="s2">,</span>
                          <span class="s1">{</span><span class="s3">'jobt'</span><span class="s1">: </span><span class="s4">9</span><span class="s1">}</span><span class="s2">,</span>
                          <span class="s1">{</span><span class="s3">'jobp'</span><span class="s1">: </span><span class="s4">9</span><span class="s1">})</span>
                         <span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_gejsv_invalid_job_arguments(kwargs):</span>
    <span class="s5">&quot;&quot;&quot;Test invalid job arguments raise an Exception&quot;&quot;&quot;</span>
    <span class="s1">A = np.ones((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=float)</span>
    <span class="s1">gejsv = get_lapack_funcs(</span><span class="s3">'gejsv'</span><span class="s2">, </span><span class="s1">dtype=float)</span>
    <span class="s1">assert_raises(Exception</span><span class="s2">, </span><span class="s1">gejsv</span><span class="s2">, </span><span class="s1">A</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;A,sva_expect,u_expect,v_expect&quot;</span><span class="s2">,</span>
                         <span class="s1">[(np.array([[</span><span class="s4">2.27</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.54</span><span class="s2">, </span><span class="s4">1.15</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.94</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[</span><span class="s4">0.28</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.67</span><span class="s2">, </span><span class="s4">0.94</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.78</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[-</span><span class="s4">0.48</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3.09</span><span class="s2">, </span><span class="s4">0.99</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.21</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[</span><span class="s4">1.07</span><span class="s2">, </span><span class="s4">1.22</span><span class="s2">, </span><span class="s4">0.79</span><span class="s2">, </span><span class="s4">0.63</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[-</span><span class="s4">2.35</span><span class="s2">, </span><span class="s4">2.93</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.45</span><span class="s2">, </span><span class="s4">2.30</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[</span><span class="s4">0.62</span><span class="s2">, </span><span class="s1">-</span><span class="s4">7.39</span><span class="s2">, </span><span class="s4">1.03</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2.57</span><span class="s1">]])</span><span class="s2">,</span>
                           <span class="s1">np.array([</span><span class="s4">9.9966</span><span class="s2">, </span><span class="s4">3.6831</span><span class="s2">, </span><span class="s4">1.3569</span><span class="s2">, </span><span class="s4">0.5000</span><span class="s1">])</span><span class="s2">,</span>
                           <span class="s1">np.array([[</span><span class="s4">0.2774</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.6003</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.1277</span><span class="s2">, </span><span class="s4">0.1323</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[</span><span class="s4">0.2020</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.0301</span><span class="s2">, </span><span class="s4">0.2805</span><span class="s2">, </span><span class="s4">0.7034</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[</span><span class="s4">0.2918</span><span class="s2">, </span><span class="s4">0.3348</span><span class="s2">, </span><span class="s4">0.6453</span><span class="s2">, </span><span class="s4">0.1906</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[-</span><span class="s4">0.0938</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.3699</span><span class="s2">, </span><span class="s4">0.6781</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.5399</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[-</span><span class="s4">0.4213</span><span class="s2">, </span><span class="s4">0.5266</span><span class="s2">, </span><span class="s4">0.0413</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.0575</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[</span><span class="s4">0.7816</span><span class="s2">, </span><span class="s4">0.3353</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.1645</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.3957</span><span class="s1">]])</span><span class="s2">,</span>
                           <span class="s1">np.array([[</span><span class="s4">0.1921</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.8030</span><span class="s2">, </span><span class="s4">0.0041</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.5642</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[-</span><span class="s4">0.8794</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.3926</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.0752</span><span class="s2">, </span><span class="s4">0.2587</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[</span><span class="s4">0.2140</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.2980</span><span class="s2">, </span><span class="s4">0.7827</span><span class="s2">, </span><span class="s4">0.5027</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[-</span><span class="s4">0.3795</span><span class="s2">, </span><span class="s4">0.3351</span><span class="s2">, </span><span class="s4">0.6178</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.6017</span><span class="s1">]]))])</span>
<span class="s2">def </span><span class="s1">test_gejsv_NAG(A</span><span class="s2">, </span><span class="s1">sva_expect</span><span class="s2">, </span><span class="s1">u_expect</span><span class="s2">, </span><span class="s1">v_expect):</span>
    <span class="s5">&quot;&quot;&quot; 
    This test implements the example found in the NAG manual, f08khf. 
    An example was not found for the complex case. 
    &quot;&quot;&quot;</span>
    <span class="s0"># NAG manual provides accuracy up to 4 decimals</span>
    <span class="s1">atol = </span><span class="s4">1e-4</span>
    <span class="s1">gejsv = get_lapack_funcs(</span><span class="s3">'gejsv'</span><span class="s2">, </span><span class="s1">dtype=A.dtype)</span>

    <span class="s1">sva</span><span class="s2">, </span><span class="s1">u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">work</span><span class="s2">, </span><span class="s1">iwork</span><span class="s2">, </span><span class="s1">info = gejsv(A)</span>

    <span class="s1">assert_allclose(sva_expect</span><span class="s2">, </span><span class="s1">sva</span><span class="s2">, </span><span class="s1">atol=atol)</span>
    <span class="s1">assert_allclose(u_expect</span><span class="s2">, </span><span class="s1">u</span><span class="s2">, </span><span class="s1">atol=atol)</span>
    <span class="s1">assert_allclose(v_expect</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">atol=atol)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype&quot;</span><span class="s2">, </span><span class="s1">DTYPES)</span>
<span class="s2">def </span><span class="s1">test_gttrf_gttrs(dtype):</span>
    <span class="s0"># The test uses ?gttrf and ?gttrs to solve a random system for each dtype,</span>
    <span class="s0"># tests that the output of ?gttrf define LU matricies, that input</span>
    <span class="s0"># parameters are unmodified, transposal options function correctly, that</span>
    <span class="s0"># incompatible matrix shapes raise an error, and singular matrices return</span>
    <span class="s0"># non zero info.</span>

    <span class="s1">seed(</span><span class="s4">42</span><span class="s1">)</span>
    <span class="s1">n = </span><span class="s4">10</span>
    <span class="s1">atol = </span><span class="s4">100 </span><span class="s1">* np.finfo(dtype).eps</span>

    <span class="s0"># create the matrix in accordance with the data type</span>
    <span class="s1">du = generate_random_dtype_array((n-</span><span class="s4">1</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">d = generate_random_dtype_array((n</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">dl = generate_random_dtype_array((n-</span><span class="s4">1</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

    <span class="s1">diag_cpy = [dl.copy()</span><span class="s2">, </span><span class="s1">d.copy()</span><span class="s2">, </span><span class="s1">du.copy()]</span>

    <span class="s1">A = np.diag(d) + np.diag(dl</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">) + np.diag(du</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">x = np.random.rand(n)</span>
    <span class="s1">b = A @ x</span>

    <span class="s1">gttrf</span><span class="s2">, </span><span class="s1">gttrs = get_lapack_funcs((</span><span class="s3">'gttrf'</span><span class="s2">, </span><span class="s3">'gttrs'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

    <span class="s1">_dl</span><span class="s2">, </span><span class="s1">_d</span><span class="s2">, </span><span class="s1">_du</span><span class="s2">, </span><span class="s1">du2</span><span class="s2">, </span><span class="s1">ipiv</span><span class="s2">, </span><span class="s1">info = gttrf(dl</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">du)</span>
    <span class="s0"># test to assure that the inputs of ?gttrf are unmodified</span>
    <span class="s1">assert_array_equal(dl</span><span class="s2">, </span><span class="s1">diag_cpy[</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(d</span><span class="s2">, </span><span class="s1">diag_cpy[</span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(du</span><span class="s2">, </span><span class="s1">diag_cpy[</span><span class="s4">2</span><span class="s1">])</span>

    <span class="s0"># generate L and U factors from ?gttrf return values</span>
    <span class="s0"># L/U are lower/upper triangular by construction (initially and at end)</span>
    <span class="s1">U = np.diag(_d</span><span class="s2">, </span><span class="s4">0</span><span class="s1">) + np.diag(_du</span><span class="s2">, </span><span class="s4">1</span><span class="s1">) + np.diag(du2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">L = np.eye(n</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">m </span><span class="s2">in </span><span class="s1">enumerate(_dl):</span>
        <span class="s0"># L is given in a factored form.</span>
        <span class="s0"># See</span>
        <span class="s0"># www.hpcavf.uclan.ac.uk/softwaredoc/sgi_scsl_html/sgi_html/ch03.html</span>
        <span class="s1">piv = ipiv[i] - </span><span class="s4">1</span>
        <span class="s0"># right multiply by permutation matrix</span>
        <span class="s1">L[:</span><span class="s2">, </span><span class="s1">[i</span><span class="s2">, </span><span class="s1">piv]] = L[:</span><span class="s2">, </span><span class="s1">[piv</span><span class="s2">, </span><span class="s1">i]]</span>
        <span class="s0"># right multiply by Li, rank-one modification of identity</span>
        <span class="s1">L[:</span><span class="s2">, </span><span class="s1">i] += L[:</span><span class="s2">, </span><span class="s1">i+</span><span class="s4">1</span><span class="s1">]*m</span>

    <span class="s0"># one last permutation</span>
    <span class="s1">i</span><span class="s2">, </span><span class="s1">piv = -</span><span class="s4">1</span><span class="s2">, </span><span class="s1">ipiv[-</span><span class="s4">1</span><span class="s1">] - </span><span class="s4">1</span>
    <span class="s0"># right multiply by final permutation matrix</span>
    <span class="s1">L[:</span><span class="s2">, </span><span class="s1">[i</span><span class="s2">, </span><span class="s1">piv]] = L[:</span><span class="s2">, </span><span class="s1">[piv</span><span class="s2">, </span><span class="s1">i]]</span>

    <span class="s0"># check that the outputs of ?gttrf define an LU decomposition of A</span>
    <span class="s1">assert_allclose(A</span><span class="s2">, </span><span class="s1">L @ U</span><span class="s2">, </span><span class="s1">atol=atol)</span>

    <span class="s1">b_cpy = b.copy()</span>
    <span class="s1">x_gttrs</span><span class="s2">, </span><span class="s1">info = gttrs(_dl</span><span class="s2">, </span><span class="s1">_d</span><span class="s2">, </span><span class="s1">_du</span><span class="s2">, </span><span class="s1">du2</span><span class="s2">, </span><span class="s1">ipiv</span><span class="s2">, </span><span class="s1">b)</span>
    <span class="s0"># test that the inputs of ?gttrs are unmodified</span>
    <span class="s1">assert_array_equal(b</span><span class="s2">, </span><span class="s1">b_cpy)</span>
    <span class="s0"># test that the result of ?gttrs matches the expected input</span>
    <span class="s1">assert_allclose(x</span><span class="s2">, </span><span class="s1">x_gttrs</span><span class="s2">, </span><span class="s1">atol=atol)</span>

    <span class="s0"># test that ?gttrf and ?gttrs work with transposal options</span>
    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">REAL_DTYPES:</span>
        <span class="s1">trans = </span><span class="s3">&quot;T&quot;</span>
        <span class="s1">b_trans = A.T @ x</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">trans = </span><span class="s3">&quot;C&quot;</span>
        <span class="s1">b_trans = A.conj().T @ x</span>

    <span class="s1">x_gttrs</span><span class="s2">, </span><span class="s1">info = gttrs(_dl</span><span class="s2">, </span><span class="s1">_d</span><span class="s2">, </span><span class="s1">_du</span><span class="s2">, </span><span class="s1">du2</span><span class="s2">, </span><span class="s1">ipiv</span><span class="s2">, </span><span class="s1">b_trans</span><span class="s2">, </span><span class="s1">trans=trans)</span>
    <span class="s1">assert_allclose(x</span><span class="s2">, </span><span class="s1">x_gttrs</span><span class="s2">, </span><span class="s1">atol=atol)</span>

    <span class="s0"># test that ValueError is raised with incompatible matrix shapes</span>
    <span class="s2">with </span><span class="s1">assert_raises(ValueError):</span>
        <span class="s1">gttrf(dl[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">du)</span>
    <span class="s2">with </span><span class="s1">assert_raises(ValueError):</span>
        <span class="s1">gttrf(dl</span><span class="s2">, </span><span class="s1">d[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">du)</span>
    <span class="s2">with </span><span class="s1">assert_raises(ValueError):</span>
        <span class="s1">gttrf(dl</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">du[:-</span><span class="s4">1</span><span class="s1">])</span>

    <span class="s0"># test that matrix of size n=2 raises exception</span>
    <span class="s2">with </span><span class="s1">assert_raises(Exception):</span>
        <span class="s1">gttrf(dl[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">d[:</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">du[</span><span class="s4">0</span><span class="s1">])</span>

    <span class="s0"># test that singular (row of all zeroes) matrix fails via info</span>
    <span class="s1">du[</span><span class="s4">0</span><span class="s1">] = </span><span class="s4">0</span>
    <span class="s1">d[</span><span class="s4">0</span><span class="s1">] = </span><span class="s4">0</span>
    <span class="s1">__dl</span><span class="s2">, </span><span class="s1">__d</span><span class="s2">, </span><span class="s1">__du</span><span class="s2">, </span><span class="s1">_du2</span><span class="s2">, </span><span class="s1">_ipiv</span><span class="s2">, </span><span class="s1">_info = gttrf(dl</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">du)</span>
    <span class="s1">np.testing.assert_(__d[info - </span><span class="s4">1</span><span class="s1">] == </span><span class="s4">0</span><span class="s2">,</span>
                       <span class="s3">&quot;?gttrf: _d[info-1] is {}, not the illegal value :0.&quot;</span>
                       <span class="s1">.format(__d[info - </span><span class="s4">1</span><span class="s1">]))</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;du, d, dl, du_exp, d_exp, du2_exp, ipiv_exp, b, x&quot;</span><span class="s2">,</span>
                         <span class="s1">[(np.array([</span><span class="s4">2.1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">1.9</span><span class="s2">, </span><span class="s4">8.0</span><span class="s1">])</span><span class="s2">,</span>
                             <span class="s1">np.array([</span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">2.3</span><span class="s2">, </span><span class="s1">-</span><span class="s4">5.0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">.9</span><span class="s2">, </span><span class="s4">7.1</span><span class="s1">])</span><span class="s2">,</span>
                             <span class="s1">np.array([</span><span class="s4">3.4</span><span class="s2">, </span><span class="s4">3.6</span><span class="s2">, </span><span class="s4">7.0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">6.0</span><span class="s1">])</span><span class="s2">,</span>
                             <span class="s1">np.array([</span><span class="s4">2.3</span><span class="s2">, </span><span class="s1">-</span><span class="s4">5</span><span class="s2">, </span><span class="s1">-</span><span class="s4">.9</span><span class="s2">, </span><span class="s4">7.1</span><span class="s1">])</span><span class="s2">,</span>
                             <span class="s1">np.array([</span><span class="s4">3.4</span><span class="s2">, </span><span class="s4">3.6</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s1">-</span><span class="s4">6</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.015373</span><span class="s1">])</span><span class="s2">,</span>
                             <span class="s1">np.array([-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1.9</span><span class="s2">, </span><span class="s4">8</span><span class="s1">])</span><span class="s2">,</span>
                             <span class="s1">np.array([</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s1">])</span><span class="s2">,</span>
                             <span class="s1">np.array([[</span><span class="s4">2.7</span><span class="s2">, </span><span class="s4">6.6</span><span class="s1">]</span><span class="s2">,</span>
                                       <span class="s1">[-</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">10.8</span><span class="s1">]</span><span class="s2">,</span>
                                       <span class="s1">[</span><span class="s4">2.6</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3.2</span><span class="s1">]</span><span class="s2">,</span>
                                       <span class="s1">[</span><span class="s4">0.6</span><span class="s2">, </span><span class="s1">-</span><span class="s4">11.2</span><span class="s1">]</span><span class="s2">,</span>
                                       <span class="s1">[</span><span class="s4">2.7</span><span class="s2">, </span><span class="s4">19.1</span><span class="s1">]</span>
                                       <span class="s1">])</span><span class="s2">,</span>
                             <span class="s1">np.array([[-</span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span><span class="s2">,</span>
                                       <span class="s1">[</span><span class="s4">7</span><span class="s2">, </span><span class="s1">-</span><span class="s4">4</span><span class="s1">]</span><span class="s2">,</span>
                                       <span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3</span><span class="s1">]</span><span class="s2">,</span>
                                       <span class="s1">[-</span><span class="s4">4</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
                                       <span class="s1">[-</span><span class="s4">3</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]]))</span><span class="s2">,</span>
                          <span class="s1">(</span>
                             <span class="s1">np.array([</span><span class="s4">2 </span><span class="s1">- </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">1j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">- </span><span class="s4">1j</span><span class="s1">])</span><span class="s2">,</span>
                             <span class="s1">np.array([-</span><span class="s4">1.3 </span><span class="s1">+ </span><span class="s4">1.3j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.3 </span><span class="s1">+ </span><span class="s4">1.3j</span><span class="s2">,</span>
                                       <span class="s1">-</span><span class="s4">1.3 </span><span class="s1">+ </span><span class="s4">3.3j</span><span class="s2">, </span><span class="s1">- </span><span class="s4">.3 </span><span class="s1">+ </span><span class="s4">4.3j</span><span class="s2">,</span>
                                       <span class="s1">-</span><span class="s4">3.3 </span><span class="s1">+ </span><span class="s4">1.3j</span><span class="s1">])</span><span class="s2">,</span>
                             <span class="s1">np.array([</span><span class="s4">1 </span><span class="s1">- </span><span class="s4">2j</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">- </span><span class="s4">3j</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">1j</span><span class="s1">])</span><span class="s2">,</span>
                             <span class="s0"># du exp</span>
                             <span class="s1">np.array([-</span><span class="s4">1.3 </span><span class="s1">+ </span><span class="s4">1.3j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.3 </span><span class="s1">+ </span><span class="s4">3.3j</span><span class="s2">,</span>
                                       <span class="s1">-</span><span class="s4">0.3 </span><span class="s1">+ </span><span class="s4">4.3j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3.3 </span><span class="s1">+ </span><span class="s4">1.3j</span><span class="s1">])</span><span class="s2">,</span>
                             <span class="s1">np.array([</span><span class="s4">1 </span><span class="s1">- </span><span class="s4">2j</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">- </span><span class="s4">3j</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">1j</span><span class="s2">,</span>
                                       <span class="s1">-</span><span class="s4">1.3399 </span><span class="s1">+ </span><span class="s4">0.2875j</span><span class="s1">])</span><span class="s2">,</span>
                             <span class="s1">np.array([</span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">1j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">- </span><span class="s4">1j</span><span class="s1">])</span><span class="s2">,</span>
                             <span class="s1">np.array([</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s1">])</span><span class="s2">,</span>
                             <span class="s1">np.array([[</span><span class="s4">2.4 </span><span class="s1">- </span><span class="s4">5j</span><span class="s2">, </span><span class="s4">2.7 </span><span class="s1">+ </span><span class="s4">6.9j</span><span class="s1">]</span><span class="s2">,</span>
                                       <span class="s1">[</span><span class="s4">3.4 </span><span class="s1">+ </span><span class="s4">18.2j</span><span class="s2">, </span><span class="s1">- </span><span class="s4">6.9 </span><span class="s1">- </span><span class="s4">5.3j</span><span class="s1">]</span><span class="s2">,</span>
                                       <span class="s1">[-</span><span class="s4">14.7 </span><span class="s1">+ </span><span class="s4">9.7j</span><span class="s2">, </span><span class="s1">- </span><span class="s4">6 </span><span class="s1">- </span><span class="s4">.6j</span><span class="s1">]</span><span class="s2">,</span>
                                       <span class="s1">[</span><span class="s4">31.9 </span><span class="s1">- </span><span class="s4">7.7j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3.9 </span><span class="s1">+ </span><span class="s4">9.3j</span><span class="s1">]</span><span class="s2">,</span>
                                       <span class="s1">[-</span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">1.6j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3 </span><span class="s1">+ </span><span class="s4">12.2j</span><span class="s1">]])</span><span class="s2">,</span>
                             <span class="s1">np.array([[</span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">- </span><span class="s4">1j</span><span class="s1">]</span><span class="s2">,</span>
                                       <span class="s1">[</span><span class="s4">3 </span><span class="s1">- </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">2j</span><span class="s1">]</span><span class="s2">,</span>
                                       <span class="s1">[</span><span class="s4">4 </span><span class="s1">+ </span><span class="s4">5j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">1j</span><span class="s1">]</span><span class="s2">,</span>
                                       <span class="s1">[-</span><span class="s4">1 </span><span class="s1">- </span><span class="s4">2j</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">1j</span><span class="s1">]</span><span class="s2">,</span>
                                       <span class="s1">[</span><span class="s4">1 </span><span class="s1">- </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">- </span><span class="s4">2j</span><span class="s1">]])</span>
                            <span class="s1">)])</span>
<span class="s2">def </span><span class="s1">test_gttrf_gttrs_NAG_f07cdf_f07cef_f07crf_f07csf(du</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">dl</span><span class="s2">, </span><span class="s1">du_exp</span><span class="s2">, </span><span class="s1">d_exp</span><span class="s2">,</span>
                                                     <span class="s1">du2_exp</span><span class="s2">, </span><span class="s1">ipiv_exp</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x):</span>
    <span class="s0"># test to assure that wrapper is consistent with NAG Library Manual Mark 26</span>
    <span class="s0"># example problems: f07cdf and f07cef (real)</span>
    <span class="s0"># examples: f07crf and f07csf (complex)</span>
    <span class="s0"># (Links may expire, so search for &quot;NAG Library Manual Mark 26&quot; online)</span>

    <span class="s1">gttrf</span><span class="s2">, </span><span class="s1">gttrs = get_lapack_funcs((</span><span class="s3">'gttrf'</span><span class="s2">, </span><span class="s3">&quot;gttrs&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(du[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">du[</span><span class="s4">0</span><span class="s1">]))</span>

    <span class="s1">_dl</span><span class="s2">, </span><span class="s1">_d</span><span class="s2">, </span><span class="s1">_du</span><span class="s2">, </span><span class="s1">du2</span><span class="s2">, </span><span class="s1">ipiv</span><span class="s2">, </span><span class="s1">info = gttrf(dl</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">du)</span>
    <span class="s1">assert_allclose(du2</span><span class="s2">, </span><span class="s1">du2_exp)</span>
    <span class="s1">assert_allclose(_du</span><span class="s2">, </span><span class="s1">du_exp)</span>
    <span class="s1">assert_allclose(_d</span><span class="s2">, </span><span class="s1">d_exp</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-4</span><span class="s1">)  </span><span class="s0"># NAG examples provide 4 decimals.</span>
    <span class="s1">assert_allclose(ipiv</span><span class="s2">, </span><span class="s1">ipiv_exp)</span>

    <span class="s1">x_gttrs</span><span class="s2">, </span><span class="s1">info = gttrs(_dl</span><span class="s2">, </span><span class="s1">_d</span><span class="s2">, </span><span class="s1">_du</span><span class="s2">, </span><span class="s1">du2</span><span class="s2">, </span><span class="s1">ipiv</span><span class="s2">, </span><span class="s1">b)</span>

    <span class="s1">assert_allclose(x_gttrs</span><span class="s2">, </span><span class="s1">x)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'dtype'</span><span class="s2">, </span><span class="s1">DTYPES)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'shape'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">7</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">7</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2</span><span class="s1">**</span><span class="s4">18</span><span class="s2">, </span><span class="s4">2</span><span class="s1">**</span><span class="s4">18</span><span class="s1">)])</span>
<span class="s2">def </span><span class="s1">test_geqrfp_lwork(dtype</span><span class="s2">, </span><span class="s1">shape):</span>
    <span class="s1">geqrfp_lwork = get_lapack_funcs((</span><span class="s3">'geqrfp_lwork'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">m</span><span class="s2">, </span><span class="s1">n = shape</span>
    <span class="s1">lwork</span><span class="s2">, </span><span class="s1">info = geqrfp_lwork(m=m</span><span class="s2">, </span><span class="s1">n=n)</span>
    <span class="s1">assert_equal(info</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;ddtype,dtype&quot;</span><span class="s2">,</span>
                         <span class="s1">zip(REAL_DTYPES + REAL_DTYPES</span><span class="s2">, </span><span class="s1">DTYPES))</span>
<span class="s2">def </span><span class="s1">test_pttrf_pttrs(ddtype</span><span class="s2">, </span><span class="s1">dtype):</span>
    <span class="s1">seed(</span><span class="s4">42</span><span class="s1">)</span>
    <span class="s0"># set test tolerance appropriate for dtype</span>
    <span class="s1">atol = </span><span class="s4">100</span><span class="s1">*np.finfo(dtype).eps</span>
    <span class="s0"># n is the length diagonal of A</span>
    <span class="s1">n = </span><span class="s4">10</span>
    <span class="s0"># create diagonals according to size and dtype</span>

    <span class="s0"># diagonal d should always be real.</span>
    <span class="s0"># add 4 to d so it will be dominant for all dtypes</span>
    <span class="s1">d = generate_random_dtype_array((n</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">ddtype) + </span><span class="s4">4</span>
    <span class="s0"># diagonal e may be real or complex.</span>
    <span class="s1">e = generate_random_dtype_array((n-</span><span class="s4">1</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype)</span>

    <span class="s0"># assemble diagonals together into matrix</span>
    <span class="s1">A = np.diag(d) + np.diag(e</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">) + np.diag(np.conj(e)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s0"># store a copy of diagonals to later verify</span>
    <span class="s1">diag_cpy = [d.copy()</span><span class="s2">, </span><span class="s1">e.copy()]</span>

    <span class="s1">pttrf = get_lapack_funcs(</span><span class="s3">'pttrf'</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

    <span class="s1">_d</span><span class="s2">, </span><span class="s1">_e</span><span class="s2">, </span><span class="s1">info = pttrf(d</span><span class="s2">, </span><span class="s1">e)</span>
    <span class="s0"># test to assure that the inputs of ?pttrf are unmodified</span>
    <span class="s1">assert_array_equal(d</span><span class="s2">, </span><span class="s1">diag_cpy[</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(e</span><span class="s2">, </span><span class="s1">diag_cpy[</span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">assert_equal(info</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">err_msg=</span><span class="s3">f&quot;pttrf: info = </span><span class="s2">{</span><span class="s1">info</span><span class="s2">}</span><span class="s3">, should be 0&quot;</span><span class="s1">)</span>

    <span class="s0"># test that the factors from pttrf can be recombined to make A</span>
    <span class="s1">L = np.diag(_e</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">) + np.diag(np.ones(n))</span>
    <span class="s1">D = np.diag(_d)</span>

    <span class="s1">assert_allclose(A</span><span class="s2">, </span><span class="s1">L@D@L.conjugate().T</span><span class="s2">, </span><span class="s1">atol=atol)</span>

    <span class="s0"># generate random solution x</span>
    <span class="s1">x = generate_random_dtype_array((n</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype)</span>
    <span class="s0"># determine accompanying b to get soln x</span>
    <span class="s1">b = A@x</span>

    <span class="s0"># determine _x from pttrs</span>
    <span class="s1">pttrs = get_lapack_funcs(</span><span class="s3">'pttrs'</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">_x</span><span class="s2">, </span><span class="s1">info = pttrs(_d</span><span class="s2">, </span><span class="s1">_e.conj()</span><span class="s2">, </span><span class="s1">b)</span>
    <span class="s1">assert_equal(info</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">err_msg=</span><span class="s3">f&quot;pttrs: info = </span><span class="s2">{</span><span class="s1">info</span><span class="s2">}</span><span class="s3">, should be 0&quot;</span><span class="s1">)</span>

    <span class="s0"># test that _x from pttrs matches the expected x</span>
    <span class="s1">assert_allclose(x</span><span class="s2">, </span><span class="s1">_x</span><span class="s2">, </span><span class="s1">atol=atol)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;ddtype,dtype&quot;</span><span class="s2">,</span>
                         <span class="s1">zip(REAL_DTYPES + REAL_DTYPES</span><span class="s2">, </span><span class="s1">DTYPES))</span>
<span class="s2">def </span><span class="s1">test_pttrf_pttrs_errors_incompatible_shape(ddtype</span><span class="s2">, </span><span class="s1">dtype):</span>
    <span class="s1">n = </span><span class="s4">10</span>
    <span class="s1">pttrf = get_lapack_funcs(</span><span class="s3">'pttrf'</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">d = generate_random_dtype_array((n</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">ddtype) + </span><span class="s4">2</span>
    <span class="s1">e = generate_random_dtype_array((n-</span><span class="s4">1</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype)</span>
    <span class="s0"># test that ValueError is raised with incompatible matrix shapes</span>
    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">pttrf</span><span class="s2">, </span><span class="s1">d[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">e)</span>
    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">pttrf</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">e[:-</span><span class="s4">1</span><span class="s1">])</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;ddtype,dtype&quot;</span><span class="s2">,</span>
                         <span class="s1">zip(REAL_DTYPES + REAL_DTYPES</span><span class="s2">, </span><span class="s1">DTYPES))</span>
<span class="s2">def </span><span class="s1">test_pttrf_pttrs_errors_singular_nonSPD(ddtype</span><span class="s2">, </span><span class="s1">dtype):</span>
    <span class="s1">n = </span><span class="s4">10</span>
    <span class="s1">pttrf = get_lapack_funcs(</span><span class="s3">'pttrf'</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">d = generate_random_dtype_array((n</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">ddtype) + </span><span class="s4">2</span>
    <span class="s1">e = generate_random_dtype_array((n-</span><span class="s4">1</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype)</span>
    <span class="s0"># test that singular (row of all zeroes) matrix fails via info</span>
    <span class="s1">d[</span><span class="s4">0</span><span class="s1">] = </span><span class="s4">0</span>
    <span class="s1">e[</span><span class="s4">0</span><span class="s1">] = </span><span class="s4">0</span>
    <span class="s1">_d</span><span class="s2">, </span><span class="s1">_e</span><span class="s2">, </span><span class="s1">info = pttrf(d</span><span class="s2">, </span><span class="s1">e)</span>
    <span class="s1">assert_equal(_d[info - </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0</span><span class="s2">,</span>
                 <span class="s3">&quot;?pttrf: _d[info-1] is {}, not the illegal value :0.&quot;</span>
                 <span class="s1">.format(_d[info - </span><span class="s4">1</span><span class="s1">]))</span>

    <span class="s0"># test with non-spd matrix</span>
    <span class="s1">d = generate_random_dtype_array((n</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">ddtype)</span>
    <span class="s1">_d</span><span class="s2">, </span><span class="s1">_e</span><span class="s2">, </span><span class="s1">info = pttrf(d</span><span class="s2">, </span><span class="s1">e)</span>
    <span class="s1">assert_(info != </span><span class="s4">0</span><span class="s2">, </span><span class="s3">&quot;?pttrf should fail with non-spd matrix, but didn't&quot;</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize((</span><span class="s3">&quot;d, e, d_expect, e_expect, b, x_expect&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">[</span>
                         <span class="s1">(np.array([</span><span class="s4">4</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">29</span><span class="s2">, </span><span class="s4">25</span><span class="s2">, </span><span class="s4">5</span><span class="s1">])</span><span class="s2">,</span>
                          <span class="s1">np.array([-</span><span class="s4">2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">6</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s4">8</span><span class="s1">])</span><span class="s2">,</span>
                          <span class="s1">np.array([</span><span class="s4">4</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">25</span><span class="s2">, </span><span class="s4">16</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span><span class="s2">,</span>
                          <span class="s1">np.array([-</span><span class="s4">.5</span><span class="s2">, </span><span class="s1">-</span><span class="s4">.6667</span><span class="s2">, </span><span class="s4">.6</span><span class="s2">, </span><span class="s4">.5</span><span class="s1">])</span><span class="s2">,</span>
                          <span class="s1">np.array([[</span><span class="s4">6</span><span class="s2">, </span><span class="s4">10</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">9</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">9</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">14</span><span class="s2">, </span><span class="s4">65</span><span class="s1">]</span><span class="s2">,</span>
                                    <span class="s1">[</span><span class="s4">7</span><span class="s2">, </span><span class="s4">23</span><span class="s1">]])</span><span class="s2">,</span>
                          <span class="s1">np.array([[</span><span class="s4">2.5</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">6</span><span class="s1">]</span><span class="s2">,</span>
                                    <span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s1">-</span><span class="s4">5</span><span class="s1">]])</span>
                          <span class="s1">)</span><span class="s2">, </span><span class="s1">(</span>
                          <span class="s1">np.array([</span><span class="s4">16</span><span class="s2">, </span><span class="s4">41</span><span class="s2">, </span><span class="s4">46</span><span class="s2">, </span><span class="s4">21</span><span class="s1">])</span><span class="s2">,</span>
                          <span class="s1">np.array([</span><span class="s4">16 </span><span class="s1">+ </span><span class="s4">16j</span><span class="s2">, </span><span class="s4">18 </span><span class="s1">- </span><span class="s4">9j</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">- </span><span class="s4">4j</span><span class="s1">])</span><span class="s2">,</span>
                          <span class="s1">np.array([</span><span class="s4">16</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">4</span><span class="s1">])</span><span class="s2">,</span>
                          <span class="s1">np.array([</span><span class="s4">1</span><span class="s1">+</span><span class="s4">1j</span><span class="s2">, </span><span class="s4">2</span><span class="s1">-</span><span class="s4">1j</span><span class="s2">, </span><span class="s4">1</span><span class="s1">-</span><span class="s4">4j</span><span class="s1">])</span><span class="s2">,</span>
                          <span class="s1">np.array([[</span><span class="s4">64</span><span class="s1">+</span><span class="s4">16j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">16</span><span class="s1">-</span><span class="s4">32j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">93</span><span class="s1">+</span><span class="s4">62j</span><span class="s2">, </span><span class="s4">61</span><span class="s1">-</span><span class="s4">66j</span><span class="s1">]</span><span class="s2">,</span>
                                    <span class="s1">[</span><span class="s4">78</span><span class="s1">-</span><span class="s4">80j</span><span class="s2">, </span><span class="s4">71</span><span class="s1">-</span><span class="s4">74j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">14</span><span class="s1">-</span><span class="s4">27j</span><span class="s2">, </span><span class="s4">35</span><span class="s1">+</span><span class="s4">15j</span><span class="s1">]])</span><span class="s2">,</span>
                          <span class="s1">np.array([[</span><span class="s4">2</span><span class="s1">+</span><span class="s4">1j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3</span><span class="s1">-</span><span class="s4">2j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">+</span><span class="s4">1j</span><span class="s2">, </span><span class="s4">1</span><span class="s1">+</span><span class="s4">1j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">-</span><span class="s4">2j</span><span class="s2">, </span><span class="s4">1</span><span class="s1">-</span><span class="s4">2j</span><span class="s1">]</span><span class="s2">,</span>
                                    <span class="s1">[</span><span class="s4">1</span><span class="s1">-</span><span class="s4">1j</span><span class="s2">, </span><span class="s4">2</span><span class="s1">+</span><span class="s4">1j</span><span class="s1">]])</span>
                         <span class="s1">)])</span>
<span class="s2">def </span><span class="s1">test_pttrf_pttrs_NAG(d</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">d_expect</span><span class="s2">, </span><span class="s1">e_expect</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x_expect):</span>
    <span class="s0"># test to assure that wrapper is consistent with NAG Manual Mark 26</span>
    <span class="s0"># example problems: f07jdf and f07jef (real)</span>
    <span class="s0"># examples: f07jrf and f07csf (complex)</span>
    <span class="s0"># NAG examples provide 4 decimals.</span>
    <span class="s0"># (Links expire, so please search for &quot;NAG Library Manual Mark 26&quot; online)</span>

    <span class="s1">atol = </span><span class="s4">1e-4</span>
    <span class="s1">pttrf = get_lapack_funcs(</span><span class="s3">'pttrf'</span><span class="s2">, </span><span class="s1">dtype=e[</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">_d</span><span class="s2">, </span><span class="s1">_e</span><span class="s2">, </span><span class="s1">info = pttrf(d</span><span class="s2">, </span><span class="s1">e)</span>
    <span class="s1">assert_allclose(_d</span><span class="s2">, </span><span class="s1">d_expect</span><span class="s2">, </span><span class="s1">atol=atol)</span>
    <span class="s1">assert_allclose(_e</span><span class="s2">, </span><span class="s1">e_expect</span><span class="s2">, </span><span class="s1">atol=atol)</span>

    <span class="s1">pttrs = get_lapack_funcs(</span><span class="s3">'pttrs'</span><span class="s2">, </span><span class="s1">dtype=e[</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">_x</span><span class="s2">, </span><span class="s1">info = pttrs(_d</span><span class="s2">, </span><span class="s1">_e.conj()</span><span class="s2">, </span><span class="s1">b)</span>
    <span class="s1">assert_allclose(_x</span><span class="s2">, </span><span class="s1">x_expect</span><span class="s2">, </span><span class="s1">atol=atol)</span>

    <span class="s0"># also test option `lower`</span>
    <span class="s2">if </span><span class="s1">e.dtype </span><span class="s2">in </span><span class="s1">COMPLEX_DTYPES:</span>
        <span class="s1">_x</span><span class="s2">, </span><span class="s1">info = pttrs(_d</span><span class="s2">, </span><span class="s1">_e</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">lower=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(_x</span><span class="s2">, </span><span class="s1">x_expect</span><span class="s2">, </span><span class="s1">atol=atol)</span>


<span class="s2">def </span><span class="s1">pteqr_get_d_e_A_z(dtype</span><span class="s2">, </span><span class="s1">realtype</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">compute_z):</span>
    <span class="s0"># used by ?pteqr tests to build parameters</span>
    <span class="s0"># returns tuple of (d, e, A, z)</span>
    <span class="s2">if </span><span class="s1">compute_z == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s0"># build Hermitian A from Q**T * tri * Q = A by creating Q and tri</span>
        <span class="s1">A_eig = generate_random_dtype_array((n</span><span class="s2">, </span><span class="s1">n)</span><span class="s2">, </span><span class="s1">dtype)</span>
        <span class="s1">A_eig = A_eig + np.diag(np.zeros(n) + </span><span class="s4">4</span><span class="s1">*n)</span>
        <span class="s1">A_eig = (A_eig + A_eig.conj().T) / </span><span class="s4">2</span>
        <span class="s0"># obtain right eigenvectors (orthogonal)</span>
        <span class="s1">vr = eigh(A_eig)[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s0"># create tridiagonal matrix</span>
        <span class="s1">d = generate_random_dtype_array((n</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">realtype) + </span><span class="s4">4</span>
        <span class="s1">e = generate_random_dtype_array((n-</span><span class="s4">1</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">realtype)</span>
        <span class="s1">tri = np.diag(d) + np.diag(e</span><span class="s2">, </span><span class="s4">1</span><span class="s1">) + np.diag(e</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s0"># Build A using these factors that sytrd would: (Q**T * tri * Q = A)</span>
        <span class="s1">A = vr @ tri @ vr.conj().T</span>
        <span class="s0"># vr is orthogonal</span>
        <span class="s1">z = vr</span>

    <span class="s2">else</span><span class="s1">:</span>
        <span class="s0"># d and e are always real per lapack docs.</span>
        <span class="s1">d = generate_random_dtype_array((n</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">realtype)</span>
        <span class="s1">e = generate_random_dtype_array((n-</span><span class="s4">1</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">realtype)</span>

        <span class="s0"># make SPD</span>
        <span class="s1">d = d + </span><span class="s4">4</span>
        <span class="s1">A = np.diag(d) + np.diag(e</span><span class="s2">, </span><span class="s4">1</span><span class="s1">) + np.diag(e</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">z = np.diag(d) + np.diag(e</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">) + np.diag(e</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">(d</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">A</span><span class="s2">, </span><span class="s1">z)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype,realtype&quot;</span><span class="s2">,</span>
                         <span class="s1">zip(DTYPES</span><span class="s2">, </span><span class="s1">REAL_DTYPES + REAL_DTYPES))</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;compute_z&quot;</span><span class="s2">, </span><span class="s1">range(</span><span class="s4">3</span><span class="s1">))</span>
<span class="s2">def </span><span class="s1">test_pteqr(dtype</span><span class="s2">, </span><span class="s1">realtype</span><span class="s2">, </span><span class="s1">compute_z):</span>
    <span class="s5">''' 
    Tests the ?pteqr lapack routine for all dtypes and compute_z parameters. 
    It generates random SPD matrix diagonals d and e, and then confirms 
    correct eigenvalues with scipy.linalg.eig. With applicable compute_z=2 it 
    tests that z can reform A. 
    '''</span>
    <span class="s1">seed(</span><span class="s4">42</span><span class="s1">)</span>
    <span class="s1">atol = </span><span class="s4">1000</span><span class="s1">*np.finfo(dtype).eps</span>
    <span class="s1">pteqr = get_lapack_funcs((</span><span class="s3">'pteqr'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

    <span class="s1">n = </span><span class="s4">10</span>

    <span class="s1">d</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">A</span><span class="s2">, </span><span class="s1">z = pteqr_get_d_e_A_z(dtype</span><span class="s2">, </span><span class="s1">realtype</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">compute_z)</span>

    <span class="s1">d_pteqr</span><span class="s2">, </span><span class="s1">e_pteqr</span><span class="s2">, </span><span class="s1">z_pteqr</span><span class="s2">, </span><span class="s1">info = pteqr(d=d</span><span class="s2">, </span><span class="s1">e=e</span><span class="s2">, </span><span class="s1">z=z</span><span class="s2">, </span><span class="s1">compute_z=compute_z)</span>
    <span class="s1">assert_equal(info</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s3">f&quot;info = </span><span class="s2">{</span><span class="s1">info</span><span class="s2">}</span><span class="s3">, should be 0.&quot;</span><span class="s1">)</span>

    <span class="s0"># compare the routine's eigenvalues with scipy.linalg.eig's.</span>
    <span class="s1">assert_allclose(np.sort(eigh(A)[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">, </span><span class="s1">np.sort(d_pteqr)</span><span class="s2">, </span><span class="s1">atol=atol)</span>

    <span class="s2">if </span><span class="s1">compute_z:</span>
        <span class="s0"># verify z_pteqr as orthogonal</span>
        <span class="s1">assert_allclose(z_pteqr @ np.conj(z_pteqr).T</span><span class="s2">, </span><span class="s1">np.identity(n)</span><span class="s2">,</span>
                        <span class="s1">atol=atol)</span>
        <span class="s0"># verify that z_pteqr recombines to A</span>
        <span class="s1">assert_allclose(z_pteqr @ np.diag(d_pteqr) @ np.conj(z_pteqr).T</span><span class="s2">,</span>
                        <span class="s1">A</span><span class="s2">, </span><span class="s1">atol=atol)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype,realtype&quot;</span><span class="s2">,</span>
                         <span class="s1">zip(DTYPES</span><span class="s2">, </span><span class="s1">REAL_DTYPES + REAL_DTYPES))</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;compute_z&quot;</span><span class="s2">, </span><span class="s1">range(</span><span class="s4">3</span><span class="s1">))</span>
<span class="s2">def </span><span class="s1">test_pteqr_error_non_spd(dtype</span><span class="s2">, </span><span class="s1">realtype</span><span class="s2">, </span><span class="s1">compute_z):</span>
    <span class="s1">seed(</span><span class="s4">42</span><span class="s1">)</span>
    <span class="s1">pteqr = get_lapack_funcs((</span><span class="s3">'pteqr'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

    <span class="s1">n = </span><span class="s4">10</span>
    <span class="s1">d</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">A</span><span class="s2">, </span><span class="s1">z = pteqr_get_d_e_A_z(dtype</span><span class="s2">, </span><span class="s1">realtype</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">compute_z)</span>

    <span class="s0"># test with non-spd matrix</span>
    <span class="s1">d_pteqr</span><span class="s2">, </span><span class="s1">e_pteqr</span><span class="s2">, </span><span class="s1">z_pteqr</span><span class="s2">, </span><span class="s1">info = pteqr(d - </span><span class="s4">4</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">z=z</span><span class="s2">, </span><span class="s1">compute_z=compute_z)</span>
    <span class="s2">assert </span><span class="s1">info &gt; </span><span class="s4">0</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype,realtype&quot;</span><span class="s2">,</span>
                         <span class="s1">zip(DTYPES</span><span class="s2">, </span><span class="s1">REAL_DTYPES + REAL_DTYPES))</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;compute_z&quot;</span><span class="s2">, </span><span class="s1">range(</span><span class="s4">3</span><span class="s1">))</span>
<span class="s2">def </span><span class="s1">test_pteqr_raise_error_wrong_shape(dtype</span><span class="s2">, </span><span class="s1">realtype</span><span class="s2">, </span><span class="s1">compute_z):</span>
    <span class="s1">seed(</span><span class="s4">42</span><span class="s1">)</span>
    <span class="s1">pteqr = get_lapack_funcs((</span><span class="s3">'pteqr'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">n = </span><span class="s4">10</span>
    <span class="s1">d</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">A</span><span class="s2">, </span><span class="s1">z = pteqr_get_d_e_A_z(dtype</span><span class="s2">, </span><span class="s1">realtype</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">compute_z)</span>
    <span class="s0"># test with incorrect/incompatible array sizes</span>
    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">pteqr</span><span class="s2">, </span><span class="s1">d[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">z=z</span><span class="s2">, </span><span class="s1">compute_z=compute_z)</span>
    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">pteqr</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">e[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">z=z</span><span class="s2">, </span><span class="s1">compute_z=compute_z)</span>
    <span class="s2">if </span><span class="s1">compute_z:</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">pteqr</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">z=z[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">compute_z=compute_z)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype,realtype&quot;</span><span class="s2">,</span>
                         <span class="s1">zip(DTYPES</span><span class="s2">, </span><span class="s1">REAL_DTYPES + REAL_DTYPES))</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;compute_z&quot;</span><span class="s2">, </span><span class="s1">range(</span><span class="s4">3</span><span class="s1">))</span>
<span class="s2">def </span><span class="s1">test_pteqr_error_singular(dtype</span><span class="s2">, </span><span class="s1">realtype</span><span class="s2">, </span><span class="s1">compute_z):</span>
    <span class="s1">seed(</span><span class="s4">42</span><span class="s1">)</span>
    <span class="s1">pteqr = get_lapack_funcs((</span><span class="s3">'pteqr'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">n = </span><span class="s4">10</span>
    <span class="s1">d</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">A</span><span class="s2">, </span><span class="s1">z = pteqr_get_d_e_A_z(dtype</span><span class="s2">, </span><span class="s1">realtype</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">compute_z)</span>
    <span class="s0"># test with singular matrix</span>
    <span class="s1">d[</span><span class="s4">0</span><span class="s1">] = </span><span class="s4">0</span>
    <span class="s1">e[</span><span class="s4">0</span><span class="s1">] = </span><span class="s4">0</span>
    <span class="s1">d_pteqr</span><span class="s2">, </span><span class="s1">e_pteqr</span><span class="s2">, </span><span class="s1">z_pteqr</span><span class="s2">, </span><span class="s1">info = pteqr(d</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">z=z</span><span class="s2">, </span><span class="s1">compute_z=compute_z)</span>
    <span class="s2">assert </span><span class="s1">info &gt; </span><span class="s4">0</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;compute_z,d,e,d_expect,z_expect&quot;</span><span class="s2">,</span>
                         <span class="s1">[(</span><span class="s4">2</span><span class="s2">,  </span><span class="s0"># &quot;I&quot;</span>
                           <span class="s1">np.array([</span><span class="s4">4.16</span><span class="s2">, </span><span class="s4">5.25</span><span class="s2">, </span><span class="s4">1.09</span><span class="s2">, </span><span class="s4">.62</span><span class="s1">])</span><span class="s2">,</span>
                           <span class="s1">np.array([</span><span class="s4">3.17</span><span class="s2">, </span><span class="s1">-</span><span class="s4">.97</span><span class="s2">, </span><span class="s4">.55</span><span class="s1">])</span><span class="s2">,</span>
                           <span class="s1">np.array([</span><span class="s4">8.0023</span><span class="s2">, </span><span class="s4">1.9926</span><span class="s2">, </span><span class="s4">1.0014</span><span class="s2">, </span><span class="s4">0.1237</span><span class="s1">])</span><span class="s2">,</span>
                           <span class="s1">np.array([[</span><span class="s4">0.6326</span><span class="s2">, </span><span class="s4">0.6245</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.4191</span><span class="s2">, </span><span class="s4">0.1847</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[</span><span class="s4">0.7668</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.4270</span><span class="s2">, </span><span class="s4">0.4176</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.2352</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[-</span><span class="s4">0.1082</span><span class="s2">, </span><span class="s4">0.6071</span><span class="s2">, </span><span class="s4">0.4594</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.6393</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[-</span><span class="s4">0.0081</span><span class="s2">, </span><span class="s4">0.2432</span><span class="s2">, </span><span class="s4">0.6625</span><span class="s2">, </span><span class="s4">0.7084</span><span class="s1">]]))</span><span class="s2">,</span>
                          <span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_pteqr_NAG_f08jgf(compute_z</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">d_expect</span><span class="s2">, </span><span class="s1">z_expect):</span>
    <span class="s5">''' 
    Implements real (f08jgf) example from NAG Manual Mark 26. 
    Tests for correct outputs. 
    '''</span>
    <span class="s0"># the NAG manual has 4 decimals accuracy</span>
    <span class="s1">atol = </span><span class="s4">1e-4</span>
    <span class="s1">pteqr = get_lapack_funcs((</span><span class="s3">'pteqr'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=d.dtype)</span>

    <span class="s1">z = np.diag(d) + np.diag(e</span><span class="s2">, </span><span class="s4">1</span><span class="s1">) + np.diag(e</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">_d</span><span class="s2">, </span><span class="s1">_e</span><span class="s2">, </span><span class="s1">_z</span><span class="s2">, </span><span class="s1">info = pteqr(d=d</span><span class="s2">, </span><span class="s1">e=e</span><span class="s2">, </span><span class="s1">z=z</span><span class="s2">, </span><span class="s1">compute_z=compute_z)</span>
    <span class="s1">assert_allclose(_d</span><span class="s2">, </span><span class="s1">d_expect</span><span class="s2">, </span><span class="s1">atol=atol)</span>
    <span class="s1">assert_allclose(np.abs(_z)</span><span class="s2">, </span><span class="s1">np.abs(z_expect)</span><span class="s2">, </span><span class="s1">atol=atol)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'dtype'</span><span class="s2">, </span><span class="s1">DTYPES)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'matrix_size'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">7</span><span class="s2">, </span><span class="s4">6</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">6</span><span class="s2">, </span><span class="s4">6</span><span class="s1">)])</span>
<span class="s2">def </span><span class="s1">test_geqrfp(dtype</span><span class="s2">, </span><span class="s1">matrix_size):</span>
    <span class="s0"># Tests for all dytpes, tall, wide, and square matrices.</span>
    <span class="s0"># Using the routine with random matrix A, Q and R are obtained and then</span>
    <span class="s0"># tested such that R is upper triangular and non-negative on the diagonal,</span>
    <span class="s0"># and Q is an orthagonal matrix. Verifies that A=Q@R. It also</span>
    <span class="s0"># tests against a matrix that for which the  linalg.qr method returns</span>
    <span class="s0"># negative diagonals, and for error messaging.</span>

    <span class="s0"># set test tolerance appropriate for dtype</span>
    <span class="s1">np.random.seed(</span><span class="s4">42</span><span class="s1">)</span>
    <span class="s1">rtol = </span><span class="s4">250</span><span class="s1">*np.finfo(dtype).eps</span>
    <span class="s1">atol = </span><span class="s4">100</span><span class="s1">*np.finfo(dtype).eps</span>
    <span class="s0"># get appropriate ?geqrfp for dtype</span>
    <span class="s1">geqrfp = get_lapack_funcs((</span><span class="s3">'geqrfp'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">gqr = get_lapack_funcs((</span><span class="s3">&quot;orgqr&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

    <span class="s1">m</span><span class="s2">, </span><span class="s1">n = matrix_size</span>

    <span class="s0"># create random matrix of dimentions m x n</span>
    <span class="s1">A = generate_random_dtype_array((m</span><span class="s2">, </span><span class="s1">n)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s0"># create qr matrix using geqrfp</span>
    <span class="s1">qr_A</span><span class="s2">, </span><span class="s1">tau</span><span class="s2">, </span><span class="s1">info = geqrfp(A)</span>

    <span class="s0"># obtain r from the upper triangular area</span>
    <span class="s1">r = np.triu(qr_A)</span>

    <span class="s0"># obtain q from the orgqr lapack routine</span>
    <span class="s0"># based on linalg.qr's extraction strategy of q with orgqr</span>

    <span class="s2">if </span><span class="s1">m &gt; n:</span>
        <span class="s0"># this adds an extra column to the end of qr_A</span>
        <span class="s0"># let qqr be an empty m x m matrix</span>
        <span class="s1">qqr = np.zeros((m</span><span class="s2">, </span><span class="s1">m)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s0"># set first n columns of qqr to qr_A</span>
        <span class="s1">qqr[:</span><span class="s2">, </span><span class="s1">:n] = qr_A</span>
        <span class="s0"># determine q from this qqr</span>
        <span class="s0"># note that m is a sufficient for lwork based on LAPACK documentation</span>
        <span class="s1">q = gqr(qqr</span><span class="s2">, </span><span class="s1">tau=tau</span><span class="s2">, </span><span class="s1">lwork=m)[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">q = gqr(qr_A[:</span><span class="s2">, </span><span class="s1">:m]</span><span class="s2">, </span><span class="s1">tau=tau</span><span class="s2">, </span><span class="s1">lwork=m)[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s0"># test that q and r still make A</span>
    <span class="s1">assert_allclose(q@r</span><span class="s2">, </span><span class="s1">A</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>
    <span class="s0"># ensure that q is orthogonal (that q @ transposed q is the identity)</span>
    <span class="s1">assert_allclose(np.eye(q.shape[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">, </span><span class="s1">q@(q.conj().T)</span><span class="s2">, </span><span class="s1">rtol=rtol</span><span class="s2">,</span>
                    <span class="s1">atol=atol)</span>
    <span class="s0"># ensure r is upper tri by comparing original r to r as upper triangular</span>
    <span class="s1">assert_allclose(r</span><span class="s2">, </span><span class="s1">np.triu(r)</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>
    <span class="s0"># make sure diagonals of r are positive for this random solution</span>
    <span class="s1">assert_(np.all(np.diag(r) &gt; np.zeros(len(np.diag(r)))))</span>
    <span class="s0"># ensure that info is zero for this success</span>
    <span class="s1">assert_(info == </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s0"># test that this routine gives r diagonals that are positive for a</span>
    <span class="s0"># matrix that returns negatives in the diagonal with scipy.linalg.rq</span>
    <span class="s1">A_negative = generate_random_dtype_array((n</span><span class="s2">, </span><span class="s1">m)</span><span class="s2">, </span><span class="s1">dtype=dtype) * -</span><span class="s4">1</span>
    <span class="s1">r_rq_neg</span><span class="s2">, </span><span class="s1">q_rq_neg = qr(A_negative)</span>
    <span class="s1">rq_A_neg</span><span class="s2">, </span><span class="s1">tau_neg</span><span class="s2">, </span><span class="s1">info_neg = geqrfp(A_negative)</span>
    <span class="s0"># assert that any of the entries on the diagonal from linalg.qr</span>
    <span class="s0">#   are negative and that all of geqrfp are positive.</span>
    <span class="s1">assert_(np.any(np.diag(r_rq_neg) &lt; </span><span class="s4">0</span><span class="s1">) </span><span class="s2">and</span>
            <span class="s1">np.all(np.diag(r) &gt; </span><span class="s4">0</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">test_geqrfp_errors_with_empty_array():</span>
    <span class="s0"># check that empty array raises good error message</span>
    <span class="s1">A_empty = np.array([])</span>
    <span class="s1">geqrfp = get_lapack_funcs(</span><span class="s3">'geqrfp'</span><span class="s2">, </span><span class="s1">dtype=A_empty.dtype)</span>
    <span class="s1">assert_raises(Exception</span><span class="s2">, </span><span class="s1">geqrfp</span><span class="s2">, </span><span class="s1">A_empty)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;driver&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'ev'</span><span class="s2">, </span><span class="s3">'evd'</span><span class="s2">, </span><span class="s3">'evr'</span><span class="s2">, </span><span class="s3">'evx'</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;pfx&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'sy'</span><span class="s2">, </span><span class="s3">'he'</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_standard_eigh_lworks(pfx</span><span class="s2">, </span><span class="s1">driver):</span>
    <span class="s1">n = </span><span class="s4">1200  </span><span class="s0"># Some sufficiently big arbitrary number</span>
    <span class="s1">dtype = REAL_DTYPES </span><span class="s2">if </span><span class="s1">pfx == </span><span class="s3">'sy' </span><span class="s2">else </span><span class="s1">COMPLEX_DTYPES</span>
    <span class="s1">sc_dlw = get_lapack_funcs(pfx+driver+</span><span class="s3">'_lwork'</span><span class="s2">, </span><span class="s1">dtype=dtype[</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">dz_dlw = get_lapack_funcs(pfx+driver+</span><span class="s3">'_lwork'</span><span class="s2">, </span><span class="s1">dtype=dtype[</span><span class="s4">1</span><span class="s1">])</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">_compute_lwork(sc_dlw</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">lower=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">_compute_lwork(dz_dlw</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">lower=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
        <span class="s1">pytest.fail(</span><span class="s3">&quot;{}_lwork raised unexpected exception: {}&quot;</span>
                    <span class="s3">&quot;&quot;</span><span class="s1">.format(pfx+driver</span><span class="s2">, </span><span class="s1">e))</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;driver&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'gv'</span><span class="s2">, </span><span class="s3">'gvx'</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;pfx&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'sy'</span><span class="s2">, </span><span class="s3">'he'</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_generalized_eigh_lworks(pfx</span><span class="s2">, </span><span class="s1">driver):</span>
    <span class="s1">n = </span><span class="s4">1200  </span><span class="s0"># Some sufficiently big arbitrary number</span>
    <span class="s1">dtype = REAL_DTYPES </span><span class="s2">if </span><span class="s1">pfx == </span><span class="s3">'sy' </span><span class="s2">else </span><span class="s1">COMPLEX_DTYPES</span>
    <span class="s1">sc_dlw = get_lapack_funcs(pfx+driver+</span><span class="s3">'_lwork'</span><span class="s2">, </span><span class="s1">dtype=dtype[</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">dz_dlw = get_lapack_funcs(pfx+driver+</span><span class="s3">'_lwork'</span><span class="s2">, </span><span class="s1">dtype=dtype[</span><span class="s4">1</span><span class="s1">])</span>
    <span class="s0"># Shouldn't raise any exceptions</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">_compute_lwork(sc_dlw</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">uplo=</span><span class="s3">&quot;L&quot;</span><span class="s1">)</span>
        <span class="s1">_compute_lwork(dz_dlw</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">uplo=</span><span class="s3">&quot;L&quot;</span><span class="s1">)</span>
    <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
        <span class="s1">pytest.fail(</span><span class="s3">&quot;{}_lwork raised unexpected exception: {}&quot;</span>
                    <span class="s3">&quot;&quot;</span><span class="s1">.format(pfx+driver</span><span class="s2">, </span><span class="s1">e))</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype_&quot;</span><span class="s2">, </span><span class="s1">DTYPES)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;m&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">1000</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_orcsd_uncsd_lwork(dtype_</span><span class="s2">, </span><span class="s1">m):</span>
    <span class="s1">seed(</span><span class="s4">1234</span><span class="s1">)</span>
    <span class="s1">p = randint(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">m)</span>
    <span class="s1">q = m - p</span>
    <span class="s1">pfx = </span><span class="s3">'or' </span><span class="s2">if </span><span class="s1">dtype_ </span><span class="s2">in </span><span class="s1">REAL_DTYPES </span><span class="s2">else </span><span class="s3">'un'</span>
    <span class="s1">dlw = pfx + </span><span class="s3">'csd_lwork'</span>
    <span class="s1">lw = get_lapack_funcs(dlw</span><span class="s2">, </span><span class="s1">dtype=dtype_)</span>
    <span class="s1">lwval = _compute_lwork(lw</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">q)</span>
    <span class="s1">lwval = lwval </span><span class="s2">if </span><span class="s1">pfx == </span><span class="s3">'un' </span><span class="s2">else </span><span class="s1">(lwval</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">all([x &gt; </span><span class="s4">0 </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">lwval])</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype_&quot;</span><span class="s2">, </span><span class="s1">DTYPES)</span>
<span class="s2">def </span><span class="s1">test_orcsd_uncsd(dtype_):</span>
    <span class="s1">m</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">q = </span><span class="s4">250</span><span class="s2">, </span><span class="s4">80</span><span class="s2">, </span><span class="s4">170</span>

    <span class="s1">pfx = </span><span class="s3">'or' </span><span class="s2">if </span><span class="s1">dtype_ </span><span class="s2">in </span><span class="s1">REAL_DTYPES </span><span class="s2">else </span><span class="s3">'un'</span>
    <span class="s1">X = ortho_group.rvs(m) </span><span class="s2">if </span><span class="s1">pfx == </span><span class="s3">'or' </span><span class="s2">else </span><span class="s1">unitary_group.rvs(m)</span>

    <span class="s1">drv</span><span class="s2">, </span><span class="s1">dlw = get_lapack_funcs((pfx + </span><span class="s3">'csd'</span><span class="s2">, </span><span class="s1">pfx + </span><span class="s3">'csd_lwork'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype_)</span>
    <span class="s1">lwval = _compute_lwork(dlw</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">q)</span>
    <span class="s1">lwvals = {</span><span class="s3">'lwork'</span><span class="s1">: lwval} </span><span class="s2">if </span><span class="s1">pfx == </span><span class="s3">'or' </span><span class="s2">else </span><span class="s1">dict(zip([</span><span class="s3">'lwork'</span><span class="s2">,</span>
                                                            <span class="s3">'lrwork'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">lwval))</span>

    <span class="s1">cs11</span><span class="s2">, </span><span class="s1">cs12</span><span class="s2">, </span><span class="s1">cs21</span><span class="s2">, </span><span class="s1">cs22</span><span class="s2">, </span><span class="s1">theta</span><span class="s2">, </span><span class="s1">u1</span><span class="s2">, </span><span class="s1">u2</span><span class="s2">, </span><span class="s1">v1t</span><span class="s2">, </span><span class="s1">v2t</span><span class="s2">, </span><span class="s1">info =\</span>
        <span class="s1">drv(X[:p</span><span class="s2">, </span><span class="s1">:q]</span><span class="s2">, </span><span class="s1">X[:p</span><span class="s2">, </span><span class="s1">q:]</span><span class="s2">, </span><span class="s1">X[p:</span><span class="s2">, </span><span class="s1">:q]</span><span class="s2">, </span><span class="s1">X[p:</span><span class="s2">, </span><span class="s1">q:]</span><span class="s2">, </span><span class="s1">**lwvals)</span>

    <span class="s2">assert </span><span class="s1">info == </span><span class="s4">0</span>

    <span class="s1">U = block_diag(u1</span><span class="s2">, </span><span class="s1">u2)</span>
    <span class="s1">VH = block_diag(v1t</span><span class="s2">, </span><span class="s1">v2t)</span>
    <span class="s1">r = min(min(p</span><span class="s2">, </span><span class="s1">q)</span><span class="s2">, </span><span class="s1">min(m-p</span><span class="s2">, </span><span class="s1">m-q))</span>
    <span class="s1">n11 = min(p</span><span class="s2">, </span><span class="s1">q) - r</span>
    <span class="s1">n12 = min(p</span><span class="s2">, </span><span class="s1">m-q) - r</span>
    <span class="s1">n21 = min(m-p</span><span class="s2">, </span><span class="s1">q) - r</span>
    <span class="s1">n22 = min(m-p</span><span class="s2">, </span><span class="s1">m-q) - r</span>

    <span class="s1">S = np.zeros((m</span><span class="s2">, </span><span class="s1">m)</span><span class="s2">, </span><span class="s1">dtype=dtype_)</span>
    <span class="s1">one = dtype_(</span><span class="s4">1.</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(n11):</span>
        <span class="s1">S[i</span><span class="s2">, </span><span class="s1">i] = one</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(n22):</span>
        <span class="s1">S[p+i</span><span class="s2">, </span><span class="s1">q+i] = one</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(n12):</span>
        <span class="s1">S[i+n11+r</span><span class="s2">, </span><span class="s1">i+n11+r+n21+n22+r] = -one</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(n21):</span>
        <span class="s1">S[p+n22+r+i</span><span class="s2">, </span><span class="s1">n11+r+i] = one</span>

    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(r):</span>
        <span class="s1">S[i+n11</span><span class="s2">, </span><span class="s1">i+n11] = np.cos(theta[i])</span>
        <span class="s1">S[p+n22+i</span><span class="s2">, </span><span class="s1">i+r+n21+n22] = np.cos(theta[i])</span>

        <span class="s1">S[i+n11</span><span class="s2">, </span><span class="s1">i+n11+n21+n22+r] = -np.sin(theta[i])</span>
        <span class="s1">S[p+n22+i</span><span class="s2">, </span><span class="s1">i+n11] = np.sin(theta[i])</span>

    <span class="s1">Xc = U @ S @ VH</span>
    <span class="s1">assert_allclose(X</span><span class="s2">, </span><span class="s1">Xc</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e4</span><span class="s1">*np.finfo(dtype_).eps)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype&quot;</span><span class="s2">, </span><span class="s1">DTYPES)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;trans_bool&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">False, True</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;fact&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;F&quot;</span><span class="s2">, </span><span class="s3">&quot;N&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_gtsvx(dtype</span><span class="s2">, </span><span class="s1">trans_bool</span><span class="s2">, </span><span class="s1">fact):</span>
    <span class="s5">&quot;&quot;&quot; 
    These tests uses ?gtsvx to solve a random Ax=b system for each dtype. 
    It tests that the outputs define an LU matrix, that inputs are unmodified, 
    transposal options, incompatible shapes, singular matrices, and 
    singular factorizations. It parametrizes DTYPES and the 'fact' value along 
    with the fact related inputs. 
    &quot;&quot;&quot;</span>
    <span class="s1">seed(</span><span class="s4">42</span><span class="s1">)</span>
    <span class="s0"># set test tolerance appropriate for dtype</span>
    <span class="s1">atol = </span><span class="s4">100 </span><span class="s1">* np.finfo(dtype).eps</span>
    <span class="s0"># obtain routine</span>
    <span class="s1">gtsvx</span><span class="s2">, </span><span class="s1">gttrf = get_lapack_funcs((</span><span class="s3">'gtsvx'</span><span class="s2">, </span><span class="s3">'gttrf'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s0"># Generate random tridiagonal matrix A</span>
    <span class="s1">n = </span><span class="s4">10</span>
    <span class="s1">dl = generate_random_dtype_array((n-</span><span class="s4">1</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">d = generate_random_dtype_array((n</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">du = generate_random_dtype_array((n-</span><span class="s4">1</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">A = np.diag(dl</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">) + np.diag(d) + np.diag(du</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s0"># generate random solution x</span>
    <span class="s1">x = generate_random_dtype_array((n</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s0"># create b from x for equation Ax=b</span>
    <span class="s1">trans = (</span><span class="s3">&quot;T&quot; </span><span class="s2">if </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">REAL_DTYPES </span><span class="s2">else </span><span class="s3">&quot;C&quot;</span><span class="s1">) </span><span class="s2">if </span><span class="s1">trans_bool </span><span class="s2">else </span><span class="s3">&quot;N&quot;</span>
    <span class="s1">b = (A.conj().T </span><span class="s2">if </span><span class="s1">trans_bool </span><span class="s2">else </span><span class="s1">A) @ x</span>

    <span class="s0"># store a copy of the inputs to check they haven't been modified later</span>
    <span class="s1">inputs_cpy = [dl.copy()</span><span class="s2">, </span><span class="s1">d.copy()</span><span class="s2">, </span><span class="s1">du.copy()</span><span class="s2">, </span><span class="s1">b.copy()]</span>

    <span class="s0"># set these to None if fact = 'N', or the output of gttrf is fact = 'F'</span>
    <span class="s1">dlf_</span><span class="s2">, </span><span class="s1">df_</span><span class="s2">, </span><span class="s1">duf_</span><span class="s2">, </span><span class="s1">du2f_</span><span class="s2">, </span><span class="s1">ipiv_</span><span class="s2">, </span><span class="s1">info_ = \</span>
        <span class="s1">gttrf(dl</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">du) </span><span class="s2">if </span><span class="s1">fact == </span><span class="s3">'F' </span><span class="s2">else </span><span class="s1">[</span><span class="s2">None</span><span class="s1">]*</span><span class="s4">6</span>

    <span class="s1">gtsvx_out = gtsvx(dl</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">du</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">fact=fact</span><span class="s2">, </span><span class="s1">trans=trans</span><span class="s2">, </span><span class="s1">dlf=dlf_</span><span class="s2">, </span><span class="s1">df=df_</span><span class="s2">,</span>
                      <span class="s1">duf=duf_</span><span class="s2">, </span><span class="s1">du2=du2f_</span><span class="s2">, </span><span class="s1">ipiv=ipiv_)</span>
    <span class="s1">dlf</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">duf</span><span class="s2">, </span><span class="s1">du2f</span><span class="s2">, </span><span class="s1">ipiv</span><span class="s2">, </span><span class="s1">x_soln</span><span class="s2">, </span><span class="s1">rcond</span><span class="s2">, </span><span class="s1">ferr</span><span class="s2">, </span><span class="s1">berr</span><span class="s2">, </span><span class="s1">info = gtsvx_out</span>
    <span class="s1">assert_(info == </span><span class="s4">0</span><span class="s2">, </span><span class="s3">f&quot;?gtsvx info = </span><span class="s2">{</span><span class="s1">info</span><span class="s2">}</span><span class="s3">, should be zero&quot;</span><span class="s1">)</span>

    <span class="s0"># assure that inputs are unmodified</span>
    <span class="s1">assert_array_equal(dl</span><span class="s2">, </span><span class="s1">inputs_cpy[</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(d</span><span class="s2">, </span><span class="s1">inputs_cpy[</span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(du</span><span class="s2">, </span><span class="s1">inputs_cpy[</span><span class="s4">2</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(b</span><span class="s2">, </span><span class="s1">inputs_cpy[</span><span class="s4">3</span><span class="s1">])</span>

    <span class="s0"># test that x_soln matches the expected x</span>
    <span class="s1">assert_allclose(x</span><span class="s2">, </span><span class="s1">x_soln</span><span class="s2">, </span><span class="s1">atol=atol)</span>

    <span class="s0"># assert that the outputs are of correct type or shape</span>
    <span class="s0"># rcond should be a scalar</span>
    <span class="s1">assert_(hasattr(rcond</span><span class="s2">, </span><span class="s3">&quot;__len__&quot;</span><span class="s1">) </span><span class="s2">is not True,</span>
            <span class="s3">f&quot;rcond should be scalar but is </span><span class="s2">{</span><span class="s1">rcond</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s0"># ferr should be length of # of cols in x</span>
    <span class="s1">assert_(ferr.shape[</span><span class="s4">0</span><span class="s1">] == b.shape[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;ferr.shape is {} but shoud be {},&quot;</span>
            <span class="s1">.format(ferr.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">b.shape[</span><span class="s4">1</span><span class="s1">]))</span>
    <span class="s0"># berr should be length of # of cols in x</span>
    <span class="s1">assert_(berr.shape[</span><span class="s4">0</span><span class="s1">] == b.shape[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;berr.shape is {} but shoud be {},&quot;</span>
            <span class="s1">.format(berr.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">b.shape[</span><span class="s4">1</span><span class="s1">]))</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype&quot;</span><span class="s2">, </span><span class="s1">DTYPES)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;trans_bool&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;fact&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;F&quot;</span><span class="s2">, </span><span class="s3">&quot;N&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_gtsvx_error_singular(dtype</span><span class="s2">, </span><span class="s1">trans_bool</span><span class="s2">, </span><span class="s1">fact):</span>
    <span class="s1">seed(</span><span class="s4">42</span><span class="s1">)</span>
    <span class="s0"># obtain routine</span>
    <span class="s1">gtsvx</span><span class="s2">, </span><span class="s1">gttrf = get_lapack_funcs((</span><span class="s3">'gtsvx'</span><span class="s2">, </span><span class="s3">'gttrf'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s0"># Generate random tridiagonal matrix A</span>
    <span class="s1">n = </span><span class="s4">10</span>
    <span class="s1">dl = generate_random_dtype_array((n-</span><span class="s4">1</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">d = generate_random_dtype_array((n</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">du = generate_random_dtype_array((n-</span><span class="s4">1</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">A = np.diag(dl</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">) + np.diag(d) + np.diag(du</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s0"># generate random solution x</span>
    <span class="s1">x = generate_random_dtype_array((n</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s0"># create b from x for equation Ax=b</span>
    <span class="s1">trans = </span><span class="s3">&quot;T&quot; </span><span class="s2">if </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">REAL_DTYPES </span><span class="s2">else </span><span class="s3">&quot;C&quot;</span>
    <span class="s1">b = (A.conj().T </span><span class="s2">if </span><span class="s1">trans_bool </span><span class="s2">else </span><span class="s1">A) @ x</span>

    <span class="s0"># set these to None if fact = 'N', or the output of gttrf is fact = 'F'</span>
    <span class="s1">dlf_</span><span class="s2">, </span><span class="s1">df_</span><span class="s2">, </span><span class="s1">duf_</span><span class="s2">, </span><span class="s1">du2f_</span><span class="s2">, </span><span class="s1">ipiv_</span><span class="s2">, </span><span class="s1">info_ = \</span>
        <span class="s1">gttrf(dl</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">du) </span><span class="s2">if </span><span class="s1">fact == </span><span class="s3">'F' </span><span class="s2">else </span><span class="s1">[</span><span class="s2">None</span><span class="s1">]*</span><span class="s4">6</span>

    <span class="s1">gtsvx_out = gtsvx(dl</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">du</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">fact=fact</span><span class="s2">, </span><span class="s1">trans=trans</span><span class="s2">, </span><span class="s1">dlf=dlf_</span><span class="s2">, </span><span class="s1">df=df_</span><span class="s2">,</span>
                      <span class="s1">duf=duf_</span><span class="s2">, </span><span class="s1">du2=du2f_</span><span class="s2">, </span><span class="s1">ipiv=ipiv_)</span>
    <span class="s1">dlf</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">duf</span><span class="s2">, </span><span class="s1">du2f</span><span class="s2">, </span><span class="s1">ipiv</span><span class="s2">, </span><span class="s1">x_soln</span><span class="s2">, </span><span class="s1">rcond</span><span class="s2">, </span><span class="s1">ferr</span><span class="s2">, </span><span class="s1">berr</span><span class="s2">, </span><span class="s1">info = gtsvx_out</span>
    <span class="s0"># test with singular matrix</span>
    <span class="s0"># no need to test inputs with fact &quot;F&quot; since ?gttrf already does.</span>
    <span class="s2">if </span><span class="s1">fact == </span><span class="s3">&quot;N&quot;</span><span class="s1">:</span>
        <span class="s0"># Construct a singular example manually</span>
        <span class="s1">d[-</span><span class="s4">1</span><span class="s1">] = </span><span class="s4">0</span>
        <span class="s1">dl[-</span><span class="s4">1</span><span class="s1">] = </span><span class="s4">0</span>
        <span class="s0"># solve using routine</span>
        <span class="s1">gtsvx_out = gtsvx(dl</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">du</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s1">dlf</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">duf</span><span class="s2">, </span><span class="s1">du2f</span><span class="s2">, </span><span class="s1">ipiv</span><span class="s2">, </span><span class="s1">x_soln</span><span class="s2">, </span><span class="s1">rcond</span><span class="s2">, </span><span class="s1">ferr</span><span class="s2">, </span><span class="s1">berr</span><span class="s2">, </span><span class="s1">info = gtsvx_out</span>
        <span class="s0"># test for the singular matrix.</span>
        <span class="s2">assert </span><span class="s1">info &gt; </span><span class="s4">0</span><span class="s2">, </span><span class="s3">&quot;info should be &gt; 0 for singular matrix&quot;</span>

    <span class="s2">elif </span><span class="s1">fact == </span><span class="s3">'F'</span><span class="s1">:</span>
        <span class="s0"># assuming that a singular factorization is input</span>
        <span class="s1">df_[-</span><span class="s4">1</span><span class="s1">] = </span><span class="s4">0</span>
        <span class="s1">duf_[-</span><span class="s4">1</span><span class="s1">] = </span><span class="s4">0</span>
        <span class="s1">du2f_[-</span><span class="s4">1</span><span class="s1">] = </span><span class="s4">0</span>

        <span class="s1">gtsvx_out = gtsvx(dl</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">du</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">fact=fact</span><span class="s2">, </span><span class="s1">dlf=dlf_</span><span class="s2">, </span><span class="s1">df=df_</span><span class="s2">, </span><span class="s1">duf=duf_</span><span class="s2">,</span>
                          <span class="s1">du2=du2f_</span><span class="s2">, </span><span class="s1">ipiv=ipiv_)</span>
        <span class="s1">dlf</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">duf</span><span class="s2">, </span><span class="s1">du2f</span><span class="s2">, </span><span class="s1">ipiv</span><span class="s2">, </span><span class="s1">x_soln</span><span class="s2">, </span><span class="s1">rcond</span><span class="s2">, </span><span class="s1">ferr</span><span class="s2">, </span><span class="s1">berr</span><span class="s2">, </span><span class="s1">info = gtsvx_out</span>
        <span class="s0"># info should not be zero and should provide index of illegal value</span>
        <span class="s2">assert </span><span class="s1">info &gt; </span><span class="s4">0</span><span class="s2">, </span><span class="s3">&quot;info should be &gt; 0 for singular matrix&quot;</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype&quot;</span><span class="s2">, </span><span class="s1">DTYPES*</span><span class="s4">2</span><span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;trans_bool&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">False, True</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;fact&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;F&quot;</span><span class="s2">, </span><span class="s3">&quot;N&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_gtsvx_error_incompatible_size(dtype</span><span class="s2">, </span><span class="s1">trans_bool</span><span class="s2">, </span><span class="s1">fact):</span>
    <span class="s1">seed(</span><span class="s4">42</span><span class="s1">)</span>
    <span class="s0"># obtain routine</span>
    <span class="s1">gtsvx</span><span class="s2">, </span><span class="s1">gttrf = get_lapack_funcs((</span><span class="s3">'gtsvx'</span><span class="s2">, </span><span class="s3">'gttrf'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s0"># Generate random tridiagonal matrix A</span>
    <span class="s1">n = </span><span class="s4">10</span>
    <span class="s1">dl = generate_random_dtype_array((n-</span><span class="s4">1</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">d = generate_random_dtype_array((n</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">du = generate_random_dtype_array((n-</span><span class="s4">1</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">A = np.diag(dl</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">) + np.diag(d) + np.diag(du</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s0"># generate random solution x</span>
    <span class="s1">x = generate_random_dtype_array((n</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s0"># create b from x for equation Ax=b</span>
    <span class="s1">trans = </span><span class="s3">&quot;T&quot; </span><span class="s2">if </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">REAL_DTYPES </span><span class="s2">else </span><span class="s3">&quot;C&quot;</span>
    <span class="s1">b = (A.conj().T </span><span class="s2">if </span><span class="s1">trans_bool </span><span class="s2">else </span><span class="s1">A) @ x</span>

    <span class="s0"># set these to None if fact = 'N', or the output of gttrf is fact = 'F'</span>
    <span class="s1">dlf_</span><span class="s2">, </span><span class="s1">df_</span><span class="s2">, </span><span class="s1">duf_</span><span class="s2">, </span><span class="s1">du2f_</span><span class="s2">, </span><span class="s1">ipiv_</span><span class="s2">, </span><span class="s1">info_ = \</span>
        <span class="s1">gttrf(dl</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">du) </span><span class="s2">if </span><span class="s1">fact == </span><span class="s3">'F' </span><span class="s2">else </span><span class="s1">[</span><span class="s2">None</span><span class="s1">]*</span><span class="s4">6</span>

    <span class="s2">if </span><span class="s1">fact == </span><span class="s3">&quot;N&quot;</span><span class="s1">:</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">gtsvx</span><span class="s2">, </span><span class="s1">dl[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">du</span><span class="s2">, </span><span class="s1">b</span><span class="s2">,</span>
                      <span class="s1">fact=fact</span><span class="s2">, </span><span class="s1">trans=trans</span><span class="s2">, </span><span class="s1">dlf=dlf_</span><span class="s2">, </span><span class="s1">df=df_</span><span class="s2">,</span>
                      <span class="s1">duf=duf_</span><span class="s2">, </span><span class="s1">du2=du2f_</span><span class="s2">, </span><span class="s1">ipiv=ipiv_)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">gtsvx</span><span class="s2">, </span><span class="s1">dl</span><span class="s2">, </span><span class="s1">d[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">du</span><span class="s2">, </span><span class="s1">b</span><span class="s2">,</span>
                      <span class="s1">fact=fact</span><span class="s2">, </span><span class="s1">trans=trans</span><span class="s2">, </span><span class="s1">dlf=dlf_</span><span class="s2">, </span><span class="s1">df=df_</span><span class="s2">,</span>
                      <span class="s1">duf=duf_</span><span class="s2">, </span><span class="s1">du2=du2f_</span><span class="s2">, </span><span class="s1">ipiv=ipiv_)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">gtsvx</span><span class="s2">, </span><span class="s1">dl</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">du[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">b</span><span class="s2">,</span>
                      <span class="s1">fact=fact</span><span class="s2">, </span><span class="s1">trans=trans</span><span class="s2">, </span><span class="s1">dlf=dlf_</span><span class="s2">, </span><span class="s1">df=df_</span><span class="s2">,</span>
                      <span class="s1">duf=duf_</span><span class="s2">, </span><span class="s1">du2=du2f_</span><span class="s2">, </span><span class="s1">ipiv=ipiv_)</span>
        <span class="s1">assert_raises(Exception</span><span class="s2">, </span><span class="s1">gtsvx</span><span class="s2">, </span><span class="s1">dl</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">du</span><span class="s2">, </span><span class="s1">b[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">fact=fact</span><span class="s2">, </span><span class="s1">trans=trans</span><span class="s2">, </span><span class="s1">dlf=dlf_</span><span class="s2">, </span><span class="s1">df=df_</span><span class="s2">,</span>
                      <span class="s1">duf=duf_</span><span class="s2">, </span><span class="s1">du2=du2f_</span><span class="s2">, </span><span class="s1">ipiv=ipiv_)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">gtsvx</span><span class="s2">, </span><span class="s1">dl</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">du</span><span class="s2">, </span><span class="s1">b</span><span class="s2">,</span>
                      <span class="s1">fact=fact</span><span class="s2">, </span><span class="s1">trans=trans</span><span class="s2">, </span><span class="s1">dlf=dlf_[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">df=df_</span><span class="s2">,</span>
                      <span class="s1">duf=duf_</span><span class="s2">, </span><span class="s1">du2=du2f_</span><span class="s2">, </span><span class="s1">ipiv=ipiv_)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">gtsvx</span><span class="s2">, </span><span class="s1">dl</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">du</span><span class="s2">, </span><span class="s1">b</span><span class="s2">,</span>
                      <span class="s1">fact=fact</span><span class="s2">, </span><span class="s1">trans=trans</span><span class="s2">, </span><span class="s1">dlf=dlf_</span><span class="s2">, </span><span class="s1">df=df_[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">duf=duf_</span><span class="s2">, </span><span class="s1">du2=du2f_</span><span class="s2">, </span><span class="s1">ipiv=ipiv_)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">gtsvx</span><span class="s2">, </span><span class="s1">dl</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">du</span><span class="s2">, </span><span class="s1">b</span><span class="s2">,</span>
                      <span class="s1">fact=fact</span><span class="s2">, </span><span class="s1">trans=trans</span><span class="s2">, </span><span class="s1">dlf=dlf_</span><span class="s2">, </span><span class="s1">df=df_</span><span class="s2">,</span>
                      <span class="s1">duf=duf_[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">du2=du2f_</span><span class="s2">, </span><span class="s1">ipiv=ipiv_)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">gtsvx</span><span class="s2">, </span><span class="s1">dl</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">du</span><span class="s2">, </span><span class="s1">b</span><span class="s2">,</span>
                      <span class="s1">fact=fact</span><span class="s2">, </span><span class="s1">trans=trans</span><span class="s2">, </span><span class="s1">dlf=dlf_</span><span class="s2">, </span><span class="s1">df=df_</span><span class="s2">,</span>
                      <span class="s1">duf=duf_</span><span class="s2">, </span><span class="s1">du2=du2f_[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ipiv=ipiv_)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;du,d,dl,b,x&quot;</span><span class="s2">,</span>
                         <span class="s1">[(np.array([</span><span class="s4">2.1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">1.9</span><span class="s2">, </span><span class="s4">8.0</span><span class="s1">])</span><span class="s2">,</span>
                           <span class="s1">np.array([</span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">2.3</span><span class="s2">, </span><span class="s1">-</span><span class="s4">5.0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.9</span><span class="s2">, </span><span class="s4">7.1</span><span class="s1">])</span><span class="s2">,</span>
                           <span class="s1">np.array([</span><span class="s4">3.4</span><span class="s2">, </span><span class="s4">3.6</span><span class="s2">, </span><span class="s4">7.0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">6.0</span><span class="s1">])</span><span class="s2">,</span>
                           <span class="s1">np.array([[</span><span class="s4">2.7</span><span class="s2">, </span><span class="s4">6.6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">.5</span><span class="s2">, </span><span class="s4">10.8</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2.6</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3.2</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[</span><span class="s4">.6</span><span class="s2">, </span><span class="s1">-</span><span class="s4">11.2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2.7</span><span class="s2">, </span><span class="s4">19.1</span><span class="s1">]])</span><span class="s2">,</span>
                           <span class="s1">np.array([[-</span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">7</span><span class="s2">, </span><span class="s1">-</span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">4</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[-</span><span class="s4">3</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]]))</span><span class="s2">,</span>
                          <span class="s1">(np.array([</span><span class="s4">2 </span><span class="s1">- </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">1j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">- </span><span class="s4">1j</span><span class="s1">])</span><span class="s2">,</span>
                           <span class="s1">np.array([-</span><span class="s4">1.3 </span><span class="s1">+ </span><span class="s4">1.3j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.3 </span><span class="s1">+ </span><span class="s4">1.3j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.3 </span><span class="s1">+ </span><span class="s4">3.3j</span><span class="s2">,</span>
                                     <span class="s1">-</span><span class="s4">.3 </span><span class="s1">+ </span><span class="s4">4.3j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3.3 </span><span class="s1">+ </span><span class="s4">1.3j</span><span class="s1">])</span><span class="s2">,</span>
                           <span class="s1">np.array([</span><span class="s4">1 </span><span class="s1">- </span><span class="s4">2j</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">- </span><span class="s4">3j</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">1j</span><span class="s1">])</span><span class="s2">,</span>
                           <span class="s1">np.array([[</span><span class="s4">2.4 </span><span class="s1">- </span><span class="s4">5j</span><span class="s2">, </span><span class="s4">2.7 </span><span class="s1">+ </span><span class="s4">6.9j</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[</span><span class="s4">3.4 </span><span class="s1">+ </span><span class="s4">18.2j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">6.9 </span><span class="s1">- </span><span class="s4">5.3j</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[-</span><span class="s4">14.7 </span><span class="s1">+ </span><span class="s4">9.7j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">6 </span><span class="s1">- </span><span class="s4">.6j</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[</span><span class="s4">31.9 </span><span class="s1">- </span><span class="s4">7.7j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3.9 </span><span class="s1">+ </span><span class="s4">9.3j</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[-</span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">1.6j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3 </span><span class="s1">+ </span><span class="s4">12.2j</span><span class="s1">]])</span><span class="s2">,</span>
                           <span class="s1">np.array([[</span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">- </span><span class="s4">1j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3 </span><span class="s1">- </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">2j</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[</span><span class="s4">4 </span><span class="s1">+ </span><span class="s4">5j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">1j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">1 </span><span class="s1">- </span><span class="s4">2j</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">1j</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[</span><span class="s4">1 </span><span class="s1">- </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">- </span><span class="s4">2j</span><span class="s1">]]))])</span>
<span class="s2">def </span><span class="s1">test_gtsvx_NAG(du</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">dl</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x):</span>
    <span class="s0"># Test to ensure wrapper is consistent with NAG Manual Mark 26</span>
    <span class="s0"># example problems: real (f07cbf) and complex (f07cpf)</span>
    <span class="s1">gtsvx = get_lapack_funcs(</span><span class="s3">'gtsvx'</span><span class="s2">, </span><span class="s1">dtype=d.dtype)</span>

    <span class="s1">gtsvx_out = gtsvx(dl</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">du</span><span class="s2">, </span><span class="s1">b)</span>
    <span class="s1">dlf</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">duf</span><span class="s2">, </span><span class="s1">du2f</span><span class="s2">, </span><span class="s1">ipiv</span><span class="s2">, </span><span class="s1">x_soln</span><span class="s2">, </span><span class="s1">rcond</span><span class="s2">, </span><span class="s1">ferr</span><span class="s2">, </span><span class="s1">berr</span><span class="s2">, </span><span class="s1">info = gtsvx_out</span>

    <span class="s1">assert_array_almost_equal(x</span><span class="s2">, </span><span class="s1">x_soln)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype,realtype&quot;</span><span class="s2">, </span><span class="s1">zip(DTYPES</span><span class="s2">, </span><span class="s1">REAL_DTYPES</span>
                                               <span class="s1">+ REAL_DTYPES))</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;fact,df_de_lambda&quot;</span><span class="s2">,</span>
                         <span class="s1">[(</span><span class="s3">&quot;F&quot;</span><span class="s2">,</span>
                           <span class="s2">lambda </span><span class="s1">d</span><span class="s2">, </span><span class="s1">e:get_lapack_funcs(</span><span class="s3">'pttrf'</span><span class="s2">,</span>
                                                        <span class="s1">dtype=e.dtype)(d</span><span class="s2">, </span><span class="s1">e))</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s3">&quot;N&quot;</span><span class="s2">, lambda </span><span class="s1">d</span><span class="s2">, </span><span class="s1">e: (</span><span class="s2">None, None, None</span><span class="s1">))])</span>
<span class="s2">def </span><span class="s1">test_ptsvx(dtype</span><span class="s2">, </span><span class="s1">realtype</span><span class="s2">, </span><span class="s1">fact</span><span class="s2">, </span><span class="s1">df_de_lambda):</span>
    <span class="s5">''' 
    This tests the ?ptsvx lapack routine wrapper to solve a random system 
    Ax = b for all dtypes and input variations. Tests for: unmodified 
    input parameters, fact options, incompatible matrix shapes raise an error, 
    and singular matrices return info of illegal value. 
    '''</span>
    <span class="s1">seed(</span><span class="s4">42</span><span class="s1">)</span>
    <span class="s0"># set test tolerance appropriate for dtype</span>
    <span class="s1">atol = </span><span class="s4">100 </span><span class="s1">* np.finfo(dtype).eps</span>
    <span class="s1">ptsvx = get_lapack_funcs(</span><span class="s3">'ptsvx'</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">n = </span><span class="s4">5</span>
    <span class="s0"># create diagonals according to size and dtype</span>
    <span class="s1">d = generate_random_dtype_array((n</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">realtype) + </span><span class="s4">4</span>
    <span class="s1">e = generate_random_dtype_array((n-</span><span class="s4">1</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype)</span>
    <span class="s1">A = np.diag(d) + np.diag(e</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">) + np.diag(np.conj(e)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">x_soln = generate_random_dtype_array((n</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">b = A @ x_soln</span>

    <span class="s0"># use lambda to determine what df, ef are</span>
    <span class="s1">df</span><span class="s2">, </span><span class="s1">ef</span><span class="s2">, </span><span class="s1">info = df_de_lambda(d</span><span class="s2">, </span><span class="s1">e)</span>

    <span class="s0"># create copy to later test that they are unmodified</span>
    <span class="s1">diag_cpy = [d.copy()</span><span class="s2">, </span><span class="s1">e.copy()</span><span class="s2">, </span><span class="s1">b.copy()]</span>

    <span class="s0"># solve using routine</span>
    <span class="s1">df</span><span class="s2">, </span><span class="s1">ef</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">rcond</span><span class="s2">, </span><span class="s1">ferr</span><span class="s2">, </span><span class="s1">berr</span><span class="s2">, </span><span class="s1">info = ptsvx(d</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">fact=fact</span><span class="s2">,</span>
                                               <span class="s1">df=df</span><span class="s2">, </span><span class="s1">ef=ef)</span>
    <span class="s0"># d, e, and b should be unmodified</span>
    <span class="s1">assert_array_equal(d</span><span class="s2">, </span><span class="s1">diag_cpy[</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(e</span><span class="s2">, </span><span class="s1">diag_cpy[</span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(b</span><span class="s2">, </span><span class="s1">diag_cpy[</span><span class="s4">2</span><span class="s1">])</span>
    <span class="s1">assert_(info == </span><span class="s4">0</span><span class="s2">, </span><span class="s3">f&quot;info should be 0 but is </span><span class="s2">{</span><span class="s1">info</span><span class="s2">}</span><span class="s3">.&quot;</span><span class="s1">)</span>
    <span class="s1">assert_array_almost_equal(x_soln</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s0"># test that the factors from ptsvx can be recombined to make A</span>
    <span class="s1">L = np.diag(ef</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">) + np.diag(np.ones(n))</span>
    <span class="s1">D = np.diag(df)</span>
    <span class="s1">assert_allclose(A</span><span class="s2">, </span><span class="s1">L@D@(np.conj(L).T)</span><span class="s2">, </span><span class="s1">atol=atol)</span>

    <span class="s0"># assert that the outputs are of correct type or shape</span>
    <span class="s0"># rcond should be a scalar</span>
    <span class="s2">assert not </span><span class="s1">hasattr(rcond</span><span class="s2">, </span><span class="s3">&quot;__len__&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">\</span>
        <span class="s3">f&quot;rcond should be scalar but is </span><span class="s2">{</span><span class="s1">rcond</span><span class="s2">}</span><span class="s3">&quot;</span>
    <span class="s0"># ferr should be length of # of cols in x</span>
    <span class="s1">assert_(ferr.shape == (</span><span class="s4">2</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;ferr.shape is {} but shoud be ({},)&quot;</span>
            <span class="s1">.format(ferr.shape</span><span class="s2">, </span><span class="s1">x_soln.shape[</span><span class="s4">1</span><span class="s1">]))</span>
    <span class="s0"># berr should be length of # of cols in x</span>
    <span class="s1">assert_(berr.shape == (</span><span class="s4">2</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;berr.shape is {} but shoud be ({},)&quot;</span>
            <span class="s1">.format(berr.shape</span><span class="s2">, </span><span class="s1">x_soln.shape[</span><span class="s4">1</span><span class="s1">]))</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype,realtype&quot;</span><span class="s2">, </span><span class="s1">zip(DTYPES</span><span class="s2">, </span><span class="s1">REAL_DTYPES</span>
                                               <span class="s1">+ REAL_DTYPES))</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;fact,df_de_lambda&quot;</span><span class="s2">,</span>
                         <span class="s1">[(</span><span class="s3">&quot;F&quot;</span><span class="s2">,</span>
                           <span class="s2">lambda </span><span class="s1">d</span><span class="s2">, </span><span class="s1">e:get_lapack_funcs(</span><span class="s3">'pttrf'</span><span class="s2">,</span>
                                                        <span class="s1">dtype=e.dtype)(d</span><span class="s2">, </span><span class="s1">e))</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s3">&quot;N&quot;</span><span class="s2">, lambda </span><span class="s1">d</span><span class="s2">, </span><span class="s1">e: (</span><span class="s2">None, None, None</span><span class="s1">))])</span>
<span class="s2">def </span><span class="s1">test_ptsvx_error_raise_errors(dtype</span><span class="s2">, </span><span class="s1">realtype</span><span class="s2">, </span><span class="s1">fact</span><span class="s2">, </span><span class="s1">df_de_lambda):</span>
    <span class="s1">seed(</span><span class="s4">42</span><span class="s1">)</span>
    <span class="s1">ptsvx = get_lapack_funcs(</span><span class="s3">'ptsvx'</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">n = </span><span class="s4">5</span>
    <span class="s0"># create diagonals according to size and dtype</span>
    <span class="s1">d = generate_random_dtype_array((n</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">realtype) + </span><span class="s4">4</span>
    <span class="s1">e = generate_random_dtype_array((n-</span><span class="s4">1</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype)</span>
    <span class="s1">A = np.diag(d) + np.diag(e</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">) + np.diag(np.conj(e)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">x_soln = generate_random_dtype_array((n</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">b = A @ x_soln</span>

    <span class="s0"># use lambda to determine what df, ef are</span>
    <span class="s1">df</span><span class="s2">, </span><span class="s1">ef</span><span class="s2">, </span><span class="s1">info = df_de_lambda(d</span><span class="s2">, </span><span class="s1">e)</span>

    <span class="s0"># test with malformatted array sizes</span>
    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">ptsvx</span><span class="s2">, </span><span class="s1">d[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">fact=fact</span><span class="s2">, </span><span class="s1">df=df</span><span class="s2">, </span><span class="s1">ef=ef)</span>
    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">ptsvx</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">e[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">fact=fact</span><span class="s2">, </span><span class="s1">df=df</span><span class="s2">, </span><span class="s1">ef=ef)</span>
    <span class="s1">assert_raises(Exception</span><span class="s2">, </span><span class="s1">ptsvx</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">b[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">fact=fact</span><span class="s2">, </span><span class="s1">df=df</span><span class="s2">, </span><span class="s1">ef=ef)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype,realtype&quot;</span><span class="s2">, </span><span class="s1">zip(DTYPES</span><span class="s2">, </span><span class="s1">REAL_DTYPES</span>
                                               <span class="s1">+ REAL_DTYPES))</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;fact,df_de_lambda&quot;</span><span class="s2">,</span>
                         <span class="s1">[(</span><span class="s3">&quot;F&quot;</span><span class="s2">,</span>
                           <span class="s2">lambda </span><span class="s1">d</span><span class="s2">, </span><span class="s1">e:get_lapack_funcs(</span><span class="s3">'pttrf'</span><span class="s2">,</span>
                                                        <span class="s1">dtype=e.dtype)(d</span><span class="s2">, </span><span class="s1">e))</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s3">&quot;N&quot;</span><span class="s2">, lambda </span><span class="s1">d</span><span class="s2">, </span><span class="s1">e: (</span><span class="s2">None, None, None</span><span class="s1">))])</span>
<span class="s2">def </span><span class="s1">test_ptsvx_non_SPD_singular(dtype</span><span class="s2">, </span><span class="s1">realtype</span><span class="s2">, </span><span class="s1">fact</span><span class="s2">, </span><span class="s1">df_de_lambda):</span>
    <span class="s1">seed(</span><span class="s4">42</span><span class="s1">)</span>
    <span class="s1">ptsvx = get_lapack_funcs(</span><span class="s3">'ptsvx'</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">n = </span><span class="s4">5</span>
    <span class="s0"># create diagonals according to size and dtype</span>
    <span class="s1">d = generate_random_dtype_array((n</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">realtype) + </span><span class="s4">4</span>
    <span class="s1">e = generate_random_dtype_array((n-</span><span class="s4">1</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype)</span>
    <span class="s1">A = np.diag(d) + np.diag(e</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">) + np.diag(np.conj(e)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">x_soln = generate_random_dtype_array((n</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">b = A @ x_soln</span>

    <span class="s0"># use lambda to determine what df, ef are</span>
    <span class="s1">df</span><span class="s2">, </span><span class="s1">ef</span><span class="s2">, </span><span class="s1">info = df_de_lambda(d</span><span class="s2">, </span><span class="s1">e)</span>

    <span class="s2">if </span><span class="s1">fact == </span><span class="s3">&quot;N&quot;</span><span class="s1">:</span>
        <span class="s1">d[</span><span class="s4">3</span><span class="s1">] = </span><span class="s4">0</span>
        <span class="s0"># obtain new df, ef</span>
        <span class="s1">df</span><span class="s2">, </span><span class="s1">ef</span><span class="s2">, </span><span class="s1">info = df_de_lambda(d</span><span class="s2">, </span><span class="s1">e)</span>
        <span class="s0"># solve using routine</span>
        <span class="s1">df</span><span class="s2">, </span><span class="s1">ef</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">rcond</span><span class="s2">, </span><span class="s1">ferr</span><span class="s2">, </span><span class="s1">berr</span><span class="s2">, </span><span class="s1">info = ptsvx(d</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s0"># test for the singular matrix.</span>
        <span class="s2">assert </span><span class="s1">info &gt; </span><span class="s4">0 </span><span class="s2">and </span><span class="s1">info &lt;= n</span>

        <span class="s0"># non SPD matrix</span>
        <span class="s1">d = generate_random_dtype_array((n</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">realtype)</span>
        <span class="s1">df</span><span class="s2">, </span><span class="s1">ef</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">rcond</span><span class="s2">, </span><span class="s1">ferr</span><span class="s2">, </span><span class="s1">berr</span><span class="s2">, </span><span class="s1">info = ptsvx(d</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s2">assert </span><span class="s1">info &gt; </span><span class="s4">0 </span><span class="s2">and </span><span class="s1">info &lt;= n</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s0"># assuming that someone is using a singular factorization</span>
        <span class="s1">df</span><span class="s2">, </span><span class="s1">ef</span><span class="s2">, </span><span class="s1">info = df_de_lambda(d</span><span class="s2">, </span><span class="s1">e)</span>
        <span class="s1">df[</span><span class="s4">0</span><span class="s1">] = </span><span class="s4">0</span>
        <span class="s1">ef[</span><span class="s4">0</span><span class="s1">] = </span><span class="s4">0</span>
        <span class="s1">df</span><span class="s2">, </span><span class="s1">ef</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">rcond</span><span class="s2">, </span><span class="s1">ferr</span><span class="s2">, </span><span class="s1">berr</span><span class="s2">, </span><span class="s1">info = ptsvx(d</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">fact=fact</span><span class="s2">,</span>
                                                   <span class="s1">df=df</span><span class="s2">, </span><span class="s1">ef=ef)</span>
        <span class="s2">assert </span><span class="s1">info &gt; </span><span class="s4">0</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'d,e,b,x'</span><span class="s2">,</span>
                         <span class="s1">[(np.array([</span><span class="s4">4</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">29</span><span class="s2">, </span><span class="s4">25</span><span class="s2">, </span><span class="s4">5</span><span class="s1">])</span><span class="s2">,</span>
                           <span class="s1">np.array([-</span><span class="s4">2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">6</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s4">8</span><span class="s1">])</span><span class="s2">,</span>
                           <span class="s1">np.array([[</span><span class="s4">6</span><span class="s2">, </span><span class="s4">10</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">9</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">9</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">14</span><span class="s2">, </span><span class="s4">65</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[</span><span class="s4">7</span><span class="s2">, </span><span class="s4">23</span><span class="s1">]])</span><span class="s2">,</span>
                           <span class="s1">np.array([[</span><span class="s4">2.5</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s1">-</span><span class="s4">5</span><span class="s1">]]))</span><span class="s2">,</span>
                          <span class="s1">(np.array([</span><span class="s4">16</span><span class="s2">, </span><span class="s4">41</span><span class="s2">, </span><span class="s4">46</span><span class="s2">, </span><span class="s4">21</span><span class="s1">])</span><span class="s2">,</span>
                           <span class="s1">np.array([</span><span class="s4">16 </span><span class="s1">+ </span><span class="s4">16j</span><span class="s2">, </span><span class="s4">18 </span><span class="s1">- </span><span class="s4">9j</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">- </span><span class="s4">4j</span><span class="s1">])</span><span class="s2">,</span>
                           <span class="s1">np.array([[</span><span class="s4">64 </span><span class="s1">+ </span><span class="s4">16j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">16 </span><span class="s1">- </span><span class="s4">32j</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[</span><span class="s4">93 </span><span class="s1">+ </span><span class="s4">62j</span><span class="s2">, </span><span class="s4">61 </span><span class="s1">- </span><span class="s4">66j</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[</span><span class="s4">78 </span><span class="s1">- </span><span class="s4">80j</span><span class="s2">, </span><span class="s4">71 </span><span class="s1">- </span><span class="s4">74j</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[</span><span class="s4">14 </span><span class="s1">- </span><span class="s4">27j</span><span class="s2">, </span><span class="s4">35 </span><span class="s1">+ </span><span class="s4">15j</span><span class="s1">]])</span><span class="s2">,</span>
                           <span class="s1">np.array([[</span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">1j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3 </span><span class="s1">- </span><span class="s4">2j</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[</span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">1j</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[</span><span class="s4">1 </span><span class="s1">- </span><span class="s4">2j</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">- </span><span class="s4">2j</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[</span><span class="s4">1 </span><span class="s1">- </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">1j</span><span class="s1">]]))])</span>
<span class="s2">def </span><span class="s1">test_ptsvx_NAG(d</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x):</span>
    <span class="s0"># test to assure that wrapper is consistent with NAG Manual Mark 26</span>
    <span class="s0"># example problemss: f07jbf, f07jpf</span>
    <span class="s0"># (Links expire, so please search for &quot;NAG Library Manual Mark 26&quot; online)</span>

    <span class="s0"># obtain routine with correct type based on e.dtype</span>
    <span class="s1">ptsvx = get_lapack_funcs(</span><span class="s3">'ptsvx'</span><span class="s2">, </span><span class="s1">dtype=e.dtype)</span>
    <span class="s0"># solve using routine</span>
    <span class="s1">df</span><span class="s2">, </span><span class="s1">ef</span><span class="s2">, </span><span class="s1">x_ptsvx</span><span class="s2">, </span><span class="s1">rcond</span><span class="s2">, </span><span class="s1">ferr</span><span class="s2">, </span><span class="s1">berr</span><span class="s2">, </span><span class="s1">info = ptsvx(d</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">b)</span>
    <span class="s0"># determine ptsvx's solution and x are the same.</span>
    <span class="s1">assert_array_almost_equal(x</span><span class="s2">, </span><span class="s1">x_ptsvx)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'lower'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">False, True</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'dtype'</span><span class="s2">, </span><span class="s1">DTYPES)</span>
<span class="s2">def </span><span class="s1">test_pptrs_pptri_pptrf_ppsv_ppcon(dtype</span><span class="s2">, </span><span class="s1">lower):</span>
    <span class="s1">seed(</span><span class="s4">1234</span><span class="s1">)</span>
    <span class="s1">atol = np.finfo(dtype).eps*</span><span class="s4">100</span>
    <span class="s0"># Manual conversion to/from packed format is feasible here.</span>
    <span class="s1">n</span><span class="s2">, </span><span class="s1">nrhs = </span><span class="s4">10</span><span class="s2">, </span><span class="s4">4</span>
    <span class="s1">a = generate_random_dtype_array([n</span><span class="s2">, </span><span class="s1">n]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">b = generate_random_dtype_array([n</span><span class="s2">, </span><span class="s1">nrhs]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

    <span class="s1">a = a.conj().T + a + np.eye(n</span><span class="s2">, </span><span class="s1">dtype=dtype) * dtype(</span><span class="s4">5.</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">lower:</span>
        <span class="s1">inds = ([x </span><span class="s2">for </span><span class="s1">y </span><span class="s2">in </span><span class="s1">range(n) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">range(y</span><span class="s2">, </span><span class="s1">n)]</span><span class="s2">,</span>
                <span class="s1">[y </span><span class="s2">for </span><span class="s1">y </span><span class="s2">in </span><span class="s1">range(n) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">range(y</span><span class="s2">, </span><span class="s1">n)])</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">inds = ([x </span><span class="s2">for </span><span class="s1">y </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">n+</span><span class="s4">1</span><span class="s1">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">range(y)]</span><span class="s2">,</span>
                <span class="s1">[y-</span><span class="s4">1 </span><span class="s2">for </span><span class="s1">y </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">n+</span><span class="s4">1</span><span class="s1">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">range(y)])</span>
    <span class="s1">ap = a[inds]</span>
    <span class="s1">ppsv</span><span class="s2">, </span><span class="s1">pptrf</span><span class="s2">, </span><span class="s1">pptrs</span><span class="s2">, </span><span class="s1">pptri</span><span class="s2">, </span><span class="s1">ppcon = get_lapack_funcs(</span>
        <span class="s1">(</span><span class="s3">'ppsv'</span><span class="s2">, </span><span class="s3">'pptrf'</span><span class="s2">, </span><span class="s3">'pptrs'</span><span class="s2">, </span><span class="s3">'pptri'</span><span class="s2">, </span><span class="s3">'ppcon'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">dtype=dtype</span><span class="s2">,</span>
        <span class="s1">ilp64=</span><span class="s3">&quot;preferred&quot;</span><span class="s1">)</span>

    <span class="s1">ul</span><span class="s2">, </span><span class="s1">info = pptrf(n</span><span class="s2">, </span><span class="s1">ap</span><span class="s2">, </span><span class="s1">lower=lower)</span>
    <span class="s1">assert_equal(info</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">aul = cholesky(a</span><span class="s2">, </span><span class="s1">lower=lower)[inds]</span>
    <span class="s1">assert_allclose(ul</span><span class="s2">, </span><span class="s1">aul</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=atol)</span>

    <span class="s1">uli</span><span class="s2">, </span><span class="s1">info = pptri(n</span><span class="s2">, </span><span class="s1">ul</span><span class="s2">, </span><span class="s1">lower=lower)</span>
    <span class="s1">assert_equal(info</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">auli = inv(a)[inds]</span>
    <span class="s1">assert_allclose(uli</span><span class="s2">, </span><span class="s1">auli</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=atol)</span>

    <span class="s1">x</span><span class="s2">, </span><span class="s1">info = pptrs(n</span><span class="s2">, </span><span class="s1">ul</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">lower=lower)</span>
    <span class="s1">assert_equal(info</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">bx = solve(a</span><span class="s2">, </span><span class="s1">b)</span>
    <span class="s1">assert_allclose(x</span><span class="s2">, </span><span class="s1">bx</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=atol)</span>

    <span class="s1">xv</span><span class="s2">, </span><span class="s1">info = ppsv(n</span><span class="s2">, </span><span class="s1">ap</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">lower=lower)</span>
    <span class="s1">assert_equal(info</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">assert_allclose(xv</span><span class="s2">, </span><span class="s1">bx</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=atol)</span>

    <span class="s1">anorm = np.linalg.norm(a</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">rcond</span><span class="s2">, </span><span class="s1">info = ppcon(n</span><span class="s2">, </span><span class="s1">ap</span><span class="s2">, </span><span class="s1">anorm=anorm</span><span class="s2">, </span><span class="s1">lower=lower)</span>
    <span class="s1">assert_equal(info</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">assert_(abs(</span><span class="s4">1</span><span class="s1">/rcond - np.linalg.cond(a</span><span class="s2">, </span><span class="s1">p=</span><span class="s4">1</span><span class="s1">))*rcond &lt; </span><span class="s4">1</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'dtype'</span><span class="s2">, </span><span class="s1">DTYPES)</span>
<span class="s2">def </span><span class="s1">test_gees_trexc(dtype):</span>
    <span class="s1">seed(</span><span class="s4">1234</span><span class="s1">)</span>
    <span class="s1">atol = np.finfo(dtype).eps*</span><span class="s4">100</span>

    <span class="s1">n = </span><span class="s4">10</span>
    <span class="s1">a = generate_random_dtype_array([n</span><span class="s2">, </span><span class="s1">n]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

    <span class="s1">gees</span><span class="s2">, </span><span class="s1">trexc = get_lapack_funcs((</span><span class="s3">'gees'</span><span class="s2">, </span><span class="s3">'trexc'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

    <span class="s1">result = gees(</span><span class="s2">lambda </span><span class="s1">x: </span><span class="s2">None, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">overwrite_a=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">assert_equal(result[-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s1">t = result[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">z = result[-</span><span class="s4">3</span><span class="s1">]</span>

    <span class="s1">d2 = t[</span><span class="s4">6</span><span class="s2">, </span><span class="s4">6</span><span class="s1">]</span>

    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">COMPLEX_DTYPES:</span>
        <span class="s1">assert_allclose(t</span><span class="s2">, </span><span class="s1">np.triu(t)</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=atol)</span>

    <span class="s1">assert_allclose(z @ t @ z.conj().T</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=atol)</span>

    <span class="s1">result = trexc(t</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(result[-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s1">t = result[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">z = result[-</span><span class="s4">2</span><span class="s1">]</span>

    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">COMPLEX_DTYPES:</span>
        <span class="s1">assert_allclose(t</span><span class="s2">, </span><span class="s1">np.triu(t)</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=atol)</span>

    <span class="s1">assert_allclose(z @ t @ z.conj().T</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=atol)</span>

    <span class="s1">assert_allclose(t[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">d2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=atol)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;t, expect, ifst, ilst&quot;</span><span class="s2">,</span>
    <span class="s1">[(np.array([[</span><span class="s4">0.80</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.11</span><span class="s2">, </span><span class="s4">0.01</span><span class="s2">, </span><span class="s4">0.03</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s4">0.00</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.10</span><span class="s2">, </span><span class="s4">0.25</span><span class="s2">, </span><span class="s4">0.35</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s4">0.00</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.65</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.10</span><span class="s2">, </span><span class="s4">0.20</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s4">0.00</span><span class="s2">, </span><span class="s4">0.00</span><span class="s2">, </span><span class="s4">0.00</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.10</span><span class="s1">]])</span><span class="s2">,</span>
      <span class="s1">np.array([[-</span><span class="s4">0.1000</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.6463</span><span class="s2">, </span><span class="s4">0.0874</span><span class="s2">, </span><span class="s4">0.2010</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s4">0.2514</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.1000</span><span class="s2">, </span><span class="s4">0.0927</span><span class="s2">, </span><span class="s4">0.3505</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s4">0.0000</span><span class="s2">, </span><span class="s4">0.0000</span><span class="s2">, </span><span class="s4">0.8000</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.0117</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s4">0.0000</span><span class="s2">, </span><span class="s4">0.0000</span><span class="s2">, </span><span class="s4">0.0000</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.1000</span><span class="s1">]])</span><span class="s2">,</span>
      <span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
     <span class="s1">(np.array([[-</span><span class="s4">6.00 </span><span class="s1">- </span><span class="s4">7.00j</span><span class="s2">, </span><span class="s4">0.36 </span><span class="s1">- </span><span class="s4">0.36j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.19 </span><span class="s1">+ </span><span class="s4">0.48j</span><span class="s2">, </span><span class="s4">0.88 </span><span class="s1">- </span><span class="s4">0.25j</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s4">0.00 </span><span class="s1">+ </span><span class="s4">0.00j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">5.00 </span><span class="s1">+ </span><span class="s4">2.00j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.03 </span><span class="s1">- </span><span class="s4">0.72j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.23 </span><span class="s1">+ </span><span class="s4">0.13j</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s4">0.00 </span><span class="s1">+ </span><span class="s4">0.00j</span><span class="s2">, </span><span class="s4">0.00 </span><span class="s1">+ </span><span class="s4">0.00j</span><span class="s2">, </span><span class="s4">8.00 </span><span class="s1">- </span><span class="s4">1.00j</span><span class="s2">, </span><span class="s4">0.94 </span><span class="s1">+ </span><span class="s4">0.53j</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s4">0.00 </span><span class="s1">+ </span><span class="s4">0.00j</span><span class="s2">, </span><span class="s4">0.00 </span><span class="s1">+ </span><span class="s4">0.00j</span><span class="s2">, </span><span class="s4">0.00 </span><span class="s1">+ </span><span class="s4">0.00j</span><span class="s2">, </span><span class="s4">3.00 </span><span class="s1">- </span><span class="s4">4.00j</span><span class="s1">]])</span><span class="s2">,</span>
      <span class="s1">np.array([[-</span><span class="s4">5.0000 </span><span class="s1">+ </span><span class="s4">2.0000j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.1574 </span><span class="s1">+ </span><span class="s4">0.7143j</span><span class="s2">,</span>
                 <span class="s4">0.1781 </span><span class="s1">- </span><span class="s4">0.1913j</span><span class="s2">, </span><span class="s4">0.3950 </span><span class="s1">+ </span><span class="s4">0.3861j</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s4">0.0000 </span><span class="s1">+ </span><span class="s4">0.0000j</span><span class="s2">, </span><span class="s4">8.0000 </span><span class="s1">- </span><span class="s4">1.0000j</span><span class="s2">,</span>
                 <span class="s4">1.0742 </span><span class="s1">+ </span><span class="s4">0.1447j</span><span class="s2">, </span><span class="s4">0.2515 </span><span class="s1">- </span><span class="s4">0.3397j</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s4">0.0000 </span><span class="s1">+ </span><span class="s4">0.0000j</span><span class="s2">, </span><span class="s4">0.0000 </span><span class="s1">+ </span><span class="s4">0.0000j</span><span class="s2">,</span>
                 <span class="s4">3.0000 </span><span class="s1">- </span><span class="s4">4.0000j</span><span class="s2">, </span><span class="s4">0.2264 </span><span class="s1">+ </span><span class="s4">0.8962j</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s4">0.0000 </span><span class="s1">+ </span><span class="s4">0.0000j</span><span class="s2">, </span><span class="s4">0.0000 </span><span class="s1">+ </span><span class="s4">0.0000j</span><span class="s2">,</span>
                 <span class="s4">0.0000 </span><span class="s1">+ </span><span class="s4">0.0000j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">6.0000 </span><span class="s1">- </span><span class="s4">7.0000j</span><span class="s1">]])</span><span class="s2">,</span>
      <span class="s4">1</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)])</span>
<span class="s2">def </span><span class="s1">test_trexc_NAG(t</span><span class="s2">, </span><span class="s1">ifst</span><span class="s2">, </span><span class="s1">ilst</span><span class="s2">, </span><span class="s1">expect):</span>
    <span class="s5">&quot;&quot;&quot; 
    This test implements the example found in the NAG manual, 
    f08qfc, f08qtc, f08qgc, f08quc. 
    &quot;&quot;&quot;</span>
    <span class="s0"># NAG manual provides accuracy up to 4 decimals</span>
    <span class="s1">atol = </span><span class="s4">1e-4</span>
    <span class="s1">trexc = get_lapack_funcs(</span><span class="s3">'trexc'</span><span class="s2">, </span><span class="s1">dtype=t.dtype)</span>

    <span class="s1">result = trexc(t</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">ifst</span><span class="s2">, </span><span class="s1">ilst</span><span class="s2">, </span><span class="s1">wantq=</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">assert_equal(result[-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s1">t = result[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">assert_allclose(expect</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">atol=atol)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'dtype'</span><span class="s2">, </span><span class="s1">DTYPES)</span>
<span class="s2">def </span><span class="s1">test_gges_tgexc(dtype):</span>
    <span class="s2">if </span><span class="s1">(</span>
        <span class="s1">dtype == np.float32 </span><span class="s2">and</span>
        <span class="s1">sys.platform == </span><span class="s3">'darwin' </span><span class="s2">and</span>
        <span class="s1">blas_provider == </span><span class="s3">'openblas' </span><span class="s2">and</span>
        <span class="s1">blas_version &lt; </span><span class="s3">'0.3.21.dev'</span>
    <span class="s1">):</span>
        <span class="s1">pytest.xfail(</span><span class="s3">&quot;gges[float32] broken for OpenBLAS on macOS, see gh-16949&quot;</span><span class="s1">)</span>

    <span class="s1">seed(</span><span class="s4">1234</span><span class="s1">)</span>
    <span class="s1">atol = np.finfo(dtype).eps*</span><span class="s4">100</span>

    <span class="s1">n = </span><span class="s4">10</span>
    <span class="s1">a = generate_random_dtype_array([n</span><span class="s2">, </span><span class="s1">n]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">b = generate_random_dtype_array([n</span><span class="s2">, </span><span class="s1">n]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

    <span class="s1">gges</span><span class="s2">, </span><span class="s1">tgexc = get_lapack_funcs((</span><span class="s3">'gges'</span><span class="s2">, </span><span class="s3">'tgexc'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

    <span class="s1">result = gges(</span><span class="s2">lambda </span><span class="s1">x: </span><span class="s2">None, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">overwrite_a=</span><span class="s2">False, </span><span class="s1">overwrite_b=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">assert_equal(result[-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s1">s = result[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">t = result[</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">q = result[-</span><span class="s4">4</span><span class="s1">]</span>
    <span class="s1">z = result[-</span><span class="s4">3</span><span class="s1">]</span>

    <span class="s1">d1 = s[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] / t[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">d2 = s[</span><span class="s4">6</span><span class="s2">, </span><span class="s4">6</span><span class="s1">] / t[</span><span class="s4">6</span><span class="s2">, </span><span class="s4">6</span><span class="s1">]</span>

    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">COMPLEX_DTYPES:</span>
        <span class="s1">assert_allclose(s</span><span class="s2">, </span><span class="s1">np.triu(s)</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=atol)</span>
        <span class="s1">assert_allclose(t</span><span class="s2">, </span><span class="s1">np.triu(t)</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=atol)</span>

    <span class="s1">assert_allclose(q @ s @ z.conj().T</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=atol)</span>
    <span class="s1">assert_allclose(q @ t @ z.conj().T</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=atol)</span>

    <span class="s1">result = tgexc(s</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(result[-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s1">s = result[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">t = result[</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">q = result[</span><span class="s4">2</span><span class="s1">]</span>
    <span class="s1">z = result[</span><span class="s4">3</span><span class="s1">]</span>

    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">COMPLEX_DTYPES:</span>
        <span class="s1">assert_allclose(s</span><span class="s2">, </span><span class="s1">np.triu(s)</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=atol)</span>
        <span class="s1">assert_allclose(t</span><span class="s2">, </span><span class="s1">np.triu(t)</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=atol)</span>

    <span class="s1">assert_allclose(q @ s @ z.conj().T</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=atol)</span>
    <span class="s1">assert_allclose(q @ t @ z.conj().T</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=atol)</span>

    <span class="s1">assert_allclose(s[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] / t[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">d2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=atol)</span>
    <span class="s1">assert_allclose(s[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">] / t[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">d1</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=atol)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'dtype'</span><span class="s2">, </span><span class="s1">DTYPES)</span>
<span class="s2">def </span><span class="s1">test_gees_trsen(dtype):</span>
    <span class="s1">seed(</span><span class="s4">1234</span><span class="s1">)</span>
    <span class="s1">atol = np.finfo(dtype).eps*</span><span class="s4">100</span>

    <span class="s1">n = </span><span class="s4">10</span>
    <span class="s1">a = generate_random_dtype_array([n</span><span class="s2">, </span><span class="s1">n]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

    <span class="s1">gees</span><span class="s2">, </span><span class="s1">trsen</span><span class="s2">, </span><span class="s1">trsen_lwork = get_lapack_funcs(</span>
        <span class="s1">(</span><span class="s3">'gees'</span><span class="s2">, </span><span class="s3">'trsen'</span><span class="s2">, </span><span class="s3">'trsen_lwork'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

    <span class="s1">result = gees(</span><span class="s2">lambda </span><span class="s1">x: </span><span class="s2">None, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">overwrite_a=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">assert_equal(result[-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s1">t = result[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">z = result[-</span><span class="s4">3</span><span class="s1">]</span>

    <span class="s1">d2 = t[</span><span class="s4">6</span><span class="s2">, </span><span class="s4">6</span><span class="s1">]</span>

    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">COMPLEX_DTYPES:</span>
        <span class="s1">assert_allclose(t</span><span class="s2">, </span><span class="s1">np.triu(t)</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=atol)</span>

    <span class="s1">assert_allclose(z @ t @ z.conj().T</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=atol)</span>

    <span class="s1">select = np.zeros(n)</span>
    <span class="s1">select[</span><span class="s4">6</span><span class="s1">] = </span><span class="s4">1</span>

    <span class="s1">lwork = _compute_lwork(trsen_lwork</span><span class="s2">, </span><span class="s1">select</span><span class="s2">, </span><span class="s1">t)</span>

    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">COMPLEX_DTYPES:</span>
        <span class="s1">result = trsen(select</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">lwork=lwork)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">result = trsen(select</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">lwork=lwork</span><span class="s2">, </span><span class="s1">liwork=lwork[</span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">assert_equal(result[-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s1">t = result[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">z = result[</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">COMPLEX_DTYPES:</span>
        <span class="s1">assert_allclose(t</span><span class="s2">, </span><span class="s1">np.triu(t)</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=atol)</span>

    <span class="s1">assert_allclose(z @ t @ z.conj().T</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=atol)</span>

    <span class="s1">assert_allclose(t[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">d2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=atol)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;t, q, expect, select, expect_s, expect_sep&quot;</span><span class="s2">,</span>
    <span class="s1">[(np.array([[</span><span class="s4">0.7995</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.1144</span><span class="s2">, </span><span class="s4">0.0060</span><span class="s2">, </span><span class="s4">0.0336</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s4">0.0000</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.0994</span><span class="s2">, </span><span class="s4">0.2478</span><span class="s2">, </span><span class="s4">0.3474</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s4">0.0000</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.6483</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.0994</span><span class="s2">, </span><span class="s4">0.2026</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s4">0.0000</span><span class="s2">, </span><span class="s4">0.0000</span><span class="s2">, </span><span class="s4">0.0000</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.1007</span><span class="s1">]])</span><span class="s2">,</span>
      <span class="s1">np.array([[</span><span class="s4">0.6551</span><span class="s2">, </span><span class="s4">0.1037</span><span class="s2">, </span><span class="s4">0.3450</span><span class="s2">, </span><span class="s4">0.6641</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s4">0.5236</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.5807</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.6141</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.1068</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[-</span><span class="s4">0.5362</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.3073</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.2935</span><span class="s2">, </span><span class="s4">0.7293</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s4">0.0956</span><span class="s2">, </span><span class="s4">0.7467</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.6463</span><span class="s2">, </span><span class="s4">0.1249</span><span class="s1">]])</span><span class="s2">,</span>
      <span class="s1">np.array([[</span><span class="s4">0.3500</span><span class="s2">, </span><span class="s4">0.4500</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.1400</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.1700</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s4">0.0900</span><span class="s2">, </span><span class="s4">0.0700</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.5399</span><span class="s2">, </span><span class="s4">0.3500</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[-</span><span class="s4">0.4400</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.3300</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.0300</span><span class="s2">, </span><span class="s4">0.1700</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s4">0.2500</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.3200</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.1300</span><span class="s2">, </span><span class="s4">0.1100</span><span class="s1">]])</span><span class="s2">,</span>
      <span class="s1">np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span><span class="s2">,</span>
      <span class="s4">1.75e+00</span><span class="s2">, </span><span class="s4">3.22e+00</span><span class="s1">)</span><span class="s2">,</span>
     <span class="s1">(np.array([[-</span><span class="s4">6.0004 </span><span class="s1">- </span><span class="s4">6.9999j</span><span class="s2">, </span><span class="s4">0.3637 </span><span class="s1">- </span><span class="s4">0.3656j</span><span class="s2">,</span>
                 <span class="s1">-</span><span class="s4">0.1880 </span><span class="s1">+ </span><span class="s4">0.4787j</span><span class="s2">, </span><span class="s4">0.8785 </span><span class="s1">- </span><span class="s4">0.2539j</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s4">0.0000 </span><span class="s1">+ </span><span class="s4">0.0000j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">5.0000 </span><span class="s1">+ </span><span class="s4">2.0060j</span><span class="s2">,</span>
                 <span class="s1">-</span><span class="s4">0.0307 </span><span class="s1">- </span><span class="s4">0.7217j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.2290 </span><span class="s1">+ </span><span class="s4">0.1313j</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s4">0.0000 </span><span class="s1">+ </span><span class="s4">0.0000j</span><span class="s2">, </span><span class="s4">0.0000 </span><span class="s1">+ </span><span class="s4">0.0000j</span><span class="s2">,</span>
                 <span class="s4">7.9982 </span><span class="s1">- </span><span class="s4">0.9964j</span><span class="s2">, </span><span class="s4">0.9357 </span><span class="s1">+ </span><span class="s4">0.5359j</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s4">0.0000 </span><span class="s1">+ </span><span class="s4">0.0000j</span><span class="s2">, </span><span class="s4">0.0000 </span><span class="s1">+ </span><span class="s4">0.0000j</span><span class="s2">,</span>
                 <span class="s4">0.0000 </span><span class="s1">+ </span><span class="s4">0.0000j</span><span class="s2">, </span><span class="s4">3.0023 </span><span class="s1">- </span><span class="s4">3.9998j</span><span class="s1">]])</span><span class="s2">,</span>
      <span class="s1">np.array([[-</span><span class="s4">0.8347 </span><span class="s1">- </span><span class="s4">0.1364j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.0628 </span><span class="s1">+ </span><span class="s4">0.3806j</span><span class="s2">,</span>
                 <span class="s4">0.2765 </span><span class="s1">- </span><span class="s4">0.0846j</span><span class="s2">, </span><span class="s4">0.0633 </span><span class="s1">- </span><span class="s4">0.2199j</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s4">0.0664 </span><span class="s1">- </span><span class="s4">0.2968j</span><span class="s2">, </span><span class="s4">0.2365 </span><span class="s1">+ </span><span class="s4">0.5240j</span><span class="s2">,</span>
                 <span class="s1">-</span><span class="s4">0.5877 </span><span class="s1">- </span><span class="s4">0.4208j</span><span class="s2">, </span><span class="s4">0.0835 </span><span class="s1">+ </span><span class="s4">0.2183j</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[-</span><span class="s4">0.0362 </span><span class="s1">- </span><span class="s4">0.3215j</span><span class="s2">, </span><span class="s4">0.3143 </span><span class="s1">- </span><span class="s4">0.5473j</span><span class="s2">,</span>
                 <span class="s4">0.0576 </span><span class="s1">- </span><span class="s4">0.5736j</span><span class="s2">, </span><span class="s4">0.0057 </span><span class="s1">- </span><span class="s4">0.4058j</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s4">0.0086 </span><span class="s1">+ </span><span class="s4">0.2958j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.3416 </span><span class="s1">- </span><span class="s4">0.0757j</span><span class="s2">,</span>
                 <span class="s1">-</span><span class="s4">0.1900 </span><span class="s1">- </span><span class="s4">0.1600j</span><span class="s2">, </span><span class="s4">0.8327 </span><span class="s1">- </span><span class="s4">0.1868j</span><span class="s1">]])</span><span class="s2">,</span>
      <span class="s1">np.array([[-</span><span class="s4">3.9702 </span><span class="s1">- </span><span class="s4">5.0406j</span><span class="s2">, </span><span class="s1">-</span><span class="s4">4.1108 </span><span class="s1">+ </span><span class="s4">3.7002j</span><span class="s2">,</span>
                 <span class="s1">-</span><span class="s4">0.3403 </span><span class="s1">+ </span><span class="s4">1.0098j</span><span class="s2">, </span><span class="s4">1.2899 </span><span class="s1">- </span><span class="s4">0.8590j</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s4">0.3397 </span><span class="s1">- </span><span class="s4">1.5006j</span><span class="s2">, </span><span class="s4">1.5201 </span><span class="s1">- </span><span class="s4">0.4301j</span><span class="s2">,</span>
                 <span class="s4">1.8797 </span><span class="s1">- </span><span class="s4">5.3804j</span><span class="s2">, </span><span class="s4">3.3606 </span><span class="s1">+ </span><span class="s4">0.6498j</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s4">3.3101 </span><span class="s1">- </span><span class="s4">3.8506j</span><span class="s2">, </span><span class="s4">2.4996 </span><span class="s1">+ </span><span class="s4">3.4504j</span><span class="s2">,</span>
                 <span class="s4">0.8802 </span><span class="s1">- </span><span class="s4">1.0802j</span><span class="s2">, </span><span class="s4">0.6401 </span><span class="s1">- </span><span class="s4">1.4800j</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[-</span><span class="s4">1.0999 </span><span class="s1">+ </span><span class="s4">0.8199j</span><span class="s2">, </span><span class="s4">1.8103 </span><span class="s1">- </span><span class="s4">1.5905j</span><span class="s2">,</span>
                 <span class="s4">3.2502 </span><span class="s1">+ </span><span class="s4">1.3297j</span><span class="s2">, </span><span class="s4">1.5701 </span><span class="s1">- </span><span class="s4">3.4397j</span><span class="s1">]])</span><span class="s2">,</span>
      <span class="s1">np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span><span class="s2">,</span>
      <span class="s4">1.02e+00</span><span class="s2">, </span><span class="s4">1.82e-01</span><span class="s1">)])</span>
<span class="s2">def </span><span class="s1">test_trsen_NAG(t</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">select</span><span class="s2">, </span><span class="s1">expect</span><span class="s2">, </span><span class="s1">expect_s</span><span class="s2">, </span><span class="s1">expect_sep):</span>
    <span class="s5">&quot;&quot;&quot; 
    This test implements the example found in the NAG manual, 
    f08qgc, f08quc. 
    &quot;&quot;&quot;</span>
    <span class="s0"># NAG manual provides accuracy up to 4 and 2 decimals</span>
    <span class="s1">atol = </span><span class="s4">1e-4</span>
    <span class="s1">atol2 = </span><span class="s4">1e-2</span>
    <span class="s1">trsen</span><span class="s2">, </span><span class="s1">trsen_lwork = get_lapack_funcs(</span>
        <span class="s1">(</span><span class="s3">'trsen'</span><span class="s2">, </span><span class="s3">'trsen_lwork'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=t.dtype)</span>

    <span class="s1">lwork = _compute_lwork(trsen_lwork</span><span class="s2">, </span><span class="s1">select</span><span class="s2">, </span><span class="s1">t)</span>

    <span class="s2">if </span><span class="s1">t.dtype </span><span class="s2">in </span><span class="s1">COMPLEX_DTYPES:</span>
        <span class="s1">result = trsen(select</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">lwork=lwork)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">result = trsen(select</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">lwork=lwork</span><span class="s2">, </span><span class="s1">liwork=lwork[</span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">assert_equal(result[-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s1">t = result[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">q = result[</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s2">if </span><span class="s1">t.dtype </span><span class="s2">in </span><span class="s1">COMPLEX_DTYPES:</span>
        <span class="s1">s = result[</span><span class="s4">4</span><span class="s1">]</span>
        <span class="s1">sep = result[</span><span class="s4">5</span><span class="s1">]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">s = result[</span><span class="s4">5</span><span class="s1">]</span>
        <span class="s1">sep = result[</span><span class="s4">6</span><span class="s1">]</span>

    <span class="s1">assert_allclose(expect</span><span class="s2">, </span><span class="s1">q @ t @ q.conj().T</span><span class="s2">, </span><span class="s1">atol=atol)</span>
    <span class="s1">assert_allclose(expect_s</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">/ s</span><span class="s2">, </span><span class="s1">atol=atol2)</span>
    <span class="s1">assert_allclose(expect_sep</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">/ sep</span><span class="s2">, </span><span class="s1">atol=atol2)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'dtype'</span><span class="s2">, </span><span class="s1">DTYPES)</span>
<span class="s2">def </span><span class="s1">test_gges_tgsen(dtype):</span>
    <span class="s2">if </span><span class="s1">(</span>
        <span class="s1">dtype == np.float32 </span><span class="s2">and</span>
        <span class="s1">sys.platform == </span><span class="s3">'darwin' </span><span class="s2">and</span>
        <span class="s1">blas_provider == </span><span class="s3">'openblas' </span><span class="s2">and</span>
        <span class="s1">blas_version &lt; </span><span class="s3">'0.3.21.dev'</span>
    <span class="s1">):</span>
        <span class="s1">pytest.xfail(</span><span class="s3">&quot;gges[float32] broken for OpenBLAS on macOS, see gh-16949&quot;</span><span class="s1">)</span>

    <span class="s1">seed(</span><span class="s4">1234</span><span class="s1">)</span>
    <span class="s1">atol = np.finfo(dtype).eps*</span><span class="s4">100</span>

    <span class="s1">n = </span><span class="s4">10</span>
    <span class="s1">a = generate_random_dtype_array([n</span><span class="s2">, </span><span class="s1">n]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">b = generate_random_dtype_array([n</span><span class="s2">, </span><span class="s1">n]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

    <span class="s1">gges</span><span class="s2">, </span><span class="s1">tgsen</span><span class="s2">, </span><span class="s1">tgsen_lwork = get_lapack_funcs(</span>
        <span class="s1">(</span><span class="s3">'gges'</span><span class="s2">, </span><span class="s3">'tgsen'</span><span class="s2">, </span><span class="s3">'tgsen_lwork'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

    <span class="s1">result = gges(</span><span class="s2">lambda </span><span class="s1">x: </span><span class="s2">None, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">overwrite_a=</span><span class="s2">False, </span><span class="s1">overwrite_b=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">assert_equal(result[-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s1">s = result[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">t = result[</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">q = result[-</span><span class="s4">4</span><span class="s1">]</span>
    <span class="s1">z = result[-</span><span class="s4">3</span><span class="s1">]</span>

    <span class="s1">d1 = s[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] / t[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">d2 = s[</span><span class="s4">6</span><span class="s2">, </span><span class="s4">6</span><span class="s1">] / t[</span><span class="s4">6</span><span class="s2">, </span><span class="s4">6</span><span class="s1">]</span>

    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">COMPLEX_DTYPES:</span>
        <span class="s1">assert_allclose(s</span><span class="s2">, </span><span class="s1">np.triu(s)</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=atol)</span>
        <span class="s1">assert_allclose(t</span><span class="s2">, </span><span class="s1">np.triu(t)</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=atol)</span>

    <span class="s1">assert_allclose(q @ s @ z.conj().T</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=atol)</span>
    <span class="s1">assert_allclose(q @ t @ z.conj().T</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=atol)</span>

    <span class="s1">select = np.zeros(n)</span>
    <span class="s1">select[</span><span class="s4">6</span><span class="s1">] = </span><span class="s4">1</span>

    <span class="s1">lwork = _compute_lwork(tgsen_lwork</span><span class="s2">, </span><span class="s1">select</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">t)</span>

    <span class="s0"># off-by-one error in LAPACK, see gh-issue #13397</span>
    <span class="s1">lwork = (lwork[</span><span class="s4">0</span><span class="s1">]+</span><span class="s4">1</span><span class="s2">, </span><span class="s1">lwork[</span><span class="s4">1</span><span class="s1">])</span>

    <span class="s1">result = tgsen(select</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">lwork=lwork)</span>
    <span class="s1">assert_equal(result[-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s1">s = result[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">t = result[</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">q = result[-</span><span class="s4">7</span><span class="s1">]</span>
    <span class="s1">z = result[-</span><span class="s4">6</span><span class="s1">]</span>

    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">COMPLEX_DTYPES:</span>
        <span class="s1">assert_allclose(s</span><span class="s2">, </span><span class="s1">np.triu(s)</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=atol)</span>
        <span class="s1">assert_allclose(t</span><span class="s2">, </span><span class="s1">np.triu(t)</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=atol)</span>

    <span class="s1">assert_allclose(q @ s @ z.conj().T</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=atol)</span>
    <span class="s1">assert_allclose(q @ t @ z.conj().T</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=atol)</span>

    <span class="s1">assert_allclose(s[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] / t[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">d2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=atol)</span>
    <span class="s1">assert_allclose(s[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">] / t[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">d1</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=atol)</span>
</pre>
</body>
</html>