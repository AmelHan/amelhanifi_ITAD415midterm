<html>
<head>
<title>parse_jmulti_var_output.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
parse_jmulti_var_output.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">io </span><span class="s0">import </span><span class="s1">open</span>
<span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">re</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">.parse_jmulti_vecm_output </span><span class="s0">import </span><span class="s1">stringify_var_names</span><span class="s0">, </span><span class="s1">sublists</span>

<span class="s1">debug_mode = </span><span class="s0">False</span>

<span class="s1">here = os.path.dirname(os.path.realpath(__file__))</span>


<span class="s0">def </span><span class="s1">print_debug_output(results</span><span class="s0">, </span><span class="s1">dt):</span>
    <span class="s1">print(</span><span class="s2">&quot;</span><span class="s0">\n\n\n</span><span class="s2">DETERMINISTIC TERMS: &quot; </span><span class="s1">+ dt)</span>
    <span class="s1">coefs = results[</span><span class="s2">&quot;est&quot;</span><span class="s1">][</span><span class="s2">&quot;Lagged endogenous term&quot;</span><span class="s1">]</span>
    <span class="s1">print(</span><span class="s2">&quot;coefs:&quot;</span><span class="s1">)</span>
    <span class="s1">print(str(type(coefs)) + str(coefs.shape))</span>
    <span class="s1">print(coefs)</span>
    <span class="s1">print(</span><span class="s2">&quot;se: &quot;</span><span class="s1">)</span>
    <span class="s1">print(results[</span><span class="s2">&quot;se&quot;</span><span class="s1">][</span><span class="s2">&quot;Lagged endogenous term&quot;</span><span class="s1">])</span>
    <span class="s1">print(</span><span class="s2">&quot;t: &quot;</span><span class="s1">)</span>
    <span class="s1">print(results[</span><span class="s2">&quot;t&quot;</span><span class="s1">][</span><span class="s2">&quot;Lagged endogenous term&quot;</span><span class="s1">])</span>
    <span class="s1">print(</span><span class="s2">&quot;p: &quot;</span><span class="s1">)</span>
    <span class="s1">print(results[</span><span class="s2">&quot;p&quot;</span><span class="s1">][</span><span class="s2">&quot;Lagged endogenous term&quot;</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">dt_s_tup_to_string(dt_s_tup):</span>
    <span class="s3">&quot;&quot;&quot; 
 
    Parameters 
    ---------- 
    dt_s_tup : tuple 
        A tuple of length 2. 
        The first entry is a string specifying the deterministic term without 
        any information about seasonal terms (for example &quot;nc&quot; or &quot;c&quot;). 
        The second entry is an int specifying the number of seasons. 
 
    Returns 
    ------- 
    dt_string : str 
        Returns dt_s_tup[0], if dt_s_tup[1] is 0 (i.e. no seasons). 
        If dt_s_tup[1] is &gt; 0 (i.e. there are seasons) add an &quot;s&quot; to the string 
        in dt_s_tup[0] like in the following examples: 
        &quot;nc&quot; --&gt; &quot;ncs&quot; 
        &quot;c&quot; --&gt; &quot;cs&quot; 
        &quot;ct&quot; --&gt; &quot;cst&quot; 
    &quot;&quot;&quot;</span>
    <span class="s1">dt_string = dt_s_tup[</span><span class="s4">0</span><span class="s1">]  </span><span class="s5"># string for identifying the file to parse.</span>
    <span class="s0">if </span><span class="s1">dt_s_tup[</span><span class="s4">1</span><span class="s1">] &gt; </span><span class="s4">0</span><span class="s1">:  </span><span class="s5"># if there are seasons in the model</span>
        <span class="s0">if </span><span class="s1">dt_string == </span><span class="s2">&quot;nc&quot;</span><span class="s1">:</span>
            <span class="s1">dt_string = dt_string[:</span><span class="s4">2</span><span class="s1">] + </span><span class="s2">&quot;s&quot;</span>
        <span class="s0">if </span><span class="s1">dt_string == </span><span class="s2">&quot;c&quot; </span><span class="s0">or </span><span class="s1">dt_string == </span><span class="s2">&quot;ct&quot;</span><span class="s1">:</span>
            <span class="s1">dt_string = dt_string[:</span><span class="s4">1</span><span class="s1">] + </span><span class="s2">&quot;s&quot; </span><span class="s1">+ dt_string[</span><span class="s4">1</span><span class="s1">:]</span>
    <span class="s0">return </span><span class="s1">dt_string</span>


<span class="s0">def </span><span class="s1">load_results_jmulti(dataset</span><span class="s0">, </span><span class="s1">dt_s_list):</span>
    <span class="s3">&quot;&quot;&quot; 
 
    Parameters 
    ---------- 
    dataset : module 
        A data module in the statsmodels/datasets directory that defines a 
        __str__() method returning the dataset's name. 
    dt_s_list : list 
        A list of strings where each string represents a combination of 
        deterministic terms. 
 
    Returns 
    ------- 
    result : dict 
        A dict (keys: tuples of deterministic terms and seasonal terms) 
        of dicts (keys: strings &quot;est&quot; (for estimators), 
                              &quot;se&quot; (for standard errors), 
                              &quot;t&quot; (for t-values), 
                              &quot;p&quot; (for p-values)) 
        of dicts (keys: strings &quot;alpha&quot;, &quot;beta&quot;, &quot;Gamma&quot; and other results) 
    &quot;&quot;&quot;</span>
    <span class="s1">source = </span><span class="s2">&quot;jmulti&quot;</span>

    <span class="s1">results_dict_per_det_terms = dict.fromkeys(dt_s_list)</span>

    <span class="s0">for </span><span class="s1">dt_s </span><span class="s0">in </span><span class="s1">dt_s_list:</span>
        <span class="s1">dt_string = dt_s_tup_to_string(dt_s)</span>
        <span class="s1">params_file = dataset.__str__()+</span><span class="s2">&quot;_&quot;</span><span class="s1">+source+</span><span class="s2">&quot;_&quot;</span><span class="s1">+dt_string+</span><span class="s2">&quot;.txt&quot;</span>
        <span class="s1">params_file = os.path.join(here</span><span class="s0">, </span><span class="s1">params_file)</span>
        <span class="s5"># sections in jmulti output:</span>
        <span class="s1">section_headers = [</span><span class="s2">&quot;Lagged endogenous term&quot;</span><span class="s0">,  </span><span class="s5"># parameter matrices</span>
                           <span class="s2">&quot;Deterministic term&quot;</span><span class="s1">]      </span><span class="s5"># c, s, ct</span>
        <span class="s0">if </span><span class="s1">dt_string == </span><span class="s2">&quot;nc&quot;</span><span class="s1">:</span>
            <span class="s0">del </span><span class="s1">section_headers[-</span><span class="s4">1</span><span class="s1">]</span>

        <span class="s1">results = dict()</span>
        <span class="s1">results[</span><span class="s2">&quot;est&quot;</span><span class="s1">] = dict.fromkeys(section_headers)</span>
        <span class="s1">results[</span><span class="s2">&quot;se&quot;</span><span class="s1">] = dict.fromkeys(section_headers)</span>
        <span class="s1">results[</span><span class="s2">&quot;t&quot;</span><span class="s1">] = dict.fromkeys(section_headers)</span>
        <span class="s1">results[</span><span class="s2">&quot;p&quot;</span><span class="s1">] = dict.fromkeys(section_headers)</span>
        <span class="s1">result = []</span>
        <span class="s1">result_se = []</span>
        <span class="s1">result_t = []</span>
        <span class="s1">result_p = []</span>

        <span class="s1">rows = </span><span class="s4">0</span>
        <span class="s1">started_reading_section = </span><span class="s0">False</span>
        <span class="s1">start_end_mark = </span><span class="s2">&quot;-----&quot;</span>

        <span class="s5"># ---------------------------------------------------------------------</span>
        <span class="s5"># parse information about \alpha, \beta, \Gamma, deterministic of VECM</span>
        <span class="s5"># and A_i and deterministic of corresponding VAR:</span>
        <span class="s1">section = -</span><span class="s4">1</span>
        <span class="s1">params_file = open(params_file</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s2">'latin_1'</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">params_file:</span>
            <span class="s0">if </span><span class="s1">section == -</span><span class="s4">1 </span><span class="s0">and </span><span class="s1">section_headers[section+</span><span class="s4">1</span><span class="s1">] </span><span class="s0">not in </span><span class="s1">line:</span>
                <span class="s0">continue</span>
            <span class="s0">if </span><span class="s1">section &lt; len(section_headers)-</span><span class="s4">1 </span><span class="s1">\</span>
                    <span class="s0">and </span><span class="s1">section_headers[section+</span><span class="s4">1</span><span class="s1">] </span><span class="s0">in </span><span class="s1">line:  </span><span class="s5"># new section</span>
                <span class="s1">section += </span><span class="s4">1</span>
                <span class="s0">continue</span>
            <span class="s0">if not </span><span class="s1">started_reading_section:</span>
                <span class="s0">if </span><span class="s1">line.startswith(start_end_mark):</span>
                    <span class="s1">started_reading_section = </span><span class="s0">True</span>
                <span class="s0">continue</span>
            <span class="s0">if </span><span class="s1">started_reading_section:</span>
                <span class="s0">if </span><span class="s1">line.startswith(start_end_mark):</span>
                    <span class="s0">if </span><span class="s1">result == []:  </span><span class="s5"># no values collected in section &quot;Legend&quot;</span>
                        <span class="s1">started_reading_section = </span><span class="s0">False</span>
                        <span class="s0">continue</span>
                    <span class="s1">results[</span><span class="s2">&quot;est&quot;</span><span class="s1">][section_headers[section]] = np.column_stack(</span>
                            <span class="s1">result)</span>
                    <span class="s1">result = []</span>
                    <span class="s1">results[</span><span class="s2">&quot;se&quot;</span><span class="s1">][section_headers[section]] = np.column_stack(</span>
                            <span class="s1">result_se)</span>
                    <span class="s1">result_se = []</span>
                    <span class="s1">results[</span><span class="s2">&quot;t&quot;</span><span class="s1">][section_headers[section]] = np.column_stack(</span>
                            <span class="s1">result_t)</span>
                    <span class="s1">result_t = []</span>
                    <span class="s1">results[</span><span class="s2">&quot;p&quot;</span><span class="s1">][section_headers[section]] = np.column_stack(</span>
                            <span class="s1">result_p)</span>
                    <span class="s1">result_p = []</span>
                    <span class="s1">started_reading_section = </span><span class="s0">False</span>
                    <span class="s0">continue</span>
                <span class="s1">str_number = </span><span class="s2">r&quot;-?\d+\.\d{3}&quot;</span>
                <span class="s1">regex_est = re.compile(str_number + </span><span class="s2">r&quot;[^\)\]\}]&quot;</span><span class="s1">)</span>
                <span class="s1">est_col = re.findall(regex_est</span><span class="s0">, </span><span class="s1">line)</span>
                <span class="s5"># standard errors in parantheses in JMulTi output:</span>
                <span class="s1">regex_se = re.compile(</span><span class="s2">r&quot;\(&quot; </span><span class="s1">+ str_number + </span><span class="s2">r&quot;\)&quot;</span><span class="s1">)</span>
                <span class="s1">se_col = re.findall(regex_se</span><span class="s0">, </span><span class="s1">line)</span>
                <span class="s5"># t-values in brackets in JMulTi output:</span>
                <span class="s1">regex_t_value = re.compile(</span><span class="s2">r&quot;\[&quot; </span><span class="s1">+ str_number + </span><span class="s2">r&quot;\]&quot;</span><span class="s1">)</span>
                <span class="s1">t_col = re.findall(regex_t_value</span><span class="s0">, </span><span class="s1">line)</span>
                <span class="s5"># p-values in braces in JMulTi output:</span>
                <span class="s1">regex_p_value = re.compile(</span><span class="s2">r&quot;\{&quot; </span><span class="s1">+ str_number + </span><span class="s2">r&quot;\}&quot;</span><span class="s1">)</span>
                <span class="s1">p_col = re.findall(regex_p_value</span><span class="s0">, </span><span class="s1">line)</span>
                <span class="s0">if </span><span class="s1">result == [] </span><span class="s0">and </span><span class="s1">est_col != []:</span>
                    <span class="s1">rows = len(est_col)</span>
                <span class="s0">if </span><span class="s1">est_col != []:</span>
                    <span class="s1">est_col = [float(el) </span><span class="s0">for </span><span class="s1">el </span><span class="s0">in </span><span class="s1">est_col]</span>
                    <span class="s1">result.append(est_col)</span>
                <span class="s0">elif </span><span class="s1">se_col != []:</span>
                    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(rows):</span>
                        <span class="s1">se_col[i] = se_col[i].replace(</span><span class="s2">&quot;(&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">).replace(</span><span class="s2">&quot;)&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
                    <span class="s1">se_col = [float(el) </span><span class="s0">for </span><span class="s1">el </span><span class="s0">in </span><span class="s1">se_col]</span>
                    <span class="s1">result_se.append(se_col)</span>
                <span class="s0">elif </span><span class="s1">t_col != []:</span>
                    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(rows):</span>
                        <span class="s1">t_col[i] = t_col[i].replace(</span><span class="s2">&quot;[&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">).replace(</span><span class="s2">&quot;]&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
                    <span class="s1">t_col = [float(el) </span><span class="s0">for </span><span class="s1">el </span><span class="s0">in </span><span class="s1">t_col]</span>
                    <span class="s1">result_t.append(t_col)</span>
                <span class="s0">elif </span><span class="s1">p_col != []:</span>
                    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(rows):</span>
                        <span class="s1">p_col[i] = p_col[i].replace(</span><span class="s2">&quot;{&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">).replace(</span><span class="s2">&quot;}&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
                    <span class="s1">p_col = [float(el) </span><span class="s0">for </span><span class="s1">el </span><span class="s0">in </span><span class="s1">p_col]</span>
                    <span class="s1">result_p.append(p_col)</span>
        <span class="s1">params_file.close()</span>

        <span class="s5"># ---------------------------------------------------------------------</span>
        <span class="s5"># parse information regarding \Sigma_u</span>
        <span class="s1">sigmau_file = dataset.__str__() + </span><span class="s2">&quot;_&quot; </span><span class="s1">+ source + </span><span class="s2">&quot;_&quot; </span><span class="s1">+ dt_string \</span>
            <span class="s1">+ </span><span class="s2">&quot;_Sigmau&quot; </span><span class="s1">+ </span><span class="s2">&quot;.txt&quot;</span>
        <span class="s1">sigmau_file = os.path.join(here</span><span class="s0">, </span><span class="s1">sigmau_file)</span>
        <span class="s1">rows_to_parse = </span><span class="s4">0</span>
        <span class="s5"># all numbers of Sigma_u in notation with e (e.g. 2.283862e-05)</span>
        <span class="s1">regex_est = re.compile(</span><span class="s2">r&quot;\s+\S+e\S+&quot;</span><span class="s1">)</span>
        <span class="s1">sigmau_section_reached = </span><span class="s0">False</span>
        <span class="s1">sigmau_file = open(sigmau_file</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s2">'latin_1'</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">sigmau_file:</span>
            <span class="s0">if </span><span class="s1">line.startswith(</span><span class="s2">&quot;Log Likelihood:&quot;</span><span class="s1">):</span>
                <span class="s1">line = line[len(</span><span class="s2">&quot;Log Likelihood:&quot;</span><span class="s1">):]</span>
                <span class="s1">results[</span><span class="s2">&quot;log_like&quot;</span><span class="s1">] = float(re.findall(regex_est</span><span class="s0">, </span><span class="s1">line)[</span><span class="s4">0</span><span class="s1">])</span>
                <span class="s0">continue</span>
            <span class="s0">if not </span><span class="s1">sigmau_section_reached </span><span class="s0">and </span><span class="s2">&quot;Covariance:&quot; </span><span class="s0">not in </span><span class="s1">line:</span>
                <span class="s0">continue</span>
            <span class="s0">if </span><span class="s2">&quot;Covariance:&quot; </span><span class="s0">in </span><span class="s1">line:</span>
                <span class="s1">sigmau_section_reached = </span><span class="s0">True</span>
                <span class="s1">row = re.findall(regex_est</span><span class="s0">, </span><span class="s1">line)</span>
                <span class="s1">rows_to_parse = len(row)  </span><span class="s5"># Sigma_u quadratic ==&gt; #rows==#cols</span>
                <span class="s1">sigma_u = np.empty((rows_to_parse</span><span class="s0">, </span><span class="s1">rows_to_parse))</span>
            <span class="s1">row = re.findall(regex_est</span><span class="s0">, </span><span class="s1">line)</span>
            <span class="s1">rows_to_parse -= </span><span class="s4">1</span>
            <span class="s1">sigma_u[rows_to_parse] = row  </span><span class="s5"># rows are added in reverse order...</span>
            <span class="s0">if </span><span class="s1">rows_to_parse == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s0">break</span>
        <span class="s1">sigmau_file.close()</span>
        <span class="s1">results[</span><span class="s2">&quot;est&quot;</span><span class="s1">][</span><span class="s2">&quot;Sigma_u&quot;</span><span class="s1">] = sigma_u[::-</span><span class="s4">1</span><span class="s1">]  </span><span class="s5"># ...and reversed again here</span>

        <span class="s5"># ---------------------------------------------------------------------</span>
        <span class="s5"># parse forecast related output:</span>
        <span class="s1">fc_file = dataset.__str__() + </span><span class="s2">&quot;_&quot; </span><span class="s1">+ source + </span><span class="s2">&quot;_&quot; </span><span class="s1">+ dt_string \</span>
            <span class="s1">+ </span><span class="s2">&quot;_fc5&quot; </span><span class="s1">+ </span><span class="s2">&quot;.txt&quot;</span>
        <span class="s1">fc_file = os.path.join(here</span><span class="s0">, </span><span class="s1">fc_file)</span>
        <span class="s1">fc</span><span class="s0">, </span><span class="s1">lower</span><span class="s0">, </span><span class="s1">upper</span><span class="s0">, </span><span class="s1">plu_min = []</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">[]</span>
        <span class="s1">fc_file = open(fc_file</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s2">'latin_1'</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">fc_file:</span>
            <span class="s1">str_number = </span><span class="s2">r&quot;(\s+-?\d+\.\d{3}\s*)&quot;</span>
            <span class="s1">regex_number = re.compile(str_number)</span>
            <span class="s1">numbers = re.findall(regex_number</span><span class="s0">, </span><span class="s1">line)</span>
            <span class="s0">if </span><span class="s1">numbers == []:</span>
                <span class="s0">continue</span>
            <span class="s1">fc.append(float(numbers[</span><span class="s4">0</span><span class="s1">]))</span>
            <span class="s1">lower.append(float(numbers[</span><span class="s4">1</span><span class="s1">]))</span>
            <span class="s1">upper.append(float(numbers[</span><span class="s4">2</span><span class="s1">]))</span>
            <span class="s1">plu_min.append(float(numbers[</span><span class="s4">3</span><span class="s1">]))</span>
        <span class="s1">fc_file.close()</span>
        <span class="s1">neqs = len(results[</span><span class="s2">&quot;est&quot;</span><span class="s1">][</span><span class="s2">&quot;Sigma_u&quot;</span><span class="s1">])</span>
        <span class="s1">fc = np.hstack(np.vsplit(np.array(fc)[:</span><span class="s0">, None</span><span class="s1">]</span><span class="s0">, </span><span class="s1">neqs))</span>
        <span class="s1">lower = np.hstack(np.vsplit(np.array(lower)[:</span><span class="s0">, None</span><span class="s1">]</span><span class="s0">, </span><span class="s1">neqs))</span>
        <span class="s1">upper = np.hstack(np.vsplit(np.array(upper)[:</span><span class="s0">, None</span><span class="s1">]</span><span class="s0">, </span><span class="s1">neqs))</span>
        <span class="s1">results[</span><span class="s2">&quot;fc&quot;</span><span class="s1">] = dict.fromkeys([</span><span class="s2">&quot;fc&quot;</span><span class="s0">, </span><span class="s2">&quot;lower&quot;</span><span class="s0">, </span><span class="s2">&quot;upper&quot;</span><span class="s1">])</span>
        <span class="s1">results[</span><span class="s2">&quot;fc&quot;</span><span class="s1">][</span><span class="s2">&quot;fc&quot;</span><span class="s1">] = fc</span>
        <span class="s1">results[</span><span class="s2">&quot;fc&quot;</span><span class="s1">][</span><span class="s2">&quot;lower&quot;</span><span class="s1">] = lower</span>
        <span class="s1">results[</span><span class="s2">&quot;fc&quot;</span><span class="s1">][</span><span class="s2">&quot;upper&quot;</span><span class="s1">] = upper</span>

        <span class="s5"># ---------------------------------------------------------------------</span>
        <span class="s5"># parse output related to Granger-caus. and instantaneous causality:</span>
        <span class="s1">results[</span><span class="s2">&quot;granger_caus&quot;</span><span class="s1">] = dict.fromkeys([</span><span class="s2">&quot;p&quot;</span><span class="s0">, </span><span class="s2">&quot;test_stat&quot;</span><span class="s1">])</span>
        <span class="s1">results[</span><span class="s2">&quot;granger_caus&quot;</span><span class="s1">][</span><span class="s2">&quot;p&quot;</span><span class="s1">] = dict()</span>
        <span class="s1">results[</span><span class="s2">&quot;granger_caus&quot;</span><span class="s1">][</span><span class="s2">&quot;test_stat&quot;</span><span class="s1">] = dict()</span>
        <span class="s1">results[</span><span class="s2">&quot;inst_caus&quot;</span><span class="s1">] = dict.fromkeys([</span><span class="s2">&quot;p&quot;</span><span class="s0">, </span><span class="s2">&quot;test_stat&quot;</span><span class="s1">])</span>
        <span class="s1">results[</span><span class="s2">&quot;inst_caus&quot;</span><span class="s1">][</span><span class="s2">&quot;p&quot;</span><span class="s1">] = dict()</span>
        <span class="s1">results[</span><span class="s2">&quot;inst_caus&quot;</span><span class="s1">][</span><span class="s2">&quot;test_stat&quot;</span><span class="s1">] = dict()</span>
        <span class="s1">vn = dataset.variable_names</span>
        <span class="s5"># all possible combinations of potentially causing variables</span>
        <span class="s5"># (at least 1 variable and not all variables together):</span>
        <span class="s1">var_combs = sublists(vn</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">len(vn)-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">debug_mode:</span>
            <span class="s1">print(</span><span class="s2">&quot;</span><span class="s0">\n\n\n</span><span class="s2">&quot; </span><span class="s1">+ dt_string)</span>
        <span class="s0">for </span><span class="s1">causing </span><span class="s0">in </span><span class="s1">var_combs:</span>
            <span class="s1">caused = tuple(name </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">vn </span><span class="s0">if </span><span class="s1">name </span><span class="s0">not in </span><span class="s1">causing)</span>
            <span class="s1">causality_file = dataset.__str__() + </span><span class="s2">&quot;_&quot; </span><span class="s1">+ source + </span><span class="s2">&quot;_&quot; </span><span class="s1">\</span>
                <span class="s1">+ dt_string + </span><span class="s2">&quot;_granger_causality_&quot; </span><span class="s1">\</span>
                <span class="s1">+ stringify_var_names(causing</span><span class="s0">, </span><span class="s2">&quot;_&quot;</span><span class="s1">) + </span><span class="s2">&quot;.txt&quot;</span>
            <span class="s1">causality_file = os.path.join(here</span><span class="s0">, </span><span class="s1">causality_file)</span>
            <span class="s1">causality_file = open(causality_file</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s2">&quot;latin_1&quot;</span><span class="s1">)</span>
            <span class="s1">causality_results = []</span>
            <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">causality_file:</span>
                <span class="s1">str_number = </span><span class="s2">r&quot;\d+\.\d{4}&quot;</span>
                <span class="s1">regex_number = re.compile(str_number)</span>
                <span class="s1">number = re.search(regex_number</span><span class="s0">, </span><span class="s1">line)</span>
                <span class="s0">if </span><span class="s1">number </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s0">continue</span>
                <span class="s1">number = float(number.group(</span><span class="s4">0</span><span class="s1">))</span>
                <span class="s1">causality_results.append(number)</span>
            <span class="s1">causality_file.close()</span>
            <span class="s1">results[</span><span class="s2">&quot;granger_caus&quot;</span><span class="s1">][</span><span class="s2">&quot;test_stat&quot;</span><span class="s1">][(causing</span><span class="s0">, </span><span class="s1">caused)] = \</span>
                <span class="s1">causality_results[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">results[</span><span class="s2">&quot;granger_caus&quot;</span><span class="s1">][</span><span class="s2">&quot;p&quot;</span><span class="s1">][(causing</span><span class="s0">, </span><span class="s1">caused)] =\</span>
                <span class="s1">causality_results[</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">results[</span><span class="s2">&quot;inst_caus&quot;</span><span class="s1">][</span><span class="s2">&quot;test_stat&quot;</span><span class="s1">][(causing</span><span class="s0">, </span><span class="s1">caused)] = \</span>
                <span class="s1">causality_results[</span><span class="s4">2</span><span class="s1">]</span>
            <span class="s1">results[</span><span class="s2">&quot;inst_caus&quot;</span><span class="s1">][</span><span class="s2">&quot;p&quot;</span><span class="s1">][(causing</span><span class="s0">, </span><span class="s1">caused)] = \</span>
                <span class="s1">causality_results[</span><span class="s4">3</span><span class="s1">]</span>

        <span class="s5"># ---------------------------------------------------------------------</span>
        <span class="s5"># parse output related to impulse-response analysis:</span>
        <span class="s1">ir_file = dataset.__str__() + </span><span class="s2">&quot;_&quot; </span><span class="s1">+ source + </span><span class="s2">&quot;_&quot; </span><span class="s1">+ dt_string \</span>
            <span class="s1">+ </span><span class="s2">&quot;_ir&quot; </span><span class="s1">+ </span><span class="s2">&quot;.txt&quot;</span>
        <span class="s1">ir_file = os.path.join(here</span><span class="s0">, </span><span class="s1">ir_file)</span>
        <span class="s1">ir_file = open(ir_file</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s2">'latin_1'</span><span class="s1">)</span>
        <span class="s1">causing = </span><span class="s0">None</span>
        <span class="s1">caused = </span><span class="s0">None</span>
        <span class="s1">data = </span><span class="s0">None</span>
        <span class="s1">regex_vars = re.compile(</span><span class="s2">r&quot;\w+&quot;</span><span class="s1">)</span>
        <span class="s1">regex_vals = re.compile(</span><span class="s2">r&quot;-?\d+\.\d{4}&quot;</span><span class="s1">)</span>
        <span class="s1">line_start_causing = </span><span class="s2">&quot;time&quot;</span>
        <span class="s1">data_line_indicator = </span><span class="s2">&quot;point estimate&quot;</span>
        <span class="s1">data_rows_read = </span><span class="s4">0</span>
        <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">ir_file:</span>
            <span class="s0">if </span><span class="s1">causing </span><span class="s0">is None and not </span><span class="s1">line.startswith(line_start_causing):</span>
                <span class="s0">continue  </span><span class="s5"># no relevant info in the header</span>
            <span class="s0">if </span><span class="s1">line.startswith(line_start_causing):</span>
                <span class="s1">line = line[</span><span class="s4">4</span><span class="s1">:]</span>
                <span class="s1">causing = re.findall(regex_vars</span><span class="s0">, </span><span class="s1">line)</span>
                <span class="s5"># 21 periods shown in JMulTi output</span>
                <span class="s1">data = np.empty((</span><span class="s4">21</span><span class="s0">, </span><span class="s1">len(causing)))</span>
                <span class="s0">continue</span>
            <span class="s0">if </span><span class="s1">caused </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">caused = re.findall(regex_vars</span><span class="s0">, </span><span class="s1">line)</span>
                <span class="s0">continue</span>
            <span class="s5"># now start collecting the values:</span>
            <span class="s0">if </span><span class="s1">data_line_indicator </span><span class="s0">not in </span><span class="s1">line:</span>
                <span class="s0">continue</span>
            <span class="s1">start = line.find(data_line_indicator) + len(data_line_indicator)</span>
            <span class="s1">line = line[start:]</span>
            <span class="s1">data[data_rows_read] = re.findall(regex_vals</span><span class="s0">, </span><span class="s1">line)</span>
            <span class="s1">data_rows_read += </span><span class="s4">1</span>
        <span class="s1">ir_file.close()</span>
        <span class="s1">results[</span><span class="s2">&quot;ir&quot;</span><span class="s1">] = data</span>

        <span class="s5"># ---------------------------------------------------------------------</span>
        <span class="s5"># parse output related to lag order selection:</span>
        <span class="s1">lagorder_file = dataset.__str__() + </span><span class="s2">&quot;_&quot; </span><span class="s1">+ source + </span><span class="s2">&quot;_&quot; </span><span class="s1">+ dt_string \</span>
            <span class="s1">+ </span><span class="s2">&quot;_lagorder&quot; </span><span class="s1">+ </span><span class="s2">&quot;.txt&quot;</span>
        <span class="s1">lagorder_file = os.path.join(here</span><span class="s0">, </span><span class="s1">lagorder_file)</span>
        <span class="s1">lagorder_file = open(lagorder_file</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s2">'latin_1'</span><span class="s1">)</span>
        <span class="s1">results[</span><span class="s2">&quot;lagorder&quot;</span><span class="s1">] = dict()</span>
        <span class="s1">aic_start = </span><span class="s2">&quot;Akaike Info Criterion:&quot;</span>
        <span class="s1">fpe_start = </span><span class="s2">&quot;Final Prediction Error:&quot;</span>
        <span class="s1">hqic_start = </span><span class="s2">&quot;Hannan-Quinn Criterion:&quot;</span>
        <span class="s1">bic_start = </span><span class="s2">&quot;Schwarz Criterion:&quot;</span>
        <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">lagorder_file:</span>
            <span class="s0">if </span><span class="s1">line.startswith(aic_start):</span>
                <span class="s1">results[</span><span class="s2">&quot;lagorder&quot;</span><span class="s1">][</span><span class="s2">&quot;aic&quot;</span><span class="s1">] = int(line[len(aic_start):])</span>
            <span class="s0">elif </span><span class="s1">line.startswith(fpe_start):</span>
                <span class="s1">results[</span><span class="s2">&quot;lagorder&quot;</span><span class="s1">][</span><span class="s2">&quot;fpe&quot;</span><span class="s1">] = int(line[len(fpe_start):])</span>
            <span class="s0">elif </span><span class="s1">line.startswith(hqic_start):</span>
                <span class="s1">results[</span><span class="s2">&quot;lagorder&quot;</span><span class="s1">][</span><span class="s2">&quot;hqic&quot;</span><span class="s1">] = int(line[len(hqic_start):])</span>
            <span class="s0">elif </span><span class="s1">line.startswith(bic_start):</span>
                <span class="s1">results[</span><span class="s2">&quot;lagorder&quot;</span><span class="s1">][</span><span class="s2">&quot;bic&quot;</span><span class="s1">] = int(line[len(bic_start):])</span>
        <span class="s1">lagorder_file.close()</span>

        <span class="s5"># ---------------------------------------------------------------------</span>
        <span class="s5"># parse output related to non-normality-test:</span>
        <span class="s1">test_norm_file = dataset.__str__() + </span><span class="s2">&quot;_&quot; </span><span class="s1">+ source + </span><span class="s2">&quot;_&quot; </span><span class="s1">+ dt_string \</span>
            <span class="s1">+ </span><span class="s2">&quot;_diag&quot; </span><span class="s1">+ </span><span class="s2">&quot;.txt&quot;</span>
        <span class="s1">test_norm_file = os.path.join(here</span><span class="s0">, </span><span class="s1">test_norm_file)</span>
        <span class="s1">test_norm_file = open(test_norm_file</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s2">'latin_1'</span><span class="s1">)</span>
        <span class="s1">results[</span><span class="s2">&quot;test_norm&quot;</span><span class="s1">] = dict()</span>
        <span class="s1">section_start_marker = </span><span class="s2">&quot;TESTS FOR NONNORMALITY&quot;</span>
        <span class="s1">section_reached = </span><span class="s0">False</span>
        <span class="s1">subsection_start_marker = </span><span class="s2">&quot;Introduction to Multiple Time Series A&quot;</span>
        <span class="s1">subsection_reached = </span><span class="s0">False</span>
        <span class="s1">line_start_statistic = </span><span class="s2">&quot;joint test statistic:&quot;</span>
        <span class="s1">line_start_pvalue = </span><span class="s2">&quot; p-value:&quot;</span>
        <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">test_norm_file:</span>
            <span class="s0">if not </span><span class="s1">section_reached:</span>
                <span class="s0">if </span><span class="s1">section_start_marker </span><span class="s0">in </span><span class="s1">line:</span>
                    <span class="s1">section_reached = </span><span class="s0">True  </span><span class="s5"># section w/ relevant results found</span>
                <span class="s0">continue</span>
            <span class="s0">if not </span><span class="s1">subsection_reached:</span>
                <span class="s0">if </span><span class="s1">subsection_start_marker </span><span class="s0">in </span><span class="s1">line:</span>
                    <span class="s1">subsection_reached = </span><span class="s0">True</span>
                <span class="s0">continue</span>
            <span class="s0">if </span><span class="s2">&quot;joint_pvalue&quot; </span><span class="s0">in </span><span class="s1">results[</span><span class="s2">&quot;test_norm&quot;</span><span class="s1">].keys():</span>
                <span class="s0">break</span>
            <span class="s0">if </span><span class="s1">line.startswith(line_start_statistic):</span>
                <span class="s1">line_end = line[len(line_start_statistic):]</span>
                <span class="s1">results[</span><span class="s2">&quot;test_norm&quot;</span><span class="s1">][</span><span class="s2">&quot;joint_test_statistic&quot;</span><span class="s1">] = float(line_end)</span>
            <span class="s0">if </span><span class="s1">line.startswith(line_start_pvalue):</span>
                <span class="s1">line_end = line[len(line_start_pvalue):]</span>
                <span class="s1">results[</span><span class="s2">&quot;test_norm&quot;</span><span class="s1">][</span><span class="s2">&quot;joint_pvalue&quot;</span><span class="s1">] = float(line_end)</span>
        <span class="s1">test_norm_file.close()</span>

        <span class="s5"># ---------------------------------------------------------------------</span>
        <span class="s5"># parse output related to testing the whiteness of the residuals:</span>
        <span class="s1">whiteness_file = dataset.__str__() + </span><span class="s2">&quot;_&quot; </span><span class="s1">+ source + </span><span class="s2">&quot;_&quot; </span><span class="s1">+ dt_string \</span>
            <span class="s1">+ </span><span class="s2">&quot;_diag&quot; </span><span class="s1">+ </span><span class="s2">&quot;.txt&quot;</span>
        <span class="s1">whiteness_file = os.path.join(here</span><span class="s0">, </span><span class="s1">whiteness_file)</span>
        <span class="s1">whiteness_file = open(whiteness_file</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s2">'latin_1'</span><span class="s1">)</span>
        <span class="s1">results[</span><span class="s2">&quot;whiteness&quot;</span><span class="s1">] = dict()</span>
        <span class="s1">section_start_marker = </span><span class="s2">&quot;PORTMANTEAU TEST&quot;</span>
        <span class="s1">order_start = </span><span class="s2">&quot;tested order:&quot;</span>
        <span class="s1">statistic_start = </span><span class="s2">&quot;test statistic:&quot;</span>
        <span class="s1">p_start = </span><span class="s2">&quot; p-value:&quot;</span>
        <span class="s1">adj_statistic_start = </span><span class="s2">&quot;adjusted test statistic:&quot;</span>
        <span class="s1">unadjusted_finished = </span><span class="s0">False</span>

        <span class="s1">in_section = </span><span class="s0">False</span>
        <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">whiteness_file:</span>
            <span class="s0">if not </span><span class="s1">in_section </span><span class="s0">and </span><span class="s1">section_start_marker </span><span class="s0">not in </span><span class="s1">line:</span>
                <span class="s0">continue</span>
            <span class="s0">if not </span><span class="s1">in_section </span><span class="s0">and </span><span class="s1">section_start_marker </span><span class="s0">in </span><span class="s1">line:</span>
                <span class="s1">in_section = </span><span class="s0">True</span>
                <span class="s0">continue</span>
            <span class="s0">if </span><span class="s1">line.startswith(order_start):</span>
                <span class="s1">results[</span><span class="s2">&quot;whiteness&quot;</span><span class="s1">][</span><span class="s2">&quot;tested order&quot;</span><span class="s1">] = int(</span>
                        <span class="s1">line[len(order_start):])</span>
                <span class="s0">continue</span>
            <span class="s0">if </span><span class="s1">line.startswith(statistic_start):</span>
                <span class="s1">results[</span><span class="s2">&quot;whiteness&quot;</span><span class="s1">][</span><span class="s2">&quot;test statistic&quot;</span><span class="s1">] = float(</span>
                        <span class="s1">line[len(statistic_start):])</span>
                <span class="s0">continue</span>
            <span class="s0">if </span><span class="s1">line.startswith(adj_statistic_start):</span>
                <span class="s1">results[</span><span class="s2">&quot;whiteness&quot;</span><span class="s1">][</span><span class="s2">&quot;test statistic adj.&quot;</span><span class="s1">] = float(</span>
                        <span class="s1">line[len(adj_statistic_start):])</span>
                <span class="s0">continue</span>
            <span class="s0">if </span><span class="s1">line.startswith(p_start):  </span><span class="s5"># same for unadjusted and adjusted</span>
                <span class="s0">if not </span><span class="s1">unadjusted_finished:</span>
                    <span class="s1">results[</span><span class="s2">&quot;whiteness&quot;</span><span class="s1">][</span><span class="s2">&quot;p-value&quot;</span><span class="s1">] = \</span>
                        <span class="s1">float(line[len(p_start):])</span>
                    <span class="s1">unadjusted_finished = </span><span class="s0">True</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">results[</span><span class="s2">&quot;whiteness&quot;</span><span class="s1">][</span><span class="s2">&quot;p-value adjusted&quot;</span><span class="s1">] = \</span>
                        <span class="s1">float(line[len(p_start):])</span>
                    <span class="s0">break</span>
        <span class="s1">whiteness_file.close()</span>

        <span class="s5"># ---------------------------------------------------------------------</span>
        <span class="s0">if </span><span class="s1">debug_mode:</span>
            <span class="s1">print_debug_output(results</span><span class="s0">, </span><span class="s1">dt_string)</span>

        <span class="s1">results_dict_per_det_terms[dt_s] = results</span>

    <span class="s0">return </span><span class="s1">results_dict_per_det_terms</span>
</pre>
</body>
</html>