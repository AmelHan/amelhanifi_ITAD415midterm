<html>
<head>
<title>test_rbfinterp.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_rbfinterp.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">pickle</span>
<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy.linalg </span><span class="s0">import </span><span class="s1">LinAlgError</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">assert_allclose</span><span class="s0">, </span><span class="s1">assert_array_equal</span>
<span class="s0">from </span><span class="s1">scipy.stats.qmc </span><span class="s0">import </span><span class="s1">Halton</span>
<span class="s0">from </span><span class="s1">scipy.spatial </span><span class="s0">import </span><span class="s1">cKDTree</span>
<span class="s0">from </span><span class="s1">scipy.interpolate._rbfinterp </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">_AVAILABLE</span><span class="s0">, </span><span class="s1">_SCALE_INVARIANT</span><span class="s0">, </span><span class="s1">_NAME_TO_MIN_DEGREE</span><span class="s0">, </span><span class="s1">_monomial_powers</span><span class="s0">,</span>
    <span class="s1">RBFInterpolator</span>
    <span class="s1">)</span>
<span class="s0">from </span><span class="s1">scipy.interpolate </span><span class="s0">import </span><span class="s1">_rbfinterp_pythran</span>


<span class="s0">def </span><span class="s1">_vandermonde(x</span><span class="s0">, </span><span class="s1">degree):</span>
    <span class="s2"># Returns a matrix of monomials that span polynomials with the specified</span>
    <span class="s2"># degree evaluated at x.</span>
    <span class="s1">powers = _monomial_powers(x.shape[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">degree)</span>
    <span class="s0">return </span><span class="s1">_rbfinterp_pythran._polynomial_matrix(x</span><span class="s0">, </span><span class="s1">powers)</span>


<span class="s0">def </span><span class="s1">_1d_test_function(x):</span>
    <span class="s2"># Test function used in Wahba's &quot;Spline Models for Observational Data&quot;.</span>
    <span class="s2"># domain ~= (0, 3), range ~= (-1.0, 0.2)</span>
    <span class="s1">x = x[:</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">y = </span><span class="s3">4.26</span><span class="s1">*(np.exp(-x) - </span><span class="s3">4</span><span class="s1">*np.exp(-</span><span class="s3">2</span><span class="s1">*x) + </span><span class="s3">3</span><span class="s1">*np.exp(-</span><span class="s3">3</span><span class="s1">*x))</span>
    <span class="s0">return </span><span class="s1">y</span>


<span class="s0">def </span><span class="s1">_2d_test_function(x):</span>
    <span class="s2"># Franke's test function.</span>
    <span class="s2"># domain ~= (0, 1) X (0, 1), range ~= (0.0, 1.2)</span>
    <span class="s1">x1</span><span class="s0">, </span><span class="s1">x2 = x[:</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x[:</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span>
    <span class="s1">term1 = </span><span class="s3">0.75 </span><span class="s1">* np.exp(-(</span><span class="s3">9</span><span class="s1">*x1-</span><span class="s3">2</span><span class="s1">)**</span><span class="s3">2</span><span class="s1">/</span><span class="s3">4 </span><span class="s1">- (</span><span class="s3">9</span><span class="s1">*x2-</span><span class="s3">2</span><span class="s1">)**</span><span class="s3">2</span><span class="s1">/</span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">term2 = </span><span class="s3">0.75 </span><span class="s1">* np.exp(-(</span><span class="s3">9</span><span class="s1">*x1+</span><span class="s3">1</span><span class="s1">)**</span><span class="s3">2</span><span class="s1">/</span><span class="s3">49 </span><span class="s1">- (</span><span class="s3">9</span><span class="s1">*x2+</span><span class="s3">1</span><span class="s1">)/</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">term3 = </span><span class="s3">0.5 </span><span class="s1">* np.exp(-(</span><span class="s3">9</span><span class="s1">*x1-</span><span class="s3">7</span><span class="s1">)**</span><span class="s3">2</span><span class="s1">/</span><span class="s3">4 </span><span class="s1">- (</span><span class="s3">9</span><span class="s1">*x2-</span><span class="s3">3</span><span class="s1">)**</span><span class="s3">2</span><span class="s1">/</span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">term4 = -</span><span class="s3">0.2 </span><span class="s1">* np.exp(-(</span><span class="s3">9</span><span class="s1">*x1-</span><span class="s3">4</span><span class="s1">)**</span><span class="s3">2 </span><span class="s1">- (</span><span class="s3">9</span><span class="s1">*x2-</span><span class="s3">7</span><span class="s1">)**</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">y = term1 + term2 + term3 + term4</span>
    <span class="s0">return </span><span class="s1">y</span>


<span class="s0">def </span><span class="s1">_is_conditionally_positive_definite(kernel</span><span class="s0">, </span><span class="s1">m):</span>
    <span class="s2"># Tests whether the kernel is conditionally positive definite of order m.</span>
    <span class="s2"># See chapter 7 of Fasshauer's &quot;Meshfree Approximation Methods with</span>
    <span class="s2"># MATLAB&quot;.</span>
    <span class="s1">nx = </span><span class="s3">10</span>
    <span class="s1">ntests = </span><span class="s3">100</span>
    <span class="s0">for </span><span class="s1">ndim </span><span class="s0">in </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]:</span>
        <span class="s2"># Generate sample points with a Halton sequence to avoid samples that</span>
        <span class="s2"># are too close to eachother, which can make the matrix singular.</span>
        <span class="s1">seq = Halton(ndim</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">False, </span><span class="s1">seed=np.random.RandomState())</span>
        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(ntests):</span>
            <span class="s1">x = </span><span class="s3">2</span><span class="s1">*seq.random(nx) - </span><span class="s3">1</span>
            <span class="s1">A = _rbfinterp_pythran._kernel_matrix(x</span><span class="s0">, </span><span class="s1">kernel)</span>
            <span class="s1">P = _vandermonde(x</span><span class="s0">, </span><span class="s1">m - </span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">Q</span><span class="s0">, </span><span class="s1">R = np.linalg.qr(P</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">'complete'</span><span class="s1">)</span>
            <span class="s2"># Q2 forms a basis spanning the space where P.T.dot(x) = 0. Project</span>
            <span class="s2"># A onto this space, and then see if it is positive definite using</span>
            <span class="s2"># the Cholesky decomposition. If not, then the kernel is not c.p.d.</span>
            <span class="s2"># of order m.</span>
            <span class="s1">Q2 = Q[:</span><span class="s0">, </span><span class="s1">P.shape[</span><span class="s3">1</span><span class="s1">]:]</span>
            <span class="s1">B = Q2.T.dot(A).dot(Q2)</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">np.linalg.cholesky(B)</span>
            <span class="s0">except </span><span class="s1">np.linalg.LinAlgError:</span>
                <span class="s0">return False</span>

    <span class="s0">return True</span>


<span class="s2"># Sorting the parametrize arguments is necessary to avoid a parallelization</span>
<span class="s2"># issue described here: https://github.com/pytest-dev/pytest-xdist/issues/432.</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'kernel'</span><span class="s0">, </span><span class="s1">sorted(_AVAILABLE))</span>
<span class="s0">def </span><span class="s1">test_conditionally_positive_definite(kernel):</span>
    <span class="s2"># Test if each kernel in _AVAILABLE is conditionally positive definite of</span>
    <span class="s2"># order m, where m comes from _NAME_TO_MIN_DEGREE. This is a necessary</span>
    <span class="s2"># condition for the smoothed RBF interpolant to be well-posed in general.</span>
    <span class="s1">m = _NAME_TO_MIN_DEGREE.get(kernel</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">) + </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">_is_conditionally_positive_definite(kernel</span><span class="s0">, </span><span class="s1">m)</span>


<span class="s0">class </span><span class="s1">_TestRBFInterpolator:</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'kernel'</span><span class="s0">, </span><span class="s1">sorted(_SCALE_INVARIANT))</span>
    <span class="s0">def </span><span class="s1">test_scale_invariance_1d(self</span><span class="s0">, </span><span class="s1">kernel):</span>
        <span class="s2"># Verify that the functions in _SCALE_INVARIANT are insensitive to the</span>
        <span class="s2"># shape parameter (when smoothing == 0) in 1d.</span>
        <span class="s1">seq = Halton(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">False, </span><span class="s1">seed=np.random.RandomState())</span>
        <span class="s1">x = </span><span class="s3">3</span><span class="s1">*seq.random(</span><span class="s3">50</span><span class="s1">)</span>
        <span class="s1">y = _1d_test_function(x)</span>
        <span class="s1">xitp = </span><span class="s3">3</span><span class="s1">*seq.random(</span><span class="s3">50</span><span class="s1">)</span>
        <span class="s1">yitp1 = self.build(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">epsilon=</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">kernel=kernel)(xitp)</span>
        <span class="s1">yitp2 = self.build(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">epsilon=</span><span class="s3">2.0</span><span class="s0">, </span><span class="s1">kernel=kernel)(xitp)</span>
        <span class="s1">assert_allclose(yitp1</span><span class="s0">, </span><span class="s1">yitp2</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-8</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'kernel'</span><span class="s0">, </span><span class="s1">sorted(_SCALE_INVARIANT))</span>
    <span class="s0">def </span><span class="s1">test_scale_invariance_2d(self</span><span class="s0">, </span><span class="s1">kernel):</span>
        <span class="s2"># Verify that the functions in _SCALE_INVARIANT are insensitive to the</span>
        <span class="s2"># shape parameter (when smoothing == 0) in 2d.</span>
        <span class="s1">seq = Halton(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">False, </span><span class="s1">seed=np.random.RandomState())</span>
        <span class="s1">x = seq.random(</span><span class="s3">100</span><span class="s1">)</span>
        <span class="s1">y = _2d_test_function(x)</span>
        <span class="s1">xitp = seq.random(</span><span class="s3">100</span><span class="s1">)</span>
        <span class="s1">yitp1 = self.build(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">epsilon=</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">kernel=kernel)(xitp)</span>
        <span class="s1">yitp2 = self.build(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">epsilon=</span><span class="s3">2.0</span><span class="s0">, </span><span class="s1">kernel=kernel)(xitp)</span>
        <span class="s1">assert_allclose(yitp1</span><span class="s0">, </span><span class="s1">yitp2</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-8</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'kernel'</span><span class="s0">, </span><span class="s1">sorted(_AVAILABLE))</span>
    <span class="s0">def </span><span class="s1">test_extreme_domains(self</span><span class="s0">, </span><span class="s1">kernel):</span>
        <span class="s2"># Make sure the interpolant remains numerically stable for very</span>
        <span class="s2"># large/small domains.</span>
        <span class="s1">seq = Halton(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">False, </span><span class="s1">seed=np.random.RandomState())</span>
        <span class="s1">scale = </span><span class="s3">1e50</span>
        <span class="s1">shift = </span><span class="s3">1e55</span>

        <span class="s1">x = seq.random(</span><span class="s3">100</span><span class="s1">)</span>
        <span class="s1">y = _2d_test_function(x)</span>
        <span class="s1">xitp = seq.random(</span><span class="s3">100</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">kernel </span><span class="s0">in </span><span class="s1">_SCALE_INVARIANT:</span>
            <span class="s1">yitp1 = self.build(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">kernel=kernel)(xitp)</span>
            <span class="s1">yitp2 = self.build(</span>
                <span class="s1">x*scale + shift</span><span class="s0">, </span><span class="s1">y</span><span class="s0">,</span>
                <span class="s1">kernel=kernel</span>
                <span class="s1">)(xitp*scale + shift)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">yitp1 = self.build(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">epsilon=</span><span class="s3">5.0</span><span class="s0">, </span><span class="s1">kernel=kernel)(xitp)</span>
            <span class="s1">yitp2 = self.build(</span>
                <span class="s1">x*scale + shift</span><span class="s0">, </span><span class="s1">y</span><span class="s0">,</span>
                <span class="s1">epsilon=</span><span class="s3">5.0</span><span class="s1">/scale</span><span class="s0">,</span>
                <span class="s1">kernel=kernel</span>
                <span class="s1">)(xitp*scale + shift)</span>

        <span class="s1">assert_allclose(yitp1</span><span class="s0">, </span><span class="s1">yitp2</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-8</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_polynomial_reproduction(self):</span>
        <span class="s2"># If the observed data comes from a polynomial, then the interpolant</span>
        <span class="s2"># should be able to reproduce the polynomial exactly, provided that</span>
        <span class="s2"># `degree` is sufficiently high.</span>
        <span class="s1">rng = np.random.RandomState(</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">seq = Halton(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">False, </span><span class="s1">seed=rng)</span>
        <span class="s1">degree = </span><span class="s3">3</span>

        <span class="s1">x = seq.random(</span><span class="s3">50</span><span class="s1">)</span>
        <span class="s1">xitp = seq.random(</span><span class="s3">50</span><span class="s1">)</span>

        <span class="s1">P = _vandermonde(x</span><span class="s0">, </span><span class="s1">degree)</span>
        <span class="s1">Pitp = _vandermonde(xitp</span><span class="s0">, </span><span class="s1">degree)</span>

        <span class="s1">poly_coeffs = rng.normal(</span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">P.shape[</span><span class="s3">1</span><span class="s1">])</span>

        <span class="s1">y = P.dot(poly_coeffs)</span>
        <span class="s1">yitp1 = Pitp.dot(poly_coeffs)</span>
        <span class="s1">yitp2 = self.build(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">degree=degree)(xitp)</span>

        <span class="s1">assert_allclose(yitp1</span><span class="s0">, </span><span class="s1">yitp2</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-8</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s0">def </span><span class="s1">test_chunking(self</span><span class="s0">, </span><span class="s1">monkeypatch):</span>
        <span class="s2"># If the observed data comes from a polynomial, then the interpolant</span>
        <span class="s2"># should be able to reproduce the polynomial exactly, provided that</span>
        <span class="s2"># `degree` is sufficiently high.</span>
        <span class="s1">rng = np.random.RandomState(</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">seq = Halton(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">False, </span><span class="s1">seed=rng)</span>
        <span class="s1">degree = </span><span class="s3">3</span>

        <span class="s1">largeN = </span><span class="s3">1000 </span><span class="s1">+ </span><span class="s3">33</span>
        <span class="s2"># this is large to check that chunking of the RBFInterpolator is tested</span>
        <span class="s1">x = seq.random(</span><span class="s3">50</span><span class="s1">)</span>
        <span class="s1">xitp = seq.random(largeN)</span>

        <span class="s1">P = _vandermonde(x</span><span class="s0">, </span><span class="s1">degree)</span>
        <span class="s1">Pitp = _vandermonde(xitp</span><span class="s0">, </span><span class="s1">degree)</span>

        <span class="s1">poly_coeffs = rng.normal(</span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">P.shape[</span><span class="s3">1</span><span class="s1">])</span>

        <span class="s1">y = P.dot(poly_coeffs)</span>
        <span class="s1">yitp1 = Pitp.dot(poly_coeffs)</span>
        <span class="s1">interp = self.build(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">degree=degree)</span>
        <span class="s1">ce_real = interp._chunk_evaluator</span>

        <span class="s0">def </span><span class="s1">_chunk_evaluator(*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s1">kwargs.update(memory_budget=</span><span class="s3">100</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">ce_real(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s1">monkeypatch.setattr(interp</span><span class="s0">, </span><span class="s4">'_chunk_evaluator'</span><span class="s0">, </span><span class="s1">_chunk_evaluator)</span>
        <span class="s1">yitp2 = interp(xitp)</span>
        <span class="s1">assert_allclose(yitp1</span><span class="s0">, </span><span class="s1">yitp2</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-8</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_vector_data(self):</span>
        <span class="s2"># Make sure interpolating a vector field is the same as interpolating</span>
        <span class="s2"># each component separately.</span>
        <span class="s1">seq = Halton(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">False, </span><span class="s1">seed=np.random.RandomState())</span>

        <span class="s1">x = seq.random(</span><span class="s3">100</span><span class="s1">)</span>
        <span class="s1">xitp = seq.random(</span><span class="s3">100</span><span class="s1">)</span>

        <span class="s1">y = np.array([_2d_test_function(x)</span><span class="s0">,</span>
                      <span class="s1">_2d_test_function(x[:</span><span class="s0">, </span><span class="s1">::-</span><span class="s3">1</span><span class="s1">])]).T</span>

        <span class="s1">yitp1 = self.build(x</span><span class="s0">, </span><span class="s1">y)(xitp)</span>
        <span class="s1">yitp2 = self.build(x</span><span class="s0">, </span><span class="s1">y[:</span><span class="s0">, </span><span class="s3">0</span><span class="s1">])(xitp)</span>
        <span class="s1">yitp3 = self.build(x</span><span class="s0">, </span><span class="s1">y[:</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])(xitp)</span>

        <span class="s1">assert_allclose(yitp1[:</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">yitp2)</span>
        <span class="s1">assert_allclose(yitp1[:</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">yitp3)</span>

    <span class="s0">def </span><span class="s1">test_complex_data(self):</span>
        <span class="s2"># Interpolating complex input should be the same as interpolating the</span>
        <span class="s2"># real and complex components.</span>
        <span class="s1">seq = Halton(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">False, </span><span class="s1">seed=np.random.RandomState())</span>

        <span class="s1">x = seq.random(</span><span class="s3">100</span><span class="s1">)</span>
        <span class="s1">xitp = seq.random(</span><span class="s3">100</span><span class="s1">)</span>

        <span class="s1">y = _2d_test_function(x) + </span><span class="s3">1j</span><span class="s1">*_2d_test_function(x[:</span><span class="s0">, </span><span class="s1">::-</span><span class="s3">1</span><span class="s1">])</span>

        <span class="s1">yitp1 = self.build(x</span><span class="s0">, </span><span class="s1">y)(xitp)</span>
        <span class="s1">yitp2 = self.build(x</span><span class="s0">, </span><span class="s1">y.real)(xitp)</span>
        <span class="s1">yitp3 = self.build(x</span><span class="s0">, </span><span class="s1">y.imag)(xitp)</span>

        <span class="s1">assert_allclose(yitp1.real</span><span class="s0">, </span><span class="s1">yitp2)</span>
        <span class="s1">assert_allclose(yitp1.imag</span><span class="s0">, </span><span class="s1">yitp3)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'kernel'</span><span class="s0">, </span><span class="s1">sorted(_AVAILABLE))</span>
    <span class="s0">def </span><span class="s1">test_interpolation_misfit_1d(self</span><span class="s0">, </span><span class="s1">kernel):</span>
        <span class="s2"># Make sure that each kernel, with its default `degree` and an</span>
        <span class="s2"># appropriate `epsilon`, does a good job at interpolation in 1d.</span>
        <span class="s1">seq = Halton(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">False, </span><span class="s1">seed=np.random.RandomState())</span>

        <span class="s1">x = </span><span class="s3">3</span><span class="s1">*seq.random(</span><span class="s3">50</span><span class="s1">)</span>
        <span class="s1">xitp = </span><span class="s3">3</span><span class="s1">*seq.random(</span><span class="s3">50</span><span class="s1">)</span>

        <span class="s1">y = _1d_test_function(x)</span>
        <span class="s1">ytrue = _1d_test_function(xitp)</span>
        <span class="s1">yitp = self.build(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">epsilon=</span><span class="s3">5.0</span><span class="s0">, </span><span class="s1">kernel=kernel)(xitp)</span>

        <span class="s1">mse = np.mean((yitp - ytrue)**</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">mse &lt; </span><span class="s3">1.0e-4</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'kernel'</span><span class="s0">, </span><span class="s1">sorted(_AVAILABLE))</span>
    <span class="s0">def </span><span class="s1">test_interpolation_misfit_2d(self</span><span class="s0">, </span><span class="s1">kernel):</span>
        <span class="s2"># Make sure that each kernel, with its default `degree` and an</span>
        <span class="s2"># appropriate `epsilon`, does a good job at interpolation in 2d.</span>
        <span class="s1">seq = Halton(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">False, </span><span class="s1">seed=np.random.RandomState())</span>

        <span class="s1">x = seq.random(</span><span class="s3">100</span><span class="s1">)</span>
        <span class="s1">xitp = seq.random(</span><span class="s3">100</span><span class="s1">)</span>

        <span class="s1">y = _2d_test_function(x)</span>
        <span class="s1">ytrue = _2d_test_function(xitp)</span>
        <span class="s1">yitp = self.build(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">epsilon=</span><span class="s3">5.0</span><span class="s0">, </span><span class="s1">kernel=kernel)(xitp)</span>

        <span class="s1">mse = np.mean((yitp - ytrue)**</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">mse &lt; </span><span class="s3">2.0e-4</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'kernel'</span><span class="s0">, </span><span class="s1">sorted(_AVAILABLE))</span>
    <span class="s0">def </span><span class="s1">test_smoothing_misfit(self</span><span class="s0">, </span><span class="s1">kernel):</span>
        <span class="s2"># Make sure we can find a smoothing parameter for each kernel that</span>
        <span class="s2"># removes a sufficient amount of noise.</span>
        <span class="s1">rng = np.random.RandomState(</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">seq = Halton(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">False, </span><span class="s1">seed=rng)</span>

        <span class="s1">noise = </span><span class="s3">0.2</span>
        <span class="s1">rmse_tol = </span><span class="s3">0.1</span>
        <span class="s1">smoothing_range = </span><span class="s3">10</span><span class="s1">**np.linspace(-</span><span class="s3">4</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span>

        <span class="s1">x = </span><span class="s3">3</span><span class="s1">*seq.random(</span><span class="s3">100</span><span class="s1">)</span>
        <span class="s1">y = _1d_test_function(x) + rng.normal(</span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">noise</span><span class="s0">, </span><span class="s1">(</span><span class="s3">100</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">ytrue = _1d_test_function(x)</span>
        <span class="s1">rmse_within_tol = </span><span class="s0">False</span>
        <span class="s0">for </span><span class="s1">smoothing </span><span class="s0">in </span><span class="s1">smoothing_range:</span>
            <span class="s1">ysmooth = self.build(</span>
                <span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">,</span>
                <span class="s1">epsilon=</span><span class="s3">1.0</span><span class="s0">,</span>
                <span class="s1">smoothing=smoothing</span><span class="s0">,</span>
                <span class="s1">kernel=kernel)(x)</span>
            <span class="s1">rmse = np.sqrt(np.mean((ysmooth - ytrue)**</span><span class="s3">2</span><span class="s1">))</span>
            <span class="s0">if </span><span class="s1">rmse &lt; rmse_tol:</span>
                <span class="s1">rmse_within_tol = </span><span class="s0">True</span>
                <span class="s0">break</span>

        <span class="s0">assert </span><span class="s1">rmse_within_tol</span>

    <span class="s0">def </span><span class="s1">test_array_smoothing(self):</span>
        <span class="s2"># Test using an array for `smoothing` to give less weight to a known</span>
        <span class="s2"># outlier.</span>
        <span class="s1">rng = np.random.RandomState(</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">seq = Halton(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">False, </span><span class="s1">seed=rng)</span>
        <span class="s1">degree = </span><span class="s3">2</span>

        <span class="s1">x = seq.random(</span><span class="s3">50</span><span class="s1">)</span>
        <span class="s1">P = _vandermonde(x</span><span class="s0">, </span><span class="s1">degree)</span>
        <span class="s1">poly_coeffs = rng.normal(</span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">P.shape[</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">y = P.dot(poly_coeffs)</span>
        <span class="s1">y_with_outlier = np.copy(y)</span>
        <span class="s1">y_with_outlier[</span><span class="s3">10</span><span class="s1">] += </span><span class="s3">1.0</span>
        <span class="s1">smoothing = np.zeros((</span><span class="s3">50</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">smoothing[</span><span class="s3">10</span><span class="s1">] = </span><span class="s3">1000.0</span>
        <span class="s1">yitp = self.build(x</span><span class="s0">, </span><span class="s1">y_with_outlier</span><span class="s0">, </span><span class="s1">smoothing=smoothing)(x)</span>
        <span class="s2"># Should be able to reproduce the uncorrupted data almost exactly.</span>
        <span class="s1">assert_allclose(yitp</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-4</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_inconsistent_x_dimensions_error(self):</span>
        <span class="s2"># ValueError should be raised if the observation points and evaluation</span>
        <span class="s2"># points have a different number of dimensions.</span>
        <span class="s1">y = Halton(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">False, </span><span class="s1">seed=np.random.RandomState()).random(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">d = _2d_test_function(y)</span>
        <span class="s1">x = Halton(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">False, </span><span class="s1">seed=np.random.RandomState()).random(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">match = </span><span class="s4">'Expected the second axis of `x`'</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=match):</span>
            <span class="s1">self.build(y</span><span class="s0">, </span><span class="s1">d)(x)</span>

    <span class="s0">def </span><span class="s1">test_inconsistent_d_length_error(self):</span>
        <span class="s1">y = np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)[:</span><span class="s0">, None</span><span class="s1">]</span>
        <span class="s1">d = np.zeros(</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">match = </span><span class="s4">'Expected the first axis of `d`'</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=match):</span>
            <span class="s1">self.build(y</span><span class="s0">, </span><span class="s1">d)</span>

    <span class="s0">def </span><span class="s1">test_y_not_2d_error(self):</span>
        <span class="s1">y = np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">d = np.zeros(</span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">match = </span><span class="s4">'`y` must be a 2-dimensional array.'</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=match):</span>
            <span class="s1">self.build(y</span><span class="s0">, </span><span class="s1">d)</span>

    <span class="s0">def </span><span class="s1">test_inconsistent_smoothing_length_error(self):</span>
        <span class="s1">y = np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)[:</span><span class="s0">, None</span><span class="s1">]</span>
        <span class="s1">d = np.zeros(</span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">smoothing = np.ones(</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">match = </span><span class="s4">'Expected `smoothing` to be'</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=match):</span>
            <span class="s1">self.build(y</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">smoothing=smoothing)</span>

    <span class="s0">def </span><span class="s1">test_invalid_kernel_name_error(self):</span>
        <span class="s1">y = np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)[:</span><span class="s0">, None</span><span class="s1">]</span>
        <span class="s1">d = np.zeros(</span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">match = </span><span class="s4">'`kernel` must be one of'</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=match):</span>
            <span class="s1">self.build(y</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">kernel=</span><span class="s4">'test'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_epsilon_not_specified_error(self):</span>
        <span class="s1">y = np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)[:</span><span class="s0">, None</span><span class="s1">]</span>
        <span class="s1">d = np.zeros(</span><span class="s3">5</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">kernel </span><span class="s0">in </span><span class="s1">_AVAILABLE:</span>
            <span class="s0">if </span><span class="s1">kernel </span><span class="s0">in </span><span class="s1">_SCALE_INVARIANT:</span>
                <span class="s0">continue</span>

            <span class="s1">match = </span><span class="s4">'`epsilon` must be specified'</span>
            <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=match):</span>
                <span class="s1">self.build(y</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">kernel=kernel)</span>

    <span class="s0">def </span><span class="s1">test_x_not_2d_error(self):</span>
        <span class="s1">y = np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)[:</span><span class="s0">, None</span><span class="s1">]</span>
        <span class="s1">x = np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">d = np.zeros(</span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">match = </span><span class="s4">'`x` must be a 2-dimensional array.'</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=match):</span>
            <span class="s1">self.build(y</span><span class="s0">, </span><span class="s1">d)(x)</span>

    <span class="s0">def </span><span class="s1">test_not_enough_observations_error(self):</span>
        <span class="s1">y = np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)[:</span><span class="s0">, None</span><span class="s1">]</span>
        <span class="s1">d = np.zeros(</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">match = </span><span class="s4">'At least 2 data points are required'</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=match):</span>
            <span class="s1">self.build(y</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">kernel=</span><span class="s4">'thin_plate_spline'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_degree_warning(self):</span>
        <span class="s1">y = np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)[:</span><span class="s0">, None</span><span class="s1">]</span>
        <span class="s1">d = np.zeros(</span><span class="s3">5</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">kernel</span><span class="s0">, </span><span class="s1">deg </span><span class="s0">in </span><span class="s1">_NAME_TO_MIN_DEGREE.items():</span>
            <span class="s1">match = </span><span class="s4">f'`degree` should not be below </span><span class="s0">{</span><span class="s1">deg</span><span class="s0">}</span><span class="s4">'</span>
            <span class="s0">with </span><span class="s1">pytest.warns(Warning</span><span class="s0">, </span><span class="s1">match=match):</span>
                <span class="s1">self.build(y</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">epsilon=</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">kernel=kernel</span><span class="s0">, </span><span class="s1">degree=deg-</span><span class="s3">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_rank_error(self):</span>
        <span class="s2"># An error should be raised when `kernel` is &quot;thin_plate_spline&quot; and</span>
        <span class="s2"># observations are 2-D and collinear.</span>
        <span class="s1">y = np.array([[</span><span class="s3">2.0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">]])</span>
        <span class="s1">d = np.array([</span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">])</span>
        <span class="s1">match = </span><span class="s4">'does not have full column rank'</span>
        <span class="s0">with </span><span class="s1">pytest.raises(LinAlgError</span><span class="s0">, </span><span class="s1">match=match):</span>
            <span class="s1">self.build(y</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">kernel=</span><span class="s4">'thin_plate_spline'</span><span class="s1">)(y)</span>

    <span class="s0">def </span><span class="s1">test_single_point(self):</span>
        <span class="s2"># Make sure interpolation still works with only one point (in 1, 2, and</span>
        <span class="s2"># 3 dimensions).</span>
        <span class="s0">for </span><span class="s1">dim </span><span class="s0">in </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]:</span>
            <span class="s1">y = np.zeros((</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dim))</span>
            <span class="s1">d = np.ones((</span><span class="s3">1</span><span class="s0">,</span><span class="s1">))</span>
            <span class="s1">f = self.build(y</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">kernel=</span><span class="s4">'linear'</span><span class="s1">)(y)</span>
            <span class="s1">assert_allclose(d</span><span class="s0">, </span><span class="s1">f)</span>

    <span class="s0">def </span><span class="s1">test_pickleable(self):</span>
        <span class="s2"># Make sure we can pickle and unpickle the interpolant without any</span>
        <span class="s2"># changes in the behavior.</span>
        <span class="s1">seq = Halton(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">False, </span><span class="s1">seed=np.random.RandomState(</span><span class="s3">2305982309</span><span class="s1">))</span>

        <span class="s1">x = </span><span class="s3">3</span><span class="s1">*seq.random(</span><span class="s3">50</span><span class="s1">)</span>
        <span class="s1">xitp = </span><span class="s3">3</span><span class="s1">*seq.random(</span><span class="s3">50</span><span class="s1">)</span>

        <span class="s1">y = _1d_test_function(x)</span>

        <span class="s1">interp = self.build(x</span><span class="s0">, </span><span class="s1">y)</span>

        <span class="s1">yitp1 = interp(xitp)</span>
        <span class="s1">yitp2 = pickle.loads(pickle.dumps(interp))(xitp)</span>

        <span class="s1">assert_array_equal(yitp1</span><span class="s0">, </span><span class="s1">yitp2)</span>


<span class="s0">class </span><span class="s1">TestRBFInterpolatorNeighborsNone(_TestRBFInterpolator):</span>
    <span class="s0">def </span><span class="s1">build(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">return </span><span class="s1">RBFInterpolator(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_smoothing_limit_1d(self):</span>
        <span class="s2"># For large smoothing parameters, the interpolant should approach a</span>
        <span class="s2"># least squares fit of a polynomial with the specified degree.</span>
        <span class="s1">seq = Halton(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">False, </span><span class="s1">seed=np.random.RandomState())</span>

        <span class="s1">degree = </span><span class="s3">3</span>
        <span class="s1">smoothing = </span><span class="s3">1e8</span>

        <span class="s1">x = </span><span class="s3">3</span><span class="s1">*seq.random(</span><span class="s3">50</span><span class="s1">)</span>
        <span class="s1">xitp = </span><span class="s3">3</span><span class="s1">*seq.random(</span><span class="s3">50</span><span class="s1">)</span>

        <span class="s1">y = _1d_test_function(x)</span>

        <span class="s1">yitp1 = self.build(</span>
            <span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">,</span>
            <span class="s1">degree=degree</span><span class="s0">,</span>
            <span class="s1">smoothing=smoothing</span>
            <span class="s1">)(xitp)</span>

        <span class="s1">P = _vandermonde(x</span><span class="s0">, </span><span class="s1">degree)</span>
        <span class="s1">Pitp = _vandermonde(xitp</span><span class="s0">, </span><span class="s1">degree)</span>
        <span class="s1">yitp2 = Pitp.dot(np.linalg.lstsq(P</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">rcond=</span><span class="s0">None</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">])</span>

        <span class="s1">assert_allclose(yitp1</span><span class="s0">, </span><span class="s1">yitp2</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-8</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_smoothing_limit_2d(self):</span>
        <span class="s2"># For large smoothing parameters, the interpolant should approach a</span>
        <span class="s2"># least squares fit of a polynomial with the specified degree.</span>
        <span class="s1">seq = Halton(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">False, </span><span class="s1">seed=np.random.RandomState())</span>

        <span class="s1">degree = </span><span class="s3">3</span>
        <span class="s1">smoothing = </span><span class="s3">1e8</span>

        <span class="s1">x = seq.random(</span><span class="s3">100</span><span class="s1">)</span>
        <span class="s1">xitp = seq.random(</span><span class="s3">100</span><span class="s1">)</span>

        <span class="s1">y = _2d_test_function(x)</span>

        <span class="s1">yitp1 = self.build(</span>
            <span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">,</span>
            <span class="s1">degree=degree</span><span class="s0">,</span>
            <span class="s1">smoothing=smoothing</span>
            <span class="s1">)(xitp)</span>

        <span class="s1">P = _vandermonde(x</span><span class="s0">, </span><span class="s1">degree)</span>
        <span class="s1">Pitp = _vandermonde(xitp</span><span class="s0">, </span><span class="s1">degree)</span>
        <span class="s1">yitp2 = Pitp.dot(np.linalg.lstsq(P</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">rcond=</span><span class="s0">None</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">])</span>

        <span class="s1">assert_allclose(yitp1</span><span class="s0">, </span><span class="s1">yitp2</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-8</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestRBFInterpolatorNeighbors20(_TestRBFInterpolator):</span>
    <span class="s2"># RBFInterpolator using 20 nearest neighbors.</span>
    <span class="s0">def </span><span class="s1">build(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">return </span><span class="s1">RBFInterpolator(*args</span><span class="s0">, </span><span class="s1">**kwargs</span><span class="s0">, </span><span class="s1">neighbors=</span><span class="s3">20</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_equivalent_to_rbf_interpolator(self):</span>
        <span class="s1">seq = Halton(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">False, </span><span class="s1">seed=np.random.RandomState())</span>

        <span class="s1">x = seq.random(</span><span class="s3">100</span><span class="s1">)</span>
        <span class="s1">xitp = seq.random(</span><span class="s3">100</span><span class="s1">)</span>

        <span class="s1">y = _2d_test_function(x)</span>

        <span class="s1">yitp1 = self.build(x</span><span class="s0">, </span><span class="s1">y)(xitp)</span>

        <span class="s1">yitp2 = []</span>
        <span class="s1">tree = cKDTree(x)</span>
        <span class="s0">for </span><span class="s1">xi </span><span class="s0">in </span><span class="s1">xitp:</span>
            <span class="s1">_</span><span class="s0">, </span><span class="s1">nbr = tree.query(xi</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span>
            <span class="s1">yitp2.append(RBFInterpolator(x[nbr]</span><span class="s0">, </span><span class="s1">y[nbr])(xi[</span><span class="s0">None</span><span class="s1">])[</span><span class="s3">0</span><span class="s1">])</span>

        <span class="s1">assert_allclose(yitp1</span><span class="s0">, </span><span class="s1">yitp2</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-8</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestRBFInterpolatorNeighborsInf(TestRBFInterpolatorNeighborsNone):</span>
    <span class="s2"># RBFInterpolator using neighbors=np.inf. This should give exactly the same</span>
    <span class="s2"># results as neighbors=None, but it will be slower.</span>
    <span class="s0">def </span><span class="s1">build(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">return </span><span class="s1">RBFInterpolator(*args</span><span class="s0">, </span><span class="s1">**kwargs</span><span class="s0">, </span><span class="s1">neighbors=np.inf)</span>

    <span class="s0">def </span><span class="s1">test_equivalent_to_rbf_interpolator(self):</span>
        <span class="s1">seq = Halton(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">False, </span><span class="s1">seed=np.random.RandomState())</span>

        <span class="s1">x = </span><span class="s3">3</span><span class="s1">*seq.random(</span><span class="s3">50</span><span class="s1">)</span>
        <span class="s1">xitp = </span><span class="s3">3</span><span class="s1">*seq.random(</span><span class="s3">50</span><span class="s1">)</span>

        <span class="s1">y = _1d_test_function(x)</span>
        <span class="s1">yitp1 = self.build(x</span><span class="s0">, </span><span class="s1">y)(xitp)</span>
        <span class="s1">yitp2 = RBFInterpolator(x</span><span class="s0">, </span><span class="s1">y)(xitp)</span>

        <span class="s1">assert_allclose(yitp1</span><span class="s0">, </span><span class="s1">yitp2</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-8</span><span class="s1">)</span>
</pre>
</body>
</html>