<html>
<head>
<title>representation.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
representation.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
State Space Representation 
 
Author: Chad Fulton 
License: Simplified-BSD 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">.tools </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">find_best_blas_type</span><span class="s2">, </span><span class="s1">validate_matrix_shape</span><span class="s2">, </span><span class="s1">validate_vector_shape</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">.initialization </span><span class="s2">import </span><span class="s1">Initialization</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">tools</span>


<span class="s2">class </span><span class="s1">OptionWrapper:</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">mask_attribute</span><span class="s2">, </span><span class="s1">mask_value):</span>
        <span class="s3"># Name of the class-level bitmask attribute</span>
        <span class="s1">self.mask_attribute = mask_attribute</span>
        <span class="s3"># Value of this option</span>
        <span class="s1">self.mask_value = mask_value</span>

    <span class="s2">def </span><span class="s1">__get__(self</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">objtype):</span>
        <span class="s3"># Return True / False based on whether the bit is set in the bitmask</span>
        <span class="s2">return </span><span class="s1">bool(getattr(obj</span><span class="s2">, </span><span class="s1">self.mask_attribute</span><span class="s2">, </span><span class="s4">0</span><span class="s1">) &amp; self.mask_value)</span>

    <span class="s2">def </span><span class="s1">__set__(self</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s1">mask_attribute_value = getattr(obj</span><span class="s2">, </span><span class="s1">self.mask_attribute</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">bool(value):</span>
            <span class="s1">value = mask_attribute_value | self.mask_value</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">value = mask_attribute_value &amp; ~self.mask_value</span>
        <span class="s1">setattr(obj</span><span class="s2">, </span><span class="s1">self.mask_attribute</span><span class="s2">, </span><span class="s1">value)</span>


<span class="s2">class </span><span class="s1">MatrixWrapper:</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attribute):</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.attribute = attribute</span>
        <span class="s1">self._attribute = </span><span class="s5">'_' </span><span class="s1">+ attribute</span>

    <span class="s2">def </span><span class="s1">__get__(self</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">objtype):</span>
        <span class="s1">matrix = getattr(obj</span><span class="s2">, </span><span class="s1">self._attribute</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s3"># # Remove last dimension if the array is not actually time-varying</span>
        <span class="s3"># if matrix is not None and matrix.shape[-1] == 1:</span>
        <span class="s3">#     return np.squeeze(matrix, -1)</span>
        <span class="s2">return </span><span class="s1">matrix</span>

    <span class="s2">def </span><span class="s1">__set__(self</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s1">value = np.asarray(value</span><span class="s2">, </span><span class="s1">order=</span><span class="s5">&quot;F&quot;</span><span class="s1">)</span>
        <span class="s1">shape = obj.shapes[self.attribute]</span>

        <span class="s2">if </span><span class="s1">len(shape) == </span><span class="s4">3</span><span class="s1">:</span>
            <span class="s1">value = self._set_matrix(obj</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">shape)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">value = self._set_vector(obj</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">shape)</span>

        <span class="s1">setattr(obj</span><span class="s2">, </span><span class="s1">self._attribute</span><span class="s2">, </span><span class="s1">value)</span>
        <span class="s1">obj.shapes[self.attribute] = value.shape</span>

    <span class="s2">def </span><span class="s1">_set_matrix(self</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">shape):</span>
        <span class="s3"># Expand 1-dimensional array if possible</span>
        <span class="s2">if </span><span class="s1">(value.ndim == </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">shape[</span><span class="s4">0</span><span class="s1">] == </span><span class="s4">1 </span><span class="s2">and</span>
                <span class="s1">value.shape[</span><span class="s4">0</span><span class="s1">] == shape[</span><span class="s4">1</span><span class="s1">]):</span>
            <span class="s1">value = value[</span><span class="s2">None, </span><span class="s1">:]</span>

        <span class="s3"># Enforce that the matrix is appropriate size</span>
        <span class="s1">validate_matrix_shape(</span>
            <span class="s1">self.name</span><span class="s2">, </span><span class="s1">value.shape</span><span class="s2">, </span><span class="s1">shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">shape[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">obj.nobs</span>
        <span class="s1">)</span>

        <span class="s3"># Expand time-invariant matrix</span>
        <span class="s2">if </span><span class="s1">value.ndim == </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s1">value = np.array(value[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=</span><span class="s5">&quot;F&quot;</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">value</span>

    <span class="s2">def </span><span class="s1">_set_vector(self</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">shape):</span>
        <span class="s3"># Enforce that the vector has appropriate length</span>
        <span class="s1">validate_vector_shape(</span>
            <span class="s1">self.name</span><span class="s2">, </span><span class="s1">value.shape</span><span class="s2">, </span><span class="s1">shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">obj.nobs</span>
        <span class="s1">)</span>

        <span class="s3"># Expand the time-invariant vector</span>
        <span class="s2">if </span><span class="s1">value.ndim == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">value = np.array(value[:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=</span><span class="s5">&quot;F&quot;</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">value</span>


<span class="s2">class </span><span class="s1">Representation:</span>
    <span class="s0">r&quot;&quot;&quot; 
    State space representation of a time series process 
 
    Parameters 
    ---------- 
    k_endog : {array_like, int} 
        The observed time-series process :math:`y` if array like or the 
        number of variables in the process if an integer. 
    k_states : int 
        The dimension of the unobserved state process. 
    k_posdef : int, optional 
        The dimension of a guaranteed positive definite covariance matrix 
        describing the shocks in the measurement equation. Must be less than 
        or equal to `k_states`. Default is `k_states`. 
    initial_variance : float, optional 
        Initial variance used when approximate diffuse initialization is 
        specified. Default is 1e6. 
    initialization : Initialization object or str, optional 
        Initialization method for the initial state. If a string, must be one 
        of {'diffuse', 'approximate_diffuse', 'stationary', 'known'}. 
    initial_state : array_like, optional 
        If `initialization='known'` is used, the mean of the initial state's 
        distribution. 
    initial_state_cov : array_like, optional 
        If `initialization='known'` is used, the covariance matrix of the 
        initial state's distribution. 
    nobs : int, optional 
        If an endogenous vector is not given (i.e. `k_endog` is an integer), 
        the number of observations can optionally be specified. If not 
        specified, they will be set to zero until data is bound to the model. 
    dtype : np.dtype, optional 
        If an endogenous vector is not given (i.e. `k_endog` is an integer), 
        the default datatype of the state space matrices can optionally be 
        specified. Default is `np.float64`. 
    design : array_like, optional 
        The design matrix, :math:`Z`. Default is set to zeros. 
    obs_intercept : array_like, optional 
        The intercept for the observation equation, :math:`d`. Default is set 
        to zeros. 
    obs_cov : array_like, optional 
        The covariance matrix for the observation equation :math:`H`. Default 
        is set to zeros. 
    transition : array_like, optional 
        The transition matrix, :math:`T`. Default is set to zeros. 
    state_intercept : array_like, optional 
        The intercept for the transition equation, :math:`c`. Default is set to 
        zeros. 
    selection : array_like, optional 
        The selection matrix, :math:`R`. Default is set to zeros. 
    state_cov : array_like, optional 
        The covariance matrix for the state equation :math:`Q`. Default is set 
        to zeros. 
    **kwargs 
        Additional keyword arguments. Not used directly. It is present to 
        improve compatibility with subclasses, so that they can use `**kwargs` 
        to specify any default state space matrices (e.g. `design`) without 
        having to clean out any other keyword arguments they might have been 
        passed. 
 
    Attributes 
    ---------- 
    nobs : int 
        The number of observations. 
    k_endog : int 
        The dimension of the observation series. 
    k_states : int 
        The dimension of the unobserved state process. 
    k_posdef : int 
        The dimension of a guaranteed positive 
        definite covariance matrix describing 
        the shocks in the measurement equation. 
    shapes : dictionary of name:tuple 
        A dictionary recording the initial shapes 
        of each of the representation matrices as 
        tuples. 
    initialization : str 
        Kalman filter initialization method. Default is unset. 
    initial_variance : float 
        Initial variance for approximate diffuse 
        initialization. Default is 1e6. 
 
    Notes 
    ----- 
    A general state space model is of the form 
 
    .. math:: 
 
        y_t &amp; = Z_t \alpha_t + d_t + \varepsilon_t \\ 
        \alpha_t &amp; = T_t \alpha_{t-1} + c_t + R_t \eta_t \\ 
 
    where :math:`y_t` refers to the observation vector at time :math:`t`, 
    :math:`\alpha_t` refers to the (unobserved) state vector at time 
    :math:`t`, and where the irregular components are defined as 
 
    .. math:: 
 
        \varepsilon_t \sim N(0, H_t) \\ 
        \eta_t \sim N(0, Q_t) \\ 
 
    The remaining variables (:math:`Z_t, d_t, H_t, T_t, c_t, R_t, Q_t`) in the 
    equations are matrices describing the process. Their variable names and 
    dimensions are as follows 
 
    Z : `design`          :math:`(k\_endog \times k\_states \times nobs)` 
 
    d : `obs_intercept`   :math:`(k\_endog \times nobs)` 
 
    H : `obs_cov`         :math:`(k\_endog \times k\_endog \times nobs)` 
 
    T : `transition`      :math:`(k\_states \times k\_states \times nobs)` 
 
    c : `state_intercept` :math:`(k\_states \times nobs)` 
 
    R : `selection`       :math:`(k\_states \times k\_posdef \times nobs)` 
 
    Q : `state_cov`       :math:`(k\_posdef \times k\_posdef \times nobs)` 
 
    In the case that one of the matrices is time-invariant (so that, for 
    example, :math:`Z_t = Z_{t+1} ~ \forall ~ t`), its last dimension may 
    be of size :math:`1` rather than size `nobs`. 
 
    References 
    ---------- 
    .. [*] Durbin, James, and Siem Jan Koopman. 2012. 
       Time Series Analysis by State Space Methods: Second Edition. 
       Oxford University Press. 
    &quot;&quot;&quot;</span>

    <span class="s1">endog = </span><span class="s2">None</span>
    <span class="s5">r&quot;&quot;&quot; 
    (array) The observation vector, alias for `obs`. 
    &quot;&quot;&quot;</span>
    <span class="s1">design = MatrixWrapper(</span><span class="s5">'design'</span><span class="s2">, </span><span class="s5">'design'</span><span class="s1">)</span>
    <span class="s5">r&quot;&quot;&quot; 
    (array) Design matrix: :math:`Z~(k\_endog \times k\_states \times nobs)` 
    &quot;&quot;&quot;</span>
    <span class="s1">obs_intercept = MatrixWrapper(</span><span class="s5">'observation intercept'</span><span class="s2">, </span><span class="s5">'obs_intercept'</span><span class="s1">)</span>
    <span class="s5">r&quot;&quot;&quot; 
    (array) Observation intercept: :math:`d~(k\_endog \times nobs)` 
    &quot;&quot;&quot;</span>
    <span class="s1">obs_cov = MatrixWrapper(</span><span class="s5">'observation covariance matrix'</span><span class="s2">, </span><span class="s5">'obs_cov'</span><span class="s1">)</span>
    <span class="s5">r&quot;&quot;&quot; 
    (array) Observation covariance matrix: 
    :math:`H~(k\_endog \times k\_endog \times nobs)` 
    &quot;&quot;&quot;</span>
    <span class="s1">transition = MatrixWrapper(</span><span class="s5">'transition'</span><span class="s2">, </span><span class="s5">'transition'</span><span class="s1">)</span>
    <span class="s5">r&quot;&quot;&quot; 
    (array) Transition matrix: 
    :math:`T~(k\_states \times k\_states \times nobs)` 
    &quot;&quot;&quot;</span>
    <span class="s1">state_intercept = MatrixWrapper(</span><span class="s5">'state intercept'</span><span class="s2">, </span><span class="s5">'state_intercept'</span><span class="s1">)</span>
    <span class="s5">r&quot;&quot;&quot; 
    (array) State intercept: :math:`c~(k\_states \times nobs)` 
    &quot;&quot;&quot;</span>
    <span class="s1">selection = MatrixWrapper(</span><span class="s5">'selection'</span><span class="s2">, </span><span class="s5">'selection'</span><span class="s1">)</span>
    <span class="s5">r&quot;&quot;&quot; 
    (array) Selection matrix: 
    :math:`R~(k\_states \times k\_posdef \times nobs)` 
    &quot;&quot;&quot;</span>
    <span class="s1">state_cov = MatrixWrapper(</span><span class="s5">'state covariance matrix'</span><span class="s2">, </span><span class="s5">'state_cov'</span><span class="s1">)</span>
    <span class="s5">r&quot;&quot;&quot; 
    (array) State covariance matrix: 
    :math:`Q~(k\_posdef \times k\_posdef \times nobs)` 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">k_endog</span><span class="s2">, </span><span class="s1">k_states</span><span class="s2">, </span><span class="s1">k_posdef=</span><span class="s2">None,</span>
                 <span class="s1">initial_variance=</span><span class="s4">1e6</span><span class="s2">, </span><span class="s1">nobs=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">dtype=np.float64</span><span class="s2">,</span>
                 <span class="s1">design=</span><span class="s2">None, </span><span class="s1">obs_intercept=</span><span class="s2">None, </span><span class="s1">obs_cov=</span><span class="s2">None,</span>
                 <span class="s1">transition=</span><span class="s2">None, </span><span class="s1">state_intercept=</span><span class="s2">None, </span><span class="s1">selection=</span><span class="s2">None,</span>
                 <span class="s1">state_cov=</span><span class="s2">None, </span><span class="s1">statespace_classes=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s1">self.shapes = {}</span>

        <span class="s3"># Check if k_endog is actually the endog array</span>
        <span class="s1">endog = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">isinstance(k_endog</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
            <span class="s1">endog = k_endog</span>
            <span class="s3"># If so, assume that it is either column-ordered and in wide format</span>
            <span class="s3"># or row-ordered and in long format</span>
            <span class="s2">if </span><span class="s1">(endog.flags[</span><span class="s5">'C_CONTIGUOUS'</span><span class="s1">] </span><span class="s2">and</span>
                    <span class="s1">(endog.shape[</span><span class="s4">0</span><span class="s1">] &gt; </span><span class="s4">1 </span><span class="s2">or </span><span class="s1">nobs == </span><span class="s4">1</span><span class="s1">)):</span>
                <span class="s1">endog = endog.T</span>
            <span class="s1">k_endog = endog.shape[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s3"># Endogenous array, dimensions, dtype</span>
        <span class="s1">self.k_endog = k_endog</span>
        <span class="s2">if </span><span class="s1">k_endog &lt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'Number of endogenous variables in statespace'</span>
                             <span class="s5">' model must be a positive number.'</span><span class="s1">)</span>
        <span class="s1">self.nobs = nobs</span>

        <span class="s3"># Get dimensions from transition equation</span>
        <span class="s2">if </span><span class="s1">k_states &lt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'Number of states in statespace model must be a'</span>
                             <span class="s5">' positive number.'</span><span class="s1">)</span>
        <span class="s1">self.k_states = k_states</span>
        <span class="s1">self.k_posdef = k_posdef </span><span class="s2">if </span><span class="s1">k_posdef </span><span class="s2">is not None else </span><span class="s1">k_states</span>

        <span class="s3"># Make sure k_posdef &lt;= k_states</span>
        <span class="s3"># TODO: we could technically allow k_posdef &gt; k_states, but the Cython</span>
        <span class="s3"># code needs to be more thoroughly checked to avoid seg faults.</span>
        <span class="s2">if </span><span class="s1">self.k_posdef &gt; self.k_states:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'Dimension of state innovation `k_posdef` cannot'</span>
                             <span class="s5">' be larger than the dimension of the state.'</span><span class="s1">)</span>

        <span class="s3"># Bind endog, if it was given</span>
        <span class="s2">if </span><span class="s1">endog </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.bind(endog)</span>

        <span class="s3"># Record the shapes of all of our matrices</span>
        <span class="s3"># Note: these are time-invariant shapes; in practice the last dimension</span>
        <span class="s3"># may also be `self.nobs` for any or all of these.</span>
        <span class="s1">self.shapes = {</span>
            <span class="s5">'obs'</span><span class="s1">: (self.k_endog</span><span class="s2">, </span><span class="s1">self.nobs)</span><span class="s2">,</span>
            <span class="s5">'design'</span><span class="s1">: (self.k_endog</span><span class="s2">, </span><span class="s1">self.k_states</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s5">'obs_intercept'</span><span class="s1">: (self.k_endog</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s5">'obs_cov'</span><span class="s1">: (self.k_endog</span><span class="s2">, </span><span class="s1">self.k_endog</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s5">'transition'</span><span class="s1">: (self.k_states</span><span class="s2">, </span><span class="s1">self.k_states</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s5">'state_intercept'</span><span class="s1">: (self.k_states</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s5">'selection'</span><span class="s1">: (self.k_states</span><span class="s2">, </span><span class="s1">self.k_posdef</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s5">'state_cov'</span><span class="s1">: (self.k_posdef</span><span class="s2">, </span><span class="s1">self.k_posdef</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">}</span>

        <span class="s3"># Representation matrices</span>
        <span class="s3"># These matrices are only used in the Python object as containers,</span>
        <span class="s3"># which will be copied to the appropriate _statespace object if a</span>
        <span class="s3"># filter is called.</span>
        <span class="s1">scope = locals()</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">shape </span><span class="s2">in </span><span class="s1">self.shapes.items():</span>
            <span class="s2">if </span><span class="s1">name == </span><span class="s5">'obs'</span><span class="s1">:</span>
                <span class="s2">continue</span>
            <span class="s3"># Create the initial storage array for each matrix</span>
            <span class="s1">setattr(self</span><span class="s2">, </span><span class="s5">'_' </span><span class="s1">+ name</span><span class="s2">, </span><span class="s1">np.zeros(shape</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">order=</span><span class="s5">&quot;F&quot;</span><span class="s1">))</span>

            <span class="s3"># If we were given an initial value for the matrix, set it</span>
            <span class="s3"># (notice it is being set via the descriptor)</span>
            <span class="s2">if </span><span class="s1">scope[name] </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">scope[name])</span>

        <span class="s3"># Options</span>
        <span class="s1">self.initial_variance = initial_variance</span>
        <span class="s1">self.prefix_statespace_map = (statespace_classes</span>
                                      <span class="s2">if </span><span class="s1">statespace_classes </span><span class="s2">is not None</span>
                                      <span class="s2">else </span><span class="s1">tools.prefix_statespace_map.copy())</span>

        <span class="s3"># State-space initialization data</span>
        <span class="s1">self.initialization = kwargs.pop(</span><span class="s5">'initialization'</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">basic_inits = [</span><span class="s5">'diffuse'</span><span class="s2">, </span><span class="s5">'approximate_diffuse'</span><span class="s2">, </span><span class="s5">'stationary'</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">self.initialization </span><span class="s2">in </span><span class="s1">basic_inits:</span>
            <span class="s1">self.initialize(self.initialization)</span>
        <span class="s2">elif </span><span class="s1">self.initialization == </span><span class="s5">'known'</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s5">'constant' </span><span class="s2">in </span><span class="s1">kwargs:</span>
                <span class="s1">constant = kwargs.pop(</span><span class="s5">'constant'</span><span class="s1">)</span>
            <span class="s2">elif </span><span class="s5">'initial_state' </span><span class="s2">in </span><span class="s1">kwargs:</span>
                <span class="s3"># TODO deprecation warning</span>
                <span class="s1">constant = kwargs.pop(</span><span class="s5">'initial_state'</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'Initial state must be provided when &quot;known&quot;'</span>
                                 <span class="s5">' is the specified initialization method.'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s5">'stationary_cov' </span><span class="s2">in </span><span class="s1">kwargs:</span>
                <span class="s1">stationary_cov = kwargs.pop(</span><span class="s5">'stationary_cov'</span><span class="s1">)</span>
            <span class="s2">elif </span><span class="s5">'initial_state_cov' </span><span class="s2">in </span><span class="s1">kwargs:</span>
                <span class="s3"># TODO deprecation warning</span>
                <span class="s1">stationary_cov = kwargs.pop(</span><span class="s5">'initial_state_cov'</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'Initial state covariance matrix must be'</span>
                                 <span class="s5">' provided when &quot;known&quot; is the specified'</span>
                                 <span class="s5">' initialization method.'</span><span class="s1">)</span>
            <span class="s1">self.initialize(</span><span class="s5">'known'</span><span class="s2">, </span><span class="s1">constant=constant</span><span class="s2">,</span>
                            <span class="s1">stationary_cov=stationary_cov)</span>
        <span class="s2">elif </span><span class="s1">(</span><span class="s2">not </span><span class="s1">isinstance(self.initialization</span><span class="s2">, </span><span class="s1">Initialization) </span><span class="s2">and</span>
                <span class="s1">self.initialization </span><span class="s2">is not None</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Invalid state space initialization method.&quot;</span><span class="s1">)</span>

        <span class="s3"># Check for unused kwargs</span>
        <span class="s2">if </span><span class="s1">len(kwargs):</span>
            <span class="s3"># raise TypeError(f'{__class__} constructor got unexpected keyword'</span>
            <span class="s3">#                 f' argument(s): {kwargs}.')</span>
            <span class="s1">msg = (</span><span class="s5">f'Unknown keyword arguments: </span><span class="s2">{</span><span class="s1">kwargs.keys()</span><span class="s2">}</span><span class="s5">.'</span>
                   <span class="s5">'Passing unknown keyword arguments will raise a TypeError'</span>
                   <span class="s5">' beginning in version 0.15.'</span><span class="s1">)</span>
            <span class="s1">warnings.warn(msg</span><span class="s2">, </span><span class="s1">FutureWarning)</span>

        <span class="s3"># Matrix representations storage</span>
        <span class="s1">self._representations = {}</span>

        <span class="s3"># Setup the underlying statespace object storage</span>
        <span class="s1">self._statespaces = {}</span>

        <span class="s3"># Caches</span>
        <span class="s1">self._time_invariant = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__getitem__(self</span><span class="s2">, </span><span class="s1">key):</span>
        <span class="s1">_type = type(key)</span>
        <span class="s3"># If only a string is given then we must be getting an entire matrix</span>
        <span class="s2">if </span><span class="s1">_type </span><span class="s2">is </span><span class="s1">str:</span>
            <span class="s2">if </span><span class="s1">key </span><span class="s2">not in </span><span class="s1">self.shapes:</span>
                <span class="s2">raise </span><span class="s1">IndexError(</span><span class="s5">'&quot;%s&quot; is an invalid state space matrix name'</span>
                                 <span class="s1">% key)</span>
            <span class="s1">matrix = getattr(self</span><span class="s2">, </span><span class="s5">'_' </span><span class="s1">+ key)</span>

            <span class="s3"># See note on time-varying arrays, below</span>
            <span class="s2">if </span><span class="s1">matrix.shape[-</span><span class="s4">1</span><span class="s1">] == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">matrix[(slice(</span><span class="s2">None</span><span class="s1">)</span><span class="s2">,</span><span class="s1">)*(matrix.ndim-</span><span class="s4">1</span><span class="s1">) + (</span><span class="s4">0</span><span class="s2">,</span><span class="s1">)]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">matrix</span>
        <span class="s3"># Otherwise if we have a tuple, we want a slice of a matrix</span>
        <span class="s2">elif </span><span class="s1">_type </span><span class="s2">is </span><span class="s1">tuple:</span>
            <span class="s1">name</span><span class="s2">, </span><span class="s1">slice_ = key[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">key[</span><span class="s4">1</span><span class="s1">:]</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">self.shapes:</span>
                <span class="s2">raise </span><span class="s1">IndexError(</span><span class="s5">'&quot;%s&quot; is an invalid state space matrix name'</span>
                                 <span class="s1">% name)</span>

            <span class="s1">matrix = getattr(self</span><span class="s2">, </span><span class="s5">'_' </span><span class="s1">+ name)</span>

            <span class="s3"># Since the model can support time-varying arrays, but often we</span>
            <span class="s3"># will instead have time-invariant arrays, we want to allow setting</span>
            <span class="s3"># a matrix slice like mod['transition',0,:] even though technically</span>
            <span class="s3"># it should be mod['transition',0,:,0]. Thus if the array in</span>
            <span class="s3"># question is time-invariant but the last slice was excluded,</span>
            <span class="s3"># add it in as a zero.</span>
            <span class="s2">if </span><span class="s1">matrix.shape[-</span><span class="s4">1</span><span class="s1">] == </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">len(slice_) &lt;= matrix.ndim-</span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">slice_ = slice_ + (</span><span class="s4">0</span><span class="s2">,</span><span class="s1">)</span>

            <span class="s2">return </span><span class="s1">matrix[slice_]</span>
        <span class="s3"># Otherwise, we have only a single slice index, but it is not a string</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">IndexError(</span><span class="s5">'First index must the name of a valid state space'</span>
                             <span class="s5">' matrix.'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__setitem__(self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s1">_type = type(key)</span>
        <span class="s3"># If only a string is given then we must be setting an entire matrix</span>
        <span class="s2">if </span><span class="s1">_type </span><span class="s2">is </span><span class="s1">str:</span>
            <span class="s2">if </span><span class="s1">key </span><span class="s2">not in </span><span class="s1">self.shapes:</span>
                <span class="s2">raise </span><span class="s1">IndexError(</span><span class="s5">'&quot;%s&quot; is an invalid state space matrix name'</span>
                                 <span class="s1">% key)</span>
            <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value)</span>
        <span class="s3"># If it's a tuple (with a string as the first element) then we must be</span>
        <span class="s3"># setting a slice of a matrix</span>
        <span class="s2">elif </span><span class="s1">_type </span><span class="s2">is </span><span class="s1">tuple:</span>
            <span class="s1">name</span><span class="s2">, </span><span class="s1">slice_ = key[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">key[</span><span class="s4">1</span><span class="s1">:]</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">self.shapes:</span>
                <span class="s2">raise </span><span class="s1">IndexError(</span><span class="s5">'&quot;%s&quot; is an invalid state space matrix name'</span>
                                 <span class="s1">% key[</span><span class="s4">0</span><span class="s1">])</span>

            <span class="s3"># Change the dtype of the corresponding matrix</span>
            <span class="s1">dtype = np.array(value).dtype</span>
            <span class="s1">matrix = getattr(self</span><span class="s2">, </span><span class="s5">'_' </span><span class="s1">+ name)</span>
            <span class="s1">valid_types = [</span><span class="s5">'f'</span><span class="s2">, </span><span class="s5">'d'</span><span class="s2">, </span><span class="s5">'F'</span><span class="s2">, </span><span class="s5">'D'</span><span class="s1">]</span>
            <span class="s2">if not </span><span class="s1">matrix.dtype == dtype </span><span class="s2">and </span><span class="s1">dtype.char </span><span class="s2">in </span><span class="s1">valid_types:</span>
                <span class="s1">matrix = getattr(self</span><span class="s2">, </span><span class="s5">'_' </span><span class="s1">+ name).real.astype(dtype)</span>

            <span class="s3"># Since the model can support time-varying arrays, but often we</span>
            <span class="s3"># will instead have time-invariant arrays, we want to allow setting</span>
            <span class="s3"># a matrix slice like mod['transition',0,:] even though technically</span>
            <span class="s3"># it should be mod['transition',0,:,0]. Thus if the array in</span>
            <span class="s3"># question is time-invariant but the last slice was excluded,</span>
            <span class="s3"># add it in as a zero.</span>
            <span class="s2">if </span><span class="s1">matrix.shape[-</span><span class="s4">1</span><span class="s1">] == </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">len(slice_) == matrix.ndim-</span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">slice_ = slice_ + (</span><span class="s4">0</span><span class="s2">,</span><span class="s1">)</span>

            <span class="s3"># Set the new value</span>
            <span class="s1">matrix[slice_] = value</span>
            <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">matrix)</span>
        <span class="s3"># Otherwise we got a single non-string key, (e.g. mod[:]), which is</span>
        <span class="s3"># invalid</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">IndexError(</span><span class="s5">'First index must the name of a valid state space'</span>
                             <span class="s5">' matrix.'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_clone_kwargs(self</span><span class="s2">, </span><span class="s1">endog</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Construct keyword arguments for cloning a state space model 
 
        Parameters 
        ---------- 
        endog : array_like 
            An observed time-series process :math:`y`. 
        **kwargs 
            Keyword arguments to pass to the new state space representation 
            model constructor. Those that are not specified are copied from 
            the specification of the current state space model. 
        &quot;&quot;&quot;</span>

        <span class="s3"># We always need the base dimensions, but they cannot change from</span>
        <span class="s3"># the base model when cloning (the idea is: if these need to change,</span>
        <span class="s3"># need to make a new instance manually, since it's not really cloning).</span>
        <span class="s1">kwargs[</span><span class="s5">'nobs'</span><span class="s1">] = len(endog)</span>
        <span class="s1">kwargs[</span><span class="s5">'k_endog'</span><span class="s1">] = self.k_endog</span>
        <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">[</span><span class="s5">'k_states'</span><span class="s2">, </span><span class="s5">'k_posdef'</span><span class="s1">]:</span>
            <span class="s1">val = getattr(self</span><span class="s2">, </span><span class="s1">key)</span>
            <span class="s2">if </span><span class="s1">key </span><span class="s2">not in </span><span class="s1">kwargs </span><span class="s2">or </span><span class="s1">kwargs[key] </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">kwargs[key] = val</span>
            <span class="s2">if </span><span class="s1">kwargs[key] != val:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'Cannot change the dimension of %s when'</span>
                                 <span class="s5">' cloning.' </span><span class="s1">% key)</span>

        <span class="s3"># Get defaults for time-invariant system matrices, if not otherwise</span>
        <span class="s3"># provided</span>
        <span class="s3"># Time-varying matrices must be replaced.</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.shapes.keys():</span>
            <span class="s2">if </span><span class="s1">name == </span><span class="s5">'obs'</span><span class="s1">:</span>
                <span class="s2">continue</span>

            <span class="s2">if </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">kwargs:</span>
                <span class="s1">mat = getattr(self</span><span class="s2">, </span><span class="s1">name)</span>
                <span class="s2">if </span><span class="s1">mat.shape[-</span><span class="s4">1</span><span class="s1">] != </span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'The `%s` matrix is time-varying. Cloning'</span>
                                     <span class="s5">' this model requires specifying an'</span>
                                     <span class="s5">' updated matrix.' </span><span class="s1">% name)</span>
                <span class="s1">kwargs[name] = mat</span>

        <span class="s3"># Default is to use the same initialization</span>
        <span class="s1">kwargs.setdefault(</span><span class="s5">'initialization'</span><span class="s2">, </span><span class="s1">self.initialization)</span>

        <span class="s2">return </span><span class="s1">kwargs</span>

    <span class="s2">def </span><span class="s1">clone(self</span><span class="s2">, </span><span class="s1">endog</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Clone a state space representation while overriding some elements 
 
        Parameters 
        ---------- 
        endog : array_like 
            An observed time-series process :math:`y`. 
        **kwargs 
            Keyword arguments to pass to the new state space representation 
            model constructor. Those that are not specified are copied from 
            the specification of the current state space model. 
 
        Returns 
        ------- 
        Representation 
 
        Notes 
        ----- 
        If some system matrices are time-varying, then new time-varying 
        matrices *must* be provided. 
        &quot;&quot;&quot;</span>
        <span class="s1">kwargs = self._clone_kwargs(endog</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">mod = self.__class__(**kwargs)</span>
        <span class="s1">mod.bind(endog)</span>
        <span class="s2">return </span><span class="s1">mod</span>

    <span class="s2">def </span><span class="s1">extend(self</span><span class="s2">, </span><span class="s1">endog</span><span class="s2">, </span><span class="s1">start=</span><span class="s2">None, </span><span class="s1">end=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Extend the current state space model, or a specific (time) subset 
 
        Parameters 
        ---------- 
        endog : array_like 
            An observed time-series process :math:`y`. 
        start : int, optional 
            The first period of a time-varying state space model to include in 
            the new model. Has no effect if the state space model is 
            time-invariant. Default is the initial period. 
        end : int, optional 
            The last period of a time-varying state space model to include in 
            the new model. Has no effect if the state space model is 
            time-invariant. Default is the final period. 
        **kwargs 
            Keyword arguments to pass to the new state space representation 
            model constructor. Those that are not specified are copied from 
            the specification of the current state space model. 
 
        Returns 
        ------- 
        Representation 
 
        Notes 
        ----- 
        This method does not allow replacing a time-varying system matrix with 
        a time-invariant one (or vice-versa). If that is required, use `clone`. 
        &quot;&quot;&quot;</span>
        <span class="s1">endog = np.atleast_1d(endog)</span>
        <span class="s2">if </span><span class="s1">endog.ndim == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">endog = endog[:</span><span class="s2">, </span><span class="s1">np.newaxis]</span>
        <span class="s1">nobs = len(endog)</span>

        <span class="s2">if </span><span class="s1">start </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">start = </span><span class="s4">0</span>
        <span class="s2">if </span><span class="s1">end </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">end = self.nobs</span>

        <span class="s2">if </span><span class="s1">start &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">start = self.nobs + start</span>
        <span class="s2">if </span><span class="s1">end &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">end = self.nobs + end</span>
        <span class="s2">if </span><span class="s1">start &gt; self.nobs:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'The `start` argument of the extension within the'</span>
                             <span class="s5">' base model cannot be after the end of the'</span>
                             <span class="s5">' base model.'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">end &gt; self.nobs:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'The `end` argument of the extension within the'</span>
                             <span class="s5">' base model cannot be after the end of the'</span>
                             <span class="s5">' base model.'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">start &gt; end:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'The `start` argument of the extension within the'</span>
                             <span class="s5">' base model cannot be after the `end` argument.'</span><span class="s1">)</span>

        <span class="s3"># Note: if start == end or if end &lt; self.nobs, then we're just cloning</span>
        <span class="s3"># (no extension)</span>
        <span class="s1">endog = tools.concat([self.endog[:</span><span class="s2">, </span><span class="s1">start:end].T</span><span class="s2">, </span><span class="s1">endog])</span>

        <span class="s3"># Extend any time-varying arrays</span>
        <span class="s1">error_ti = (</span><span class="s5">'Model has time-invariant %s matrix, so cannot provide'</span>
                    <span class="s5">' an extended matrix.'</span><span class="s1">)</span>
        <span class="s1">error_tv = (</span><span class="s5">'Model has time-varying %s matrix, so an updated'</span>
                    <span class="s5">' time-varying matrix for the extension period'</span>
                    <span class="s5">' is required.'</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">shape </span><span class="s2">in </span><span class="s1">self.shapes.items():</span>
            <span class="s2">if </span><span class="s1">name == </span><span class="s5">'obs'</span><span class="s1">:</span>
                <span class="s2">continue</span>

            <span class="s1">mat = getattr(self</span><span class="s2">, </span><span class="s1">name)</span>

            <span class="s3"># If we were *not* given an extended value for this matrix...</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">kwargs:</span>
                <span class="s3"># If this is a time-varying matrix in the existing model</span>
                <span class="s2">if </span><span class="s1">mat.shape[-</span><span class="s4">1</span><span class="s1">] &gt; </span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s3"># If we have an extension period, then raise an error</span>
                    <span class="s3"># because we should have been given an extended value</span>
                    <span class="s2">if </span><span class="s1">end + nobs &gt; self.nobs:</span>
                        <span class="s2">raise </span><span class="s1">ValueError(error_tv % name)</span>
                    <span class="s3"># If we do not have an extension period, then set the new</span>
                    <span class="s3"># time-varying matrix to be the portion of the existing</span>
                    <span class="s3"># time-varying matrix that corresponds to the period of</span>
                    <span class="s3"># interest</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">kwargs[name] = mat[...</span><span class="s2">, </span><span class="s1">start:end + nobs]</span>
            <span class="s2">elif </span><span class="s1">nobs == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'Extension is being performed within-sample'</span>
                                 <span class="s5">' so cannot provide an extended matrix'</span><span class="s1">)</span>
            <span class="s3"># If we were given an extended value for this matrix</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s3"># TODO: Need to add a check for ndim, and if the matrix has</span>
                <span class="s3"># one fewer dimensions than the existing matrix, add a new axis</span>

                <span class="s3"># If this is a time-invariant matrix in the existing model,</span>
                <span class="s3"># raise an error</span>
                <span class="s2">if </span><span class="s1">mat.shape[-</span><span class="s4">1</span><span class="s1">] == </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">self.nobs &gt; </span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(error_ti % name)</span>

                <span class="s3"># Otherwise, validate the shape of the given extended value</span>
                <span class="s3"># Note: we do not validate the number of observations here</span>
                <span class="s3"># (so we pass in updated_mat.shape[-1] as the nobs argument</span>
                <span class="s3"># in the validate_* calls); instead, we check below that we</span>
                <span class="s3"># at least `nobs` values were passed in and then only take the</span>
                <span class="s3"># first of them as required. This can be useful when e.g. the</span>
                <span class="s3"># end user knows the extension values up to some maximum</span>
                <span class="s3"># endpoint, but does not know what the calling methods may</span>
                <span class="s3"># specifically require.</span>
                <span class="s1">updated_mat = np.asarray(kwargs[name])</span>
                <span class="s2">if </span><span class="s1">len(shape) == </span><span class="s4">2</span><span class="s1">:</span>
                    <span class="s1">validate_vector_shape(name</span><span class="s2">, </span><span class="s1">updated_mat.shape</span><span class="s2">, </span><span class="s1">shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                                          <span class="s1">updated_mat.shape[-</span><span class="s4">1</span><span class="s1">])</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">validate_matrix_shape(name</span><span class="s2">, </span><span class="s1">updated_mat.shape</span><span class="s2">, </span><span class="s1">shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                                          <span class="s1">shape[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">updated_mat.shape[-</span><span class="s4">1</span><span class="s1">])</span>

                <span class="s2">if </span><span class="s1">updated_mat.shape[-</span><span class="s4">1</span><span class="s1">] &lt; nobs:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(error_tv % name)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">updated_mat = updated_mat[...</span><span class="s2">, </span><span class="s1">:nobs]</span>

                <span class="s3"># Concatenate to get the new time-varying matrix</span>
                <span class="s1">kwargs[name] = np.c_[mat[...</span><span class="s2">, </span><span class="s1">start:end]</span><span class="s2">, </span><span class="s1">updated_mat]</span>

        <span class="s2">return </span><span class="s1">self.clone(endog</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">diff_endog(self</span><span class="s2">, </span><span class="s1">new_endog</span><span class="s2">, </span><span class="s1">tolerance=</span><span class="s4">1e-10</span><span class="s1">):</span>
        <span class="s3"># TODO: move this function to tools?</span>
        <span class="s1">endog = self.endog.T</span>
        <span class="s2">if </span><span class="s1">len(new_endog) &lt; len(endog):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'Given data (length %d) is too short to diff'</span>
                             <span class="s5">' against model data (length %d).'</span>
                             <span class="s1">% (len(new_endog)</span><span class="s2">, </span><span class="s1">len(endog)))</span>
        <span class="s2">if </span><span class="s1">len(new_endog) &gt; len(endog):</span>
            <span class="s1">nobs_append = len(new_endog) - len(endog)</span>
            <span class="s1">endog = np.c_[endog.T</span><span class="s2">, </span><span class="s1">new_endog[-nobs_append:].T * np.nan].T</span>

        <span class="s1">new_nan = np.isnan(new_endog)</span>
        <span class="s1">existing_nan = np.isnan(endog)</span>
        <span class="s1">diff = np.abs(new_endog - endog)</span>
        <span class="s1">diff[new_nan ^ existing_nan] = np.inf</span>
        <span class="s1">diff[new_nan &amp; existing_nan] = </span><span class="s4">0.</span>

        <span class="s1">is_revision = (diff &gt; tolerance)</span>
        <span class="s1">is_new = existing_nan &amp; ~new_nan</span>
        <span class="s1">is_revision[is_new] = </span><span class="s2">False</span>

        <span class="s1">revision_ix = list(zip(*np.where(is_revision)))</span>
        <span class="s1">new_ix = list(zip(*np.where(is_new)))</span>

        <span class="s2">return </span><span class="s1">revision_ix</span><span class="s2">, </span><span class="s1">new_ix</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">prefix(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        (str) BLAS prefix of currently active representation matrices 
        &quot;&quot;&quot;</span>
        <span class="s1">arrays = (</span>
            <span class="s1">self._design</span><span class="s2">, </span><span class="s1">self._obs_intercept</span><span class="s2">, </span><span class="s1">self._obs_cov</span><span class="s2">,</span>
            <span class="s1">self._transition</span><span class="s2">, </span><span class="s1">self._state_intercept</span><span class="s2">, </span><span class="s1">self._selection</span><span class="s2">,</span>
            <span class="s1">self._state_cov</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.endog </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">arrays = (self.endog</span><span class="s2">,</span><span class="s1">) + arrays</span>
        <span class="s2">return </span><span class="s1">find_best_blas_type(arrays)[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">dtype(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        (dtype) Datatype of currently active representation matrices 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">tools.prefix_dtype_map[self.prefix]</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">time_invariant(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        (bool) Whether or not currently active representation matrices are 
        time-invariant 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._time_invariant </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">(</span>
                <span class="s1">self._design.shape[</span><span class="s4">2</span><span class="s1">] == self._obs_intercept.shape[</span><span class="s4">1</span><span class="s1">] ==</span>
                <span class="s1">self._obs_cov.shape[</span><span class="s4">2</span><span class="s1">] == self._transition.shape[</span><span class="s4">2</span><span class="s1">] ==</span>
                <span class="s1">self._state_intercept.shape[</span><span class="s4">1</span><span class="s1">] == self._selection.shape[</span><span class="s4">2</span><span class="s1">] ==</span>
                <span class="s1">self._state_cov.shape[</span><span class="s4">2</span><span class="s1">]</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._time_invariant</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_statespace(self):</span>
        <span class="s1">prefix = self.prefix</span>
        <span class="s2">if </span><span class="s1">prefix </span><span class="s2">in </span><span class="s1">self._statespaces:</span>
            <span class="s2">return </span><span class="s1">self._statespaces[prefix]</span>
        <span class="s2">return None</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">obs(self):</span>
        <span class="s0">r&quot;&quot;&quot; 
        (array) Observation vector: :math:`y~(k\_endog \times nobs)` 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.endog</span>

    <span class="s2">def </span><span class="s1">bind(self</span><span class="s2">, </span><span class="s1">endog):</span>
        <span class="s0">&quot;&quot;&quot; 
        Bind data to the statespace representation 
 
        Parameters 
        ---------- 
        endog : ndarray 
            Endogenous data to bind to the model. Must be column-ordered 
            ndarray with shape (`k_endog`, `nobs`) or row-ordered ndarray with 
            shape (`nobs`, `k_endog`). 
 
        Notes 
        ----- 
        The strict requirements arise because the underlying statespace and 
        Kalman filtering classes require Fortran-ordered arrays in the wide 
        format (shaped (`k_endog`, `nobs`)), and this structure is setup to 
        prevent copying arrays in memory. 
 
        By default, numpy arrays are row (C)-ordered and most time series are 
        represented in the long format (with time on the 0-th axis). In this 
        case, no copying or re-ordering needs to be performed, instead the 
        array can simply be transposed to get it in the right order and shape. 
 
        Although this class (Representation) has stringent `bind` requirements, 
        it is assumed that it will rarely be used directly. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">isinstance(endog</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Invalid endogenous array; must be an ndarray.&quot;</span><span class="s1">)</span>

        <span class="s3"># Make sure we have a 2-dimensional array</span>
        <span class="s3"># Note: reshaping a 1-dim array into a 2-dim array by changing the</span>
        <span class="s3">#       shape tuple always results in a row (C)-ordered array, so it</span>
        <span class="s3">#       must be shaped (nobs, k_endog)</span>
        <span class="s2">if </span><span class="s1">endog.ndim == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s3"># In the case of nobs x 0 arrays</span>
            <span class="s2">if </span><span class="s1">self.k_endog == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">endog.shape = (endog.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s3"># In the case of k_endog x 0 arrays</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">endog.shape = (</span><span class="s4">1</span><span class="s2">, </span><span class="s1">endog.shape[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s2">if not </span><span class="s1">endog.ndim == </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'Invalid endogenous array provided; must be'</span>
                             <span class="s5">' 2-dimensional.'</span><span class="s1">)</span>

        <span class="s3"># Check for valid column-ordered arrays</span>
        <span class="s2">if </span><span class="s1">endog.flags[</span><span class="s5">'F_CONTIGUOUS'</span><span class="s1">] </span><span class="s2">and </span><span class="s1">endog.shape[</span><span class="s4">0</span><span class="s1">] == self.k_endog:</span>
            <span class="s2">pass</span>
        <span class="s3"># Check for valid row-ordered arrays, and transpose them to be the</span>
        <span class="s3"># correct column-ordered array</span>
        <span class="s2">elif </span><span class="s1">endog.flags[</span><span class="s5">'C_CONTIGUOUS'</span><span class="s1">] </span><span class="s2">and </span><span class="s1">endog.shape[</span><span class="s4">1</span><span class="s1">] == self.k_endog:</span>
            <span class="s1">endog = endog.T</span>
        <span class="s3"># Invalid column-ordered arrays</span>
        <span class="s2">elif </span><span class="s1">endog.flags[</span><span class="s5">'F_CONTIGUOUS'</span><span class="s1">]:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'Invalid endogenous array; column-ordered'</span>
                             <span class="s5">' arrays must have first axis shape of'</span>
                             <span class="s5">' `k_endog`.'</span><span class="s1">)</span>
        <span class="s3"># Invalid row-ordered arrays</span>
        <span class="s2">elif </span><span class="s1">endog.flags[</span><span class="s5">'C_CONTIGUOUS'</span><span class="s1">]:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'Invalid endogenous array; row-ordered'</span>
                             <span class="s5">' arrays must have last axis shape of'</span>
                             <span class="s5">' `k_endog`.'</span><span class="s1">)</span>
        <span class="s3"># Non-contiguous arrays</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'Invalid endogenous array; must be ordered in'</span>
                             <span class="s5">' contiguous memory.'</span><span class="s1">)</span>

        <span class="s3"># We may still have a non-fortran contiguous array, so double-check</span>
        <span class="s2">if not </span><span class="s1">endog.flags[</span><span class="s5">'F_CONTIGUOUS'</span><span class="s1">]:</span>
            <span class="s1">endog = np.asfortranarray(endog)</span>

        <span class="s3"># Set a flag for complex data</span>
        <span class="s1">self._complex_endog = np.iscomplexobj(endog)</span>

        <span class="s3"># Set the data</span>
        <span class="s1">self.endog = endog</span>
        <span class="s1">self.nobs = self.endog.shape[</span><span class="s4">1</span><span class="s1">]</span>

        <span class="s3"># Reset shapes</span>
        <span class="s2">if </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s5">'shapes'</span><span class="s1">):</span>
            <span class="s1">self.shapes[</span><span class="s5">'obs'</span><span class="s1">] = self.endog.shape</span>

    <span class="s2">def </span><span class="s1">initialize(self</span><span class="s2">, </span><span class="s1">initialization</span><span class="s2">, </span><span class="s1">approximate_diffuse_variance=</span><span class="s2">None,</span>
                   <span class="s1">constant=</span><span class="s2">None, </span><span class="s1">stationary_cov=</span><span class="s2">None, </span><span class="s1">a=</span><span class="s2">None, </span><span class="s1">Pstar=</span><span class="s2">None,</span>
                   <span class="s1">Pinf=</span><span class="s2">None, </span><span class="s1">A=</span><span class="s2">None, </span><span class="s1">R0=</span><span class="s2">None, </span><span class="s1">Q0=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Create an Initialization object if necessary&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">initialization == </span><span class="s5">'known'</span><span class="s1">:</span>
            <span class="s1">initialization = Initialization(self.k_states</span><span class="s2">, </span><span class="s5">'known'</span><span class="s2">,</span>
                                            <span class="s1">constant=constant</span><span class="s2">,</span>
                                            <span class="s1">stationary_cov=stationary_cov)</span>
        <span class="s2">elif </span><span class="s1">initialization == </span><span class="s5">'components'</span><span class="s1">:</span>
            <span class="s1">initialization = Initialization.from_components(</span>
                <span class="s1">a=a</span><span class="s2">, </span><span class="s1">Pstar=Pstar</span><span class="s2">, </span><span class="s1">Pinf=Pinf</span><span class="s2">, </span><span class="s1">A=A</span><span class="s2">, </span><span class="s1">R0=R0</span><span class="s2">, </span><span class="s1">Q0=Q0)</span>
        <span class="s2">elif </span><span class="s1">initialization == </span><span class="s5">'approximate_diffuse'</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">approximate_diffuse_variance </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">approximate_diffuse_variance = self.initial_variance</span>
            <span class="s1">initialization = Initialization(</span>
                <span class="s1">self.k_states</span><span class="s2">, </span><span class="s5">'approximate_diffuse'</span><span class="s2">,</span>
                <span class="s1">approximate_diffuse_variance=approximate_diffuse_variance)</span>
        <span class="s2">elif </span><span class="s1">initialization == </span><span class="s5">'stationary'</span><span class="s1">:</span>
            <span class="s1">initialization = Initialization(self.k_states</span><span class="s2">, </span><span class="s5">'stationary'</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">initialization == </span><span class="s5">'diffuse'</span><span class="s1">:</span>
            <span class="s1">initialization = Initialization(self.k_states</span><span class="s2">, </span><span class="s5">'diffuse'</span><span class="s1">)</span>

        <span class="s3"># We must have an initialization object at this point</span>
        <span class="s2">if not </span><span class="s1">isinstance(initialization</span><span class="s2">, </span><span class="s1">Initialization):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Invalid state space initialization method.&quot;</span><span class="s1">)</span>

        <span class="s1">self.initialization = initialization</span>

    <span class="s2">def </span><span class="s1">initialize_known(self</span><span class="s2">, </span><span class="s1">constant</span><span class="s2">, </span><span class="s1">stationary_cov):</span>
        <span class="s0">&quot;&quot;&quot; 
        Initialize the statespace model with known distribution for initial 
        state. 
 
        These values are assumed to be known with certainty or else 
        filled with parameters during, for example, maximum likelihood 
        estimation. 
 
        Parameters 
        ---------- 
        constant : array_like 
            Known mean of the initial state vector. 
        stationary_cov : array_like 
            Known covariance matrix of the initial state vector. 
        &quot;&quot;&quot;</span>
        <span class="s1">constant = np.asarray(constant</span><span class="s2">, </span><span class="s1">order=</span><span class="s5">&quot;F&quot;</span><span class="s1">)</span>
        <span class="s1">stationary_cov = np.asarray(stationary_cov</span><span class="s2">, </span><span class="s1">order=</span><span class="s5">&quot;F&quot;</span><span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">constant.shape == (self.k_states</span><span class="s2">,</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'Invalid dimensions for constant state vector.'</span>
                             <span class="s5">' Requires shape (%d,), got %s' </span><span class="s1">%</span>
                             <span class="s1">(self.k_states</span><span class="s2">, </span><span class="s1">str(constant.shape)))</span>
        <span class="s2">if not </span><span class="s1">stationary_cov.shape == (self.k_states</span><span class="s2">, </span><span class="s1">self.k_states):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'Invalid dimensions for stationary covariance'</span>
                             <span class="s5">' matrix. Requires shape (%d,%d), got %s' </span><span class="s1">%</span>
                             <span class="s1">(self.k_states</span><span class="s2">, </span><span class="s1">self.k_states</span><span class="s2">,</span>
                              <span class="s1">str(stationary_cov.shape)))</span>

        <span class="s1">self.initialize(</span><span class="s5">'known'</span><span class="s2">, </span><span class="s1">constant=constant</span><span class="s2">,</span>
                        <span class="s1">stationary_cov=stationary_cov)</span>

    <span class="s2">def </span><span class="s1">initialize_approximate_diffuse(self</span><span class="s2">, </span><span class="s1">variance=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Initialize the statespace model with approximate diffuse values. 
 
        Rather than following the exact diffuse treatment (which is developed 
        for the case that the variance becomes infinitely large), this assigns 
        an arbitrary large number for the variance. 
 
        Parameters 
        ---------- 
        variance : float, optional 
            The variance for approximating diffuse initial conditions. Default 
            is 1e6. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">variance </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">variance = self.initial_variance</span>

        <span class="s1">self.initialize(</span><span class="s5">'approximate_diffuse'</span><span class="s2">,</span>
                        <span class="s1">approximate_diffuse_variance=variance)</span>

    <span class="s2">def </span><span class="s1">initialize_components(self</span><span class="s2">, </span><span class="s1">a=</span><span class="s2">None, </span><span class="s1">Pstar=</span><span class="s2">None, </span><span class="s1">Pinf=</span><span class="s2">None, </span><span class="s1">A=</span><span class="s2">None,</span>
                              <span class="s1">R0=</span><span class="s2">None, </span><span class="s1">Q0=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Initialize the statespace model with component matrices 
 
        Parameters 
        ---------- 
        a : array_like, optional 
            Vector of constant values describing the mean of the stationary 
            component of the initial state. 
        Pstar : array_like, optional 
            Stationary component of the initial state covariance matrix. If 
            given, should be a matrix shaped `k_states x k_states`. The 
            submatrix associated with the diffuse states should contain zeros. 
            Note that by definition, `Pstar = R0 @ Q0 @ R0.T`, so either 
            `R0,Q0` or `Pstar` may be given, but not both. 
        Pinf : array_like, optional 
            Diffuse component of the initial state covariance matrix. If given, 
            should be a matrix shaped `k_states x k_states` with ones in the 
            diagonal positions corresponding to states with diffuse 
            initialization and zeros otherwise. Note that by definition, 
            `Pinf = A @ A.T`, so either `A` or `Pinf` may be given, but not 
            both. 
        A : array_like, optional 
            Diffuse selection matrix, used in the definition of the diffuse 
            initial state covariance matrix. If given, should be a 
            `k_states x k_diffuse_states` matrix that contains the subset of 
            the columns of the identity matrix that correspond to states with 
            diffuse initialization. Note that by definition, `Pinf = A @ A.T`, 
            so either `A` or `Pinf` may be given, but not both. 
        R0 : array_like, optional 
            Stationary selection matrix, used in the definition of the 
            stationary initial state covariance matrix. If given, should be a 
            `k_states x k_nondiffuse_states` matrix that contains the subset of 
            the columns of the identity matrix that correspond to states with a 
            non-diffuse initialization. Note that by definition, 
            `Pstar = R0 @ Q0 @ R0.T`, so either `R0,Q0` or `Pstar` may be 
            given, but not both. 
        Q0 : array_like, optional 
            Covariance matrix associated with stationary initial states. If 
            given, should be a matrix shaped 
            `k_nondiffuse_states x k_nondiffuse_states`. 
            Note that by definition, `Pstar = R0 @ Q0 @ R0.T`, so either 
            `R0,Q0` or `Pstar` may be given, but not both. 
 
        Notes 
        ----- 
        The matrices `a, Pstar, Pinf, A, R0, Q0` and the process for 
        initializing the state space model is as given in Chapter 5 of [1]_. 
        For the definitions of these matrices, see equation (5.2) and the 
        subsequent discussion there. 
 
        References 
        ---------- 
        .. [1] Durbin, James, and Siem Jan Koopman. 2012. 
           Time Series Analysis by State Space Methods: Second Edition. 
           Oxford University Press. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.initialize(</span><span class="s5">'components'</span><span class="s2">, </span><span class="s1">a=a</span><span class="s2">, </span><span class="s1">Pstar=Pstar</span><span class="s2">, </span><span class="s1">Pinf=Pinf</span><span class="s2">, </span><span class="s1">A=A</span><span class="s2">, </span><span class="s1">R0=R0</span><span class="s2">,</span>
                        <span class="s1">Q0=Q0)</span>

    <span class="s2">def </span><span class="s1">initialize_stationary(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Initialize the statespace model as stationary. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.initialize(</span><span class="s5">'stationary'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">initialize_diffuse(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Initialize the statespace model as diffuse. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.initialize(</span><span class="s5">'diffuse'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_initialize_representation(self</span><span class="s2">, </span><span class="s1">prefix=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">prefix </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">prefix = self.prefix</span>
        <span class="s1">dtype = tools.prefix_dtype_map[prefix]</span>

        <span class="s3"># If the dtype-specific representation matrices do not exist, create</span>
        <span class="s3"># them</span>
        <span class="s2">if </span><span class="s1">prefix </span><span class="s2">not in </span><span class="s1">self._representations:</span>
            <span class="s3"># Copy the statespace representation matrices</span>
            <span class="s1">self._representations[prefix] = {}</span>
            <span class="s2">for </span><span class="s1">matrix </span><span class="s2">in </span><span class="s1">self.shapes.keys():</span>
                <span class="s2">if </span><span class="s1">matrix == </span><span class="s5">'obs'</span><span class="s1">:</span>
                    <span class="s1">self._representations[prefix][matrix] = (</span>
                        <span class="s1">self.obs.astype(dtype)</span>
                    <span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s3"># Note: this always makes a copy</span>
                    <span class="s1">self._representations[prefix][matrix] = (</span>
                        <span class="s1">getattr(self</span><span class="s2">, </span><span class="s5">'_' </span><span class="s1">+ matrix).astype(dtype)</span>
                    <span class="s1">)</span>
        <span class="s3"># If they do exist, update them</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">matrix </span><span class="s2">in </span><span class="s1">self.shapes.keys():</span>
                <span class="s1">existing = self._representations[prefix][matrix]</span>
                <span class="s2">if </span><span class="s1">matrix == </span><span class="s5">'obs'</span><span class="s1">:</span>
                    <span class="s3"># existing[:] = self.obs.astype(dtype)</span>
                    <span class="s2">pass</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">new = getattr(self</span><span class="s2">, </span><span class="s5">'_' </span><span class="s1">+ matrix).astype(dtype)</span>
                    <span class="s2">if </span><span class="s1">existing.shape == new.shape:</span>
                        <span class="s1">existing[:] = new[:]</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">self._representations[prefix][matrix] = new</span>

        <span class="s3"># Determine if we need to (re-)create the _statespace models</span>
        <span class="s3"># (if time-varying matrices changed)</span>
        <span class="s2">if </span><span class="s1">prefix </span><span class="s2">in </span><span class="s1">self._statespaces:</span>
            <span class="s1">ss = self._statespaces[prefix]</span>
            <span class="s1">create = (</span>
                <span class="s2">not </span><span class="s1">ss.obs.shape[</span><span class="s4">1</span><span class="s1">] == self.endog.shape[</span><span class="s4">1</span><span class="s1">] </span><span class="s2">or</span>
                <span class="s2">not </span><span class="s1">ss.design.shape[</span><span class="s4">2</span><span class="s1">] == self.design.shape[</span><span class="s4">2</span><span class="s1">] </span><span class="s2">or</span>
                <span class="s2">not </span><span class="s1">ss.obs_intercept.shape[</span><span class="s4">1</span><span class="s1">] == self.obs_intercept.shape[</span><span class="s4">1</span><span class="s1">] </span><span class="s2">or</span>
                <span class="s2">not </span><span class="s1">ss.obs_cov.shape[</span><span class="s4">2</span><span class="s1">] == self.obs_cov.shape[</span><span class="s4">2</span><span class="s1">] </span><span class="s2">or</span>
                <span class="s2">not </span><span class="s1">ss.transition.shape[</span><span class="s4">2</span><span class="s1">] == self.transition.shape[</span><span class="s4">2</span><span class="s1">] </span><span class="s2">or</span>
                <span class="s2">not </span><span class="s1">(ss.state_intercept.shape[</span><span class="s4">1</span><span class="s1">] ==</span>
                     <span class="s1">self.state_intercept.shape[</span><span class="s4">1</span><span class="s1">]) </span><span class="s2">or</span>
                <span class="s2">not </span><span class="s1">ss.selection.shape[</span><span class="s4">2</span><span class="s1">] == self.selection.shape[</span><span class="s4">2</span><span class="s1">] </span><span class="s2">or</span>
                <span class="s2">not </span><span class="s1">ss.state_cov.shape[</span><span class="s4">2</span><span class="s1">] == self.state_cov.shape[</span><span class="s4">2</span><span class="s1">]</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">create = </span><span class="s2">True</span>

        <span class="s3"># (re-)create if necessary</span>
        <span class="s2">if </span><span class="s1">create:</span>
            <span class="s2">if </span><span class="s1">prefix </span><span class="s2">in </span><span class="s1">self._statespaces:</span>
                <span class="s2">del </span><span class="s1">self._statespaces[prefix]</span>

            <span class="s3"># Setup the base statespace object</span>
            <span class="s1">cls = self.prefix_statespace_map[prefix]</span>
            <span class="s1">self._statespaces[prefix] = cls(</span>
                <span class="s1">self._representations[prefix][</span><span class="s5">'obs'</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">self._representations[prefix][</span><span class="s5">'design'</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">self._representations[prefix][</span><span class="s5">'obs_intercept'</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">self._representations[prefix][</span><span class="s5">'obs_cov'</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">self._representations[prefix][</span><span class="s5">'transition'</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">self._representations[prefix][</span><span class="s5">'state_intercept'</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">self._representations[prefix][</span><span class="s5">'selection'</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">self._representations[prefix][</span><span class="s5">'state_cov'</span><span class="s1">]</span>
            <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">prefix</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">create</span>

    <span class="s2">def </span><span class="s1">_initialize_state(self</span><span class="s2">, </span><span class="s1">prefix=</span><span class="s2">None, </span><span class="s1">complex_step=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s3"># TODO once the transition to using the Initialization objects is</span>
        <span class="s3"># complete, this should be moved entirely to the _{{prefix}}Statespace</span>
        <span class="s3"># object.</span>
        <span class="s2">if </span><span class="s1">prefix </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">prefix = self.prefix</span>

        <span class="s3"># (Re-)initialize the statespace model</span>
        <span class="s2">if </span><span class="s1">isinstance(self.initialization</span><span class="s2">, </span><span class="s1">Initialization):</span>
            <span class="s2">if not </span><span class="s1">self.initialization.initialized:</span>
                <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s5">'Initialization is incomplete.'</span><span class="s1">)</span>
            <span class="s1">self._statespaces[prefix].initialize(self.initialization</span><span class="s2">,</span>
                                                 <span class="s1">complex_step=complex_step)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s5">'Statespace model not initialized.'</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">FrozenRepresentation:</span>
    <span class="s0">&quot;&quot;&quot; 
    Frozen Statespace Model 
 
    Takes a snapshot of a Statespace model. 
 
    Parameters 
    ---------- 
    model : Representation 
        A Statespace representation 
 
    Attributes 
    ---------- 
    nobs : int 
        Number of observations. 
    k_endog : int 
        The dimension of the observation series. 
    k_states : int 
        The dimension of the unobserved state process. 
    k_posdef : int 
        The dimension of a guaranteed positive definite 
        covariance matrix describing the shocks in the 
        measurement equation. 
    dtype : dtype 
        Datatype of representation matrices 
    prefix : str 
        BLAS prefix of representation matrices 
    shapes : dictionary of name:tuple 
        A dictionary recording the shapes of each of 
        the representation matrices as tuples. 
    endog : ndarray 
        The observation vector. 
    design : ndarray 
        The design matrix, :math:`Z`. 
    obs_intercept : ndarray 
        The intercept for the observation equation, :math:`d`. 
    obs_cov : ndarray 
        The covariance matrix for the observation equation :math:`H`. 
    transition : ndarray 
        The transition matrix, :math:`T`. 
    state_intercept : ndarray 
        The intercept for the transition equation, :math:`c`. 
    selection : ndarray 
        The selection matrix, :math:`R`. 
    state_cov : ndarray 
        The covariance matrix for the state equation :math:`Q`. 
    missing : array of bool 
        An array of the same size as `endog`, filled 
        with boolean values that are True if the 
        corresponding entry in `endog` is NaN and False 
        otherwise. 
    nmissing : array of int 
        An array of size `nobs`, where the ith entry 
        is the number (between 0 and `k_endog`) of NaNs in 
        the ith row of the `endog` array. 
    time_invariant : bool 
        Whether or not the representation matrices are time-invariant 
    initialization : Initialization object 
        Kalman filter initialization method. 
    initial_state : array_like 
        The state vector used to initialize the Kalamn filter. 
    initial_state_cov : array_like 
        The state covariance matrix used to initialize the Kalamn filter. 
    &quot;&quot;&quot;</span>
    <span class="s1">_model_attributes = [</span>
        <span class="s5">'model'</span><span class="s2">, </span><span class="s5">'prefix'</span><span class="s2">, </span><span class="s5">'dtype'</span><span class="s2">, </span><span class="s5">'nobs'</span><span class="s2">, </span><span class="s5">'k_endog'</span><span class="s2">, </span><span class="s5">'k_states'</span><span class="s2">,</span>
        <span class="s5">'k_posdef'</span><span class="s2">, </span><span class="s5">'time_invariant'</span><span class="s2">, </span><span class="s5">'endog'</span><span class="s2">, </span><span class="s5">'design'</span><span class="s2">, </span><span class="s5">'obs_intercept'</span><span class="s2">,</span>
        <span class="s5">'obs_cov'</span><span class="s2">, </span><span class="s5">'transition'</span><span class="s2">, </span><span class="s5">'state_intercept'</span><span class="s2">, </span><span class="s5">'selection'</span><span class="s2">,</span>
        <span class="s5">'state_cov'</span><span class="s2">, </span><span class="s5">'missing'</span><span class="s2">, </span><span class="s5">'nmissing'</span><span class="s2">, </span><span class="s5">'shapes'</span><span class="s2">, </span><span class="s5">'initialization'</span><span class="s2">,</span>
        <span class="s5">'initial_state'</span><span class="s2">, </span><span class="s5">'initial_state_cov'</span><span class="s2">, </span><span class="s5">'initial_variance'</span>
    <span class="s1">]</span>
    <span class="s1">_attributes = _model_attributes</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">model):</span>
        <span class="s3"># Initialize all attributes to None</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self._attributes:</span>
            <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, None</span><span class="s1">)</span>

        <span class="s3"># Update the representation attributes</span>
        <span class="s1">self.update_representation(model)</span>

    <span class="s2">def </span><span class="s1">update_representation(self</span><span class="s2">, </span><span class="s1">model):</span>
        <span class="s0">&quot;&quot;&quot;Update model Representation&quot;&quot;&quot;</span>
        <span class="s3"># Model</span>
        <span class="s1">self.model = model</span>

        <span class="s3"># Data type</span>
        <span class="s1">self.prefix = model.prefix</span>
        <span class="s1">self.dtype = model.dtype</span>

        <span class="s3"># Copy the model dimensions</span>
        <span class="s1">self.nobs = model.nobs</span>
        <span class="s1">self.k_endog = model.k_endog</span>
        <span class="s1">self.k_states = model.k_states</span>
        <span class="s1">self.k_posdef = model.k_posdef</span>
        <span class="s1">self.time_invariant = model.time_invariant</span>

        <span class="s3"># Save the state space representation at the time</span>
        <span class="s1">self.endog = model.endog</span>
        <span class="s1">self.design = model._design.copy()</span>
        <span class="s1">self.obs_intercept = model._obs_intercept.copy()</span>
        <span class="s1">self.obs_cov = model._obs_cov.copy()</span>
        <span class="s1">self.transition = model._transition.copy()</span>
        <span class="s1">self.state_intercept = model._state_intercept.copy()</span>
        <span class="s1">self.selection = model._selection.copy()</span>
        <span class="s1">self.state_cov = model._state_cov.copy()</span>

        <span class="s1">self.missing = np.array(model._statespaces[self.prefix].missing</span><span class="s2">,</span>
                                <span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">self.nmissing = np.array(model._statespaces[self.prefix].nmissing</span><span class="s2">,</span>
                                 <span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s3"># Save the final shapes of the matrices</span>
        <span class="s1">self.shapes = dict(model.shapes)</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.shapes.keys():</span>
            <span class="s2">if </span><span class="s1">name == </span><span class="s5">'obs'</span><span class="s1">:</span>
                <span class="s2">continue</span>
            <span class="s1">self.shapes[name] = getattr(self</span><span class="s2">, </span><span class="s1">name).shape</span>
        <span class="s1">self.shapes[</span><span class="s5">'obs'</span><span class="s1">] = self.endog.shape</span>

        <span class="s3"># Save the state space initialization</span>
        <span class="s1">self.initialization = model.initialization</span>

        <span class="s2">if </span><span class="s1">model.initialization </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">model._initialize_state()</span>
            <span class="s1">self.initial_state = np.array(</span>
                <span class="s1">model._statespaces[self.prefix].initial_state</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">self.initial_state_cov = np.array(</span>
                <span class="s1">model._statespaces[self.prefix].initial_state_cov</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">self.initial_diffuse_state_cov = np.array(</span>
                <span class="s1">model._statespaces[self.prefix].initial_diffuse_state_cov</span><span class="s2">,</span>
                <span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>
</pre>
</body>
</html>