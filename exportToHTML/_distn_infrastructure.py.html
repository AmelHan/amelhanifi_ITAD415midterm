<html>
<head>
<title>_distn_infrastructure.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_distn_infrastructure.py</font>
</center></td></tr></table>
<pre><span class="s0">#</span>
<span class="s0"># Author:  Travis Oliphant  2002-2011 with contributions from</span>
<span class="s0">#          SciPy Developers 2004-2011</span>
<span class="s0">#</span>
<span class="s2">from </span><span class="s1">scipy._lib._util </span><span class="s2">import </span><span class="s1">getfullargspec_no_self </span><span class="s2">as </span><span class="s1">_getfullargspec</span>

<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">keyword</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">types</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">itertools </span><span class="s2">import </span><span class="s1">zip_longest</span>

<span class="s2">from </span><span class="s1">scipy._lib </span><span class="s2">import </span><span class="s1">doccer</span>
<span class="s2">from </span><span class="s1">._distr_params </span><span class="s2">import </span><span class="s1">distcont</span><span class="s2">, </span><span class="s1">distdiscrete</span>
<span class="s2">from </span><span class="s1">scipy._lib._util </span><span class="s2">import </span><span class="s1">check_random_state</span>

<span class="s2">from </span><span class="s1">scipy.special </span><span class="s2">import </span><span class="s1">comb</span><span class="s2">, </span><span class="s1">entr</span>


<span class="s0"># for root finding for continuous distribution ppf, and maximum likelihood</span>
<span class="s0"># estimation</span>
<span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">optimize</span>

<span class="s0"># for functions of continuous distributions (e.g. moments, entropy, cdf)</span>
<span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">integrate</span>

<span class="s0"># to approximate the pdf of a continuous distribution given its cdf</span>
<span class="s2">from </span><span class="s1">scipy._lib._finite_differences </span><span class="s2">import </span><span class="s1">_derivative</span>

<span class="s0"># for scipy.stats.entropy. Attempts to import just that function or file</span>
<span class="s0"># have cause import problems</span>
<span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">stats</span>

<span class="s2">from </span><span class="s1">numpy </span><span class="s2">import </span><span class="s1">(arange</span><span class="s2">, </span><span class="s1">putmask</span><span class="s2">, </span><span class="s1">ones</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">ndarray</span><span class="s2">, </span><span class="s1">zeros</span><span class="s2">, </span><span class="s1">floor</span><span class="s2">,</span>
                   <span class="s1">logical_and</span><span class="s2">, </span><span class="s1">log</span><span class="s2">, </span><span class="s1">sqrt</span><span class="s2">, </span><span class="s1">place</span><span class="s2">, </span><span class="s1">argmax</span><span class="s2">, </span><span class="s1">vectorize</span><span class="s2">, </span><span class="s1">asarray</span><span class="s2">,</span>
                   <span class="s1">nan</span><span class="s2">, </span><span class="s1">inf</span><span class="s2">, </span><span class="s1">isinf</span><span class="s2">, </span><span class="s1">NINF</span><span class="s2">, </span><span class="s1">empty)</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">._constants </span><span class="s2">import </span><span class="s1">_XMAX</span><span class="s2">, </span><span class="s1">_LOGXMAX</span>
<span class="s2">from </span><span class="s1">._censored_data </span><span class="s2">import </span><span class="s1">CensoredData</span>
<span class="s2">from </span><span class="s1">scipy.stats._warnings_errors </span><span class="s2">import </span><span class="s1">FitError</span>

<span class="s0"># These are the docstring parts used for substitution in specific</span>
<span class="s0"># distribution docstrings</span>

<span class="s1">docheaders = {</span><span class="s3">'methods'</span><span class="s1">: </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\n</span><span class="s3">Methods</span><span class="s2">\n</span><span class="s3">-------</span><span class="s2">\n</span><span class="s3">&quot;&quot;&quot;</span><span class="s2">,</span>
              <span class="s3">'notes'</span><span class="s1">: </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\n</span><span class="s3">Notes</span><span class="s2">\n</span><span class="s3">-----</span><span class="s2">\n</span><span class="s3">&quot;&quot;&quot;</span><span class="s2">,</span>
              <span class="s3">'examples'</span><span class="s1">: </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\n</span><span class="s3">Examples</span><span class="s2">\n</span><span class="s3">--------</span><span class="s2">\n</span><span class="s3">&quot;&quot;&quot;</span><span class="s1">}</span>

<span class="s1">_doc_rvs = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">rvs(%(shapes)s, loc=0, scale=1, size=1, random_state=None) 
    Random variates. 
&quot;&quot;&quot;</span>
<span class="s1">_doc_pdf = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">pdf(x, %(shapes)s, loc=0, scale=1) 
    Probability density function. 
&quot;&quot;&quot;</span>
<span class="s1">_doc_logpdf = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">logpdf(x, %(shapes)s, loc=0, scale=1) 
    Log of the probability density function. 
&quot;&quot;&quot;</span>
<span class="s1">_doc_pmf = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">pmf(k, %(shapes)s, loc=0, scale=1) 
    Probability mass function. 
&quot;&quot;&quot;</span>
<span class="s1">_doc_logpmf = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">logpmf(k, %(shapes)s, loc=0, scale=1) 
    Log of the probability mass function. 
&quot;&quot;&quot;</span>
<span class="s1">_doc_cdf = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">cdf(x, %(shapes)s, loc=0, scale=1) 
    Cumulative distribution function. 
&quot;&quot;&quot;</span>
<span class="s1">_doc_logcdf = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">logcdf(x, %(shapes)s, loc=0, scale=1) 
    Log of the cumulative distribution function. 
&quot;&quot;&quot;</span>
<span class="s1">_doc_sf = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">sf(x, %(shapes)s, loc=0, scale=1) 
    Survival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate). 
&quot;&quot;&quot;</span>
<span class="s1">_doc_logsf = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">logsf(x, %(shapes)s, loc=0, scale=1) 
    Log of the survival function. 
&quot;&quot;&quot;</span>
<span class="s1">_doc_ppf = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">ppf(q, %(shapes)s, loc=0, scale=1) 
    Percent point function (inverse of ``cdf`` --- percentiles). 
&quot;&quot;&quot;</span>
<span class="s1">_doc_isf = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">isf(q, %(shapes)s, loc=0, scale=1) 
    Inverse survival function (inverse of ``sf``). 
&quot;&quot;&quot;</span>
<span class="s1">_doc_moment = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">moment(order, %(shapes)s, loc=0, scale=1) 
    Non-central moment of the specified order. 
&quot;&quot;&quot;</span>
<span class="s1">_doc_stats = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">stats(%(shapes)s, loc=0, scale=1, moments='mv') 
    Mean('m'), variance('v'), skew('s'), and/or kurtosis('k'). 
&quot;&quot;&quot;</span>
<span class="s1">_doc_entropy = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">entropy(%(shapes)s, loc=0, scale=1) 
    (Differential) entropy of the RV. 
&quot;&quot;&quot;</span>
<span class="s1">_doc_fit = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">fit(data) 
    Parameter estimates for generic data. 
    See `scipy.stats.rv_continuous.fit &lt;https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit&gt;`__ for detailed documentation of the 
    keyword arguments. 
&quot;&quot;&quot;</span>
<span class="s1">_doc_expect = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">expect(func, args=(%(shapes_)s), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds) 
    Expected value of a function (of one argument) with respect to the distribution. 
&quot;&quot;&quot;</span>
<span class="s1">_doc_expect_discrete = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">expect(func, args=(%(shapes_)s), loc=0, lb=None, ub=None, conditional=False) 
    Expected value of a function (of one argument) with respect to the distribution. 
&quot;&quot;&quot;</span>
<span class="s1">_doc_median = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">median(%(shapes)s, loc=0, scale=1) 
    Median of the distribution. 
&quot;&quot;&quot;</span>
<span class="s1">_doc_mean = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">mean(%(shapes)s, loc=0, scale=1) 
    Mean of the distribution. 
&quot;&quot;&quot;</span>
<span class="s1">_doc_var = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">var(%(shapes)s, loc=0, scale=1) 
    Variance of the distribution. 
&quot;&quot;&quot;</span>
<span class="s1">_doc_std = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">std(%(shapes)s, loc=0, scale=1) 
    Standard deviation of the distribution. 
&quot;&quot;&quot;</span>
<span class="s1">_doc_interval = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">interval(confidence, %(shapes)s, loc=0, scale=1) 
    Confidence interval with equal areas around the median. 
&quot;&quot;&quot;</span>
<span class="s1">_doc_allmethods = </span><span class="s3">''</span><span class="s1">.join([docheaders[</span><span class="s3">'methods'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">_doc_rvs</span><span class="s2">, </span><span class="s1">_doc_pdf</span><span class="s2">,</span>
                           <span class="s1">_doc_logpdf</span><span class="s2">, </span><span class="s1">_doc_cdf</span><span class="s2">, </span><span class="s1">_doc_logcdf</span><span class="s2">, </span><span class="s1">_doc_sf</span><span class="s2">,</span>
                           <span class="s1">_doc_logsf</span><span class="s2">, </span><span class="s1">_doc_ppf</span><span class="s2">, </span><span class="s1">_doc_isf</span><span class="s2">, </span><span class="s1">_doc_moment</span><span class="s2">,</span>
                           <span class="s1">_doc_stats</span><span class="s2">, </span><span class="s1">_doc_entropy</span><span class="s2">, </span><span class="s1">_doc_fit</span><span class="s2">,</span>
                           <span class="s1">_doc_expect</span><span class="s2">, </span><span class="s1">_doc_median</span><span class="s2">,</span>
                           <span class="s1">_doc_mean</span><span class="s2">, </span><span class="s1">_doc_var</span><span class="s2">, </span><span class="s1">_doc_std</span><span class="s2">, </span><span class="s1">_doc_interval])</span>

<span class="s1">_doc_default_longsummary = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">As an instance of the `rv_continuous` class, `%(name)s` object inherits from it 
a collection of generic methods (see below for the full list), 
and completes them with details specific for this particular distribution. 
&quot;&quot;&quot;</span>

<span class="s1">_doc_default_frozen_note = </span><span class="s3">&quot;&quot;&quot; 
Alternatively, the object may be called (as a function) to fix the shape, 
location, and scale parameters returning a &quot;frozen&quot; continuous RV object: 
 
rv = %(name)s(%(shapes)s, loc=0, scale=1) 
    - Frozen RV object with the same methods but holding the given shape, 
      location, and scale fixed. 
&quot;&quot;&quot;</span>
<span class="s1">_doc_default_example = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">Examples 
-------- 
&gt;&gt;&gt; import numpy as np 
&gt;&gt;&gt; from scipy.stats import %(name)s 
&gt;&gt;&gt; import matplotlib.pyplot as plt 
&gt;&gt;&gt; fig, ax = plt.subplots(1, 1) 
 
Calculate the first four moments: 
 
%(set_vals_stmt)s 
&gt;&gt;&gt; mean, var, skew, kurt = %(name)s.stats(%(shapes)s, moments='mvsk') 
 
Display the probability density function (``pdf``): 
 
&gt;&gt;&gt; x = np.linspace(%(name)s.ppf(0.01, %(shapes)s), 
...                 %(name)s.ppf(0.99, %(shapes)s), 100) 
&gt;&gt;&gt; ax.plot(x, %(name)s.pdf(x, %(shapes)s), 
...        'r-', lw=5, alpha=0.6, label='%(name)s pdf') 
 
Alternatively, the distribution object can be called (as a function) 
to fix the shape, location and scale parameters. This returns a &quot;frozen&quot; 
RV object holding the given parameters fixed. 
 
Freeze the distribution and display the frozen ``pdf``: 
 
&gt;&gt;&gt; rv = %(name)s(%(shapes)s) 
&gt;&gt;&gt; ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf') 
 
Check accuracy of ``cdf`` and ``ppf``: 
 
&gt;&gt;&gt; vals = %(name)s.ppf([0.001, 0.5, 0.999], %(shapes)s) 
&gt;&gt;&gt; np.allclose([0.001, 0.5, 0.999], %(name)s.cdf(vals, %(shapes)s)) 
True 
 
Generate random numbers: 
 
&gt;&gt;&gt; r = %(name)s.rvs(%(shapes)s, size=1000) 
 
And compare the histogram: 
 
&gt;&gt;&gt; ax.hist(r, density=True, bins='auto', histtype='stepfilled', alpha=0.2) 
&gt;&gt;&gt; ax.set_xlim([x[0], x[-1]]) 
&gt;&gt;&gt; ax.legend(loc='best', frameon=False) 
&gt;&gt;&gt; plt.show() 
 
&quot;&quot;&quot;</span>

<span class="s1">_doc_default_locscale = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">The probability density above is defined in the &quot;standardized&quot; form. To shift 
and/or scale the distribution use the ``loc`` and ``scale`` parameters. 
Specifically, ``%(name)s.pdf(x, %(shapes)s, loc, scale)`` is identically 
equivalent to ``%(name)s.pdf(y, %(shapes)s) / scale`` with 
``y = (x - loc) / scale``. Note that shifting the location of a distribution 
does not make it a &quot;noncentral&quot; distribution; noncentral generalizations of 
some distributions are available in separate classes. 
&quot;&quot;&quot;</span>

<span class="s1">_doc_default = </span><span class="s3">''</span><span class="s1">.join([_doc_default_longsummary</span><span class="s2">,</span>
                        <span class="s1">_doc_allmethods</span><span class="s2">,</span>
                        <span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s2">,</span>
                        <span class="s1">_doc_default_example])</span>

<span class="s1">_doc_default_before_notes = </span><span class="s3">''</span><span class="s1">.join([_doc_default_longsummary</span><span class="s2">,</span>
                                     <span class="s1">_doc_allmethods])</span>

<span class="s1">docdict = {</span>
    <span class="s3">'rvs'</span><span class="s1">: _doc_rvs</span><span class="s2">,</span>
    <span class="s3">'pdf'</span><span class="s1">: _doc_pdf</span><span class="s2">,</span>
    <span class="s3">'logpdf'</span><span class="s1">: _doc_logpdf</span><span class="s2">,</span>
    <span class="s3">'cdf'</span><span class="s1">: _doc_cdf</span><span class="s2">,</span>
    <span class="s3">'logcdf'</span><span class="s1">: _doc_logcdf</span><span class="s2">,</span>
    <span class="s3">'sf'</span><span class="s1">: _doc_sf</span><span class="s2">,</span>
    <span class="s3">'logsf'</span><span class="s1">: _doc_logsf</span><span class="s2">,</span>
    <span class="s3">'ppf'</span><span class="s1">: _doc_ppf</span><span class="s2">,</span>
    <span class="s3">'isf'</span><span class="s1">: _doc_isf</span><span class="s2">,</span>
    <span class="s3">'stats'</span><span class="s1">: _doc_stats</span><span class="s2">,</span>
    <span class="s3">'entropy'</span><span class="s1">: _doc_entropy</span><span class="s2">,</span>
    <span class="s3">'fit'</span><span class="s1">: _doc_fit</span><span class="s2">,</span>
    <span class="s3">'moment'</span><span class="s1">: _doc_moment</span><span class="s2">,</span>
    <span class="s3">'expect'</span><span class="s1">: _doc_expect</span><span class="s2">,</span>
    <span class="s3">'interval'</span><span class="s1">: _doc_interval</span><span class="s2">,</span>
    <span class="s3">'mean'</span><span class="s1">: _doc_mean</span><span class="s2">,</span>
    <span class="s3">'std'</span><span class="s1">: _doc_std</span><span class="s2">,</span>
    <span class="s3">'var'</span><span class="s1">: _doc_var</span><span class="s2">,</span>
    <span class="s3">'median'</span><span class="s1">: _doc_median</span><span class="s2">,</span>
    <span class="s3">'allmethods'</span><span class="s1">: _doc_allmethods</span><span class="s2">,</span>
    <span class="s3">'longsummary'</span><span class="s1">: _doc_default_longsummary</span><span class="s2">,</span>
    <span class="s3">'frozennote'</span><span class="s1">: _doc_default_frozen_note</span><span class="s2">,</span>
    <span class="s3">'example'</span><span class="s1">: _doc_default_example</span><span class="s2">,</span>
    <span class="s3">'default'</span><span class="s1">: _doc_default</span><span class="s2">,</span>
    <span class="s3">'before_notes'</span><span class="s1">: _doc_default_before_notes</span><span class="s2">,</span>
    <span class="s3">'after_notes'</span><span class="s1">: _doc_default_locscale</span>
<span class="s1">}</span>

<span class="s0"># Reuse common content between continuous and discrete docs, change some</span>
<span class="s0"># minor bits.</span>
<span class="s1">docdict_discrete = docdict.copy()</span>

<span class="s1">docdict_discrete[</span><span class="s3">'pmf'</span><span class="s1">] = _doc_pmf</span>
<span class="s1">docdict_discrete[</span><span class="s3">'logpmf'</span><span class="s1">] = _doc_logpmf</span>
<span class="s1">docdict_discrete[</span><span class="s3">'expect'</span><span class="s1">] = _doc_expect_discrete</span>
<span class="s1">_doc_disc_methods = [</span><span class="s3">'rvs'</span><span class="s2">, </span><span class="s3">'pmf'</span><span class="s2">, </span><span class="s3">'logpmf'</span><span class="s2">, </span><span class="s3">'cdf'</span><span class="s2">, </span><span class="s3">'logcdf'</span><span class="s2">, </span><span class="s3">'sf'</span><span class="s2">, </span><span class="s3">'logsf'</span><span class="s2">,</span>
                     <span class="s3">'ppf'</span><span class="s2">, </span><span class="s3">'isf'</span><span class="s2">, </span><span class="s3">'stats'</span><span class="s2">, </span><span class="s3">'entropy'</span><span class="s2">, </span><span class="s3">'expect'</span><span class="s2">, </span><span class="s3">'median'</span><span class="s2">,</span>
                     <span class="s3">'mean'</span><span class="s2">, </span><span class="s3">'var'</span><span class="s2">, </span><span class="s3">'std'</span><span class="s2">, </span><span class="s3">'interval'</span><span class="s1">]</span>
<span class="s2">for </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">_doc_disc_methods:</span>
    <span class="s1">docdict_discrete[obj] = docdict_discrete[obj].replace(</span><span class="s3">', scale=1'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span>

<span class="s1">_doc_disc_methods_err_varname = [</span><span class="s3">'cdf'</span><span class="s2">, </span><span class="s3">'logcdf'</span><span class="s2">, </span><span class="s3">'sf'</span><span class="s2">, </span><span class="s3">'logsf'</span><span class="s1">]</span>
<span class="s2">for </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">_doc_disc_methods_err_varname:</span>
    <span class="s1">docdict_discrete[obj] = docdict_discrete[obj].replace(</span><span class="s3">'(x, '</span><span class="s2">, </span><span class="s3">'(k, '</span><span class="s1">)</span>

<span class="s1">docdict_discrete.pop(</span><span class="s3">'pdf'</span><span class="s1">)</span>
<span class="s1">docdict_discrete.pop(</span><span class="s3">'logpdf'</span><span class="s1">)</span>

<span class="s1">_doc_allmethods = </span><span class="s3">''</span><span class="s1">.join([docdict_discrete[obj] </span><span class="s2">for </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">_doc_disc_methods])</span>
<span class="s1">docdict_discrete[</span><span class="s3">'allmethods'</span><span class="s1">] = docheaders[</span><span class="s3">'methods'</span><span class="s1">] + _doc_allmethods</span>

<span class="s1">docdict_discrete[</span><span class="s3">'longsummary'</span><span class="s1">] = _doc_default_longsummary.replace(</span>
    <span class="s3">'rv_continuous'</span><span class="s2">, </span><span class="s3">'rv_discrete'</span><span class="s1">)</span>

<span class="s1">_doc_default_frozen_note = </span><span class="s3">&quot;&quot;&quot; 
Alternatively, the object may be called (as a function) to fix the shape and 
location parameters returning a &quot;frozen&quot; discrete RV object: 
 
rv = %(name)s(%(shapes)s, loc=0) 
    - Frozen RV object with the same methods but holding the given shape and 
      location fixed. 
&quot;&quot;&quot;</span>
<span class="s1">docdict_discrete[</span><span class="s3">'frozennote'</span><span class="s1">] = _doc_default_frozen_note</span>

<span class="s1">_doc_default_discrete_example = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">Examples 
-------- 
&gt;&gt;&gt; import numpy as np 
&gt;&gt;&gt; from scipy.stats import %(name)s 
&gt;&gt;&gt; import matplotlib.pyplot as plt 
&gt;&gt;&gt; fig, ax = plt.subplots(1, 1) 
 
Calculate the first four moments: 
 
%(set_vals_stmt)s 
&gt;&gt;&gt; mean, var, skew, kurt = %(name)s.stats(%(shapes)s, moments='mvsk') 
 
Display the probability mass function (``pmf``): 
 
&gt;&gt;&gt; x = np.arange(%(name)s.ppf(0.01, %(shapes)s), 
...               %(name)s.ppf(0.99, %(shapes)s)) 
&gt;&gt;&gt; ax.plot(x, %(name)s.pmf(x, %(shapes)s), 'bo', ms=8, label='%(name)s pmf') 
&gt;&gt;&gt; ax.vlines(x, 0, %(name)s.pmf(x, %(shapes)s), colors='b', lw=5, alpha=0.5) 
 
Alternatively, the distribution object can be called (as a function) 
to fix the shape and location. This returns a &quot;frozen&quot; RV object holding 
the given parameters fixed. 
 
Freeze the distribution and display the frozen ``pmf``: 
 
&gt;&gt;&gt; rv = %(name)s(%(shapes)s) 
&gt;&gt;&gt; ax.vlines(x, 0, rv.pmf(x), colors='k', linestyles='-', lw=1, 
...         label='frozen pmf') 
&gt;&gt;&gt; ax.legend(loc='best', frameon=False) 
&gt;&gt;&gt; plt.show() 
 
Check accuracy of ``cdf`` and ``ppf``: 
 
&gt;&gt;&gt; prob = %(name)s.cdf(x, %(shapes)s) 
&gt;&gt;&gt; np.allclose(x, %(name)s.ppf(prob, %(shapes)s)) 
True 
 
Generate random numbers: 
 
&gt;&gt;&gt; r = %(name)s.rvs(%(shapes)s, size=1000) 
&quot;&quot;&quot;</span>


<span class="s1">_doc_default_discrete_locscale = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">The probability mass function above is defined in the &quot;standardized&quot; form. 
To shift distribution use the ``loc`` parameter. 
Specifically, ``%(name)s.pmf(k, %(shapes)s, loc)`` is identically 
equivalent to ``%(name)s.pmf(k - loc, %(shapes)s)``. 
&quot;&quot;&quot;</span>

<span class="s1">docdict_discrete[</span><span class="s3">'example'</span><span class="s1">] = _doc_default_discrete_example</span>
<span class="s1">docdict_discrete[</span><span class="s3">'after_notes'</span><span class="s1">] = _doc_default_discrete_locscale</span>

<span class="s1">_doc_default_before_notes = </span><span class="s3">''</span><span class="s1">.join([docdict_discrete[</span><span class="s3">'longsummary'</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">docdict_discrete[</span><span class="s3">'allmethods'</span><span class="s1">]])</span>
<span class="s1">docdict_discrete[</span><span class="s3">'before_notes'</span><span class="s1">] = _doc_default_before_notes</span>

<span class="s1">_doc_default_disc = </span><span class="s3">''</span><span class="s1">.join([docdict_discrete[</span><span class="s3">'longsummary'</span><span class="s1">]</span><span class="s2">,</span>
                             <span class="s1">docdict_discrete[</span><span class="s3">'allmethods'</span><span class="s1">]</span><span class="s2">,</span>
                             <span class="s1">docdict_discrete[</span><span class="s3">'frozennote'</span><span class="s1">]</span><span class="s2">,</span>
                             <span class="s1">docdict_discrete[</span><span class="s3">'example'</span><span class="s1">]])</span>
<span class="s1">docdict_discrete[</span><span class="s3">'default'</span><span class="s1">] = _doc_default_disc</span>

<span class="s0"># clean up all the separate docstring elements, we do not need them anymore</span>
<span class="s2">for </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">[s </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">dir() </span><span class="s2">if </span><span class="s1">s.startswith(</span><span class="s3">'_doc_'</span><span class="s1">)]:</span>
    <span class="s1">exec(</span><span class="s3">'del ' </span><span class="s1">+ obj)</span>
<span class="s2">del </span><span class="s1">obj</span>


<span class="s2">def </span><span class="s1">_moment(data</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">mu=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">if </span><span class="s1">mu </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">mu = data.mean()</span>
    <span class="s2">return </span><span class="s1">((data - mu)**n).mean()</span>


<span class="s2">def </span><span class="s1">_moment_from_stats(n</span><span class="s2">, </span><span class="s1">mu</span><span class="s2">, </span><span class="s1">mu2</span><span class="s2">, </span><span class="s1">g1</span><span class="s2">, </span><span class="s1">g2</span><span class="s2">, </span><span class="s1">moment_func</span><span class="s2">, </span><span class="s1">args):</span>
    <span class="s2">if </span><span class="s1">(n == </span><span class="s4">0</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s4">1.0</span>
    <span class="s2">elif </span><span class="s1">(n == </span><span class="s4">1</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">mu </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">val = moment_func(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">*args)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">val = mu</span>
    <span class="s2">elif </span><span class="s1">(n == </span><span class="s4">2</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">mu2 </span><span class="s2">is None or </span><span class="s1">mu </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">val = moment_func(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">*args)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">val = mu2 + mu*mu</span>
    <span class="s2">elif </span><span class="s1">(n == </span><span class="s4">3</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">g1 </span><span class="s2">is None or </span><span class="s1">mu2 </span><span class="s2">is None or </span><span class="s1">mu </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">val = moment_func(</span><span class="s4">3</span><span class="s2">, </span><span class="s1">*args)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">mu3 = g1 * np.power(mu2</span><span class="s2">, </span><span class="s4">1.5</span><span class="s1">)  </span><span class="s0"># 3rd central moment</span>
            <span class="s1">val = mu3+</span><span class="s4">3</span><span class="s1">*mu*mu2+mu*mu*mu  </span><span class="s0"># 3rd non-central moment</span>
    <span class="s2">elif </span><span class="s1">(n == </span><span class="s4">4</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">g1 </span><span class="s2">is None or </span><span class="s1">g2 </span><span class="s2">is None or </span><span class="s1">mu2 </span><span class="s2">is None or </span><span class="s1">mu </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">val = moment_func(</span><span class="s4">4</span><span class="s2">, </span><span class="s1">*args)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">mu4 = (g2+</span><span class="s4">3.0</span><span class="s1">)*(mu2**</span><span class="s4">2.0</span><span class="s1">)  </span><span class="s0"># 4th central moment</span>
            <span class="s1">mu3 = g1*np.power(mu2</span><span class="s2">, </span><span class="s4">1.5</span><span class="s1">)  </span><span class="s0"># 3rd central moment</span>
            <span class="s1">val = mu4+</span><span class="s4">4</span><span class="s1">*mu*mu3+</span><span class="s4">6</span><span class="s1">*mu*mu*mu2+mu*mu*mu*mu</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">val = moment_func(n</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s2">return </span><span class="s1">val</span>


<span class="s2">def </span><span class="s1">_skew(data):</span>
    <span class="s5">&quot;&quot;&quot; 
    skew is third central moment / variance**(1.5) 
    &quot;&quot;&quot;</span>
    <span class="s1">data = np.ravel(data)</span>
    <span class="s1">mu = data.mean()</span>
    <span class="s1">m2 = ((data - mu)**</span><span class="s4">2</span><span class="s1">).mean()</span>
    <span class="s1">m3 = ((data - mu)**</span><span class="s4">3</span><span class="s1">).mean()</span>
    <span class="s2">return </span><span class="s1">m3 / np.power(m2</span><span class="s2">, </span><span class="s4">1.5</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_kurtosis(data):</span>
    <span class="s5">&quot;&quot;&quot;kurtosis is fourth central moment / variance**2 - 3.&quot;&quot;&quot;</span>
    <span class="s1">data = np.ravel(data)</span>
    <span class="s1">mu = data.mean()</span>
    <span class="s1">m2 = ((data - mu)**</span><span class="s4">2</span><span class="s1">).mean()</span>
    <span class="s1">m4 = ((data - mu)**</span><span class="s4">4</span><span class="s1">).mean()</span>
    <span class="s2">return </span><span class="s1">m4 / m2**</span><span class="s4">2 </span><span class="s1">- </span><span class="s4">3</span>


<span class="s2">def </span><span class="s1">_fit_determine_optimizer(optimizer):</span>
    <span class="s2">if not </span><span class="s1">callable(optimizer) </span><span class="s2">and </span><span class="s1">isinstance(optimizer</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s2">if not </span><span class="s1">optimizer.startswith(</span><span class="s3">'fmin_'</span><span class="s1">):</span>
            <span class="s1">optimizer = </span><span class="s3">&quot;fmin_&quot;</span><span class="s1">+optimizer</span>
        <span class="s2">if </span><span class="s1">optimizer == </span><span class="s3">'fmin_'</span><span class="s1">:</span>
            <span class="s1">optimizer = </span><span class="s3">'fmin'</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">optimizer = getattr(optimize</span><span class="s2">, </span><span class="s1">optimizer)</span>
        <span class="s2">except </span><span class="s1">AttributeError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;%s is not a valid optimizer&quot; </span><span class="s1">% optimizer) </span><span class="s2">from </span><span class="s1">e</span>
    <span class="s2">return </span><span class="s1">optimizer</span>


<span class="s2">def </span><span class="s1">_sum_finite(x):</span>
    <span class="s5">&quot;&quot;&quot; 
    For a 1D array x, return a tuple containing the sum of the 
    finite values of x and the number of nonfinite values. 
 
    This is a utility function used when evaluating the negative 
    loglikelihood for a distribution and an array of samples. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; tot, nbad = _sum_finite(np.array([-2, -np.inf, 5, 1])) 
    &gt;&gt;&gt; tot 
    4.0 
    &gt;&gt;&gt; nbad 
    1 
    &quot;&quot;&quot;</span>
    <span class="s1">finite_x = np.isfinite(x)</span>
    <span class="s1">bad_count = finite_x.size - np.count_nonzero(finite_x)</span>
    <span class="s2">return </span><span class="s1">np.sum(x[finite_x])</span><span class="s2">, </span><span class="s1">bad_count</span>


<span class="s0"># Frozen RV class</span>
<span class="s2">class </span><span class="s1">rv_frozen:</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">dist</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s1">self.args = args</span>
        <span class="s1">self.kwds = kwds</span>

        <span class="s0"># create a new instance</span>
        <span class="s1">self.dist = dist.__class__(**dist._updated_ctor_param())</span>

        <span class="s1">shapes</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_ = self.dist._parse_args(*args</span><span class="s2">, </span><span class="s1">**kwds)</span>
        <span class="s1">self.a</span><span class="s2">, </span><span class="s1">self.b = self.dist._get_support(*shapes)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">random_state(self):</span>
        <span class="s2">return </span><span class="s1">self.dist._random_state</span>

    <span class="s1">@random_state.setter</span>
    <span class="s2">def </span><span class="s1">random_state(self</span><span class="s2">, </span><span class="s1">seed):</span>
        <span class="s1">self.dist._random_state = check_random_state(seed)</span>

    <span class="s2">def </span><span class="s1">cdf(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">self.dist.cdf(x</span><span class="s2">, </span><span class="s1">*self.args</span><span class="s2">, </span><span class="s1">**self.kwds)</span>

    <span class="s2">def </span><span class="s1">logcdf(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">self.dist.logcdf(x</span><span class="s2">, </span><span class="s1">*self.args</span><span class="s2">, </span><span class="s1">**self.kwds)</span>

    <span class="s2">def </span><span class="s1">ppf(self</span><span class="s2">, </span><span class="s1">q):</span>
        <span class="s2">return </span><span class="s1">self.dist.ppf(q</span><span class="s2">, </span><span class="s1">*self.args</span><span class="s2">, </span><span class="s1">**self.kwds)</span>

    <span class="s2">def </span><span class="s1">isf(self</span><span class="s2">, </span><span class="s1">q):</span>
        <span class="s2">return </span><span class="s1">self.dist.isf(q</span><span class="s2">, </span><span class="s1">*self.args</span><span class="s2">, </span><span class="s1">**self.kwds)</span>

    <span class="s2">def </span><span class="s1">rvs(self</span><span class="s2">, </span><span class="s1">size=</span><span class="s2">None, </span><span class="s1">random_state=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">kwds = self.kwds.copy()</span>
        <span class="s1">kwds.update({</span><span class="s3">'size'</span><span class="s1">: size</span><span class="s2">, </span><span class="s3">'random_state'</span><span class="s1">: random_state})</span>
        <span class="s2">return </span><span class="s1">self.dist.rvs(*self.args</span><span class="s2">, </span><span class="s1">**kwds)</span>

    <span class="s2">def </span><span class="s1">sf(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">self.dist.sf(x</span><span class="s2">, </span><span class="s1">*self.args</span><span class="s2">, </span><span class="s1">**self.kwds)</span>

    <span class="s2">def </span><span class="s1">logsf(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">self.dist.logsf(x</span><span class="s2">, </span><span class="s1">*self.args</span><span class="s2">, </span><span class="s1">**self.kwds)</span>

    <span class="s2">def </span><span class="s1">stats(self</span><span class="s2">, </span><span class="s1">moments=</span><span class="s3">'mv'</span><span class="s1">):</span>
        <span class="s1">kwds = self.kwds.copy()</span>
        <span class="s1">kwds.update({</span><span class="s3">'moments'</span><span class="s1">: moments})</span>
        <span class="s2">return </span><span class="s1">self.dist.stats(*self.args</span><span class="s2">, </span><span class="s1">**kwds)</span>

    <span class="s2">def </span><span class="s1">median(self):</span>
        <span class="s2">return </span><span class="s1">self.dist.median(*self.args</span><span class="s2">, </span><span class="s1">**self.kwds)</span>

    <span class="s2">def </span><span class="s1">mean(self):</span>
        <span class="s2">return </span><span class="s1">self.dist.mean(*self.args</span><span class="s2">, </span><span class="s1">**self.kwds)</span>

    <span class="s2">def </span><span class="s1">var(self):</span>
        <span class="s2">return </span><span class="s1">self.dist.var(*self.args</span><span class="s2">, </span><span class="s1">**self.kwds)</span>

    <span class="s2">def </span><span class="s1">std(self):</span>
        <span class="s2">return </span><span class="s1">self.dist.std(*self.args</span><span class="s2">, </span><span class="s1">**self.kwds)</span>

    <span class="s2">def </span><span class="s1">moment(self</span><span class="s2">, </span><span class="s1">order=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">self.dist.moment(order</span><span class="s2">, </span><span class="s1">*self.args</span><span class="s2">, </span><span class="s1">**self.kwds)</span>

    <span class="s2">def </span><span class="s1">entropy(self):</span>
        <span class="s2">return </span><span class="s1">self.dist.entropy(*self.args</span><span class="s2">, </span><span class="s1">**self.kwds)</span>

    <span class="s2">def </span><span class="s1">interval(self</span><span class="s2">, </span><span class="s1">confidence=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">self.dist.interval(confidence</span><span class="s2">, </span><span class="s1">*self.args</span><span class="s2">, </span><span class="s1">**self.kwds)</span>

    <span class="s2">def </span><span class="s1">expect(self</span><span class="s2">, </span><span class="s1">func=</span><span class="s2">None, </span><span class="s1">lb=</span><span class="s2">None, </span><span class="s1">ub=</span><span class="s2">None, </span><span class="s1">conditional=</span><span class="s2">False, </span><span class="s1">**kwds):</span>
        <span class="s0"># expect method only accepts shape parameters as positional args</span>
        <span class="s0"># hence convert self.args, self.kwds, also loc/scale</span>
        <span class="s0"># See the .expect method docstrings for the meaning of</span>
        <span class="s0"># other parameters.</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = self.dist._parse_args(*self.args</span><span class="s2">, </span><span class="s1">**self.kwds)</span>
        <span class="s2">if </span><span class="s1">isinstance(self.dist</span><span class="s2">, </span><span class="s1">rv_discrete):</span>
            <span class="s2">return </span><span class="s1">self.dist.expect(func</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">lb</span><span class="s2">, </span><span class="s1">ub</span><span class="s2">, </span><span class="s1">conditional</span><span class="s2">, </span><span class="s1">**kwds)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.dist.expect(func</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">lb</span><span class="s2">, </span><span class="s1">ub</span><span class="s2">,</span>
                                    <span class="s1">conditional</span><span class="s2">, </span><span class="s1">**kwds)</span>

    <span class="s2">def </span><span class="s1">support(self):</span>
        <span class="s2">return </span><span class="s1">self.dist.support(*self.args</span><span class="s2">, </span><span class="s1">**self.kwds)</span>


<span class="s2">class </span><span class="s1">rv_discrete_frozen(rv_frozen):</span>

    <span class="s2">def </span><span class="s1">pmf(self</span><span class="s2">, </span><span class="s1">k):</span>
        <span class="s2">return </span><span class="s1">self.dist.pmf(k</span><span class="s2">, </span><span class="s1">*self.args</span><span class="s2">, </span><span class="s1">**self.kwds)</span>

    <span class="s2">def </span><span class="s1">logpmf(self</span><span class="s2">, </span><span class="s1">k):  </span><span class="s0"># No error</span>
        <span class="s2">return </span><span class="s1">self.dist.logpmf(k</span><span class="s2">, </span><span class="s1">*self.args</span><span class="s2">, </span><span class="s1">**self.kwds)</span>


<span class="s2">class </span><span class="s1">rv_continuous_frozen(rv_frozen):</span>

    <span class="s2">def </span><span class="s1">pdf(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">self.dist.pdf(x</span><span class="s2">, </span><span class="s1">*self.args</span><span class="s2">, </span><span class="s1">**self.kwds)</span>

    <span class="s2">def </span><span class="s1">logpdf(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">self.dist.logpdf(x</span><span class="s2">, </span><span class="s1">*self.args</span><span class="s2">, </span><span class="s1">**self.kwds)</span>


<span class="s2">def </span><span class="s1">argsreduce(cond</span><span class="s2">, </span><span class="s1">*args):</span>
    <span class="s5">&quot;&quot;&quot;Clean arguments to: 
 
    1. Ensure all arguments are iterable (arrays of dimension at least one 
    2. If cond != True and size &gt; 1, ravel(args[i]) where ravel(condition) is 
       True, in 1D. 
 
    Return list of processed arguments. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; A = rng.random((4, 5)) 
    &gt;&gt;&gt; B = 2 
    &gt;&gt;&gt; C = rng.random((1, 5)) 
    &gt;&gt;&gt; cond = np.ones(A.shape) 
    &gt;&gt;&gt; [A1, B1, C1] = argsreduce(cond, A, B, C) 
    &gt;&gt;&gt; A1.shape 
    (4, 5) 
    &gt;&gt;&gt; B1.shape 
    (1,) 
    &gt;&gt;&gt; C1.shape 
    (1, 5) 
    &gt;&gt;&gt; cond[2,:] = 0 
    &gt;&gt;&gt; [A1, B1, C1] = argsreduce(cond, A, B, C) 
    &gt;&gt;&gt; A1.shape 
    (15,) 
    &gt;&gt;&gt; B1.shape 
    (1,) 
    &gt;&gt;&gt; C1.shape 
    (15,) 
 
    &quot;&quot;&quot;</span>
    <span class="s0"># some distributions assume arguments are iterable.</span>
    <span class="s1">newargs = np.atleast_1d(*args)</span>

    <span class="s0"># np.atleast_1d returns an array if only one argument, or a list of arrays</span>
    <span class="s0"># if more than one argument.</span>
    <span class="s2">if not </span><span class="s1">isinstance(newargs</span><span class="s2">, </span><span class="s1">list):</span>
        <span class="s1">newargs = [newargs</span><span class="s2">, </span><span class="s1">]</span>

    <span class="s2">if </span><span class="s1">np.all(cond):</span>
        <span class="s0"># broadcast arrays with cond</span>
        <span class="s1">*newargs</span><span class="s2">, </span><span class="s1">cond = np.broadcast_arrays(*newargs</span><span class="s2">, </span><span class="s1">cond)</span>
        <span class="s2">return </span><span class="s1">[arg.ravel() </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">newargs]</span>

    <span class="s1">s = cond.shape</span>
    <span class="s0"># np.extract returns flattened arrays, which are not broadcastable together</span>
    <span class="s0"># unless they are either the same size or size == 1.</span>
    <span class="s2">return </span><span class="s1">[(arg </span><span class="s2">if </span><span class="s1">np.size(arg) == </span><span class="s4">1</span>
            <span class="s2">else </span><span class="s1">np.extract(cond</span><span class="s2">, </span><span class="s1">np.broadcast_to(arg</span><span class="s2">, </span><span class="s1">s)))</span>
            <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">newargs]</span>


<span class="s1">parse_arg_template = </span><span class="s3">&quot;&quot;&quot; 
def _parse_args(self, %(shape_arg_str)s %(locscale_in)s): 
    return (%(shape_arg_str)s), %(locscale_out)s 
 
def _parse_args_rvs(self, %(shape_arg_str)s %(locscale_in)s, size=None): 
    return self._argcheck_rvs(%(shape_arg_str)s %(locscale_out)s, size=size) 
 
def _parse_args_stats(self, %(shape_arg_str)s %(locscale_in)s, moments='mv'): 
    return (%(shape_arg_str)s), %(locscale_out)s, moments 
&quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">rv_generic:</span>
    <span class="s5">&quot;&quot;&quot;Class which encapsulates common functionality between rv_discrete 
    and rv_continuous. 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">seed=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">super().__init__()</span>

        <span class="s0"># figure out if _stats signature has 'moments' keyword</span>
        <span class="s1">sig = _getfullargspec(self._stats)</span>
        <span class="s1">self._stats_has_moments = ((sig.varkw </span><span class="s2">is not None</span><span class="s1">) </span><span class="s2">or</span>
                                   <span class="s1">(</span><span class="s3">'moments' </span><span class="s2">in </span><span class="s1">sig.args) </span><span class="s2">or</span>
                                   <span class="s1">(</span><span class="s3">'moments' </span><span class="s2">in </span><span class="s1">sig.kwonlyargs))</span>
        <span class="s1">self._random_state = check_random_state(seed)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">random_state(self):</span>
        <span class="s5">&quot;&quot;&quot;Get or set the generator object for generating random variates. 
 
        If `random_state` is None (or `np.random`), the 
        `numpy.random.RandomState` singleton is used. 
        If `random_state` is an int, a new ``RandomState`` instance is used, 
        seeded with `random_state`. 
        If `random_state` is already a ``Generator`` or ``RandomState`` 
        instance, that instance is used. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._random_state</span>

    <span class="s1">@random_state.setter</span>
    <span class="s2">def </span><span class="s1">random_state(self</span><span class="s2">, </span><span class="s1">seed):</span>
        <span class="s1">self._random_state = check_random_state(seed)</span>

    <span class="s2">def </span><span class="s1">__setstate__(self</span><span class="s2">, </span><span class="s1">state):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self.__dict__.update(state)</span>
            <span class="s0"># attaches the dynamically created methods on each instance.</span>
            <span class="s0"># if a subclass overrides rv_generic.__setstate__, or implements</span>
            <span class="s0"># it's own _attach_methods, then it must make sure that</span>
            <span class="s0"># _attach_argparser_methods is called.</span>
            <span class="s1">self._attach_methods()</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s0"># reconstitute an old pickle scipy&lt;1.6, that contains</span>
            <span class="s0"># (_ctor_param, random_state) as state</span>
            <span class="s1">self._ctor_param = state[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">self._random_state = state[</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">self.__init__()</span>

    <span class="s2">def </span><span class="s1">_attach_methods(self):</span>
        <span class="s5">&quot;&quot;&quot;Attaches dynamically created methods to the rv_* instance. 
 
        This method must be overridden by subclasses, and must itself call 
         _attach_argparser_methods. This method is called in __init__ in 
         subclasses, and in __setstate__ 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">_attach_argparser_methods(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Generates the argument-parsing functions dynamically and attaches 
        them to the instance. 
 
        Should be called from `_attach_methods`, typically in __init__ and 
        during unpickling (__setstate__) 
        &quot;&quot;&quot;</span>
        <span class="s1">ns = {}</span>
        <span class="s1">exec(self._parse_arg_template</span><span class="s2">, </span><span class="s1">ns)</span>
        <span class="s0"># NB: attach to the instance, not class</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'_parse_args'</span><span class="s2">, </span><span class="s3">'_parse_args_stats'</span><span class="s2">, </span><span class="s3">'_parse_args_rvs'</span><span class="s1">]:</span>
            <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">types.MethodType(ns[name]</span><span class="s2">, </span><span class="s1">self))</span>

    <span class="s2">def </span><span class="s1">_construct_argparser(</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">meths_to_inspect</span><span class="s2">, </span><span class="s1">locscale_in</span><span class="s2">, </span><span class="s1">locscale_out):</span>
        <span class="s5">&quot;&quot;&quot;Construct the parser string for the shape arguments. 
 
        This method should be called in __init__ of a class for each 
        distribution. It creates the `_parse_arg_template` attribute that is 
        then used by `_attach_argparser_methods` to dynamically create and 
        attach the `_parse_args`, `_parse_args_stats`, `_parse_args_rvs` 
        methods to the instance. 
 
        If self.shapes is a non-empty string, interprets it as a 
        comma-separated list of shape parameters. 
 
        Otherwise inspects the call signatures of `meths_to_inspect` 
        and constructs the argument-parsing functions from these. 
        In this case also sets `shapes` and `numargs`. 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">self.shapes:</span>
            <span class="s0"># sanitize the user-supplied shapes</span>
            <span class="s2">if not </span><span class="s1">isinstance(self.shapes</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">'shapes must be a string.'</span><span class="s1">)</span>

            <span class="s1">shapes = self.shapes.replace(</span><span class="s3">','</span><span class="s2">, </span><span class="s3">' '</span><span class="s1">).split()</span>

            <span class="s2">for </span><span class="s1">field </span><span class="s2">in </span><span class="s1">shapes:</span>
                <span class="s2">if </span><span class="s1">keyword.iskeyword(field):</span>
                    <span class="s2">raise </span><span class="s1">SyntaxError(</span><span class="s3">'keywords cannot be used as shapes.'</span><span class="s1">)</span>
                <span class="s2">if not </span><span class="s1">re.match(</span><span class="s3">'^[_a-zA-Z][_a-zA-Z0-9]*$'</span><span class="s2">, </span><span class="s1">field):</span>
                    <span class="s2">raise </span><span class="s1">SyntaxError(</span>
                        <span class="s3">'shapes must be valid python identifiers'</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># find out the call signatures (_pdf, _cdf etc), deduce shape</span>
            <span class="s0"># arguments. Generic methods only have 'self, x', any further args</span>
            <span class="s0"># are shapes.</span>
            <span class="s1">shapes_list = []</span>
            <span class="s2">for </span><span class="s1">meth </span><span class="s2">in </span><span class="s1">meths_to_inspect:</span>
                <span class="s1">shapes_args = _getfullargspec(meth)  </span><span class="s0"># NB does not contain self</span>
                <span class="s1">args = shapes_args.args[</span><span class="s4">1</span><span class="s1">:]       </span><span class="s0"># peel off 'x', too</span>

                <span class="s2">if </span><span class="s1">args:</span>
                    <span class="s1">shapes_list.append(args)</span>

                    <span class="s0"># *args or **kwargs are not allowed w/automatic shapes</span>
                    <span class="s2">if </span><span class="s1">shapes_args.varargs </span><span class="s2">is not None</span><span class="s1">:</span>
                        <span class="s2">raise </span><span class="s1">TypeError(</span>
                            <span class="s3">'*args are not allowed w/out explicit shapes'</span><span class="s1">)</span>
                    <span class="s2">if </span><span class="s1">shapes_args.varkw </span><span class="s2">is not None</span><span class="s1">:</span>
                        <span class="s2">raise </span><span class="s1">TypeError(</span>
                            <span class="s3">'**kwds are not allowed w/out explicit shapes'</span><span class="s1">)</span>
                    <span class="s2">if </span><span class="s1">shapes_args.kwonlyargs:</span>
                        <span class="s2">raise </span><span class="s1">TypeError(</span>
                            <span class="s3">'kwonly args are not allowed w/out explicit shapes'</span><span class="s1">)</span>
                    <span class="s2">if </span><span class="s1">shapes_args.defaults </span><span class="s2">is not None</span><span class="s1">:</span>
                        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">'defaults are not allowed for shapes'</span><span class="s1">)</span>

            <span class="s2">if </span><span class="s1">shapes_list:</span>
                <span class="s1">shapes = shapes_list[</span><span class="s4">0</span><span class="s1">]</span>

                <span class="s0"># make sure the signatures are consistent</span>
                <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">shapes_list:</span>
                    <span class="s2">if </span><span class="s1">item != shapes:</span>
                        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">'Shape arguments are inconsistent.'</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">shapes = []</span>

        <span class="s0"># have the arguments, construct the method from template</span>
        <span class="s1">shapes_str = </span><span class="s3">', '</span><span class="s1">.join(shapes) + </span><span class="s3">', ' </span><span class="s2">if </span><span class="s1">shapes </span><span class="s2">else </span><span class="s3">''  </span><span class="s0"># NB: not None</span>
        <span class="s1">dct = dict(shape_arg_str=shapes_str</span><span class="s2">,</span>
                   <span class="s1">locscale_in=locscale_in</span><span class="s2">,</span>
                   <span class="s1">locscale_out=locscale_out</span><span class="s2">,</span>
                   <span class="s1">)</span>

        <span class="s0"># this string is used by _attach_argparser_methods</span>
        <span class="s1">self._parse_arg_template = parse_arg_template % dct</span>

        <span class="s1">self.shapes = </span><span class="s3">', '</span><span class="s1">.join(shapes) </span><span class="s2">if </span><span class="s1">shapes </span><span class="s2">else None</span>
        <span class="s2">if not </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s3">'numargs'</span><span class="s1">):</span>
            <span class="s0"># allows more general subclassing with *args</span>
            <span class="s1">self.numargs = len(shapes)</span>

    <span class="s2">def </span><span class="s1">_construct_doc(self</span><span class="s2">, </span><span class="s1">docdict</span><span class="s2">, </span><span class="s1">shapes_vals=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Construct the instance docstring with string substitutions.&quot;&quot;&quot;</span>
        <span class="s1">tempdict = docdict.copy()</span>
        <span class="s1">tempdict[</span><span class="s3">'name'</span><span class="s1">] = self.name </span><span class="s2">or </span><span class="s3">'distname'</span>
        <span class="s1">tempdict[</span><span class="s3">'shapes'</span><span class="s1">] = self.shapes </span><span class="s2">or </span><span class="s3">''</span>

        <span class="s2">if </span><span class="s1">shapes_vals </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">shapes_vals = ()</span>
        <span class="s1">vals = </span><span class="s3">', '</span><span class="s1">.join(</span><span class="s3">'%.3g' </span><span class="s1">% val </span><span class="s2">for </span><span class="s1">val </span><span class="s2">in </span><span class="s1">shapes_vals)</span>
        <span class="s1">tempdict[</span><span class="s3">'vals'</span><span class="s1">] = vals</span>

        <span class="s1">tempdict[</span><span class="s3">'shapes_'</span><span class="s1">] = self.shapes </span><span class="s2">or </span><span class="s3">''</span>
        <span class="s2">if </span><span class="s1">self.shapes </span><span class="s2">and </span><span class="s1">self.numargs == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">tempdict[</span><span class="s3">'shapes_'</span><span class="s1">] += </span><span class="s3">','</span>

        <span class="s2">if </span><span class="s1">self.shapes:</span>
            <span class="s1">tempdict[</span><span class="s3">'set_vals_stmt'</span><span class="s1">] = </span><span class="s3">f'&gt;&gt;&gt; </span><span class="s2">{</span><span class="s1">self.shapes</span><span class="s2">} </span><span class="s3">= </span><span class="s2">{</span><span class="s1">vals</span><span class="s2">}</span><span class="s3">'</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">tempdict[</span><span class="s3">'set_vals_stmt'</span><span class="s1">] = </span><span class="s3">''</span>

        <span class="s2">if </span><span class="s1">self.shapes </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s0"># remove shapes from call parameters if there are none</span>
            <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'default'</span><span class="s2">, </span><span class="s3">'before_notes'</span><span class="s1">]:</span>
                <span class="s1">tempdict[item] = tempdict[item].replace(</span>
                    <span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">%(shapes)s : array_like</span><span class="s2">\n    </span><span class="s3">shape parameters&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">2</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">self.shapes </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s0"># necessary because we use %(shapes)s in two forms (w w/o &quot;, &quot;)</span>
                <span class="s1">self.__doc__ = self.__doc__.replace(</span><span class="s3">&quot;%(shapes)s, &quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">self.__doc__ = doccer.docformat(self.__doc__</span><span class="s2">, </span><span class="s1">tempdict)</span>
            <span class="s2">except </span><span class="s1">TypeError </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s2">raise </span><span class="s1">Exception(</span><span class="s3">&quot;Unable to construct docstring for &quot;</span>
                                <span class="s3">&quot;distribution </span><span class="s2">\&quot;</span><span class="s3">%s</span><span class="s2">\&quot;</span><span class="s3">: %s&quot; </span><span class="s1">%</span>
                                <span class="s1">(self.name</span><span class="s2">, </span><span class="s1">repr(e))) </span><span class="s2">from </span><span class="s1">e</span>

        <span class="s0"># correct for empty shapes</span>
        <span class="s1">self.__doc__ = self.__doc__.replace(</span><span class="s3">'(, '</span><span class="s2">, </span><span class="s3">'('</span><span class="s1">).replace(</span><span class="s3">', )'</span><span class="s2">, </span><span class="s3">')'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_construct_default_doc(self</span><span class="s2">, </span><span class="s1">longname=</span><span class="s2">None,</span>
                               <span class="s1">docdict=</span><span class="s2">None, </span><span class="s1">discrete=</span><span class="s3">'continuous'</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Construct instance docstring from the default template.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">longname </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">longname = </span><span class="s3">'A'</span>
        <span class="s1">self.__doc__ = </span><span class="s3">''</span><span class="s1">.join([</span><span class="s3">f'</span><span class="s2">{</span><span class="s1">longname</span><span class="s2">} {</span><span class="s1">discrete</span><span class="s2">} </span><span class="s3">random variable.'</span><span class="s2">,</span>
                                <span class="s3">'</span><span class="s2">\n\n</span><span class="s3">%(before_notes)s</span><span class="s2">\n</span><span class="s3">'</span><span class="s2">, </span><span class="s1">docheaders[</span><span class="s3">'notes'</span><span class="s1">]</span><span class="s2">,</span>
                                <span class="s3">'</span><span class="s2">\n</span><span class="s3">%(example)s'</span><span class="s1">])</span>
        <span class="s1">self._construct_doc(docdict)</span>

    <span class="s2">def </span><span class="s1">freeze(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s5">&quot;&quot;&quot;Freeze the distribution for the given arguments. 
 
        Parameters 
        ---------- 
        arg1, arg2, arg3,... : array_like 
            The shape parameter(s) for the distribution.  Should include all 
            the non-optional arguments, may include ``loc`` and ``scale``. 
 
        Returns 
        ------- 
        rv_frozen : rv_frozen instance 
            The frozen distribution. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(self</span><span class="s2">, </span><span class="s1">rv_continuous):</span>
            <span class="s2">return </span><span class="s1">rv_continuous_frozen(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">rv_discrete_frozen(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds)</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s2">return </span><span class="s1">self.freeze(*args</span><span class="s2">, </span><span class="s1">**kwds)</span>
    <span class="s1">__call__.__doc__ = freeze.__doc__</span>

    <span class="s0"># The actual calculation functions (no basic checking need be done)</span>
    <span class="s0"># If these are defined, the others won't be looked at.</span>
    <span class="s0"># Otherwise, the other set can be defined.</span>
    <span class="s2">def </span><span class="s1">_stats(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s2">return None, None, None, None</span>

    <span class="s0"># Noncentral moments (also known as the moment about the origin).</span>
    <span class="s0"># Expressed in LaTeX, munp would be $\mu'_{n}$, i.e. &quot;mu-sub-n-prime&quot;.</span>
    <span class="s0"># The primed mu is a widely used notation for the noncentral moment.</span>
    <span class="s2">def </span><span class="s1">_munp(self</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s0"># Silence floating point warnings from integration.</span>
        <span class="s2">with </span><span class="s1">np.errstate(all=</span><span class="s3">'ignore'</span><span class="s1">):</span>
            <span class="s1">vals = self.generic_moment(n</span><span class="s2">, </span><span class="s1">*args)</span>
        <span class="s2">return </span><span class="s1">vals</span>

    <span class="s2">def </span><span class="s1">_argcheck_rvs(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0"># Handle broadcasting and size validation of the rvs method.</span>
        <span class="s0"># Subclasses should not have to override this method.</span>
        <span class="s0"># The rule is that if `size` is not None, then `size` gives the</span>
        <span class="s0"># shape of the result (integer values of `size` are treated as</span>
        <span class="s0"># tuples with length 1; i.e. `size=3` is the same as `size=(3,)`.)</span>
        <span class="s0">#</span>
        <span class="s0"># `args` is expected to contain the shape parameters (if any), the</span>
        <span class="s0"># location and the scale in a flat tuple (e.g. if there are two</span>
        <span class="s0"># shape parameters `a` and `b`, `args` will be `(a, b, loc, scale)`).</span>
        <span class="s0"># The only keyword argument expected is 'size'.</span>
        <span class="s1">size = kwargs.get(</span><span class="s3">'size'</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">all_bcast = np.broadcast_arrays(*args)</span>

        <span class="s2">def </span><span class="s1">squeeze_left(a):</span>
            <span class="s2">while </span><span class="s1">a.ndim &gt; </span><span class="s4">0 </span><span class="s2">and </span><span class="s1">a.shape[</span><span class="s4">0</span><span class="s1">] == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">a = a[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s2">return </span><span class="s1">a</span>

        <span class="s0"># Eliminate trivial leading dimensions.  In the convention</span>
        <span class="s0"># used by numpy's random variate generators, trivial leading</span>
        <span class="s0"># dimensions are effectively ignored.  In other words, when `size`</span>
        <span class="s0"># is given, trivial leading dimensions of the broadcast parameters</span>
        <span class="s0"># in excess of the number of dimensions  in size are ignored, e.g.</span>
        <span class="s0">#   &gt;&gt;&gt; np.random.normal([[1, 3, 5]], [[[[0.01]]]], size=3)</span>
        <span class="s0">#   array([ 1.00104267,  3.00422496,  4.99799278])</span>
        <span class="s0"># If `size` is not given, the exact broadcast shape is preserved:</span>
        <span class="s0">#   &gt;&gt;&gt; np.random.normal([[1, 3, 5]], [[[[0.01]]]])</span>
        <span class="s0">#   array([[[[ 1.00862899,  3.00061431,  4.99867122]]]])</span>
        <span class="s0">#</span>
        <span class="s1">all_bcast = [squeeze_left(a) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">all_bcast]</span>
        <span class="s1">bcast_shape = all_bcast[</span><span class="s4">0</span><span class="s1">].shape</span>
        <span class="s1">bcast_ndim = all_bcast[</span><span class="s4">0</span><span class="s1">].ndim</span>

        <span class="s2">if </span><span class="s1">size </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">size_ = bcast_shape</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">size_ = tuple(np.atleast_1d(size))</span>

        <span class="s0"># Check compatibility of size_ with the broadcast shape of all</span>
        <span class="s0"># the parameters.  This check is intended to be consistent with</span>
        <span class="s0"># how the numpy random variate generators (e.g. np.random.normal,</span>
        <span class="s0"># np.random.beta) handle their arguments.   The rule is that, if size</span>
        <span class="s0"># is given, it determines the shape of the output.  Broadcasting</span>
        <span class="s0"># can't change the output size.</span>

        <span class="s0"># This is the standard broadcasting convention of extending the</span>
        <span class="s0"># shape with fewer dimensions with enough dimensions of length 1</span>
        <span class="s0"># so that the two shapes have the same number of dimensions.</span>
        <span class="s1">ndiff = bcast_ndim - len(size_)</span>
        <span class="s2">if </span><span class="s1">ndiff &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">bcast_shape = (</span><span class="s4">1</span><span class="s2">,</span><span class="s1">)*(-ndiff) + bcast_shape</span>
        <span class="s2">elif </span><span class="s1">ndiff &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">size_ = (</span><span class="s4">1</span><span class="s2">,</span><span class="s1">)*ndiff + size_</span>

        <span class="s0"># This compatibility test is not standard.  In &quot;regular&quot; broadcasting,</span>
        <span class="s0"># two shapes are compatible if for each dimension, the lengths are the</span>
        <span class="s0"># same or one of the lengths is 1.  Here, the length of a dimension in</span>
        <span class="s0"># size_ must not be less than the corresponding length in bcast_shape.</span>
        <span class="s1">ok = all([bcdim == </span><span class="s4">1 </span><span class="s2">or </span><span class="s1">bcdim == szdim</span>
                  <span class="s2">for </span><span class="s1">(bcdim</span><span class="s2">, </span><span class="s1">szdim) </span><span class="s2">in </span><span class="s1">zip(bcast_shape</span><span class="s2">, </span><span class="s1">size_)])</span>
        <span class="s2">if not </span><span class="s1">ok:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;size does not match the broadcast shape of &quot;</span>
                             <span class="s3">f&quot;the parameters. </span><span class="s2">{</span><span class="s1">size</span><span class="s2">}</span><span class="s3">, </span><span class="s2">{</span><span class="s1">size_</span><span class="s2">}</span><span class="s3">, </span><span class="s2">{</span><span class="s1">bcast_shape</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

        <span class="s1">param_bcast = all_bcast[:-</span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">loc_bcast = all_bcast[-</span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">scale_bcast = all_bcast[-</span><span class="s4">1</span><span class="s1">]</span>

        <span class="s2">return </span><span class="s1">param_bcast</span><span class="s2">, </span><span class="s1">loc_bcast</span><span class="s2">, </span><span class="s1">scale_bcast</span><span class="s2">, </span><span class="s1">size_</span>

    <span class="s0"># These are the methods you must define (standard form functions)</span>
    <span class="s0"># NB: generic _pdf, _logpdf, _cdf are different for</span>
    <span class="s0"># rv_continuous and rv_discrete hence are defined in there</span>
    <span class="s2">def </span><span class="s1">_argcheck(self</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s5">&quot;&quot;&quot;Default check for correct values on args and keywords. 
 
        Returns condition array of 1's where arguments are correct and 
         0's where they are not. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">cond = </span><span class="s4">1</span>
        <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">args:</span>
            <span class="s1">cond = logical_and(cond</span><span class="s2">, </span><span class="s1">(asarray(arg) &gt; </span><span class="s4">0</span><span class="s1">))</span>
        <span class="s2">return </span><span class="s1">cond</span>

    <span class="s2">def </span><span class="s1">_get_support(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s5">&quot;&quot;&quot;Return the support of the (unscaled, unshifted) distribution. 
 
        *Must* be overridden by distributions which have support dependent 
        upon the shape parameters of the distribution.  Any such override 
        *must not* set or change any of the class members, as these members 
        are shared amongst all instances of the distribution. 
 
        Parameters 
        ---------- 
        arg1, arg2, ... : array_like 
            The shape parameter(s) for the distribution (see docstring of the 
            instance object for more information). 
 
        Returns 
        ------- 
        a, b : numeric (float, or int or +/-np.inf) 
            end-points of the distribution's support for the specified 
            shape parameters. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.a</span><span class="s2">, </span><span class="s1">self.b</span>

    <span class="s2">def </span><span class="s1">_support_mask(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">b = self._get_support(*args)</span>
        <span class="s2">with </span><span class="s1">np.errstate(invalid=</span><span class="s3">'ignore'</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">(a &lt;= x) &amp; (x &lt;= b)</span>

    <span class="s2">def </span><span class="s1">_open_support_mask(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">b = self._get_support(*args)</span>
        <span class="s2">with </span><span class="s1">np.errstate(invalid=</span><span class="s3">'ignore'</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">(a &lt; x) &amp; (x &lt; b)</span>

    <span class="s2">def </span><span class="s1">_rvs(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">size=</span><span class="s2">None, </span><span class="s1">random_state=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0"># This method must handle size being a tuple, and it must</span>
        <span class="s0"># properly broadcast *args and size.  size might be</span>
        <span class="s0"># an empty tuple, which means a scalar random variate is to be</span>
        <span class="s0"># generated.</span>

        <span class="s0"># Use basic inverse cdf algorithm for RV generation as default.</span>
        <span class="s1">U = random_state.uniform(size=size)</span>
        <span class="s1">Y = self._ppf(U</span><span class="s2">, </span><span class="s1">*args)</span>
        <span class="s2">return </span><span class="s1">Y</span>

    <span class="s2">def </span><span class="s1">_logcdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s2">with </span><span class="s1">np.errstate(divide=</span><span class="s3">'ignore'</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">log(self._cdf(x</span><span class="s2">, </span><span class="s1">*args))</span>

    <span class="s2">def </span><span class="s1">_sf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s2">return </span><span class="s4">1.0</span><span class="s1">-self._cdf(x</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s2">def </span><span class="s1">_logsf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s2">with </span><span class="s1">np.errstate(divide=</span><span class="s3">'ignore'</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">log(self._sf(x</span><span class="s2">, </span><span class="s1">*args))</span>

    <span class="s2">def </span><span class="s1">_ppf(self</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s2">return </span><span class="s1">self._ppfvec(q</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s2">def </span><span class="s1">_isf(self</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s2">return </span><span class="s1">self._ppf(</span><span class="s4">1.0</span><span class="s1">-q</span><span class="s2">, </span><span class="s1">*args)  </span><span class="s0"># use correct _ppf for subclasses</span>

    <span class="s0"># These are actually called, and should not be overwritten if you</span>
    <span class="s0"># want to keep error checking.</span>
    <span class="s2">def </span><span class="s1">rvs(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s5">&quot;&quot;&quot;Random variates of given type. 
 
        Parameters 
        ---------- 
        arg1, arg2, arg3,... : array_like 
            The shape parameter(s) for the distribution (see docstring of the 
            instance object for more information). 
        loc : array_like, optional 
            Location parameter (default=0). 
        scale : array_like, optional 
            Scale parameter (default=1). 
        size : int or tuple of ints, optional 
            Defining number of random variates (default is 1). 
        random_state : {None, int, `numpy.random.Generator`, 
                        `numpy.random.RandomState`}, optional 
 
            If `random_state` is None (or `np.random`), the 
            `numpy.random.RandomState` singleton is used. 
            If `random_state` is an int, a new ``RandomState`` instance is 
            used, seeded with `random_state`. 
            If `random_state` is already a ``Generator`` or ``RandomState`` 
            instance, that instance is used. 
 
        Returns 
        ------- 
        rvs : ndarray or scalar 
            Random variates of given `size`. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">discrete = kwds.pop(</span><span class="s3">'discrete'</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">rndm = kwds.pop(</span><span class="s3">'random_state'</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">args</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">size = self._parse_args_rvs(*args</span><span class="s2">, </span><span class="s1">**kwds)</span>
        <span class="s1">cond = logical_and(self._argcheck(*args)</span><span class="s2">, </span><span class="s1">(scale &gt;= </span><span class="s4">0</span><span class="s1">))</span>
        <span class="s2">if not </span><span class="s1">np.all(cond):</span>
            <span class="s1">message = (</span><span class="s3">&quot;Domain error in arguments. The `scale` parameter must &quot;</span>
                       <span class="s3">&quot;be positive for all distributions, and many &quot;</span>
                       <span class="s3">&quot;distributions have restrictions on shape parameters. &quot;</span>
                       <span class="s3">f&quot;Please see the `scipy.stats.</span><span class="s2">{</span><span class="s1">self.name</span><span class="s2">}</span><span class="s3">` &quot;</span>
                       <span class="s3">&quot;documentation for details.&quot;</span><span class="s1">)</span>
            <span class="s2">raise </span><span class="s1">ValueError(message)</span>

        <span class="s2">if </span><span class="s1">np.all(scale == </span><span class="s4">0</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">loc*ones(size</span><span class="s2">, </span><span class="s3">'d'</span><span class="s1">)</span>

        <span class="s0"># extra gymnastics needed for a custom random_state</span>
        <span class="s2">if </span><span class="s1">rndm </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">random_state_saved = self._random_state</span>
            <span class="s1">random_state = check_random_state(rndm)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">random_state = self._random_state</span>

        <span class="s1">vals = self._rvs(*args</span><span class="s2">, </span><span class="s1">size=size</span><span class="s2">, </span><span class="s1">random_state=random_state)</span>

        <span class="s1">vals = vals * scale + loc</span>

        <span class="s0"># do not forget to restore the _random_state</span>
        <span class="s2">if </span><span class="s1">rndm </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._random_state = random_state_saved</span>

        <span class="s0"># Cast to int if discrete</span>
        <span class="s2">if </span><span class="s1">discrete </span><span class="s2">and not </span><span class="s1">isinstance(self</span><span class="s2">, </span><span class="s1">rv_sample):</span>
            <span class="s2">if </span><span class="s1">size == ():</span>
                <span class="s1">vals = int(vals)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">vals = vals.astype(np.int64)</span>

        <span class="s2">return </span><span class="s1">vals</span>

    <span class="s2">def </span><span class="s1">stats(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s5">&quot;&quot;&quot;Some statistics of the given RV. 
 
        Parameters 
        ---------- 
        arg1, arg2, arg3,... : array_like 
            The shape parameter(s) for the distribution (see docstring of the 
            instance object for more information) 
        loc : array_like, optional 
            location parameter (default=0) 
        scale : array_like, optional (continuous RVs only) 
            scale parameter (default=1) 
        moments : str, optional 
            composed of letters ['mvsk'] defining which moments to compute: 
            'm' = mean, 
            'v' = variance, 
            's' = (Fisher's) skew, 
            'k' = (Fisher's) kurtosis. 
            (default is 'mv') 
 
        Returns 
        ------- 
        stats : sequence 
            of requested moments. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">args</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">moments = self._parse_args_stats(*args</span><span class="s2">, </span><span class="s1">**kwds)</span>
        <span class="s0"># scale = 1 by construction for discrete RVs</span>
        <span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = map(asarray</span><span class="s2">, </span><span class="s1">(loc</span><span class="s2">, </span><span class="s1">scale))</span>
        <span class="s1">args = tuple(map(asarray</span><span class="s2">, </span><span class="s1">args))</span>
        <span class="s1">cond = self._argcheck(*args) &amp; (scale &gt; </span><span class="s4">0</span><span class="s1">) &amp; (loc == loc)</span>
        <span class="s1">output = []</span>
        <span class="s1">default = np.full(shape(cond)</span><span class="s2">, </span><span class="s1">fill_value=self.badvalue)</span>

        <span class="s0"># Use only entries that are valid in calculation</span>
        <span class="s2">if </span><span class="s1">np.any(cond):</span>
            <span class="s1">goodargs = argsreduce(cond</span><span class="s2">, </span><span class="s1">*(args+(scale</span><span class="s2">, </span><span class="s1">loc)))</span>
            <span class="s1">scale</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">goodargs = goodargs[-</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">goodargs[-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">goodargs[:-</span><span class="s4">2</span><span class="s1">]</span>

            <span class="s2">if </span><span class="s1">self._stats_has_moments:</span>
                <span class="s1">mu</span><span class="s2">, </span><span class="s1">mu2</span><span class="s2">, </span><span class="s1">g1</span><span class="s2">, </span><span class="s1">g2 = self._stats(*goodargs</span><span class="s2">,</span>
                                              <span class="s1">**{</span><span class="s3">'moments'</span><span class="s1">: moments})</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">mu</span><span class="s2">, </span><span class="s1">mu2</span><span class="s2">, </span><span class="s1">g1</span><span class="s2">, </span><span class="s1">g2 = self._stats(*goodargs)</span>

            <span class="s2">if </span><span class="s3">'m' </span><span class="s2">in </span><span class="s1">moments:</span>
                <span class="s2">if </span><span class="s1">mu </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">mu = self._munp(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">*goodargs)</span>
                <span class="s1">out0 = default.copy()</span>
                <span class="s1">place(out0</span><span class="s2">, </span><span class="s1">cond</span><span class="s2">, </span><span class="s1">mu * scale + loc)</span>
                <span class="s1">output.append(out0)</span>

            <span class="s2">if </span><span class="s3">'v' </span><span class="s2">in </span><span class="s1">moments:</span>
                <span class="s2">if </span><span class="s1">mu2 </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">mu2p = self._munp(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">*goodargs)</span>
                    <span class="s2">if </span><span class="s1">mu </span><span class="s2">is None</span><span class="s1">:</span>
                        <span class="s1">mu = self._munp(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">*goodargs)</span>
                    <span class="s0"># if mean is inf then var is also inf</span>
                    <span class="s2">with </span><span class="s1">np.errstate(invalid=</span><span class="s3">'ignore'</span><span class="s1">):</span>
                        <span class="s1">mu2 = np.where(~np.isinf(mu)</span><span class="s2">, </span><span class="s1">mu2p - mu**</span><span class="s4">2</span><span class="s2">, </span><span class="s1">np.inf)</span>
                <span class="s1">out0 = default.copy()</span>
                <span class="s1">place(out0</span><span class="s2">, </span><span class="s1">cond</span><span class="s2">, </span><span class="s1">mu2 * scale * scale)</span>
                <span class="s1">output.append(out0)</span>

            <span class="s2">if </span><span class="s3">'s' </span><span class="s2">in </span><span class="s1">moments:</span>
                <span class="s2">if </span><span class="s1">g1 </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">mu3p = self._munp(</span><span class="s4">3</span><span class="s2">, </span><span class="s1">*goodargs)</span>
                    <span class="s2">if </span><span class="s1">mu </span><span class="s2">is None</span><span class="s1">:</span>
                        <span class="s1">mu = self._munp(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">*goodargs)</span>
                    <span class="s2">if </span><span class="s1">mu2 </span><span class="s2">is None</span><span class="s1">:</span>
                        <span class="s1">mu2p = self._munp(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">*goodargs)</span>
                        <span class="s1">mu2 = mu2p - mu * mu</span>
                    <span class="s2">with </span><span class="s1">np.errstate(invalid=</span><span class="s3">'ignore'</span><span class="s1">):</span>
                        <span class="s1">mu3 = (-mu*mu - </span><span class="s4">3</span><span class="s1">*mu2)*mu + mu3p</span>
                        <span class="s1">g1 = mu3 / np.power(mu2</span><span class="s2">, </span><span class="s4">1.5</span><span class="s1">)</span>
                <span class="s1">out0 = default.copy()</span>
                <span class="s1">place(out0</span><span class="s2">, </span><span class="s1">cond</span><span class="s2">, </span><span class="s1">g1)</span>
                <span class="s1">output.append(out0)</span>

            <span class="s2">if </span><span class="s3">'k' </span><span class="s2">in </span><span class="s1">moments:</span>
                <span class="s2">if </span><span class="s1">g2 </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">mu4p = self._munp(</span><span class="s4">4</span><span class="s2">, </span><span class="s1">*goodargs)</span>
                    <span class="s2">if </span><span class="s1">mu </span><span class="s2">is None</span><span class="s1">:</span>
                        <span class="s1">mu = self._munp(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">*goodargs)</span>
                    <span class="s2">if </span><span class="s1">mu2 </span><span class="s2">is None</span><span class="s1">:</span>
                        <span class="s1">mu2p = self._munp(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">*goodargs)</span>
                        <span class="s1">mu2 = mu2p - mu * mu</span>
                    <span class="s2">if </span><span class="s1">g1 </span><span class="s2">is None</span><span class="s1">:</span>
                        <span class="s1">mu3 = </span><span class="s2">None</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s0"># (mu2**1.5) breaks down for nan and inf</span>
                        <span class="s1">mu3 = g1 * np.power(mu2</span><span class="s2">, </span><span class="s4">1.5</span><span class="s1">)</span>
                    <span class="s2">if </span><span class="s1">mu3 </span><span class="s2">is None</span><span class="s1">:</span>
                        <span class="s1">mu3p = self._munp(</span><span class="s4">3</span><span class="s2">, </span><span class="s1">*goodargs)</span>
                        <span class="s2">with </span><span class="s1">np.errstate(invalid=</span><span class="s3">'ignore'</span><span class="s1">):</span>
                            <span class="s1">mu3 = (-mu * mu - </span><span class="s4">3 </span><span class="s1">* mu2) * mu + mu3p</span>
                    <span class="s2">with </span><span class="s1">np.errstate(invalid=</span><span class="s3">'ignore'</span><span class="s1">):</span>
                        <span class="s1">mu4 = ((-mu**</span><span class="s4">2 </span><span class="s1">- </span><span class="s4">6</span><span class="s1">*mu2) * mu - </span><span class="s4">4</span><span class="s1">*mu3)*mu + mu4p</span>
                        <span class="s1">g2 = mu4 / mu2**</span><span class="s4">2.0 </span><span class="s1">- </span><span class="s4">3.0</span>
                <span class="s1">out0 = default.copy()</span>
                <span class="s1">place(out0</span><span class="s2">, </span><span class="s1">cond</span><span class="s2">, </span><span class="s1">g2)</span>
                <span class="s1">output.append(out0)</span>
        <span class="s2">else</span><span class="s1">:  </span><span class="s0"># no valid args</span>
            <span class="s1">output = [default.copy() </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">moments]</span>

        <span class="s1">output = [out[()] </span><span class="s2">for </span><span class="s1">out </span><span class="s2">in </span><span class="s1">output]</span>
        <span class="s2">if </span><span class="s1">len(output) == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">output[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">tuple(output)</span>

    <span class="s2">def </span><span class="s1">entropy(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s5">&quot;&quot;&quot;Differential entropy of the RV. 
 
        Parameters 
        ---------- 
        arg1, arg2, arg3,... : array_like 
            The shape parameter(s) for the distribution (see docstring of the 
            instance object for more information). 
        loc : array_like, optional 
            Location parameter (default=0). 
        scale : array_like, optional  (continuous distributions only). 
            Scale parameter (default=1). 
 
        Notes 
        ----- 
        Entropy is defined base `e`: 
 
        &gt;&gt;&gt; import numpy as np 
        &gt;&gt;&gt; drv = rv_discrete(values=((0, 1), (0.5, 0.5))) 
        &gt;&gt;&gt; np.allclose(drv.entropy(), np.log(2.0)) 
        True 
 
        &quot;&quot;&quot;</span>
        <span class="s1">args</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = self._parse_args(*args</span><span class="s2">, </span><span class="s1">**kwds)</span>
        <span class="s0"># NB: for discrete distributions scale=1 by construction in _parse_args</span>
        <span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = map(asarray</span><span class="s2">, </span><span class="s1">(loc</span><span class="s2">, </span><span class="s1">scale))</span>
        <span class="s1">args = tuple(map(asarray</span><span class="s2">, </span><span class="s1">args))</span>
        <span class="s1">cond0 = self._argcheck(*args) &amp; (scale &gt; </span><span class="s4">0</span><span class="s1">) &amp; (loc == loc)</span>
        <span class="s1">output = zeros(shape(cond0)</span><span class="s2">, </span><span class="s3">'d'</span><span class="s1">)</span>
        <span class="s1">place(output</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s1">-cond0)</span><span class="s2">, </span><span class="s1">self.badvalue)</span>
        <span class="s1">goodargs = argsreduce(cond0</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">*args)</span>
        <span class="s1">goodscale = goodargs[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">goodargs = goodargs[</span><span class="s4">1</span><span class="s1">:]</span>
        <span class="s1">place(output</span><span class="s2">, </span><span class="s1">cond0</span><span class="s2">, </span><span class="s1">self.vecentropy(*goodargs) + log(goodscale))</span>
        <span class="s2">return </span><span class="s1">output[()]</span>

    <span class="s2">def </span><span class="s1">moment(self</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s5">&quot;&quot;&quot;non-central moment of distribution of specified order. 
 
        Parameters 
        ---------- 
        order : int, order &gt;= 1 
            Order of moment. 
        arg1, arg2, arg3,... : float 
            The shape parameter(s) for the distribution (see docstring of the 
            instance object for more information). 
        loc : array_like, optional 
            location parameter (default=0) 
        scale : array_like, optional 
            scale parameter (default=1) 
 
        &quot;&quot;&quot;</span>
        <span class="s1">n = order</span>
        <span class="s1">shapes</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = self._parse_args(*args</span><span class="s2">, </span><span class="s1">**kwds)</span>
        <span class="s1">args = np.broadcast_arrays(*(*shapes</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale))</span>
        <span class="s1">*shapes</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = args</span>

        <span class="s1">i0 = np.logical_and(self._argcheck(*shapes)</span><span class="s2">, </span><span class="s1">scale &gt; </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">i1 = np.logical_and(i0</span><span class="s2">, </span><span class="s1">loc == </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">i2 = np.logical_and(i0</span><span class="s2">, </span><span class="s1">loc != </span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">args = argsreduce(i0</span><span class="s2">, </span><span class="s1">*shapes</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale)</span>
        <span class="s1">*shapes</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = args</span>

        <span class="s2">if </span><span class="s1">(floor(n) != n):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Moment must be an integer.&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">(n &lt; </span><span class="s4">0</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Moment must be positive.&quot;</span><span class="s1">)</span>
        <span class="s1">mu</span><span class="s2">, </span><span class="s1">mu2</span><span class="s2">, </span><span class="s1">g1</span><span class="s2">, </span><span class="s1">g2 = </span><span class="s2">None, None, None, None</span>
        <span class="s2">if </span><span class="s1">(n &gt; </span><span class="s4">0</span><span class="s1">) </span><span class="s2">and </span><span class="s1">(n &lt; </span><span class="s4">5</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">self._stats_has_moments:</span>
                <span class="s1">mdict = {</span><span class="s3">'moments'</span><span class="s1">: {</span><span class="s4">1</span><span class="s1">: </span><span class="s3">'m'</span><span class="s2">, </span><span class="s4">2</span><span class="s1">: </span><span class="s3">'v'</span><span class="s2">, </span><span class="s4">3</span><span class="s1">: </span><span class="s3">'vs'</span><span class="s2">, </span><span class="s4">4</span><span class="s1">: </span><span class="s3">'mvsk'</span><span class="s1">}[n]}</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">mdict = {}</span>
            <span class="s1">mu</span><span class="s2">, </span><span class="s1">mu2</span><span class="s2">, </span><span class="s1">g1</span><span class="s2">, </span><span class="s1">g2 = self._stats(*shapes</span><span class="s2">, </span><span class="s1">**mdict)</span>
        <span class="s1">val = np.empty(loc.shape)  </span><span class="s0"># val needs to be indexed by loc</span>
        <span class="s1">val[...] = _moment_from_stats(n</span><span class="s2">, </span><span class="s1">mu</span><span class="s2">, </span><span class="s1">mu2</span><span class="s2">, </span><span class="s1">g1</span><span class="s2">, </span><span class="s1">g2</span><span class="s2">, </span><span class="s1">self._munp</span><span class="s2">, </span><span class="s1">shapes)</span>

        <span class="s0"># Convert to transformed  X = L + S*Y</span>
        <span class="s0"># E[X^n] = E[(L+S*Y)^n] = L^n sum(comb(n, k)*(S/L)^k E[Y^k], k=0...n)</span>
        <span class="s1">result = zeros(i0.shape)</span>
        <span class="s1">place(result</span><span class="s2">, </span><span class="s1">~i0</span><span class="s2">, </span><span class="s1">self.badvalue)</span>

        <span class="s2">if </span><span class="s1">i1.any():</span>
            <span class="s1">res1 = scale[loc == </span><span class="s4">0</span><span class="s1">]**n * val[loc == </span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">place(result</span><span class="s2">, </span><span class="s1">i1</span><span class="s2">, </span><span class="s1">res1)</span>

        <span class="s2">if </span><span class="s1">i2.any():</span>
            <span class="s1">mom = [mu</span><span class="s2">, </span><span class="s1">mu2</span><span class="s2">, </span><span class="s1">g1</span><span class="s2">, </span><span class="s1">g2]</span>
            <span class="s1">arrs = [i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">mom </span><span class="s2">if </span><span class="s1">i </span><span class="s2">is not None</span><span class="s1">]</span>
            <span class="s1">idx = [i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">4</span><span class="s1">) </span><span class="s2">if </span><span class="s1">mom[i] </span><span class="s2">is not None</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">any(idx):</span>
                <span class="s1">arrs = argsreduce(loc != </span><span class="s4">0</span><span class="s2">, </span><span class="s1">*arrs)</span>
                <span class="s1">j = </span><span class="s4">0</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">idx:</span>
                    <span class="s1">mom[i] = arrs[j]</span>
                    <span class="s1">j += </span><span class="s4">1</span>
            <span class="s1">mu</span><span class="s2">, </span><span class="s1">mu2</span><span class="s2">, </span><span class="s1">g1</span><span class="s2">, </span><span class="s1">g2 = mom</span>
            <span class="s1">args = argsreduce(loc != </span><span class="s4">0</span><span class="s2">, </span><span class="s1">*shapes</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">val)</span>
            <span class="s1">*shapes</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">val = args</span>

            <span class="s1">res2 = zeros(loc.shape</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">'d'</span><span class="s1">)</span>
            <span class="s1">fac = scale / loc</span>
            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range(n):</span>
                <span class="s1">valk = _moment_from_stats(k</span><span class="s2">, </span><span class="s1">mu</span><span class="s2">, </span><span class="s1">mu2</span><span class="s2">, </span><span class="s1">g1</span><span class="s2">, </span><span class="s1">g2</span><span class="s2">, </span><span class="s1">self._munp</span><span class="s2">,</span>
                                          <span class="s1">shapes)</span>
                <span class="s1">res2 += comb(n</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">exact=</span><span class="s2">True</span><span class="s1">)*fac**k * valk</span>
            <span class="s1">res2 += fac**n * val</span>
            <span class="s1">res2 *= loc**n</span>
            <span class="s1">place(result</span><span class="s2">, </span><span class="s1">i2</span><span class="s2">, </span><span class="s1">res2)</span>

        <span class="s2">return </span><span class="s1">result[()]</span>

    <span class="s2">def </span><span class="s1">median(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s5">&quot;&quot;&quot;Median of the distribution. 
 
        Parameters 
        ---------- 
        arg1, arg2, arg3,... : array_like 
            The shape parameter(s) for the distribution (see docstring of the 
            instance object for more information) 
        loc : array_like, optional 
            Location parameter, Default is 0. 
        scale : array_like, optional 
            Scale parameter, Default is 1. 
 
        Returns 
        ------- 
        median : float 
            The median of the distribution. 
 
        See Also 
        -------- 
        rv_discrete.ppf 
            Inverse of the CDF 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.ppf(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds)</span>

    <span class="s2">def </span><span class="s1">mean(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s5">&quot;&quot;&quot;Mean of the distribution. 
 
        Parameters 
        ---------- 
        arg1, arg2, arg3,... : array_like 
            The shape parameter(s) for the distribution (see docstring of the 
            instance object for more information) 
        loc : array_like, optional 
            location parameter (default=0) 
        scale : array_like, optional 
            scale parameter (default=1) 
 
        Returns 
        ------- 
        mean : float 
            the mean of the distribution 
 
        &quot;&quot;&quot;</span>
        <span class="s1">kwds[</span><span class="s3">'moments'</span><span class="s1">] = </span><span class="s3">'m'</span>
        <span class="s1">res = self.stats(*args</span><span class="s2">, </span><span class="s1">**kwds)</span>
        <span class="s2">if </span><span class="s1">isinstance(res</span><span class="s2">, </span><span class="s1">ndarray) </span><span class="s2">and </span><span class="s1">res.ndim == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">res[()]</span>
        <span class="s2">return </span><span class="s1">res</span>

    <span class="s2">def </span><span class="s1">var(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s5">&quot;&quot;&quot;Variance of the distribution. 
 
        Parameters 
        ---------- 
        arg1, arg2, arg3,... : array_like 
            The shape parameter(s) for the distribution (see docstring of the 
            instance object for more information) 
        loc : array_like, optional 
            location parameter (default=0) 
        scale : array_like, optional 
            scale parameter (default=1) 
 
        Returns 
        ------- 
        var : float 
            the variance of the distribution 
 
        &quot;&quot;&quot;</span>
        <span class="s1">kwds[</span><span class="s3">'moments'</span><span class="s1">] = </span><span class="s3">'v'</span>
        <span class="s1">res = self.stats(*args</span><span class="s2">, </span><span class="s1">**kwds)</span>
        <span class="s2">if </span><span class="s1">isinstance(res</span><span class="s2">, </span><span class="s1">ndarray) </span><span class="s2">and </span><span class="s1">res.ndim == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">res[()]</span>
        <span class="s2">return </span><span class="s1">res</span>

    <span class="s2">def </span><span class="s1">std(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s5">&quot;&quot;&quot;Standard deviation of the distribution. 
 
        Parameters 
        ---------- 
        arg1, arg2, arg3,... : array_like 
            The shape parameter(s) for the distribution (see docstring of the 
            instance object for more information) 
        loc : array_like, optional 
            location parameter (default=0) 
        scale : array_like, optional 
            scale parameter (default=1) 
 
        Returns 
        ------- 
        std : float 
            standard deviation of the distribution 
 
        &quot;&quot;&quot;</span>
        <span class="s1">kwds[</span><span class="s3">'moments'</span><span class="s1">] = </span><span class="s3">'v'</span>
        <span class="s1">res = sqrt(self.stats(*args</span><span class="s2">, </span><span class="s1">**kwds))</span>
        <span class="s2">return </span><span class="s1">res</span>

    <span class="s2">def </span><span class="s1">interval(self</span><span class="s2">, </span><span class="s1">confidence</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s5">&quot;&quot;&quot;Confidence interval with equal areas around the median. 
 
        Parameters 
        ---------- 
        confidence : array_like of float 
            Probability that an rv will be drawn from the returned range. 
            Each value should be in the range [0, 1]. 
        arg1, arg2, ... : array_like 
            The shape parameter(s) for the distribution (see docstring of the 
            instance object for more information). 
        loc : array_like, optional 
            location parameter, Default is 0. 
        scale : array_like, optional 
            scale parameter, Default is 1. 
 
        Returns 
        ------- 
        a, b : ndarray of float 
            end-points of range that contain ``100 * alpha %`` of the rv's 
            possible values. 
 
        Notes 
        ----- 
        This is implemented as ``ppf([p_tail, 1-p_tail])``, where 
        ``ppf`` is the inverse cumulative distribution function and 
        ``p_tail = (1-confidence)/2``. Suppose ``[c, d]`` is the support of a 
        discrete distribution; then ``ppf([0, 1]) == (c-1, d)``. Therefore, 
        when ``confidence=1`` and the distribution is discrete, the left end 
        of the interval will be beyond the support of the distribution. 
        For discrete distributions, the interval will limit the probability 
        in each tail to be less than or equal to ``p_tail`` (usually 
        strictly less). 
 
        &quot;&quot;&quot;</span>
        <span class="s1">alpha = confidence</span>

        <span class="s1">alpha = asarray(alpha)</span>
        <span class="s2">if </span><span class="s1">np.any((alpha &gt; </span><span class="s4">1</span><span class="s1">) | (alpha &lt; </span><span class="s4">0</span><span class="s1">)):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;alpha must be between 0 and 1 inclusive&quot;</span><span class="s1">)</span>
        <span class="s1">q1 = (</span><span class="s4">1.0</span><span class="s1">-alpha)/</span><span class="s4">2</span>
        <span class="s1">q2 = (</span><span class="s4">1.0</span><span class="s1">+alpha)/</span><span class="s4">2</span>
        <span class="s1">a = self.ppf(q1</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds)</span>
        <span class="s1">b = self.ppf(q2</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds)</span>
        <span class="s2">return </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span>

    <span class="s2">def </span><span class="s1">support(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s5">&quot;&quot;&quot;Support of the distribution. 
 
        Parameters 
        ---------- 
        arg1, arg2, ... : array_like 
            The shape parameter(s) for the distribution (see docstring of the 
            instance object for more information). 
        loc : array_like, optional 
            location parameter, Default is 0. 
        scale : array_like, optional 
            scale parameter, Default is 1. 
 
        Returns 
        ------- 
        a, b : array_like 
            end-points of the distribution's support. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">args</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = self._parse_args(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">arrs = np.broadcast_arrays(*args</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale)</span>
        <span class="s1">args</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = arrs[:-</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">arrs[-</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">arrs[-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">cond = self._argcheck(*args) &amp; (scale &gt; </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">_a</span><span class="s2">, </span><span class="s1">_b = self._get_support(*args)</span>
        <span class="s2">if </span><span class="s1">cond.all():</span>
            <span class="s2">return </span><span class="s1">_a * scale + loc</span><span class="s2">, </span><span class="s1">_b * scale + loc</span>
        <span class="s2">elif </span><span class="s1">cond.ndim == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.badvalue</span><span class="s2">, </span><span class="s1">self.badvalue</span>
        <span class="s0"># promote bounds to at least float to fill in the badvalue</span>
        <span class="s1">_a</span><span class="s2">, </span><span class="s1">_b = np.asarray(_a).astype(</span><span class="s3">'d'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.asarray(_b).astype(</span><span class="s3">'d'</span><span class="s1">)</span>
        <span class="s1">out_a</span><span class="s2">, </span><span class="s1">out_b = _a * scale + loc</span><span class="s2">, </span><span class="s1">_b * scale + loc</span>
        <span class="s1">place(out_a</span><span class="s2">, </span><span class="s4">1</span><span class="s1">-cond</span><span class="s2">, </span><span class="s1">self.badvalue)</span>
        <span class="s1">place(out_b</span><span class="s2">, </span><span class="s4">1</span><span class="s1">-cond</span><span class="s2">, </span><span class="s1">self.badvalue)</span>
        <span class="s2">return </span><span class="s1">out_a</span><span class="s2">, </span><span class="s1">out_b</span>

    <span class="s2">def </span><span class="s1">nnlf(self</span><span class="s2">, </span><span class="s1">theta</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s5">&quot;&quot;&quot;Negative loglikelihood function. 
        Notes 
        ----- 
        This is ``-sum(log pdf(x, theta), axis=0)`` where `theta` are the 
        parameters (including loc and scale). 
        &quot;&quot;&quot;</span>
        <span class="s1">loc</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">args = self._unpack_loc_scale(theta)</span>
        <span class="s2">if not </span><span class="s1">self._argcheck(*args) </span><span class="s2">or </span><span class="s1">scale &lt;= </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">inf</span>
        <span class="s1">x = (asarray(x)-loc) / scale</span>
        <span class="s1">n_log_scale = len(x) * log(scale)</span>
        <span class="s2">if </span><span class="s1">np.any(~self._support_mask(x</span><span class="s2">, </span><span class="s1">*args)):</span>
            <span class="s2">return </span><span class="s1">inf</span>
        <span class="s2">return </span><span class="s1">self._nnlf(x</span><span class="s2">, </span><span class="s1">*args) + n_log_scale</span>

    <span class="s2">def </span><span class="s1">_nnlf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s2">return </span><span class="s1">-np.sum(self._logpxf(x</span><span class="s2">, </span><span class="s1">*args)</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_nlff_and_penalty(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">log_fitfun):</span>
        <span class="s0"># negative log fit function</span>
        <span class="s1">cond0 = ~self._support_mask(x</span><span class="s2">, </span><span class="s1">*args)</span>
        <span class="s1">n_bad = np.count_nonzero(cond0</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">n_bad &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">x = argsreduce(~cond0</span><span class="s2">, </span><span class="s1">x)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">logff = log_fitfun(x</span><span class="s2">, </span><span class="s1">*args)</span>
        <span class="s1">finite_logff = np.isfinite(logff)</span>
        <span class="s1">n_bad += np.sum(~finite_logff</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">n_bad &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">penalty = n_bad * log(_XMAX) * </span><span class="s4">100</span>
            <span class="s2">return </span><span class="s1">-np.sum(logff[finite_logff]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">) + penalty</span>
        <span class="s2">return </span><span class="s1">-np.sum(logff</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_penalized_nnlf(self</span><span class="s2">, </span><span class="s1">theta</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s5">&quot;&quot;&quot;Penalized negative loglikelihood function. 
        i.e., - sum (log pdf(x, theta), axis=0) + penalty 
        where theta are the parameters (including loc and scale) 
        &quot;&quot;&quot;</span>
        <span class="s1">loc</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">args = self._unpack_loc_scale(theta)</span>
        <span class="s2">if not </span><span class="s1">self._argcheck(*args) </span><span class="s2">or </span><span class="s1">scale &lt;= </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">inf</span>
        <span class="s1">x = asarray((x-loc) / scale)</span>
        <span class="s1">n_log_scale = len(x) * log(scale)</span>
        <span class="s2">return </span><span class="s1">self._nlff_and_penalty(x</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">self._logpxf) + n_log_scale</span>

    <span class="s2">def </span><span class="s1">_penalized_nlpsf(self</span><span class="s2">, </span><span class="s1">theta</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s5">&quot;&quot;&quot;Penalized negative log product spacing function. 
        i.e., - sum (log (diff (cdf (x, theta))), axis=0) + penalty 
        where theta are the parameters (including loc and scale) 
        Follows reference [1] of scipy.stats.fit 
        &quot;&quot;&quot;</span>
        <span class="s1">loc</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">args = self._unpack_loc_scale(theta)</span>
        <span class="s2">if not </span><span class="s1">self._argcheck(*args) </span><span class="s2">or </span><span class="s1">scale &lt;= </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">inf</span>
        <span class="s1">x = (np.sort(x) - loc)/scale</span>

        <span class="s2">def </span><span class="s1">log_psf(x</span><span class="s2">, </span><span class="s1">*args):</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">lj = np.unique(x</span><span class="s2">, </span><span class="s1">return_counts=</span><span class="s2">True</span><span class="s1">)  </span><span class="s0"># fast for sorted x</span>
            <span class="s1">cdf_data = self._cdf(x</span><span class="s2">, </span><span class="s1">*args) </span><span class="s2">if </span><span class="s1">x.size </span><span class="s2">else </span><span class="s1">[]</span>
            <span class="s2">if not </span><span class="s1">(x.size </span><span class="s2">and </span><span class="s4">1 </span><span class="s1">- cdf_data[-</span><span class="s4">1</span><span class="s1">] &lt;= </span><span class="s4">0</span><span class="s1">):</span>
                <span class="s1">cdf = np.concatenate(([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">cdf_data</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">]))</span>
                <span class="s1">lj = np.concatenate((lj</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">]))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">cdf = np.concatenate(([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">cdf_data))</span>
            <span class="s0"># here we could use logcdf w/ logsumexp trick to take differences,</span>
            <span class="s0"># but in the context of the method, it seems unlikely to matter</span>
            <span class="s2">return </span><span class="s1">lj * np.log(np.diff(cdf) / lj)</span>

        <span class="s2">return </span><span class="s1">self._nlff_and_penalty(x</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">log_psf)</span>


<span class="s2">class </span><span class="s1">_ShapeInfo:</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">integrality=</span><span class="s2">False, </span><span class="s1">domain=(-np.inf</span><span class="s2">, </span><span class="s1">np.inf)</span><span class="s2">,</span>
                 <span class="s1">inclusive=(</span><span class="s2">True, True</span><span class="s1">)):</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.integrality = integrality</span>

        <span class="s1">domain = list(domain)</span>
        <span class="s2">if </span><span class="s1">np.isfinite(domain[</span><span class="s4">0</span><span class="s1">]) </span><span class="s2">and not </span><span class="s1">inclusive[</span><span class="s4">0</span><span class="s1">]:</span>
            <span class="s1">domain[</span><span class="s4">0</span><span class="s1">] = np.nextafter(domain[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.inf)</span>
        <span class="s2">if </span><span class="s1">np.isfinite(domain[</span><span class="s4">1</span><span class="s1">]) </span><span class="s2">and not </span><span class="s1">inclusive[</span><span class="s4">1</span><span class="s1">]:</span>
            <span class="s1">domain[</span><span class="s4">1</span><span class="s1">] = np.nextafter(domain[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">-np.inf)</span>
        <span class="s1">self.domain = domain</span>


<span class="s2">def </span><span class="s1">_get_fixed_fit_value(kwds</span><span class="s2">, </span><span class="s1">names):</span>
    <span class="s5">&quot;&quot;&quot; 
    Given names such as `['f0', 'fa', 'fix_a']`, check that there is 
    at most one non-None value in `kwds` associaed with those names. 
    Return that value, or None if none of the names occur in `kwds`. 
    As a side effect, all occurrences of those names in `kwds` are 
    removed. 
    &quot;&quot;&quot;</span>
    <span class="s1">vals = [(name</span><span class="s2">, </span><span class="s1">kwds.pop(name)) </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">names </span><span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">kwds]</span>
    <span class="s2">if </span><span class="s1">len(vals) &gt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">repeated = [name </span><span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">vals]</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;fit method got multiple keyword arguments to &quot;</span>
                         <span class="s3">&quot;specify the same fixed parameter: &quot; </span><span class="s1">+</span>
                         <span class="s3">', '</span><span class="s1">.join(repeated))</span>
    <span class="s2">return </span><span class="s1">vals[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">1</span><span class="s1">] </span><span class="s2">if </span><span class="s1">vals </span><span class="s2">else None</span>


<span class="s0">#  continuous random variables: implement maybe later</span>
<span class="s0">#</span>
<span class="s0">#  hf  --- Hazard Function (PDF / SF)</span>
<span class="s0">#  chf  --- Cumulative hazard function (-log(SF))</span>
<span class="s0">#  psf --- Probability sparsity function (reciprocal of the pdf) in</span>
<span class="s0">#                units of percent-point-function (as a function of q).</span>
<span class="s0">#                Also, the derivative of the percent-point function.</span>


<span class="s2">class </span><span class="s1">rv_continuous(rv_generic):</span>
    <span class="s5">&quot;&quot;&quot;A generic continuous random variable class meant for subclassing. 
 
    `rv_continuous` is a base class to construct specific distribution classes 
    and instances for continuous random variables. It cannot be used 
    directly as a distribution. 
 
    Parameters 
    ---------- 
    momtype : int, optional 
        The type of generic moment calculation to use: 0 for pdf, 1 (default) 
        for ppf. 
    a : float, optional 
        Lower bound of the support of the distribution, default is minus 
        infinity. 
    b : float, optional 
        Upper bound of the support of the distribution, default is plus 
        infinity. 
    xtol : float, optional 
        The tolerance for fixed point calculation for generic ppf. 
    badvalue : float, optional 
        The value in a result arrays that indicates a value that for which 
        some argument restriction is violated, default is np.nan. 
    name : str, optional 
        The name of the instance. This string is used to construct the default 
        example for distributions. 
    longname : str, optional 
        This string is used as part of the first line of the docstring returned 
        when a subclass has no docstring of its own. Note: `longname` exists 
        for backwards compatibility, do not use for new subclasses. 
    shapes : str, optional 
        The shape of the distribution. For example ``&quot;m, n&quot;`` for a 
        distribution that takes two integers as the two shape arguments for all 
        its methods. If not provided, shape parameters will be inferred from 
        the signature of the private methods, ``_pdf`` and ``_cdf`` of the 
        instance. 
    seed : {None, int, `numpy.random.Generator`, `numpy.random.RandomState`}, optional 
        If `seed` is None (or `np.random`), the `numpy.random.RandomState` 
        singleton is used. 
        If `seed` is an int, a new ``RandomState`` instance is used, 
        seeded with `seed`. 
        If `seed` is already a ``Generator`` or ``RandomState`` instance then 
        that instance is used. 
 
    Methods 
    ------- 
    rvs 
    pdf 
    logpdf 
    cdf 
    logcdf 
    sf 
    logsf 
    ppf 
    isf 
    moment 
    stats 
    entropy 
    expect 
    median 
    mean 
    std 
    var 
    interval 
    __call__ 
    fit 
    fit_loc_scale 
    nnlf 
    support 
 
    Notes 
    ----- 
    Public methods of an instance of a distribution class (e.g., ``pdf``, 
    ``cdf``) check their arguments and pass valid arguments to private, 
    computational methods (``_pdf``, ``_cdf``). For ``pdf(x)``, ``x`` is valid 
    if it is within the support of the distribution. 
    Whether a shape parameter is valid is decided by an ``_argcheck`` method 
    (which defaults to checking that its arguments are strictly positive.) 
 
    **Subclassing** 
 
    New random variables can be defined by subclassing the `rv_continuous` class 
    and re-defining at least the ``_pdf`` or the ``_cdf`` method (normalized 
    to location 0 and scale 1). 
 
    If positive argument checking is not correct for your RV 
    then you will also need to re-define the ``_argcheck`` method. 
 
    For most of the scipy.stats distributions, the support interval doesn't 
    depend on the shape parameters. ``x`` being in the support interval is 
    equivalent to ``self.a &lt;= x &lt;= self.b``.  If either of the endpoints of 
    the support do depend on the shape parameters, then 
    i) the distribution must implement the ``_get_support`` method; and 
    ii) those dependent endpoints must be omitted from the distribution's 
    call to the ``rv_continuous`` initializer. 
 
    Correct, but potentially slow defaults exist for the remaining 
    methods but for speed and/or accuracy you can over-ride:: 
 
      _logpdf, _cdf, _logcdf, _ppf, _rvs, _isf, _sf, _logsf 
 
    The default method ``_rvs`` relies on the inverse of the cdf, ``_ppf``, 
    applied to a uniform random variate. In order to generate random variates 
    efficiently, either the default ``_ppf`` needs to be overwritten (e.g. 
    if the inverse cdf can expressed in an explicit form) or a sampling 
    method needs to be implemented in a custom ``_rvs`` method. 
 
    If possible, you should override ``_isf``, ``_sf`` or ``_logsf``. 
    The main reason would be to improve numerical accuracy: for example, 
    the survival function ``_sf`` is computed as ``1 - _cdf`` which can 
    result in loss of precision if ``_cdf(x)`` is close to one. 
 
    **Methods that can be overwritten by subclasses** 
    :: 
 
      _rvs 
      _pdf 
      _cdf 
      _sf 
      _ppf 
      _isf 
      _stats 
      _munp 
      _entropy 
      _argcheck 
      _get_support 
 
    There are additional (internal and private) generic methods that can 
    be useful for cross-checking and for debugging, but might work in all 
    cases when directly called. 
 
    A note on ``shapes``: subclasses need not specify them explicitly. In this 
    case, `shapes` will be automatically deduced from the signatures of the 
    overridden methods (`pdf`, `cdf` etc). 
    If, for some reason, you prefer to avoid relying on introspection, you can 
    specify ``shapes`` explicitly as an argument to the instance constructor. 
 
 
    **Frozen Distributions** 
 
    Normally, you must provide shape parameters (and, optionally, location and 
    scale parameters to each call of a method of a distribution. 
 
    Alternatively, the object may be called (as a function) to fix the shape, 
    location, and scale parameters returning a &quot;frozen&quot; continuous RV object: 
 
    rv = generic(&lt;shape(s)&gt;, loc=0, scale=1) 
        `rv_frozen` object with the same methods but holding the given shape, 
        location, and scale fixed 
 
    **Statistics** 
 
    Statistics are computed using numerical integration by default. 
    For speed you can redefine this using ``_stats``: 
 
     - take shape parameters and return mu, mu2, g1, g2 
     - If you can't compute one of these, return it as None 
     - Can also be defined with a keyword argument ``moments``, which is a 
       string composed of &quot;m&quot;, &quot;v&quot;, &quot;s&quot;, and/or &quot;k&quot;. 
       Only the components appearing in string should be computed and 
       returned in the order &quot;m&quot;, &quot;v&quot;, &quot;s&quot;, or &quot;k&quot;  with missing values 
       returned as None. 
 
    Alternatively, you can override ``_munp``, which takes ``n`` and shape 
    parameters and returns the n-th non-central moment of the distribution. 
 
    **Deepcopying / Pickling** 
 
    If a distribution or frozen distribution is deepcopied (pickled/unpickled, 
    etc.), any underlying random number generator is deepcopied with it. An 
    implication is that if a distribution relies on the singleton RandomState 
    before copying, it will rely on a copy of that random state after copying, 
    and ``np.random.seed`` will no longer control the state. 
 
    Examples 
    -------- 
    To create a new Gaussian distribution, we would do the following: 
 
    &gt;&gt;&gt; from scipy.stats import rv_continuous 
    &gt;&gt;&gt; class gaussian_gen(rv_continuous): 
    ...     &quot;Gaussian distribution&quot; 
    ...     def _pdf(self, x): 
    ...         return np.exp(-x**2 / 2.) / np.sqrt(2.0 * np.pi) 
    &gt;&gt;&gt; gaussian = gaussian_gen(name='gaussian') 
 
    ``scipy.stats`` distributions are *instances*, so here we subclass 
    `rv_continuous` and create an instance. With this, we now have 
    a fully functional distribution with all relevant methods automagically 
    generated by the framework. 
 
    Note that above we defined a standard normal distribution, with zero mean 
    and unit variance. Shifting and scaling of the distribution can be done 
    by using ``loc`` and ``scale`` parameters: ``gaussian.pdf(x, loc, scale)`` 
    essentially computes ``y = (x - loc) / scale`` and 
    ``gaussian._pdf(y) / scale``. 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">momtype=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">a=</span><span class="s2">None, </span><span class="s1">b=</span><span class="s2">None, </span><span class="s1">xtol=</span><span class="s4">1e-14</span><span class="s2">,</span>
                 <span class="s1">badvalue=</span><span class="s2">None, </span><span class="s1">name=</span><span class="s2">None, </span><span class="s1">longname=</span><span class="s2">None,</span>
                 <span class="s1">shapes=</span><span class="s2">None, </span><span class="s1">seed=</span><span class="s2">None</span><span class="s1">):</span>

        <span class="s1">super().__init__(seed)</span>

        <span class="s0"># save the ctor parameters, cf generic freeze</span>
        <span class="s1">self._ctor_param = dict(</span>
            <span class="s1">momtype=momtype</span><span class="s2">, </span><span class="s1">a=a</span><span class="s2">, </span><span class="s1">b=b</span><span class="s2">, </span><span class="s1">xtol=xtol</span><span class="s2">,</span>
            <span class="s1">badvalue=badvalue</span><span class="s2">, </span><span class="s1">name=name</span><span class="s2">, </span><span class="s1">longname=longname</span><span class="s2">,</span>
            <span class="s1">shapes=shapes</span><span class="s2">, </span><span class="s1">seed=seed)</span>

        <span class="s2">if </span><span class="s1">badvalue </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">badvalue = nan</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">name = </span><span class="s3">'Distribution'</span>
        <span class="s1">self.badvalue = badvalue</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.a = a</span>
        <span class="s1">self.b = b</span>
        <span class="s2">if </span><span class="s1">a </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.a = -inf</span>
        <span class="s2">if </span><span class="s1">b </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.b = inf</span>
        <span class="s1">self.xtol = xtol</span>
        <span class="s1">self.moment_type = momtype</span>
        <span class="s1">self.shapes = shapes</span>

        <span class="s1">self._construct_argparser(meths_to_inspect=[self._pdf</span><span class="s2">, </span><span class="s1">self._cdf]</span><span class="s2">,</span>
                                  <span class="s1">locscale_in=</span><span class="s3">'loc=0, scale=1'</span><span class="s2">,</span>
                                  <span class="s1">locscale_out=</span><span class="s3">'loc, scale'</span><span class="s1">)</span>
        <span class="s1">self._attach_methods()</span>

        <span class="s2">if </span><span class="s1">longname </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">name[</span><span class="s4">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'aeiouAEIOU'</span><span class="s1">]:</span>
                <span class="s1">hstr = </span><span class="s3">&quot;An &quot;</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">hstr = </span><span class="s3">&quot;A &quot;</span>
            <span class="s1">longname = hstr + name</span>

        <span class="s2">if </span><span class="s1">sys.flags.optimize &lt; </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s0"># Skip adding docstrings if interpreter is run with -OO</span>
            <span class="s2">if </span><span class="s1">self.__doc__ </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">self._construct_default_doc(longname=longname</span><span class="s2">,</span>
                                            <span class="s1">docdict=docdict</span><span class="s2">,</span>
                                            <span class="s1">discrete=</span><span class="s3">'continuous'</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">dct = dict(distcont)</span>
                <span class="s1">self._construct_doc(docdict</span><span class="s2">, </span><span class="s1">dct.get(self.name))</span>

    <span class="s2">def </span><span class="s1">__getstate__(self):</span>
        <span class="s1">dct = self.__dict__.copy()</span>

        <span class="s0"># these methods will be remade in __setstate__</span>
        <span class="s0"># _random_state attribute is taken care of by rv_generic</span>
        <span class="s1">attrs = [</span><span class="s3">&quot;_parse_args&quot;</span><span class="s2">, </span><span class="s3">&quot;_parse_args_stats&quot;</span><span class="s2">, </span><span class="s3">&quot;_parse_args_rvs&quot;</span><span class="s2">,</span>
                 <span class="s3">&quot;_cdfvec&quot;</span><span class="s2">, </span><span class="s3">&quot;_ppfvec&quot;</span><span class="s2">, </span><span class="s3">&quot;vecentropy&quot;</span><span class="s2">, </span><span class="s3">&quot;generic_moment&quot;</span><span class="s1">]</span>
        <span class="s1">[dct.pop(attr</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">attrs]</span>
        <span class="s2">return </span><span class="s1">dct</span>

    <span class="s2">def </span><span class="s1">_attach_methods(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Attaches dynamically created methods to the rv_continuous instance. 
        &quot;&quot;&quot;</span>
        <span class="s0"># _attach_methods is responsible for calling _attach_argparser_methods</span>
        <span class="s1">self._attach_argparser_methods()</span>

        <span class="s0"># nin correction</span>
        <span class="s1">self._ppfvec = vectorize(self._ppf_single</span><span class="s2">, </span><span class="s1">otypes=</span><span class="s3">'d'</span><span class="s1">)</span>
        <span class="s1">self._ppfvec.nin = self.numargs + </span><span class="s4">1</span>
        <span class="s1">self.vecentropy = vectorize(self._entropy</span><span class="s2">, </span><span class="s1">otypes=</span><span class="s3">'d'</span><span class="s1">)</span>
        <span class="s1">self._cdfvec = vectorize(self._cdf_single</span><span class="s2">, </span><span class="s1">otypes=</span><span class="s3">'d'</span><span class="s1">)</span>
        <span class="s1">self._cdfvec.nin = self.numargs + </span><span class="s4">1</span>

        <span class="s2">if </span><span class="s1">self.moment_type == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">self.generic_moment = vectorize(self._mom0_sc</span><span class="s2">, </span><span class="s1">otypes=</span><span class="s3">'d'</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.generic_moment = vectorize(self._mom1_sc</span><span class="s2">, </span><span class="s1">otypes=</span><span class="s3">'d'</span><span class="s1">)</span>
        <span class="s0"># Because of the *args argument of _mom0_sc, vectorize cannot count the</span>
        <span class="s0"># number of arguments correctly.</span>
        <span class="s1">self.generic_moment.nin = self.numargs + </span><span class="s4">1</span>

    <span class="s2">def </span><span class="s1">_updated_ctor_param(self):</span>
        <span class="s5">&quot;&quot;&quot;Return the current version of _ctor_param, possibly updated by user. 
 
        Used by freezing. 
        Keep this in sync with the signature of __init__. 
        &quot;&quot;&quot;</span>
        <span class="s1">dct = self._ctor_param.copy()</span>
        <span class="s1">dct[</span><span class="s3">'a'</span><span class="s1">] = self.a</span>
        <span class="s1">dct[</span><span class="s3">'b'</span><span class="s1">] = self.b</span>
        <span class="s1">dct[</span><span class="s3">'xtol'</span><span class="s1">] = self.xtol</span>
        <span class="s1">dct[</span><span class="s3">'badvalue'</span><span class="s1">] = self.badvalue</span>
        <span class="s1">dct[</span><span class="s3">'name'</span><span class="s1">] = self.name</span>
        <span class="s1">dct[</span><span class="s3">'shapes'</span><span class="s1">] = self.shapes</span>
        <span class="s2">return </span><span class="s1">dct</span>

    <span class="s2">def </span><span class="s1">_ppf_to_solve(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s2">return </span><span class="s1">self.cdf(*(x</span><span class="s2">, </span><span class="s1">)+args)-q</span>

    <span class="s2">def </span><span class="s1">_ppf_single(self</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s1">factor = </span><span class="s4">10.</span>
        <span class="s1">left</span><span class="s2">, </span><span class="s1">right = self._get_support(*args)</span>

        <span class="s2">if </span><span class="s1">np.isinf(left):</span>
            <span class="s1">left = min(-factor</span><span class="s2">, </span><span class="s1">right)</span>
            <span class="s2">while </span><span class="s1">self._ppf_to_solve(left</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">*args) &gt; </span><span class="s4">0.</span><span class="s1">:</span>
                <span class="s1">left</span><span class="s2">, </span><span class="s1">right = left * factor</span><span class="s2">, </span><span class="s1">left</span>
            <span class="s0"># left is now such that cdf(left) &lt;= q</span>
            <span class="s0"># if right has changed, then cdf(right) &gt; q</span>

        <span class="s2">if </span><span class="s1">np.isinf(right):</span>
            <span class="s1">right = max(factor</span><span class="s2">, </span><span class="s1">left)</span>
            <span class="s2">while </span><span class="s1">self._ppf_to_solve(right</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">*args) &lt; </span><span class="s4">0.</span><span class="s1">:</span>
                <span class="s1">left</span><span class="s2">, </span><span class="s1">right = right</span><span class="s2">, </span><span class="s1">right * factor</span>
            <span class="s0"># right is now such that cdf(right) &gt;= q</span>

        <span class="s2">return </span><span class="s1">optimize.brentq(self._ppf_to_solve</span><span class="s2">,</span>
                               <span class="s1">left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">args=(q</span><span class="s2">,</span><span class="s1">)+args</span><span class="s2">, </span><span class="s1">xtol=self.xtol)</span>

    <span class="s0"># moment from definition</span>
    <span class="s2">def </span><span class="s1">_mom_integ0(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s2">return </span><span class="s1">x**m * self.pdf(x</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s2">def </span><span class="s1">_mom0_sc(self</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s1">_a</span><span class="s2">, </span><span class="s1">_b = self._get_support(*args)</span>
        <span class="s2">return </span><span class="s1">integrate.quad(self._mom_integ0</span><span class="s2">, </span><span class="s1">_a</span><span class="s2">, </span><span class="s1">_b</span><span class="s2">,</span>
                              <span class="s1">args=(m</span><span class="s2">,</span><span class="s1">)+args)[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s0"># moment calculated using ppf</span>
    <span class="s2">def </span><span class="s1">_mom_integ1(self</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s2">return </span><span class="s1">(self.ppf(q</span><span class="s2">, </span><span class="s1">*args))**m</span>

    <span class="s2">def </span><span class="s1">_mom1_sc(self</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s2">return </span><span class="s1">integrate.quad(self._mom_integ1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">args=(m</span><span class="s2">,</span><span class="s1">)+args)[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">_pdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s2">return </span><span class="s1">_derivative(self._cdf</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">dx=</span><span class="s4">1e-5</span><span class="s2">, </span><span class="s1">args=args</span><span class="s2">, </span><span class="s1">order=</span><span class="s4">5</span><span class="s1">)</span>

    <span class="s0"># Could also define any of these</span>
    <span class="s2">def </span><span class="s1">_logpdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s1">p = self._pdf(x</span><span class="s2">, </span><span class="s1">*args)</span>
        <span class="s2">with </span><span class="s1">np.errstate(divide=</span><span class="s3">'ignore'</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">log(p)</span>

    <span class="s2">def </span><span class="s1">_logpxf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s0"># continuous distributions have PDF, discrete have PMF, but sometimes</span>
        <span class="s0"># the distinction doesn't matter. This lets us use `_logpxf` for both</span>
        <span class="s0"># discrete and continuous distributions.</span>
        <span class="s2">return </span><span class="s1">self._logpdf(x</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s2">def </span><span class="s1">_cdf_single(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s1">_a</span><span class="s2">, </span><span class="s1">_b = self._get_support(*args)</span>
        <span class="s2">return </span><span class="s1">integrate.quad(self._pdf</span><span class="s2">, </span><span class="s1">_a</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">args=args)[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">_cdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s2">return </span><span class="s1">self._cdfvec(x</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s0"># generic _argcheck, _logcdf, _sf, _logsf, _ppf, _isf, _rvs are defined</span>
    <span class="s0"># in rv_generic</span>

    <span class="s2">def </span><span class="s1">pdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s5">&quot;&quot;&quot;Probability density function at x of the given RV. 
 
        Parameters 
        ---------- 
        x : array_like 
            quantiles 
        arg1, arg2, arg3,... : array_like 
            The shape parameter(s) for the distribution (see docstring of the 
            instance object for more information) 
        loc : array_like, optional 
            location parameter (default=0) 
        scale : array_like, optional 
            scale parameter (default=1) 
 
        Returns 
        ------- 
        pdf : ndarray 
            Probability density function evaluated at x 
 
        &quot;&quot;&quot;</span>
        <span class="s1">args</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = self._parse_args(*args</span><span class="s2">, </span><span class="s1">**kwds)</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = map(asarray</span><span class="s2">, </span><span class="s1">(x</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale))</span>
        <span class="s1">args = tuple(map(asarray</span><span class="s2">, </span><span class="s1">args))</span>
        <span class="s1">dtyp = np.promote_types(x.dtype</span><span class="s2">, </span><span class="s1">np.float64)</span>
        <span class="s1">x = np.asarray((x - loc)/scale</span><span class="s2">, </span><span class="s1">dtype=dtyp)</span>
        <span class="s1">cond0 = self._argcheck(*args) &amp; (scale &gt; </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">cond1 = self._support_mask(x</span><span class="s2">, </span><span class="s1">*args) &amp; (scale &gt; </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">cond = cond0 &amp; cond1</span>
        <span class="s1">output = zeros(shape(cond)</span><span class="s2">, </span><span class="s1">dtyp)</span>
        <span class="s1">putmask(output</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s1">-cond0)+np.isnan(x)</span><span class="s2">, </span><span class="s1">self.badvalue)</span>
        <span class="s2">if </span><span class="s1">np.any(cond):</span>
            <span class="s1">goodargs = argsreduce(cond</span><span class="s2">, </span><span class="s1">*((x</span><span class="s2">,</span><span class="s1">)+args+(scale</span><span class="s2">,</span><span class="s1">)))</span>
            <span class="s1">scale</span><span class="s2">, </span><span class="s1">goodargs = goodargs[-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">goodargs[:-</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">place(output</span><span class="s2">, </span><span class="s1">cond</span><span class="s2">, </span><span class="s1">self._pdf(*goodargs) / scale)</span>
        <span class="s2">if </span><span class="s1">output.ndim == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">output[()]</span>
        <span class="s2">return </span><span class="s1">output</span>

    <span class="s2">def </span><span class="s1">logpdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s5">&quot;&quot;&quot;Log of the probability density function at x of the given RV. 
 
        This uses a more numerically accurate calculation if available. 
 
        Parameters 
        ---------- 
        x : array_like 
            quantiles 
        arg1, arg2, arg3,... : array_like 
            The shape parameter(s) for the distribution (see docstring of the 
            instance object for more information) 
        loc : array_like, optional 
            location parameter (default=0) 
        scale : array_like, optional 
            scale parameter (default=1) 
 
        Returns 
        ------- 
        logpdf : array_like 
            Log of the probability density function evaluated at x 
 
        &quot;&quot;&quot;</span>
        <span class="s1">args</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = self._parse_args(*args</span><span class="s2">, </span><span class="s1">**kwds)</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = map(asarray</span><span class="s2">, </span><span class="s1">(x</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale))</span>
        <span class="s1">args = tuple(map(asarray</span><span class="s2">, </span><span class="s1">args))</span>
        <span class="s1">dtyp = np.promote_types(x.dtype</span><span class="s2">, </span><span class="s1">np.float64)</span>
        <span class="s1">x = np.asarray((x - loc)/scale</span><span class="s2">, </span><span class="s1">dtype=dtyp)</span>
        <span class="s1">cond0 = self._argcheck(*args) &amp; (scale &gt; </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">cond1 = self._support_mask(x</span><span class="s2">, </span><span class="s1">*args) &amp; (scale &gt; </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">cond = cond0 &amp; cond1</span>
        <span class="s1">output = empty(shape(cond)</span><span class="s2">, </span><span class="s1">dtyp)</span>
        <span class="s1">output.fill(NINF)</span>
        <span class="s1">putmask(output</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s1">-cond0)+np.isnan(x)</span><span class="s2">, </span><span class="s1">self.badvalue)</span>
        <span class="s2">if </span><span class="s1">np.any(cond):</span>
            <span class="s1">goodargs = argsreduce(cond</span><span class="s2">, </span><span class="s1">*((x</span><span class="s2">,</span><span class="s1">)+args+(scale</span><span class="s2">,</span><span class="s1">)))</span>
            <span class="s1">scale</span><span class="s2">, </span><span class="s1">goodargs = goodargs[-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">goodargs[:-</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">place(output</span><span class="s2">, </span><span class="s1">cond</span><span class="s2">, </span><span class="s1">self._logpdf(*goodargs) - log(scale))</span>
        <span class="s2">if </span><span class="s1">output.ndim == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">output[()]</span>
        <span class="s2">return </span><span class="s1">output</span>

    <span class="s2">def </span><span class="s1">cdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s5">&quot;&quot;&quot; 
        Cumulative distribution function of the given RV. 
 
        Parameters 
        ---------- 
        x : array_like 
            quantiles 
        arg1, arg2, arg3,... : array_like 
            The shape parameter(s) for the distribution (see docstring of the 
            instance object for more information) 
        loc : array_like, optional 
            location parameter (default=0) 
        scale : array_like, optional 
            scale parameter (default=1) 
 
        Returns 
        ------- 
        cdf : ndarray 
            Cumulative distribution function evaluated at `x` 
 
        &quot;&quot;&quot;</span>
        <span class="s1">args</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = self._parse_args(*args</span><span class="s2">, </span><span class="s1">**kwds)</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = map(asarray</span><span class="s2">, </span><span class="s1">(x</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale))</span>
        <span class="s1">args = tuple(map(asarray</span><span class="s2">, </span><span class="s1">args))</span>
        <span class="s1">_a</span><span class="s2">, </span><span class="s1">_b = self._get_support(*args)</span>
        <span class="s1">dtyp = np.promote_types(x.dtype</span><span class="s2">, </span><span class="s1">np.float64)</span>
        <span class="s1">x = np.asarray((x - loc)/scale</span><span class="s2">, </span><span class="s1">dtype=dtyp)</span>
        <span class="s1">cond0 = self._argcheck(*args) &amp; (scale &gt; </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">cond1 = self._open_support_mask(x</span><span class="s2">, </span><span class="s1">*args) &amp; (scale &gt; </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">cond2 = (x &gt;= np.asarray(_b)) &amp; cond0</span>
        <span class="s1">cond = cond0 &amp; cond1</span>
        <span class="s1">output = zeros(shape(cond)</span><span class="s2">, </span><span class="s1">dtyp)</span>
        <span class="s1">place(output</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s1">-cond0)+np.isnan(x)</span><span class="s2">, </span><span class="s1">self.badvalue)</span>
        <span class="s1">place(output</span><span class="s2">, </span><span class="s1">cond2</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">np.any(cond):  </span><span class="s0"># call only if at least 1 entry</span>
            <span class="s1">goodargs = argsreduce(cond</span><span class="s2">, </span><span class="s1">*((x</span><span class="s2">,</span><span class="s1">)+args))</span>
            <span class="s1">place(output</span><span class="s2">, </span><span class="s1">cond</span><span class="s2">, </span><span class="s1">self._cdf(*goodargs))</span>
        <span class="s2">if </span><span class="s1">output.ndim == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">output[()]</span>
        <span class="s2">return </span><span class="s1">output</span>

    <span class="s2">def </span><span class="s1">logcdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s5">&quot;&quot;&quot;Log of the cumulative distribution function at x of the given RV. 
 
        Parameters 
        ---------- 
        x : array_like 
            quantiles 
        arg1, arg2, arg3,... : array_like 
            The shape parameter(s) for the distribution (see docstring of the 
            instance object for more information) 
        loc : array_like, optional 
            location parameter (default=0) 
        scale : array_like, optional 
            scale parameter (default=1) 
 
        Returns 
        ------- 
        logcdf : array_like 
            Log of the cumulative distribution function evaluated at x 
 
        &quot;&quot;&quot;</span>
        <span class="s1">args</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = self._parse_args(*args</span><span class="s2">, </span><span class="s1">**kwds)</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = map(asarray</span><span class="s2">, </span><span class="s1">(x</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale))</span>
        <span class="s1">args = tuple(map(asarray</span><span class="s2">, </span><span class="s1">args))</span>
        <span class="s1">_a</span><span class="s2">, </span><span class="s1">_b = self._get_support(*args)</span>
        <span class="s1">dtyp = np.promote_types(x.dtype</span><span class="s2">, </span><span class="s1">np.float64)</span>
        <span class="s1">x = np.asarray((x - loc)/scale</span><span class="s2">, </span><span class="s1">dtype=dtyp)</span>
        <span class="s1">cond0 = self._argcheck(*args) &amp; (scale &gt; </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">cond1 = self._open_support_mask(x</span><span class="s2">, </span><span class="s1">*args) &amp; (scale &gt; </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">cond2 = (x &gt;= _b) &amp; cond0</span>
        <span class="s1">cond = cond0 &amp; cond1</span>
        <span class="s1">output = empty(shape(cond)</span><span class="s2">, </span><span class="s1">dtyp)</span>
        <span class="s1">output.fill(NINF)</span>
        <span class="s1">place(output</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s1">-cond0)*(cond1 == cond1)+np.isnan(x)</span><span class="s2">, </span><span class="s1">self.badvalue)</span>
        <span class="s1">place(output</span><span class="s2">, </span><span class="s1">cond2</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">np.any(cond):  </span><span class="s0"># call only if at least 1 entry</span>
            <span class="s1">goodargs = argsreduce(cond</span><span class="s2">, </span><span class="s1">*((x</span><span class="s2">,</span><span class="s1">)+args))</span>
            <span class="s1">place(output</span><span class="s2">, </span><span class="s1">cond</span><span class="s2">, </span><span class="s1">self._logcdf(*goodargs))</span>
        <span class="s2">if </span><span class="s1">output.ndim == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">output[()]</span>
        <span class="s2">return </span><span class="s1">output</span>

    <span class="s2">def </span><span class="s1">sf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s5">&quot;&quot;&quot;Survival function (1 - `cdf`) at x of the given RV. 
 
        Parameters 
        ---------- 
        x : array_like 
            quantiles 
        arg1, arg2, arg3,... : array_like 
            The shape parameter(s) for the distribution (see docstring of the 
            instance object for more information) 
        loc : array_like, optional 
            location parameter (default=0) 
        scale : array_like, optional 
            scale parameter (default=1) 
 
        Returns 
        ------- 
        sf : array_like 
            Survival function evaluated at x 
 
        &quot;&quot;&quot;</span>
        <span class="s1">args</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = self._parse_args(*args</span><span class="s2">, </span><span class="s1">**kwds)</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = map(asarray</span><span class="s2">, </span><span class="s1">(x</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale))</span>
        <span class="s1">args = tuple(map(asarray</span><span class="s2">, </span><span class="s1">args))</span>
        <span class="s1">_a</span><span class="s2">, </span><span class="s1">_b = self._get_support(*args)</span>
        <span class="s1">dtyp = np.promote_types(x.dtype</span><span class="s2">, </span><span class="s1">np.float64)</span>
        <span class="s1">x = np.asarray((x - loc)/scale</span><span class="s2">, </span><span class="s1">dtype=dtyp)</span>
        <span class="s1">cond0 = self._argcheck(*args) &amp; (scale &gt; </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">cond1 = self._open_support_mask(x</span><span class="s2">, </span><span class="s1">*args) &amp; (scale &gt; </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">cond2 = cond0 &amp; (x &lt;= _a)</span>
        <span class="s1">cond = cond0 &amp; cond1</span>
        <span class="s1">output = zeros(shape(cond)</span><span class="s2">, </span><span class="s1">dtyp)</span>
        <span class="s1">place(output</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s1">-cond0)+np.isnan(x)</span><span class="s2">, </span><span class="s1">self.badvalue)</span>
        <span class="s1">place(output</span><span class="s2">, </span><span class="s1">cond2</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">np.any(cond):</span>
            <span class="s1">goodargs = argsreduce(cond</span><span class="s2">, </span><span class="s1">*((x</span><span class="s2">,</span><span class="s1">)+args))</span>
            <span class="s1">place(output</span><span class="s2">, </span><span class="s1">cond</span><span class="s2">, </span><span class="s1">self._sf(*goodargs))</span>
        <span class="s2">if </span><span class="s1">output.ndim == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">output[()]</span>
        <span class="s2">return </span><span class="s1">output</span>

    <span class="s2">def </span><span class="s1">logsf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s5">&quot;&quot;&quot;Log of the survival function of the given RV. 
 
        Returns the log of the &quot;survival function,&quot; defined as (1 - `cdf`), 
        evaluated at `x`. 
 
        Parameters 
        ---------- 
        x : array_like 
            quantiles 
        arg1, arg2, arg3,... : array_like 
            The shape parameter(s) for the distribution (see docstring of the 
            instance object for more information) 
        loc : array_like, optional 
            location parameter (default=0) 
        scale : array_like, optional 
            scale parameter (default=1) 
 
        Returns 
        ------- 
        logsf : ndarray 
            Log of the survival function evaluated at `x`. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">args</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = self._parse_args(*args</span><span class="s2">, </span><span class="s1">**kwds)</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = map(asarray</span><span class="s2">, </span><span class="s1">(x</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale))</span>
        <span class="s1">args = tuple(map(asarray</span><span class="s2">, </span><span class="s1">args))</span>
        <span class="s1">_a</span><span class="s2">, </span><span class="s1">_b = self._get_support(*args)</span>
        <span class="s1">dtyp = np.promote_types(x.dtype</span><span class="s2">, </span><span class="s1">np.float64)</span>
        <span class="s1">x = np.asarray((x - loc)/scale</span><span class="s2">, </span><span class="s1">dtype=dtyp)</span>
        <span class="s1">cond0 = self._argcheck(*args) &amp; (scale &gt; </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">cond1 = self._open_support_mask(x</span><span class="s2">, </span><span class="s1">*args) &amp; (scale &gt; </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">cond2 = cond0 &amp; (x &lt;= _a)</span>
        <span class="s1">cond = cond0 &amp; cond1</span>
        <span class="s1">output = empty(shape(cond)</span><span class="s2">, </span><span class="s1">dtyp)</span>
        <span class="s1">output.fill(NINF)</span>
        <span class="s1">place(output</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s1">-cond0)+np.isnan(x)</span><span class="s2">, </span><span class="s1">self.badvalue)</span>
        <span class="s1">place(output</span><span class="s2">, </span><span class="s1">cond2</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">np.any(cond):</span>
            <span class="s1">goodargs = argsreduce(cond</span><span class="s2">, </span><span class="s1">*((x</span><span class="s2">,</span><span class="s1">)+args))</span>
            <span class="s1">place(output</span><span class="s2">, </span><span class="s1">cond</span><span class="s2">, </span><span class="s1">self._logsf(*goodargs))</span>
        <span class="s2">if </span><span class="s1">output.ndim == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">output[()]</span>
        <span class="s2">return </span><span class="s1">output</span>

    <span class="s2">def </span><span class="s1">ppf(self</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s5">&quot;&quot;&quot;Percent point function (inverse of `cdf`) at q of the given RV. 
 
        Parameters 
        ---------- 
        q : array_like 
            lower tail probability 
        arg1, arg2, arg3,... : array_like 
            The shape parameter(s) for the distribution (see docstring of the 
            instance object for more information) 
        loc : array_like, optional 
            location parameter (default=0) 
        scale : array_like, optional 
            scale parameter (default=1) 
 
        Returns 
        ------- 
        x : array_like 
            quantile corresponding to the lower tail probability q. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">args</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = self._parse_args(*args</span><span class="s2">, </span><span class="s1">**kwds)</span>
        <span class="s1">q</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = map(asarray</span><span class="s2">, </span><span class="s1">(q</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale))</span>
        <span class="s1">args = tuple(map(asarray</span><span class="s2">, </span><span class="s1">args))</span>
        <span class="s1">_a</span><span class="s2">, </span><span class="s1">_b = self._get_support(*args)</span>
        <span class="s1">cond0 = self._argcheck(*args) &amp; (scale &gt; </span><span class="s4">0</span><span class="s1">) &amp; (loc == loc)</span>
        <span class="s1">cond1 = (</span><span class="s4">0 </span><span class="s1">&lt; q) &amp; (q &lt; </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">cond2 = cond0 &amp; (q == </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">cond3 = cond0 &amp; (q == </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">cond = cond0 &amp; cond1</span>
        <span class="s1">output = np.full(shape(cond)</span><span class="s2">, </span><span class="s1">fill_value=self.badvalue)</span>

        <span class="s1">lower_bound = _a * scale + loc</span>
        <span class="s1">upper_bound = _b * scale + loc</span>
        <span class="s1">place(output</span><span class="s2">, </span><span class="s1">cond2</span><span class="s2">, </span><span class="s1">argsreduce(cond2</span><span class="s2">, </span><span class="s1">lower_bound)[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">place(output</span><span class="s2">, </span><span class="s1">cond3</span><span class="s2">, </span><span class="s1">argsreduce(cond3</span><span class="s2">, </span><span class="s1">upper_bound)[</span><span class="s4">0</span><span class="s1">])</span>

        <span class="s2">if </span><span class="s1">np.any(cond):  </span><span class="s0"># call only if at least 1 entry</span>
            <span class="s1">goodargs = argsreduce(cond</span><span class="s2">, </span><span class="s1">*((q</span><span class="s2">,</span><span class="s1">)+args+(scale</span><span class="s2">, </span><span class="s1">loc)))</span>
            <span class="s1">scale</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">goodargs = goodargs[-</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">goodargs[-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">goodargs[:-</span><span class="s4">2</span><span class="s1">]</span>
            <span class="s1">place(output</span><span class="s2">, </span><span class="s1">cond</span><span class="s2">, </span><span class="s1">self._ppf(*goodargs) * scale + loc)</span>
        <span class="s2">if </span><span class="s1">output.ndim == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">output[()]</span>
        <span class="s2">return </span><span class="s1">output</span>

    <span class="s2">def </span><span class="s1">isf(self</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s5">&quot;&quot;&quot;Inverse survival function (inverse of `sf`) at q of the given RV. 
 
        Parameters 
        ---------- 
        q : array_like 
            upper tail probability 
        arg1, arg2, arg3,... : array_like 
            The shape parameter(s) for the distribution (see docstring of the 
            instance object for more information) 
        loc : array_like, optional 
            location parameter (default=0) 
        scale : array_like, optional 
            scale parameter (default=1) 
 
        Returns 
        ------- 
        x : ndarray or scalar 
            Quantile corresponding to the upper tail probability q. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">args</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = self._parse_args(*args</span><span class="s2">, </span><span class="s1">**kwds)</span>
        <span class="s1">q</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = map(asarray</span><span class="s2">, </span><span class="s1">(q</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale))</span>
        <span class="s1">args = tuple(map(asarray</span><span class="s2">, </span><span class="s1">args))</span>
        <span class="s1">_a</span><span class="s2">, </span><span class="s1">_b = self._get_support(*args)</span>
        <span class="s1">cond0 = self._argcheck(*args) &amp; (scale &gt; </span><span class="s4">0</span><span class="s1">) &amp; (loc == loc)</span>
        <span class="s1">cond1 = (</span><span class="s4">0 </span><span class="s1">&lt; q) &amp; (q &lt; </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">cond2 = cond0 &amp; (q == </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">cond3 = cond0 &amp; (q == </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">cond = cond0 &amp; cond1</span>
        <span class="s1">output = np.full(shape(cond)</span><span class="s2">, </span><span class="s1">fill_value=self.badvalue)</span>

        <span class="s1">lower_bound = _a * scale + loc</span>
        <span class="s1">upper_bound = _b * scale + loc</span>
        <span class="s1">place(output</span><span class="s2">, </span><span class="s1">cond2</span><span class="s2">, </span><span class="s1">argsreduce(cond2</span><span class="s2">, </span><span class="s1">lower_bound)[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">place(output</span><span class="s2">, </span><span class="s1">cond3</span><span class="s2">, </span><span class="s1">argsreduce(cond3</span><span class="s2">, </span><span class="s1">upper_bound)[</span><span class="s4">0</span><span class="s1">])</span>

        <span class="s2">if </span><span class="s1">np.any(cond):</span>
            <span class="s1">goodargs = argsreduce(cond</span><span class="s2">, </span><span class="s1">*((q</span><span class="s2">,</span><span class="s1">)+args+(scale</span><span class="s2">, </span><span class="s1">loc)))</span>
            <span class="s1">scale</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">goodargs = goodargs[-</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">goodargs[-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">goodargs[:-</span><span class="s4">2</span><span class="s1">]</span>
            <span class="s1">place(output</span><span class="s2">, </span><span class="s1">cond</span><span class="s2">, </span><span class="s1">self._isf(*goodargs) * scale + loc)</span>
        <span class="s2">if </span><span class="s1">output.ndim == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">output[()]</span>
        <span class="s2">return </span><span class="s1">output</span>

    <span class="s2">def </span><span class="s1">_unpack_loc_scale(self</span><span class="s2">, </span><span class="s1">theta):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">loc = theta[-</span><span class="s4">2</span><span class="s1">]</span>
            <span class="s1">scale = theta[-</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">args = tuple(theta[:-</span><span class="s4">2</span><span class="s1">])</span>
        <span class="s2">except </span><span class="s1">IndexError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Not enough input arguments.&quot;</span><span class="s1">) </span><span class="s2">from </span><span class="s1">e</span>
        <span class="s2">return </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">args</span>

    <span class="s2">def </span><span class="s1">_nnlf_and_penalty(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">args):</span>
        <span class="s5">&quot;&quot;&quot; 
        Compute the penalized negative log-likelihood for the 
        &quot;standardized&quot; data (i.e. already shifted by loc and 
        scaled by scale) for the shape parameters in `args`. 
 
        `x` can be a 1D numpy array or a CensoredData instance. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">CensoredData):</span>
            <span class="s0"># Filter out the data that is not in the support.</span>
            <span class="s1">xs = x._supported(*self._get_support(*args))</span>
            <span class="s1">n_bad = len(x) - len(xs)</span>
            <span class="s1">i1</span><span class="s2">, </span><span class="s1">i2 = xs._interval.T</span>
            <span class="s1">terms = [</span>
                <span class="s0"># logpdf of the noncensored data.</span>
                <span class="s1">self._logpdf(xs._uncensored</span><span class="s2">, </span><span class="s1">*args)</span><span class="s2">,</span>
                <span class="s0"># logcdf of the left-censored data.</span>
                <span class="s1">self._logcdf(xs._left</span><span class="s2">, </span><span class="s1">*args)</span><span class="s2">,</span>
                <span class="s0"># logsf of the right-censored data.</span>
                <span class="s1">self._logsf(xs._right</span><span class="s2">, </span><span class="s1">*args)</span><span class="s2">,</span>
                <span class="s0"># log of probability of the interval-censored data.</span>
                <span class="s1">np.log(self._delta_cdf(i1</span><span class="s2">, </span><span class="s1">i2</span><span class="s2">, </span><span class="s1">*args))</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">cond0 = ~self._support_mask(x</span><span class="s2">, </span><span class="s1">*args)</span>
            <span class="s1">n_bad = np.count_nonzero(cond0)</span>
            <span class="s2">if </span><span class="s1">n_bad &gt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">x = argsreduce(~cond0</span><span class="s2">, </span><span class="s1">x)[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">terms = [self._logpdf(x</span><span class="s2">, </span><span class="s1">*args)]</span>

        <span class="s1">totals</span><span class="s2">, </span><span class="s1">bad_counts = zip(*[_sum_finite(term) </span><span class="s2">for </span><span class="s1">term </span><span class="s2">in </span><span class="s1">terms])</span>
        <span class="s1">total = sum(totals)</span>
        <span class="s1">n_bad += sum(bad_counts)</span>

        <span class="s2">return </span><span class="s1">-total + n_bad * _LOGXMAX * </span><span class="s4">100</span>

    <span class="s2">def </span><span class="s1">_penalized_nnlf(self</span><span class="s2">, </span><span class="s1">theta</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s5">&quot;&quot;&quot;Penalized negative loglikelihood function. 
 
        i.e., - sum (log pdf(x, theta), axis=0) + penalty 
        where theta are the parameters (including loc and scale) 
        &quot;&quot;&quot;</span>
        <span class="s1">loc</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">args = self._unpack_loc_scale(theta)</span>
        <span class="s2">if not </span><span class="s1">self._argcheck(*args) </span><span class="s2">or </span><span class="s1">scale &lt;= </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">inf</span>
        <span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">CensoredData):</span>
            <span class="s1">x = (x - loc) / scale</span>
            <span class="s1">n_log_scale = (len(x) - x.num_censored()) * log(scale)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">x = (x - loc) / scale</span>
            <span class="s1">n_log_scale = len(x) * log(scale)</span>

        <span class="s2">return </span><span class="s1">self._nnlf_and_penalty(x</span><span class="s2">, </span><span class="s1">args) + n_log_scale</span>

    <span class="s2">def </span><span class="s1">_fitstart(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">args=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Starting point for fit (shape arguments + loc + scale).&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">args </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">args = (</span><span class="s4">1.0</span><span class="s2">,</span><span class="s1">)*self.numargs</span>
        <span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = self._fit_loc_scale_support(data</span><span class="s2">, </span><span class="s1">*args)</span>
        <span class="s2">return </span><span class="s1">args + (loc</span><span class="s2">, </span><span class="s1">scale)</span>

    <span class="s2">def </span><span class="s1">_reduce_func(self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwds</span><span class="s2">, </span><span class="s1">data=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Return the (possibly reduced) function to optimize in order to find MLE 
        estimates for the .fit method. 
        &quot;&quot;&quot;</span>
        <span class="s0"># Convert fixed shape parameters to the standard numeric form: e.g. for</span>
        <span class="s0"># stats.beta, shapes='a, b'. To fix `a`, the caller can give a value</span>
        <span class="s0"># for `f0`, `fa` or 'fix_a'.  The following converts the latter two</span>
        <span class="s0"># into the first (numeric) form.</span>
        <span class="s1">shapes = []</span>
        <span class="s2">if </span><span class="s1">self.shapes:</span>
            <span class="s1">shapes = self.shapes.replace(</span><span class="s3">','</span><span class="s2">, </span><span class="s3">' '</span><span class="s1">).split()</span>
            <span class="s2">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">s </span><span class="s2">in </span><span class="s1">enumerate(shapes):</span>
                <span class="s1">key = </span><span class="s3">'f' </span><span class="s1">+ str(j)</span>
                <span class="s1">names = [key</span><span class="s2">, </span><span class="s3">'f' </span><span class="s1">+ s</span><span class="s2">, </span><span class="s3">'fix_' </span><span class="s1">+ s]</span>
                <span class="s1">val = _get_fixed_fit_value(kwds</span><span class="s2">, </span><span class="s1">names)</span>
                <span class="s2">if </span><span class="s1">val </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">kwds[key] = val</span>

        <span class="s1">args = list(args)</span>
        <span class="s1">Nargs = len(args)</span>
        <span class="s1">fixedn = []</span>
        <span class="s1">names = [</span><span class="s3">'f%d' </span><span class="s1">% n </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(Nargs - </span><span class="s4">2</span><span class="s1">)] + [</span><span class="s3">'floc'</span><span class="s2">, </span><span class="s3">'fscale'</span><span class="s1">]</span>
        <span class="s1">x0 = []</span>
        <span class="s2">for </span><span class="s1">n</span><span class="s2">, </span><span class="s1">key </span><span class="s2">in </span><span class="s1">enumerate(names):</span>
            <span class="s2">if </span><span class="s1">key </span><span class="s2">in </span><span class="s1">kwds:</span>
                <span class="s1">fixedn.append(n)</span>
                <span class="s1">args[n] = kwds.pop(key)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">x0.append(args[n])</span>

        <span class="s1">methods = {</span><span class="s3">&quot;mle&quot;</span><span class="s2">, </span><span class="s3">&quot;mm&quot;</span><span class="s1">}</span>
        <span class="s1">method = kwds.pop(</span><span class="s3">'method'</span><span class="s2">, </span><span class="s3">&quot;mle&quot;</span><span class="s1">).lower()</span>
        <span class="s2">if </span><span class="s1">method == </span><span class="s3">&quot;mm&quot;</span><span class="s1">:</span>
            <span class="s1">n_params = len(shapes) + </span><span class="s4">2 </span><span class="s1">- len(fixedn)</span>
            <span class="s1">exponents = (np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">n_params+</span><span class="s4">1</span><span class="s1">))[:</span><span class="s2">, </span><span class="s1">np.newaxis]</span>
            <span class="s1">data_moments = np.sum(data[</span><span class="s2">None, </span><span class="s1">:]**exponents/len(data)</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>

            <span class="s2">def </span><span class="s1">objective(theta</span><span class="s2">, </span><span class="s1">x):</span>
                <span class="s2">return </span><span class="s1">self._moment_error(theta</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">data_moments)</span>

        <span class="s2">elif </span><span class="s1">method == </span><span class="s3">&quot;mle&quot;</span><span class="s1">:</span>
            <span class="s1">objective = self._penalized_nnlf</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Method '{}' not available; must be one of {}&quot;</span>
                             <span class="s1">.format(method</span><span class="s2">, </span><span class="s1">methods))</span>

        <span class="s2">if </span><span class="s1">len(fixedn) == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">func = objective</span>
            <span class="s1">restore = </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">len(fixedn) == Nargs:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;All parameters fixed. There is nothing to optimize.&quot;</span><span class="s1">)</span>

            <span class="s2">def </span><span class="s1">restore(args</span><span class="s2">, </span><span class="s1">theta):</span>
                <span class="s0"># Replace with theta for all numbers not in fixedn</span>
                <span class="s0"># This allows the non-fixed values to vary, but</span>
                <span class="s0">#  we still call self.nnlf with all parameters.</span>
                <span class="s1">i = </span><span class="s4">0</span>
                <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(Nargs):</span>
                    <span class="s2">if </span><span class="s1">n </span><span class="s2">not in </span><span class="s1">fixedn:</span>
                        <span class="s1">args[n] = theta[i]</span>
                        <span class="s1">i += </span><span class="s4">1</span>
                <span class="s2">return </span><span class="s1">args</span>

            <span class="s2">def </span><span class="s1">func(theta</span><span class="s2">, </span><span class="s1">x):</span>
                <span class="s1">newtheta = restore(args[:]</span><span class="s2">, </span><span class="s1">theta)</span>
                <span class="s2">return </span><span class="s1">objective(newtheta</span><span class="s2">, </span><span class="s1">x)</span>

        <span class="s2">return </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">restore</span><span class="s2">, </span><span class="s1">args</span>

    <span class="s2">def </span><span class="s1">_moment_error(self</span><span class="s2">, </span><span class="s1">theta</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">data_moments):</span>
        <span class="s1">loc</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">args = self._unpack_loc_scale(theta)</span>
        <span class="s2">if not </span><span class="s1">self._argcheck(*args) </span><span class="s2">or </span><span class="s1">scale &lt;= </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">inf</span>

        <span class="s1">dist_moments = np.array([self.moment(i+</span><span class="s4">1</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">loc=loc</span><span class="s2">, </span><span class="s1">scale=scale)</span>
                                 <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(data_moments))])</span>
        <span class="s2">if </span><span class="s1">np.any(np.isnan(dist_moments)):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Method of moments encountered a non-finite &quot;</span>
                             <span class="s3">&quot;distribution moment and cannot continue. &quot;</span>
                             <span class="s3">&quot;Consider trying method='MLE'.&quot;</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">(((data_moments - dist_moments) /</span>
                 <span class="s1">np.maximum(np.abs(data_moments)</span><span class="s2">, </span><span class="s4">1e-8</span><span class="s1">))**</span><span class="s4">2</span><span class="s1">).sum()</span>

    <span class="s2">def </span><span class="s1">fit(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s5">&quot;&quot;&quot; 
        Return estimates of shape (if applicable), location, and scale 
        parameters from data. The default estimation method is Maximum 
        Likelihood Estimation (MLE), but Method of Moments (MM) 
        is also available. 
 
        Starting estimates for the fit are given by input arguments; 
        for any arguments not provided with starting estimates, 
        ``self._fitstart(data)`` is called to generate such. 
 
        One can hold some parameters fixed to specific values by passing in 
        keyword arguments ``f0``, ``f1``, ..., ``fn`` (for shape parameters) 
        and ``floc`` and ``fscale`` (for location and scale parameters, 
        respectively). 
 
        Parameters 
        ---------- 
        data : array_like or `CensoredData` instance 
            Data to use in estimating the distribution parameters. 
        arg1, arg2, arg3,... : floats, optional 
            Starting value(s) for any shape-characterizing arguments (those not 
            provided will be determined by a call to ``_fitstart(data)``). 
            No default value. 
        **kwds : floats, optional 
            - `loc`: initial guess of the distribution's location parameter. 
            - `scale`: initial guess of the distribution's scale parameter. 
 
            Special keyword arguments are recognized as holding certain 
            parameters fixed: 
 
            - f0...fn : hold respective shape parameters fixed. 
              Alternatively, shape parameters to fix can be specified by name. 
              For example, if ``self.shapes == &quot;a, b&quot;``, ``fa`` and ``fix_a`` 
              are equivalent to ``f0``, and ``fb`` and ``fix_b`` are 
              equivalent to ``f1``. 
 
            - floc : hold location parameter fixed to specified value. 
 
            - fscale : hold scale parameter fixed to specified value. 
 
            - optimizer : The optimizer to use.  The optimizer must take 
              ``func`` and starting position as the first two arguments, 
              plus ``args`` (for extra arguments to pass to the 
              function to be optimized) and ``disp=0`` to suppress 
              output as keyword arguments. 
 
            - method : The method to use. The default is &quot;MLE&quot; (Maximum 
              Likelihood Estimate); &quot;MM&quot; (Method of Moments) 
              is also available. 
 
        Raises 
        ------ 
        TypeError, ValueError 
            If an input is invalid 
        `~scipy.stats.FitError` 
            If fitting fails or the fit produced would be invalid 
 
        Returns 
        ------- 
        parameter_tuple : tuple of floats 
            Estimates for any shape parameters (if applicable), followed by 
            those for location and scale. For most random variables, shape 
            statistics will be returned, but there are exceptions (e.g. 
            ``norm``). 
 
        Notes 
        ----- 
        With ``method=&quot;MLE&quot;`` (default), the fit is computed by minimizing 
        the negative log-likelihood function. A large, finite penalty 
        (rather than infinite negative log-likelihood) is applied for 
        observations beyond the support of the distribution. 
 
        With ``method=&quot;MM&quot;``, the fit is computed by minimizing the L2 norm 
        of the relative errors between the first *k* raw (about zero) data 
        moments and the corresponding distribution moments, where *k* is the 
        number of non-fixed parameters. 
        More precisely, the objective function is:: 
 
            (((data_moments - dist_moments) 
              / np.maximum(np.abs(data_moments), 1e-8))**2).sum() 
 
        where the constant ``1e-8`` avoids division by zero in case of 
        vanishing data moments. Typically, this error norm can be reduced to 
        zero. 
        Note that the standard method of moments can produce parameters for 
        which some data are outside the support of the fitted distribution; 
        this implementation does nothing to prevent this. 
 
        For either method, 
        the returned answer is not guaranteed to be globally optimal; it 
        may only be locally optimal, or the optimization may fail altogether. 
        If the data contain any of ``np.nan``, ``np.inf``, or ``-np.inf``, 
        the `fit` method will raise a ``RuntimeError``. 
 
        Examples 
        -------- 
 
        Generate some data to fit: draw random variates from the `beta` 
        distribution 
 
        &gt;&gt;&gt; from scipy.stats import beta 
        &gt;&gt;&gt; a, b = 1., 2. 
        &gt;&gt;&gt; x = beta.rvs(a, b, size=1000) 
 
        Now we can fit all four parameters (``a``, ``b``, ``loc`` and 
        ``scale``): 
 
        &gt;&gt;&gt; a1, b1, loc1, scale1 = beta.fit(x) 
 
        We can also use some prior knowledge about the dataset: let's keep 
        ``loc`` and ``scale`` fixed: 
 
        &gt;&gt;&gt; a1, b1, loc1, scale1 = beta.fit(x, floc=0, fscale=1) 
        &gt;&gt;&gt; loc1, scale1 
        (0, 1) 
 
        We can also keep shape parameters fixed by using ``f``-keywords. To 
        keep the zero-th shape parameter ``a`` equal 1, use ``f0=1`` or, 
        equivalently, ``fa=1``: 
 
        &gt;&gt;&gt; a1, b1, loc1, scale1 = beta.fit(x, fa=1, floc=0, fscale=1) 
        &gt;&gt;&gt; a1 
        1 
 
        Not all distributions return estimates for the shape parameters. 
        ``norm`` for example just returns estimates for location and scale: 
 
        &gt;&gt;&gt; from scipy.stats import norm 
        &gt;&gt;&gt; x = norm.rvs(a, b, size=1000, random_state=123) 
        &gt;&gt;&gt; loc1, scale1 = norm.fit(x) 
        &gt;&gt;&gt; loc1, scale1 
        (0.92087172783841631, 2.0015750750324668) 
        &quot;&quot;&quot;</span>
        <span class="s1">method = kwds.get(</span><span class="s3">'method'</span><span class="s2">, </span><span class="s3">&quot;mle&quot;</span><span class="s1">).lower()</span>

        <span class="s1">censored = isinstance(data</span><span class="s2">, </span><span class="s1">CensoredData)</span>
        <span class="s2">if </span><span class="s1">censored:</span>
            <span class="s2">if </span><span class="s1">method != </span><span class="s3">'mle'</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'For censored data, the method must'</span>
                                 <span class="s3">' be &quot;MLE&quot;.'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">data.num_censored() == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s0"># There are no censored values in data, so replace the</span>
                <span class="s0"># CensoredData instance with a regular array.</span>
                <span class="s1">data = data._uncensored</span>
                <span class="s1">censored = </span><span class="s2">False</span>

        <span class="s1">Narg = len(args)</span>
        <span class="s2">if </span><span class="s1">Narg &gt; self.numargs:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Too many input arguments.&quot;</span><span class="s1">)</span>

        <span class="s0"># Check the finiteness of data only if data is not an instance of</span>
        <span class="s0"># CensoredData.  The arrays in a CensoredData instance have already</span>
        <span class="s0"># been validated.</span>
        <span class="s2">if not </span><span class="s1">censored:</span>
            <span class="s0"># Note: `ravel()` is called for backwards compatibility.</span>
            <span class="s1">data = np.asarray(data).ravel()</span>
            <span class="s2">if not </span><span class="s1">np.isfinite(data).all():</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;The data contains non-finite values.&quot;</span><span class="s1">)</span>

        <span class="s1">start = [</span><span class="s2">None</span><span class="s1">]*</span><span class="s4">2</span>
        <span class="s2">if </span><span class="s1">(Narg &lt; self.numargs) </span><span class="s2">or not </span><span class="s1">(</span><span class="s3">'loc' </span><span class="s2">in </span><span class="s1">kwds </span><span class="s2">and</span>
                                         <span class="s3">'scale' </span><span class="s2">in </span><span class="s1">kwds):</span>
            <span class="s0"># get distribution specific starting locations</span>
            <span class="s1">start = self._fitstart(data)</span>
            <span class="s1">args += start[Narg:-</span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">loc = kwds.pop(</span><span class="s3">'loc'</span><span class="s2">, </span><span class="s1">start[-</span><span class="s4">2</span><span class="s1">])</span>
        <span class="s1">scale = kwds.pop(</span><span class="s3">'scale'</span><span class="s2">, </span><span class="s1">start[-</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">args += (loc</span><span class="s2">, </span><span class="s1">scale)</span>
        <span class="s1">x0</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">restore</span><span class="s2">, </span><span class="s1">args = self._reduce_func(args</span><span class="s2">, </span><span class="s1">kwds</span><span class="s2">, </span><span class="s1">data=data)</span>
        <span class="s1">optimizer = kwds.pop(</span><span class="s3">'optimizer'</span><span class="s2">, </span><span class="s1">optimize.fmin)</span>
        <span class="s0"># convert string to function in scipy.optimize</span>
        <span class="s1">optimizer = _fit_determine_optimizer(optimizer)</span>
        <span class="s0"># by now kwds must be empty, since everybody took what they needed</span>
        <span class="s2">if </span><span class="s1">kwds:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Unknown arguments: %s.&quot; </span><span class="s1">% kwds)</span>

        <span class="s0"># In some cases, method of moments can be done with fsolve/root</span>
        <span class="s0"># instead of an optimizer, but sometimes no solution exists,</span>
        <span class="s0"># especially when the user fixes parameters. Minimizing the sum</span>
        <span class="s0"># of squares of the error generalizes to these cases.</span>
        <span class="s1">vals = optimizer(func</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">args=(data</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">obj = func(vals</span><span class="s2">, </span><span class="s1">data)</span>

        <span class="s2">if </span><span class="s1">restore </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">vals = restore(args</span><span class="s2">, </span><span class="s1">vals)</span>
        <span class="s1">vals = tuple(vals)</span>

        <span class="s1">loc</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">shapes = self._unpack_loc_scale(vals)</span>
        <span class="s2">if not </span><span class="s1">(np.all(self._argcheck(*shapes)) </span><span class="s2">and </span><span class="s1">scale &gt; </span><span class="s4">0</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">FitError(</span><span class="s3">&quot;Optimization converged to parameters that are &quot;</span>
                           <span class="s3">&quot;outside the range allowed by the distribution.&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">method == </span><span class="s3">'mm'</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">np.isfinite(obj):</span>
                <span class="s2">raise </span><span class="s1">FitError(</span><span class="s3">&quot;Optimization failed: either a data moment &quot;</span>
                               <span class="s3">&quot;or fitted distribution moment is &quot;</span>
                               <span class="s3">&quot;non-finite.&quot;</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">vals</span>

    <span class="s2">def </span><span class="s1">_fit_loc_scale_support(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s5">&quot;&quot;&quot;Estimate loc and scale parameters from data accounting for support. 
 
        Parameters 
        ---------- 
        data : array_like 
            Data to fit. 
        arg1, arg2, arg3,... : array_like 
            The shape parameter(s) for the distribution (see docstring of the 
            instance object for more information). 
 
        Returns 
        ------- 
        Lhat : float 
            Estimated location parameter for the data. 
        Shat : float 
            Estimated scale parameter for the data. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(data</span><span class="s2">, </span><span class="s1">CensoredData):</span>
            <span class="s0"># For this estimate, &quot;uncensor&quot; the data by taking the</span>
            <span class="s0"># given endpoints as the data for the left- or right-censored</span>
            <span class="s0"># data, and the mean for the interval-censored data.</span>
            <span class="s1">data = data._uncensor()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">data = np.asarray(data)</span>

        <span class="s0"># Estimate location and scale according to the method of moments.</span>
        <span class="s1">loc_hat</span><span class="s2">, </span><span class="s1">scale_hat = self.fit_loc_scale(data</span><span class="s2">, </span><span class="s1">*args)</span>

        <span class="s0"># Compute the support according to the shape parameters.</span>
        <span class="s1">self._argcheck(*args)</span>
        <span class="s1">_a</span><span class="s2">, </span><span class="s1">_b = self._get_support(*args)</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">b = _a</span><span class="s2">, </span><span class="s1">_b</span>
        <span class="s1">support_width = b - a</span>

        <span class="s0"># If the support is empty then return the moment-based estimates.</span>
        <span class="s2">if </span><span class="s1">support_width &lt;= </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">loc_hat</span><span class="s2">, </span><span class="s1">scale_hat</span>

        <span class="s0"># Compute the proposed support according to the loc and scale</span>
        <span class="s0"># estimates.</span>
        <span class="s1">a_hat = loc_hat + a * scale_hat</span>
        <span class="s1">b_hat = loc_hat + b * scale_hat</span>

        <span class="s0"># Use the moment-based estimates if they are compatible with the data.</span>
        <span class="s1">data_a = np.min(data)</span>
        <span class="s1">data_b = np.max(data)</span>
        <span class="s2">if </span><span class="s1">a_hat &lt; data_a </span><span class="s2">and </span><span class="s1">data_b &lt; b_hat:</span>
            <span class="s2">return </span><span class="s1">loc_hat</span><span class="s2">, </span><span class="s1">scale_hat</span>

        <span class="s0"># Otherwise find other estimates that are compatible with the data.</span>
        <span class="s1">data_width = data_b - data_a</span>
        <span class="s1">rel_margin = </span><span class="s4">0.1</span>
        <span class="s1">margin = data_width * rel_margin</span>

        <span class="s0"># For a finite interval, both the location and scale</span>
        <span class="s0"># should have interesting values.</span>
        <span class="s2">if </span><span class="s1">support_width &lt; np.inf:</span>
            <span class="s1">loc_hat = (data_a - a) - margin</span>
            <span class="s1">scale_hat = (data_width + </span><span class="s4">2 </span><span class="s1">* margin) / support_width</span>
            <span class="s2">return </span><span class="s1">loc_hat</span><span class="s2">, </span><span class="s1">scale_hat</span>

        <span class="s0"># For a one-sided interval, use only an interesting location parameter.</span>
        <span class="s2">if </span><span class="s1">a &gt; -np.inf:</span>
            <span class="s2">return </span><span class="s1">(data_a - a) - margin</span><span class="s2">, </span><span class="s4">1</span>
        <span class="s2">elif </span><span class="s1">b &lt; np.inf:</span>
            <span class="s2">return </span><span class="s1">(data_b - b) + margin</span><span class="s2">, </span><span class="s4">1</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError</span>

    <span class="s2">def </span><span class="s1">fit_loc_scale(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s5">&quot;&quot;&quot; 
        Estimate loc and scale parameters from data using 1st and 2nd moments. 
 
        Parameters 
        ---------- 
        data : array_like 
            Data to fit. 
        arg1, arg2, arg3,... : array_like 
            The shape parameter(s) for the distribution (see docstring of the 
            instance object for more information). 
 
        Returns 
        ------- 
        Lhat : float 
            Estimated location parameter for the data. 
        Shat : float 
            Estimated scale parameter for the data. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">mu</span><span class="s2">, </span><span class="s1">mu2 = self.stats(*args</span><span class="s2">, </span><span class="s1">**{</span><span class="s3">'moments'</span><span class="s1">: </span><span class="s3">'mv'</span><span class="s1">})</span>
        <span class="s1">tmp = asarray(data)</span>
        <span class="s1">muhat = tmp.mean()</span>
        <span class="s1">mu2hat = tmp.var()</span>
        <span class="s1">Shat = sqrt(mu2hat / mu2)</span>
        <span class="s2">with </span><span class="s1">np.errstate(invalid=</span><span class="s3">'ignore'</span><span class="s1">):</span>
            <span class="s1">Lhat = muhat - Shat*mu</span>
        <span class="s2">if not </span><span class="s1">np.isfinite(Lhat):</span>
            <span class="s1">Lhat = </span><span class="s4">0</span>
        <span class="s2">if not </span><span class="s1">(np.isfinite(Shat) </span><span class="s2">and </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">&lt; Shat)):</span>
            <span class="s1">Shat = </span><span class="s4">1</span>
        <span class="s2">return </span><span class="s1">Lhat</span><span class="s2">, </span><span class="s1">Shat</span>

    <span class="s2">def </span><span class="s1">_entropy(self</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s2">def </span><span class="s1">integ(x):</span>
            <span class="s1">val = self._pdf(x</span><span class="s2">, </span><span class="s1">*args)</span>
            <span class="s2">return </span><span class="s1">entr(val)</span>

        <span class="s0"># upper limit is often inf, so suppress warnings when integrating</span>
        <span class="s1">_a</span><span class="s2">, </span><span class="s1">_b = self._get_support(*args)</span>
        <span class="s2">with </span><span class="s1">np.errstate(over=</span><span class="s3">'ignore'</span><span class="s1">):</span>
            <span class="s1">h = integrate.quad(integ</span><span class="s2">, </span><span class="s1">_a</span><span class="s2">, </span><span class="s1">_b)[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s2">if not </span><span class="s1">np.isnan(h):</span>
            <span class="s2">return </span><span class="s1">h</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># try with different limits if integration problems</span>
            <span class="s1">low</span><span class="s2">, </span><span class="s1">upp = self.ppf([</span><span class="s4">1e-10</span><span class="s2">, </span><span class="s4">1. </span><span class="s1">- </span><span class="s4">1e-10</span><span class="s1">]</span><span class="s2">, </span><span class="s1">*args)</span>
            <span class="s2">if </span><span class="s1">np.isinf(_b):</span>
                <span class="s1">upper = upp</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">upper = _b</span>
            <span class="s2">if </span><span class="s1">np.isinf(_a):</span>
                <span class="s1">lower = low</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">lower = _a</span>
            <span class="s2">return </span><span class="s1">integrate.quad(integ</span><span class="s2">, </span><span class="s1">lower</span><span class="s2">, </span><span class="s1">upper)[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">expect(self</span><span class="s2">, </span><span class="s1">func=</span><span class="s2">None, </span><span class="s1">args=()</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">lb=</span><span class="s2">None, </span><span class="s1">ub=</span><span class="s2">None,</span>
               <span class="s1">conditional=</span><span class="s2">False, </span><span class="s1">**kwds):</span>
        <span class="s5">&quot;&quot;&quot;Calculate expected value of a function with respect to the 
        distribution by numerical integration. 
 
        The expected value of a function ``f(x)`` with respect to a 
        distribution ``dist`` is defined as:: 
 
                    ub 
            E[f(x)] = Integral(f(x) * dist.pdf(x)), 
                    lb 
 
        where ``ub`` and ``lb`` are arguments and ``x`` has the ``dist.pdf(x)`` 
        distribution. If the bounds ``lb`` and ``ub`` correspond to the 
        support of the distribution, e.g. ``[-inf, inf]`` in the default 
        case, then the integral is the unrestricted expectation of ``f(x)``. 
        Also, the function ``f(x)`` may be defined such that ``f(x)`` is ``0`` 
        outside a finite interval in which case the expectation is 
        calculated within the finite range ``[lb, ub]``. 
 
        Parameters 
        ---------- 
        func : callable, optional 
            Function for which integral is calculated. Takes only one argument. 
            The default is the identity mapping f(x) = x. 
        args : tuple, optional 
            Shape parameters of the distribution. 
        loc : float, optional 
            Location parameter (default=0). 
        scale : float, optional 
            Scale parameter (default=1). 
        lb, ub : scalar, optional 
            Lower and upper bound for integration. Default is set to the 
            support of the distribution. 
        conditional : bool, optional 
            If True, the integral is corrected by the conditional probability 
            of the integration interval.  The return value is the expectation 
            of the function, conditional on being in the given interval. 
            Default is False. 
 
        Additional keyword arguments are passed to the integration routine. 
 
        Returns 
        ------- 
        expect : float 
            The calculated expected value. 
 
        Notes 
        ----- 
        The integration behavior of this function is inherited from 
        `scipy.integrate.quad`. Neither this function nor 
        `scipy.integrate.quad` can verify whether the integral exists or is 
        finite. For example ``cauchy(0).mean()`` returns ``np.nan`` and 
        ``cauchy(0).expect()`` returns ``0.0``. 
 
        Likewise, the accuracy of results is not verified by the function. 
        `scipy.integrate.quad` is typically reliable for integrals that are 
        numerically favorable, but it is not guaranteed to converge 
        to a correct value for all possible intervals and integrands. This 
        function is provided for convenience; for critical applications, 
        check results against other integration methods. 
 
        The function is not vectorized. 
 
        Examples 
        -------- 
 
        To understand the effect of the bounds of integration consider 
 
        &gt;&gt;&gt; from scipy.stats import expon 
        &gt;&gt;&gt; expon(1).expect(lambda x: 1, lb=0.0, ub=2.0) 
        0.6321205588285578 
 
        This is close to 
 
        &gt;&gt;&gt; expon(1).cdf(2.0) - expon(1).cdf(0.0) 
        0.6321205588285577 
 
        If ``conditional=True`` 
 
        &gt;&gt;&gt; expon(1).expect(lambda x: 1, lb=0.0, ub=2.0, conditional=True) 
        1.0000000000000002 
 
        The slight deviation from 1 is due to numerical integration. 
 
        The integrand can be treated as a complex-valued function 
        by passing ``complex_func=True`` to `scipy.integrate.quad` . 
 
        &gt;&gt;&gt; import numpy as np 
        &gt;&gt;&gt; from scipy.stats import vonmises 
        &gt;&gt;&gt; res = vonmises(loc=2, kappa=1).expect(lambda x: np.exp(1j*x), 
        ...                                       complex_func=True) 
        &gt;&gt;&gt; res 
        (-0.18576377217422957+0.40590124735052263j) 
 
        &gt;&gt;&gt; np.angle(res)  # location of the (circular) distribution 
        2.0 
 
        &quot;&quot;&quot;</span>
        <span class="s1">lockwds = {</span><span class="s3">'loc'</span><span class="s1">: loc</span><span class="s2">,</span>
                   <span class="s3">'scale'</span><span class="s1">: scale}</span>
        <span class="s1">self._argcheck(*args)</span>
        <span class="s1">_a</span><span class="s2">, </span><span class="s1">_b = self._get_support(*args)</span>
        <span class="s2">if </span><span class="s1">func </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">def </span><span class="s1">fun(x</span><span class="s2">, </span><span class="s1">*args):</span>
                <span class="s2">return </span><span class="s1">x * self.pdf(x</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**lockwds)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">def </span><span class="s1">fun(x</span><span class="s2">, </span><span class="s1">*args):</span>
                <span class="s2">return </span><span class="s1">func(x) * self.pdf(x</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**lockwds)</span>
        <span class="s2">if </span><span class="s1">lb </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">lb = loc + _a * scale</span>
        <span class="s2">if </span><span class="s1">ub </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">ub = loc + _b * scale</span>

        <span class="s1">cdf_bounds = self.cdf([lb</span><span class="s2">, </span><span class="s1">ub]</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**lockwds)</span>
        <span class="s1">invfac = cdf_bounds[</span><span class="s4">1</span><span class="s1">] - cdf_bounds[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s1">kwds[</span><span class="s3">'args'</span><span class="s1">] = args</span>

        <span class="s0"># split interval to help integrator w/ infinite support; see gh-8928</span>
        <span class="s1">alpha = </span><span class="s4">0.05  </span><span class="s0"># split body from tails at probability mass `alpha`</span>
        <span class="s1">inner_bounds = np.array([alpha</span><span class="s2">, </span><span class="s4">1</span><span class="s1">-alpha])</span>
        <span class="s1">cdf_inner_bounds = cdf_bounds[</span><span class="s4">0</span><span class="s1">] + invfac * inner_bounds</span>
        <span class="s1">c</span><span class="s2">, </span><span class="s1">d = loc + self._ppf(cdf_inner_bounds</span><span class="s2">, </span><span class="s1">*args) * scale</span>

        <span class="s0"># Do not silence warnings from integration.</span>
        <span class="s1">lbc = integrate.quad(fun</span><span class="s2">, </span><span class="s1">lb</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">**kwds)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">cd = integrate.quad(fun</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">**kwds)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">dub = integrate.quad(fun</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">ub</span><span class="s2">, </span><span class="s1">**kwds)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">vals = (lbc + cd + dub)</span>

        <span class="s2">if </span><span class="s1">conditional:</span>
            <span class="s1">vals /= invfac</span>
        <span class="s2">return </span><span class="s1">np.array(vals)[()]  </span><span class="s0"># make it a numpy scalar like other methods</span>

    <span class="s2">def </span><span class="s1">_param_info(self):</span>
        <span class="s1">shape_info = self._shape_info()</span>
        <span class="s1">loc_info = _ShapeInfo(</span><span class="s3">&quot;loc&quot;</span><span class="s2">, False, </span><span class="s1">(-np.inf</span><span class="s2">, </span><span class="s1">np.inf)</span><span class="s2">, </span><span class="s1">(</span><span class="s2">False, False</span><span class="s1">))</span>
        <span class="s1">scale_info = _ShapeInfo(</span><span class="s3">&quot;scale&quot;</span><span class="s2">, False, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">np.inf)</span><span class="s2">, </span><span class="s1">(</span><span class="s2">False, False</span><span class="s1">))</span>
        <span class="s1">param_info = shape_info + [loc_info</span><span class="s2">, </span><span class="s1">scale_info]</span>
        <span class="s2">return </span><span class="s1">param_info</span>

    <span class="s0"># For now, _delta_cdf is a private method.</span>
    <span class="s2">def </span><span class="s1">_delta_cdf(self</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Compute CDF(x2) - CDF(x1). 
 
        Where x1 is greater than the median, compute SF(x1) - SF(x2), 
        otherwise compute CDF(x2) - CDF(x1). 
 
        This function is only useful if `dist.sf(x, ...)` has an implementation 
        that is numerically more accurate than `1 - dist.cdf(x, ...)`. 
        &quot;&quot;&quot;</span>
        <span class="s1">cdf1 = self.cdf(x1</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">loc=loc</span><span class="s2">, </span><span class="s1">scale=scale)</span>
        <span class="s0"># Possible optimizations (needs investigation-these might not be</span>
        <span class="s0"># better):</span>
        <span class="s0"># * Use _lazywhere instead of np.where</span>
        <span class="s0"># * Instead of cdf1 &gt; 0.5, compare x1 to the median.</span>
        <span class="s1">result = np.where(cdf1 &gt; </span><span class="s4">0.5</span><span class="s2">,</span>
                          <span class="s1">(self.sf(x1</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">loc=loc</span><span class="s2">, </span><span class="s1">scale=scale)</span>
                           <span class="s1">- self.sf(x2</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">loc=loc</span><span class="s2">, </span><span class="s1">scale=scale))</span><span class="s2">,</span>
                          <span class="s1">self.cdf(x2</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">loc=loc</span><span class="s2">, </span><span class="s1">scale=scale) - cdf1)</span>
        <span class="s2">if </span><span class="s1">result.ndim == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">result = result[()]</span>
        <span class="s2">return </span><span class="s1">result</span>


<span class="s0"># Helpers for the discrete distributions</span>
<span class="s2">def </span><span class="s1">_drv2_moment(self</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">*args):</span>
    <span class="s5">&quot;&quot;&quot;Non-central moment of discrete distribution.&quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">fun(x):</span>
        <span class="s2">return </span><span class="s1">np.power(x</span><span class="s2">, </span><span class="s1">n) * self._pmf(x</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s1">_a</span><span class="s2">, </span><span class="s1">_b = self._get_support(*args)</span>
    <span class="s2">return </span><span class="s1">_expect(fun</span><span class="s2">, </span><span class="s1">_a</span><span class="s2">, </span><span class="s1">_b</span><span class="s2">, </span><span class="s1">self.ppf(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">*args)</span><span class="s2">, </span><span class="s1">self.inc)</span>


<span class="s2">def </span><span class="s1">_drv2_ppfsingle(self</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">*args):  </span><span class="s0"># Use basic bisection algorithm</span>
    <span class="s1">_a</span><span class="s2">, </span><span class="s1">_b = self._get_support(*args)</span>
    <span class="s1">b = _b</span>
    <span class="s1">a = _a</span>
    <span class="s2">if </span><span class="s1">isinf(b):            </span><span class="s0"># Be sure ending point is &gt; q</span>
        <span class="s1">b = int(max(</span><span class="s4">100</span><span class="s1">*q</span><span class="s2">, </span><span class="s4">10</span><span class="s1">))</span>
        <span class="s2">while </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">b &gt;= _b:</span>
                <span class="s1">qb = </span><span class="s4">1.0</span>
                <span class="s2">break</span>
            <span class="s1">qb = self._cdf(b</span><span class="s2">, </span><span class="s1">*args)</span>
            <span class="s2">if </span><span class="s1">(qb &lt; q):</span>
                <span class="s1">b += </span><span class="s4">10</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">break</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">qb = </span><span class="s4">1.0</span>
    <span class="s2">if </span><span class="s1">isinf(a):    </span><span class="s0"># be sure starting point &lt; q</span>
        <span class="s1">a = int(min(-</span><span class="s4">100</span><span class="s1">*q</span><span class="s2">, </span><span class="s1">-</span><span class="s4">10</span><span class="s1">))</span>
        <span class="s2">while </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">a &lt;= _a:</span>
                <span class="s1">qb = </span><span class="s4">0.0</span>
                <span class="s2">break</span>
            <span class="s1">qa = self._cdf(a</span><span class="s2">, </span><span class="s1">*args)</span>
            <span class="s2">if </span><span class="s1">(qa &gt; q):</span>
                <span class="s1">a -= </span><span class="s4">10</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">break</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">qa = self._cdf(a</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s2">while </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">(qa == q):</span>
            <span class="s2">return </span><span class="s1">a</span>
        <span class="s2">if </span><span class="s1">(qb == q):</span>
            <span class="s2">return </span><span class="s1">b</span>
        <span class="s2">if </span><span class="s1">b &lt;= a+</span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">qa &gt; q:</span>
                <span class="s2">return </span><span class="s1">a</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">b</span>
        <span class="s1">c = int((a+b)/</span><span class="s4">2.0</span><span class="s1">)</span>
        <span class="s1">qc = self._cdf(c</span><span class="s2">, </span><span class="s1">*args)</span>
        <span class="s2">if </span><span class="s1">(qc &lt; q):</span>
            <span class="s2">if </span><span class="s1">a != c:</span>
                <span class="s1">a = c</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">'updating stopped, endless loop'</span><span class="s1">)</span>
            <span class="s1">qa = qc</span>
        <span class="s2">elif </span><span class="s1">(qc &gt; q):</span>
            <span class="s2">if </span><span class="s1">b != c:</span>
                <span class="s1">b = c</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">'updating stopped, endless loop'</span><span class="s1">)</span>
            <span class="s1">qb = qc</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">c</span>


<span class="s0"># Must over-ride one of _pmf or _cdf or pass in</span>
<span class="s0">#  x_k, p(x_k) lists in initialization</span>


<span class="s2">class </span><span class="s1">rv_discrete(rv_generic):</span>
    <span class="s5">&quot;&quot;&quot;A generic discrete random variable class meant for subclassing. 
 
    `rv_discrete` is a base class to construct specific distribution classes 
    and instances for discrete random variables. It can also be used 
    to construct an arbitrary distribution defined by a list of support 
    points and corresponding probabilities. 
 
    Parameters 
    ---------- 
    a : float, optional 
        Lower bound of the support of the distribution, default: 0 
    b : float, optional 
        Upper bound of the support of the distribution, default: plus infinity 
    moment_tol : float, optional 
        The tolerance for the generic calculation of moments. 
    values : tuple of two array_like, optional 
        ``(xk, pk)`` where ``xk`` are integers and ``pk`` are the non-zero 
        probabilities between 0 and 1 with ``sum(pk) = 1``. ``xk`` 
        and ``pk`` must have the same shape. 
    inc : integer, optional 
        Increment for the support of the distribution. 
        Default is 1. (other values have not been tested) 
    badvalue : float, optional 
        The value in a result arrays that indicates a value that for which 
        some argument restriction is violated, default is np.nan. 
    name : str, optional 
        The name of the instance. This string is used to construct the default 
        example for distributions. 
    longname : str, optional 
        This string is used as part of the first line of the docstring returned 
        when a subclass has no docstring of its own. Note: `longname` exists 
        for backwards compatibility, do not use for new subclasses. 
    shapes : str, optional 
        The shape of the distribution. For example &quot;m, n&quot; for a distribution 
        that takes two integers as the two shape arguments for all its methods 
        If not provided, shape parameters will be inferred from 
        the signatures of the private methods, ``_pmf`` and ``_cdf`` of 
        the instance. 
    seed : {None, int, `numpy.random.Generator`, `numpy.random.RandomState`}, optional 
        If `seed` is None (or `np.random`), the `numpy.random.RandomState` 
        singleton is used. 
        If `seed` is an int, a new ``RandomState`` instance is used, 
        seeded with `seed`. 
        If `seed` is already a ``Generator`` or ``RandomState`` instance then 
        that instance is used. 
 
    Methods 
    ------- 
    rvs 
    pmf 
    logpmf 
    cdf 
    logcdf 
    sf 
    logsf 
    ppf 
    isf 
    moment 
    stats 
    entropy 
    expect 
    median 
    mean 
    std 
    var 
    interval 
    __call__ 
    support 
 
    Notes 
    ----- 
    This class is similar to `rv_continuous`. Whether a shape parameter is 
    valid is decided by an ``_argcheck`` method (which defaults to checking 
    that its arguments are strictly positive.) 
    The main differences are: 
 
    - the support of the distribution is a set of integers 
    - instead of the probability density function, ``pdf`` (and the 
      corresponding private ``_pdf``), this class defines the 
      *probability mass function*, `pmf` (and the corresponding 
      private ``_pmf``.) 
    - scale parameter is not defined. 
 
    To create a new discrete distribution, we would do the following: 
 
    &gt;&gt;&gt; from scipy.stats import rv_discrete 
    &gt;&gt;&gt; class poisson_gen(rv_discrete): 
    ...     &quot;Poisson distribution&quot; 
    ...     def _pmf(self, k, mu): 
    ...         return exp(-mu) * mu**k / factorial(k) 
 
    and create an instance:: 
 
    &gt;&gt;&gt; poisson = poisson_gen(name=&quot;poisson&quot;) 
 
    Note that above we defined the Poisson distribution in the standard form. 
    Shifting the distribution can be done by providing the ``loc`` parameter 
    to the methods of the instance. For example, ``poisson.pmf(x, mu, loc)`` 
    delegates the work to ``poisson._pmf(x-loc, mu)``. 
 
    **Discrete distributions from a list of probabilities** 
 
    Alternatively, you can construct an arbitrary discrete rv defined 
    on a finite set of values ``xk`` with ``Prob{X=xk} = pk`` by using the 
    ``values`` keyword argument to the `rv_discrete` constructor. 
 
    **Deepcopying / Pickling** 
 
    If a distribution or frozen distribution is deepcopied (pickled/unpickled, 
    etc.), any underlying random number generator is deepcopied with it. An 
    implication is that if a distribution relies on the singleton RandomState 
    before copying, it will rely on a copy of that random state after copying, 
    and ``np.random.seed`` will no longer control the state. 
 
    Examples 
    -------- 
    Custom made discrete distribution: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; xk = np.arange(7) 
    &gt;&gt;&gt; pk = (0.1, 0.2, 0.3, 0.1, 0.1, 0.0, 0.2) 
    &gt;&gt;&gt; custm = stats.rv_discrete(name='custm', values=(xk, pk)) 
    &gt;&gt;&gt; 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig, ax = plt.subplots(1, 1) 
    &gt;&gt;&gt; ax.plot(xk, custm.pmf(xk), 'ro', ms=12, mec='r') 
    &gt;&gt;&gt; ax.vlines(xk, 0, custm.pmf(xk), colors='r', lw=4) 
    &gt;&gt;&gt; plt.show() 
 
    Random number generation: 
 
    &gt;&gt;&gt; R = custm.rvs(size=100) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__new__(cls</span><span class="s2">, </span><span class="s1">a=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">b=inf</span><span class="s2">, </span><span class="s1">name=</span><span class="s2">None, </span><span class="s1">badvalue=</span><span class="s2">None,</span>
                <span class="s1">moment_tol=</span><span class="s4">1e-8</span><span class="s2">, </span><span class="s1">values=</span><span class="s2">None, </span><span class="s1">inc=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">longname=</span><span class="s2">None,</span>
                <span class="s1">shapes=</span><span class="s2">None, </span><span class="s1">seed=</span><span class="s2">None</span><span class="s1">):</span>

        <span class="s2">if </span><span class="s1">values </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s0"># dispatch to a subclass</span>
            <span class="s2">return </span><span class="s1">super().__new__(rv_sample)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># business as usual</span>
            <span class="s2">return </span><span class="s1">super().__new__(cls)</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">a=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">b=inf</span><span class="s2">, </span><span class="s1">name=</span><span class="s2">None, </span><span class="s1">badvalue=</span><span class="s2">None,</span>
                 <span class="s1">moment_tol=</span><span class="s4">1e-8</span><span class="s2">, </span><span class="s1">values=</span><span class="s2">None, </span><span class="s1">inc=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">longname=</span><span class="s2">None,</span>
                 <span class="s1">shapes=</span><span class="s2">None, </span><span class="s1">seed=</span><span class="s2">None</span><span class="s1">):</span>

        <span class="s1">super().__init__(seed)</span>

        <span class="s0"># cf generic freeze</span>
        <span class="s1">self._ctor_param = dict(</span>
            <span class="s1">a=a</span><span class="s2">, </span><span class="s1">b=b</span><span class="s2">, </span><span class="s1">name=name</span><span class="s2">, </span><span class="s1">badvalue=badvalue</span><span class="s2">,</span>
            <span class="s1">moment_tol=moment_tol</span><span class="s2">, </span><span class="s1">values=values</span><span class="s2">, </span><span class="s1">inc=inc</span><span class="s2">,</span>
            <span class="s1">longname=longname</span><span class="s2">, </span><span class="s1">shapes=shapes</span><span class="s2">, </span><span class="s1">seed=seed)</span>

        <span class="s2">if </span><span class="s1">badvalue </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">badvalue = nan</span>
        <span class="s1">self.badvalue = badvalue</span>
        <span class="s1">self.a = a</span>
        <span class="s1">self.b = b</span>
        <span class="s1">self.moment_tol = moment_tol</span>
        <span class="s1">self.inc = inc</span>
        <span class="s1">self.shapes = shapes</span>

        <span class="s2">if </span><span class="s1">values </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;rv_discrete.__init__(..., values != None, ...)&quot;</span><span class="s1">)</span>

        <span class="s1">self._construct_argparser(meths_to_inspect=[self._pmf</span><span class="s2">, </span><span class="s1">self._cdf]</span><span class="s2">,</span>
                                  <span class="s1">locscale_in=</span><span class="s3">'loc=0'</span><span class="s2">,</span>
                                  <span class="s0"># scale=1 for discrete RVs</span>
                                  <span class="s1">locscale_out=</span><span class="s3">'loc, 1'</span><span class="s1">)</span>
        <span class="s1">self._attach_methods()</span>
        <span class="s1">self._construct_docstrings(name</span><span class="s2">, </span><span class="s1">longname)</span>

    <span class="s2">def </span><span class="s1">__getstate__(self):</span>
        <span class="s1">dct = self.__dict__.copy()</span>
        <span class="s0"># these methods will be remade in __setstate__</span>
        <span class="s1">attrs = [</span><span class="s3">&quot;_parse_args&quot;</span><span class="s2">, </span><span class="s3">&quot;_parse_args_stats&quot;</span><span class="s2">, </span><span class="s3">&quot;_parse_args_rvs&quot;</span><span class="s2">,</span>
                 <span class="s3">&quot;_cdfvec&quot;</span><span class="s2">, </span><span class="s3">&quot;_ppfvec&quot;</span><span class="s2">, </span><span class="s3">&quot;generic_moment&quot;</span><span class="s1">]</span>
        <span class="s1">[dct.pop(attr</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">attrs]</span>
        <span class="s2">return </span><span class="s1">dct</span>

    <span class="s2">def </span><span class="s1">_attach_methods(self):</span>
        <span class="s5">&quot;&quot;&quot;Attaches dynamically created methods to the rv_discrete instance.&quot;&quot;&quot;</span>
        <span class="s1">self._cdfvec = vectorize(self._cdf_single</span><span class="s2">, </span><span class="s1">otypes=</span><span class="s3">'d'</span><span class="s1">)</span>
        <span class="s1">self.vecentropy = vectorize(self._entropy)</span>

        <span class="s0"># _attach_methods is responsible for calling _attach_argparser_methods</span>
        <span class="s1">self._attach_argparser_methods()</span>

        <span class="s0"># nin correction needs to be after we know numargs</span>
        <span class="s0"># correct nin for generic moment vectorization</span>
        <span class="s1">_vec_generic_moment = vectorize(_drv2_moment</span><span class="s2">, </span><span class="s1">otypes=</span><span class="s3">'d'</span><span class="s1">)</span>
        <span class="s1">_vec_generic_moment.nin = self.numargs + </span><span class="s4">2</span>
        <span class="s1">self.generic_moment = types.MethodType(_vec_generic_moment</span><span class="s2">, </span><span class="s1">self)</span>

        <span class="s0"># correct nin for ppf vectorization</span>
        <span class="s1">_vppf = vectorize(_drv2_ppfsingle</span><span class="s2">, </span><span class="s1">otypes=</span><span class="s3">'d'</span><span class="s1">)</span>
        <span class="s1">_vppf.nin = self.numargs + </span><span class="s4">2</span>
        <span class="s1">self._ppfvec = types.MethodType(_vppf</span><span class="s2">, </span><span class="s1">self)</span>

        <span class="s0"># now that self.numargs is defined, we can adjust nin</span>
        <span class="s1">self._cdfvec.nin = self.numargs + </span><span class="s4">1</span>

    <span class="s2">def </span><span class="s1">_construct_docstrings(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">longname):</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">name = </span><span class="s3">'Distribution'</span>
        <span class="s1">self.name = name</span>

        <span class="s0"># generate docstring for subclass instances</span>
        <span class="s2">if </span><span class="s1">longname </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">name[</span><span class="s4">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'aeiouAEIOU'</span><span class="s1">]:</span>
                <span class="s1">hstr = </span><span class="s3">&quot;An &quot;</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">hstr = </span><span class="s3">&quot;A &quot;</span>
            <span class="s1">longname = hstr + name</span>

        <span class="s2">if </span><span class="s1">sys.flags.optimize &lt; </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s0"># Skip adding docstrings if interpreter is run with -OO</span>
            <span class="s2">if </span><span class="s1">self.__doc__ </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">self._construct_default_doc(longname=longname</span><span class="s2">,</span>
                                            <span class="s1">docdict=docdict_discrete</span><span class="s2">,</span>
                                            <span class="s1">discrete=</span><span class="s3">'discrete'</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">dct = dict(distdiscrete)</span>
                <span class="s1">self._construct_doc(docdict_discrete</span><span class="s2">, </span><span class="s1">dct.get(self.name))</span>

            <span class="s0"># discrete RV do not have the scale parameter, remove it</span>
            <span class="s1">self.__doc__ = self.__doc__.replace(</span>
                <span class="s3">'</span><span class="s2">\n    </span><span class="s3">scale : array_like, '</span>
                <span class="s3">'optional</span><span class="s2">\n        </span><span class="s3">scale parameter (default=1)'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_updated_ctor_param(self):</span>
        <span class="s5">&quot;&quot;&quot;Return the current version of _ctor_param, possibly updated by user. 
 
        Used by freezing. 
        Keep this in sync with the signature of __init__. 
        &quot;&quot;&quot;</span>
        <span class="s1">dct = self._ctor_param.copy()</span>
        <span class="s1">dct[</span><span class="s3">'a'</span><span class="s1">] = self.a</span>
        <span class="s1">dct[</span><span class="s3">'b'</span><span class="s1">] = self.b</span>
        <span class="s1">dct[</span><span class="s3">'badvalue'</span><span class="s1">] = self.badvalue</span>
        <span class="s1">dct[</span><span class="s3">'moment_tol'</span><span class="s1">] = self.moment_tol</span>
        <span class="s1">dct[</span><span class="s3">'inc'</span><span class="s1">] = self.inc</span>
        <span class="s1">dct[</span><span class="s3">'name'</span><span class="s1">] = self.name</span>
        <span class="s1">dct[</span><span class="s3">'shapes'</span><span class="s1">] = self.shapes</span>
        <span class="s2">return </span><span class="s1">dct</span>

    <span class="s2">def </span><span class="s1">_nonzero(self</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s2">return </span><span class="s1">floor(k) == k</span>

    <span class="s2">def </span><span class="s1">_pmf(self</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s2">return </span><span class="s1">self._cdf(k</span><span class="s2">, </span><span class="s1">*args) - self._cdf(k-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s2">def </span><span class="s1">_logpmf(self</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s2">return </span><span class="s1">log(self._pmf(k</span><span class="s2">, </span><span class="s1">*args))</span>

    <span class="s2">def </span><span class="s1">_logpxf(self</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s0"># continuous distributions have PDF, discrete have PMF, but sometimes</span>
        <span class="s0"># the distinction doesn't matter. This lets us use `_logpxf` for both</span>
        <span class="s0"># discrete and continuous distributions.</span>
        <span class="s2">return </span><span class="s1">self._logpmf(k</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s2">def </span><span class="s1">_unpack_loc_scale(self</span><span class="s2">, </span><span class="s1">theta):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">loc = theta[-</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">scale = </span><span class="s4">1</span>
            <span class="s1">args = tuple(theta[:-</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s2">except </span><span class="s1">IndexError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Not enough input arguments.&quot;</span><span class="s1">) </span><span class="s2">from </span><span class="s1">e</span>
        <span class="s2">return </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">args</span>

    <span class="s2">def </span><span class="s1">_cdf_single(self</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s1">_a</span><span class="s2">, </span><span class="s1">_b = self._get_support(*args)</span>
        <span class="s1">m = arange(int(_a)</span><span class="s2">, </span><span class="s1">k+</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">np.sum(self._pmf(m</span><span class="s2">, </span><span class="s1">*args)</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_cdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s1">k = floor(x)</span>
        <span class="s2">return </span><span class="s1">self._cdfvec(k</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s0"># generic _logcdf, _sf, _logsf, _ppf, _isf, _rvs defined in rv_generic</span>

    <span class="s2">def </span><span class="s1">rvs(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s5">&quot;&quot;&quot;Random variates of given type. 
 
        Parameters 
        ---------- 
        arg1, arg2, arg3,... : array_like 
            The shape parameter(s) for the distribution (see docstring of the 
            instance object for more information). 
        loc : array_like, optional 
            Location parameter (default=0). 
        size : int or tuple of ints, optional 
            Defining number of random variates (Default is 1). Note that `size` 
            has to be given as keyword, not as positional argument. 
        random_state : {None, int, `numpy.random.Generator`, 
                        `numpy.random.RandomState`}, optional 
 
            If `random_state` is None (or `np.random`), the 
            `numpy.random.RandomState` singleton is used. 
            If `random_state` is an int, a new ``RandomState`` instance is 
            used, seeded with `random_state`. 
            If `random_state` is already a ``Generator`` or ``RandomState`` 
            instance, that instance is used. 
 
        Returns 
        ------- 
        rvs : ndarray or scalar 
            Random variates of given `size`. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">kwargs[</span><span class="s3">'discrete'</span><span class="s1">] = </span><span class="s2">True</span>
        <span class="s2">return </span><span class="s1">super().rvs(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">pmf(self</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s5">&quot;&quot;&quot;Probability mass function at k of the given RV. 
 
        Parameters 
        ---------- 
        k : array_like 
            Quantiles. 
        arg1, arg2, arg3,... : array_like 
            The shape parameter(s) for the distribution (see docstring of the 
            instance object for more information) 
        loc : array_like, optional 
            Location parameter (default=0). 
 
        Returns 
        ------- 
        pmf : array_like 
            Probability mass function evaluated at k 
 
        &quot;&quot;&quot;</span>
        <span class="s1">args</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">_ = self._parse_args(*args</span><span class="s2">, </span><span class="s1">**kwds)</span>
        <span class="s1">k</span><span class="s2">, </span><span class="s1">loc = map(asarray</span><span class="s2">, </span><span class="s1">(k</span><span class="s2">, </span><span class="s1">loc))</span>
        <span class="s1">args = tuple(map(asarray</span><span class="s2">, </span><span class="s1">args))</span>
        <span class="s1">_a</span><span class="s2">, </span><span class="s1">_b = self._get_support(*args)</span>
        <span class="s1">k = asarray(k-loc)</span>
        <span class="s1">cond0 = self._argcheck(*args)</span>
        <span class="s1">cond1 = (k &gt;= _a) &amp; (k &lt;= _b)</span>
        <span class="s2">if not </span><span class="s1">isinstance(self</span><span class="s2">, </span><span class="s1">rv_sample):</span>
            <span class="s1">cond1 = cond1 &amp; self._nonzero(k</span><span class="s2">, </span><span class="s1">*args)</span>
        <span class="s1">cond = cond0 &amp; cond1</span>
        <span class="s1">output = zeros(shape(cond)</span><span class="s2">, </span><span class="s3">'d'</span><span class="s1">)</span>
        <span class="s1">place(output</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s1">-cond0) + np.isnan(k)</span><span class="s2">, </span><span class="s1">self.badvalue)</span>
        <span class="s2">if </span><span class="s1">np.any(cond):</span>
            <span class="s1">goodargs = argsreduce(cond</span><span class="s2">, </span><span class="s1">*((k</span><span class="s2">,</span><span class="s1">)+args))</span>
            <span class="s1">place(output</span><span class="s2">, </span><span class="s1">cond</span><span class="s2">, </span><span class="s1">np.clip(self._pmf(*goodargs)</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">output.ndim == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">output[()]</span>
        <span class="s2">return </span><span class="s1">output</span>

    <span class="s2">def </span><span class="s1">logpmf(self</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s5">&quot;&quot;&quot;Log of the probability mass function at k of the given RV. 
 
        Parameters 
        ---------- 
        k : array_like 
            Quantiles. 
        arg1, arg2, arg3,... : array_like 
            The shape parameter(s) for the distribution (see docstring of the 
            instance object for more information). 
        loc : array_like, optional 
            Location parameter. Default is 0. 
 
        Returns 
        ------- 
        logpmf : array_like 
            Log of the probability mass function evaluated at k. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">args</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">_ = self._parse_args(*args</span><span class="s2">, </span><span class="s1">**kwds)</span>
        <span class="s1">k</span><span class="s2">, </span><span class="s1">loc = map(asarray</span><span class="s2">, </span><span class="s1">(k</span><span class="s2">, </span><span class="s1">loc))</span>
        <span class="s1">args = tuple(map(asarray</span><span class="s2">, </span><span class="s1">args))</span>
        <span class="s1">_a</span><span class="s2">, </span><span class="s1">_b = self._get_support(*args)</span>
        <span class="s1">k = asarray(k-loc)</span>
        <span class="s1">cond0 = self._argcheck(*args)</span>
        <span class="s1">cond1 = (k &gt;= _a) &amp; (k &lt;= _b)</span>
        <span class="s2">if not </span><span class="s1">isinstance(self</span><span class="s2">, </span><span class="s1">rv_sample):</span>
            <span class="s1">cond1 = cond1 &amp; self._nonzero(k</span><span class="s2">, </span><span class="s1">*args)</span>
        <span class="s1">cond = cond0 &amp; cond1</span>
        <span class="s1">output = empty(shape(cond)</span><span class="s2">, </span><span class="s3">'d'</span><span class="s1">)</span>
        <span class="s1">output.fill(NINF)</span>
        <span class="s1">place(output</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s1">-cond0) + np.isnan(k)</span><span class="s2">, </span><span class="s1">self.badvalue)</span>
        <span class="s2">if </span><span class="s1">np.any(cond):</span>
            <span class="s1">goodargs = argsreduce(cond</span><span class="s2">, </span><span class="s1">*((k</span><span class="s2">,</span><span class="s1">)+args))</span>
            <span class="s1">place(output</span><span class="s2">, </span><span class="s1">cond</span><span class="s2">, </span><span class="s1">self._logpmf(*goodargs))</span>
        <span class="s2">if </span><span class="s1">output.ndim == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">output[()]</span>
        <span class="s2">return </span><span class="s1">output</span>

    <span class="s2">def </span><span class="s1">cdf(self</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s5">&quot;&quot;&quot;Cumulative distribution function of the given RV. 
 
        Parameters 
        ---------- 
        k : array_like, int 
            Quantiles. 
        arg1, arg2, arg3,... : array_like 
            The shape parameter(s) for the distribution (see docstring of the 
            instance object for more information). 
        loc : array_like, optional 
            Location parameter (default=0). 
 
        Returns 
        ------- 
        cdf : ndarray 
            Cumulative distribution function evaluated at `k`. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">args</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">_ = self._parse_args(*args</span><span class="s2">, </span><span class="s1">**kwds)</span>
        <span class="s1">k</span><span class="s2">, </span><span class="s1">loc = map(asarray</span><span class="s2">, </span><span class="s1">(k</span><span class="s2">, </span><span class="s1">loc))</span>
        <span class="s1">args = tuple(map(asarray</span><span class="s2">, </span><span class="s1">args))</span>
        <span class="s1">_a</span><span class="s2">, </span><span class="s1">_b = self._get_support(*args)</span>
        <span class="s1">k = asarray(k-loc)</span>
        <span class="s1">cond0 = self._argcheck(*args)</span>
        <span class="s1">cond1 = (k &gt;= _a) &amp; (k &lt; _b)</span>
        <span class="s1">cond2 = (k &gt;= _b)</span>
        <span class="s1">cond3 = np.isneginf(k)</span>
        <span class="s1">cond = cond0 &amp; cond1 &amp; np.isfinite(k)</span>

        <span class="s1">output = zeros(shape(cond)</span><span class="s2">, </span><span class="s3">'d'</span><span class="s1">)</span>
        <span class="s1">place(output</span><span class="s2">, </span><span class="s1">cond2*(cond0 == cond0)</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">)</span>
        <span class="s1">place(output</span><span class="s2">, </span><span class="s1">cond3*(cond0 == cond0)</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>
        <span class="s1">place(output</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s1">-cond0) + np.isnan(k)</span><span class="s2">, </span><span class="s1">self.badvalue)</span>

        <span class="s2">if </span><span class="s1">np.any(cond):</span>
            <span class="s1">goodargs = argsreduce(cond</span><span class="s2">, </span><span class="s1">*((k</span><span class="s2">,</span><span class="s1">)+args))</span>
            <span class="s1">place(output</span><span class="s2">, </span><span class="s1">cond</span><span class="s2">, </span><span class="s1">np.clip(self._cdf(*goodargs)</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">output.ndim == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">output[()]</span>
        <span class="s2">return </span><span class="s1">output</span>

    <span class="s2">def </span><span class="s1">logcdf(self</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s5">&quot;&quot;&quot;Log of the cumulative distribution function at k of the given RV. 
 
        Parameters 
        ---------- 
        k : array_like, int 
            Quantiles. 
        arg1, arg2, arg3,... : array_like 
            The shape parameter(s) for the distribution (see docstring of the 
            instance object for more information). 
        loc : array_like, optional 
            Location parameter (default=0). 
 
        Returns 
        ------- 
        logcdf : array_like 
            Log of the cumulative distribution function evaluated at k. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">args</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">_ = self._parse_args(*args</span><span class="s2">, </span><span class="s1">**kwds)</span>
        <span class="s1">k</span><span class="s2">, </span><span class="s1">loc = map(asarray</span><span class="s2">, </span><span class="s1">(k</span><span class="s2">, </span><span class="s1">loc))</span>
        <span class="s1">args = tuple(map(asarray</span><span class="s2">, </span><span class="s1">args))</span>
        <span class="s1">_a</span><span class="s2">, </span><span class="s1">_b = self._get_support(*args)</span>
        <span class="s1">k = asarray(k-loc)</span>
        <span class="s1">cond0 = self._argcheck(*args)</span>
        <span class="s1">cond1 = (k &gt;= _a) &amp; (k &lt; _b)</span>
        <span class="s1">cond2 = (k &gt;= _b)</span>
        <span class="s1">cond = cond0 &amp; cond1</span>
        <span class="s1">output = empty(shape(cond)</span><span class="s2">, </span><span class="s3">'d'</span><span class="s1">)</span>
        <span class="s1">output.fill(NINF)</span>
        <span class="s1">place(output</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s1">-cond0) + np.isnan(k)</span><span class="s2">, </span><span class="s1">self.badvalue)</span>
        <span class="s1">place(output</span><span class="s2">, </span><span class="s1">cond2*(cond0 == cond0)</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">np.any(cond):</span>
            <span class="s1">goodargs = argsreduce(cond</span><span class="s2">, </span><span class="s1">*((k</span><span class="s2">,</span><span class="s1">)+args))</span>
            <span class="s1">place(output</span><span class="s2">, </span><span class="s1">cond</span><span class="s2">, </span><span class="s1">self._logcdf(*goodargs))</span>
        <span class="s2">if </span><span class="s1">output.ndim == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">output[()]</span>
        <span class="s2">return </span><span class="s1">output</span>

    <span class="s2">def </span><span class="s1">sf(self</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s5">&quot;&quot;&quot;Survival function (1 - `cdf`) at k of the given RV. 
 
        Parameters 
        ---------- 
        k : array_like 
            Quantiles. 
        arg1, arg2, arg3,... : array_like 
            The shape parameter(s) for the distribution (see docstring of the 
            instance object for more information). 
        loc : array_like, optional 
            Location parameter (default=0). 
 
        Returns 
        ------- 
        sf : array_like 
            Survival function evaluated at k. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">args</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">_ = self._parse_args(*args</span><span class="s2">, </span><span class="s1">**kwds)</span>
        <span class="s1">k</span><span class="s2">, </span><span class="s1">loc = map(asarray</span><span class="s2">, </span><span class="s1">(k</span><span class="s2">, </span><span class="s1">loc))</span>
        <span class="s1">args = tuple(map(asarray</span><span class="s2">, </span><span class="s1">args))</span>
        <span class="s1">_a</span><span class="s2">, </span><span class="s1">_b = self._get_support(*args)</span>
        <span class="s1">k = asarray(k-loc)</span>
        <span class="s1">cond0 = self._argcheck(*args)</span>
        <span class="s1">cond1 = (k &gt;= _a) &amp; (k &lt; _b)</span>
        <span class="s1">cond2 = ((k &lt; _a) | np.isneginf(k)) &amp; cond0</span>
        <span class="s1">cond = cond0 &amp; cond1 &amp; np.isfinite(k)</span>
        <span class="s1">output = zeros(shape(cond)</span><span class="s2">, </span><span class="s3">'d'</span><span class="s1">)</span>
        <span class="s1">place(output</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s1">-cond0) + np.isnan(k)</span><span class="s2">, </span><span class="s1">self.badvalue)</span>
        <span class="s1">place(output</span><span class="s2">, </span><span class="s1">cond2</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">np.any(cond):</span>
            <span class="s1">goodargs = argsreduce(cond</span><span class="s2">, </span><span class="s1">*((k</span><span class="s2">,</span><span class="s1">)+args))</span>
            <span class="s1">place(output</span><span class="s2">, </span><span class="s1">cond</span><span class="s2">, </span><span class="s1">np.clip(self._sf(*goodargs)</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">output.ndim == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">output[()]</span>
        <span class="s2">return </span><span class="s1">output</span>

    <span class="s2">def </span><span class="s1">logsf(self</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s5">&quot;&quot;&quot;Log of the survival function of the given RV. 
 
        Returns the log of the &quot;survival function,&quot; defined as 1 - `cdf`, 
        evaluated at `k`. 
 
        Parameters 
        ---------- 
        k : array_like 
            Quantiles. 
        arg1, arg2, arg3,... : array_like 
            The shape parameter(s) for the distribution (see docstring of the 
            instance object for more information). 
        loc : array_like, optional 
            Location parameter (default=0). 
 
        Returns 
        ------- 
        logsf : ndarray 
            Log of the survival function evaluated at `k`. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">args</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">_ = self._parse_args(*args</span><span class="s2">, </span><span class="s1">**kwds)</span>
        <span class="s1">k</span><span class="s2">, </span><span class="s1">loc = map(asarray</span><span class="s2">, </span><span class="s1">(k</span><span class="s2">, </span><span class="s1">loc))</span>
        <span class="s1">args = tuple(map(asarray</span><span class="s2">, </span><span class="s1">args))</span>
        <span class="s1">_a</span><span class="s2">, </span><span class="s1">_b = self._get_support(*args)</span>
        <span class="s1">k = asarray(k-loc)</span>
        <span class="s1">cond0 = self._argcheck(*args)</span>
        <span class="s1">cond1 = (k &gt;= _a) &amp; (k &lt; _b)</span>
        <span class="s1">cond2 = (k &lt; _a) &amp; cond0</span>
        <span class="s1">cond = cond0 &amp; cond1</span>
        <span class="s1">output = empty(shape(cond)</span><span class="s2">, </span><span class="s3">'d'</span><span class="s1">)</span>
        <span class="s1">output.fill(NINF)</span>
        <span class="s1">place(output</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s1">-cond0) + np.isnan(k)</span><span class="s2">, </span><span class="s1">self.badvalue)</span>
        <span class="s1">place(output</span><span class="s2">, </span><span class="s1">cond2</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">np.any(cond):</span>
            <span class="s1">goodargs = argsreduce(cond</span><span class="s2">, </span><span class="s1">*((k</span><span class="s2">,</span><span class="s1">)+args))</span>
            <span class="s1">place(output</span><span class="s2">, </span><span class="s1">cond</span><span class="s2">, </span><span class="s1">self._logsf(*goodargs))</span>
        <span class="s2">if </span><span class="s1">output.ndim == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">output[()]</span>
        <span class="s2">return </span><span class="s1">output</span>

    <span class="s2">def </span><span class="s1">ppf(self</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s5">&quot;&quot;&quot;Percent point function (inverse of `cdf`) at q of the given RV. 
 
        Parameters 
        ---------- 
        q : array_like 
            Lower tail probability. 
        arg1, arg2, arg3,... : array_like 
            The shape parameter(s) for the distribution (see docstring of the 
            instance object for more information). 
        loc : array_like, optional 
            Location parameter (default=0). 
 
        Returns 
        ------- 
        k : array_like 
            Quantile corresponding to the lower tail probability, q. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">args</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">_ = self._parse_args(*args</span><span class="s2">, </span><span class="s1">**kwds)</span>
        <span class="s1">q</span><span class="s2">, </span><span class="s1">loc = map(asarray</span><span class="s2">, </span><span class="s1">(q</span><span class="s2">, </span><span class="s1">loc))</span>
        <span class="s1">args = tuple(map(asarray</span><span class="s2">, </span><span class="s1">args))</span>
        <span class="s1">_a</span><span class="s2">, </span><span class="s1">_b = self._get_support(*args)</span>
        <span class="s1">cond0 = self._argcheck(*args) &amp; (loc == loc)</span>
        <span class="s1">cond1 = (q &gt; </span><span class="s4">0</span><span class="s1">) &amp; (q &lt; </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">cond2 = (q == </span><span class="s4">1</span><span class="s1">) &amp; cond0</span>
        <span class="s1">cond = cond0 &amp; cond1</span>
        <span class="s1">output = np.full(shape(cond)</span><span class="s2">, </span><span class="s1">fill_value=self.badvalue</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">'d'</span><span class="s1">)</span>
        <span class="s0"># output type 'd' to handle nin and inf</span>
        <span class="s1">place(output</span><span class="s2">, </span><span class="s1">(q == </span><span class="s4">0</span><span class="s1">)*(cond == cond)</span><span class="s2">, </span><span class="s1">_a-</span><span class="s4">1 </span><span class="s1">+ loc)</span>
        <span class="s1">place(output</span><span class="s2">, </span><span class="s1">cond2</span><span class="s2">, </span><span class="s1">_b + loc)</span>
        <span class="s2">if </span><span class="s1">np.any(cond):</span>
            <span class="s1">goodargs = argsreduce(cond</span><span class="s2">, </span><span class="s1">*((q</span><span class="s2">,</span><span class="s1">)+args+(loc</span><span class="s2">,</span><span class="s1">)))</span>
            <span class="s1">loc</span><span class="s2">, </span><span class="s1">goodargs = goodargs[-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">goodargs[:-</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">place(output</span><span class="s2">, </span><span class="s1">cond</span><span class="s2">, </span><span class="s1">self._ppf(*goodargs) + loc)</span>

        <span class="s2">if </span><span class="s1">output.ndim == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">output[()]</span>
        <span class="s2">return </span><span class="s1">output</span>

    <span class="s2">def </span><span class="s1">isf(self</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s5">&quot;&quot;&quot;Inverse survival function (inverse of `sf`) at q of the given RV. 
 
        Parameters 
        ---------- 
        q : array_like 
            Upper tail probability. 
        arg1, arg2, arg3,... : array_like 
            The shape parameter(s) for the distribution (see docstring of the 
            instance object for more information). 
        loc : array_like, optional 
            Location parameter (default=0). 
 
        Returns 
        ------- 
        k : ndarray or scalar 
            Quantile corresponding to the upper tail probability, q. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">args</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">_ = self._parse_args(*args</span><span class="s2">, </span><span class="s1">**kwds)</span>
        <span class="s1">q</span><span class="s2">, </span><span class="s1">loc = map(asarray</span><span class="s2">, </span><span class="s1">(q</span><span class="s2">, </span><span class="s1">loc))</span>
        <span class="s1">args = tuple(map(asarray</span><span class="s2">, </span><span class="s1">args))</span>
        <span class="s1">_a</span><span class="s2">, </span><span class="s1">_b = self._get_support(*args)</span>
        <span class="s1">cond0 = self._argcheck(*args) &amp; (loc == loc)</span>
        <span class="s1">cond1 = (q &gt; </span><span class="s4">0</span><span class="s1">) &amp; (q &lt; </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">cond2 = (q == </span><span class="s4">1</span><span class="s1">) &amp; cond0</span>
        <span class="s1">cond3 = (q == </span><span class="s4">0</span><span class="s1">) &amp; cond0</span>
        <span class="s1">cond = cond0 &amp; cond1</span>

        <span class="s0"># same problem as with ppf; copied from ppf and changed</span>
        <span class="s1">output = np.full(shape(cond)</span><span class="s2">, </span><span class="s1">fill_value=self.badvalue</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">'d'</span><span class="s1">)</span>
        <span class="s0"># output type 'd' to handle nin and inf</span>
        <span class="s1">lower_bound = _a - </span><span class="s4">1 </span><span class="s1">+ loc</span>
        <span class="s1">upper_bound = _b + loc</span>
        <span class="s1">place(output</span><span class="s2">, </span><span class="s1">cond2*(cond == cond)</span><span class="s2">, </span><span class="s1">lower_bound)</span>
        <span class="s1">place(output</span><span class="s2">, </span><span class="s1">cond3*(cond == cond)</span><span class="s2">, </span><span class="s1">upper_bound)</span>

        <span class="s0"># call place only if at least 1 valid argument</span>
        <span class="s2">if </span><span class="s1">np.any(cond):</span>
            <span class="s1">goodargs = argsreduce(cond</span><span class="s2">, </span><span class="s1">*((q</span><span class="s2">,</span><span class="s1">)+args+(loc</span><span class="s2">,</span><span class="s1">)))</span>
            <span class="s1">loc</span><span class="s2">, </span><span class="s1">goodargs = goodargs[-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">goodargs[:-</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s0"># PB same as ticket 766</span>
            <span class="s1">place(output</span><span class="s2">, </span><span class="s1">cond</span><span class="s2">, </span><span class="s1">self._isf(*goodargs) + loc)</span>

        <span class="s2">if </span><span class="s1">output.ndim == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">output[()]</span>
        <span class="s2">return </span><span class="s1">output</span>

    <span class="s2">def </span><span class="s1">_entropy(self</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s2">if </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s3">'pk'</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">stats.entropy(self.pk)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">_a</span><span class="s2">, </span><span class="s1">_b = self._get_support(*args)</span>
            <span class="s2">return </span><span class="s1">_expect(</span><span class="s2">lambda </span><span class="s1">x: entr(self.pmf(x</span><span class="s2">, </span><span class="s1">*args))</span><span class="s2">,</span>
                           <span class="s1">_a</span><span class="s2">, </span><span class="s1">_b</span><span class="s2">, </span><span class="s1">self.ppf(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">*args)</span><span class="s2">, </span><span class="s1">self.inc)</span>

    <span class="s2">def </span><span class="s1">expect(self</span><span class="s2">, </span><span class="s1">func=</span><span class="s2">None, </span><span class="s1">args=()</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">lb=</span><span class="s2">None, </span><span class="s1">ub=</span><span class="s2">None,</span>
               <span class="s1">conditional=</span><span class="s2">False, </span><span class="s1">maxcount=</span><span class="s4">1000</span><span class="s2">, </span><span class="s1">tolerance=</span><span class="s4">1e-10</span><span class="s2">, </span><span class="s1">chunksize=</span><span class="s4">32</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Calculate expected value of a function with respect to the distribution 
        for discrete distribution by numerical summation. 
 
        Parameters 
        ---------- 
        func : callable, optional 
            Function for which the expectation value is calculated. 
            Takes only one argument. 
            The default is the identity mapping f(k) = k. 
        args : tuple, optional 
            Shape parameters of the distribution. 
        loc : float, optional 
            Location parameter. 
            Default is 0. 
        lb, ub : int, optional 
            Lower and upper bound for the summation, default is set to the 
            support of the distribution, inclusive (``lb &lt;= k &lt;= ub``). 
        conditional : bool, optional 
            If true then the expectation is corrected by the conditional 
            probability of the summation interval. The return value is the 
            expectation of the function, `func`, conditional on being in 
            the given interval (k such that ``lb &lt;= k &lt;= ub``). 
            Default is False. 
        maxcount : int, optional 
            Maximal number of terms to evaluate (to avoid an endless loop for 
            an infinite sum). Default is 1000. 
        tolerance : float, optional 
            Absolute tolerance for the summation. Default is 1e-10. 
        chunksize : int, optional 
            Iterate over the support of a distributions in chunks of this size. 
            Default is 32. 
 
        Returns 
        ------- 
        expect : float 
            Expected value. 
 
        Notes 
        ----- 
        For heavy-tailed distributions, the expected value may or 
        may not exist, 
        depending on the function, `func`. If it does exist, but the 
        sum converges 
        slowly, the accuracy of the result may be rather low. For instance, for 
        ``zipf(4)``, accuracy for mean, variance in example is only 1e-5. 
        increasing `maxcount` and/or `chunksize` may improve the result, 
        but may also make zipf very slow. 
 
        The function is not vectorized. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">func </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">def </span><span class="s1">fun(x):</span>
                <span class="s0"># loc and args from outer scope</span>
                <span class="s2">return </span><span class="s1">(x+loc)*self._pmf(x</span><span class="s2">, </span><span class="s1">*args)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">def </span><span class="s1">fun(x):</span>
                <span class="s0"># loc and args from outer scope</span>
                <span class="s2">return </span><span class="s1">func(x+loc)*self._pmf(x</span><span class="s2">, </span><span class="s1">*args)</span>
        <span class="s0"># used pmf because _pmf does not check support in randint and there</span>
        <span class="s0"># might be problems(?) with correct self.a, self.b at this stage maybe</span>
        <span class="s0"># not anymore, seems to work now with _pmf</span>

        <span class="s1">_a</span><span class="s2">, </span><span class="s1">_b = self._get_support(*args)</span>
        <span class="s2">if </span><span class="s1">lb </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">lb = _a</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">lb = lb - loc   </span><span class="s0"># convert bound for standardized distribution</span>
        <span class="s2">if </span><span class="s1">ub </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">ub = _b</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">ub = ub - loc   </span><span class="s0"># convert bound for standardized distribution</span>
        <span class="s2">if </span><span class="s1">conditional:</span>
            <span class="s1">invfac = self.sf(lb-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">*args) - self.sf(ub</span><span class="s2">, </span><span class="s1">*args)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">invfac = </span><span class="s4">1.0</span>

        <span class="s2">if </span><span class="s1">isinstance(self</span><span class="s2">, </span><span class="s1">rv_sample):</span>
            <span class="s1">res = self._expect(fun</span><span class="s2">, </span><span class="s1">lb</span><span class="s2">, </span><span class="s1">ub)</span>
            <span class="s2">return </span><span class="s1">res / invfac</span>

        <span class="s0"># iterate over the support, starting from the median</span>
        <span class="s1">x0 = self.ppf(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">*args)</span>
        <span class="s1">res = _expect(fun</span><span class="s2">, </span><span class="s1">lb</span><span class="s2">, </span><span class="s1">ub</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">self.inc</span><span class="s2">, </span><span class="s1">maxcount</span><span class="s2">, </span><span class="s1">tolerance</span><span class="s2">, </span><span class="s1">chunksize)</span>
        <span class="s2">return </span><span class="s1">res / invfac</span>

    <span class="s2">def </span><span class="s1">_param_info(self):</span>
        <span class="s1">shape_info = self._shape_info()</span>
        <span class="s1">loc_info = _ShapeInfo(</span><span class="s3">&quot;loc&quot;</span><span class="s2">, True, </span><span class="s1">(-np.inf</span><span class="s2">, </span><span class="s1">np.inf)</span><span class="s2">, </span><span class="s1">(</span><span class="s2">False, False</span><span class="s1">))</span>
        <span class="s1">param_info = shape_info + [loc_info]</span>
        <span class="s2">return </span><span class="s1">param_info</span>


<span class="s2">def </span><span class="s1">_expect(fun</span><span class="s2">, </span><span class="s1">lb</span><span class="s2">, </span><span class="s1">ub</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">inc</span><span class="s2">, </span><span class="s1">maxcount=</span><span class="s4">1000</span><span class="s2">, </span><span class="s1">tolerance=</span><span class="s4">1e-10</span><span class="s2">,</span>
            <span class="s1">chunksize=</span><span class="s4">32</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot;Helper for computing the expectation value of `fun`.&quot;&quot;&quot;</span>
    <span class="s0"># short-circuit if the support size is small enough</span>
    <span class="s2">if </span><span class="s1">(ub - lb) &lt;= chunksize:</span>
        <span class="s1">supp = np.arange(lb</span><span class="s2">, </span><span class="s1">ub+</span><span class="s4">1</span><span class="s2">, </span><span class="s1">inc)</span>
        <span class="s1">vals = fun(supp)</span>
        <span class="s2">return </span><span class="s1">np.sum(vals)</span>

    <span class="s0"># otherwise, iterate starting from x0</span>
    <span class="s2">if </span><span class="s1">x0 &lt; lb:</span>
        <span class="s1">x0 = lb</span>
    <span class="s2">if </span><span class="s1">x0 &gt; ub:</span>
        <span class="s1">x0 = ub</span>

    <span class="s1">count</span><span class="s2">, </span><span class="s1">tot = </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.</span>
    <span class="s0"># iterate over [x0, ub] inclusive</span>
    <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">_iter_chunked(x0</span><span class="s2">, </span><span class="s1">ub+</span><span class="s4">1</span><span class="s2">, </span><span class="s1">chunksize=chunksize</span><span class="s2">, </span><span class="s1">inc=inc):</span>
        <span class="s1">count += x.size</span>
        <span class="s1">delta = np.sum(fun(x))</span>
        <span class="s1">tot += delta</span>
        <span class="s2">if </span><span class="s1">abs(delta) &lt; tolerance * x.size:</span>
            <span class="s2">break</span>
        <span class="s2">if </span><span class="s1">count &gt; maxcount:</span>
            <span class="s1">warnings.warn(</span><span class="s3">'expect(): sum did not converge'</span><span class="s2">, </span><span class="s1">RuntimeWarning)</span>
            <span class="s2">return </span><span class="s1">tot</span>

    <span class="s0"># iterate over [lb, x0)</span>
    <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">_iter_chunked(x0-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">lb-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">chunksize=chunksize</span><span class="s2">, </span><span class="s1">inc=-inc):</span>
        <span class="s1">count += x.size</span>
        <span class="s1">delta = np.sum(fun(x))</span>
        <span class="s1">tot += delta</span>
        <span class="s2">if </span><span class="s1">abs(delta) &lt; tolerance * x.size:</span>
            <span class="s2">break</span>
        <span class="s2">if </span><span class="s1">count &gt; maxcount:</span>
            <span class="s1">warnings.warn(</span><span class="s3">'expect(): sum did not converge'</span><span class="s2">, </span><span class="s1">RuntimeWarning)</span>
            <span class="s2">break</span>

    <span class="s2">return </span><span class="s1">tot</span>


<span class="s2">def </span><span class="s1">_iter_chunked(x0</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">chunksize=</span><span class="s4">4</span><span class="s2">, </span><span class="s1">inc=</span><span class="s4">1</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot;Iterate from x0 to x1 in chunks of chunksize and steps inc. 
 
    x0 must be finite, x1 need not be. In the latter case, the iterator is 
    infinite. 
    Handles both x0 &lt; x1 and x0 &gt; x1. In the latter case, iterates downwards 
    (make sure to set inc &lt; 0.) 
 
    &gt;&gt;&gt; [x for x in _iter_chunked(2, 5, inc=2)] 
    [array([2, 4])] 
    &gt;&gt;&gt; [x for x in _iter_chunked(2, 11, inc=2)] 
    [array([2, 4, 6, 8]), array([10])] 
    &gt;&gt;&gt; [x for x in _iter_chunked(2, -5, inc=-2)] 
    [array([ 2,  0, -2, -4])] 
    &gt;&gt;&gt; [x for x in _iter_chunked(2, -9, inc=-2)] 
    [array([ 2,  0, -2, -4]), array([-6, -8])] 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">inc == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'Cannot increment by zero.'</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">chunksize &lt;= </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'Chunk size must be positive; got %s.' </span><span class="s1">% chunksize)</span>

    <span class="s1">s = </span><span class="s4">1 </span><span class="s2">if </span><span class="s1">inc &gt; </span><span class="s4">0 </span><span class="s2">else </span><span class="s1">-</span><span class="s4">1</span>
    <span class="s1">stepsize = abs(chunksize * inc)</span>

    <span class="s1">x = x0</span>
    <span class="s2">while </span><span class="s1">(x - x1) * inc &lt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">delta = min(stepsize</span><span class="s2">, </span><span class="s1">abs(x - x1))</span>
        <span class="s1">step = delta * s</span>
        <span class="s1">supp = np.arange(x</span><span class="s2">, </span><span class="s1">x + step</span><span class="s2">, </span><span class="s1">inc)</span>
        <span class="s1">x += step</span>
        <span class="s2">yield </span><span class="s1">supp</span>


<span class="s2">class </span><span class="s1">rv_sample(rv_discrete):</span>
    <span class="s5">&quot;&quot;&quot;A 'sample' discrete distribution defined by the support and values. 
 
    The ctor ignores most of the arguments, only needs the `values` argument. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">a=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">b=inf</span><span class="s2">, </span><span class="s1">name=</span><span class="s2">None, </span><span class="s1">badvalue=</span><span class="s2">None,</span>
                 <span class="s1">moment_tol=</span><span class="s4">1e-8</span><span class="s2">, </span><span class="s1">values=</span><span class="s2">None, </span><span class="s1">inc=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">longname=</span><span class="s2">None,</span>
                 <span class="s1">shapes=</span><span class="s2">None, </span><span class="s1">seed=</span><span class="s2">None</span><span class="s1">):</span>

        <span class="s1">super(rv_discrete</span><span class="s2">, </span><span class="s1">self).__init__(seed)</span>

        <span class="s2">if </span><span class="s1">values </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;rv_sample.__init__(..., values=None,...)&quot;</span><span class="s1">)</span>

        <span class="s0"># cf generic freeze</span>
        <span class="s1">self._ctor_param = dict(</span>
            <span class="s1">a=a</span><span class="s2">, </span><span class="s1">b=b</span><span class="s2">, </span><span class="s1">name=name</span><span class="s2">, </span><span class="s1">badvalue=badvalue</span><span class="s2">,</span>
            <span class="s1">moment_tol=moment_tol</span><span class="s2">, </span><span class="s1">values=values</span><span class="s2">, </span><span class="s1">inc=inc</span><span class="s2">,</span>
            <span class="s1">longname=longname</span><span class="s2">, </span><span class="s1">shapes=shapes</span><span class="s2">, </span><span class="s1">seed=seed)</span>

        <span class="s2">if </span><span class="s1">badvalue </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">badvalue = nan</span>
        <span class="s1">self.badvalue = badvalue</span>
        <span class="s1">self.moment_tol = moment_tol</span>
        <span class="s1">self.inc = inc</span>
        <span class="s1">self.shapes = shapes</span>
        <span class="s1">self.vecentropy = self._entropy</span>

        <span class="s1">xk</span><span class="s2">, </span><span class="s1">pk = values</span>

        <span class="s2">if </span><span class="s1">np.shape(xk) != np.shape(pk):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;xk and pk must have the same shape.&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">np.less(pk</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">).any():</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;All elements of pk must be non-negative.&quot;</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">np.allclose(np.sum(pk)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;The sum of provided pk is not 1.&quot;</span><span class="s1">)</span>

        <span class="s1">indx = np.argsort(np.ravel(xk))</span>
        <span class="s1">self.xk = np.take(np.ravel(xk)</span><span class="s2">, </span><span class="s1">indx</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.pk = np.take(np.ravel(pk)</span><span class="s2">, </span><span class="s1">indx</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.a = self.xk[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">self.b = self.xk[-</span><span class="s4">1</span><span class="s1">]</span>

        <span class="s1">self.qvals = np.cumsum(self.pk</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">self.shapes = </span><span class="s3">' '   </span><span class="s0"># bypass inspection</span>

        <span class="s1">self._construct_argparser(meths_to_inspect=[self._pmf]</span><span class="s2">,</span>
                                  <span class="s1">locscale_in=</span><span class="s3">'loc=0'</span><span class="s2">,</span>
                                  <span class="s0"># scale=1 for discrete RVs</span>
                                  <span class="s1">locscale_out=</span><span class="s3">'loc, 1'</span><span class="s1">)</span>

        <span class="s1">self._attach_methods()</span>

        <span class="s1">self._construct_docstrings(name</span><span class="s2">, </span><span class="s1">longname)</span>

    <span class="s2">def </span><span class="s1">__getstate__(self):</span>
        <span class="s1">dct = self.__dict__.copy()</span>

        <span class="s0"># these methods will be remade in rv_generic.__setstate__,</span>
        <span class="s0"># which calls rv_generic._attach_methods</span>
        <span class="s1">attrs = [</span><span class="s3">&quot;_parse_args&quot;</span><span class="s2">, </span><span class="s3">&quot;_parse_args_stats&quot;</span><span class="s2">, </span><span class="s3">&quot;_parse_args_rvs&quot;</span><span class="s1">]</span>
        <span class="s1">[dct.pop(attr</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">attrs]</span>

        <span class="s2">return </span><span class="s1">dct</span>

    <span class="s2">def </span><span class="s1">_attach_methods(self):</span>
        <span class="s5">&quot;&quot;&quot;Attaches dynamically created argparser methods.&quot;&quot;&quot;</span>
        <span class="s1">self._attach_argparser_methods()</span>

    <span class="s2">def </span><span class="s1">_get_support(self</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s5">&quot;&quot;&quot;Return the support of the (unscaled, unshifted) distribution. 
 
        Parameters 
        ---------- 
        arg1, arg2, ... : array_like 
            The shape parameter(s) for the distribution (see docstring of the 
            instance object for more information). 
 
        Returns 
        ------- 
        a, b : numeric (float, or int or +/-np.inf) 
            end-points of the distribution's support. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.a</span><span class="s2">, </span><span class="s1">self.b</span>

    <span class="s2">def </span><span class="s1">_pmf(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">np.select([x == k </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">self.xk]</span><span class="s2">,</span>
                         <span class="s1">[np.broadcast_arrays(p</span><span class="s2">, </span><span class="s1">x)[</span><span class="s4">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self.pk]</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_cdf(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s1">xx</span><span class="s2">, </span><span class="s1">xxk = np.broadcast_arrays(x[:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.xk)</span>
        <span class="s1">indx = np.argmax(xxk &gt; xx</span><span class="s2">, </span><span class="s1">axis=-</span><span class="s4">1</span><span class="s1">) - </span><span class="s4">1</span>
        <span class="s2">return </span><span class="s1">self.qvals[indx]</span>

    <span class="s2">def </span><span class="s1">_ppf(self</span><span class="s2">, </span><span class="s1">q):</span>
        <span class="s1">qq</span><span class="s2">, </span><span class="s1">sqq = np.broadcast_arrays(q[...</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.qvals)</span>
        <span class="s1">indx = argmax(sqq &gt;= qq</span><span class="s2">, </span><span class="s1">axis=-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self.xk[indx]</span>

    <span class="s2">def </span><span class="s1">_rvs(self</span><span class="s2">, </span><span class="s1">size=</span><span class="s2">None, </span><span class="s1">random_state=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0"># Need to define it explicitly, otherwise .rvs() with size=None</span>
        <span class="s0"># fails due to explicit broadcasting in _ppf</span>
        <span class="s1">U = random_state.uniform(size=size)</span>
        <span class="s2">if </span><span class="s1">size </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">U = np.array(U</span><span class="s2">, </span><span class="s1">ndmin=</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">Y = self._ppf(U)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">Y = self._ppf(U)</span>
        <span class="s2">return </span><span class="s1">Y</span>

    <span class="s2">def </span><span class="s1">_entropy(self):</span>
        <span class="s2">return </span><span class="s1">stats.entropy(self.pk)</span>

    <span class="s2">def </span><span class="s1">generic_moment(self</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s1">n = asarray(n)</span>
        <span class="s2">return </span><span class="s1">np.sum(self.xk**n[np.newaxis</span><span class="s2">, </span><span class="s1">...] * self.pk</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_expect(self</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">lb</span><span class="s2">, </span><span class="s1">ub</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s0"># ignore all args, just do a brute force summation</span>
        <span class="s1">supp = self.xk[(lb &lt;= self.xk) &amp; (self.xk &lt;= ub)]</span>
        <span class="s1">vals = fun(supp)</span>
        <span class="s2">return </span><span class="s1">np.sum(vals)</span>


<span class="s2">def </span><span class="s1">_check_shape(argshape</span><span class="s2">, </span><span class="s1">size):</span>
    <span class="s5">&quot;&quot;&quot; 
    This is a utility function used by `_rvs()` in the class geninvgauss_gen. 
    It compares the tuple argshape to the tuple size. 
 
    Parameters 
    ---------- 
    argshape : tuple of integers 
        Shape of the arguments. 
    size : tuple of integers or integer 
        Size argument of rvs(). 
 
    Returns 
    ------- 
    The function returns two tuples, scalar_shape and bc. 
 
    scalar_shape : tuple 
        Shape to which the 1-d array of random variates returned by 
        _rvs_scalar() is converted when it is copied into the 
        output array of _rvs(). 
 
    bc : tuple of booleans 
        bc is an tuple the same length as size. bc[j] is True if the data 
        associated with that index is generated in one call of _rvs_scalar(). 
 
    &quot;&quot;&quot;</span>
    <span class="s1">scalar_shape = []</span>
    <span class="s1">bc = []</span>
    <span class="s2">for </span><span class="s1">argdim</span><span class="s2">, </span><span class="s1">sizedim </span><span class="s2">in </span><span class="s1">zip_longest(argshape[::-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">size[::-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                                       <span class="s1">fillvalue=</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">sizedim &gt; argdim </span><span class="s2">or </span><span class="s1">(argdim == sizedim == </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">scalar_shape.append(sizedim)</span>
            <span class="s1">bc.append(</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">bc.append(</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">tuple(scalar_shape[::-</span><span class="s4">1</span><span class="s1">])</span><span class="s2">, </span><span class="s1">tuple(bc[::-</span><span class="s4">1</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">get_distribution_names(namespace_pairs</span><span class="s2">, </span><span class="s1">rv_base_class):</span>
    <span class="s5">&quot;&quot;&quot;Collect names of statistical distributions and their generators. 
 
    Parameters 
    ---------- 
    namespace_pairs : sequence 
        A snapshot of (name, value) pairs in the namespace of a module. 
    rv_base_class : class 
        The base class of random variable generator classes in a module. 
 
    Returns 
    ------- 
    distn_names : list of strings 
        Names of the statistical distributions. 
    distn_gen_names : list of strings 
        Names of the generators of the statistical distributions. 
        Note that these are not simply the names of the statistical 
        distributions, with a _gen suffix added. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">distn_names = []</span>
    <span class="s1">distn_gen_names = []</span>
    <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">namespace_pairs:</span>
        <span class="s2">if </span><span class="s1">name.startswith(</span><span class="s3">'_'</span><span class="s1">):</span>
            <span class="s2">continue</span>
        <span class="s2">if </span><span class="s1">name.endswith(</span><span class="s3">'_gen'</span><span class="s1">) </span><span class="s2">and </span><span class="s1">issubclass(value</span><span class="s2">, </span><span class="s1">rv_base_class):</span>
            <span class="s1">distn_gen_names.append(name)</span>
        <span class="s2">if </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">rv_base_class):</span>
            <span class="s1">distn_names.append(name)</span>
    <span class="s2">return </span><span class="s1">distn_names</span><span class="s2">, </span><span class="s1">distn_gen_names</span>
</pre>
</body>
</html>