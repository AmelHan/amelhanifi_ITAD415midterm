<html>
<head>
<title>transformed.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
transformed.py</font>
</center></td></tr></table>
<pre><span class="s0">## copied from nonlinear_transform_gen.py</span>

<span class="s2">''' A class for the distribution of a non-linear monotonic transformation of a continuous random variable 
 
simplest usage: 
example: create log-gamma distribution, i.e. y = log(x), 
            where x is gamma distributed (also available in scipy.stats) 
    loggammaexpg = Transf_gen(stats.gamma, np.log, np.exp) 
 
example: what is the distribution of the discount factor y=1/(1+x) 
            where interest rate x is normally distributed with N(mux,stdx**2)')? 
            (just to come up with a story that implies a nice transformation) 
    invnormalg = Transf_gen(stats.norm, inversew, inversew_inv, decr=True, a=-np.inf) 
 
This class does not work well for distributions with difficult shapes, 
    e.g. 1/x where x is standard normal, because of the singularity and jump at zero. 
 
Note: I'm working from my version of scipy.stats.distribution. 
      But this script runs under scipy 0.6.0 (checked with numpy: 1.2.0rc2 and python 2.4) 
 
This is not yet thoroughly tested, polished or optimized 
 
TODO: 
  * numargs handling is not yet working properly, numargs needs to be specified (default = 0 or 1) 
  * feeding args and kwargs to underlying distribution is untested and incomplete 
  * distinguish args and kwargs for the transformed and the underlying distribution 
    - currently all args and no kwargs are transmitted to underlying distribution 
    - loc and scale only work for transformed, but not for underlying distribution 
    - possible to separate args for transformation and underlying distribution parameters 
 
  * add _rvs as method, will be faster in many cases 
 
 
Created on Tuesday, October 28, 2008, 12:40:37 PM 
Author: josef-pktd 
License: BSD 
 
'''</span>
<span class="s3">from </span><span class="s1">scipy </span><span class="s3">import </span><span class="s1">stats</span>
<span class="s3">from </span><span class="s1">scipy.stats </span><span class="s3">import </span><span class="s1">distributions</span>
<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>


<span class="s3">def </span><span class="s1">get_u_argskwargs(**kwargs):</span>
    <span class="s0"># Todo: What's this? wrong spacing, used in Transf_gen TransfTwo_gen</span>
    <span class="s1">u_kwargs = dict((k.replace(</span><span class="s4">'u_'</span><span class="s3">, </span><span class="s4">''</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">v) </span><span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">kwargs.items()</span>
                    <span class="s3">if </span><span class="s1">k.startswith(</span><span class="s4">'u_'</span><span class="s1">))</span>
    <span class="s1">u_args = u_kwargs.pop(</span><span class="s4">'u_args'</span><span class="s3">, None</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">u_args</span><span class="s3">, </span><span class="s1">u_kwargs</span>


<span class="s3">class </span><span class="s1">Transf_gen(distributions.rv_continuous):</span>
    <span class="s2">'''a class for non-linear monotonic transformation of a continuous random variable 
 
    '''</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">kls</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">funcinv</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s0"># print(args</span>
        <span class="s0"># print(kwargs</span>

        <span class="s1">self.func = func</span>
        <span class="s1">self.funcinv = funcinv</span>
        <span class="s0"># explicit for self.__dict__.update(kwargs)</span>
        <span class="s0"># need to set numargs because inspection does not work</span>
        <span class="s1">self.numargs = kwargs.pop(</span><span class="s4">'numargs'</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0"># print(self.numargs</span>
        <span class="s1">name = kwargs.pop(</span><span class="s4">'name'</span><span class="s3">, </span><span class="s4">'transfdist'</span><span class="s1">)</span>
        <span class="s1">longname = kwargs.pop(</span><span class="s4">'longname'</span><span class="s3">, </span><span class="s4">'Non-linear transformed distribution'</span><span class="s1">)</span>
        <span class="s1">extradoc = kwargs.pop(</span><span class="s4">'extradoc'</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">a = kwargs.pop(</span><span class="s4">'a'</span><span class="s3">, </span><span class="s1">-np.inf)</span>
        <span class="s1">b = kwargs.pop(</span><span class="s4">'b'</span><span class="s3">, </span><span class="s1">np.inf)</span>
        <span class="s1">self.decr = kwargs.pop(</span><span class="s4">'decr'</span><span class="s3">, False</span><span class="s1">)</span>
        <span class="s0"># defines whether it is a decreasing (True)</span>
        <span class="s0">#       or increasing (False) monotonic transformation</span>

        <span class="s1">self.u_args</span><span class="s3">, </span><span class="s1">self.u_kwargs = get_u_argskwargs(**kwargs)</span>
        <span class="s1">self.kls = kls  </span><span class="s0"># (self.u_args, self.u_kwargs)</span>
        <span class="s0"># possible to freeze the underlying distribution</span>

        <span class="s1">super(Transf_gen</span><span class="s3">, </span><span class="s1">self).__init__(a=a</span><span class="s3">, </span><span class="s1">b=b</span><span class="s3">, </span><span class="s1">name=name</span><span class="s3">,</span>
                                         <span class="s1">shapes=kls.shapes</span><span class="s3">,</span>
                                         <span class="s1">longname=longname</span><span class="s3">,</span>
                                         <span class="s0"># extradoc = extradoc</span>
                                         <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_cdf(self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s0"># print(args</span>
        <span class="s3">if not </span><span class="s1">self.decr:</span>
            <span class="s3">return </span><span class="s1">self.kls._cdf(self.funcinv(x)</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
            <span class="s0"># note scipy _cdf only take *args not *kwargs</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s5">1.0 </span><span class="s1">- self.kls._cdf(self.funcinv(x)</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>

    <span class="s3">def </span><span class="s1">_ppf(self</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s3">if not </span><span class="s1">self.decr:</span>
            <span class="s3">return </span><span class="s1">self.func(self.kls._ppf(q</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.func(self.kls._ppf(</span><span class="s5">1 </span><span class="s1">- q</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs))</span>


<span class="s3">def </span><span class="s1">inverse(x):</span>
    <span class="s3">return </span><span class="s1">np.divide(</span><span class="s5">1.0</span><span class="s3">, </span><span class="s1">x)</span>


<span class="s1">mux</span><span class="s3">, </span><span class="s1">stdx = </span><span class="s5">0.05</span><span class="s3">, </span><span class="s5">0.1</span>
<span class="s1">mux</span><span class="s3">, </span><span class="s1">stdx = </span><span class="s5">9.0</span><span class="s3">, </span><span class="s5">1.0</span>


<span class="s3">def </span><span class="s1">inversew(x):</span>
    <span class="s3">return </span><span class="s5">1.0 </span><span class="s1">/ (</span><span class="s5">1 </span><span class="s1">+ mux + x * stdx)</span>


<span class="s3">def </span><span class="s1">inversew_inv(x):</span>
    <span class="s3">return </span><span class="s1">(</span><span class="s5">1.0 </span><span class="s1">/ x - </span><span class="s5">1.0 </span><span class="s1">- mux) / stdx  </span><span class="s0"># .np.divide(1.0,x)-10</span>


<span class="s3">def </span><span class="s1">identit(x):</span>
    <span class="s3">return </span><span class="s1">x</span>


<span class="s1">invdnormalg = Transf_gen(stats.norm</span><span class="s3">, </span><span class="s1">inversew</span><span class="s3">, </span><span class="s1">inversew_inv</span><span class="s3">, </span><span class="s1">decr=</span><span class="s3">True,  </span><span class="s0"># a=-np.inf,</span>
                         <span class="s1">numargs=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">name=</span><span class="s4">'discf'</span><span class="s3">, </span><span class="s1">longname=</span><span class="s4">'normal-based discount factor'</span><span class="s3">,</span>
                         <span class="s0"># extradoc = '\ndistribution of discount factor y=1/(1+x)) with x N(0.05,0.1**2)'</span>
                         <span class="s1">)</span>

<span class="s1">lognormalg = Transf_gen(stats.norm</span><span class="s3">, </span><span class="s1">np.exp</span><span class="s3">, </span><span class="s1">np.log</span><span class="s3">,</span>
                        <span class="s1">numargs=</span><span class="s5">2</span><span class="s3">, </span><span class="s1">a=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">name=</span><span class="s4">'lnnorm'</span><span class="s3">,</span>
                        <span class="s1">longname=</span><span class="s4">'Exp transformed normal'</span><span class="s3">,</span>
                        <span class="s0"># extradoc = '\ndistribution of y = exp(x), with x standard normal'</span>
                        <span class="s0"># 'precision for moment andstats is not very high, 2-3 decimals'</span>
                        <span class="s1">)</span>

<span class="s1">loggammaexpg = Transf_gen(stats.gamma</span><span class="s3">, </span><span class="s1">np.log</span><span class="s3">, </span><span class="s1">np.exp</span><span class="s3">, </span><span class="s1">numargs=</span><span class="s5">1</span><span class="s1">)</span>

<span class="s0">## copied form nonlinear_transform_short.py</span>

<span class="s4">'''univariate distribution of a non-linear monotonic transformation of a 
random variable 
 
'''</span>


<span class="s3">class </span><span class="s1">ExpTransf_gen(distributions.rv_continuous):</span>
    <span class="s2">'''Distribution based on log/exp transformation 
 
    the constructor can be called with a distribution class 
    and generates the distribution of the transformed random variable 
 
    '''</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">kls</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s0"># print(args</span>
        <span class="s0"># print(kwargs</span>
        <span class="s0"># explicit for self.__dict__.update(kwargs)</span>
        <span class="s3">if </span><span class="s4">'numargs' </span><span class="s3">in </span><span class="s1">kwargs:</span>
            <span class="s1">self.numargs = kwargs[</span><span class="s4">'numargs'</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.numargs = </span><span class="s5">1</span>
        <span class="s3">if </span><span class="s4">'name' </span><span class="s3">in </span><span class="s1">kwargs:</span>
            <span class="s1">name = kwargs[</span><span class="s4">'name'</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">name = </span><span class="s4">'Log transformed distribution'</span>
        <span class="s3">if </span><span class="s4">'a' </span><span class="s3">in </span><span class="s1">kwargs:</span>
            <span class="s1">a = kwargs[</span><span class="s4">'a'</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">a = </span><span class="s5">0</span>
        <span class="s1">super(ExpTransf_gen</span><span class="s3">, </span><span class="s1">self).__init__(a=a</span><span class="s3">, </span><span class="s1">name=name)</span>
        <span class="s1">self.kls = kls</span>

    <span class="s3">def </span><span class="s1">_cdf(self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">*args):</span>
        <span class="s0"># print(args</span>
        <span class="s3">return </span><span class="s1">self.kls._cdf(np.log(x)</span><span class="s3">, </span><span class="s1">*args)</span>

    <span class="s3">def </span><span class="s1">_ppf(self</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">*args):</span>
        <span class="s3">return </span><span class="s1">np.exp(self.kls._ppf(q</span><span class="s3">, </span><span class="s1">*args))</span>


<span class="s3">class </span><span class="s1">LogTransf_gen(distributions.rv_continuous):</span>
    <span class="s2">'''Distribution based on log/exp transformation 
 
    the constructor can be called with a distribution class 
    and generates the distribution of the transformed random variable 
 
    '''</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">kls</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s0"># explicit for self.__dict__.update(kwargs)</span>
        <span class="s3">if </span><span class="s4">'numargs' </span><span class="s3">in </span><span class="s1">kwargs:</span>
            <span class="s1">self.numargs = kwargs[</span><span class="s4">'numargs'</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.numargs = </span><span class="s5">1</span>
        <span class="s3">if </span><span class="s4">'name' </span><span class="s3">in </span><span class="s1">kwargs:</span>
            <span class="s1">name = kwargs[</span><span class="s4">'name'</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">name = </span><span class="s4">'Log transformed distribution'</span>
        <span class="s3">if </span><span class="s4">'a' </span><span class="s3">in </span><span class="s1">kwargs:</span>
            <span class="s1">a = kwargs[</span><span class="s4">'a'</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">a = </span><span class="s5">0</span>

        <span class="s1">super(LogTransf_gen</span><span class="s3">, </span><span class="s1">self).__init__(a=a</span><span class="s3">, </span><span class="s1">name=name)</span>
        <span class="s1">self.kls = kls</span>

    <span class="s3">def </span><span class="s1">_cdf(self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">*args):</span>
        <span class="s0"># print(args</span>
        <span class="s3">return </span><span class="s1">self.kls._cdf(np.exp(x)</span><span class="s3">, </span><span class="s1">*args)</span>

    <span class="s3">def </span><span class="s1">_ppf(self</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">*args):</span>
        <span class="s3">return </span><span class="s1">np.log(self.kls._ppf(q</span><span class="s3">, </span><span class="s1">*args))</span>


<span class="s3">def </span><span class="s1">examples_transf():</span>
    <span class="s0">##lognormal = ExpTransf(a=0.0, xa=-10.0, name = 'Log transformed normal')</span>
    <span class="s0">##print(lognormal.cdf(1)</span>
    <span class="s0">##print(stats.lognorm.cdf(1,1)</span>
    <span class="s0">##print(lognormal.stats()</span>
    <span class="s0">##print(stats.lognorm.stats(1)</span>
    <span class="s0">##print(lognormal.rvs(size=10)</span>

    <span class="s1">print(</span><span class="s4">'Results for lognormal'</span><span class="s1">)</span>
    <span class="s1">lognormalg = ExpTransf_gen(stats.norm</span><span class="s3">, </span><span class="s1">a=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">name=</span><span class="s4">'Log transformed normal general'</span><span class="s1">)</span>
    <span class="s1">print(lognormalg.cdf(</span><span class="s5">1</span><span class="s1">))</span>
    <span class="s1">print(stats.lognorm.cdf(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">))</span>
    <span class="s1">print(lognormalg.stats())</span>
    <span class="s1">print(stats.lognorm.stats(</span><span class="s5">1</span><span class="s1">))</span>
    <span class="s1">print(lognormalg.rvs(size=</span><span class="s5">5</span><span class="s1">))</span>

    <span class="s0">##print('Results for loggamma'</span>
    <span class="s0">##loggammag = ExpTransf_gen(stats.gamma)</span>
    <span class="s0">##print(loggammag._cdf(1,10)</span>
    <span class="s0">##print(stats.loggamma.cdf(1,10)</span>

    <span class="s1">print(</span><span class="s4">'Results for expgamma'</span><span class="s1">)</span>
    <span class="s1">loggammaexpg = LogTransf_gen(stats.gamma)</span>
    <span class="s1">print(loggammaexpg._cdf(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">10</span><span class="s1">))</span>
    <span class="s1">print(stats.loggamma.cdf(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">10</span><span class="s1">))</span>
    <span class="s1">print(loggammaexpg._cdf(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">15</span><span class="s1">))</span>
    <span class="s1">print(stats.loggamma.cdf(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">15</span><span class="s1">))</span>

    <span class="s0"># this requires change in scipy.stats.distribution</span>
    <span class="s0"># print(loggammaexpg.cdf(1,10)</span>

    <span class="s1">print(</span><span class="s4">'Results for loglaplace'</span><span class="s1">)</span>
    <span class="s1">loglaplaceg = LogTransf_gen(stats.laplace)</span>
    <span class="s1">print(loglaplaceg._cdf(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">10</span><span class="s1">))</span>
    <span class="s1">print(stats.loglaplace.cdf(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">10</span><span class="s1">))</span>
    <span class="s1">loglaplaceexpg = ExpTransf_gen(stats.laplace)</span>
    <span class="s1">print(loglaplaceexpg._cdf(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">10</span><span class="s1">))</span>


<span class="s0">## copied from transformtwo.py</span>

<span class="s4">''' 
Created on Apr 28, 2009 
 
@author: Josef Perktold 
'''</span>

<span class="s4">''' A class for the distribution of a non-linear u-shaped or hump shaped transformation of a 
continuous random variable 
 
This is a companion to the distributions of non-linear monotonic transformation to the case 
when the inverse mapping is a 2-valued correspondence, for example for absolute value or square 
 
simplest usage: 
example: create squared distribution, i.e. y = x**2, 
            where x is normal or t distributed 
 
 
This class does not work well for distributions with difficult shapes, 
    e.g. 1/x where x is standard normal, because of the singularity and jump at zero. 
 
 
This verifies for normal - chi2, normal - halfnorm, foldnorm, and t - F 
 
TODO: 
  * numargs handling is not yet working properly, 
    numargs needs to be specified (default = 0 or 1) 
  * feeding args and kwargs to underlying distribution works in t distribution example 
  * distinguish args and kwargs for the transformed and the underlying distribution 
    - currently all args and no kwargs are transmitted to underlying distribution 
    - loc and scale only work for transformed, but not for underlying distribution 
    - possible to separate args for transformation and underlying distribution parameters 
 
  * add _rvs as method, will be faster in many cases 
 
'''</span>


<span class="s3">class </span><span class="s1">TransfTwo_gen(distributions.rv_continuous):</span>
    <span class="s2">'''Distribution based on a non-monotonic (u- or hump-shaped transformation) 
 
    the constructor can be called with a distribution class, and functions 
    that define the non-linear transformation. 
    and generates the distribution of the transformed random variable 
 
    Note: the transformation, it's inverse and derivatives need to be fully 
    specified: func, funcinvplus, funcinvminus, derivplus,  derivminus. 
    Currently no numerical derivatives or inverse are calculated 
 
    This can be used to generate distribution instances similar to the 
    distributions in scipy.stats. 
 
    '''</span>

    <span class="s0"># a class for non-linear non-monotonic transformation of a continuous random variable</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">kls</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">funcinvplus</span><span class="s3">, </span><span class="s1">funcinvminus</span><span class="s3">, </span><span class="s1">derivplus</span><span class="s3">,</span>
                 <span class="s1">derivminus</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s0"># print(args</span>
        <span class="s0"># print(kwargs</span>

        <span class="s1">self.func = func</span>
        <span class="s1">self.funcinvplus = funcinvplus</span>
        <span class="s1">self.funcinvminus = funcinvminus</span>
        <span class="s1">self.derivplus = derivplus</span>
        <span class="s1">self.derivminus = derivminus</span>
        <span class="s0"># explicit for self.__dict__.update(kwargs)</span>
        <span class="s0"># need to set numargs because inspection does not work</span>
        <span class="s1">self.numargs = kwargs.pop(</span><span class="s4">'numargs'</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0"># print(self.numargs</span>
        <span class="s1">name = kwargs.pop(</span><span class="s4">'name'</span><span class="s3">, </span><span class="s4">'transfdist'</span><span class="s1">)</span>
        <span class="s1">longname = kwargs.pop(</span><span class="s4">'longname'</span><span class="s3">, </span><span class="s4">'Non-linear transformed distribution'</span><span class="s1">)</span>
        <span class="s1">extradoc = kwargs.pop(</span><span class="s4">'extradoc'</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">a = kwargs.pop(</span><span class="s4">'a'</span><span class="s3">, </span><span class="s1">-np.inf)  </span><span class="s0"># attached to self in super</span>
        <span class="s1">b = kwargs.pop(</span><span class="s4">'b'</span><span class="s3">, </span><span class="s1">np.inf)  </span><span class="s0"># self.a, self.b would be overwritten</span>
        <span class="s1">self.shape = kwargs.pop(</span><span class="s4">'shape'</span><span class="s3">, False</span><span class="s1">)</span>
        <span class="s0"># defines whether it is a `u` shaped or `hump' shaped</span>
        <span class="s0">#       transformation</span>

        <span class="s1">self.u_args</span><span class="s3">, </span><span class="s1">self.u_kwargs = get_u_argskwargs(**kwargs)</span>
        <span class="s1">self.kls = kls  </span><span class="s0"># (self.u_args, self.u_kwargs)</span>
        <span class="s0"># possible to freeze the underlying distribution</span>

        <span class="s1">super(TransfTwo_gen</span><span class="s3">, </span><span class="s1">self).__init__(a=a</span><span class="s3">, </span><span class="s1">b=b</span><span class="s3">,</span>
                                            <span class="s1">name=name</span><span class="s3">,</span>
                                            <span class="s1">shapes=kls.shapes</span><span class="s3">,</span>
                                            <span class="s1">longname=longname</span><span class="s3">,</span>
                                            <span class="s0"># extradoc = extradoc</span>
                                            <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_rvs(self</span><span class="s3">, </span><span class="s1">*args):</span>
        <span class="s1">self.kls._size = self._size  </span><span class="s0"># size attached to self, not function argument</span>
        <span class="s3">return </span><span class="s1">self.func(self.kls._rvs(*args))</span>

    <span class="s3">def </span><span class="s1">_pdf(self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s0"># print(args</span>
        <span class="s3">if </span><span class="s1">self.shape == </span><span class="s4">'u'</span><span class="s1">:</span>
            <span class="s1">signpdf = </span><span class="s5">1</span>
        <span class="s3">elif </span><span class="s1">self.shape == </span><span class="s4">'hump'</span><span class="s1">:</span>
            <span class="s1">signpdf = -</span><span class="s5">1</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'shape can only be `u` or `hump`'</span><span class="s1">)</span>

        <span class="s3">return </span><span class="s1">signpdf * (self.derivplus(x) * self.kls._pdf(self.funcinvplus(x)</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs) -</span>
                          <span class="s1">self.derivminus(x) * self.kls._pdf(self.funcinvminus(x)</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">,</span>
                                                             <span class="s1">**kwargs))</span>
        <span class="s0"># note scipy _cdf only take *args not *kwargs</span>

    <span class="s3">def </span><span class="s1">_cdf(self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s0"># print(args</span>
        <span class="s3">if </span><span class="s1">self.shape == </span><span class="s4">'u'</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.kls._cdf(self.funcinvplus(x)</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs) - \</span>
                <span class="s1">self.kls._cdf(self.funcinvminus(x)</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
            <span class="s0"># note scipy _cdf only take *args not *kwargs</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s5">1.0 </span><span class="s1">- self._sf(x</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>

    <span class="s3">def </span><span class="s1">_sf(self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s0"># print(args</span>
        <span class="s3">if </span><span class="s1">self.shape == </span><span class="s4">'hump'</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.kls._cdf(self.funcinvplus(x)</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs) - \</span>
                <span class="s1">self.kls._cdf(self.funcinvminus(x)</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
            <span class="s0"># note scipy _cdf only take *args not *kwargs</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s5">1.0 </span><span class="s1">- self._cdf(x</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>

    <span class="s3">def </span><span class="s1">_munp(self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s3">return </span><span class="s1">self._mom0_sc(n</span><span class="s3">, </span><span class="s1">*args)</span>


<span class="s0"># ppf might not be possible in general case?</span>
<span class="s0"># should be possible in symmetric case</span>
<span class="s0">#    def _ppf(self, q, *args, **kwargs):</span>
<span class="s0">#        if self.shape == 'u':</span>
<span class="s0">#            return self.func(self.kls._ppf(q,*args, **kwargs))</span>
<span class="s0">#        elif self.shape == 'hump':</span>
<span class="s0">#            return self.func(self.kls._ppf(1-q,*args, **kwargs))</span>

<span class="s0"># TODO: rename these functions to have unique names</span>

<span class="s3">class </span><span class="s1">SquareFunc:</span>
    <span class="s2">'''class to hold quadratic function with inverse function and derivative 
 
    using instance methods instead of class methods, if we want extension 
    to parametrized function 
    '''</span>

    <span class="s3">def </span><span class="s1">inverseplus(self</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s3">return </span><span class="s1">np.sqrt(x)</span>

    <span class="s3">def </span><span class="s1">inverseminus(self</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s3">return </span><span class="s5">0.0 </span><span class="s1">- np.sqrt(x)</span>

    <span class="s3">def </span><span class="s1">derivplus(self</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s3">return </span><span class="s5">0.5 </span><span class="s1">/ np.sqrt(x)</span>

    <span class="s3">def </span><span class="s1">derivminus(self</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s3">return </span><span class="s5">0.0 </span><span class="s1">- </span><span class="s5">0.5 </span><span class="s1">/ np.sqrt(x)</span>

    <span class="s3">def </span><span class="s1">squarefunc(self</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s3">return </span><span class="s1">np.power(x</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span>


<span class="s1">sqfunc = SquareFunc()</span>

<span class="s1">squarenormalg = TransfTwo_gen(stats.norm</span><span class="s3">, </span><span class="s1">sqfunc.squarefunc</span><span class="s3">, </span><span class="s1">sqfunc.inverseplus</span><span class="s3">,</span>
                              <span class="s1">sqfunc.inverseminus</span><span class="s3">, </span><span class="s1">sqfunc.derivplus</span><span class="s3">, </span><span class="s1">sqfunc.derivminus</span><span class="s3">,</span>
                              <span class="s1">shape=</span><span class="s4">'u'</span><span class="s3">, </span><span class="s1">a=</span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">b=np.inf</span><span class="s3">,</span>
                              <span class="s1">numargs=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">name=</span><span class="s4">'squarenorm'</span><span class="s3">, </span><span class="s1">longname=</span><span class="s4">'squared normal distribution'</span><span class="s3">,</span>
                              <span class="s0"># extradoc = '\ndistribution of the square of a normal random variable' +\</span>
                              <span class="s0">#            ' y=x**2 with x N(0.0,1)'</span>
                              <span class="s1">)</span>
<span class="s0"># u_loc=l, u_scale=s)</span>
<span class="s1">squaretg = TransfTwo_gen(stats.t</span><span class="s3">, </span><span class="s1">sqfunc.squarefunc</span><span class="s3">, </span><span class="s1">sqfunc.inverseplus</span><span class="s3">,</span>
                         <span class="s1">sqfunc.inverseminus</span><span class="s3">, </span><span class="s1">sqfunc.derivplus</span><span class="s3">, </span><span class="s1">sqfunc.derivminus</span><span class="s3">,</span>
                         <span class="s1">shape=</span><span class="s4">'u'</span><span class="s3">, </span><span class="s1">a=</span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">b=np.inf</span><span class="s3">,</span>
                         <span class="s1">numargs=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">name=</span><span class="s4">'squarenorm'</span><span class="s3">, </span><span class="s1">longname=</span><span class="s4">'squared t distribution'</span><span class="s3">,</span>
                         <span class="s0"># extradoc = '\ndistribution of the square of a t random variable' +\</span>
                         <span class="s0">#           ' y=x**2 with x t(dof,0.0,1)'</span>
                         <span class="s1">)</span>


<span class="s3">def </span><span class="s1">inverseplus(x):</span>
    <span class="s3">return </span><span class="s1">np.sqrt(-x)</span>


<span class="s3">def </span><span class="s1">inverseminus(x):</span>
    <span class="s3">return </span><span class="s5">0.0 </span><span class="s1">- np.sqrt(-x)</span>


<span class="s3">def </span><span class="s1">derivplus(x):</span>
    <span class="s3">return </span><span class="s5">0.0 </span><span class="s1">- </span><span class="s5">0.5 </span><span class="s1">/ np.sqrt(-x)</span>


<span class="s3">def </span><span class="s1">derivminus(x):</span>
    <span class="s3">return </span><span class="s5">0.5 </span><span class="s1">/ np.sqrt(-x)</span>


<span class="s3">def </span><span class="s1">negsquarefunc(x):</span>
    <span class="s3">return </span><span class="s1">-np.power(x</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span>


<span class="s1">negsquarenormalg = TransfTwo_gen(stats.norm</span><span class="s3">, </span><span class="s1">negsquarefunc</span><span class="s3">, </span><span class="s1">inverseplus</span><span class="s3">, </span><span class="s1">inverseminus</span><span class="s3">,</span>
                                 <span class="s1">derivplus</span><span class="s3">, </span><span class="s1">derivminus</span><span class="s3">, </span><span class="s1">shape=</span><span class="s4">'hump'</span><span class="s3">, </span><span class="s1">a=-np.inf</span><span class="s3">, </span><span class="s1">b=</span><span class="s5">0.0</span><span class="s3">,</span>
                                 <span class="s1">numargs=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">name=</span><span class="s4">'negsquarenorm'</span><span class="s3">,</span>
                                 <span class="s1">longname=</span><span class="s4">'negative squared normal distribution'</span><span class="s3">,</span>
                                 <span class="s0"># extradoc = '\ndistribution of the negative square of a normal random variable' +\</span>
                                 <span class="s0">#            ' y=-x**2 with x N(0.0,1)'</span>
                                 <span class="s1">)</span>


<span class="s0"># u_loc=l, u_scale=s)</span>

<span class="s3">def </span><span class="s1">inverseplus(x):</span>
    <span class="s3">return </span><span class="s1">x</span>


<span class="s3">def </span><span class="s1">inverseminus(x):</span>
    <span class="s3">return </span><span class="s5">0.0 </span><span class="s1">- x</span>


<span class="s3">def </span><span class="s1">derivplus(x):</span>
    <span class="s3">return </span><span class="s5">1.0</span>


<span class="s3">def </span><span class="s1">derivminus(x):</span>
    <span class="s3">return </span><span class="s5">0.0 </span><span class="s1">- </span><span class="s5">1.0</span>


<span class="s3">def </span><span class="s1">absfunc(x):</span>
    <span class="s3">return </span><span class="s1">np.abs(x)</span>


<span class="s1">absnormalg = TransfTwo_gen(stats.norm</span><span class="s3">, </span><span class="s1">np.abs</span><span class="s3">, </span><span class="s1">inverseplus</span><span class="s3">, </span><span class="s1">inverseminus</span><span class="s3">,</span>
                           <span class="s1">derivplus</span><span class="s3">, </span><span class="s1">derivminus</span><span class="s3">, </span><span class="s1">shape=</span><span class="s4">'u'</span><span class="s3">, </span><span class="s1">a=</span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">b=np.inf</span><span class="s3">,</span>
                           <span class="s1">numargs=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">name=</span><span class="s4">'absnorm'</span><span class="s3">, </span><span class="s1">longname=</span><span class="s4">'absolute of normal distribution'</span><span class="s3">,</span>
                           <span class="s0"># extradoc = '\ndistribution of the absolute value of a normal random variable' +\</span>
                           <span class="s0">#           ' y=abs(x) with x N(0,1)'</span>
                           <span class="s1">)</span>
</pre>
</body>
</html>