<html>
<head>
<title>_arff.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6a8759;}
.s4 { color: #cc7832;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_arff.py</font>
</center></td></tr></table>
<pre><span class="s0"># =============================================================================</span>
<span class="s0"># Federal University of Rio Grande do Sul (UFRGS)</span>
<span class="s0"># Connectionist Artificial Intelligence Laboratory (LIAC)</span>
<span class="s0"># Renato de Pontes Pereira - rppereira@inf.ufrgs.br</span>
<span class="s0"># =============================================================================</span>
<span class="s0"># Copyright (c) 2011 Renato de Pontes Pereira, renato.ppontes at gmail dot com</span>
<span class="s0">#</span>
<span class="s0"># Permission is hereby granted, free of charge, to any person obtaining a copy</span>
<span class="s0"># of this software and associated documentation files (the &quot;Software&quot;), to deal</span>
<span class="s0"># in the Software without restriction, including without limitation the rights</span>
<span class="s0"># to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
<span class="s0"># copies of the Software, and to permit persons to whom the Software is</span>
<span class="s0"># furnished to do so, subject to the following conditions:</span>
<span class="s0">#</span>
<span class="s0"># The above copyright notice and this permission notice shall be included in</span>
<span class="s0"># all copies or substantial portions of the Software.</span>
<span class="s0">#</span>
<span class="s0"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="s0"># IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="s0"># FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class="s0"># AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="s0"># LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
<span class="s0"># OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="s0"># SOFTWARE.</span>
<span class="s0"># =============================================================================</span>

<span class="s2">''' 
The liac-arff module implements functions to read and write ARFF files in 
Python. It was created in the Connectionist Artificial Intelligence Laboratory 
(LIAC), which takes place at the Federal University of Rio Grande do Sul 
(UFRGS), in Brazil. 
 
ARFF (Attribute-Relation File Format) is an file format specially created for 
describe datasets which are commonly used for machine learning experiments and 
software. This file format was created to be used in Weka, the best 
representative software for machine learning automated experiments. 
 
An ARFF file can be divided into two sections: header and data. The Header 
describes the metadata of the dataset, including a general description of the 
dataset, its name and its attributes. The source below is an example of a 
header section in a XOR dataset:: 
 
    % 
    % XOR Dataset 
    % 
    % Created by Renato Pereira 
    %            rppereira@inf.ufrgs.br 
    %            http://inf.ufrgs.br/~rppereira 
    % 
    % 
    @RELATION XOR 
 
    @ATTRIBUTE input1 REAL 
    @ATTRIBUTE input2 REAL 
    @ATTRIBUTE y REAL 
 
The Data section of an ARFF file describes the observations of the dataset, in 
the case of XOR dataset:: 
 
    @DATA 
    0.0,0.0,0.0 
    0.0,1.0,1.0 
    1.0,0.0,1.0 
    1.0,1.0,0.0 
    % 
    % 
    % 
 
Notice that several lines are starting with an ``%`` symbol, denoting a 
comment, thus, lines with ``%`` at the beginning will be ignored, except by the 
description part at the beginning of the file. The declarations ``@RELATION``, 
``@ATTRIBUTE``, and ``@DATA`` are all case insensitive and obligatory. 
 
For more information and details about the ARFF file description, consult 
http://www.cs.waikato.ac.nz/~ml/weka/arff.html 
 
 
ARFF Files in Python 
~~~~~~~~~~~~~~~~~~~~ 
 
This module uses built-ins python objects to represent a deserialized ARFF 
file. A dictionary is used as the container of the data and metadata of ARFF, 
and have the following keys: 
 
- **description**: (OPTIONAL) a string with the description of the dataset. 
- **relation**: (OBLIGATORY) a string with the name of the dataset. 
- **attributes**: (OBLIGATORY) a list of attributes with the following 
  template:: 
 
    (attribute_name, attribute_type) 
 
  the attribute_name is a string, and attribute_type must be an string 
  or a list of strings. 
- **data**: (OBLIGATORY) a list of data instances. Each data instance must be 
  a list with values, depending on the attributes. 
 
The above keys must follow the case which were described, i.e., the keys are 
case sensitive. The attribute type ``attribute_type`` must be one of these 
strings (they are not case sensitive): ``NUMERIC``, ``INTEGER``, ``REAL`` or 
``STRING``. For nominal attributes, the ``atribute_type`` must be a list of 
strings. 
 
In this format, the XOR dataset presented above can be represented as a python 
object as:: 
 
    xor_dataset = { 
        'description': 'XOR Dataset', 
        'relation': 'XOR', 
        'attributes': [ 
            ('input1', 'REAL'), 
            ('input2', 'REAL'), 
            ('y', 'REAL'), 
        ], 
        'data': [ 
            [0.0, 0.0, 0.0], 
            [0.0, 1.0, 1.0], 
            [1.0, 0.0, 1.0], 
            [1.0, 1.0, 0.0] 
        ] 
    } 
 
 
Features 
~~~~~~~~ 
 
This module provides several features, including: 
 
- Read and write ARFF files using python built-in structures, such dictionaries 
  and lists; 
- Supports `scipy.sparse.coo &lt;http://docs.scipy 
  .org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.html#scipy.sparse.coo_matrix&gt;`_ 
  and lists of dictionaries as used by SVMLight 
- Supports the following attribute types: NUMERIC, REAL, INTEGER, STRING, and 
  NOMINAL; 
- Has an interface similar to other built-in modules such as ``json``, or 
  ``zipfile``; 
- Supports read and write the descriptions of files; 
- Supports missing values and names with spaces; 
- Supports unicode values and names; 
- Fully compatible with Python 2.7+, Python 3.5+, pypy and pypy3; 
- Under `MIT License &lt;http://opensource.org/licenses/MIT&gt;`_ 
 
'''</span>
<span class="s1">__author__ = </span><span class="s3">'Renato de Pontes Pereira, Matthias Feurer, Joel Nothman'</span>
<span class="s1">__author_email__ = (</span><span class="s3">'renato.ppontes@gmail.com, '</span>
                    <span class="s3">'feurerm@informatik.uni-freiburg.de, '</span>
                    <span class="s3">'joel.nothman@gmail.com'</span><span class="s1">)</span>
<span class="s1">__version__ = </span><span class="s3">'2.4.0'</span>

<span class="s4">import </span><span class="s1">re</span>
<span class="s4">import </span><span class="s1">csv</span>
<span class="s4">from </span><span class="s1">typing </span><span class="s4">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s4">from </span><span class="s1">typing </span><span class="s4">import </span><span class="s1">Optional</span><span class="s4">, </span><span class="s1">List</span><span class="s4">, </span><span class="s1">Dict</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">Iterator</span><span class="s4">, </span><span class="s1">Union</span><span class="s4">, </span><span class="s1">Tuple</span>

<span class="s0"># CONSTANTS ===================================================================</span>
<span class="s1">_SIMPLE_TYPES = [</span><span class="s3">'NUMERIC'</span><span class="s4">, </span><span class="s3">'REAL'</span><span class="s4">, </span><span class="s3">'INTEGER'</span><span class="s4">, </span><span class="s3">'STRING'</span><span class="s1">]</span>

<span class="s1">_TK_DESCRIPTION = </span><span class="s3">'%'</span>
<span class="s1">_TK_COMMENT     = </span><span class="s3">'%'</span>
<span class="s1">_TK_RELATION    = </span><span class="s3">'@RELATION'</span>
<span class="s1">_TK_ATTRIBUTE   = </span><span class="s3">'@ATTRIBUTE'</span>
<span class="s1">_TK_DATA        = </span><span class="s3">'@DATA'</span>

<span class="s1">_RE_RELATION     = re.compile(</span><span class="s3">r'^([^\{\}%,\s]*|\&quot;.*\&quot;|\'.*\')$'</span><span class="s4">, </span><span class="s1">re.UNICODE)</span>
<span class="s1">_RE_ATTRIBUTE    = re.compile(</span><span class="s3">r'^(\&quot;.*\&quot;|\'.*\'|[^\{\}%,\s]*)\s+(.+)$'</span><span class="s4">, </span><span class="s1">re.UNICODE)</span>
<span class="s1">_RE_QUOTE_CHARS = re.compile(</span><span class="s3">r'[&quot;\'\\\s%,\000-\031]'</span><span class="s4">, </span><span class="s1">re.UNICODE)</span>
<span class="s1">_RE_ESCAPE_CHARS = re.compile(</span><span class="s3">r'(?=[&quot;\'\\%])|[\n\r\t\000-\031]'</span><span class="s1">)</span>
<span class="s1">_RE_SPARSE_LINE = re.compile(</span><span class="s3">r'^\s*\{.*\}\s*$'</span><span class="s4">, </span><span class="s1">re.UNICODE)</span>
<span class="s1">_RE_NONTRIVIAL_DATA = re.compile(</span><span class="s3">'[&quot;</span><span class="s4">\'</span><span class="s3">{}</span><span class="s4">\\</span><span class="s3">s]'</span><span class="s4">, </span><span class="s1">re.UNICODE)</span>

<span class="s1">ArffDenseDataType = Iterator[List]</span>
<span class="s1">ArffSparseDataType = Tuple[List</span><span class="s4">, </span><span class="s1">...]</span>


<span class="s4">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s0"># typing_extensions is available when mypy is installed</span>
    <span class="s4">from </span><span class="s1">typing_extensions </span><span class="s4">import </span><span class="s1">TypedDict</span>

    <span class="s4">class </span><span class="s1">ArffContainerType(TypedDict):</span>
        <span class="s1">description: str</span>
        <span class="s1">relation: str</span>
        <span class="s1">attributes: List</span>
        <span class="s1">data: Union[ArffDenseDataType</span><span class="s4">, </span><span class="s1">ArffSparseDataType]</span>

<span class="s4">else</span><span class="s1">:</span>
    <span class="s1">ArffContainerType = Dict[str</span><span class="s4">, </span><span class="s1">Any]</span>


<span class="s4">def </span><span class="s1">_build_re_values():</span>
    <span class="s1">quoted_re = </span><span class="s3">r''' 
                    &quot;      # open quote followed by zero or more of: 
                    (?: 
                        (?&lt;!\\)    # no additional backslash 
                        (?:\\\\)*  # maybe escaped backslashes 
                        \\&quot;        # escaped quote 
                    | 
                        \\[^&quot;]     # escaping a non-quote 
                    | 
                        [^&quot;\\]     # non-quote char 
                    )* 
                    &quot;      # close quote 
                    '''</span>
    <span class="s0"># a value is surrounded by &quot; or by ' or contains no quotables</span>
    <span class="s1">value_re = </span><span class="s3">r'''(?: 
        %s|          # a value may be surrounded by &quot; 
        %s|          # or by ' 
        [^,\s&quot;'{}]+  # or may contain no characters requiring quoting 
        )''' </span><span class="s1">% (quoted_re</span><span class="s4">,</span>
                <span class="s1">quoted_re.replace(</span><span class="s3">'&quot;'</span><span class="s4">, </span><span class="s3">&quot;'&quot;</span><span class="s1">))</span>

    <span class="s0"># This captures (value, error) groups. Because empty values are allowed,</span>
    <span class="s0"># we cannot just look for empty values to handle syntax errors.</span>
    <span class="s0"># We presume the line has had ',' prepended...</span>
    <span class="s1">dense = re.compile(</span><span class="s3">r'''(?x) 
        ,                # may follow ',' 
        \s* 
        ((?=,)|$|{value_re})  # empty or value 
        | 
        (\S.*)           # error 
        '''</span><span class="s1">.format(value_re=value_re))</span>

    <span class="s0"># This captures (key, value) groups and will have an empty key/value</span>
    <span class="s0"># in case of syntax errors.</span>
    <span class="s0"># It does not ensure that the line starts with '{' or ends with '}'.</span>
    <span class="s1">sparse = re.compile(</span><span class="s3">r'''(?x) 
        (?:^\s*\{|,)   # may follow ',', or '{' at line start 
        \s* 
        (\d+)          # attribute key 
        \s+ 
        (%(value_re)s) # value 
        | 
        (?!}\s*$)      # not an error if it's }$ 
        (?!^\s*{\s*}\s*$)  # not an error if it's ^{}$ 
        \S.*           # error 
        ''' </span><span class="s1">% {</span><span class="s3">'value_re'</span><span class="s1">: value_re})</span>
    <span class="s4">return </span><span class="s1">dense</span><span class="s4">, </span><span class="s1">sparse</span>



<span class="s1">_RE_DENSE_VALUES</span><span class="s4">, </span><span class="s1">_RE_SPARSE_KEY_VALUES = _build_re_values()</span>


<span class="s1">_ESCAPE_SUB_MAP = {</span>
    <span class="s3">'</span><span class="s4">\\\\</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'</span><span class="s4">\\</span><span class="s3">'</span><span class="s4">,</span>
    <span class="s3">'</span><span class="s4">\\</span><span class="s3">&quot;'</span><span class="s1">: </span><span class="s3">'&quot;'</span><span class="s4">,</span>
    <span class="s3">&quot;</span><span class="s4">\\</span><span class="s3">'&quot;</span><span class="s1">: </span><span class="s3">&quot;'&quot;</span><span class="s4">,</span>
    <span class="s3">'</span><span class="s4">\\</span><span class="s3">t'</span><span class="s1">: </span><span class="s3">'</span><span class="s4">\t</span><span class="s3">'</span><span class="s4">,</span>
    <span class="s3">'</span><span class="s4">\\</span><span class="s3">n'</span><span class="s1">: </span><span class="s3">'</span><span class="s4">\n</span><span class="s3">'</span><span class="s4">,</span>
    <span class="s3">'</span><span class="s4">\\</span><span class="s3">r'</span><span class="s1">: </span><span class="s3">'</span><span class="s4">\r</span><span class="s3">'</span><span class="s4">,</span>
    <span class="s3">'</span><span class="s4">\\</span><span class="s3">b'</span><span class="s1">: </span><span class="s3">'</span><span class="s4">\b</span><span class="s3">'</span><span class="s4">,</span>
    <span class="s3">'</span><span class="s4">\\</span><span class="s3">f'</span><span class="s1">: </span><span class="s3">'</span><span class="s4">\f</span><span class="s3">'</span><span class="s4">,</span>
    <span class="s3">'</span><span class="s4">\\</span><span class="s3">%'</span><span class="s1">: </span><span class="s3">'%'</span><span class="s4">,</span>
<span class="s1">}</span>
<span class="s1">_UNESCAPE_SUB_MAP = {chr(i): </span><span class="s3">'</span><span class="s4">\\</span><span class="s3">%03o' </span><span class="s1">% i </span><span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(</span><span class="s5">32</span><span class="s1">)}</span>
<span class="s1">_UNESCAPE_SUB_MAP.update({v: k </span><span class="s4">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v </span><span class="s4">in </span><span class="s1">_ESCAPE_SUB_MAP.items()})</span>
<span class="s1">_UNESCAPE_SUB_MAP[</span><span class="s3">''</span><span class="s1">] = </span><span class="s3">'</span><span class="s4">\\</span><span class="s3">'</span>
<span class="s1">_ESCAPE_SUB_MAP.update({</span><span class="s3">'</span><span class="s4">\\</span><span class="s3">%d' </span><span class="s1">% i: chr(i) </span><span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(</span><span class="s5">10</span><span class="s1">)})</span>


<span class="s4">def </span><span class="s1">_escape_sub_callback(match):</span>
    <span class="s1">s = match.group()</span>
    <span class="s4">if </span><span class="s1">len(s) == </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">_ESCAPE_SUB_MAP[s]</span>
        <span class="s4">except </span><span class="s1">KeyError:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Unsupported escape sequence: %s' </span><span class="s1">% s)</span>
    <span class="s4">if </span><span class="s1">s[</span><span class="s5">1</span><span class="s1">] == </span><span class="s3">'u'</span><span class="s1">:</span>
        <span class="s4">return </span><span class="s1">chr(int(s[</span><span class="s5">2</span><span class="s1">:]</span><span class="s4">, </span><span class="s5">16</span><span class="s1">))</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s4">return </span><span class="s1">chr(int(s[</span><span class="s5">1</span><span class="s1">:]</span><span class="s4">, </span><span class="s5">8</span><span class="s1">))</span>


<span class="s4">def </span><span class="s1">_unquote(v):</span>
    <span class="s4">if </span><span class="s1">v[:</span><span class="s5">1</span><span class="s1">] </span><span class="s4">in </span><span class="s1">(</span><span class="s3">'&quot;'</span><span class="s4">, </span><span class="s3">&quot;'&quot;</span><span class="s1">):</span>
        <span class="s4">return </span><span class="s1">re.sub(</span><span class="s3">r'\\([0-9]{1,3}|u[0-9a-f]{4}|.)'</span><span class="s4">, </span><span class="s1">_escape_sub_callback</span><span class="s4">,</span>
                      <span class="s1">v[</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s4">elif </span><span class="s1">v </span><span class="s4">in </span><span class="s1">(</span><span class="s3">'?'</span><span class="s4">, </span><span class="s3">''</span><span class="s1">):</span>
        <span class="s4">return None</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s4">return </span><span class="s1">v</span>


<span class="s4">def </span><span class="s1">_parse_values(s):</span>
    <span class="s2">'''(INTERNAL) Split a line into a list of values'''</span>
    <span class="s4">if not </span><span class="s1">_RE_NONTRIVIAL_DATA.search(s):</span>
        <span class="s0"># Fast path for trivial cases (unfortunately we have to handle missing</span>
        <span class="s0"># values because of the empty string case :(.)</span>
        <span class="s4">return </span><span class="s1">[</span><span class="s4">None if </span><span class="s1">s </span><span class="s4">in </span><span class="s1">(</span><span class="s3">'?'</span><span class="s4">, </span><span class="s3">''</span><span class="s1">) </span><span class="s4">else </span><span class="s1">s</span>
                <span class="s4">for </span><span class="s1">s </span><span class="s4">in </span><span class="s1">next(csv.reader([s]))]</span>

    <span class="s0"># _RE_DENSE_VALUES tokenizes despite quoting, whitespace, etc.</span>
    <span class="s1">values</span><span class="s4">, </span><span class="s1">errors = zip(*_RE_DENSE_VALUES.findall(</span><span class="s3">',' </span><span class="s1">+ s))</span>
    <span class="s4">if not </span><span class="s1">any(errors):</span>
        <span class="s4">return </span><span class="s1">[_unquote(v) </span><span class="s4">for </span><span class="s1">v </span><span class="s4">in </span><span class="s1">values]</span>
    <span class="s4">if </span><span class="s1">_RE_SPARSE_LINE.match(s):</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">{int(k): _unquote(v)</span>
                    <span class="s4">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v </span><span class="s4">in </span><span class="s1">_RE_SPARSE_KEY_VALUES.findall(s)}</span>
        <span class="s4">except </span><span class="s1">ValueError:</span>
            <span class="s0"># an ARFF syntax error in sparse data</span>
            <span class="s4">for </span><span class="s1">match </span><span class="s4">in </span><span class="s1">_RE_SPARSE_KEY_VALUES.finditer(s):</span>
                <span class="s4">if not </span><span class="s1">match.group(</span><span class="s5">1</span><span class="s1">):</span>
                    <span class="s4">raise </span><span class="s1">BadLayout(</span><span class="s3">'Error parsing %r' </span><span class="s1">% match.group())</span>
            <span class="s4">raise </span><span class="s1">BadLayout(</span><span class="s3">'Unknown parsing error'</span><span class="s1">)</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s0"># an ARFF syntax error</span>
        <span class="s4">for </span><span class="s1">match </span><span class="s4">in </span><span class="s1">_RE_DENSE_VALUES.finditer(s):</span>
            <span class="s4">if </span><span class="s1">match.group(</span><span class="s5">2</span><span class="s1">):</span>
                <span class="s4">raise </span><span class="s1">BadLayout(</span><span class="s3">'Error parsing %r' </span><span class="s1">% match.group())</span>
        <span class="s4">raise </span><span class="s1">BadLayout(</span><span class="s3">'Unknown parsing error'</span><span class="s1">)</span>


<span class="s1">DENSE = </span><span class="s5">0     </span><span class="s0"># Constant value representing a dense matrix</span>
<span class="s1">COO = </span><span class="s5">1       </span><span class="s0"># Constant value representing a sparse matrix in coordinate format</span>
<span class="s1">LOD = </span><span class="s5">2       </span><span class="s0"># Constant value representing a sparse matrix in list of</span>
              <span class="s0"># dictionaries format</span>
<span class="s1">DENSE_GEN = </span><span class="s5">3 </span><span class="s0"># Generator of dictionaries</span>
<span class="s1">LOD_GEN = </span><span class="s5">4   </span><span class="s0"># Generator of dictionaries</span>
<span class="s1">_SUPPORTED_DATA_STRUCTURES = [DENSE</span><span class="s4">, </span><span class="s1">COO</span><span class="s4">, </span><span class="s1">LOD</span><span class="s4">, </span><span class="s1">DENSE_GEN</span><span class="s4">, </span><span class="s1">LOD_GEN]</span>


<span class="s0"># EXCEPTIONS ==================================================================</span>
<span class="s4">class </span><span class="s1">ArffException(Exception):</span>
    <span class="s1">message: Optional[str] = </span><span class="s4">None</span>

    <span class="s4">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self.line = -</span><span class="s5">1</span>

    <span class="s4">def </span><span class="s1">__str__(self):</span>
        <span class="s4">return </span><span class="s1">self.message%self.line</span>

<span class="s4">class </span><span class="s1">BadRelationFormat(ArffException):</span>
    <span class="s2">'''Error raised when the relation declaration is in an invalid format.'''</span>
    <span class="s1">message = </span><span class="s3">'Bad @RELATION format, at line %d.'</span>

<span class="s4">class </span><span class="s1">BadAttributeFormat(ArffException):</span>
    <span class="s2">'''Error raised when some attribute declaration is in an invalid format.'''</span>
    <span class="s1">message = </span><span class="s3">'Bad @ATTRIBUTE format, at line %d.'</span>

<span class="s4">class </span><span class="s1">BadDataFormat(ArffException):</span>
    <span class="s2">'''Error raised when some data instance is in an invalid format.'''</span>
    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">value):</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.message = (</span>
            <span class="s3">'Bad @DATA instance format in line %d: ' </span><span class="s1">+</span>
            <span class="s1">(</span><span class="s3">'%s' </span><span class="s1">% value)</span>
        <span class="s1">)</span>

<span class="s4">class </span><span class="s1">BadAttributeType(ArffException):</span>
    <span class="s2">'''Error raised when some invalid type is provided into the attribute 
    declaration.'''</span>
    <span class="s1">message = </span><span class="s3">'Bad @ATTRIBUTE type, at line %d.'</span>

<span class="s4">class </span><span class="s1">BadAttributeName(ArffException):</span>
    <span class="s2">'''Error raised when an attribute name is provided twice the attribute 
    declaration.'''</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">value</span><span class="s4">, </span><span class="s1">value2):</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.message = (</span>
            <span class="s1">(</span><span class="s3">'Bad @ATTRIBUTE name %s at line' </span><span class="s1">% value) +</span>
            <span class="s3">' %d, this name is already in use in line' </span><span class="s1">+</span>
            <span class="s1">(</span><span class="s3">' %d.' </span><span class="s1">% value2)</span>
        <span class="s1">)</span>

<span class="s4">class </span><span class="s1">BadNominalValue(ArffException):</span>
    <span class="s2">'''Error raised when a value in used in some data instance but is not 
    declared into it respective attribute declaration.'''</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">value):</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.message = (</span>
            <span class="s1">(</span><span class="s3">'Data value %s not found in nominal declaration, ' </span><span class="s1">% value)</span>
            <span class="s1">+ </span><span class="s3">'at line %d.'</span>
        <span class="s1">)</span>

<span class="s4">class </span><span class="s1">BadNominalFormatting(ArffException):</span>
    <span class="s2">'''Error raised when a nominal value with space is not properly quoted.'''</span>
    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">value):</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.message = (</span>
            <span class="s1">(</span><span class="s3">'Nominal data value &quot;%s&quot; not properly quoted in line ' </span><span class="s1">% value) +</span>
            <span class="s3">'%d.'</span>
        <span class="s1">)</span>

<span class="s4">class </span><span class="s1">BadNumericalValue(ArffException):</span>
    <span class="s2">'''Error raised when and invalid numerical value is used in some data 
    instance.'''</span>
    <span class="s1">message = </span><span class="s3">'Invalid numerical value, at line %d.'</span>

<span class="s4">class </span><span class="s1">BadStringValue(ArffException):</span>
    <span class="s2">'''Error raise when a string contains space but is not quoted.'''</span>
    <span class="s1">message = </span><span class="s3">'Invalid string value at line %d.'</span>

<span class="s4">class </span><span class="s1">BadLayout(ArffException):</span>
    <span class="s2">'''Error raised when the layout of the ARFF file has something wrong.'''</span>
    <span class="s1">message = </span><span class="s3">'Invalid layout of the ARFF file, at line %d.'</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">msg=</span><span class="s3">''</span><span class="s1">):</span>
        <span class="s1">super().__init__()</span>
        <span class="s4">if </span><span class="s1">msg:</span>
            <span class="s1">self.message = BadLayout.message + </span><span class="s3">' ' </span><span class="s1">+ msg.replace(</span><span class="s3">'%'</span><span class="s4">, </span><span class="s3">'%%'</span><span class="s1">)</span>


<span class="s4">class </span><span class="s1">BadObject(ArffException):</span>
    <span class="s2">'''Error raised when the object representing the ARFF file has something 
    wrong.'''</span>
    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">msg=</span><span class="s3">'Invalid object.'</span><span class="s1">):</span>
        <span class="s1">self.msg = msg</span>

    <span class="s4">def </span><span class="s1">__str__(self):</span>
        <span class="s4">return </span><span class="s3">'%s' </span><span class="s1">% self.msg</span>

<span class="s0"># =============================================================================</span>

<span class="s0"># INTERNAL ====================================================================</span>
<span class="s4">def </span><span class="s1">_unescape_sub_callback(match):</span>
    <span class="s4">return </span><span class="s1">_UNESCAPE_SUB_MAP[match.group()]</span>


<span class="s4">def </span><span class="s1">encode_string(s):</span>
    <span class="s4">if </span><span class="s1">_RE_QUOTE_CHARS.search(s):</span>
        <span class="s4">return </span><span class="s3">&quot;'%s'&quot; </span><span class="s1">% _RE_ESCAPE_CHARS.sub(_unescape_sub_callback</span><span class="s4">, </span><span class="s1">s)</span>
    <span class="s4">return </span><span class="s1">s</span>


<span class="s4">class </span><span class="s1">EncodedNominalConversor:</span>
    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">values):</span>
        <span class="s1">self.values = {v: i </span><span class="s4">for </span><span class="s1">i</span><span class="s4">, </span><span class="s1">v </span><span class="s4">in </span><span class="s1">enumerate(values)}</span>
        <span class="s1">self.values[</span><span class="s5">0</span><span class="s1">] = </span><span class="s5">0</span>

    <span class="s4">def </span><span class="s1">__call__(self</span><span class="s4">, </span><span class="s1">value):</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">self.values[value]</span>
        <span class="s4">except </span><span class="s1">KeyError:</span>
            <span class="s4">raise </span><span class="s1">BadNominalValue(value)</span>


<span class="s4">class </span><span class="s1">NominalConversor:</span>
    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">values):</span>
        <span class="s1">self.values = set(values)</span>
        <span class="s1">self.zero_value = values[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s4">def </span><span class="s1">__call__(self</span><span class="s4">, </span><span class="s1">value):</span>
        <span class="s4">if </span><span class="s1">value </span><span class="s4">not in </span><span class="s1">self.values:</span>
            <span class="s4">if </span><span class="s1">value == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s0"># Sparse decode</span>
                <span class="s0"># See issue #52: nominals should take their first value when</span>
                <span class="s0"># unspecified in a sparse matrix. Naturally, this is consistent</span>
                <span class="s0"># with EncodedNominalConversor.</span>
                <span class="s4">return </span><span class="s1">self.zero_value</span>
            <span class="s4">raise </span><span class="s1">BadNominalValue(value)</span>
        <span class="s4">return </span><span class="s1">str(value)</span>


<span class="s4">class </span><span class="s1">DenseGeneratorData:</span>
    <span class="s2">'''Internal helper class to allow for different matrix types without 
    making the code a huge collection of if statements.'''</span>

    <span class="s4">def </span><span class="s1">decode_rows(self</span><span class="s4">, </span><span class="s1">stream</span><span class="s4">, </span><span class="s1">conversors):</span>
        <span class="s4">for </span><span class="s1">row </span><span class="s4">in </span><span class="s1">stream:</span>
            <span class="s1">values = _parse_values(row)</span>

            <span class="s4">if </span><span class="s1">isinstance(values</span><span class="s4">, </span><span class="s1">dict):</span>
                <span class="s4">if </span><span class="s1">values </span><span class="s4">and </span><span class="s1">max(values) &gt;= len(conversors):</span>
                    <span class="s4">raise </span><span class="s1">BadDataFormat(row)</span>
                <span class="s0"># XXX: int 0 is used for implicit values, not '0'</span>
                <span class="s1">values = [values[i] </span><span class="s4">if </span><span class="s1">i </span><span class="s4">in </span><span class="s1">values </span><span class="s4">else </span><span class="s5">0 </span><span class="s4">for </span><span class="s1">i </span><span class="s4">in</span>
                          <span class="s1">range(len(conversors))]</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s4">if </span><span class="s1">len(values) != len(conversors):</span>
                    <span class="s4">raise </span><span class="s1">BadDataFormat(row)</span>

            <span class="s4">yield </span><span class="s1">self._decode_values(values</span><span class="s4">, </span><span class="s1">conversors)</span>

    <span class="s1">@staticmethod</span>
    <span class="s4">def </span><span class="s1">_decode_values(values</span><span class="s4">, </span><span class="s1">conversors):</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">values = [</span><span class="s4">None if </span><span class="s1">value </span><span class="s4">is None else </span><span class="s1">conversor(value)</span>
                      <span class="s4">for </span><span class="s1">conversor</span><span class="s4">, </span><span class="s1">value</span>
                      <span class="s4">in </span><span class="s1">zip(conversors</span><span class="s4">, </span><span class="s1">values)]</span>
        <span class="s4">except </span><span class="s1">ValueError </span><span class="s4">as </span><span class="s1">exc:</span>
            <span class="s4">if </span><span class="s3">'float: ' </span><span class="s4">in </span><span class="s1">str(exc):</span>
                <span class="s4">raise </span><span class="s1">BadNumericalValue()</span>
        <span class="s4">return </span><span class="s1">values</span>

    <span class="s4">def </span><span class="s1">encode_data(self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">, </span><span class="s1">attributes):</span>
        <span class="s2">'''(INTERNAL) Encodes a line of data. 
 
        Data instances follow the csv format, i.e, attribute values are 
        delimited by commas. After converted from csv. 
 
        :param data: a list of values. 
        :param attributes: a list of attributes. Used to check if data is valid. 
        :return: a string with the encoded data line. 
        '''</span>
        <span class="s1">current_row = </span><span class="s5">0</span>

        <span class="s4">for </span><span class="s1">inst </span><span class="s4">in </span><span class="s1">data:</span>
            <span class="s4">if </span><span class="s1">len(inst) != len(attributes):</span>
                <span class="s4">raise </span><span class="s1">BadObject(</span>
                    <span class="s3">'Instance %d has %d attributes, expected %d' </span><span class="s1">%</span>
                     <span class="s1">(current_row</span><span class="s4">, </span><span class="s1">len(inst)</span><span class="s4">, </span><span class="s1">len(attributes))</span>
                <span class="s1">)</span>

            <span class="s1">new_data = []</span>
            <span class="s4">for </span><span class="s1">value </span><span class="s4">in </span><span class="s1">inst:</span>
                <span class="s4">if </span><span class="s1">value </span><span class="s4">is None or </span><span class="s1">value == </span><span class="s3">'' </span><span class="s4">or </span><span class="s1">value != value:</span>
                    <span class="s1">s = </span><span class="s3">'?'</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s1">s = encode_string(str(value))</span>
                <span class="s1">new_data.append(s)</span>

            <span class="s1">current_row += </span><span class="s5">1</span>
            <span class="s4">yield </span><span class="s3">','</span><span class="s1">.join(new_data)</span>


<span class="s4">class </span><span class="s1">_DataListMixin:</span>
    <span class="s2">&quot;&quot;&quot;Mixin to return a list from decode_rows instead of a generator&quot;&quot;&quot;</span>
    <span class="s4">def </span><span class="s1">decode_rows(self</span><span class="s4">, </span><span class="s1">stream</span><span class="s4">, </span><span class="s1">conversors):</span>
        <span class="s4">return </span><span class="s1">list(super().decode_rows(stream</span><span class="s4">, </span><span class="s1">conversors))</span>


<span class="s4">class </span><span class="s1">Data(_DataListMixin</span><span class="s4">, </span><span class="s1">DenseGeneratorData):</span>
    <span class="s4">pass</span>


<span class="s4">class </span><span class="s1">COOData:</span>
    <span class="s4">def </span><span class="s1">decode_rows(self</span><span class="s4">, </span><span class="s1">stream</span><span class="s4">, </span><span class="s1">conversors):</span>
        <span class="s1">data</span><span class="s4">, </span><span class="s1">rows</span><span class="s4">, </span><span class="s1">cols = []</span><span class="s4">, </span><span class="s1">[]</span><span class="s4">, </span><span class="s1">[]</span>
        <span class="s4">for </span><span class="s1">i</span><span class="s4">, </span><span class="s1">row </span><span class="s4">in </span><span class="s1">enumerate(stream):</span>
            <span class="s1">values = _parse_values(row)</span>
            <span class="s4">if not </span><span class="s1">isinstance(values</span><span class="s4">, </span><span class="s1">dict):</span>
                <span class="s4">raise </span><span class="s1">BadLayout()</span>
            <span class="s4">if not </span><span class="s1">values:</span>
                <span class="s4">continue</span>
            <span class="s1">row_cols</span><span class="s4">, </span><span class="s1">values = zip(*sorted(values.items()))</span>
            <span class="s4">try</span><span class="s1">:</span>
                <span class="s1">values = [value </span><span class="s4">if </span><span class="s1">value </span><span class="s4">is None else </span><span class="s1">conversors[key](value)</span>
                          <span class="s4">for </span><span class="s1">key</span><span class="s4">, </span><span class="s1">value </span><span class="s4">in </span><span class="s1">zip(row_cols</span><span class="s4">, </span><span class="s1">values)]</span>
            <span class="s4">except </span><span class="s1">ValueError </span><span class="s4">as </span><span class="s1">exc:</span>
                <span class="s4">if </span><span class="s3">'float: ' </span><span class="s4">in </span><span class="s1">str(exc):</span>
                    <span class="s4">raise </span><span class="s1">BadNumericalValue()</span>
                <span class="s4">raise</span>
            <span class="s4">except </span><span class="s1">IndexError:</span>
                <span class="s0"># conversor out of range</span>
                <span class="s4">raise </span><span class="s1">BadDataFormat(row)</span>

            <span class="s1">data.extend(values)</span>
            <span class="s1">rows.extend([i] * len(values))</span>
            <span class="s1">cols.extend(row_cols)</span>

        <span class="s4">return </span><span class="s1">data</span><span class="s4">, </span><span class="s1">rows</span><span class="s4">, </span><span class="s1">cols</span>

    <span class="s4">def </span><span class="s1">encode_data(self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">, </span><span class="s1">attributes):</span>
        <span class="s1">num_attributes = len(attributes)</span>
        <span class="s1">new_data = []</span>
        <span class="s1">current_row = </span><span class="s5">0</span>

        <span class="s1">row = data.row</span>
        <span class="s1">col = data.col</span>
        <span class="s1">data = data.data</span>

        <span class="s0"># Check if the rows are sorted</span>
        <span class="s4">if not </span><span class="s1">all(row[i] &lt;= row[i + </span><span class="s5">1</span><span class="s1">] </span><span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(len(row) - </span><span class="s5">1</span><span class="s1">)):</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;liac-arff can only output COO matrices with &quot;</span>
                             <span class="s3">&quot;sorted rows.&quot;</span><span class="s1">)</span>

        <span class="s4">for </span><span class="s1">v</span><span class="s4">, </span><span class="s1">col</span><span class="s4">, </span><span class="s1">row </span><span class="s4">in </span><span class="s1">zip(data</span><span class="s4">, </span><span class="s1">col</span><span class="s4">, </span><span class="s1">row):</span>
            <span class="s4">if </span><span class="s1">row &gt; current_row:</span>
                <span class="s0"># Add empty rows if necessary</span>
                <span class="s4">while </span><span class="s1">current_row &lt; row:</span>
                    <span class="s4">yield </span><span class="s3">&quot; &quot;</span><span class="s1">.join([</span><span class="s3">&quot;{&quot;</span><span class="s4">, </span><span class="s3">','</span><span class="s1">.join(new_data)</span><span class="s4">, </span><span class="s3">&quot;}&quot;</span><span class="s1">])</span>
                    <span class="s1">new_data = []</span>
                    <span class="s1">current_row += </span><span class="s5">1</span>

            <span class="s4">if </span><span class="s1">col &gt;= num_attributes:</span>
                <span class="s4">raise </span><span class="s1">BadObject(</span>
                    <span class="s3">'Instance %d has at least %d attributes, expected %d' </span><span class="s1">%</span>
                    <span class="s1">(current_row</span><span class="s4">, </span><span class="s1">col + </span><span class="s5">1</span><span class="s4">, </span><span class="s1">num_attributes)</span>
                <span class="s1">)</span>

            <span class="s4">if </span><span class="s1">v </span><span class="s4">is None or </span><span class="s1">v == </span><span class="s3">'' </span><span class="s4">or </span><span class="s1">v != v:</span>
                <span class="s1">s = </span><span class="s3">'?'</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">s = encode_string(str(v))</span>
            <span class="s1">new_data.append(</span><span class="s3">&quot;%d %s&quot; </span><span class="s1">% (col</span><span class="s4">, </span><span class="s1">s))</span>

        <span class="s4">yield </span><span class="s3">&quot; &quot;</span><span class="s1">.join([</span><span class="s3">&quot;{&quot;</span><span class="s4">, </span><span class="s3">','</span><span class="s1">.join(new_data)</span><span class="s4">, </span><span class="s3">&quot;}&quot;</span><span class="s1">])</span>

<span class="s4">class </span><span class="s1">LODGeneratorData:</span>
    <span class="s4">def </span><span class="s1">decode_rows(self</span><span class="s4">, </span><span class="s1">stream</span><span class="s4">, </span><span class="s1">conversors):</span>
        <span class="s4">for </span><span class="s1">row </span><span class="s4">in </span><span class="s1">stream:</span>
            <span class="s1">values = _parse_values(row)</span>

            <span class="s4">if not </span><span class="s1">isinstance(values</span><span class="s4">, </span><span class="s1">dict):</span>
                <span class="s4">raise </span><span class="s1">BadLayout()</span>
            <span class="s4">try</span><span class="s1">:</span>
                <span class="s4">yield </span><span class="s1">{key: </span><span class="s4">None if </span><span class="s1">value </span><span class="s4">is None else </span><span class="s1">conversors[key](value)</span>
                       <span class="s4">for </span><span class="s1">key</span><span class="s4">, </span><span class="s1">value </span><span class="s4">in </span><span class="s1">values.items()}</span>
            <span class="s4">except </span><span class="s1">ValueError </span><span class="s4">as </span><span class="s1">exc:</span>
                <span class="s4">if </span><span class="s3">'float: ' </span><span class="s4">in </span><span class="s1">str(exc):</span>
                    <span class="s4">raise </span><span class="s1">BadNumericalValue()</span>
                <span class="s4">raise</span>
            <span class="s4">except </span><span class="s1">IndexError:</span>
                <span class="s0"># conversor out of range</span>
                <span class="s4">raise </span><span class="s1">BadDataFormat(row)</span>

    <span class="s4">def </span><span class="s1">encode_data(self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">, </span><span class="s1">attributes):</span>
        <span class="s1">current_row = </span><span class="s5">0</span>

        <span class="s1">num_attributes = len(attributes)</span>
        <span class="s4">for </span><span class="s1">row </span><span class="s4">in </span><span class="s1">data:</span>
            <span class="s1">new_data = []</span>

            <span class="s4">if </span><span class="s1">len(row) &gt; </span><span class="s5">0 </span><span class="s4">and </span><span class="s1">max(row) &gt;= num_attributes:</span>
                <span class="s4">raise </span><span class="s1">BadObject(</span>
                    <span class="s3">'Instance %d has %d attributes, expected %d' </span><span class="s1">%</span>
                    <span class="s1">(current_row</span><span class="s4">, </span><span class="s1">max(row) + </span><span class="s5">1</span><span class="s4">, </span><span class="s1">num_attributes)</span>
                <span class="s1">)</span>

            <span class="s4">for </span><span class="s1">col </span><span class="s4">in </span><span class="s1">sorted(row):</span>
                <span class="s1">v = row[col]</span>
                <span class="s4">if </span><span class="s1">v </span><span class="s4">is None or </span><span class="s1">v == </span><span class="s3">'' </span><span class="s4">or </span><span class="s1">v != v:</span>
                    <span class="s1">s = </span><span class="s3">'?'</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s1">s = encode_string(str(v))</span>
                <span class="s1">new_data.append(</span><span class="s3">&quot;%d %s&quot; </span><span class="s1">% (col</span><span class="s4">, </span><span class="s1">s))</span>

            <span class="s1">current_row += </span><span class="s5">1</span>
            <span class="s4">yield </span><span class="s3">&quot; &quot;</span><span class="s1">.join([</span><span class="s3">&quot;{&quot;</span><span class="s4">, </span><span class="s3">','</span><span class="s1">.join(new_data)</span><span class="s4">, </span><span class="s3">&quot;}&quot;</span><span class="s1">])</span>

<span class="s4">class </span><span class="s1">LODData(_DataListMixin</span><span class="s4">, </span><span class="s1">LODGeneratorData):</span>
    <span class="s4">pass</span>


<span class="s4">def </span><span class="s1">_get_data_object_for_decoding(matrix_type):</span>
    <span class="s4">if </span><span class="s1">matrix_type == DENSE:</span>
        <span class="s4">return </span><span class="s1">Data()</span>
    <span class="s4">elif </span><span class="s1">matrix_type == COO:</span>
        <span class="s4">return </span><span class="s1">COOData()</span>
    <span class="s4">elif </span><span class="s1">matrix_type == LOD:</span>
        <span class="s4">return </span><span class="s1">LODData()</span>
    <span class="s4">elif </span><span class="s1">matrix_type == DENSE_GEN:</span>
        <span class="s4">return </span><span class="s1">DenseGeneratorData()</span>
    <span class="s4">elif </span><span class="s1">matrix_type == LOD_GEN:</span>
        <span class="s4">return </span><span class="s1">LODGeneratorData()</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Matrix type %s not supported.&quot; </span><span class="s1">% str(matrix_type))</span>

<span class="s4">def </span><span class="s1">_get_data_object_for_encoding(matrix):</span>
    <span class="s0"># Probably a scipy.sparse</span>
    <span class="s4">if </span><span class="s1">hasattr(matrix</span><span class="s4">, </span><span class="s3">'format'</span><span class="s1">):</span>
        <span class="s4">if </span><span class="s1">matrix.format == </span><span class="s3">'coo'</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">COOData()</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Cannot guess matrix format!'</span><span class="s1">)</span>
    <span class="s4">elif </span><span class="s1">isinstance(matrix[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">, </span><span class="s1">dict):</span>
        <span class="s4">return </span><span class="s1">LODData()</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s4">return </span><span class="s1">Data()</span>

<span class="s0"># =============================================================================</span>

<span class="s0"># ADVANCED INTERFACE ==========================================================</span>
<span class="s4">class </span><span class="s1">ArffDecoder:</span>
    <span class="s2">'''An ARFF decoder.'''</span>

    <span class="s4">def </span><span class="s1">__init__(self):</span>
        <span class="s2">'''Constructor.'''</span>
        <span class="s1">self._conversors = []</span>
        <span class="s1">self._current_line = </span><span class="s5">0</span>

    <span class="s4">def </span><span class="s1">_decode_comment(self</span><span class="s4">, </span><span class="s1">s):</span>
        <span class="s2">'''(INTERNAL) Decodes a comment line. 
 
        Comments are single line strings starting, obligatorily, with the ``%`` 
        character, and can have any symbol, including whitespaces or special 
        characters. 
 
        This method must receive a normalized string, i.e., a string without 
        padding, including the &quot;\r\n&quot; characters. 
 
        :param s: a normalized string. 
        :return: a string with the decoded comment. 
        '''</span>
        <span class="s1">res = re.sub(</span><span class="s3">r'^\%( )?'</span><span class="s4">, </span><span class="s3">''</span><span class="s4">, </span><span class="s1">s)</span>
        <span class="s4">return </span><span class="s1">res</span>

    <span class="s4">def </span><span class="s1">_decode_relation(self</span><span class="s4">, </span><span class="s1">s):</span>
        <span class="s2">'''(INTERNAL) Decodes a relation line. 
 
        The relation declaration is a line with the format ``@RELATION 
        &lt;relation-name&gt;``, where ``relation-name`` is a string. The string must 
        start with alphabetic character and must be quoted if the name includes 
        spaces, otherwise this method will raise a `BadRelationFormat` exception. 
 
        This method must receive a normalized string, i.e., a string without 
        padding, including the &quot;\r\n&quot; characters. 
 
        :param s: a normalized string. 
        :return: a string with the decoded relation name. 
        '''</span>
        <span class="s1">_</span><span class="s4">, </span><span class="s1">v = s.split(</span><span class="s3">' '</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">v = v.strip()</span>

        <span class="s4">if not </span><span class="s1">_RE_RELATION.match(v):</span>
            <span class="s4">raise </span><span class="s1">BadRelationFormat()</span>

        <span class="s1">res = str(v.strip(</span><span class="s3">'&quot;</span><span class="s4">\'</span><span class="s3">'</span><span class="s1">))</span>
        <span class="s4">return </span><span class="s1">res</span>

    <span class="s4">def </span><span class="s1">_decode_attribute(self</span><span class="s4">, </span><span class="s1">s):</span>
        <span class="s2">'''(INTERNAL) Decodes an attribute line. 
 
        The attribute is the most complex declaration in an arff file. All 
        attributes must follow the template:: 
 
             @attribute &lt;attribute-name&gt; &lt;datatype&gt; 
 
        where ``attribute-name`` is a string, quoted if the name contains any 
        whitespace, and ``datatype`` can be: 
 
        - Numerical attributes as ``NUMERIC``, ``INTEGER`` or ``REAL``. 
        - Strings as ``STRING``. 
        - Dates (NOT IMPLEMENTED). 
        - Nominal attributes with format: 
 
            {&lt;nominal-name1&gt;, &lt;nominal-name2&gt;, &lt;nominal-name3&gt;, ...} 
 
        The nominal names follow the rules for the attribute names, i.e., they 
        must be quoted if the name contains whitespaces. 
 
        This method must receive a normalized string, i.e., a string without 
        padding, including the &quot;\r\n&quot; characters. 
 
        :param s: a normalized string. 
        :return: a tuple (ATTRIBUTE_NAME, TYPE_OR_VALUES). 
        '''</span>
        <span class="s1">_</span><span class="s4">, </span><span class="s1">v = s.split(</span><span class="s3">' '</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">v = v.strip()</span>

        <span class="s0"># Verify the general structure of declaration</span>
        <span class="s1">m = _RE_ATTRIBUTE.match(v)</span>
        <span class="s4">if not </span><span class="s1">m:</span>
            <span class="s4">raise </span><span class="s1">BadAttributeFormat()</span>

        <span class="s0"># Extracts the raw name and type</span>
        <span class="s1">name</span><span class="s4">, </span><span class="s1">type_ = m.groups()</span>

        <span class="s0"># Extracts the final name</span>
        <span class="s1">name = str(name.strip(</span><span class="s3">'&quot;</span><span class="s4">\'</span><span class="s3">'</span><span class="s1">))</span>

        <span class="s0"># Extracts the final type</span>
        <span class="s4">if </span><span class="s1">type_[:</span><span class="s5">1</span><span class="s1">] == </span><span class="s3">&quot;{&quot; </span><span class="s4">and </span><span class="s1">type_[-</span><span class="s5">1</span><span class="s1">:] == </span><span class="s3">&quot;}&quot;</span><span class="s1">:</span>
            <span class="s4">try</span><span class="s1">:</span>
                <span class="s1">type_ = _parse_values(type_.strip(</span><span class="s3">'{} '</span><span class="s1">))</span>
            <span class="s4">except </span><span class="s1">Exception:</span>
                <span class="s4">raise </span><span class="s1">BadAttributeType()</span>
            <span class="s4">if </span><span class="s1">isinstance(type_</span><span class="s4">, </span><span class="s1">dict):</span>
                <span class="s4">raise </span><span class="s1">BadAttributeType()</span>

        <span class="s4">else</span><span class="s1">:</span>
            <span class="s0"># If not nominal, verify the type name</span>
            <span class="s1">type_ = str(type_).upper()</span>
            <span class="s4">if </span><span class="s1">type_ </span><span class="s4">not in </span><span class="s1">[</span><span class="s3">'NUMERIC'</span><span class="s4">, </span><span class="s3">'REAL'</span><span class="s4">, </span><span class="s3">'INTEGER'</span><span class="s4">, </span><span class="s3">'STRING'</span><span class="s1">]:</span>
                <span class="s4">raise </span><span class="s1">BadAttributeType()</span>

        <span class="s4">return </span><span class="s1">(name</span><span class="s4">, </span><span class="s1">type_)</span>

    <span class="s4">def </span><span class="s1">_decode(self</span><span class="s4">, </span><span class="s1">s</span><span class="s4">, </span><span class="s1">encode_nominal=</span><span class="s4">False, </span><span class="s1">matrix_type=DENSE):</span>
        <span class="s2">'''Do the job the ``encode``.'''</span>

        <span class="s0"># Make sure this method is idempotent</span>
        <span class="s1">self._current_line = </span><span class="s5">0</span>

        <span class="s0"># If string, convert to a list of lines</span>
        <span class="s4">if </span><span class="s1">isinstance(s</span><span class="s4">, </span><span class="s1">str):</span>
            <span class="s1">s = s.strip(</span><span class="s3">'</span><span class="s4">\r\n </span><span class="s3">'</span><span class="s1">).replace(</span><span class="s3">'</span><span class="s4">\r\n</span><span class="s3">'</span><span class="s4">, </span><span class="s3">'</span><span class="s4">\n</span><span class="s3">'</span><span class="s1">).split(</span><span class="s3">'</span><span class="s4">\n</span><span class="s3">'</span><span class="s1">)</span>

        <span class="s0"># Create the return object</span>
        <span class="s1">obj: ArffContainerType = {</span>
            <span class="s3">'description'</span><span class="s1">: </span><span class="s3">''</span><span class="s4">,</span>
            <span class="s3">'relation'</span><span class="s1">: </span><span class="s3">''</span><span class="s4">,</span>
            <span class="s3">'attributes'</span><span class="s1">: []</span><span class="s4">,</span>
            <span class="s3">'data'</span><span class="s1">: []</span>
        <span class="s1">}</span>
        <span class="s1">attribute_names = {}</span>

        <span class="s0"># Create the data helper object</span>
        <span class="s1">data = _get_data_object_for_decoding(matrix_type)</span>

        <span class="s0"># Read all lines</span>
        <span class="s1">STATE = _TK_DESCRIPTION</span>
        <span class="s1">s = iter(s)</span>
        <span class="s4">for </span><span class="s1">row </span><span class="s4">in </span><span class="s1">s:</span>
            <span class="s1">self._current_line += </span><span class="s5">1</span>
            <span class="s0"># Ignore empty lines</span>
            <span class="s1">row = row.strip(</span><span class="s3">' </span><span class="s4">\r\n</span><span class="s3">'</span><span class="s1">)</span>
            <span class="s4">if not </span><span class="s1">row: </span><span class="s4">continue</span>

            <span class="s1">u_row = row.upper()</span>

            <span class="s0"># DESCRIPTION -----------------------------------------------------</span>
            <span class="s4">if </span><span class="s1">u_row.startswith(_TK_DESCRIPTION) </span><span class="s4">and </span><span class="s1">STATE == _TK_DESCRIPTION:</span>
                <span class="s1">obj[</span><span class="s3">'description'</span><span class="s1">] += self._decode_comment(row) + </span><span class="s3">'</span><span class="s4">\n</span><span class="s3">'</span>
            <span class="s0"># -----------------------------------------------------------------</span>

            <span class="s0"># RELATION --------------------------------------------------------</span>
            <span class="s4">elif </span><span class="s1">u_row.startswith(_TK_RELATION):</span>
                <span class="s4">if </span><span class="s1">STATE != _TK_DESCRIPTION:</span>
                    <span class="s4">raise </span><span class="s1">BadLayout()</span>

                <span class="s1">STATE = _TK_RELATION</span>
                <span class="s1">obj[</span><span class="s3">'relation'</span><span class="s1">] = self._decode_relation(row)</span>
            <span class="s0"># -----------------------------------------------------------------</span>

            <span class="s0"># ATTRIBUTE -------------------------------------------------------</span>
            <span class="s4">elif </span><span class="s1">u_row.startswith(_TK_ATTRIBUTE):</span>
                <span class="s4">if </span><span class="s1">STATE != _TK_RELATION </span><span class="s4">and </span><span class="s1">STATE != _TK_ATTRIBUTE:</span>
                    <span class="s4">raise </span><span class="s1">BadLayout()</span>

                <span class="s1">STATE = _TK_ATTRIBUTE</span>

                <span class="s1">attr = self._decode_attribute(row)</span>
                <span class="s4">if </span><span class="s1">attr[</span><span class="s5">0</span><span class="s1">] </span><span class="s4">in </span><span class="s1">attribute_names:</span>
                    <span class="s4">raise </span><span class="s1">BadAttributeName(attr[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">, </span><span class="s1">attribute_names[attr[</span><span class="s5">0</span><span class="s1">]])</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s1">attribute_names[attr[</span><span class="s5">0</span><span class="s1">]] = self._current_line</span>
                <span class="s1">obj[</span><span class="s3">'attributes'</span><span class="s1">].append(attr)</span>

                <span class="s4">if </span><span class="s1">isinstance(attr[</span><span class="s5">1</span><span class="s1">]</span><span class="s4">, </span><span class="s1">(list</span><span class="s4">, </span><span class="s1">tuple)):</span>
                    <span class="s4">if </span><span class="s1">encode_nominal:</span>
                        <span class="s1">conversor = EncodedNominalConversor(attr[</span><span class="s5">1</span><span class="s1">])</span>
                    <span class="s4">else</span><span class="s1">:</span>
                        <span class="s1">conversor = NominalConversor(attr[</span><span class="s5">1</span><span class="s1">])</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s1">CONVERSOR_MAP = {</span><span class="s3">'STRING'</span><span class="s1">: str</span><span class="s4">,</span>
                                     <span class="s3">'INTEGER'</span><span class="s1">: </span><span class="s4">lambda </span><span class="s1">x: int(float(x))</span><span class="s4">,</span>
                                     <span class="s3">'NUMERIC'</span><span class="s1">: float</span><span class="s4">,</span>
                                     <span class="s3">'REAL'</span><span class="s1">: float}</span>
                    <span class="s1">conversor = CONVERSOR_MAP[attr[</span><span class="s5">1</span><span class="s1">]]</span>

                <span class="s1">self._conversors.append(conversor)</span>
            <span class="s0"># -----------------------------------------------------------------</span>

            <span class="s0"># DATA ------------------------------------------------------------</span>
            <span class="s4">elif </span><span class="s1">u_row.startswith(_TK_DATA):</span>
                <span class="s4">if </span><span class="s1">STATE != _TK_ATTRIBUTE:</span>
                    <span class="s4">raise </span><span class="s1">BadLayout()</span>

                <span class="s4">break</span>
            <span class="s0"># -----------------------------------------------------------------</span>

            <span class="s0"># COMMENT ---------------------------------------------------------</span>
            <span class="s4">elif </span><span class="s1">u_row.startswith(_TK_COMMENT):</span>
                <span class="s4">pass</span>
            <span class="s0"># -----------------------------------------------------------------</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s0"># Never found @DATA</span>
            <span class="s4">raise </span><span class="s1">BadLayout()</span>

        <span class="s4">def </span><span class="s1">stream():</span>
            <span class="s4">for </span><span class="s1">row </span><span class="s4">in </span><span class="s1">s:</span>
                <span class="s1">self._current_line += </span><span class="s5">1</span>
                <span class="s1">row = row.strip()</span>
                <span class="s0"># Ignore empty lines and comment lines.</span>
                <span class="s4">if </span><span class="s1">row </span><span class="s4">and not </span><span class="s1">row.startswith(_TK_COMMENT):</span>
                    <span class="s4">yield </span><span class="s1">row</span>

        <span class="s0"># Alter the data object</span>
        <span class="s1">obj[</span><span class="s3">'data'</span><span class="s1">] = data.decode_rows(stream()</span><span class="s4">, </span><span class="s1">self._conversors)</span>
        <span class="s4">if </span><span class="s1">obj[</span><span class="s3">'description'</span><span class="s1">].endswith(</span><span class="s3">'</span><span class="s4">\n</span><span class="s3">'</span><span class="s1">):</span>
            <span class="s1">obj[</span><span class="s3">'description'</span><span class="s1">] = obj[</span><span class="s3">'description'</span><span class="s1">][:-</span><span class="s5">1</span><span class="s1">]</span>

        <span class="s4">return </span><span class="s1">obj</span>

    <span class="s4">def </span><span class="s1">decode(self</span><span class="s4">, </span><span class="s1">s</span><span class="s4">, </span><span class="s1">encode_nominal=</span><span class="s4">False, </span><span class="s1">return_type=DENSE):</span>
        <span class="s2">'''Returns the Python representation of a given ARFF file. 
 
        When a file object is passed as an argument, this method reads lines 
        iteratively, avoiding to load unnecessary information to the memory. 
 
        :param s: a string or file object with the ARFF file. 
        :param encode_nominal: boolean, if True perform a label encoding 
            while reading the .arff file. 
        :param return_type: determines the data structure used to store the 
            dataset. Can be one of `arff.DENSE`, `arff.COO`, `arff.LOD`, 
            `arff.DENSE_GEN` or `arff.LOD_GEN`. 
            Consult the sections on `working with sparse data`_ and `loading 
            progressively`_. 
        '''</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">self._decode(s</span><span class="s4">, </span><span class="s1">encode_nominal=encode_nominal</span><span class="s4">,</span>
                                <span class="s1">matrix_type=return_type)</span>
        <span class="s4">except </span><span class="s1">ArffException </span><span class="s4">as </span><span class="s1">e:</span>
            <span class="s1">e.line = self._current_line</span>
            <span class="s4">raise </span><span class="s1">e</span>


<span class="s4">class </span><span class="s1">ArffEncoder:</span>
    <span class="s2">'''An ARFF encoder.'''</span>

    <span class="s4">def </span><span class="s1">_encode_comment(self</span><span class="s4">, </span><span class="s1">s=</span><span class="s3">''</span><span class="s1">):</span>
        <span class="s2">'''(INTERNAL) Encodes a comment line. 
 
        Comments are single line strings starting, obligatorily, with the ``%`` 
        character, and can have any symbol, including whitespaces or special 
        characters. 
 
        If ``s`` is None, this method will simply return an empty comment. 
 
        :param s: (OPTIONAL) string. 
        :return: a string with the encoded comment line. 
        '''</span>
        <span class="s4">if </span><span class="s1">s:</span>
            <span class="s4">return </span><span class="s3">'%s %s'</span><span class="s1">%(_TK_COMMENT</span><span class="s4">, </span><span class="s1">s)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s3">'%s' </span><span class="s1">% _TK_COMMENT</span>

    <span class="s4">def </span><span class="s1">_encode_relation(self</span><span class="s4">, </span><span class="s1">name):</span>
        <span class="s2">'''(INTERNAL) Decodes a relation line. 
 
        The relation declaration is a line with the format ``@RELATION 
        &lt;relation-name&gt;``, where ``relation-name`` is a string. 
 
        :param name: a string. 
        :return: a string with the encoded relation declaration. 
        '''</span>
        <span class="s4">for </span><span class="s1">char </span><span class="s4">in </span><span class="s3">' %{},'</span><span class="s1">:</span>
            <span class="s4">if </span><span class="s1">char </span><span class="s4">in </span><span class="s1">name:</span>
                <span class="s1">name = </span><span class="s3">'&quot;%s&quot;'</span><span class="s1">%name</span>
                <span class="s4">break</span>

        <span class="s4">return </span><span class="s3">'%s %s'</span><span class="s1">%(_TK_RELATION</span><span class="s4">, </span><span class="s1">name)</span>

    <span class="s4">def </span><span class="s1">_encode_attribute(self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">type_):</span>
        <span class="s2">'''(INTERNAL) Encodes an attribute line. 
 
        The attribute follow the template:: 
 
             @attribute &lt;attribute-name&gt; &lt;datatype&gt; 
 
        where ``attribute-name`` is a string, and ``datatype`` can be: 
 
        - Numerical attributes as ``NUMERIC``, ``INTEGER`` or ``REAL``. 
        - Strings as ``STRING``. 
        - Dates (NOT IMPLEMENTED). 
        - Nominal attributes with format: 
 
            {&lt;nominal-name1&gt;, &lt;nominal-name2&gt;, &lt;nominal-name3&gt;, ...} 
 
        This method must receive a the name of the attribute and its type, if 
        the attribute type is nominal, ``type`` must be a list of values. 
 
        :param name: a string. 
        :param type_: a string or a list of string. 
        :return: a string with the encoded attribute declaration. 
        '''</span>
        <span class="s4">for </span><span class="s1">char </span><span class="s4">in </span><span class="s3">' %{},'</span><span class="s1">:</span>
            <span class="s4">if </span><span class="s1">char </span><span class="s4">in </span><span class="s1">name:</span>
                <span class="s1">name = </span><span class="s3">'&quot;%s&quot;'</span><span class="s1">%name</span>
                <span class="s4">break</span>

        <span class="s4">if </span><span class="s1">isinstance(type_</span><span class="s4">, </span><span class="s1">(tuple</span><span class="s4">, </span><span class="s1">list)):</span>
            <span class="s1">type_tmp = [</span><span class="s3">'%s' </span><span class="s1">% encode_string(type_k) </span><span class="s4">for </span><span class="s1">type_k </span><span class="s4">in </span><span class="s1">type_]</span>
            <span class="s1">type_ = </span><span class="s3">'{%s}'</span><span class="s1">%(</span><span class="s3">', '</span><span class="s1">.join(type_tmp))</span>

        <span class="s4">return </span><span class="s3">'%s %s %s'</span><span class="s1">%(_TK_ATTRIBUTE</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">type_)</span>

    <span class="s4">def </span><span class="s1">encode(self</span><span class="s4">, </span><span class="s1">obj):</span>
        <span class="s2">'''Encodes a given object to an ARFF file. 
 
        :param obj: the object containing the ARFF information. 
        :return: the ARFF file as an string. 
        '''</span>
        <span class="s1">data = [row </span><span class="s4">for </span><span class="s1">row </span><span class="s4">in </span><span class="s1">self.iter_encode(obj)]</span>

        <span class="s4">return </span><span class="s3">'</span><span class="s4">\n</span><span class="s3">'</span><span class="s1">.join(data)</span>

    <span class="s4">def </span><span class="s1">iter_encode(self</span><span class="s4">, </span><span class="s1">obj):</span>
        <span class="s2">'''The iterative version of `arff.ArffEncoder.encode`. 
 
        This encodes iteratively a given object and return, one-by-one, the 
        lines of the ARFF file. 
 
        :param obj: the object containing the ARFF information. 
        :return: (yields) the ARFF file as strings. 
        '''</span>
        <span class="s0"># DESCRIPTION</span>
        <span class="s4">if </span><span class="s1">obj.get(</span><span class="s3">'description'</span><span class="s4">, None</span><span class="s1">):</span>
            <span class="s4">for </span><span class="s1">row </span><span class="s4">in </span><span class="s1">obj[</span><span class="s3">'description'</span><span class="s1">].split(</span><span class="s3">'</span><span class="s4">\n</span><span class="s3">'</span><span class="s1">):</span>
                <span class="s4">yield </span><span class="s1">self._encode_comment(row)</span>

        <span class="s0"># RELATION</span>
        <span class="s4">if not </span><span class="s1">obj.get(</span><span class="s3">'relation'</span><span class="s1">):</span>
            <span class="s4">raise </span><span class="s1">BadObject(</span><span class="s3">'Relation name not found or with invalid value.'</span><span class="s1">)</span>

        <span class="s4">yield </span><span class="s1">self._encode_relation(obj[</span><span class="s3">'relation'</span><span class="s1">])</span>
        <span class="s4">yield </span><span class="s3">''</span>

        <span class="s0"># ATTRIBUTES</span>
        <span class="s4">if not </span><span class="s1">obj.get(</span><span class="s3">'attributes'</span><span class="s1">):</span>
            <span class="s4">raise </span><span class="s1">BadObject(</span><span class="s3">'Attributes not found.'</span><span class="s1">)</span>

        <span class="s1">attribute_names = set()</span>
        <span class="s4">for </span><span class="s1">attr </span><span class="s4">in </span><span class="s1">obj[</span><span class="s3">'attributes'</span><span class="s1">]:</span>
            <span class="s0"># Verify for bad object format</span>
            <span class="s4">if not </span><span class="s1">isinstance(attr</span><span class="s4">, </span><span class="s1">(tuple</span><span class="s4">, </span><span class="s1">list)) </span><span class="s4">or </span><span class="s1">\</span>
               <span class="s1">len(attr) != </span><span class="s5">2 </span><span class="s4">or </span><span class="s1">\</span>
               <span class="s4">not </span><span class="s1">isinstance(attr[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">, </span><span class="s1">str):</span>
                <span class="s4">raise </span><span class="s1">BadObject(</span><span class="s3">'Invalid attribute declaration &quot;%s&quot;'</span><span class="s1">%str(attr))</span>

            <span class="s4">if </span><span class="s1">isinstance(attr[</span><span class="s5">1</span><span class="s1">]</span><span class="s4">, </span><span class="s1">str):</span>
                <span class="s0"># Verify for invalid types</span>
                <span class="s4">if </span><span class="s1">attr[</span><span class="s5">1</span><span class="s1">] </span><span class="s4">not in </span><span class="s1">_SIMPLE_TYPES:</span>
                    <span class="s4">raise </span><span class="s1">BadObject(</span><span class="s3">'Invalid attribute type &quot;%s&quot;'</span><span class="s1">%str(attr))</span>

            <span class="s0"># Verify for bad object format</span>
            <span class="s4">elif not </span><span class="s1">isinstance(attr[</span><span class="s5">1</span><span class="s1">]</span><span class="s4">, </span><span class="s1">(tuple</span><span class="s4">, </span><span class="s1">list)):</span>
                <span class="s4">raise </span><span class="s1">BadObject(</span><span class="s3">'Invalid attribute type &quot;%s&quot;'</span><span class="s1">%str(attr))</span>

            <span class="s0"># Verify attribute name is not used twice</span>
            <span class="s4">if </span><span class="s1">attr[</span><span class="s5">0</span><span class="s1">] </span><span class="s4">in </span><span class="s1">attribute_names:</span>
                <span class="s4">raise </span><span class="s1">BadObject(</span><span class="s3">'Trying to use attribute name &quot;%s&quot; for the '</span>
                                <span class="s3">'second time.' </span><span class="s1">% str(attr[</span><span class="s5">0</span><span class="s1">]))</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">attribute_names.add(attr[</span><span class="s5">0</span><span class="s1">])</span>

            <span class="s4">yield </span><span class="s1">self._encode_attribute(attr[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">, </span><span class="s1">attr[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s4">yield </span><span class="s3">''</span>
        <span class="s1">attributes = obj[</span><span class="s3">'attributes'</span><span class="s1">]</span>

        <span class="s0"># DATA</span>
        <span class="s4">yield </span><span class="s1">_TK_DATA</span>
        <span class="s4">if </span><span class="s3">'data' </span><span class="s4">in </span><span class="s1">obj:</span>
            <span class="s1">data = _get_data_object_for_encoding(obj.get(</span><span class="s3">'data'</span><span class="s1">))</span>
            <span class="s4">yield from </span><span class="s1">data.encode_data(obj.get(</span><span class="s3">'data'</span><span class="s1">)</span><span class="s4">, </span><span class="s1">attributes)</span>

        <span class="s4">yield </span><span class="s3">''</span>

<span class="s0"># =============================================================================</span>

<span class="s0"># BASIC INTERFACE =============================================================</span>
<span class="s4">def </span><span class="s1">load(fp</span><span class="s4">, </span><span class="s1">encode_nominal=</span><span class="s4">False, </span><span class="s1">return_type=DENSE):</span>
    <span class="s2">'''Load a file-like object containing the ARFF document and convert it into 
    a Python object. 
 
    :param fp: a file-like object. 
    :param encode_nominal: boolean, if True perform a label encoding 
        while reading the .arff file. 
    :param return_type: determines the data structure used to store the 
        dataset. Can be one of `arff.DENSE`, `arff.COO`, `arff.LOD`, 
        `arff.DENSE_GEN` or `arff.LOD_GEN`. 
        Consult the sections on `working with sparse data`_ and `loading 
        progressively`_. 
    :return: a dictionary. 
     '''</span>
    <span class="s1">decoder = ArffDecoder()</span>
    <span class="s4">return </span><span class="s1">decoder.decode(fp</span><span class="s4">, </span><span class="s1">encode_nominal=encode_nominal</span><span class="s4">,</span>
                          <span class="s1">return_type=return_type)</span>

<span class="s4">def </span><span class="s1">loads(s</span><span class="s4">, </span><span class="s1">encode_nominal=</span><span class="s4">False, </span><span class="s1">return_type=DENSE):</span>
    <span class="s2">'''Convert a string instance containing the ARFF document into a Python 
    object. 
 
    :param s: a string object. 
    :param encode_nominal: boolean, if True perform a label encoding 
        while reading the .arff file. 
    :param return_type: determines the data structure used to store the 
        dataset. Can be one of `arff.DENSE`, `arff.COO`, `arff.LOD`, 
        `arff.DENSE_GEN` or `arff.LOD_GEN`. 
        Consult the sections on `working with sparse data`_ and `loading 
        progressively`_. 
    :return: a dictionary. 
    '''</span>
    <span class="s1">decoder = ArffDecoder()</span>
    <span class="s4">return </span><span class="s1">decoder.decode(s</span><span class="s4">, </span><span class="s1">encode_nominal=encode_nominal</span><span class="s4">,</span>
                          <span class="s1">return_type=return_type)</span>

<span class="s4">def </span><span class="s1">dump(obj</span><span class="s4">, </span><span class="s1">fp):</span>
    <span class="s2">'''Serialize an object representing the ARFF document to a given file-like 
    object. 
 
    :param obj: a dictionary. 
    :param fp: a file-like object. 
    '''</span>
    <span class="s1">encoder = ArffEncoder()</span>
    <span class="s1">generator = encoder.iter_encode(obj)</span>

    <span class="s1">last_row = next(generator)</span>
    <span class="s4">for </span><span class="s1">row </span><span class="s4">in </span><span class="s1">generator:</span>
        <span class="s1">fp.write(last_row + </span><span class="s3">'</span><span class="s4">\n</span><span class="s3">'</span><span class="s1">)</span>
        <span class="s1">last_row = row</span>
    <span class="s1">fp.write(last_row)</span>

    <span class="s4">return </span><span class="s1">fp</span>

<span class="s4">def </span><span class="s1">dumps(obj):</span>
    <span class="s2">'''Serialize an object representing the ARFF document, returning a string. 
 
    :param obj: a dictionary. 
    :return: a string with the ARFF document. 
    '''</span>
    <span class="s1">encoder = ArffEncoder()</span>
    <span class="s4">return </span><span class="s1">encoder.encode(obj)</span>
<span class="s0"># =============================================================================</span>
</pre>
</body>
</html>