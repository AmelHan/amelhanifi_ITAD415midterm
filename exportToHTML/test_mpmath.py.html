<html>
<head>
<title>test_mpmath.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_mpmath.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Test SciPy functions versus mpmath, if available. 
 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">assert_</span><span class="s2">, </span><span class="s1">assert_allclose</span>
<span class="s2">from </span><span class="s1">numpy </span><span class="s2">import </span><span class="s1">pi</span>
<span class="s2">import </span><span class="s1">pytest</span>
<span class="s2">import </span><span class="s1">itertools</span>

<span class="s2">from </span><span class="s1">scipy._lib </span><span class="s2">import </span><span class="s1">_pep440</span>

<span class="s2">import </span><span class="s1">scipy.special </span><span class="s2">as </span><span class="s1">sc</span>
<span class="s2">from </span><span class="s1">scipy.special._testutils </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">MissingModule</span><span class="s2">, </span><span class="s1">check_version</span><span class="s2">, </span><span class="s1">FuncData</span><span class="s2">,</span>
    <span class="s1">assert_func_equal)</span>
<span class="s2">from </span><span class="s1">scipy.special._mptestutils </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Arg</span><span class="s2">, </span><span class="s1">FixedArg</span><span class="s2">, </span><span class="s1">ComplexArg</span><span class="s2">, </span><span class="s1">IntArg</span><span class="s2">, </span><span class="s1">assert_mpmath_equal</span><span class="s2">,</span>
    <span class="s1">nonfunctional_tooslow</span><span class="s2">, </span><span class="s1">trace_args</span><span class="s2">, </span><span class="s1">time_limited</span><span class="s2">, </span><span class="s1">exception_to_nan</span><span class="s2">,</span>
    <span class="s1">inf_to_nan)</span>
<span class="s2">from </span><span class="s1">scipy.special._ufuncs </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">_sinpi</span><span class="s2">, </span><span class="s1">_cospi</span><span class="s2">, </span><span class="s1">_lgam1p</span><span class="s2">, </span><span class="s1">_lanczos_sum_expg_scaled</span><span class="s2">, </span><span class="s1">_log1pmx</span><span class="s2">,</span>
    <span class="s1">_igam_fac)</span>

<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">import </span><span class="s1">mpmath</span>
<span class="s2">except </span><span class="s1">ImportError:</span>
    <span class="s1">mpmath = MissingModule(</span><span class="s3">'mpmath'</span><span class="s1">)</span>


<span class="s4"># ------------------------------------------------------------------------------</span>
<span class="s4"># expi</span>
<span class="s4"># ------------------------------------------------------------------------------</span>

<span class="s1">@check_version(mpmath</span><span class="s2">, </span><span class="s3">'0.10'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_expi_complex():</span>
    <span class="s1">dataset = []</span>
    <span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">np.logspace(-</span><span class="s5">99</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">10</span><span class="s1">):</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">np.linspace(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s1">*np.pi</span><span class="s2">, </span><span class="s5">30</span><span class="s1">):</span>
            <span class="s1">z = r*np.exp(</span><span class="s5">1j</span><span class="s1">*p)</span>
            <span class="s1">dataset.append((z</span><span class="s2">, </span><span class="s1">complex(mpmath.ei(z))))</span>
    <span class="s1">dataset = np.array(dataset</span><span class="s2">, </span><span class="s1">dtype=np.complex_)</span>

    <span class="s1">FuncData(sc.expi</span><span class="s2">, </span><span class="s1">dataset</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">).check()</span>


<span class="s4"># ------------------------------------------------------------------------------</span>
<span class="s4"># expn</span>
<span class="s4"># ------------------------------------------------------------------------------</span>

<span class="s1">@check_version(mpmath</span><span class="s2">, </span><span class="s3">'0.19'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_expn_large_n():</span>
    <span class="s4"># Test the transition to the asymptotic regime of n.</span>
    <span class="s1">dataset = []</span>
    <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">[</span><span class="s5">50</span><span class="s2">, </span><span class="s5">51</span><span class="s1">]:</span>
        <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">np.logspace(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">200</span><span class="s1">):</span>
            <span class="s2">with </span><span class="s1">mpmath.workdps(</span><span class="s5">100</span><span class="s1">):</span>
                <span class="s1">dataset.append((n</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">float(mpmath.expint(n</span><span class="s2">, </span><span class="s1">x))))</span>
    <span class="s1">dataset = np.asarray(dataset)</span>

    <span class="s1">FuncData(sc.expn</span><span class="s2">, </span><span class="s1">dataset</span><span class="s2">, </span><span class="s1">(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-13</span><span class="s1">).check()</span>

<span class="s4"># ------------------------------------------------------------------------------</span>
<span class="s4"># hyp0f1</span>
<span class="s4"># ------------------------------------------------------------------------------</span>


<span class="s1">@check_version(mpmath</span><span class="s2">, </span><span class="s3">'0.19'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_hyp0f1_gh5764():</span>
    <span class="s4"># Do a small and somewhat systematic test that runs quickly</span>
    <span class="s1">dataset = []</span>
    <span class="s1">axis = [-</span><span class="s5">99.5</span><span class="s2">, </span><span class="s1">-</span><span class="s5">9.5</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">9.5</span><span class="s2">, </span><span class="s5">99.5</span><span class="s1">]</span>
    <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">axis:</span>
        <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">axis:</span>
            <span class="s2">for </span><span class="s1">y </span><span class="s2">in </span><span class="s1">axis:</span>
                <span class="s1">z = x + </span><span class="s5">1j</span><span class="s1">*y</span>
                <span class="s4"># mpmath computes the answer correctly at dps ~ 17 but</span>
                <span class="s4"># fails for 20 &lt; dps &lt; 120 (uses a different method);</span>
                <span class="s4"># set the dps high enough that this isn't an issue</span>
                <span class="s2">with </span><span class="s1">mpmath.workdps(</span><span class="s5">120</span><span class="s1">):</span>
                    <span class="s1">res = complex(mpmath.hyp0f1(v</span><span class="s2">, </span><span class="s1">z))</span>
                <span class="s1">dataset.append((v</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">res))</span>
    <span class="s1">dataset = np.array(dataset)</span>

    <span class="s1">FuncData(</span><span class="s2">lambda </span><span class="s1">v</span><span class="s2">, </span><span class="s1">z: sc.hyp0f1(v.real</span><span class="s2">, </span><span class="s1">z)</span><span class="s2">, </span><span class="s1">dataset</span><span class="s2">, </span><span class="s1">(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s5">2</span><span class="s2">,</span>
             <span class="s1">rtol=</span><span class="s5">1e-13</span><span class="s1">).check()</span>


<span class="s1">@check_version(mpmath</span><span class="s2">, </span><span class="s3">'0.19'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_hyp0f1_gh_1609():</span>
    <span class="s4"># this is a regression test for gh-1609</span>
    <span class="s1">vv = np.linspace(</span><span class="s5">150</span><span class="s2">, </span><span class="s5">180</span><span class="s2">, </span><span class="s5">21</span><span class="s1">)</span>
    <span class="s1">af = sc.hyp0f1(vv</span><span class="s2">, </span><span class="s5">0.5</span><span class="s1">)</span>
    <span class="s1">mf = np.array([mpmath.hyp0f1(v</span><span class="s2">, </span><span class="s5">0.5</span><span class="s1">) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">vv])</span>
    <span class="s1">assert_allclose(af</span><span class="s2">, </span><span class="s1">mf.astype(float)</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-12</span><span class="s1">)</span>


<span class="s4"># ------------------------------------------------------------------------------</span>
<span class="s4"># hyperu</span>
<span class="s4"># ------------------------------------------------------------------------------</span>

<span class="s1">@check_version(mpmath</span><span class="s2">, </span><span class="s3">'1.1.0'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_hyperu_around_0():</span>
    <span class="s1">dataset = []</span>
    <span class="s4"># DLMF 13.2.14-15 test points.</span>
    <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">np.arange(-</span><span class="s5">5</span><span class="s2">, </span><span class="s5">5</span><span class="s1">):</span>
        <span class="s2">for </span><span class="s1">b </span><span class="s2">in </span><span class="s1">np.linspace(-</span><span class="s5">5</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s5">20</span><span class="s1">):</span>
            <span class="s1">a = -n</span>
            <span class="s1">dataset.append((a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">float(mpmath.hyperu(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))))</span>
            <span class="s1">a = -n + b - </span><span class="s5">1</span>
            <span class="s1">dataset.append((a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">float(mpmath.hyperu(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))))</span>
    <span class="s4"># DLMF 13.2.16-22 test points.</span>
    <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">[-</span><span class="s5">10.5</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1.5</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">10</span><span class="s1">]:</span>
        <span class="s2">for </span><span class="s1">b </span><span class="s2">in </span><span class="s1">[-</span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1.5</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">2.5</span><span class="s1">]:</span>
            <span class="s1">dataset.append((a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">float(mpmath.hyperu(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))))</span>
    <span class="s1">dataset = np.array(dataset)</span>

    <span class="s1">FuncData(sc.hyperu</span><span class="s2">, </span><span class="s1">dataset</span><span class="s2">, </span><span class="s1">(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-15</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">5e-13</span><span class="s1">).check()</span>


<span class="s4"># ------------------------------------------------------------------------------</span>
<span class="s4"># hyp2f1</span>
<span class="s4"># ------------------------------------------------------------------------------</span>

<span class="s1">@check_version(mpmath</span><span class="s2">, </span><span class="s3">'1.0.0'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_hyp2f1_strange_points():</span>
    <span class="s1">pts = [</span>
        <span class="s1">(</span><span class="s5">2</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0.7</span><span class="s1">)</span><span class="s2">,  </span><span class="s4"># expected: 2.4</span>
        <span class="s1">(</span><span class="s5">2</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2</span><span class="s2">, </span><span class="s5">0.7</span><span class="s1">)</span><span class="s2">,  </span><span class="s4"># expected: 3.87</span>
    <span class="s1">]</span>
    <span class="s1">pts += list(itertools.product([</span><span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.7</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1000</span><span class="s1">]</span><span class="s2">, </span><span class="s1">repeat=</span><span class="s5">4</span><span class="s1">))</span>
    <span class="s1">pts = [</span>
        <span class="s1">(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">x) </span><span class="s2">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">x </span><span class="s2">in </span><span class="s1">pts</span>
        <span class="s2">if </span><span class="s1">b == c </span><span class="s2">and </span><span class="s1">round(b) == b </span><span class="s2">and </span><span class="s1">b &lt; </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">b != -</span><span class="s5">1000</span>
    <span class="s1">]</span>
    <span class="s1">kw = dict(eliminate=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">dataset = [p + (float(mpmath.hyp2f1(*p</span><span class="s2">, </span><span class="s1">**kw))</span><span class="s2">,</span><span class="s1">) </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">pts]</span>
    <span class="s1">dataset = np.array(dataset</span><span class="s2">, </span><span class="s1">dtype=np.float_)</span>

    <span class="s1">FuncData(sc.hyp2f1</span><span class="s2">, </span><span class="s1">dataset</span><span class="s2">, </span><span class="s1">(</span><span class="s5">0</span><span class="s2">,</span><span class="s5">1</span><span class="s2">,</span><span class="s5">2</span><span class="s2">,</span><span class="s5">3</span><span class="s1">)</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-10</span><span class="s1">).check()</span>


<span class="s1">@check_version(mpmath</span><span class="s2">, </span><span class="s3">'0.13'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_hyp2f1_real_some_points():</span>
    <span class="s1">pts = [</span>
        <span class="s1">(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s5">1.</span><span class="s1">/</span><span class="s5">3</span><span class="s2">, </span><span class="s5">2.</span><span class="s1">/</span><span class="s5">3</span><span class="s2">, </span><span class="s5">5.</span><span class="s1">/</span><span class="s5">6</span><span class="s2">, </span><span class="s5">27.</span><span class="s1">/</span><span class="s5">32</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s5">1.</span><span class="s1">/</span><span class="s5">4</span><span class="s2">, </span><span class="s5">1.</span><span class="s1">/</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3.</span><span class="s1">/</span><span class="s5">4</span><span class="s2">, </span><span class="s5">80.</span><span class="s1">/</span><span class="s5">81</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s5">2</span><span class="s2">,</span><span class="s1">-</span><span class="s5">2</span><span class="s2">, </span><span class="s1">-</span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s5">2</span><span class="s2">, </span><span class="s1">-</span><span class="s5">3</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s5">2</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1.5</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1.5</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s5">0.7235</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">5</span><span class="s2">, </span><span class="s5">0.3</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s5">0.25</span><span class="s2">, </span><span class="s5">1.</span><span class="s1">/</span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">0.999</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s5">0.25</span><span class="s2">, </span><span class="s5">1.</span><span class="s1">/</span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s5">0.99</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s5">3.</span><span class="s1">/</span><span class="s5">2</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">0.99</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2.5</span><span class="s2">, </span><span class="s1">-</span><span class="s5">3.25</span><span class="s2">, </span><span class="s5">0.999</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(-</span><span class="s5">8</span><span class="s2">, </span><span class="s5">18.016500331508873</span><span class="s2">, </span><span class="s5">10.805295997850628</span><span class="s2">, </span><span class="s5">0.90875647507000001</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(-</span><span class="s5">10</span><span class="s2">, </span><span class="s5">900</span><span class="s2">, </span><span class="s1">-</span><span class="s5">10.5</span><span class="s2">, </span><span class="s5">0.99</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(-</span><span class="s5">10</span><span class="s2">, </span><span class="s5">900</span><span class="s2">, </span><span class="s5">10.5</span><span class="s2">, </span><span class="s5">0.99</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1.0</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1.0</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(-</span><span class="s5">3</span><span class="s2">, </span><span class="s5">13</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s5">1.0</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(-</span><span class="s5">3</span><span class="s2">, </span><span class="s5">13</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1.0</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">1 </span><span class="s1">- </span><span class="s5">270.5</span><span class="s2">, </span><span class="s5">1.5</span><span class="s2">, </span><span class="s5">0.999</span><span class="s1">**</span><span class="s5">2</span><span class="s1">)</span><span class="s2">,  </span><span class="s4"># from issue 1561</span>
    <span class="s1">]</span>
    <span class="s1">dataset = [p + (float(mpmath.hyp2f1(*p))</span><span class="s2">,</span><span class="s1">) </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">pts]</span>
    <span class="s1">dataset = np.array(dataset</span><span class="s2">, </span><span class="s1">dtype=np.float_)</span>

    <span class="s2">with </span><span class="s1">np.errstate(invalid=</span><span class="s3">'ignore'</span><span class="s1">):</span>
        <span class="s1">FuncData(sc.hyp2f1</span><span class="s2">, </span><span class="s1">dataset</span><span class="s2">, </span><span class="s1">(</span><span class="s5">0</span><span class="s2">,</span><span class="s5">1</span><span class="s2">,</span><span class="s5">2</span><span class="s2">,</span><span class="s5">3</span><span class="s1">)</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-10</span><span class="s1">).check()</span>


<span class="s1">@check_version(mpmath</span><span class="s2">, </span><span class="s3">'0.14'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_hyp2f1_some_points_2():</span>
    <span class="s4"># Taken from mpmath unit tests -- this point failed for mpmath 0.13 but</span>
    <span class="s4"># was fixed in their SVN since then</span>
    <span class="s1">pts = [</span>
        <span class="s1">(</span><span class="s5">112</span><span class="s2">, </span><span class="s1">(</span><span class="s5">51</span><span class="s2">,</span><span class="s5">10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(-</span><span class="s5">9</span><span class="s2">,</span><span class="s5">10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.99999</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s5">10</span><span class="s2">,</span><span class="s1">-</span><span class="s5">900</span><span class="s2">,</span><span class="s5">10.5</span><span class="s2">,</span><span class="s5">0.99</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s5">10</span><span class="s2">,</span><span class="s1">-</span><span class="s5">900</span><span class="s2">,</span><span class="s1">-</span><span class="s5">10.5</span><span class="s2">,</span><span class="s5">0.99</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">]</span>

    <span class="s2">def </span><span class="s1">fev(x):</span>
        <span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">tuple):</span>
            <span class="s2">return </span><span class="s1">float(x[</span><span class="s5">0</span><span class="s1">]) / x[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">x</span>

    <span class="s1">dataset = [tuple(map(fev</span><span class="s2">, </span><span class="s1">p)) + (float(mpmath.hyp2f1(*p))</span><span class="s2">,</span><span class="s1">) </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">pts]</span>
    <span class="s1">dataset = np.array(dataset</span><span class="s2">, </span><span class="s1">dtype=np.float_)</span>

    <span class="s1">FuncData(sc.hyp2f1</span><span class="s2">, </span><span class="s1">dataset</span><span class="s2">, </span><span class="s1">(</span><span class="s5">0</span><span class="s2">,</span><span class="s5">1</span><span class="s2">,</span><span class="s5">2</span><span class="s2">,</span><span class="s5">3</span><span class="s1">)</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-10</span><span class="s1">).check()</span>


<span class="s1">@check_version(mpmath</span><span class="s2">, </span><span class="s3">'0.13'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_hyp2f1_real_some():</span>
    <span class="s1">dataset = []</span>
    <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">[-</span><span class="s5">10</span><span class="s2">, </span><span class="s1">-</span><span class="s5">5</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1.8</span><span class="s2">, </span><span class="s5">1.8</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s5">10</span><span class="s1">]:</span>
        <span class="s2">for </span><span class="s1">b </span><span class="s2">in </span><span class="s1">[-</span><span class="s5">2.5</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">7.4</span><span class="s1">]:</span>
            <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">[-</span><span class="s5">9</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1.8</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s5">20.4</span><span class="s1">]:</span>
                <span class="s2">for </span><span class="s1">z </span><span class="s2">in </span><span class="s1">[-</span><span class="s5">10</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1.01</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.99</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0.6</span><span class="s2">, </span><span class="s5">0.95</span><span class="s2">, </span><span class="s5">1.5</span><span class="s2">, </span><span class="s5">10</span><span class="s1">]:</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s1">v = float(mpmath.hyp2f1(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">z))</span>
                    <span class="s2">except </span><span class="s1">Exception:</span>
                        <span class="s2">continue</span>
                    <span class="s1">dataset.append((a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">v))</span>
    <span class="s1">dataset = np.array(dataset</span><span class="s2">, </span><span class="s1">dtype=np.float_)</span>

    <span class="s2">with </span><span class="s1">np.errstate(invalid=</span><span class="s3">'ignore'</span><span class="s1">):</span>
        <span class="s1">FuncData(sc.hyp2f1</span><span class="s2">, </span><span class="s1">dataset</span><span class="s2">, </span><span class="s1">(</span><span class="s5">0</span><span class="s2">,</span><span class="s5">1</span><span class="s2">,</span><span class="s5">2</span><span class="s2">,</span><span class="s5">3</span><span class="s1">)</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-9</span><span class="s2">,</span>
                 <span class="s1">ignore_inf_sign=</span><span class="s2">True</span><span class="s1">).check()</span>


<span class="s1">@check_version(mpmath</span><span class="s2">, </span><span class="s3">'0.12'</span><span class="s1">)</span>
<span class="s1">@pytest.mark.slow</span>
<span class="s2">def </span><span class="s1">test_hyp2f1_real_random():</span>
    <span class="s1">npoints = </span><span class="s5">500</span>
    <span class="s1">dataset = np.zeros((npoints</span><span class="s2">, </span><span class="s5">5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.float_)</span>

    <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
    <span class="s1">dataset[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = np.random.pareto(</span><span class="s5">1.5</span><span class="s2">, </span><span class="s1">npoints)</span>
    <span class="s1">dataset[:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">] = np.random.pareto(</span><span class="s5">1.5</span><span class="s2">, </span><span class="s1">npoints)</span>
    <span class="s1">dataset[:</span><span class="s2">, </span><span class="s5">2</span><span class="s1">] = np.random.pareto(</span><span class="s5">1.5</span><span class="s2">, </span><span class="s1">npoints)</span>
    <span class="s1">dataset[:</span><span class="s2">, </span><span class="s5">3</span><span class="s1">] = </span><span class="s5">2</span><span class="s1">*np.random.rand(npoints) - </span><span class="s5">1</span>

    <span class="s1">dataset[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] *= (-</span><span class="s5">1</span><span class="s1">)**np.random.randint(</span><span class="s5">2</span><span class="s2">, </span><span class="s1">npoints)</span>
    <span class="s1">dataset[:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">] *= (-</span><span class="s5">1</span><span class="s1">)**np.random.randint(</span><span class="s5">2</span><span class="s2">, </span><span class="s1">npoints)</span>
    <span class="s1">dataset[:</span><span class="s2">, </span><span class="s5">2</span><span class="s1">] *= (-</span><span class="s5">1</span><span class="s1">)**np.random.randint(</span><span class="s5">2</span><span class="s2">, </span><span class="s1">npoints)</span>

    <span class="s2">for </span><span class="s1">ds </span><span class="s2">in </span><span class="s1">dataset:</span>
        <span class="s2">if </span><span class="s1">mpmath.__version__ &lt; </span><span class="s3">'0.14'</span><span class="s1">:</span>
            <span class="s4"># mpmath &lt; 0.14 fails for c too much smaller than a, b</span>
            <span class="s2">if </span><span class="s1">abs(ds[:</span><span class="s5">2</span><span class="s1">]).max() &gt; abs(ds[</span><span class="s5">2</span><span class="s1">]):</span>
                <span class="s1">ds[</span><span class="s5">2</span><span class="s1">] = abs(ds[:</span><span class="s5">2</span><span class="s1">]).max()</span>
        <span class="s1">ds[</span><span class="s5">4</span><span class="s1">] = float(mpmath.hyp2f1(*tuple(ds[:</span><span class="s5">4</span><span class="s1">])))</span>

    <span class="s1">FuncData(sc.hyp2f1</span><span class="s2">, </span><span class="s1">dataset</span><span class="s2">, </span><span class="s1">(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-9</span><span class="s1">).check()</span>


<span class="s4"># ------------------------------------------------------------------------------</span>
<span class="s4"># erf (complex)</span>
<span class="s4"># ------------------------------------------------------------------------------</span>

<span class="s1">@check_version(mpmath</span><span class="s2">, </span><span class="s3">'0.14'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_erf_complex():</span>
    <span class="s4"># need to increase mpmath precision for this test</span>
    <span class="s1">old_dps</span><span class="s2">, </span><span class="s1">old_prec = mpmath.mp.dps</span><span class="s2">, </span><span class="s1">mpmath.mp.prec</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">mpmath.mp.dps = </span><span class="s5">70</span>
        <span class="s1">x1</span><span class="s2">, </span><span class="s1">y1 = np.meshgrid(np.linspace(-</span><span class="s5">10</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">31</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.linspace(-</span><span class="s5">10</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">11</span><span class="s1">))</span>
        <span class="s1">x2</span><span class="s2">, </span><span class="s1">y2 = np.meshgrid(np.logspace(-</span><span class="s5">80</span><span class="s2">, </span><span class="s5">.8</span><span class="s2">, </span><span class="s5">31</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.logspace(-</span><span class="s5">80</span><span class="s2">, </span><span class="s5">.8</span><span class="s2">, </span><span class="s5">11</span><span class="s1">))</span>
        <span class="s1">points = np.r_[x1.ravel()</span><span class="s2">,</span><span class="s1">x2.ravel()] + </span><span class="s5">1j</span><span class="s1">*np.r_[y1.ravel()</span><span class="s2">, </span><span class="s1">y2.ravel()]</span>

        <span class="s1">assert_func_equal(sc.erf</span><span class="s2">, lambda </span><span class="s1">x: complex(mpmath.erf(x))</span><span class="s2">, </span><span class="s1">points</span><span class="s2">,</span>
                          <span class="s1">vectorized=</span><span class="s2">False, </span><span class="s1">rtol=</span><span class="s5">1e-13</span><span class="s1">)</span>
        <span class="s1">assert_func_equal(sc.erfc</span><span class="s2">, lambda </span><span class="s1">x: complex(mpmath.erfc(x))</span><span class="s2">, </span><span class="s1">points</span><span class="s2">,</span>
                          <span class="s1">vectorized=</span><span class="s2">False, </span><span class="s1">rtol=</span><span class="s5">1e-13</span><span class="s1">)</span>
    <span class="s2">finally</span><span class="s1">:</span>
        <span class="s1">mpmath.mp.dps</span><span class="s2">, </span><span class="s1">mpmath.mp.prec = old_dps</span><span class="s2">, </span><span class="s1">old_prec</span>


<span class="s4"># ------------------------------------------------------------------------------</span>
<span class="s4"># lpmv</span>
<span class="s4"># ------------------------------------------------------------------------------</span>

<span class="s1">@check_version(mpmath</span><span class="s2">, </span><span class="s3">'0.15'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_lpmv():</span>
    <span class="s1">pts = []</span>
    <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">[-</span><span class="s5">0.99</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.557</span><span class="s2">, </span><span class="s5">1e-6</span><span class="s2">, </span><span class="s5">0.132</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]:</span>
        <span class="s1">pts.extend([</span>
            <span class="s1">(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
            <span class="s1">(-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
            <span class="s1">(-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1.7</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1.7</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
            <span class="s1">(-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1.7</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
            <span class="s1">(-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2.7</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s5">3</span><span class="s2">, </span><span class="s5">8</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s5">5</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
            <span class="s1">(-</span><span class="s5">3</span><span class="s2">, </span><span class="s5">8</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
            <span class="s1">(-</span><span class="s5">5</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s5">3</span><span class="s2">, </span><span class="s1">-</span><span class="s5">8</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s5">5</span><span class="s2">, </span><span class="s1">-</span><span class="s5">11</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
            <span class="s1">(-</span><span class="s5">3</span><span class="s2">, </span><span class="s1">-</span><span class="s5">8</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
            <span class="s1">(-</span><span class="s5">5</span><span class="s2">, </span><span class="s1">-</span><span class="s5">11</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s5">3</span><span class="s2">, </span><span class="s5">8.3</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s5">5</span><span class="s2">, </span><span class="s5">11.3</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
            <span class="s1">(-</span><span class="s5">3</span><span class="s2">, </span><span class="s5">8.3</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
            <span class="s1">(-</span><span class="s5">5</span><span class="s2">, </span><span class="s5">11.3</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s5">3</span><span class="s2">, </span><span class="s1">-</span><span class="s5">8.3</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s5">5</span><span class="s2">, </span><span class="s1">-</span><span class="s5">11.3</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
            <span class="s1">(-</span><span class="s5">3</span><span class="s2">, </span><span class="s1">-</span><span class="s5">8.3</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
            <span class="s1">(-</span><span class="s5">5</span><span class="s2">, </span><span class="s1">-</span><span class="s5">11.3</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
        <span class="s1">])</span>

    <span class="s2">def </span><span class="s1">mplegenp(nu</span><span class="s2">, </span><span class="s1">mu</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">if </span><span class="s1">mu == int(mu) </span><span class="s2">and </span><span class="s1">x == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4"># mpmath 0.17 gets this wrong</span>
            <span class="s2">if </span><span class="s1">mu == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s5">1</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s5">0</span>
        <span class="s2">return </span><span class="s1">mpmath.legenp(nu</span><span class="s2">, </span><span class="s1">mu</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s1">dataset = [p + (mplegenp(p[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">p[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">p[</span><span class="s5">2</span><span class="s1">])</span><span class="s2">,</span><span class="s1">) </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">pts]</span>
    <span class="s1">dataset = np.array(dataset</span><span class="s2">, </span><span class="s1">dtype=np.float_)</span>

    <span class="s2">def </span><span class="s1">evf(mu</span><span class="s2">, </span><span class="s1">nu</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">sc.lpmv(mu.astype(int)</span><span class="s2">, </span><span class="s1">nu</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s2">with </span><span class="s1">np.errstate(invalid=</span><span class="s3">'ignore'</span><span class="s1">):</span>
        <span class="s1">FuncData(evf</span><span class="s2">, </span><span class="s1">dataset</span><span class="s2">, </span><span class="s1">(</span><span class="s5">0</span><span class="s2">,</span><span class="s5">1</span><span class="s2">,</span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-10</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-14</span><span class="s1">).check()</span>


<span class="s4"># ------------------------------------------------------------------------------</span>
<span class="s4"># beta</span>
<span class="s4"># ------------------------------------------------------------------------------</span>

<span class="s1">@check_version(mpmath</span><span class="s2">, </span><span class="s3">'0.15'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_beta():</span>
    <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>

    <span class="s1">b = np.r_[np.logspace(-</span><span class="s5">200</span><span class="s2">, </span><span class="s5">200</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span><span class="s2">,</span>
              <span class="s1">np.logspace(-</span><span class="s5">10</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span><span class="s2">,</span>
              <span class="s1">np.logspace(-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span><span class="s2">,</span>
              <span class="s1">np.arange(-</span><span class="s5">10</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
              <span class="s1">np.arange(-</span><span class="s5">10</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">1</span><span class="s1">) + </span><span class="s5">0.5</span><span class="s2">,</span>
              <span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2.3</span><span class="s2">, </span><span class="s1">-</span><span class="s5">3</span><span class="s2">, </span><span class="s1">-</span><span class="s5">100.3</span><span class="s2">, </span><span class="s1">-</span><span class="s5">10003.4</span><span class="s1">]</span>
    <span class="s1">a = b</span>

    <span class="s1">ab = np.array(np.broadcast_arrays(a[:</span><span class="s2">,None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">b[</span><span class="s2">None,</span><span class="s1">:])).reshape(</span><span class="s5">2</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">).T</span>

    <span class="s1">old_dps</span><span class="s2">, </span><span class="s1">old_prec = mpmath.mp.dps</span><span class="s2">, </span><span class="s1">mpmath.mp.prec</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">mpmath.mp.dps = </span><span class="s5">400</span>

        <span class="s1">assert_func_equal(sc.beta</span><span class="s2">,</span>
                          <span class="s2">lambda </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b: float(mpmath.beta(a</span><span class="s2">, </span><span class="s1">b))</span><span class="s2">,</span>
                          <span class="s1">ab</span><span class="s2">,</span>
                          <span class="s1">vectorized=</span><span class="s2">False,</span>
                          <span class="s1">rtol=</span><span class="s5">1e-10</span><span class="s2">,</span>
                          <span class="s1">ignore_inf_sign=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s1">assert_func_equal(</span>
            <span class="s1">sc.betaln</span><span class="s2">,</span>
            <span class="s2">lambda </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b: float(mpmath.log(abs(mpmath.beta(a</span><span class="s2">, </span><span class="s1">b))))</span><span class="s2">,</span>
            <span class="s1">ab</span><span class="s2">,</span>
            <span class="s1">vectorized=</span><span class="s2">False,</span>
            <span class="s1">rtol=</span><span class="s5">1e-10</span><span class="s1">)</span>
    <span class="s2">finally</span><span class="s1">:</span>
        <span class="s1">mpmath.mp.dps</span><span class="s2">, </span><span class="s1">mpmath.mp.prec = old_dps</span><span class="s2">, </span><span class="s1">old_prec</span>


<span class="s4"># ------------------------------------------------------------------------------</span>
<span class="s4"># loggamma</span>
<span class="s4"># ------------------------------------------------------------------------------</span>

<span class="s1">LOGGAMMA_TAYLOR_RADIUS = </span><span class="s5">0.2</span>


<span class="s1">@check_version(mpmath</span><span class="s2">, </span><span class="s3">'0.19'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_loggamma_taylor_transition():</span>
    <span class="s4"># Make sure there isn't a big jump in accuracy when we move from</span>
    <span class="s4"># using the Taylor series to using the recurrence relation.</span>

    <span class="s1">r = LOGGAMMA_TAYLOR_RADIUS + np.array([-</span><span class="s5">0.1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.01</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0.01</span><span class="s2">, </span><span class="s5">0.1</span><span class="s1">])</span>
    <span class="s1">theta = np.linspace(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s1">*np.pi</span><span class="s2">, </span><span class="s5">20</span><span class="s1">)</span>
    <span class="s1">r</span><span class="s2">, </span><span class="s1">theta = np.meshgrid(r</span><span class="s2">, </span><span class="s1">theta)</span>
    <span class="s1">dz = r*np.exp(</span><span class="s5">1j</span><span class="s1">*theta)</span>
    <span class="s1">z = np.r_[</span><span class="s5">1 </span><span class="s1">+ dz</span><span class="s2">, </span><span class="s5">2 </span><span class="s1">+ dz].flatten()</span>

    <span class="s1">dataset = [(z0</span><span class="s2">, </span><span class="s1">complex(mpmath.loggamma(z0))) </span><span class="s2">for </span><span class="s1">z0 </span><span class="s2">in </span><span class="s1">z]</span>
    <span class="s1">dataset = np.array(dataset)</span>

    <span class="s1">FuncData(sc.loggamma</span><span class="s2">, </span><span class="s1">dataset</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">5e-14</span><span class="s1">).check()</span>


<span class="s1">@check_version(mpmath</span><span class="s2">, </span><span class="s3">'0.19'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_loggamma_taylor():</span>
    <span class="s4"># Test around the zeros at z = 1, 2.</span>

    <span class="s1">r = np.logspace(-</span><span class="s5">16</span><span class="s2">, </span><span class="s1">np.log10(LOGGAMMA_TAYLOR_RADIUS)</span><span class="s2">, </span><span class="s5">10</span><span class="s1">)</span>
    <span class="s1">theta = np.linspace(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s1">*np.pi</span><span class="s2">, </span><span class="s5">20</span><span class="s1">)</span>
    <span class="s1">r</span><span class="s2">, </span><span class="s1">theta = np.meshgrid(r</span><span class="s2">, </span><span class="s1">theta)</span>
    <span class="s1">dz = r*np.exp(</span><span class="s5">1j</span><span class="s1">*theta)</span>
    <span class="s1">z = np.r_[</span><span class="s5">1 </span><span class="s1">+ dz</span><span class="s2">, </span><span class="s5">2 </span><span class="s1">+ dz].flatten()</span>

    <span class="s1">dataset = [(z0</span><span class="s2">, </span><span class="s1">complex(mpmath.loggamma(z0))) </span><span class="s2">for </span><span class="s1">z0 </span><span class="s2">in </span><span class="s1">z]</span>
    <span class="s1">dataset = np.array(dataset)</span>

    <span class="s1">FuncData(sc.loggamma</span><span class="s2">, </span><span class="s1">dataset</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">5e-14</span><span class="s1">).check()</span>


<span class="s4"># ------------------------------------------------------------------------------</span>
<span class="s4"># rgamma</span>
<span class="s4"># ------------------------------------------------------------------------------</span>

<span class="s1">@check_version(mpmath</span><span class="s2">, </span><span class="s3">'0.19'</span><span class="s1">)</span>
<span class="s1">@pytest.mark.slow</span>
<span class="s2">def </span><span class="s1">test_rgamma_zeros():</span>
    <span class="s4"># Test around the zeros at z = 0, -1, -2, ...,  -169. (After -169 we</span>
    <span class="s4"># get values that are out of floating point range even when we're</span>
    <span class="s4"># within 0.1 of the zero.)</span>

    <span class="s4"># Can't use too many points here or the test takes forever.</span>
    <span class="s1">dx = np.r_[-np.logspace(-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">13</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">np.logspace(-</span><span class="s5">13</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)]</span>
    <span class="s1">dy = dx.copy()</span>
    <span class="s1">dx</span><span class="s2">, </span><span class="s1">dy = np.meshgrid(dx</span><span class="s2">, </span><span class="s1">dy)</span>
    <span class="s1">dz = dx + </span><span class="s5">1j</span><span class="s1">*dy</span>
    <span class="s1">zeros = np.arange(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">170</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">).reshape(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">z = (zeros + np.dstack((dz</span><span class="s2">,</span><span class="s1">)*zeros.size)).flatten()</span>
    <span class="s2">with </span><span class="s1">mpmath.workdps(</span><span class="s5">100</span><span class="s1">):</span>
        <span class="s1">dataset = [(z0</span><span class="s2">, </span><span class="s1">complex(mpmath.rgamma(z0))) </span><span class="s2">for </span><span class="s1">z0 </span><span class="s2">in </span><span class="s1">z]</span>

    <span class="s1">dataset = np.array(dataset)</span>
    <span class="s1">FuncData(sc.rgamma</span><span class="s2">, </span><span class="s1">dataset</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-12</span><span class="s1">).check()</span>


<span class="s4"># ------------------------------------------------------------------------------</span>
<span class="s4"># digamma</span>
<span class="s4"># ------------------------------------------------------------------------------</span>

<span class="s1">@check_version(mpmath</span><span class="s2">, </span><span class="s3">'0.19'</span><span class="s1">)</span>
<span class="s1">@pytest.mark.slow</span>
<span class="s2">def </span><span class="s1">test_digamma_roots():</span>
    <span class="s4"># Test the special-cased roots for digamma.</span>
    <span class="s1">root = mpmath.findroot(mpmath.digamma</span><span class="s2">, </span><span class="s5">1.5</span><span class="s1">)</span>
    <span class="s1">roots = [float(root)]</span>
    <span class="s1">root = mpmath.findroot(mpmath.digamma</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.5</span><span class="s1">)</span>
    <span class="s1">roots.append(float(root))</span>
    <span class="s1">roots = np.array(roots)</span>

    <span class="s4"># If we test beyond a radius of 0.24 mpmath will take forever.</span>
    <span class="s1">dx = np.r_[-</span><span class="s5">0.24</span><span class="s2">, </span><span class="s1">-np.logspace(-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">15</span><span class="s2">, </span><span class="s5">10</span><span class="s1">)</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">np.logspace(-</span><span class="s5">15</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">10</span><span class="s1">)</span><span class="s2">, </span><span class="s5">0.24</span><span class="s1">]</span>
    <span class="s1">dy = dx.copy()</span>
    <span class="s1">dx</span><span class="s2">, </span><span class="s1">dy = np.meshgrid(dx</span><span class="s2">, </span><span class="s1">dy)</span>
    <span class="s1">dz = dx + </span><span class="s5">1j</span><span class="s1">*dy</span>
    <span class="s1">z = (roots + np.dstack((dz</span><span class="s2">,</span><span class="s1">)*roots.size)).flatten()</span>
    <span class="s2">with </span><span class="s1">mpmath.workdps(</span><span class="s5">30</span><span class="s1">):</span>
        <span class="s1">dataset = [(z0</span><span class="s2">, </span><span class="s1">complex(mpmath.digamma(z0))) </span><span class="s2">for </span><span class="s1">z0 </span><span class="s2">in </span><span class="s1">z]</span>

    <span class="s1">dataset = np.array(dataset)</span>
    <span class="s1">FuncData(sc.digamma</span><span class="s2">, </span><span class="s1">dataset</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-14</span><span class="s1">).check()</span>


<span class="s1">@check_version(mpmath</span><span class="s2">, </span><span class="s3">'0.19'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_digamma_negreal():</span>
    <span class="s4"># Test digamma around the negative real axis. Don't do this in</span>
    <span class="s4"># TestSystematic because the points need some jiggering so that</span>
    <span class="s4"># mpmath doesn't take forever.</span>

    <span class="s1">digamma = exception_to_nan(mpmath.digamma)</span>

    <span class="s1">x = -np.logspace(</span><span class="s5">300</span><span class="s2">, </span><span class="s1">-</span><span class="s5">30</span><span class="s2">, </span><span class="s5">100</span><span class="s1">)</span>
    <span class="s1">y = np.r_[-np.logspace(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">3</span><span class="s2">, </span><span class="s5">5</span><span class="s1">)</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">np.logspace(-</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">5</span><span class="s1">)]</span>
    <span class="s1">x</span><span class="s2">, </span><span class="s1">y = np.meshgrid(x</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s1">z = (x + </span><span class="s5">1j</span><span class="s1">*y).flatten()</span>

    <span class="s2">with </span><span class="s1">mpmath.workdps(</span><span class="s5">40</span><span class="s1">):</span>
        <span class="s1">dataset = [(z0</span><span class="s2">, </span><span class="s1">complex(digamma(z0))) </span><span class="s2">for </span><span class="s1">z0 </span><span class="s2">in </span><span class="s1">z]</span>
    <span class="s1">dataset = np.asarray(dataset)</span>

    <span class="s1">FuncData(sc.digamma</span><span class="s2">, </span><span class="s1">dataset</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-13</span><span class="s1">).check()</span>


<span class="s1">@check_version(mpmath</span><span class="s2">, </span><span class="s3">'0.19'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_digamma_boundary():</span>
    <span class="s4"># Check that there isn't a jump in accuracy when we switch from</span>
    <span class="s4"># using the asymptotic series to the reflection formula.</span>

    <span class="s1">x = -np.logspace(</span><span class="s5">300</span><span class="s2">, </span><span class="s1">-</span><span class="s5">30</span><span class="s2">, </span><span class="s5">100</span><span class="s1">)</span>
    <span class="s1">y = np.array([-</span><span class="s5">6.1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">5.9</span><span class="s2">, </span><span class="s5">5.9</span><span class="s2">, </span><span class="s5">6.1</span><span class="s1">])</span>
    <span class="s1">x</span><span class="s2">, </span><span class="s1">y = np.meshgrid(x</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s1">z = (x + </span><span class="s5">1j</span><span class="s1">*y).flatten()</span>

    <span class="s2">with </span><span class="s1">mpmath.workdps(</span><span class="s5">30</span><span class="s1">):</span>
        <span class="s1">dataset = [(z0</span><span class="s2">, </span><span class="s1">complex(mpmath.digamma(z0))) </span><span class="s2">for </span><span class="s1">z0 </span><span class="s2">in </span><span class="s1">z]</span>
    <span class="s1">dataset = np.asarray(dataset)</span>

    <span class="s1">FuncData(sc.digamma</span><span class="s2">, </span><span class="s1">dataset</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-13</span><span class="s1">).check()</span>


<span class="s4"># ------------------------------------------------------------------------------</span>
<span class="s4"># gammainc</span>
<span class="s4"># ------------------------------------------------------------------------------</span>

<span class="s1">@check_version(mpmath</span><span class="s2">, </span><span class="s3">'0.19'</span><span class="s1">)</span>
<span class="s1">@pytest.mark.slow</span>
<span class="s2">def </span><span class="s1">test_gammainc_boundary():</span>
    <span class="s4"># Test the transition to the asymptotic series.</span>
    <span class="s1">small = </span><span class="s5">20</span>
    <span class="s1">a = np.linspace(</span><span class="s5">0.5</span><span class="s1">*small</span><span class="s2">, </span><span class="s5">2</span><span class="s1">*small</span><span class="s2">, </span><span class="s5">50</span><span class="s1">)</span>
    <span class="s1">x = a.copy()</span>
    <span class="s1">a</span><span class="s2">, </span><span class="s1">x = np.meshgrid(a</span><span class="s2">, </span><span class="s1">x)</span>
    <span class="s1">a</span><span class="s2">, </span><span class="s1">x = a.flatten()</span><span class="s2">, </span><span class="s1">x.flatten()</span>
    <span class="s2">with </span><span class="s1">mpmath.workdps(</span><span class="s5">100</span><span class="s1">):</span>
        <span class="s1">dataset = [(a0</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">float(mpmath.gammainc(a0</span><span class="s2">, </span><span class="s1">b=x0</span><span class="s2">, </span><span class="s1">regularized=</span><span class="s2">True</span><span class="s1">)))</span>
                   <span class="s2">for </span><span class="s1">a0</span><span class="s2">, </span><span class="s1">x0 </span><span class="s2">in </span><span class="s1">zip(a</span><span class="s2">, </span><span class="s1">x)]</span>
    <span class="s1">dataset = np.array(dataset)</span>

    <span class="s1">FuncData(sc.gammainc</span><span class="s2">, </span><span class="s1">dataset</span><span class="s2">, </span><span class="s1">(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-12</span><span class="s1">).check()</span>


<span class="s4"># ------------------------------------------------------------------------------</span>
<span class="s4"># spence</span>
<span class="s4"># ------------------------------------------------------------------------------</span>

<span class="s1">@check_version(mpmath</span><span class="s2">, </span><span class="s3">'0.19'</span><span class="s1">)</span>
<span class="s1">@pytest.mark.slow</span>
<span class="s2">def </span><span class="s1">test_spence_circle():</span>
    <span class="s4"># The trickiest region for spence is around the circle |z - 1| = 1,</span>
    <span class="s4"># so test that region carefully.</span>

    <span class="s2">def </span><span class="s1">spence(z):</span>
        <span class="s2">return </span><span class="s1">complex(mpmath.polylog(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">1 </span><span class="s1">- z))</span>

    <span class="s1">r = np.linspace(</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">1.5</span><span class="s1">)</span>
    <span class="s1">theta = np.linspace(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s1">*pi)</span>
    <span class="s1">z = (</span><span class="s5">1 </span><span class="s1">+ np.outer(r</span><span class="s2">, </span><span class="s1">np.exp(</span><span class="s5">1j</span><span class="s1">*theta))).flatten()</span>
    <span class="s1">dataset = np.asarray([(z0</span><span class="s2">, </span><span class="s1">spence(z0)) </span><span class="s2">for </span><span class="s1">z0 </span><span class="s2">in </span><span class="s1">z])</span>

    <span class="s1">FuncData(sc.spence</span><span class="s2">, </span><span class="s1">dataset</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-14</span><span class="s1">).check()</span>


<span class="s4"># ------------------------------------------------------------------------------</span>
<span class="s4"># sinpi and cospi</span>
<span class="s4"># ------------------------------------------------------------------------------</span>

<span class="s1">@check_version(mpmath</span><span class="s2">, </span><span class="s3">'0.19'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_sinpi_zeros():</span>
    <span class="s1">eps = np.finfo(float).eps</span>
    <span class="s1">dx = np.r_[-np.logspace(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">13</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">np.logspace(-</span><span class="s5">13</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)]</span>
    <span class="s1">dy = dx.copy()</span>
    <span class="s1">dx</span><span class="s2">, </span><span class="s1">dy = np.meshgrid(dx</span><span class="s2">, </span><span class="s1">dy)</span>
    <span class="s1">dz = dx + </span><span class="s5">1j</span><span class="s1">*dy</span>
    <span class="s1">zeros = np.arange(-</span><span class="s5">100</span><span class="s2">, </span><span class="s5">100</span><span class="s2">, </span><span class="s5">1</span><span class="s1">).reshape(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">z = (zeros + np.dstack((dz</span><span class="s2">,</span><span class="s1">)*zeros.size)).flatten()</span>
    <span class="s1">dataset = np.asarray([(z0</span><span class="s2">, </span><span class="s1">complex(mpmath.sinpi(z0)))</span>
                          <span class="s2">for </span><span class="s1">z0 </span><span class="s2">in </span><span class="s1">z])</span>
    <span class="s1">FuncData(_sinpi</span><span class="s2">, </span><span class="s1">dataset</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">2</span><span class="s1">*eps).check()</span>


<span class="s1">@check_version(mpmath</span><span class="s2">, </span><span class="s3">'0.19'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_cospi_zeros():</span>
    <span class="s1">eps = np.finfo(float).eps</span>
    <span class="s1">dx = np.r_[-np.logspace(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">13</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">np.logspace(-</span><span class="s5">13</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)]</span>
    <span class="s1">dy = dx.copy()</span>
    <span class="s1">dx</span><span class="s2">, </span><span class="s1">dy = np.meshgrid(dx</span><span class="s2">, </span><span class="s1">dy)</span>
    <span class="s1">dz = dx + </span><span class="s5">1j</span><span class="s1">*dy</span>
    <span class="s1">zeros = (np.arange(-</span><span class="s5">100</span><span class="s2">, </span><span class="s5">100</span><span class="s2">, </span><span class="s5">1</span><span class="s1">) + </span><span class="s5">0.5</span><span class="s1">).reshape(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">z = (zeros + np.dstack((dz</span><span class="s2">,</span><span class="s1">)*zeros.size)).flatten()</span>
    <span class="s1">dataset = np.asarray([(z0</span><span class="s2">, </span><span class="s1">complex(mpmath.cospi(z0)))</span>
                          <span class="s2">for </span><span class="s1">z0 </span><span class="s2">in </span><span class="s1">z])</span>

    <span class="s1">FuncData(_cospi</span><span class="s2">, </span><span class="s1">dataset</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">2</span><span class="s1">*eps).check()</span>


<span class="s4"># ------------------------------------------------------------------------------</span>
<span class="s4"># ellipj</span>
<span class="s4"># ------------------------------------------------------------------------------</span>

<span class="s1">@check_version(mpmath</span><span class="s2">, </span><span class="s3">'0.19'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_dn_quarter_period():</span>
    <span class="s2">def </span><span class="s1">dn(u</span><span class="s2">, </span><span class="s1">m):</span>
        <span class="s2">return </span><span class="s1">sc.ellipj(u</span><span class="s2">, </span><span class="s1">m)[</span><span class="s5">2</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">mpmath_dn(u</span><span class="s2">, </span><span class="s1">m):</span>
        <span class="s2">return </span><span class="s1">float(mpmath.ellipfun(</span><span class="s3">&quot;dn&quot;</span><span class="s2">, </span><span class="s1">u=u</span><span class="s2">, </span><span class="s1">m=m))</span>

    <span class="s1">m = np.linspace(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">20</span><span class="s1">)</span>
    <span class="s1">du = np.r_[-np.logspace(-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">15</span><span class="s2">, </span><span class="s5">10</span><span class="s1">)</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">np.logspace(-</span><span class="s5">15</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">10</span><span class="s1">)]</span>
    <span class="s1">dataset = []</span>
    <span class="s2">for </span><span class="s1">m0 </span><span class="s2">in </span><span class="s1">m:</span>
        <span class="s1">u0 = float(mpmath.ellipk(m0))</span>
        <span class="s2">for </span><span class="s1">du0 </span><span class="s2">in </span><span class="s1">du:</span>
            <span class="s1">p = u0 + du0</span>
            <span class="s1">dataset.append((p</span><span class="s2">, </span><span class="s1">m0</span><span class="s2">, </span><span class="s1">mpmath_dn(p</span><span class="s2">, </span><span class="s1">m0)))</span>
    <span class="s1">dataset = np.asarray(dataset)</span>

    <span class="s1">FuncData(dn</span><span class="s2">, </span><span class="s1">dataset</span><span class="s2">, </span><span class="s1">(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-10</span><span class="s1">).check()</span>


<span class="s4"># ------------------------------------------------------------------------------</span>
<span class="s4"># Wright Omega</span>
<span class="s4"># ------------------------------------------------------------------------------</span>

<span class="s2">def </span><span class="s1">_mpmath_wrightomega(z</span><span class="s2">, </span><span class="s1">dps):</span>
    <span class="s2">with </span><span class="s1">mpmath.workdps(dps):</span>
        <span class="s1">z = mpmath.mpc(z)</span>
        <span class="s1">unwind = mpmath.ceil((z.imag - mpmath.pi)/(</span><span class="s5">2</span><span class="s1">*mpmath.pi))</span>
        <span class="s1">res = mpmath.lambertw(mpmath.exp(z)</span><span class="s2">, </span><span class="s1">unwind)</span>
    <span class="s2">return </span><span class="s1">res</span>


<span class="s1">@pytest.mark.slow</span>
<span class="s1">@check_version(mpmath</span><span class="s2">, </span><span class="s3">'0.19'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_wrightomega_branch():</span>
    <span class="s1">x = -np.logspace(</span><span class="s5">10</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">25</span><span class="s1">)</span>
    <span class="s1">picut_above = [np.nextafter(np.pi</span><span class="s2">, </span><span class="s1">np.inf)]</span>
    <span class="s1">picut_below = [np.nextafter(np.pi</span><span class="s2">, </span><span class="s1">-np.inf)]</span>
    <span class="s1">npicut_above = [np.nextafter(-np.pi</span><span class="s2">, </span><span class="s1">np.inf)]</span>
    <span class="s1">npicut_below = [np.nextafter(-np.pi</span><span class="s2">, </span><span class="s1">-np.inf)]</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">50</span><span class="s1">):</span>
        <span class="s1">picut_above.append(np.nextafter(picut_above[-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.inf))</span>
        <span class="s1">picut_below.append(np.nextafter(picut_below[-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">-np.inf))</span>
        <span class="s1">npicut_above.append(np.nextafter(npicut_above[-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.inf))</span>
        <span class="s1">npicut_below.append(np.nextafter(npicut_below[-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">-np.inf))</span>
    <span class="s1">y = np.hstack((picut_above</span><span class="s2">, </span><span class="s1">picut_below</span><span class="s2">, </span><span class="s1">npicut_above</span><span class="s2">, </span><span class="s1">npicut_below))</span>
    <span class="s1">x</span><span class="s2">, </span><span class="s1">y = np.meshgrid(x</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s1">z = (x + </span><span class="s5">1j</span><span class="s1">*y).flatten()</span>

    <span class="s1">dataset = np.asarray([(z0</span><span class="s2">, </span><span class="s1">complex(_mpmath_wrightomega(z0</span><span class="s2">, </span><span class="s5">25</span><span class="s1">)))</span>
                          <span class="s2">for </span><span class="s1">z0 </span><span class="s2">in </span><span class="s1">z])</span>

    <span class="s1">FuncData(sc.wrightomega</span><span class="s2">, </span><span class="s1">dataset</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-8</span><span class="s1">).check()</span>


<span class="s1">@pytest.mark.slow</span>
<span class="s1">@check_version(mpmath</span><span class="s2">, </span><span class="s3">'0.19'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_wrightomega_region1():</span>
    <span class="s4"># This region gets less coverage in the TestSystematic test</span>
    <span class="s1">x = np.linspace(-</span><span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">y = np.linspace(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">*np.pi)</span>
    <span class="s1">x</span><span class="s2">, </span><span class="s1">y = np.meshgrid(x</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s1">z = (x + </span><span class="s5">1j</span><span class="s1">*y).flatten()</span>

    <span class="s1">dataset = np.asarray([(z0</span><span class="s2">, </span><span class="s1">complex(_mpmath_wrightomega(z0</span><span class="s2">, </span><span class="s5">25</span><span class="s1">)))</span>
                          <span class="s2">for </span><span class="s1">z0 </span><span class="s2">in </span><span class="s1">z])</span>

    <span class="s1">FuncData(sc.wrightomega</span><span class="s2">, </span><span class="s1">dataset</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-15</span><span class="s1">).check()</span>


<span class="s1">@pytest.mark.slow</span>
<span class="s1">@check_version(mpmath</span><span class="s2">, </span><span class="s3">'0.19'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_wrightomega_region2():</span>
    <span class="s4"># This region gets less coverage in the TestSystematic test</span>
    <span class="s1">x = np.linspace(-</span><span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">y = np.linspace(-</span><span class="s5">2</span><span class="s1">*np.pi</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">x</span><span class="s2">, </span><span class="s1">y = np.meshgrid(x</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s1">z = (x + </span><span class="s5">1j</span><span class="s1">*y).flatten()</span>

    <span class="s1">dataset = np.asarray([(z0</span><span class="s2">, </span><span class="s1">complex(_mpmath_wrightomega(z0</span><span class="s2">, </span><span class="s5">25</span><span class="s1">)))</span>
                          <span class="s2">for </span><span class="s1">z0 </span><span class="s2">in </span><span class="s1">z])</span>

    <span class="s1">FuncData(sc.wrightomega</span><span class="s2">, </span><span class="s1">dataset</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-15</span><span class="s1">).check()</span>


<span class="s4"># ------------------------------------------------------------------------------</span>
<span class="s4"># lambertw</span>
<span class="s4"># ------------------------------------------------------------------------------</span>

<span class="s1">@pytest.mark.slow</span>
<span class="s1">@check_version(mpmath</span><span class="s2">, </span><span class="s3">'0.19'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_lambertw_smallz():</span>
    <span class="s1">x</span><span class="s2">, </span><span class="s1">y = np.linspace(-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">25</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.linspace(-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">25</span><span class="s1">)</span>
    <span class="s1">x</span><span class="s2">, </span><span class="s1">y = np.meshgrid(x</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s1">z = (x + </span><span class="s5">1j</span><span class="s1">*y).flatten()</span>

    <span class="s1">dataset = np.asarray([(z0</span><span class="s2">, </span><span class="s1">complex(mpmath.lambertw(z0)))</span>
                          <span class="s2">for </span><span class="s1">z0 </span><span class="s2">in </span><span class="s1">z])</span>

    <span class="s1">FuncData(sc.lambertw</span><span class="s2">, </span><span class="s1">dataset</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-13</span><span class="s1">).check()</span>


<span class="s4"># ------------------------------------------------------------------------------</span>
<span class="s4"># Systematic tests</span>
<span class="s4"># ------------------------------------------------------------------------------</span>

<span class="s1">HYPERKW = dict(maxprec=</span><span class="s5">200</span><span class="s2">, </span><span class="s1">maxterms=</span><span class="s5">200</span><span class="s1">)</span>


<span class="s1">@pytest.mark.slow</span>
<span class="s1">@check_version(mpmath</span><span class="s2">, </span><span class="s3">'0.17'</span><span class="s1">)</span>
<span class="s2">class </span><span class="s1">TestSystematic:</span>

    <span class="s2">def </span><span class="s1">test_airyai(self):</span>
        <span class="s4"># oscillating function, limit range</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">z: sc.airy(z)[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">mpmath.airyai</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e8</span><span class="s2">, </span><span class="s5">1e8</span><span class="s1">)]</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s5">1e-5</span><span class="s1">)</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">z: sc.airy(z)[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">mpmath.airyai</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e3</span><span class="s2">, </span><span class="s5">1e3</span><span class="s1">)])</span>

    <span class="s2">def </span><span class="s1">test_airyai_complex(self):</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">z: sc.airy(z)[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">mpmath.airyai</span><span class="s2">,</span>
                            <span class="s1">[ComplexArg()])</span>

    <span class="s2">def </span><span class="s1">test_airyai_prime(self):</span>
        <span class="s4"># oscillating function, limit range</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">z: sc.airy(z)[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, lambda </span><span class="s1">z:</span>
                            <span class="s1">mpmath.airyai(z</span><span class="s2">, </span><span class="s1">derivative=</span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e8</span><span class="s2">, </span><span class="s5">1e8</span><span class="s1">)]</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s5">1e-5</span><span class="s1">)</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">z: sc.airy(z)[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, lambda </span><span class="s1">z:</span>
                            <span class="s1">mpmath.airyai(z</span><span class="s2">, </span><span class="s1">derivative=</span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e3</span><span class="s2">, </span><span class="s5">1e3</span><span class="s1">)])</span>

    <span class="s2">def </span><span class="s1">test_airyai_prime_complex(self):</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">z: sc.airy(z)[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, lambda </span><span class="s1">z:</span>
                            <span class="s1">mpmath.airyai(z</span><span class="s2">, </span><span class="s1">derivative=</span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                            <span class="s1">[ComplexArg()])</span>

    <span class="s2">def </span><span class="s1">test_airybi(self):</span>
        <span class="s4"># oscillating function, limit range</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">z: sc.airy(z)[</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, lambda </span><span class="s1">z:</span>
                            <span class="s1">mpmath.airybi(z)</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e8</span><span class="s2">, </span><span class="s5">1e8</span><span class="s1">)]</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s5">1e-5</span><span class="s1">)</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">z: sc.airy(z)[</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, lambda </span><span class="s1">z:</span>
                            <span class="s1">mpmath.airybi(z)</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e3</span><span class="s2">, </span><span class="s5">1e3</span><span class="s1">)])</span>

    <span class="s2">def </span><span class="s1">test_airybi_complex(self):</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">z: sc.airy(z)[</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, lambda </span><span class="s1">z:</span>
                            <span class="s1">mpmath.airybi(z)</span><span class="s2">,</span>
                            <span class="s1">[ComplexArg()])</span>

    <span class="s2">def </span><span class="s1">test_airybi_prime(self):</span>
        <span class="s4"># oscillating function, limit range</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">z: sc.airy(z)[</span><span class="s5">3</span><span class="s1">]</span><span class="s2">, lambda </span><span class="s1">z:</span>
                            <span class="s1">mpmath.airybi(z</span><span class="s2">, </span><span class="s1">derivative=</span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e8</span><span class="s2">, </span><span class="s5">1e8</span><span class="s1">)]</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s5">1e-5</span><span class="s1">)</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">z: sc.airy(z)[</span><span class="s5">3</span><span class="s1">]</span><span class="s2">, lambda </span><span class="s1">z:</span>
                            <span class="s1">mpmath.airybi(z</span><span class="s2">, </span><span class="s1">derivative=</span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e3</span><span class="s2">, </span><span class="s5">1e3</span><span class="s1">)])</span>

    <span class="s2">def </span><span class="s1">test_airybi_prime_complex(self):</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">z: sc.airy(z)[</span><span class="s5">3</span><span class="s1">]</span><span class="s2">, lambda </span><span class="s1">z:</span>
                            <span class="s1">mpmath.airybi(z</span><span class="s2">, </span><span class="s1">derivative=</span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                            <span class="s1">[ComplexArg()])</span>

    <span class="s2">def </span><span class="s1">test_bei(self):</span>
        <span class="s1">assert_mpmath_equal(sc.bei</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(</span><span class="s2">lambda </span><span class="s1">z: mpmath.bei(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">**HYPERKW))</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e3</span><span class="s2">, </span><span class="s5">1e3</span><span class="s1">)])</span>

    <span class="s2">def </span><span class="s1">test_ber(self):</span>
        <span class="s1">assert_mpmath_equal(sc.ber</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(</span><span class="s2">lambda </span><span class="s1">z: mpmath.ber(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">**HYPERKW))</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e3</span><span class="s2">, </span><span class="s5">1e3</span><span class="s1">)])</span>

    <span class="s2">def </span><span class="s1">test_bernoulli(self):</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">n: sc.bernoulli(int(n))[int(n)]</span><span class="s2">,</span>
                            <span class="s2">lambda </span><span class="s1">n: float(mpmath.bernoulli(int(n)))</span><span class="s2">,</span>
                            <span class="s1">[IntArg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">13000</span><span class="s1">)]</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s5">1e-9</span><span class="s2">, </span><span class="s1">n=</span><span class="s5">13000</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_besseli(self):</span>
        <span class="s1">assert_mpmath_equal(sc.iv</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(</span><span class="s2">lambda </span><span class="s1">v</span><span class="s2">, </span><span class="s1">z: mpmath.besseli(v</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">**HYPERKW))</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e100</span><span class="s2">, </span><span class="s5">1e100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg()]</span><span class="s2">,</span>
                            <span class="s1">atol=</span><span class="s5">1e-270</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_besseli_complex(self):</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">v</span><span class="s2">, </span><span class="s1">z: sc.iv(v.real</span><span class="s2">, </span><span class="s1">z)</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(</span><span class="s2">lambda </span><span class="s1">v</span><span class="s2">, </span><span class="s1">z: mpmath.besseli(v</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">**HYPERKW))</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e100</span><span class="s2">, </span><span class="s5">1e100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">ComplexArg()])</span>

    <span class="s2">def </span><span class="s1">test_besselj(self):</span>
        <span class="s1">assert_mpmath_equal(sc.jv</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(</span><span class="s2">lambda </span><span class="s1">v</span><span class="s2">, </span><span class="s1">z: mpmath.besselj(v</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">**HYPERKW))</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e100</span><span class="s2">, </span><span class="s5">1e100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg(-</span><span class="s5">1e3</span><span class="s2">, </span><span class="s5">1e3</span><span class="s1">)]</span><span class="s2">,</span>
                            <span class="s1">ignore_inf_sign=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s4"># loss of precision at large arguments due to oscillation</span>
        <span class="s1">assert_mpmath_equal(sc.jv</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(</span><span class="s2">lambda </span><span class="s1">v</span><span class="s2">, </span><span class="s1">z: mpmath.besselj(v</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">**HYPERKW))</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e100</span><span class="s2">, </span><span class="s5">1e100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg(-</span><span class="s5">1e8</span><span class="s2">, </span><span class="s5">1e8</span><span class="s1">)]</span><span class="s2">,</span>
                            <span class="s1">ignore_inf_sign=</span><span class="s2">True,</span>
                            <span class="s1">rtol=</span><span class="s5">1e-5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_besselj_complex(self):</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">v</span><span class="s2">, </span><span class="s1">z: sc.jv(v.real</span><span class="s2">, </span><span class="s1">z)</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(</span><span class="s2">lambda </span><span class="s1">v</span><span class="s2">, </span><span class="s1">z: mpmath.besselj(v</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">**HYPERKW))</span><span class="s2">,</span>
                            <span class="s1">[Arg()</span><span class="s2">, </span><span class="s1">ComplexArg()])</span>

    <span class="s2">def </span><span class="s1">test_besselk(self):</span>
        <span class="s1">assert_mpmath_equal(sc.kv</span><span class="s2">,</span>
                            <span class="s1">mpmath.besselk</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">200</span><span class="s2">, </span><span class="s5">200</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">np.inf)]</span><span class="s2">,</span>
                            <span class="s1">nan_ok=</span><span class="s2">False, </span><span class="s1">rtol=</span><span class="s5">1e-12</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_besselk_int(self):</span>
        <span class="s1">assert_mpmath_equal(sc.kn</span><span class="s2">,</span>
                            <span class="s1">mpmath.besselk</span><span class="s2">,</span>
                            <span class="s1">[IntArg(-</span><span class="s5">200</span><span class="s2">, </span><span class="s5">200</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">np.inf)]</span><span class="s2">,</span>
                            <span class="s1">nan_ok=</span><span class="s2">False, </span><span class="s1">rtol=</span><span class="s5">1e-12</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_besselk_complex(self):</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">v</span><span class="s2">, </span><span class="s1">z: sc.kv(v.real</span><span class="s2">, </span><span class="s1">z)</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(</span><span class="s2">lambda </span><span class="s1">v</span><span class="s2">, </span><span class="s1">z: mpmath.besselk(v</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">**HYPERKW))</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e100</span><span class="s2">, </span><span class="s5">1e100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">ComplexArg()])</span>

    <span class="s2">def </span><span class="s1">test_bessely(self):</span>
        <span class="s2">def </span><span class="s1">mpbessely(v</span><span class="s2">, </span><span class="s1">x):</span>
            <span class="s1">r = float(mpmath.bessely(v</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">**HYPERKW))</span>
            <span class="s2">if </span><span class="s1">abs(r) &gt; </span><span class="s5">1e305</span><span class="s1">:</span>
                <span class="s4"># overflowing to inf a bit earlier is OK</span>
                <span class="s1">r = np.inf * np.sign(r)</span>
            <span class="s2">if </span><span class="s1">abs(r) == </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">x == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s4"># invalid result from mpmath, point x=0 is a divergence</span>
                <span class="s2">return </span><span class="s1">np.nan</span>
            <span class="s2">return </span><span class="s1">r</span>
        <span class="s1">assert_mpmath_equal(sc.yv</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(mpbessely)</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e100</span><span class="s2">, </span><span class="s5">1e100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg(-</span><span class="s5">1e8</span><span class="s2">, </span><span class="s5">1e8</span><span class="s1">)]</span><span class="s2">,</span>
                            <span class="s1">n=</span><span class="s5">5000</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bessely_complex(self):</span>
        <span class="s2">def </span><span class="s1">mpbessely(v</span><span class="s2">, </span><span class="s1">x):</span>
            <span class="s1">r = complex(mpmath.bessely(v</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">**HYPERKW))</span>
            <span class="s2">if </span><span class="s1">abs(r) &gt; </span><span class="s5">1e305</span><span class="s1">:</span>
                <span class="s4"># overflowing to inf a bit earlier is OK</span>
                <span class="s2">with </span><span class="s1">np.errstate(invalid=</span><span class="s3">'ignore'</span><span class="s1">):</span>
                    <span class="s1">r = np.inf * np.sign(r)</span>
            <span class="s2">return </span><span class="s1">r</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">v</span><span class="s2">, </span><span class="s1">z: sc.yv(v.real</span><span class="s2">, </span><span class="s1">z)</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(mpbessely)</span><span class="s2">,</span>
                            <span class="s1">[Arg()</span><span class="s2">, </span><span class="s1">ComplexArg()]</span><span class="s2">,</span>
                            <span class="s1">n=</span><span class="s5">15000</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bessely_int(self):</span>
        <span class="s2">def </span><span class="s1">mpbessely(v</span><span class="s2">, </span><span class="s1">x):</span>
            <span class="s1">r = float(mpmath.bessely(v</span><span class="s2">, </span><span class="s1">x))</span>
            <span class="s2">if </span><span class="s1">abs(r) == </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">x == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s4"># invalid result from mpmath, point x=0 is a divergence</span>
                <span class="s2">return </span><span class="s1">np.nan</span>
            <span class="s2">return </span><span class="s1">r</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">v</span><span class="s2">, </span><span class="s1">z: sc.yn(int(v)</span><span class="s2">, </span><span class="s1">z)</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(mpbessely)</span><span class="s2">,</span>
                            <span class="s1">[IntArg(-</span><span class="s5">1000</span><span class="s2">, </span><span class="s5">1000</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg(-</span><span class="s5">1e8</span><span class="s2">, </span><span class="s5">1e8</span><span class="s1">)])</span>

    <span class="s2">def </span><span class="s1">test_beta(self):</span>
        <span class="s1">bad_points = []</span>

        <span class="s2">def </span><span class="s1">beta(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">nonzero=</span><span class="s2">False</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">a &lt; -</span><span class="s5">1e12 </span><span class="s2">or </span><span class="s1">b &lt; -</span><span class="s5">1e12</span><span class="s1">:</span>
                <span class="s4"># Function is defined here only at integers, but due</span>
                <span class="s4"># to loss of precision this is numerically</span>
                <span class="s4"># ill-defined. Don't compare values here.</span>
                <span class="s2">return </span><span class="s1">np.nan</span>
            <span class="s2">if </span><span class="s1">(a &lt; </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">b &lt; </span><span class="s5">0</span><span class="s1">) </span><span class="s2">and </span><span class="s1">(abs(float(a + b)) % </span><span class="s5">1</span><span class="s1">) == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s4"># close to a zero of the function: mpmath and scipy</span>
                <span class="s4"># will not round here the same, so the test needs to be</span>
                <span class="s4"># run with an absolute tolerance</span>
                <span class="s2">if </span><span class="s1">nonzero:</span>
                    <span class="s1">bad_points.append((float(a)</span><span class="s2">, </span><span class="s1">float(b)))</span>
                    <span class="s2">return </span><span class="s1">np.nan</span>
            <span class="s2">return </span><span class="s1">mpmath.beta(a</span><span class="s2">, </span><span class="s1">b)</span>

        <span class="s1">assert_mpmath_equal(sc.beta</span><span class="s2">,</span>
                            <span class="s2">lambda </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b: beta(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">nonzero=</span><span class="s2">True</span><span class="s1">)</span><span class="s2">,</span>
                            <span class="s1">[Arg()</span><span class="s2">, </span><span class="s1">Arg()]</span><span class="s2">,</span>
                            <span class="s1">dps=</span><span class="s5">400</span><span class="s2">,</span>
                            <span class="s1">ignore_inf_sign=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s1">assert_mpmath_equal(sc.beta</span><span class="s2">,</span>
                            <span class="s1">beta</span><span class="s2">,</span>
                            <span class="s1">np.array(bad_points)</span><span class="s2">,</span>
                            <span class="s1">dps=</span><span class="s5">400</span><span class="s2">,</span>
                            <span class="s1">ignore_inf_sign=</span><span class="s2">True,</span>
                            <span class="s1">atol=</span><span class="s5">1e-11</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_betainc(self):</span>
        <span class="s1">assert_mpmath_equal(sc.betainc</span><span class="s2">,</span>
                            <span class="s1">time_limited()(exception_to_nan(</span><span class="s2">lambda </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x: mpmath.betainc(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">regularized=</span><span class="s2">True</span><span class="s1">)))</span><span class="s2">,</span>
                            <span class="s1">[Arg()</span><span class="s2">, </span><span class="s1">Arg()</span><span class="s2">, </span><span class="s1">Arg()])</span>

    <span class="s2">def </span><span class="s1">test_binom(self):</span>
        <span class="s1">bad_points = []</span>

        <span class="s2">def </span><span class="s1">binomial(n</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">nonzero=</span><span class="s2">False</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">abs(k) &gt; </span><span class="s5">1e8</span><span class="s1">*(abs(n) + </span><span class="s5">1</span><span class="s1">):</span>
                <span class="s4"># The binomial is rapidly oscillating in this region,</span>
                <span class="s4"># and the function is numerically ill-defined. Don't</span>
                <span class="s4"># compare values here.</span>
                <span class="s2">return </span><span class="s1">np.nan</span>
            <span class="s2">if </span><span class="s1">n &lt; k </span><span class="s2">and </span><span class="s1">abs(float(n-k) - np.round(float(n-k))) &lt; </span><span class="s5">1e-15</span><span class="s1">:</span>
                <span class="s4"># close to a zero of the function: mpmath and scipy</span>
                <span class="s4"># will not round here the same, so the test needs to be</span>
                <span class="s4"># run with an absolute tolerance</span>
                <span class="s2">if </span><span class="s1">nonzero:</span>
                    <span class="s1">bad_points.append((float(n)</span><span class="s2">, </span><span class="s1">float(k)))</span>
                    <span class="s2">return </span><span class="s1">np.nan</span>
            <span class="s2">return </span><span class="s1">mpmath.binomial(n</span><span class="s2">, </span><span class="s1">k)</span>

        <span class="s1">assert_mpmath_equal(sc.binom</span><span class="s2">,</span>
                            <span class="s2">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">k: binomial(n</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">nonzero=</span><span class="s2">True</span><span class="s1">)</span><span class="s2">,</span>
                            <span class="s1">[Arg()</span><span class="s2">, </span><span class="s1">Arg()]</span><span class="s2">,</span>
                            <span class="s1">dps=</span><span class="s5">400</span><span class="s1">)</span>

        <span class="s1">assert_mpmath_equal(sc.binom</span><span class="s2">,</span>
                            <span class="s1">binomial</span><span class="s2">,</span>
                            <span class="s1">np.array(bad_points)</span><span class="s2">,</span>
                            <span class="s1">dps=</span><span class="s5">400</span><span class="s2">,</span>
                            <span class="s1">atol=</span><span class="s5">1e-14</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_chebyt_int(self):</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">x: sc.eval_chebyt(int(n)</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(</span><span class="s2">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">x: mpmath.chebyt(n</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">**HYPERKW))</span><span class="s2">,</span>
                            <span class="s1">[IntArg()</span><span class="s2">, </span><span class="s1">Arg()]</span><span class="s2">, </span><span class="s1">dps=</span><span class="s5">50</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.xfail(run=</span><span class="s2">False, </span><span class="s1">reason=</span><span class="s3">&quot;some cases in hyp2f1 not fully accurate&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_chebyt(self):</span>
        <span class="s1">assert_mpmath_equal(sc.eval_chebyt</span><span class="s2">,</span>
                            <span class="s2">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">x: time_limited()(exception_to_nan(mpmath.chebyt))(n</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">**HYPERKW)</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">101</span><span class="s2">, </span><span class="s5">101</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg()]</span><span class="s2">, </span><span class="s1">n=</span><span class="s5">10000</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_chebyu_int(self):</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">x: sc.eval_chebyu(int(n)</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(</span><span class="s2">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">x: mpmath.chebyu(n</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">**HYPERKW))</span><span class="s2">,</span>
                            <span class="s1">[IntArg()</span><span class="s2">, </span><span class="s1">Arg()]</span><span class="s2">, </span><span class="s1">dps=</span><span class="s5">50</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.xfail(run=</span><span class="s2">False, </span><span class="s1">reason=</span><span class="s3">&quot;some cases in hyp2f1 not fully accurate&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_chebyu(self):</span>
        <span class="s1">assert_mpmath_equal(sc.eval_chebyu</span><span class="s2">,</span>
                            <span class="s2">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">x: time_limited()(exception_to_nan(mpmath.chebyu))(n</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">**HYPERKW)</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">101</span><span class="s2">, </span><span class="s5">101</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg()])</span>

    <span class="s2">def </span><span class="s1">test_chi(self):</span>
        <span class="s2">def </span><span class="s1">chi(x):</span>
            <span class="s2">return </span><span class="s1">sc.shichi(x)[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">assert_mpmath_equal(chi</span><span class="s2">, </span><span class="s1">mpmath.chi</span><span class="s2">, </span><span class="s1">[Arg()])</span>
        <span class="s4"># check asymptotic series cross-over</span>
        <span class="s1">assert_mpmath_equal(chi</span><span class="s2">, </span><span class="s1">mpmath.chi</span><span class="s2">, </span><span class="s1">[FixedArg([</span><span class="s5">88 </span><span class="s1">- </span><span class="s5">1e-9</span><span class="s2">, </span><span class="s5">88</span><span class="s2">, </span><span class="s5">88 </span><span class="s1">+ </span><span class="s5">1e-9</span><span class="s1">])])</span>

    <span class="s2">def </span><span class="s1">test_chi_complex(self):</span>
        <span class="s2">def </span><span class="s1">chi(z):</span>
            <span class="s2">return </span><span class="s1">sc.shichi(z)[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s4"># chi oscillates as Im[z] -&gt; +- inf, so limit range</span>
        <span class="s1">assert_mpmath_equal(chi</span><span class="s2">,</span>
                            <span class="s1">mpmath.chi</span><span class="s2">,</span>
                            <span class="s1">[ComplexArg(complex(-np.inf</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1e8</span><span class="s1">)</span><span class="s2">, </span><span class="s1">complex(np.inf</span><span class="s2">, </span><span class="s5">1e8</span><span class="s1">))]</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s5">1e-12</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_ci(self):</span>
        <span class="s2">def </span><span class="s1">ci(x):</span>
            <span class="s2">return </span><span class="s1">sc.sici(x)[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s4"># oscillating function: limit range</span>
        <span class="s1">assert_mpmath_equal(ci</span><span class="s2">,</span>
                            <span class="s1">mpmath.ci</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e8</span><span class="s2">, </span><span class="s5">1e8</span><span class="s1">)])</span>

    <span class="s2">def </span><span class="s1">test_ci_complex(self):</span>
        <span class="s2">def </span><span class="s1">ci(z):</span>
            <span class="s2">return </span><span class="s1">sc.sici(z)[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s4"># ci oscillates as Re[z] -&gt; +- inf, so limit range</span>
        <span class="s1">assert_mpmath_equal(ci</span><span class="s2">,</span>
                            <span class="s1">mpmath.ci</span><span class="s2">,</span>
                            <span class="s1">[ComplexArg(complex(-</span><span class="s5">1e8</span><span class="s2">, </span><span class="s1">-np.inf)</span><span class="s2">, </span><span class="s1">complex(</span><span class="s5">1e8</span><span class="s2">, </span><span class="s1">np.inf))]</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s5">1e-8</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_cospi(self):</span>
        <span class="s1">eps = np.finfo(float).eps</span>
        <span class="s1">assert_mpmath_equal(_cospi</span><span class="s2">,</span>
                            <span class="s1">mpmath.cospi</span><span class="s2">,</span>
                            <span class="s1">[Arg()]</span><span class="s2">, </span><span class="s1">nan_ok=</span><span class="s2">False, </span><span class="s1">rtol=</span><span class="s5">2</span><span class="s1">*eps)</span>

    <span class="s2">def </span><span class="s1">test_cospi_complex(self):</span>
        <span class="s1">assert_mpmath_equal(_cospi</span><span class="s2">,</span>
                            <span class="s1">mpmath.cospi</span><span class="s2">,</span>
                            <span class="s1">[ComplexArg()]</span><span class="s2">, </span><span class="s1">nan_ok=</span><span class="s2">False, </span><span class="s1">rtol=</span><span class="s5">1e-13</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_digamma(self):</span>
        <span class="s1">assert_mpmath_equal(sc.digamma</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(mpmath.digamma)</span><span class="s2">,</span>
                            <span class="s1">[Arg()]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-12</span><span class="s2">, </span><span class="s1">dps=</span><span class="s5">50</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_digamma_complex(self):</span>
        <span class="s4"># Test on a cut plane because mpmath will hang. See</span>
        <span class="s4"># test_digamma_negreal for tests on the negative real axis.</span>
        <span class="s2">def </span><span class="s1">param_filter(z):</span>
            <span class="s2">return </span><span class="s1">np.where((z.real &lt; </span><span class="s5">0</span><span class="s1">) &amp; (np.abs(z.imag) &lt; </span><span class="s5">1.12</span><span class="s1">)</span><span class="s2">, False, True</span><span class="s1">)</span>

        <span class="s1">assert_mpmath_equal(sc.digamma</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(mpmath.digamma)</span><span class="s2">,</span>
                            <span class="s1">[ComplexArg()]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-13</span><span class="s2">, </span><span class="s1">dps=</span><span class="s5">40</span><span class="s2">,</span>
                            <span class="s1">param_filter=param_filter)</span>

    <span class="s2">def </span><span class="s1">test_e1(self):</span>
        <span class="s1">assert_mpmath_equal(sc.exp1</span><span class="s2">,</span>
                            <span class="s1">mpmath.e1</span><span class="s2">,</span>
                            <span class="s1">[Arg()]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-14</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_e1_complex(self):</span>
        <span class="s4"># E_1 oscillates as Im[z] -&gt; +- inf, so limit range</span>
        <span class="s1">assert_mpmath_equal(sc.exp1</span><span class="s2">,</span>
                            <span class="s1">mpmath.e1</span><span class="s2">,</span>
                            <span class="s1">[ComplexArg(complex(-np.inf</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1e8</span><span class="s1">)</span><span class="s2">, </span><span class="s1">complex(np.inf</span><span class="s2">, </span><span class="s5">1e8</span><span class="s1">))]</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s5">1e-11</span><span class="s1">)</span>

        <span class="s4"># Check cross-over region</span>
        <span class="s1">assert_mpmath_equal(sc.exp1</span><span class="s2">,</span>
                            <span class="s1">mpmath.e1</span><span class="s2">,</span>
                            <span class="s1">(np.linspace(-</span><span class="s5">50</span><span class="s2">, </span><span class="s5">50</span><span class="s2">, </span><span class="s5">171</span><span class="s1">)[:</span><span class="s2">, None</span><span class="s1">] +</span>
                             <span class="s1">np.r_[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">np.logspace(-</span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">61</span><span class="s1">)</span><span class="s2">,</span>
                                   <span class="s1">-np.logspace(-</span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">11</span><span class="s1">)]*</span><span class="s5">1j</span><span class="s1">).ravel()</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s5">1e-11</span><span class="s1">)</span>
        <span class="s1">assert_mpmath_equal(sc.exp1</span><span class="s2">,</span>
                            <span class="s1">mpmath.e1</span><span class="s2">,</span>
                            <span class="s1">(np.linspace(-</span><span class="s5">50</span><span class="s2">, </span><span class="s1">-</span><span class="s5">35</span><span class="s2">, </span><span class="s5">10000</span><span class="s1">) + </span><span class="s5">0j</span><span class="s1">)</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s5">1e-11</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_exprel(self):</span>
        <span class="s1">assert_mpmath_equal(sc.exprel</span><span class="s2">,</span>
                            <span class="s2">lambda </span><span class="s1">x: mpmath.expm1(x)/x </span><span class="s2">if </span><span class="s1">x != </span><span class="s5">0 </span><span class="s2">else </span><span class="s1">mpmath.mpf(</span><span class="s3">'1.0'</span><span class="s1">)</span><span class="s2">,</span>
                            <span class="s1">[Arg(a=-np.log(np.finfo(np.double).max)</span><span class="s2">, </span><span class="s1">b=np.log(np.finfo(np.double).max))])</span>
        <span class="s1">assert_mpmath_equal(sc.exprel</span><span class="s2">,</span>
                            <span class="s2">lambda </span><span class="s1">x: mpmath.expm1(x)/x </span><span class="s2">if </span><span class="s1">x != </span><span class="s5">0 </span><span class="s2">else </span><span class="s1">mpmath.mpf(</span><span class="s3">'1.0'</span><span class="s1">)</span><span class="s2">,</span>
                            <span class="s1">np.array([</span><span class="s5">1e-12</span><span class="s2">, </span><span class="s5">1e-24</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1e12</span><span class="s2">, </span><span class="s5">1e24</span><span class="s2">, </span><span class="s1">np.inf])</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-11</span><span class="s1">)</span>
        <span class="s1">assert_(np.isinf(sc.exprel(np.inf)))</span>
        <span class="s1">assert_(sc.exprel(-np.inf) == </span><span class="s5">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_expm1_complex(self):</span>
        <span class="s4"># Oscillates as a function of Im[z], so limit range to avoid loss of precision</span>
        <span class="s1">assert_mpmath_equal(sc.expm1</span><span class="s2">,</span>
                            <span class="s1">mpmath.expm1</span><span class="s2">,</span>
                            <span class="s1">[ComplexArg(complex(-np.inf</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1e7</span><span class="s1">)</span><span class="s2">, </span><span class="s1">complex(np.inf</span><span class="s2">, </span><span class="s5">1e7</span><span class="s1">))])</span>

    <span class="s2">def </span><span class="s1">test_log1p_complex(self):</span>
        <span class="s1">assert_mpmath_equal(sc.log1p</span><span class="s2">,</span>
                            <span class="s2">lambda </span><span class="s1">x: mpmath.log(x+</span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                            <span class="s1">[ComplexArg()]</span><span class="s2">, </span><span class="s1">dps=</span><span class="s5">60</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_log1pmx(self):</span>
        <span class="s1">assert_mpmath_equal(_log1pmx</span><span class="s2">,</span>
                            <span class="s2">lambda </span><span class="s1">x: mpmath.log(x + </span><span class="s5">1</span><span class="s1">) - x</span><span class="s2">,</span>
                            <span class="s1">[Arg()]</span><span class="s2">, </span><span class="s1">dps=</span><span class="s5">60</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-14</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_ei(self):</span>
        <span class="s1">assert_mpmath_equal(sc.expi</span><span class="s2">,</span>
                            <span class="s1">mpmath.ei</span><span class="s2">,</span>
                            <span class="s1">[Arg()]</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s5">1e-11</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_ei_complex(self):</span>
        <span class="s4"># Ei oscillates as Im[z] -&gt; +- inf, so limit range</span>
        <span class="s1">assert_mpmath_equal(sc.expi</span><span class="s2">,</span>
                            <span class="s1">mpmath.ei</span><span class="s2">,</span>
                            <span class="s1">[ComplexArg(complex(-np.inf</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1e8</span><span class="s1">)</span><span class="s2">, </span><span class="s1">complex(np.inf</span><span class="s2">, </span><span class="s5">1e8</span><span class="s1">))]</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s5">1e-9</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_ellipe(self):</span>
        <span class="s1">assert_mpmath_equal(sc.ellipe</span><span class="s2">,</span>
                            <span class="s1">mpmath.ellipe</span><span class="s2">,</span>
                            <span class="s1">[Arg(b=</span><span class="s5">1.0</span><span class="s1">)])</span>

    <span class="s2">def </span><span class="s1">test_ellipeinc(self):</span>
        <span class="s1">assert_mpmath_equal(sc.ellipeinc</span><span class="s2">,</span>
                            <span class="s1">mpmath.ellipe</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e3</span><span class="s2">, </span><span class="s5">1e3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg(b=</span><span class="s5">1.0</span><span class="s1">)])</span>

    <span class="s2">def </span><span class="s1">test_ellipeinc_largephi(self):</span>
        <span class="s1">assert_mpmath_equal(sc.ellipeinc</span><span class="s2">,</span>
                            <span class="s1">mpmath.ellipe</span><span class="s2">,</span>
                            <span class="s1">[Arg()</span><span class="s2">, </span><span class="s1">Arg()])</span>

    <span class="s2">def </span><span class="s1">test_ellipf(self):</span>
        <span class="s1">assert_mpmath_equal(sc.ellipkinc</span><span class="s2">,</span>
                            <span class="s1">mpmath.ellipf</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e3</span><span class="s2">, </span><span class="s5">1e3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg()])</span>

    <span class="s2">def </span><span class="s1">test_ellipf_largephi(self):</span>
        <span class="s1">assert_mpmath_equal(sc.ellipkinc</span><span class="s2">,</span>
                            <span class="s1">mpmath.ellipf</span><span class="s2">,</span>
                            <span class="s1">[Arg()</span><span class="s2">, </span><span class="s1">Arg()])</span>

    <span class="s2">def </span><span class="s1">test_ellipk(self):</span>
        <span class="s1">assert_mpmath_equal(sc.ellipk</span><span class="s2">,</span>
                            <span class="s1">mpmath.ellipk</span><span class="s2">,</span>
                            <span class="s1">[Arg(b=</span><span class="s5">1.0</span><span class="s1">)])</span>
        <span class="s1">assert_mpmath_equal(sc.ellipkm1</span><span class="s2">,</span>
                            <span class="s2">lambda </span><span class="s1">m: mpmath.ellipk(</span><span class="s5">1 </span><span class="s1">- m)</span><span class="s2">,</span>
                            <span class="s1">[Arg(a=</span><span class="s5">0.0</span><span class="s1">)]</span><span class="s2">,</span>
                            <span class="s1">dps=</span><span class="s5">400</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_ellipkinc(self):</span>
        <span class="s2">def </span><span class="s1">ellipkinc(phi</span><span class="s2">, </span><span class="s1">m):</span>
            <span class="s2">return </span><span class="s1">mpmath.ellippi(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">phi</span><span class="s2">, </span><span class="s1">m)</span>
        <span class="s1">assert_mpmath_equal(sc.ellipkinc</span><span class="s2">,</span>
                            <span class="s1">ellipkinc</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e3</span><span class="s2">, </span><span class="s5">1e3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg(b=</span><span class="s5">1.0</span><span class="s1">)]</span><span class="s2">,</span>
                            <span class="s1">ignore_inf_sign=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_ellipkinc_largephi(self):</span>
        <span class="s2">def </span><span class="s1">ellipkinc(phi</span><span class="s2">, </span><span class="s1">m):</span>
            <span class="s2">return </span><span class="s1">mpmath.ellippi(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">phi</span><span class="s2">, </span><span class="s1">m)</span>
        <span class="s1">assert_mpmath_equal(sc.ellipkinc</span><span class="s2">,</span>
                            <span class="s1">ellipkinc</span><span class="s2">,</span>
                            <span class="s1">[Arg()</span><span class="s2">, </span><span class="s1">Arg(b=</span><span class="s5">1.0</span><span class="s1">)]</span><span class="s2">,</span>
                            <span class="s1">ignore_inf_sign=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_ellipfun_sn(self):</span>
        <span class="s2">def </span><span class="s1">sn(u</span><span class="s2">, </span><span class="s1">m):</span>
            <span class="s4"># mpmath doesn't get the zero at u = 0--fix that</span>
            <span class="s2">if </span><span class="s1">u == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s5">0</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">mpmath.ellipfun(</span><span class="s3">&quot;sn&quot;</span><span class="s2">, </span><span class="s1">u=u</span><span class="s2">, </span><span class="s1">m=m)</span>

        <span class="s4"># Oscillating function --- limit range of first argument; the</span>
        <span class="s4"># loss of precision there is an expected numerical feature</span>
        <span class="s4"># rather than an actual bug</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">u</span><span class="s2">, </span><span class="s1">m: sc.ellipj(u</span><span class="s2">, </span><span class="s1">m)[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">sn</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e6</span><span class="s2">, </span><span class="s5">1e6</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg(a=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">b=</span><span class="s5">1</span><span class="s1">)]</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s5">1e-8</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_ellipfun_cn(self):</span>
        <span class="s4"># see comment in ellipfun_sn</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">u</span><span class="s2">, </span><span class="s1">m: sc.ellipj(u</span><span class="s2">, </span><span class="s1">m)[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s2">lambda </span><span class="s1">u</span><span class="s2">, </span><span class="s1">m: mpmath.ellipfun(</span><span class="s3">&quot;cn&quot;</span><span class="s2">, </span><span class="s1">u=u</span><span class="s2">, </span><span class="s1">m=m)</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e6</span><span class="s2">, </span><span class="s5">1e6</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg(a=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">b=</span><span class="s5">1</span><span class="s1">)]</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s5">1e-8</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_ellipfun_dn(self):</span>
        <span class="s4"># see comment in ellipfun_sn</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">u</span><span class="s2">, </span><span class="s1">m: sc.ellipj(u</span><span class="s2">, </span><span class="s1">m)[</span><span class="s5">2</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s2">lambda </span><span class="s1">u</span><span class="s2">, </span><span class="s1">m: mpmath.ellipfun(</span><span class="s3">&quot;dn&quot;</span><span class="s2">, </span><span class="s1">u=u</span><span class="s2">, </span><span class="s1">m=m)</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e6</span><span class="s2">, </span><span class="s5">1e6</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg(a=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">b=</span><span class="s5">1</span><span class="s1">)]</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s5">1e-8</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_erf(self):</span>
        <span class="s1">assert_mpmath_equal(sc.erf</span><span class="s2">,</span>
                            <span class="s2">lambda </span><span class="s1">z: mpmath.erf(z)</span><span class="s2">,</span>
                            <span class="s1">[Arg()])</span>

    <span class="s2">def </span><span class="s1">test_erf_complex(self):</span>
        <span class="s1">assert_mpmath_equal(sc.erf</span><span class="s2">,</span>
                            <span class="s2">lambda </span><span class="s1">z: mpmath.erf(z)</span><span class="s2">,</span>
                            <span class="s1">[ComplexArg()]</span><span class="s2">, </span><span class="s1">n=</span><span class="s5">200</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_erfc(self):</span>
        <span class="s1">assert_mpmath_equal(sc.erfc</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(</span><span class="s2">lambda </span><span class="s1">z: mpmath.erfc(z))</span><span class="s2">,</span>
                            <span class="s1">[Arg()]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-13</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_erfc_complex(self):</span>
        <span class="s1">assert_mpmath_equal(sc.erfc</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(</span><span class="s2">lambda </span><span class="s1">z: mpmath.erfc(z))</span><span class="s2">,</span>
                            <span class="s1">[ComplexArg()]</span><span class="s2">, </span><span class="s1">n=</span><span class="s5">200</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_erfi(self):</span>
        <span class="s1">assert_mpmath_equal(sc.erfi</span><span class="s2">,</span>
                            <span class="s1">mpmath.erfi</span><span class="s2">,</span>
                            <span class="s1">[Arg()]</span><span class="s2">, </span><span class="s1">n=</span><span class="s5">200</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_erfi_complex(self):</span>
        <span class="s1">assert_mpmath_equal(sc.erfi</span><span class="s2">,</span>
                            <span class="s1">mpmath.erfi</span><span class="s2">,</span>
                            <span class="s1">[ComplexArg()]</span><span class="s2">, </span><span class="s1">n=</span><span class="s5">200</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_ndtr(self):</span>
        <span class="s1">assert_mpmath_equal(sc.ndtr</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(</span><span class="s2">lambda </span><span class="s1">z: mpmath.ncdf(z))</span><span class="s2">,</span>
                            <span class="s1">[Arg()]</span><span class="s2">, </span><span class="s1">n=</span><span class="s5">200</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_ndtr_complex(self):</span>
        <span class="s1">assert_mpmath_equal(sc.ndtr</span><span class="s2">,</span>
                            <span class="s2">lambda </span><span class="s1">z: mpmath.erfc(-z/np.sqrt(</span><span class="s5">2.</span><span class="s1">))/</span><span class="s5">2.</span><span class="s2">,</span>
                            <span class="s1">[ComplexArg(a=complex(-</span><span class="s5">10000</span><span class="s2">, </span><span class="s1">-</span><span class="s5">10000</span><span class="s1">)</span><span class="s2">, </span><span class="s1">b=complex(</span><span class="s5">10000</span><span class="s2">, </span><span class="s5">10000</span><span class="s1">))]</span><span class="s2">, </span><span class="s1">n=</span><span class="s5">400</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_log_ndtr(self):</span>
        <span class="s1">assert_mpmath_equal(sc.log_ndtr</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(</span><span class="s2">lambda </span><span class="s1">z: mpmath.log(mpmath.ncdf(z)))</span><span class="s2">,</span>
                            <span class="s1">[Arg()]</span><span class="s2">, </span><span class="s1">n=</span><span class="s5">600</span><span class="s2">, </span><span class="s1">dps=</span><span class="s5">300</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-13</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_log_ndtr_complex(self):</span>
        <span class="s1">assert_mpmath_equal(sc.log_ndtr</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(</span><span class="s2">lambda </span><span class="s1">z: mpmath.log(mpmath.erfc(-z/np.sqrt(</span><span class="s5">2.</span><span class="s1">))/</span><span class="s5">2.</span><span class="s1">))</span><span class="s2">,</span>
                            <span class="s1">[ComplexArg(a=complex(-</span><span class="s5">10000</span><span class="s2">, </span><span class="s1">-</span><span class="s5">100</span><span class="s1">)</span><span class="s2">,</span>
                                        <span class="s1">b=complex(</span><span class="s5">10000</span><span class="s2">, </span><span class="s5">100</span><span class="s1">))]</span><span class="s2">, </span><span class="s1">n=</span><span class="s5">200</span><span class="s2">, </span><span class="s1">dps=</span><span class="s5">300</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_eulernum(self):</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">n: sc.euler(n)[-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">mpmath.eulernum</span><span class="s2">,</span>
                            <span class="s1">[IntArg(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">10000</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">n=</span><span class="s5">10000</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_expint(self):</span>
        <span class="s1">assert_mpmath_equal(sc.expn</span><span class="s2">,</span>
                            <span class="s1">mpmath.expint</span><span class="s2">,</span>
                            <span class="s1">[IntArg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">200</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">np.inf)]</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s5">1e-13</span><span class="s2">, </span><span class="s1">dps=</span><span class="s5">160</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_fresnels(self):</span>
        <span class="s2">def </span><span class="s1">fresnels(x):</span>
            <span class="s2">return </span><span class="s1">sc.fresnel(x)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">assert_mpmath_equal(fresnels</span><span class="s2">,</span>
                            <span class="s1">mpmath.fresnels</span><span class="s2">,</span>
                            <span class="s1">[Arg()])</span>

    <span class="s2">def </span><span class="s1">test_fresnelc(self):</span>
        <span class="s2">def </span><span class="s1">fresnelc(x):</span>
            <span class="s2">return </span><span class="s1">sc.fresnel(x)[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">assert_mpmath_equal(fresnelc</span><span class="s2">,</span>
                            <span class="s1">mpmath.fresnelc</span><span class="s2">,</span>
                            <span class="s1">[Arg()])</span>

    <span class="s2">def </span><span class="s1">test_gamma(self):</span>
        <span class="s1">assert_mpmath_equal(sc.gamma</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(mpmath.gamma)</span><span class="s2">,</span>
                            <span class="s1">[Arg()])</span>

    <span class="s2">def </span><span class="s1">test_gamma_complex(self):</span>
        <span class="s1">assert_mpmath_equal(sc.gamma</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(mpmath.gamma)</span><span class="s2">,</span>
                            <span class="s1">[ComplexArg()]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">5e-13</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_gammainc(self):</span>
        <span class="s4"># Larger arguments are tested in test_data.py:test_local</span>
        <span class="s1">assert_mpmath_equal(sc.gammainc</span><span class="s2">,</span>
                            <span class="s2">lambda </span><span class="s1">z</span><span class="s2">, </span><span class="s1">b: mpmath.gammainc(z</span><span class="s2">, </span><span class="s1">b=b</span><span class="s2">, </span><span class="s1">regularized=</span><span class="s2">True</span><span class="s1">)</span><span class="s2">,</span>
                            <span class="s1">[Arg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1e4</span><span class="s2">, </span><span class="s1">inclusive_a=</span><span class="s2">False</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1e4</span><span class="s1">)]</span><span class="s2">,</span>
                            <span class="s1">nan_ok=</span><span class="s2">False, </span><span class="s1">rtol=</span><span class="s5">1e-11</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_gammaincc(self):</span>
        <span class="s4"># Larger arguments are tested in test_data.py:test_local</span>
        <span class="s1">assert_mpmath_equal(sc.gammaincc</span><span class="s2">,</span>
                            <span class="s2">lambda </span><span class="s1">z</span><span class="s2">, </span><span class="s1">a: mpmath.gammainc(z</span><span class="s2">, </span><span class="s1">a=a</span><span class="s2">, </span><span class="s1">regularized=</span><span class="s2">True</span><span class="s1">)</span><span class="s2">,</span>
                            <span class="s1">[Arg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1e4</span><span class="s2">, </span><span class="s1">inclusive_a=</span><span class="s2">False</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1e4</span><span class="s1">)]</span><span class="s2">,</span>
                            <span class="s1">nan_ok=</span><span class="s2">False, </span><span class="s1">rtol=</span><span class="s5">1e-11</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_gammaln(self):</span>
        <span class="s4"># The real part of loggamma is log(|gamma(z)|).</span>
        <span class="s2">def </span><span class="s1">f(z):</span>
            <span class="s2">return </span><span class="s1">mpmath.loggamma(z).real</span>

        <span class="s1">assert_mpmath_equal(sc.gammaln</span><span class="s2">, </span><span class="s1">exception_to_nan(f)</span><span class="s2">, </span><span class="s1">[Arg()])</span>

    <span class="s1">@pytest.mark.xfail(run=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_gegenbauer(self):</span>
        <span class="s1">assert_mpmath_equal(sc.eval_gegenbauer</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(mpmath.gegenbauer)</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e3</span><span class="s2">, </span><span class="s5">1e3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg()</span><span class="s2">, </span><span class="s1">Arg()])</span>

    <span class="s2">def </span><span class="s1">test_gegenbauer_int(self):</span>
        <span class="s4"># Redefine functions to deal with numerical + mpmath issues</span>
        <span class="s2">def </span><span class="s1">gegenbauer(n</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">x):</span>
            <span class="s4"># Avoid overflow at large `a` (mpmath would need an even larger</span>
            <span class="s4"># dps to handle this correctly, so just skip this region)</span>
            <span class="s2">if </span><span class="s1">abs(a) &gt; </span><span class="s5">1e100</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">np.nan</span>

            <span class="s4"># Deal with n=0, n=1 correctly; mpmath 0.17 doesn't do these</span>
            <span class="s4"># always correctly</span>
            <span class="s2">if </span><span class="s1">n == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">r = </span><span class="s5">1.0</span>
            <span class="s2">elif </span><span class="s1">n == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">r = </span><span class="s5">2</span><span class="s1">*a*x</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">r = mpmath.gegenbauer(n</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">x)</span>

            <span class="s4"># Mpmath 0.17 gives wrong results (spurious zero) in some cases, so</span>
            <span class="s4"># compute the value by perturbing the result</span>
            <span class="s2">if </span><span class="s1">float(r) == </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">a &lt; -</span><span class="s5">1 </span><span class="s2">and </span><span class="s1">float(a) == int(float(a)):</span>
                <span class="s1">r = mpmath.gegenbauer(n</span><span class="s2">, </span><span class="s1">a + mpmath.mpf(</span><span class="s3">'1e-50'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">x)</span>
                <span class="s2">if </span><span class="s1">abs(r) &lt; mpmath.mpf(</span><span class="s3">'1e-50'</span><span class="s1">):</span>
                    <span class="s1">r = mpmath.mpf(</span><span class="s3">'0.0'</span><span class="s1">)</span>

            <span class="s4"># Differing overflow thresholds in scipy vs. mpmath</span>
            <span class="s2">if </span><span class="s1">abs(r) &gt; </span><span class="s5">1e270</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">np.inf</span>
            <span class="s2">return </span><span class="s1">r</span>

        <span class="s2">def </span><span class="s1">sc_gegenbauer(n</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">x):</span>
            <span class="s1">r = sc.eval_gegenbauer(int(n)</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">x)</span>
            <span class="s4"># Differing overflow thresholds in scipy vs. mpmath</span>
            <span class="s2">if </span><span class="s1">abs(r) &gt; </span><span class="s5">1e270</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">np.inf</span>
            <span class="s2">return </span><span class="s1">r</span>
        <span class="s1">assert_mpmath_equal(sc_gegenbauer</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(gegenbauer)</span><span class="s2">,</span>
                            <span class="s1">[IntArg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg(-</span><span class="s5">1e9</span><span class="s2">, </span><span class="s5">1e9</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg()]</span><span class="s2">,</span>
                            <span class="s1">n=</span><span class="s5">40000</span><span class="s2">, </span><span class="s1">dps=</span><span class="s5">100</span><span class="s2">,</span>
                            <span class="s1">ignore_inf_sign=</span><span class="s2">True, </span><span class="s1">rtol=</span><span class="s5">1e-6</span><span class="s1">)</span>

        <span class="s4"># Check the small-x expansion</span>
        <span class="s1">assert_mpmath_equal(sc_gegenbauer</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(gegenbauer)</span><span class="s2">,</span>
                            <span class="s1">[IntArg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg()</span><span class="s2">, </span><span class="s1">FixedArg(np.logspace(-</span><span class="s5">30</span><span class="s2">, </span><span class="s1">-</span><span class="s5">4</span><span class="s2">, </span><span class="s5">30</span><span class="s1">))]</span><span class="s2">,</span>
                            <span class="s1">dps=</span><span class="s5">100</span><span class="s2">,</span>
                            <span class="s1">ignore_inf_sign=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.xfail(run=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_gegenbauer_complex(self):</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">x: sc.eval_gegenbauer(int(n)</span><span class="s2">, </span><span class="s1">a.real</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(mpmath.gegenbauer)</span><span class="s2">,</span>
                            <span class="s1">[IntArg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg()</span><span class="s2">, </span><span class="s1">ComplexArg()])</span>

    <span class="s1">@nonfunctional_tooslow</span>
    <span class="s2">def </span><span class="s1">test_gegenbauer_complex_general(self):</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">x: sc.eval_gegenbauer(n.real</span><span class="s2">, </span><span class="s1">a.real</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(mpmath.gegenbauer)</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e3</span><span class="s2">, </span><span class="s5">1e3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg()</span><span class="s2">, </span><span class="s1">ComplexArg()])</span>

    <span class="s2">def </span><span class="s1">test_hankel1(self):</span>
        <span class="s1">assert_mpmath_equal(sc.hankel1</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(</span><span class="s2">lambda </span><span class="s1">v</span><span class="s2">, </span><span class="s1">x: mpmath.hankel1(v</span><span class="s2">, </span><span class="s1">x</span><span class="s2">,</span>
                                                                          <span class="s1">**HYPERKW))</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e20</span><span class="s2">, </span><span class="s5">1e20</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg()])</span>

    <span class="s2">def </span><span class="s1">test_hankel2(self):</span>
        <span class="s1">assert_mpmath_equal(sc.hankel2</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(</span><span class="s2">lambda </span><span class="s1">v</span><span class="s2">, </span><span class="s1">x: mpmath.hankel2(v</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">**HYPERKW))</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e20</span><span class="s2">, </span><span class="s5">1e20</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg()])</span>

    <span class="s1">@pytest.mark.xfail(run=</span><span class="s2">False, </span><span class="s1">reason=</span><span class="s3">&quot;issues at intermediately large orders&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_hermite(self):</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">x: sc.eval_hermite(int(n)</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(mpmath.hermite)</span><span class="s2">,</span>
                            <span class="s1">[IntArg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">10000</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg()])</span>

    <span class="s4"># hurwitz: same as zeta</span>

    <span class="s2">def </span><span class="s1">test_hyp0f1(self):</span>
        <span class="s4"># mpmath reports no convergence unless maxterms is large enough</span>
        <span class="s1">KW = dict(maxprec=</span><span class="s5">400</span><span class="s2">, </span><span class="s1">maxterms=</span><span class="s5">1500</span><span class="s1">)</span>
        <span class="s4"># n=500 (non-xslow default) fails for one bad point</span>
        <span class="s1">assert_mpmath_equal(sc.hyp0f1</span><span class="s2">,</span>
                            <span class="s2">lambda </span><span class="s1">a</span><span class="s2">, </span><span class="s1">x: mpmath.hyp0f1(a</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">**KW)</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e7</span><span class="s2">, </span><span class="s5">1e7</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1e5</span><span class="s1">)]</span><span class="s2">,</span>
                            <span class="s1">n=</span><span class="s5">5000</span><span class="s1">)</span>
        <span class="s4"># NB: The range of the second parameter (&quot;z&quot;) is limited from below</span>
        <span class="s4"># because of an overflow in the intermediate calculations. The way</span>
        <span class="s4"># for fix it is to implement an asymptotic expansion for Bessel J</span>
        <span class="s4"># (similar to what is implemented for Bessel I here).</span>

    <span class="s2">def </span><span class="s1">test_hyp0f1_complex(self):</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">a</span><span class="s2">, </span><span class="s1">z: sc.hyp0f1(a.real</span><span class="s2">, </span><span class="s1">z)</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(</span><span class="s2">lambda </span><span class="s1">a</span><span class="s2">, </span><span class="s1">x: mpmath.hyp0f1(a</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">**HYPERKW))</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">10</span><span class="s2">, </span><span class="s5">10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">ComplexArg(complex(-</span><span class="s5">120</span><span class="s2">, </span><span class="s1">-</span><span class="s5">120</span><span class="s1">)</span><span class="s2">, </span><span class="s1">complex(</span><span class="s5">120</span><span class="s2">, </span><span class="s5">120</span><span class="s1">))])</span>
        <span class="s4"># NB: The range of the first parameter (&quot;v&quot;) are limited by an overflow</span>
        <span class="s4"># in the intermediate calculations. Can be fixed by implementing an</span>
        <span class="s4"># asymptotic expansion for Bessel functions for large order.</span>

    <span class="s2">def </span><span class="s1">test_hyp1f1(self):</span>
        <span class="s2">def </span><span class="s1">mpmath_hyp1f1(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">mpmath.hyp1f1(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x)</span>
            <span class="s2">except </span><span class="s1">ZeroDivisionError:</span>
                <span class="s2">return </span><span class="s1">np.inf</span>

        <span class="s1">assert_mpmath_equal(</span>
            <span class="s1">sc.hyp1f1</span><span class="s2">,</span>
            <span class="s1">mpmath_hyp1f1</span><span class="s2">,</span>
            <span class="s1">[Arg(-</span><span class="s5">50</span><span class="s2">, </span><span class="s5">50</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">50</span><span class="s2">, </span><span class="s1">inclusive_a=</span><span class="s2">False</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg(-</span><span class="s5">50</span><span class="s2">, </span><span class="s5">50</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">n=</span><span class="s5">500</span><span class="s2">,</span>
            <span class="s1">nan_ok=</span><span class="s2">False</span>
        <span class="s1">)</span>

    <span class="s1">@pytest.mark.xfail(run=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_hyp1f1_complex(self):</span>
        <span class="s1">assert_mpmath_equal(inf_to_nan(</span><span class="s2">lambda </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x: sc.hyp1f1(a.real</span><span class="s2">, </span><span class="s1">b.real</span><span class="s2">, </span><span class="s1">x))</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(</span><span class="s2">lambda </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x: mpmath.hyp1f1(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">**HYPERKW))</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e3</span><span class="s2">, </span><span class="s5">1e3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg(-</span><span class="s5">1e3</span><span class="s2">, </span><span class="s5">1e3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">ComplexArg()]</span><span class="s2">,</span>
                            <span class="s1">n=</span><span class="s5">2000</span><span class="s1">)</span>

    <span class="s1">@nonfunctional_tooslow</span>
    <span class="s2">def </span><span class="s1">test_hyp2f1_complex(self):</span>
        <span class="s4"># SciPy's hyp2f1 seems to have performance and accuracy problems</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">x: sc.hyp2f1(a.real</span><span class="s2">, </span><span class="s1">b.real</span><span class="s2">, </span><span class="s1">c.real</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(</span><span class="s2">lambda </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">x: mpmath.hyp2f1(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">**HYPERKW))</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e2</span><span class="s2">, </span><span class="s5">1e2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg(-</span><span class="s5">1e2</span><span class="s2">, </span><span class="s5">1e2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg(-</span><span class="s5">1e2</span><span class="s2">, </span><span class="s5">1e2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">ComplexArg()]</span><span class="s2">,</span>
                            <span class="s1">n=</span><span class="s5">10</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.xfail(run=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_hyperu(self):</span>
        <span class="s1">assert_mpmath_equal(sc.hyperu</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(</span><span class="s2">lambda </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x: mpmath.hyperu(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">**HYPERKW))</span><span class="s2">,</span>
                            <span class="s1">[Arg()</span><span class="s2">, </span><span class="s1">Arg()</span><span class="s2">, </span><span class="s1">Arg()])</span>

    <span class="s1">@pytest.mark.xfail_on_32bit(</span><span class="s3">&quot;mpmath issue gh-342: unsupported operand mpz, long for pow&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_igam_fac(self):</span>
        <span class="s2">def </span><span class="s1">mp_igam_fac(a</span><span class="s2">, </span><span class="s1">x):</span>
            <span class="s2">return </span><span class="s1">mpmath.power(x</span><span class="s2">, </span><span class="s1">a)*mpmath.exp(-x)/mpmath.gamma(a)</span>

        <span class="s1">assert_mpmath_equal(_igam_fac</span><span class="s2">,</span>
                            <span class="s1">mp_igam_fac</span><span class="s2">,</span>
                            <span class="s1">[Arg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1e14</span><span class="s2">, </span><span class="s1">inclusive_a=</span><span class="s2">False</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1e14</span><span class="s1">)]</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s5">1e-10</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_j0(self):</span>
        <span class="s4"># The Bessel function at large arguments is j0(x) ~ cos(x + phi)/sqrt(x)</span>
        <span class="s4"># and at large arguments the phase of the cosine loses precision.</span>
        <span class="s4">#</span>
        <span class="s4"># This is numerically expected behavior, so we compare only up to</span>
        <span class="s4"># 1e8 = 1e15 * 1e-7</span>
        <span class="s1">assert_mpmath_equal(sc.j0</span><span class="s2">,</span>
                            <span class="s1">mpmath.j0</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e3</span><span class="s2">, </span><span class="s5">1e3</span><span class="s1">)])</span>
        <span class="s1">assert_mpmath_equal(sc.j0</span><span class="s2">,</span>
                            <span class="s1">mpmath.j0</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e8</span><span class="s2">, </span><span class="s5">1e8</span><span class="s1">)]</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s5">1e-5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_j1(self):</span>
        <span class="s4"># See comment in test_j0</span>
        <span class="s1">assert_mpmath_equal(sc.j1</span><span class="s2">,</span>
                            <span class="s1">mpmath.j1</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e3</span><span class="s2">, </span><span class="s5">1e3</span><span class="s1">)])</span>
        <span class="s1">assert_mpmath_equal(sc.j1</span><span class="s2">,</span>
                            <span class="s1">mpmath.j1</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e8</span><span class="s2">, </span><span class="s5">1e8</span><span class="s1">)]</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s5">1e-5</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.xfail(run=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_jacobi(self):</span>
        <span class="s1">assert_mpmath_equal(sc.eval_jacobi</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(</span><span class="s2">lambda </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">x: mpmath.jacobi(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">**HYPERKW))</span><span class="s2">,</span>
                            <span class="s1">[Arg()</span><span class="s2">, </span><span class="s1">Arg()</span><span class="s2">, </span><span class="s1">Arg()</span><span class="s2">, </span><span class="s1">Arg()])</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">x: sc.eval_jacobi(int(n)</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(</span><span class="s2">lambda </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">x: mpmath.jacobi(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">**HYPERKW))</span><span class="s2">,</span>
                            <span class="s1">[IntArg()</span><span class="s2">, </span><span class="s1">Arg()</span><span class="s2">, </span><span class="s1">Arg()</span><span class="s2">, </span><span class="s1">Arg()])</span>

    <span class="s2">def </span><span class="s1">test_jacobi_int(self):</span>
        <span class="s4"># Redefine functions to deal with numerical + mpmath issues</span>
        <span class="s2">def </span><span class="s1">jacobi(n</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x):</span>
            <span class="s4"># Mpmath does not handle n=0 case always correctly</span>
            <span class="s2">if </span><span class="s1">n == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s5">1.0</span>
            <span class="s2">return </span><span class="s1">mpmath.jacobi(n</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x: sc.eval_jacobi(int(n)</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
                            <span class="s2">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x: exception_to_nan(jacobi)(n</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">**HYPERKW)</span><span class="s2">,</span>
                            <span class="s1">[IntArg()</span><span class="s2">, </span><span class="s1">Arg()</span><span class="s2">, </span><span class="s1">Arg()</span><span class="s2">, </span><span class="s1">Arg()]</span><span class="s2">,</span>
                            <span class="s1">n=</span><span class="s5">20000</span><span class="s2">, </span><span class="s1">dps=</span><span class="s5">50</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_kei(self):</span>
        <span class="s2">def </span><span class="s1">kei(x):</span>
            <span class="s2">if </span><span class="s1">x == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s4"># work around mpmath issue at x=0</span>
                <span class="s2">return </span><span class="s1">-pi/</span><span class="s5">4</span>
            <span class="s2">return </span><span class="s1">exception_to_nan(mpmath.kei)(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">**HYPERKW)</span>
        <span class="s1">assert_mpmath_equal(sc.kei</span><span class="s2">,</span>
                            <span class="s1">kei</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e30</span><span class="s2">, </span><span class="s5">1e30</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">n=</span><span class="s5">1000</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_ker(self):</span>
        <span class="s1">assert_mpmath_equal(sc.ker</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(</span><span class="s2">lambda </span><span class="s1">x: mpmath.ker(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">**HYPERKW))</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e30</span><span class="s2">, </span><span class="s5">1e30</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">n=</span><span class="s5">1000</span><span class="s1">)</span>

    <span class="s1">@nonfunctional_tooslow</span>
    <span class="s2">def </span><span class="s1">test_laguerre(self):</span>
        <span class="s1">assert_mpmath_equal(trace_args(sc.eval_laguerre)</span><span class="s2">,</span>
                            <span class="s2">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">x: exception_to_nan(mpmath.laguerre)(n</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">**HYPERKW)</span><span class="s2">,</span>
                            <span class="s1">[Arg()</span><span class="s2">, </span><span class="s1">Arg()])</span>

    <span class="s2">def </span><span class="s1">test_laguerre_int(self):</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">x: sc.eval_laguerre(int(n)</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
                            <span class="s2">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">x: exception_to_nan(mpmath.laguerre)(n</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">**HYPERKW)</span><span class="s2">,</span>
                            <span class="s1">[IntArg()</span><span class="s2">, </span><span class="s1">Arg()]</span><span class="s2">, </span><span class="s1">n=</span><span class="s5">20000</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.xfail_on_32bit(</span><span class="s3">&quot;see gh-3551 for bad points&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_lambertw_real(self):</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">x</span><span class="s2">, </span><span class="s1">k: sc.lambertw(x</span><span class="s2">, </span><span class="s1">int(k.real))</span><span class="s2">,</span>
                            <span class="s2">lambda </span><span class="s1">x</span><span class="s2">, </span><span class="s1">k: mpmath.lambertw(x</span><span class="s2">, </span><span class="s1">int(k.real))</span><span class="s2">,</span>
                            <span class="s1">[ComplexArg(-np.inf</span><span class="s2">, </span><span class="s1">np.inf)</span><span class="s2">, </span><span class="s1">IntArg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">10</span><span class="s1">)]</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s5">1e-13</span><span class="s2">, </span><span class="s1">nan_ok=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_lanczos_sum_expg_scaled(self):</span>
        <span class="s1">maxgamma = </span><span class="s5">171.624376956302725</span>
        <span class="s1">e = np.exp(</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">g = </span><span class="s5">6.024680040776729583740234375</span>

        <span class="s2">def </span><span class="s1">gamma(x):</span>
            <span class="s2">with </span><span class="s1">np.errstate(over=</span><span class="s3">'ignore'</span><span class="s1">):</span>
                <span class="s1">fac = ((x + g - </span><span class="s5">0.5</span><span class="s1">)/e)**(x - </span><span class="s5">0.5</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">fac != np.inf:</span>
                    <span class="s1">res = fac*_lanczos_sum_expg_scaled(x)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">fac = ((x + g - </span><span class="s5">0.5</span><span class="s1">)/e)**(</span><span class="s5">0.5</span><span class="s1">*(x - </span><span class="s5">0.5</span><span class="s1">))</span>
                    <span class="s1">res = fac*_lanczos_sum_expg_scaled(x)</span>
                    <span class="s1">res *= fac</span>
            <span class="s2">return </span><span class="s1">res</span>

        <span class="s1">assert_mpmath_equal(gamma</span><span class="s2">,</span>
                            <span class="s1">mpmath.gamma</span><span class="s2">,</span>
                            <span class="s1">[Arg(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">maxgamma</span><span class="s2">, </span><span class="s1">inclusive_a=</span><span class="s2">False</span><span class="s1">)]</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s5">1e-13</span><span class="s1">)</span>

    <span class="s1">@nonfunctional_tooslow</span>
    <span class="s2">def </span><span class="s1">test_legendre(self):</span>
        <span class="s1">assert_mpmath_equal(sc.eval_legendre</span><span class="s2">,</span>
                            <span class="s1">mpmath.legendre</span><span class="s2">,</span>
                            <span class="s1">[Arg()</span><span class="s2">, </span><span class="s1">Arg()])</span>

    <span class="s2">def </span><span class="s1">test_legendre_int(self):</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">x: sc.eval_legendre(int(n)</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
                            <span class="s2">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">x: exception_to_nan(mpmath.legendre)(n</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">**HYPERKW)</span><span class="s2">,</span>
                            <span class="s1">[IntArg()</span><span class="s2">, </span><span class="s1">Arg()]</span><span class="s2">,</span>
                            <span class="s1">n=</span><span class="s5">20000</span><span class="s1">)</span>

        <span class="s4"># Check the small-x expansion</span>
        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">x: sc.eval_legendre(int(n)</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
                            <span class="s2">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">x: exception_to_nan(mpmath.legendre)(n</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">**HYPERKW)</span><span class="s2">,</span>
                            <span class="s1">[IntArg()</span><span class="s2">, </span><span class="s1">FixedArg(np.logspace(-</span><span class="s5">30</span><span class="s2">, </span><span class="s1">-</span><span class="s5">4</span><span class="s2">, </span><span class="s5">20</span><span class="s1">))])</span>

    <span class="s2">def </span><span class="s1">test_legenp(self):</span>
        <span class="s2">def </span><span class="s1">lpnm(n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">z):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">v = sc.lpmn(m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">z)[</span><span class="s5">0</span><span class="s1">][-</span><span class="s5">1</span><span class="s2">,</span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s2">except </span><span class="s1">ValueError:</span>
                <span class="s2">return </span><span class="s1">np.nan</span>
            <span class="s2">if </span><span class="s1">abs(v) &gt; </span><span class="s5">1e306</span><span class="s1">:</span>
                <span class="s4"># harmonize overflow to inf</span>
                <span class="s1">v = np.inf * np.sign(v.real)</span>
            <span class="s2">return </span><span class="s1">v</span>

        <span class="s2">def </span><span class="s1">lpnm_2(n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">z):</span>
            <span class="s1">v = sc.lpmv(m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">z)</span>
            <span class="s2">if </span><span class="s1">abs(v) &gt; </span><span class="s5">1e306</span><span class="s1">:</span>
                <span class="s4"># harmonize overflow to inf</span>
                <span class="s1">v = np.inf * np.sign(v.real)</span>
            <span class="s2">return </span><span class="s1">v</span>

        <span class="s2">def </span><span class="s1">legenp(n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">z):</span>
            <span class="s2">if </span><span class="s1">(z == </span><span class="s5">1 </span><span class="s2">or </span><span class="s1">z == -</span><span class="s5">1</span><span class="s1">) </span><span class="s2">and </span><span class="s1">int(n) == n:</span>
                <span class="s4"># Special case (mpmath may give inf, we take the limit by</span>
                <span class="s4"># continuity)</span>
                <span class="s2">if </span><span class="s1">m == </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">n &lt; </span><span class="s5">0</span><span class="s1">:</span>
                        <span class="s1">n = -n - </span><span class="s5">1</span>
                    <span class="s2">return </span><span class="s1">mpmath.power(mpmath.sign(z)</span><span class="s2">, </span><span class="s1">n)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s5">0</span>

            <span class="s2">if </span><span class="s1">abs(z) &lt; </span><span class="s5">1e-15</span><span class="s1">:</span>
                <span class="s4"># mpmath has bad performance here</span>
                <span class="s2">return </span><span class="s1">np.nan</span>

            <span class="s1">typ = </span><span class="s5">2 </span><span class="s2">if </span><span class="s1">abs(z) &lt; </span><span class="s5">1 </span><span class="s2">else </span><span class="s5">3</span>
            <span class="s1">v = exception_to_nan(mpmath.legenp)(n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">type=typ)</span>

            <span class="s2">if </span><span class="s1">abs(v) &gt; </span><span class="s5">1e306</span><span class="s1">:</span>
                <span class="s4"># harmonize overflow to inf</span>
                <span class="s1">v = mpmath.inf * mpmath.sign(v.real)</span>

            <span class="s2">return </span><span class="s1">v</span>

        <span class="s1">assert_mpmath_equal(lpnm</span><span class="s2">,</span>
                            <span class="s1">legenp</span><span class="s2">,</span>
                            <span class="s1">[IntArg(-</span><span class="s5">100</span><span class="s2">, </span><span class="s5">100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">IntArg(-</span><span class="s5">100</span><span class="s2">, </span><span class="s5">100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg()])</span>

        <span class="s1">assert_mpmath_equal(lpnm_2</span><span class="s2">,</span>
                            <span class="s1">legenp</span><span class="s2">,</span>
                            <span class="s1">[IntArg(-</span><span class="s5">100</span><span class="s2">, </span><span class="s5">100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg(-</span><span class="s5">100</span><span class="s2">, </span><span class="s5">100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg(-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)]</span><span class="s2">,</span>
                            <span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_legenp_complex_2(self):</span>
        <span class="s2">def </span><span class="s1">clpnm(n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">z):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">sc.clpmn(m.real</span><span class="s2">, </span><span class="s1">n.real</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">type=</span><span class="s5">2</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">][-</span><span class="s5">1</span><span class="s2">,</span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s2">except </span><span class="s1">ValueError:</span>
                <span class="s2">return </span><span class="s1">np.nan</span>

        <span class="s2">def </span><span class="s1">legenp(n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">z):</span>
            <span class="s2">if </span><span class="s1">abs(z) &lt; </span><span class="s5">1e-15</span><span class="s1">:</span>
                <span class="s4"># mpmath has bad performance here</span>
                <span class="s2">return </span><span class="s1">np.nan</span>
            <span class="s2">return </span><span class="s1">exception_to_nan(mpmath.legenp)(int(n.real)</span><span class="s2">, </span><span class="s1">int(m.real)</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">type=</span><span class="s5">2</span><span class="s1">)</span>

        <span class="s4"># mpmath is quite slow here</span>
        <span class="s1">x = np.array([-</span><span class="s5">2</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.99</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1e-5</span><span class="s2">, </span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.99</span><span class="s2">, </span><span class="s5">20</span><span class="s2">, </span><span class="s5">2e3</span><span class="s1">])</span>
        <span class="s1">y = np.array([-</span><span class="s5">1e3</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">1.3</span><span class="s1">])</span>
        <span class="s1">z = (x[:</span><span class="s2">,None</span><span class="s1">] + </span><span class="s5">1j</span><span class="s1">*y[</span><span class="s2">None,</span><span class="s1">:]).ravel()</span>

        <span class="s1">assert_mpmath_equal(clpnm</span><span class="s2">,</span>
                            <span class="s1">legenp</span><span class="s2">,</span>
                            <span class="s1">[FixedArg([-</span><span class="s5">2</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">10</span><span class="s1">])</span><span class="s2">, </span><span class="s1">FixedArg([-</span><span class="s5">2</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">10</span><span class="s1">])</span><span class="s2">, </span><span class="s1">FixedArg(z)]</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s5">1e-6</span><span class="s2">,</span>
                            <span class="s1">n=</span><span class="s5">500</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_legenp_complex_3(self):</span>
        <span class="s2">def </span><span class="s1">clpnm(n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">z):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">sc.clpmn(m.real</span><span class="s2">, </span><span class="s1">n.real</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">type=</span><span class="s5">3</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">][-</span><span class="s5">1</span><span class="s2">,</span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s2">except </span><span class="s1">ValueError:</span>
                <span class="s2">return </span><span class="s1">np.nan</span>

        <span class="s2">def </span><span class="s1">legenp(n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">z):</span>
            <span class="s2">if </span><span class="s1">abs(z) &lt; </span><span class="s5">1e-15</span><span class="s1">:</span>
                <span class="s4"># mpmath has bad performance here</span>
                <span class="s2">return </span><span class="s1">np.nan</span>
            <span class="s2">return </span><span class="s1">exception_to_nan(mpmath.legenp)(int(n.real)</span><span class="s2">, </span><span class="s1">int(m.real)</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">type=</span><span class="s5">3</span><span class="s1">)</span>

        <span class="s4"># mpmath is quite slow here</span>
        <span class="s1">x = np.array([-</span><span class="s5">2</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.99</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1e-5</span><span class="s2">, </span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.99</span><span class="s2">, </span><span class="s5">20</span><span class="s2">, </span><span class="s5">2e3</span><span class="s1">])</span>
        <span class="s1">y = np.array([-</span><span class="s5">1e3</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">1.3</span><span class="s1">])</span>
        <span class="s1">z = (x[:</span><span class="s2">,None</span><span class="s1">] + </span><span class="s5">1j</span><span class="s1">*y[</span><span class="s2">None,</span><span class="s1">:]).ravel()</span>

        <span class="s1">assert_mpmath_equal(clpnm</span><span class="s2">,</span>
                            <span class="s1">legenp</span><span class="s2">,</span>
                            <span class="s1">[FixedArg([-</span><span class="s5">2</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">10</span><span class="s1">])</span><span class="s2">, </span><span class="s1">FixedArg([-</span><span class="s5">2</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">10</span><span class="s1">])</span><span class="s2">, </span><span class="s1">FixedArg(z)]</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s5">1e-6</span><span class="s2">,</span>
                            <span class="s1">n=</span><span class="s5">500</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.xfail(run=</span><span class="s2">False, </span><span class="s1">reason=</span><span class="s3">&quot;apparently picks wrong function at |z| &gt; 1&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_legenq(self):</span>
        <span class="s2">def </span><span class="s1">lqnm(n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">z):</span>
            <span class="s2">return </span><span class="s1">sc.lqmn(m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">z)[</span><span class="s5">0</span><span class="s1">][-</span><span class="s5">1</span><span class="s2">,</span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span>

        <span class="s2">def </span><span class="s1">legenq(n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">z):</span>
            <span class="s2">if </span><span class="s1">abs(z) &lt; </span><span class="s5">1e-15</span><span class="s1">:</span>
                <span class="s4"># mpmath has bad performance here</span>
                <span class="s2">return </span><span class="s1">np.nan</span>
            <span class="s2">return </span><span class="s1">exception_to_nan(mpmath.legenq)(n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">type=</span><span class="s5">2</span><span class="s1">)</span>

        <span class="s1">assert_mpmath_equal(lqnm</span><span class="s2">,</span>
                            <span class="s1">legenq</span><span class="s2">,</span>
                            <span class="s1">[IntArg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">IntArg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg()])</span>

    <span class="s1">@nonfunctional_tooslow</span>
    <span class="s2">def </span><span class="s1">test_legenq_complex(self):</span>
        <span class="s2">def </span><span class="s1">lqnm(n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">z):</span>
            <span class="s2">return </span><span class="s1">sc.lqmn(int(m.real)</span><span class="s2">, </span><span class="s1">int(n.real)</span><span class="s2">, </span><span class="s1">z)[</span><span class="s5">0</span><span class="s1">][-</span><span class="s5">1</span><span class="s2">,</span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span>

        <span class="s2">def </span><span class="s1">legenq(n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">z):</span>
            <span class="s2">if </span><span class="s1">abs(z) &lt; </span><span class="s5">1e-15</span><span class="s1">:</span>
                <span class="s4"># mpmath has bad performance here</span>
                <span class="s2">return </span><span class="s1">np.nan</span>
            <span class="s2">return </span><span class="s1">exception_to_nan(mpmath.legenq)(int(n.real)</span><span class="s2">, </span><span class="s1">int(m.real)</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">type=</span><span class="s5">2</span><span class="s1">)</span>

        <span class="s1">assert_mpmath_equal(lqnm</span><span class="s2">,</span>
                            <span class="s1">legenq</span><span class="s2">,</span>
                            <span class="s1">[IntArg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">IntArg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">ComplexArg()]</span><span class="s2">,</span>
                            <span class="s1">n=</span><span class="s5">100</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_lgam1p(self):</span>
        <span class="s2">def </span><span class="s1">param_filter(x):</span>
            <span class="s4"># Filter the poles</span>
            <span class="s2">return </span><span class="s1">np.where((np.floor(x) == x) &amp; (x &lt;= </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, False, True</span><span class="s1">)</span>

        <span class="s2">def </span><span class="s1">mp_lgam1p(z):</span>
            <span class="s4"># The real part of loggamma is log(|gamma(z)|)</span>
            <span class="s2">return </span><span class="s1">mpmath.loggamma(</span><span class="s5">1 </span><span class="s1">+ z).real</span>

        <span class="s1">assert_mpmath_equal(_lgam1p</span><span class="s2">,</span>
                            <span class="s1">mp_lgam1p</span><span class="s2">,</span>
                            <span class="s1">[Arg()]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-13</span><span class="s2">, </span><span class="s1">dps=</span><span class="s5">100</span><span class="s2">,</span>
                            <span class="s1">param_filter=param_filter)</span>

    <span class="s2">def </span><span class="s1">test_loggamma(self):</span>
        <span class="s2">def </span><span class="s1">mpmath_loggamma(z):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">res = mpmath.loggamma(z)</span>
            <span class="s2">except </span><span class="s1">ValueError:</span>
                <span class="s1">res = complex(np.nan</span><span class="s2">, </span><span class="s1">np.nan)</span>
            <span class="s2">return </span><span class="s1">res</span>

        <span class="s1">assert_mpmath_equal(sc.loggamma</span><span class="s2">,</span>
                            <span class="s1">mpmath_loggamma</span><span class="s2">,</span>
                            <span class="s1">[ComplexArg()]</span><span class="s2">, </span><span class="s1">nan_ok=</span><span class="s2">False,</span>
                            <span class="s1">distinguish_nan_and_inf=</span><span class="s2">False, </span><span class="s1">rtol=</span><span class="s5">5e-14</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.xfail(run=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_pcfd(self):</span>
        <span class="s2">def </span><span class="s1">pcfd(v</span><span class="s2">, </span><span class="s1">x):</span>
            <span class="s2">return </span><span class="s1">sc.pbdv(v</span><span class="s2">, </span><span class="s1">x)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">assert_mpmath_equal(pcfd</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(</span><span class="s2">lambda </span><span class="s1">v</span><span class="s2">, </span><span class="s1">x: mpmath.pcfd(v</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">**HYPERKW))</span><span class="s2">,</span>
                            <span class="s1">[Arg()</span><span class="s2">, </span><span class="s1">Arg()])</span>

    <span class="s1">@pytest.mark.xfail(run=</span><span class="s2">False, </span><span class="s1">reason=</span><span class="s3">&quot;it's not the same as the mpmath function --- maybe different definition?&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_pcfv(self):</span>
        <span class="s2">def </span><span class="s1">pcfv(v</span><span class="s2">, </span><span class="s1">x):</span>
            <span class="s2">return </span><span class="s1">sc.pbvv(v</span><span class="s2">, </span><span class="s1">x)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">assert_mpmath_equal(pcfv</span><span class="s2">,</span>
                            <span class="s2">lambda </span><span class="s1">v</span><span class="s2">, </span><span class="s1">x: time_limited()(exception_to_nan(mpmath.pcfv))(v</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">**HYPERKW)</span><span class="s2">,</span>
                            <span class="s1">[Arg()</span><span class="s2">, </span><span class="s1">Arg()]</span><span class="s2">, </span><span class="s1">n=</span><span class="s5">1000</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pcfw(self):</span>
        <span class="s2">def </span><span class="s1">pcfw(a</span><span class="s2">, </span><span class="s1">x):</span>
            <span class="s2">return </span><span class="s1">sc.pbwa(a</span><span class="s2">, </span><span class="s1">x)[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s2">def </span><span class="s1">dpcfw(a</span><span class="s2">, </span><span class="s1">x):</span>
            <span class="s2">return </span><span class="s1">sc.pbwa(a</span><span class="s2">, </span><span class="s1">x)[</span><span class="s5">1</span><span class="s1">]</span>

        <span class="s2">def </span><span class="s1">mpmath_dpcfw(a</span><span class="s2">, </span><span class="s1">x):</span>
            <span class="s2">return </span><span class="s1">mpmath.diff(mpmath.pcfw</span><span class="s2">, </span><span class="s1">(a</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">, </span><span class="s1">(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>

        <span class="s4"># The Zhang and Jin implementation only uses Taylor series and</span>
        <span class="s4"># is thus accurate in only a very small range.</span>
        <span class="s1">assert_mpmath_equal(pcfw</span><span class="s2">,</span>
                            <span class="s1">mpmath.pcfw</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">5</span><span class="s2">, </span><span class="s5">5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg(-</span><span class="s5">5</span><span class="s2">, </span><span class="s5">5</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">2e-8</span><span class="s2">, </span><span class="s1">n=</span><span class="s5">100</span><span class="s1">)</span>

        <span class="s1">assert_mpmath_equal(dpcfw</span><span class="s2">,</span>
                            <span class="s1">mpmath_dpcfw</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">5</span><span class="s2">, </span><span class="s5">5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg(-</span><span class="s5">5</span><span class="s2">, </span><span class="s5">5</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">2e-9</span><span class="s2">, </span><span class="s1">n=</span><span class="s5">100</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.xfail(run=</span><span class="s2">False, </span><span class="s1">reason=</span><span class="s3">&quot;issues at large arguments (atol OK, rtol not) and &lt;eps-close to z=0&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_polygamma(self):</span>
        <span class="s1">assert_mpmath_equal(sc.polygamma</span><span class="s2">,</span>
                            <span class="s1">time_limited()(exception_to_nan(mpmath.polygamma))</span><span class="s2">,</span>
                            <span class="s1">[IntArg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1000</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg()])</span>

    <span class="s2">def </span><span class="s1">test_rgamma(self):</span>
        <span class="s1">assert_mpmath_equal(</span>
            <span class="s1">sc.rgamma</span><span class="s2">,</span>
            <span class="s1">mpmath.rgamma</span><span class="s2">,</span>
            <span class="s1">[Arg(-</span><span class="s5">8000</span><span class="s2">, </span><span class="s1">np.inf)]</span><span class="s2">,</span>
            <span class="s1">n=</span><span class="s5">5000</span><span class="s2">,</span>
            <span class="s1">nan_ok=</span><span class="s2">False,</span>
            <span class="s1">ignore_inf_sign=</span><span class="s2">True,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_rgamma_complex(self):</span>
        <span class="s1">assert_mpmath_equal(sc.rgamma</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(mpmath.rgamma)</span><span class="s2">,</span>
                            <span class="s1">[ComplexArg()]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">5e-13</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.xfail(reason=(</span><span class="s3">&quot;see gh-3551 for bad points on 32 bit &quot;</span>
                               <span class="s3">&quot;systems and gh-8095 for another bad &quot;</span>
                               <span class="s3">&quot;point&quot;</span><span class="s1">))</span>
    <span class="s2">def </span><span class="s1">test_rf(self):</span>
        <span class="s2">if </span><span class="s1">_pep440.parse(mpmath.__version__) &gt;= _pep440.Version(</span><span class="s3">&quot;1.0.0&quot;</span><span class="s1">):</span>
            <span class="s4"># no workarounds needed</span>
            <span class="s1">mppoch = mpmath.rf</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">def </span><span class="s1">mppoch(a</span><span class="s2">, </span><span class="s1">m):</span>
                <span class="s4"># deal with cases where the result in double precision</span>
                <span class="s4"># hits exactly a non-positive integer, but the</span>
                <span class="s4"># corresponding extended-precision mpf floats don't</span>
                <span class="s2">if </span><span class="s1">float(a + m) == int(a + m) </span><span class="s2">and </span><span class="s1">float(a + m) &lt;= </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s1">a = mpmath.mpf(a)</span>
                    <span class="s1">m = int(a + m) - a</span>
                <span class="s2">return </span><span class="s1">mpmath.rf(a</span><span class="s2">, </span><span class="s1">m)</span>

        <span class="s1">assert_mpmath_equal(sc.poch</span><span class="s2">,</span>
                            <span class="s1">mppoch</span><span class="s2">,</span>
                            <span class="s1">[Arg()</span><span class="s2">, </span><span class="s1">Arg()]</span><span class="s2">,</span>
                            <span class="s1">dps=</span><span class="s5">400</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_sinpi(self):</span>
        <span class="s1">eps = np.finfo(float).eps</span>
        <span class="s1">assert_mpmath_equal(_sinpi</span><span class="s2">, </span><span class="s1">mpmath.sinpi</span><span class="s2">,</span>
                            <span class="s1">[Arg()]</span><span class="s2">, </span><span class="s1">nan_ok=</span><span class="s2">False, </span><span class="s1">rtol=</span><span class="s5">2</span><span class="s1">*eps)</span>

    <span class="s2">def </span><span class="s1">test_sinpi_complex(self):</span>
        <span class="s1">assert_mpmath_equal(_sinpi</span><span class="s2">, </span><span class="s1">mpmath.sinpi</span><span class="s2">,</span>
                            <span class="s1">[ComplexArg()]</span><span class="s2">, </span><span class="s1">nan_ok=</span><span class="s2">False, </span><span class="s1">rtol=</span><span class="s5">2e-14</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_shi(self):</span>
        <span class="s2">def </span><span class="s1">shi(x):</span>
            <span class="s2">return </span><span class="s1">sc.shichi(x)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">assert_mpmath_equal(shi</span><span class="s2">, </span><span class="s1">mpmath.shi</span><span class="s2">, </span><span class="s1">[Arg()])</span>
        <span class="s4"># check asymptotic series cross-over</span>
        <span class="s1">assert_mpmath_equal(shi</span><span class="s2">, </span><span class="s1">mpmath.shi</span><span class="s2">, </span><span class="s1">[FixedArg([</span><span class="s5">88 </span><span class="s1">- </span><span class="s5">1e-9</span><span class="s2">, </span><span class="s5">88</span><span class="s2">, </span><span class="s5">88 </span><span class="s1">+ </span><span class="s5">1e-9</span><span class="s1">])])</span>

    <span class="s2">def </span><span class="s1">test_shi_complex(self):</span>
        <span class="s2">def </span><span class="s1">shi(z):</span>
            <span class="s2">return </span><span class="s1">sc.shichi(z)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s4"># shi oscillates as Im[z] -&gt; +- inf, so limit range</span>
        <span class="s1">assert_mpmath_equal(shi</span><span class="s2">,</span>
                            <span class="s1">mpmath.shi</span><span class="s2">,</span>
                            <span class="s1">[ComplexArg(complex(-np.inf</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1e8</span><span class="s1">)</span><span class="s2">, </span><span class="s1">complex(np.inf</span><span class="s2">, </span><span class="s5">1e8</span><span class="s1">))]</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s5">1e-12</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_si(self):</span>
        <span class="s2">def </span><span class="s1">si(x):</span>
            <span class="s2">return </span><span class="s1">sc.sici(x)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">assert_mpmath_equal(si</span><span class="s2">, </span><span class="s1">mpmath.si</span><span class="s2">, </span><span class="s1">[Arg()])</span>

    <span class="s2">def </span><span class="s1">test_si_complex(self):</span>
        <span class="s2">def </span><span class="s1">si(z):</span>
            <span class="s2">return </span><span class="s1">sc.sici(z)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s4"># si oscillates as Re[z] -&gt; +- inf, so limit range</span>
        <span class="s1">assert_mpmath_equal(si</span><span class="s2">,</span>
                            <span class="s1">mpmath.si</span><span class="s2">,</span>
                            <span class="s1">[ComplexArg(complex(-</span><span class="s5">1e8</span><span class="s2">, </span><span class="s1">-np.inf)</span><span class="s2">, </span><span class="s1">complex(</span><span class="s5">1e8</span><span class="s2">, </span><span class="s1">np.inf))]</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s5">1e-12</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_spence(self):</span>
        <span class="s4"># mpmath uses a different convention for the dilogarithm</span>
        <span class="s2">def </span><span class="s1">dilog(x):</span>
            <span class="s2">return </span><span class="s1">mpmath.polylog(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">1 </span><span class="s1">- x)</span>
        <span class="s4"># Spence has a branch cut on the negative real axis</span>
        <span class="s1">assert_mpmath_equal(sc.spence</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(dilog)</span><span class="s2">,</span>
                            <span class="s1">[Arg(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">np.inf)]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-14</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_spence_complex(self):</span>
        <span class="s2">def </span><span class="s1">dilog(z):</span>
            <span class="s2">return </span><span class="s1">mpmath.polylog(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">1 </span><span class="s1">- z)</span>
        <span class="s1">assert_mpmath_equal(sc.spence</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(dilog)</span><span class="s2">,</span>
                            <span class="s1">[ComplexArg()]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-14</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_spherharm(self):</span>
        <span class="s2">def </span><span class="s1">spherharm(l</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">theta</span><span class="s2">, </span><span class="s1">phi):</span>
            <span class="s2">if </span><span class="s1">m &gt; l:</span>
                <span class="s2">return </span><span class="s1">np.nan</span>
            <span class="s2">return </span><span class="s1">sc.sph_harm(m</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">phi</span><span class="s2">, </span><span class="s1">theta)</span>
        <span class="s1">assert_mpmath_equal(spherharm</span><span class="s2">,</span>
                            <span class="s1">mpmath.spherharm</span><span class="s2">,</span>
                            <span class="s1">[IntArg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">IntArg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">100</span><span class="s1">)</span><span class="s2">,</span>
                             <span class="s1">Arg(a=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">b=pi)</span><span class="s2">, </span><span class="s1">Arg(a=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">b=</span><span class="s5">2</span><span class="s1">*pi)]</span><span class="s2">,</span>
                            <span class="s1">atol=</span><span class="s5">1e-8</span><span class="s2">, </span><span class="s1">n=</span><span class="s5">6000</span><span class="s2">,</span>
                            <span class="s1">dps=</span><span class="s5">150</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_struveh(self):</span>
        <span class="s1">assert_mpmath_equal(sc.struve</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(mpmath.struveh)</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e4</span><span class="s2">, </span><span class="s5">1e4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1e4</span><span class="s1">)]</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s5">5e-10</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_struvel(self):</span>
        <span class="s2">def </span><span class="s1">mp_struvel(v</span><span class="s2">, </span><span class="s1">z):</span>
            <span class="s2">if </span><span class="s1">v &lt; </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">z &lt; -v </span><span class="s2">and </span><span class="s1">abs(v) &gt; </span><span class="s5">1000</span><span class="s1">:</span>
                <span class="s4"># larger DPS needed for correct results</span>
                <span class="s1">old_dps = mpmath.mp.dps</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">mpmath.mp.dps = </span><span class="s5">300</span>
                    <span class="s2">return </span><span class="s1">mpmath.struvel(v</span><span class="s2">, </span><span class="s1">z)</span>
                <span class="s2">finally</span><span class="s1">:</span>
                    <span class="s1">mpmath.mp.dps = old_dps</span>
            <span class="s2">return </span><span class="s1">mpmath.struvel(v</span><span class="s2">, </span><span class="s1">z)</span>

        <span class="s1">assert_mpmath_equal(sc.modstruve</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(mp_struvel)</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">1e4</span><span class="s2">, </span><span class="s5">1e4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1e4</span><span class="s1">)]</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s5">5e-10</span><span class="s2">,</span>
                            <span class="s1">ignore_inf_sign=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_wrightomega_real(self):</span>
        <span class="s2">def </span><span class="s1">mpmath_wrightomega_real(x):</span>
            <span class="s2">return </span><span class="s1">mpmath.lambertw(mpmath.exp(x)</span><span class="s2">, </span><span class="s1">mpmath.mpf(</span><span class="s3">'-0.5'</span><span class="s1">))</span>

        <span class="s4"># For x &lt; -1000 the Wright Omega function is just 0 to double</span>
        <span class="s4"># precision, and for x &gt; 1e21 it is just x to double</span>
        <span class="s4"># precision.</span>
        <span class="s1">assert_mpmath_equal(</span>
            <span class="s1">sc.wrightomega</span><span class="s2">,</span>
            <span class="s1">mpmath_wrightomega_real</span><span class="s2">,</span>
            <span class="s1">[Arg(-</span><span class="s5">1000</span><span class="s2">, </span><span class="s5">1e21</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">rtol=</span><span class="s5">5e-15</span><span class="s2">,</span>
            <span class="s1">atol=</span><span class="s5">0</span><span class="s2">,</span>
            <span class="s1">nan_ok=</span><span class="s2">False,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_wrightomega(self):</span>
        <span class="s1">assert_mpmath_equal(sc.wrightomega</span><span class="s2">,</span>
                            <span class="s2">lambda </span><span class="s1">z: _mpmath_wrightomega(z</span><span class="s2">, </span><span class="s5">25</span><span class="s1">)</span><span class="s2">,</span>
                            <span class="s1">[ComplexArg()]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-14</span><span class="s2">, </span><span class="s1">nan_ok=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_hurwitz_zeta(self):</span>
        <span class="s1">assert_mpmath_equal(sc.zeta</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(mpmath.zeta)</span><span class="s2">,</span>
                            <span class="s1">[Arg(a=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">b=</span><span class="s5">1e10</span><span class="s2">, </span><span class="s1">inclusive_a=</span><span class="s2">False</span><span class="s1">)</span><span class="s2">,</span>
                             <span class="s1">Arg(a=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">inclusive_a=</span><span class="s2">False</span><span class="s1">)])</span>

    <span class="s2">def </span><span class="s1">test_riemann_zeta(self):</span>
        <span class="s1">assert_mpmath_equal(</span>
            <span class="s1">sc.zeta</span><span class="s2">,</span>
            <span class="s2">lambda </span><span class="s1">x: mpmath.zeta(x) </span><span class="s2">if </span><span class="s1">x != </span><span class="s5">1 </span><span class="s2">else </span><span class="s1">mpmath.inf</span><span class="s2">,</span>
            <span class="s1">[Arg(-</span><span class="s5">100</span><span class="s2">, </span><span class="s5">100</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">nan_ok=</span><span class="s2">False,</span>
            <span class="s1">rtol=</span><span class="s5">5e-13</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_zetac(self):</span>
        <span class="s1">assert_mpmath_equal(sc.zetac</span><span class="s2">,</span>
                            <span class="s2">lambda </span><span class="s1">x: (mpmath.zeta(x) - </span><span class="s5">1</span>
                                       <span class="s2">if </span><span class="s1">x != </span><span class="s5">1 </span><span class="s2">else </span><span class="s1">mpmath.inf)</span><span class="s2">,</span>
                            <span class="s1">[Arg(-</span><span class="s5">100</span><span class="s2">, </span><span class="s5">100</span><span class="s1">)]</span><span class="s2">,</span>
                            <span class="s1">nan_ok=</span><span class="s2">False, </span><span class="s1">dps=</span><span class="s5">45</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">5e-13</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_boxcox(self):</span>

        <span class="s2">def </span><span class="s1">mp_boxcox(x</span><span class="s2">, </span><span class="s1">lmbda):</span>
            <span class="s1">x = mpmath.mp.mpf(x)</span>
            <span class="s1">lmbda = mpmath.mp.mpf(lmbda)</span>
            <span class="s2">if </span><span class="s1">lmbda == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">mpmath.mp.log(x)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">mpmath.mp.powm1(x</span><span class="s2">, </span><span class="s1">lmbda) / lmbda</span>

        <span class="s1">assert_mpmath_equal(sc.boxcox</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(mp_boxcox)</span><span class="s2">,</span>
                            <span class="s1">[Arg(a=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">inclusive_a=</span><span class="s2">False</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg()]</span><span class="s2">,</span>
                            <span class="s1">n=</span><span class="s5">200</span><span class="s2">,</span>
                            <span class="s1">dps=</span><span class="s5">60</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s5">1e-13</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_boxcox1p(self):</span>

        <span class="s2">def </span><span class="s1">mp_boxcox1p(x</span><span class="s2">, </span><span class="s1">lmbda):</span>
            <span class="s1">x = mpmath.mp.mpf(x)</span>
            <span class="s1">lmbda = mpmath.mp.mpf(lmbda)</span>
            <span class="s1">one = mpmath.mp.mpf(</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">lmbda == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">mpmath.mp.log(one + x)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">mpmath.mp.powm1(one + x</span><span class="s2">, </span><span class="s1">lmbda) / lmbda</span>

        <span class="s1">assert_mpmath_equal(sc.boxcox1p</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(mp_boxcox1p)</span><span class="s2">,</span>
                            <span class="s1">[Arg(a=-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">inclusive_a=</span><span class="s2">False</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg()]</span><span class="s2">,</span>
                            <span class="s1">n=</span><span class="s5">200</span><span class="s2">,</span>
                            <span class="s1">dps=</span><span class="s5">60</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s5">1e-13</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_spherical_jn(self):</span>
        <span class="s2">def </span><span class="s1">mp_spherical_jn(n</span><span class="s2">, </span><span class="s1">z):</span>
            <span class="s1">arg = mpmath.mpmathify(z)</span>
            <span class="s1">out = (mpmath.besselj(n + mpmath.mpf(</span><span class="s5">1</span><span class="s1">)/</span><span class="s5">2</span><span class="s2">, </span><span class="s1">arg) /</span>
                   <span class="s1">mpmath.sqrt(</span><span class="s5">2</span><span class="s1">*arg/mpmath.pi))</span>
            <span class="s2">if </span><span class="s1">arg.imag == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">out.real</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">out</span>

        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">z: sc.spherical_jn(int(n)</span><span class="s2">, </span><span class="s1">z)</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(mp_spherical_jn)</span><span class="s2">,</span>
                            <span class="s1">[IntArg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">200</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg(-</span><span class="s5">1e8</span><span class="s2">, </span><span class="s5">1e8</span><span class="s1">)]</span><span class="s2">,</span>
                            <span class="s1">dps=</span><span class="s5">300</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_spherical_jn_complex(self):</span>
        <span class="s2">def </span><span class="s1">mp_spherical_jn(n</span><span class="s2">, </span><span class="s1">z):</span>
            <span class="s1">arg = mpmath.mpmathify(z)</span>
            <span class="s1">out = (mpmath.besselj(n + mpmath.mpf(</span><span class="s5">1</span><span class="s1">)/</span><span class="s5">2</span><span class="s2">, </span><span class="s1">arg) /</span>
                   <span class="s1">mpmath.sqrt(</span><span class="s5">2</span><span class="s1">*arg/mpmath.pi))</span>
            <span class="s2">if </span><span class="s1">arg.imag == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">out.real</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">out</span>

        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">z: sc.spherical_jn(int(n.real)</span><span class="s2">, </span><span class="s1">z)</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(mp_spherical_jn)</span><span class="s2">,</span>
                            <span class="s1">[IntArg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">200</span><span class="s1">)</span><span class="s2">, </span><span class="s1">ComplexArg()])</span>

    <span class="s2">def </span><span class="s1">test_spherical_yn(self):</span>
        <span class="s2">def </span><span class="s1">mp_spherical_yn(n</span><span class="s2">, </span><span class="s1">z):</span>
            <span class="s1">arg = mpmath.mpmathify(z)</span>
            <span class="s1">out = (mpmath.bessely(n + mpmath.mpf(</span><span class="s5">1</span><span class="s1">)/</span><span class="s5">2</span><span class="s2">, </span><span class="s1">arg) /</span>
                   <span class="s1">mpmath.sqrt(</span><span class="s5">2</span><span class="s1">*arg/mpmath.pi))</span>
            <span class="s2">if </span><span class="s1">arg.imag == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">out.real</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">out</span>

        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">z: sc.spherical_yn(int(n)</span><span class="s2">, </span><span class="s1">z)</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(mp_spherical_yn)</span><span class="s2">,</span>
                            <span class="s1">[IntArg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">200</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg(-</span><span class="s5">1e10</span><span class="s2">, </span><span class="s5">1e10</span><span class="s1">)]</span><span class="s2">,</span>
                            <span class="s1">dps=</span><span class="s5">100</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_spherical_yn_complex(self):</span>
        <span class="s2">def </span><span class="s1">mp_spherical_yn(n</span><span class="s2">, </span><span class="s1">z):</span>
            <span class="s1">arg = mpmath.mpmathify(z)</span>
            <span class="s1">out = (mpmath.bessely(n + mpmath.mpf(</span><span class="s5">1</span><span class="s1">)/</span><span class="s5">2</span><span class="s2">, </span><span class="s1">arg) /</span>
                   <span class="s1">mpmath.sqrt(</span><span class="s5">2</span><span class="s1">*arg/mpmath.pi))</span>
            <span class="s2">if </span><span class="s1">arg.imag == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">out.real</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">out</span>

        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">z: sc.spherical_yn(int(n.real)</span><span class="s2">, </span><span class="s1">z)</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(mp_spherical_yn)</span><span class="s2">,</span>
                            <span class="s1">[IntArg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">200</span><span class="s1">)</span><span class="s2">, </span><span class="s1">ComplexArg()])</span>

    <span class="s2">def </span><span class="s1">test_spherical_in(self):</span>
        <span class="s2">def </span><span class="s1">mp_spherical_in(n</span><span class="s2">, </span><span class="s1">z):</span>
            <span class="s1">arg = mpmath.mpmathify(z)</span>
            <span class="s1">out = (mpmath.besseli(n + mpmath.mpf(</span><span class="s5">1</span><span class="s1">)/</span><span class="s5">2</span><span class="s2">, </span><span class="s1">arg) /</span>
                   <span class="s1">mpmath.sqrt(</span><span class="s5">2</span><span class="s1">*arg/mpmath.pi))</span>
            <span class="s2">if </span><span class="s1">arg.imag == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">out.real</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">out</span>

        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">z: sc.spherical_in(int(n)</span><span class="s2">, </span><span class="s1">z)</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(mp_spherical_in)</span><span class="s2">,</span>
                            <span class="s1">[IntArg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">200</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg()]</span><span class="s2">,</span>
                            <span class="s1">dps=</span><span class="s5">200</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">10</span><span class="s1">**(-</span><span class="s5">278</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_spherical_in_complex(self):</span>
        <span class="s2">def </span><span class="s1">mp_spherical_in(n</span><span class="s2">, </span><span class="s1">z):</span>
            <span class="s1">arg = mpmath.mpmathify(z)</span>
            <span class="s1">out = (mpmath.besseli(n + mpmath.mpf(</span><span class="s5">1</span><span class="s1">)/</span><span class="s5">2</span><span class="s2">, </span><span class="s1">arg) /</span>
                   <span class="s1">mpmath.sqrt(</span><span class="s5">2</span><span class="s1">*arg/mpmath.pi))</span>
            <span class="s2">if </span><span class="s1">arg.imag == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">out.real</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">out</span>

        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">z: sc.spherical_in(int(n.real)</span><span class="s2">, </span><span class="s1">z)</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(mp_spherical_in)</span><span class="s2">,</span>
                            <span class="s1">[IntArg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">200</span><span class="s1">)</span><span class="s2">, </span><span class="s1">ComplexArg()])</span>

    <span class="s2">def </span><span class="s1">test_spherical_kn(self):</span>
        <span class="s2">def </span><span class="s1">mp_spherical_kn(n</span><span class="s2">, </span><span class="s1">z):</span>
            <span class="s1">out = (mpmath.besselk(n + mpmath.mpf(</span><span class="s5">1</span><span class="s1">)/</span><span class="s5">2</span><span class="s2">, </span><span class="s1">z) *</span>
                   <span class="s1">mpmath.sqrt(mpmath.pi/(</span><span class="s5">2</span><span class="s1">*mpmath.mpmathify(z))))</span>
            <span class="s2">if </span><span class="s1">mpmath.mpmathify(z).imag == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">out.real</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">out</span>

        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">z: sc.spherical_kn(int(n)</span><span class="s2">, </span><span class="s1">z)</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(mp_spherical_kn)</span><span class="s2">,</span>
                            <span class="s1">[IntArg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">150</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg()]</span><span class="s2">,</span>
                            <span class="s1">dps=</span><span class="s5">100</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.xfail(run=</span><span class="s2">False, </span><span class="s1">reason=</span><span class="s3">&quot;Accuracy issues near z = -1 inherited from kv.&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_spherical_kn_complex(self):</span>
        <span class="s2">def </span><span class="s1">mp_spherical_kn(n</span><span class="s2">, </span><span class="s1">z):</span>
            <span class="s1">arg = mpmath.mpmathify(z)</span>
            <span class="s1">out = (mpmath.besselk(n + mpmath.mpf(</span><span class="s5">1</span><span class="s1">)/</span><span class="s5">2</span><span class="s2">, </span><span class="s1">arg) /</span>
                   <span class="s1">mpmath.sqrt(</span><span class="s5">2</span><span class="s1">*arg/mpmath.pi))</span>
            <span class="s2">if </span><span class="s1">arg.imag == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">out.real</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">out</span>

        <span class="s1">assert_mpmath_equal(</span><span class="s2">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">z: sc.spherical_kn(int(n.real)</span><span class="s2">, </span><span class="s1">z)</span><span class="s2">,</span>
                            <span class="s1">exception_to_nan(mp_spherical_kn)</span><span class="s2">,</span>
                            <span class="s1">[IntArg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">200</span><span class="s1">)</span><span class="s2">, </span><span class="s1">ComplexArg()]</span><span class="s2">,</span>
                            <span class="s1">dps=</span><span class="s5">200</span><span class="s1">)</span>
</pre>
</body>
</html>