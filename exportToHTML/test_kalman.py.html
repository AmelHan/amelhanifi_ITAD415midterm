<html>
<head>
<title>test_kalman.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_kalman.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Tests for _representation and _kalman_filter modules 
 
Author: Chad Fulton 
License: Simplified-BSD 
 
References 
---------- 
 
Kim, Chang-Jin, and Charles R. Nelson. 1999. 
&quot;State-Space Models with Regime Switching: 
Classical and Gibbs-Sampling Approaches with Applications&quot;. 
MIT Press Books. The MIT Press. 
 
Hamilton, James D. 1994. 
Time Series Analysis. 
Princeton, N.J.: Princeton University Press. 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">copy</span>
<span class="s2">import </span><span class="s1">pickle</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">from </span><span class="s1">scipy.linalg.blas </span><span class="s2">import </span><span class="s1">find_best_blas_type</span>
<span class="s2">from </span><span class="s1">scipy.linalg </span><span class="s2">import </span><span class="s1">solve_discrete_lyapunov</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace.kalman_filter </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">MEMORY_NO_FORECAST</span><span class="s2">, </span><span class="s1">MEMORY_NO_PREDICTED</span><span class="s2">, </span><span class="s1">MEMORY_CONSERVE)</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace.mlemodel </span><span class="s2">import </span><span class="s1">MLEModel</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace </span><span class="s2">import </span><span class="s1">_representation</span><span class="s2">, </span><span class="s1">_kalman_filter</span>
<span class="s2">from </span><span class="s1">.results </span><span class="s2">import </span><span class="s1">results_kalman_filter</span>
<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">assert_almost_equal</span><span class="s2">, </span><span class="s1">assert_allclose</span>

<span class="s1">prefix_statespace_map = {</span>
    <span class="s3">'s'</span><span class="s1">: _representation.sStatespace</span><span class="s2">, </span><span class="s3">'d'</span><span class="s1">: _representation.dStatespace</span><span class="s2">,</span>
    <span class="s3">'c'</span><span class="s1">: _representation.cStatespace</span><span class="s2">, </span><span class="s3">'z'</span><span class="s1">: _representation.zStatespace</span>
<span class="s1">}</span>
<span class="s1">prefix_kalman_filter_map = {</span>
    <span class="s3">'s'</span><span class="s1">: _kalman_filter.sKalmanFilter</span><span class="s2">, </span><span class="s3">'d'</span><span class="s1">: _kalman_filter.dKalmanFilter</span><span class="s2">,</span>
    <span class="s3">'c'</span><span class="s1">: _kalman_filter.cKalmanFilter</span><span class="s2">, </span><span class="s3">'z'</span><span class="s1">: _kalman_filter.zKalmanFilter</span>
<span class="s1">}</span>

<span class="s1">current_path = os.path.dirname(os.path.abspath(__file__))</span>


<span class="s2">class </span><span class="s1">Clark1987:</span>
    <span class="s0">&quot;&quot;&quot; 
    Clark's (1987) univariate unobserved components model of real GDP (as 
    presented in Kim and Nelson, 1999) 
 
    Test data produced using GAUSS code described in Kim and Nelson (1999) and 
    found at http://econ.korea.ac.kr/~cjkim/SSMARKOV.htm 
 
    See `results.results_kalman_filter` for more information. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">dtype=float</span><span class="s2">, </span><span class="s1">conserve_memory=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">loglikelihood_burn=</span><span class="s4">0</span><span class="s1">):</span>
        <span class="s1">cls.true = results_kalman_filter.uc_uni</span>
        <span class="s1">cls.true_states = pd.DataFrame(cls.true[</span><span class="s3">'states'</span><span class="s1">])</span>

        <span class="s5"># GDP, Quarterly, 1947.1 - 1995.3</span>
        <span class="s1">data = pd.DataFrame(</span>
            <span class="s1">cls.true[</span><span class="s3">'data'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">index=pd.date_range(</span><span class="s3">'1947-01-01'</span><span class="s2">, </span><span class="s3">'1995-07-01'</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'QS'</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">columns=[</span><span class="s3">'GDP'</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">data[</span><span class="s3">'lgdp'</span><span class="s1">] = np.log(data[</span><span class="s3">'GDP'</span><span class="s1">])</span>

        <span class="s5"># Parameters</span>
        <span class="s1">cls.conserve_memory = conserve_memory</span>
        <span class="s1">cls.loglikelihood_burn = loglikelihood_burn</span>

        <span class="s5"># Observed data</span>
        <span class="s1">cls.obs = np.array(data[</span><span class="s3">'lgdp'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ndmin=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">&quot;F&quot;</span><span class="s1">)</span>

        <span class="s5"># Measurement equation</span>
        <span class="s1">cls.k_endog = k_endog = </span><span class="s4">1  </span><span class="s5"># dimension of observed data</span>
        <span class="s5"># design matrix</span>
        <span class="s1">cls.design = np.zeros((k_endog</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">&quot;F&quot;</span><span class="s1">)</span>
        <span class="s1">cls.design[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
        <span class="s5"># observation intercept</span>
        <span class="s1">cls.obs_intercept = np.zeros((k_endog</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">&quot;F&quot;</span><span class="s1">)</span>
        <span class="s5"># observation covariance matrix</span>
        <span class="s1">cls.obs_cov = np.zeros((k_endog</span><span class="s2">, </span><span class="s1">k_endog</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">&quot;F&quot;</span><span class="s1">)</span>

        <span class="s5"># Transition equation</span>
        <span class="s1">cls.k_states = k_states = </span><span class="s4">4  </span><span class="s5"># dimension of state space</span>
        <span class="s5"># transition matrix</span>
        <span class="s1">cls.transition = np.zeros((k_states</span><span class="s2">, </span><span class="s1">k_states</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
                                  <span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">&quot;F&quot;</span><span class="s1">)</span>
        <span class="s1">cls.transition[([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])] = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s5"># state intercept</span>
        <span class="s1">cls.state_intercept = np.zeros((k_states</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">&quot;F&quot;</span><span class="s1">)</span>
        <span class="s5"># selection matrix</span>
        <span class="s1">cls.selection = np.asfortranarray(np.eye(k_states)[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
                                          <span class="s1">dtype=dtype)</span>
        <span class="s5"># state covariance matrix</span>
        <span class="s1">cls.state_cov = np.zeros((k_states</span><span class="s2">, </span><span class="s1">k_states</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
                                 <span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">&quot;F&quot;</span><span class="s1">)</span>

        <span class="s5"># Initialization: Diffuse priors</span>
        <span class="s1">cls.initial_state = np.zeros((k_states</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">&quot;F&quot;</span><span class="s1">)</span>
        <span class="s1">cls.initial_state_cov = np.asfortranarray(np.eye(k_states)*</span><span class="s4">100</span><span class="s2">,</span>
                                                  <span class="s1">dtype=dtype)</span>

        <span class="s5"># Update matrices with given parameters</span>
        <span class="s1">(sigma_v</span><span class="s2">, </span><span class="s1">sigma_e</span><span class="s2">, </span><span class="s1">sigma_w</span><span class="s2">, </span><span class="s1">phi_1</span><span class="s2">, </span><span class="s1">phi_2) = np.array(</span>
            <span class="s1">cls.true[</span><span class="s3">'parameters'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype</span>
        <span class="s1">)</span>
        <span class="s1">cls.transition[([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])] = [phi_1</span><span class="s2">, </span><span class="s1">phi_2]</span>
        <span class="s1">cls.state_cov[</span>
            <span class="s1">np.diag_indices(k_states)+(np.zeros(k_states</span><span class="s2">, </span><span class="s1">dtype=int)</span><span class="s2">,</span><span class="s1">)] = [</span>
            <span class="s1">sigma_v**</span><span class="s4">2</span><span class="s2">, </span><span class="s1">sigma_e**</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">sigma_w**</span><span class="s4">2</span>
        <span class="s1">]</span>

        <span class="s5"># Initialization: modification</span>
        <span class="s5"># Due to the difference in the way Kim and Nelson (1999) and Durbin</span>
        <span class="s5"># and Koopman (2012) define the order of the Kalman filter routines,</span>
        <span class="s5"># we need to modify the initial state covariance matrix to match</span>
        <span class="s5"># Kim and Nelson's results, since the *Statespace models follow Durbin</span>
        <span class="s5"># and Koopman.</span>
        <span class="s1">cls.initial_state_cov = np.asfortranarray(</span>
            <span class="s1">np.dot(</span>
                <span class="s1">np.dot(cls.transition[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">cls.initial_state_cov)</span><span class="s2">,</span>
                <span class="s1">cls.transition[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">].T</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">init_filter(cls):</span>
        <span class="s5"># Use the appropriate Statespace model</span>
        <span class="s1">prefix = find_best_blas_type((cls.obs</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">klass = prefix_statespace_map[prefix[</span><span class="s4">0</span><span class="s1">]]</span>

        <span class="s5"># Instantiate the statespace model</span>
        <span class="s1">model = klass(</span>
            <span class="s1">cls.obs</span><span class="s2">, </span><span class="s1">cls.design</span><span class="s2">, </span><span class="s1">cls.obs_intercept</span><span class="s2">, </span><span class="s1">cls.obs_cov</span><span class="s2">,</span>
            <span class="s1">cls.transition</span><span class="s2">, </span><span class="s1">cls.state_intercept</span><span class="s2">, </span><span class="s1">cls.selection</span><span class="s2">,</span>
            <span class="s1">cls.state_cov</span>
        <span class="s1">)</span>
        <span class="s1">model.initialize_known(cls.initial_state</span><span class="s2">, </span><span class="s1">cls.initial_state_cov)</span>

        <span class="s5"># Initialize the appropriate Kalman filter</span>
        <span class="s1">klass = prefix_kalman_filter_map[prefix[</span><span class="s4">0</span><span class="s1">]]</span>
        <span class="s1">kfilter = klass(model</span><span class="s2">, </span><span class="s1">conserve_memory=cls.conserve_memory</span><span class="s2">,</span>
                        <span class="s1">loglikelihood_burn=cls.loglikelihood_burn)</span>

        <span class="s2">return </span><span class="s1">model</span><span class="s2">, </span><span class="s1">kfilter</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">run_filter(cls):</span>
        <span class="s5"># Filter the data</span>
        <span class="s1">cls.filter()</span>

        <span class="s5"># Get results</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s3">'loglike'</span><span class="s1">: </span><span class="s2">lambda </span><span class="s1">burn: np.sum(cls.filter.loglikelihood[burn:])</span><span class="s2">,</span>
            <span class="s3">'state'</span><span class="s1">: np.array(cls.filter.filtered_state)</span><span class="s2">,</span>
        <span class="s1">}</span>

    <span class="s2">def </span><span class="s1">test_loglike(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.result[</span><span class="s3">'loglike'</span><span class="s1">](self.true[</span><span class="s3">'start'</span><span class="s1">])</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'loglike'</span><span class="s1">]</span><span class="s2">, </span><span class="s4">5</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_filtered_state(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.result[</span><span class="s3">'state'</span><span class="s1">][</span><span class="s4">0</span><span class="s1">][self.true[</span><span class="s3">'start'</span><span class="s1">]:]</span><span class="s2">,</span>
            <span class="s1">self.true_states.iloc[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s4">4</span>
        <span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.result[</span><span class="s3">'state'</span><span class="s1">][</span><span class="s4">1</span><span class="s1">][self.true[</span><span class="s3">'start'</span><span class="s1">]:]</span><span class="s2">,</span>
            <span class="s1">self.true_states.iloc[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">4</span>
        <span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.result[</span><span class="s3">'state'</span><span class="s1">][</span><span class="s4">3</span><span class="s1">][self.true[</span><span class="s3">'start'</span><span class="s1">]:]</span><span class="s2">,</span>
            <span class="s1">self.true_states.iloc[:</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s4">4</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pickled_filter(self):</span>
        <span class="s1">pickled = pickle.loads(pickle.dumps(self.filter))</span>
        <span class="s5">#  Run the filters</span>
        <span class="s1">self.filter()</span>
        <span class="s1">pickled()</span>

        <span class="s2">assert </span><span class="s1">id(filter) != id(pickled)</span>
        <span class="s1">assert_allclose(np.array(self.filter.filtered_state)</span><span class="s2">,</span>
                        <span class="s1">np.array(pickled.filtered_state))</span>
        <span class="s1">assert_allclose(np.array(self.filter.loglikelihood)</span><span class="s2">,</span>
                        <span class="s1">np.array(pickled.loglikelihood))</span>

    <span class="s2">def </span><span class="s1">test_copied_filter(self):</span>
        <span class="s1">copied = copy.deepcopy(self.filter)</span>
        <span class="s5">#  Run the filters</span>
        <span class="s1">self.filter()</span>
        <span class="s1">copied()</span>

        <span class="s2">assert </span><span class="s1">id(filter) != id(copied)</span>
        <span class="s1">assert_allclose(np.array(self.filter.filtered_state)</span><span class="s2">,</span>
                        <span class="s1">np.array(copied.filtered_state))</span>

        <span class="s1">assert_allclose(np.array(self.filter.loglikelihood)</span><span class="s2">,</span>
                        <span class="s1">np.array(copied.loglikelihood))</span>


<span class="s2">class </span><span class="s1">TestClark1987Single(Clark1987):</span>
    <span class="s0">&quot;&quot;&quot; 
    Basic single precision test for the loglikelihood and filtered states. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s5"># TODO: Can we be more specific?  How can a contributor help?</span>
        <span class="s1">pytest.skip(</span><span class="s3">'Not implemented'</span><span class="s1">)</span>
        <span class="s1">super(TestClark1987Single</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">dtype=np.float32</span><span class="s2">, </span><span class="s1">conserve_memory=</span><span class="s4">0</span>
        <span class="s1">)</span>
        <span class="s1">cls.model</span><span class="s2">, </span><span class="s1">cls.filter = cls.init_filter()</span>
        <span class="s1">cls.result = cls.run_filter()</span>

    <span class="s2">def </span><span class="s1">test_loglike(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.result[</span><span class="s3">'loglike'</span><span class="s1">](self.true[</span><span class="s3">'start'</span><span class="s1">])</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'loglike'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">rtol=</span><span class="s4">1e-3</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_filtered_state(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.result[</span><span class="s3">'state'</span><span class="s1">][</span><span class="s4">0</span><span class="s1">][self.true[</span><span class="s3">'start'</span><span class="s1">]:]</span><span class="s2">,</span>
            <span class="s1">self.true_states.iloc[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">atol=</span><span class="s4">1e-2</span>
        <span class="s1">)</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.result[</span><span class="s3">'state'</span><span class="s1">][</span><span class="s4">1</span><span class="s1">][self.true[</span><span class="s3">'start'</span><span class="s1">]:]</span><span class="s2">,</span>
            <span class="s1">self.true_states.iloc[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">atol=</span><span class="s4">1e-2</span>
        <span class="s1">)</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.result[</span><span class="s3">'state'</span><span class="s1">][</span><span class="s4">3</span><span class="s1">][self.true[</span><span class="s3">'start'</span><span class="s1">]:]</span><span class="s2">,</span>
            <span class="s1">self.true_states.iloc[:</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">atol=</span><span class="s4">1e-2</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestClark1987Double(Clark1987):</span>
    <span class="s0">&quot;&quot;&quot; 
    Basic double precision test for the loglikelihood and filtered states. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">super(TestClark1987Double</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">dtype=float</span><span class="s2">, </span><span class="s1">conserve_memory=</span><span class="s4">0</span>
        <span class="s1">)</span>
        <span class="s1">cls.model</span><span class="s2">, </span><span class="s1">cls.filter = cls.init_filter()</span>
        <span class="s1">cls.result = cls.run_filter()</span>


<span class="s2">class </span><span class="s1">TestClark1987SingleComplex(Clark1987):</span>
    <span class="s0">&quot;&quot;&quot; 
    Basic single precision complex test for the loglikelihood and filtered 
    states. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s5"># TODO: Can we be more specific?  How can a contributor help?</span>
        <span class="s1">pytest.skip(</span><span class="s3">'Not implemented'</span><span class="s1">)</span>
        <span class="s1">super(TestClark1987SingleComplex</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">dtype=np.complex64</span><span class="s2">, </span><span class="s1">conserve_memory=</span><span class="s4">0</span>
        <span class="s1">)</span>
        <span class="s1">cls.model</span><span class="s2">, </span><span class="s1">cls.filter = cls.init_filter()</span>
        <span class="s1">cls.result = cls.run_filter()</span>

    <span class="s2">def </span><span class="s1">test_loglike(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.result[</span><span class="s3">'loglike'</span><span class="s1">](self.true[</span><span class="s3">'start'</span><span class="s1">])</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'loglike'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">rtol=</span><span class="s4">1e-3</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_filtered_state(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.result[</span><span class="s3">'state'</span><span class="s1">][</span><span class="s4">0</span><span class="s1">][self.true[</span><span class="s3">'start'</span><span class="s1">]:]</span><span class="s2">,</span>
            <span class="s1">self.true_states.iloc[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">atol=</span><span class="s4">1e-2</span>
        <span class="s1">)</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.result[</span><span class="s3">'state'</span><span class="s1">][</span><span class="s4">1</span><span class="s1">][self.true[</span><span class="s3">'start'</span><span class="s1">]:]</span><span class="s2">,</span>
            <span class="s1">self.true_states.iloc[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">atol=</span><span class="s4">1e-2</span>
        <span class="s1">)</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.result[</span><span class="s3">'state'</span><span class="s1">][</span><span class="s4">3</span><span class="s1">][self.true[</span><span class="s3">'start'</span><span class="s1">]:]</span><span class="s2">,</span>
            <span class="s1">self.true_states.iloc[:</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">atol=</span><span class="s4">1e-2</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestClark1987DoubleComplex(Clark1987):</span>
    <span class="s0">&quot;&quot;&quot; 
    Basic double precision complex test for the loglikelihood and filtered 
    states. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">super(TestClark1987DoubleComplex</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">dtype=complex</span><span class="s2">, </span><span class="s1">conserve_memory=</span><span class="s4">0</span>
        <span class="s1">)</span>
        <span class="s1">cls.model</span><span class="s2">, </span><span class="s1">cls.filter = cls.init_filter()</span>
        <span class="s1">cls.result = cls.run_filter()</span>


<span class="s2">class </span><span class="s1">TestClark1987Conserve(Clark1987):</span>
    <span class="s0">&quot;&quot;&quot; 
    Memory conservation test for the loglikelihood and filtered states. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">super(TestClark1987Conserve</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">dtype=float</span><span class="s2">,</span>
            <span class="s1">conserve_memory=MEMORY_NO_FORECAST | MEMORY_NO_PREDICTED</span>
        <span class="s1">)</span>
        <span class="s1">cls.model</span><span class="s2">, </span><span class="s1">cls.filter = cls.init_filter()</span>
        <span class="s1">cls.result = cls.run_filter()</span>


<span class="s2">class </span><span class="s1">Clark1987Forecast(Clark1987):</span>
    <span class="s0">&quot;&quot;&quot; 
    Forecasting test for the loglikelihood and filtered states. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">dtype=float</span><span class="s2">, </span><span class="s1">nforecast=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">conserve_memory=</span><span class="s4">0</span><span class="s1">):</span>
        <span class="s1">super(Clark1987Forecast</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">dtype</span><span class="s2">, </span><span class="s1">conserve_memory</span>
        <span class="s1">)</span>
        <span class="s1">cls.nforecast = nforecast</span>

        <span class="s5"># Add missing observations to the end (to forecast)</span>
        <span class="s1">cls._obs = cls.obs</span>
        <span class="s1">cls.obs = np.array(np.r_[cls.obs[</span><span class="s4">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">[np.nan]*nforecast]</span><span class="s2">,</span>
                           <span class="s1">ndmin=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">&quot;F&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_filtered_state(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.result[</span><span class="s3">'state'</span><span class="s1">][</span><span class="s4">0</span><span class="s1">][self.true[</span><span class="s3">'start'</span><span class="s1">]:-self.nforecast]</span><span class="s2">,</span>
            <span class="s1">self.true_states.iloc[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s4">4</span>
        <span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.result[</span><span class="s3">'state'</span><span class="s1">][</span><span class="s4">1</span><span class="s1">][self.true[</span><span class="s3">'start'</span><span class="s1">]:-self.nforecast]</span><span class="s2">,</span>
            <span class="s1">self.true_states.iloc[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">4</span>
        <span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.result[</span><span class="s3">'state'</span><span class="s1">][</span><span class="s4">3</span><span class="s1">][self.true[</span><span class="s3">'start'</span><span class="s1">]:-self.nforecast]</span><span class="s2">,</span>
            <span class="s1">self.true_states.iloc[:</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s4">4</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestClark1987ForecastDouble(Clark1987Forecast):</span>
    <span class="s0">&quot;&quot;&quot; 
    Basic double forecasting test for the loglikelihood and filtered states. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">super(TestClark1987ForecastDouble</span><span class="s2">, </span><span class="s1">cls).setup_class()</span>
        <span class="s1">cls.model</span><span class="s2">, </span><span class="s1">cls.filter = cls.init_filter()</span>
        <span class="s1">cls.result = cls.run_filter()</span>


<span class="s2">class </span><span class="s1">TestClark1987ForecastDoubleComplex(Clark1987Forecast):</span>
    <span class="s0">&quot;&quot;&quot; 
    Basic double complex forecasting test for the loglikelihood and filtered 
    states. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">super(TestClark1987ForecastDoubleComplex</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">dtype=complex</span>
        <span class="s1">)</span>
        <span class="s1">cls.model</span><span class="s2">, </span><span class="s1">cls.filter = cls.init_filter()</span>
        <span class="s1">cls.result = cls.run_filter()</span>


<span class="s2">class </span><span class="s1">TestClark1987ForecastConserve(Clark1987Forecast):</span>
    <span class="s0">&quot;&quot;&quot; 
    Memory conservation forecasting test for the loglikelihood and filtered 
    states. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">super(TestClark1987ForecastConserve</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">dtype=float</span><span class="s2">,</span>
            <span class="s1">conserve_memory=MEMORY_NO_FORECAST | MEMORY_NO_PREDICTED</span>
        <span class="s1">)</span>
        <span class="s1">cls.model</span><span class="s2">, </span><span class="s1">cls.filter = cls.init_filter()</span>
        <span class="s1">cls.result = cls.run_filter()</span>


<span class="s2">class </span><span class="s1">TestClark1987ConserveAll(Clark1987):</span>
    <span class="s0">&quot;&quot;&quot; 
    Memory conservation forecasting test for the loglikelihood and filtered 
    states. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">super(TestClark1987ConserveAll</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">dtype=float</span><span class="s2">, </span><span class="s1">conserve_memory=MEMORY_CONSERVE</span>
        <span class="s1">)</span>
        <span class="s1">cls.loglikelihood_burn = cls.true[</span><span class="s3">'start'</span><span class="s1">]</span>
        <span class="s1">cls.model</span><span class="s2">, </span><span class="s1">cls.filter = cls.init_filter()</span>
        <span class="s1">cls.result = cls.run_filter()</span>

    <span class="s2">def </span><span class="s1">test_loglike(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.result[</span><span class="s3">'loglike'</span><span class="s1">](</span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'loglike'</span><span class="s1">]</span><span class="s2">, </span><span class="s4">5</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_filtered_state(self):</span>
        <span class="s1">end = self.true_states.shape[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.result[</span><span class="s3">'state'</span><span class="s1">][</span><span class="s4">0</span><span class="s1">][-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">self.true_states.iloc[end-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s4">4</span>
        <span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.result[</span><span class="s3">'state'</span><span class="s1">][</span><span class="s4">1</span><span class="s1">][-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">self.true_states.iloc[end-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">4</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">Clark1989:</span>
    <span class="s0">&quot;&quot;&quot; 
    Clark's (1989) bivariate unobserved components model of real GDP (as 
    presented in Kim and Nelson, 1999) 
 
    Tests two-dimensional observation data. 
 
    Test data produced using GAUSS code described in Kim and Nelson (1999) and 
    found at http://econ.korea.ac.kr/~cjkim/SSMARKOV.htm 
 
    See `results.results_kalman_filter` for more information. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">dtype=float</span><span class="s2">, </span><span class="s1">conserve_memory=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">loglikelihood_burn=</span><span class="s4">0</span><span class="s1">):</span>
        <span class="s1">cls.true = results_kalman_filter.uc_bi</span>
        <span class="s1">cls.true_states = pd.DataFrame(cls.true[</span><span class="s3">'states'</span><span class="s1">])</span>

        <span class="s5"># GDP and Unemployment, Quarterly, 1948.1 - 1995.3</span>
        <span class="s1">data = pd.DataFrame(</span>
            <span class="s1">cls.true[</span><span class="s3">'data'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">index=pd.date_range(</span><span class="s3">'1947-01-01'</span><span class="s2">, </span><span class="s3">'1995-07-01'</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'QS'</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">columns=[</span><span class="s3">'GDP'</span><span class="s2">, </span><span class="s3">'UNEMP'</span><span class="s1">]</span>
        <span class="s1">)[</span><span class="s4">4</span><span class="s1">:]</span>
        <span class="s1">data[</span><span class="s3">'GDP'</span><span class="s1">] = np.log(data[</span><span class="s3">'GDP'</span><span class="s1">])</span>
        <span class="s1">data[</span><span class="s3">'UNEMP'</span><span class="s1">] = (data[</span><span class="s3">'UNEMP'</span><span class="s1">]/</span><span class="s4">100</span><span class="s1">)</span>

        <span class="s5"># Observed data</span>
        <span class="s1">cls.obs = np.array(data</span><span class="s2">, </span><span class="s1">ndmin=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">&quot;C&quot;</span><span class="s1">).T</span>

        <span class="s5"># Parameters</span>
        <span class="s1">cls.k_endog = k_endog = </span><span class="s4">2  </span><span class="s5"># dimension of observed data</span>
        <span class="s1">cls.k_states = k_states = </span><span class="s4">6  </span><span class="s5"># dimension of state space</span>
        <span class="s1">cls.conserve_memory = conserve_memory</span>
        <span class="s1">cls.loglikelihood_burn = loglikelihood_burn</span>

        <span class="s5"># Measurement equation</span>

        <span class="s5"># design matrix</span>
        <span class="s1">cls.design = np.zeros((k_endog</span><span class="s2">, </span><span class="s1">k_states</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">&quot;F&quot;</span><span class="s1">)</span>
        <span class="s1">cls.design[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] = [[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]]</span>
        <span class="s5"># observation intercept</span>
        <span class="s1">cls.obs_intercept = np.zeros((k_endog</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">&quot;F&quot;</span><span class="s1">)</span>
        <span class="s5"># observation covariance matrix</span>
        <span class="s1">cls.obs_cov = np.zeros((k_endog</span><span class="s2">, </span><span class="s1">k_endog</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">&quot;F&quot;</span><span class="s1">)</span>

        <span class="s5"># Transition equation</span>

        <span class="s5"># transition matrix</span>
        <span class="s1">cls.transition = np.zeros((k_states</span><span class="s2">, </span><span class="s1">k_states</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
                                  <span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">&quot;F&quot;</span><span class="s1">)</span>
        <span class="s1">cls.transition[([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])] = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s5"># state intercept</span>
        <span class="s1">cls.state_intercept = np.zeros((k_states</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">&quot;F&quot;</span><span class="s1">)</span>
        <span class="s5"># selection matrix</span>
        <span class="s1">cls.selection = np.asfortranarray(np.eye(k_states)[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
                                          <span class="s1">dtype=dtype)</span>
        <span class="s5"># state covariance matrix</span>
        <span class="s1">cls.state_cov = np.zeros((k_states</span><span class="s2">, </span><span class="s1">k_states</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
                                 <span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">&quot;F&quot;</span><span class="s1">)</span>

        <span class="s5"># Initialization: Diffuse priors</span>
        <span class="s1">cls.initial_state = np.zeros((k_states</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">cls.initial_state_cov = np.asfortranarray(np.eye(k_states)*</span><span class="s4">100</span><span class="s2">,</span>
                                                  <span class="s1">dtype=dtype)</span>

        <span class="s5"># Update matrices with given parameters</span>
        <span class="s1">(sigma_v</span><span class="s2">, </span><span class="s1">sigma_e</span><span class="s2">, </span><span class="s1">sigma_w</span><span class="s2">, </span><span class="s1">sigma_vl</span><span class="s2">, </span><span class="s1">sigma_ec</span><span class="s2">,</span>
         <span class="s1">phi_1</span><span class="s2">, </span><span class="s1">phi_2</span><span class="s2">, </span><span class="s1">alpha_1</span><span class="s2">, </span><span class="s1">alpha_2</span><span class="s2">, </span><span class="s1">alpha_3) = np.array(</span>
            <span class="s1">cls.true[</span><span class="s3">'parameters'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype</span>
        <span class="s1">)</span>
        <span class="s1">cls.design[([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])] = [</span>
            <span class="s1">alpha_1</span><span class="s2">, </span><span class="s1">alpha_2</span><span class="s2">, </span><span class="s1">alpha_3</span>
        <span class="s1">]</span>
        <span class="s1">cls.transition[([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])] = [phi_1</span><span class="s2">, </span><span class="s1">phi_2]</span>
        <span class="s1">cls.obs_cov[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] = sigma_ec**</span><span class="s4">2</span>
        <span class="s1">cls.state_cov[</span>
            <span class="s1">np.diag_indices(k_states)+(np.zeros(k_states</span><span class="s2">, </span><span class="s1">dtype=int)</span><span class="s2">,</span><span class="s1">)] = [</span>
            <span class="s1">sigma_v**</span><span class="s4">2</span><span class="s2">, </span><span class="s1">sigma_e**</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">sigma_w**</span><span class="s4">2</span><span class="s2">, </span><span class="s1">sigma_vl**</span><span class="s4">2</span>
        <span class="s1">]</span>

        <span class="s5"># Initialization: modification</span>
        <span class="s5"># Due to the difference in the way Kim and Nelson (1999) and Drubin</span>
        <span class="s5"># and Koopman (2012) define the order of the Kalman filter routines,</span>
        <span class="s5"># we need to modify the initial state covariance matrix to match</span>
        <span class="s5"># Kim and Nelson's results, since the *Statespace models follow Durbin</span>
        <span class="s5"># and Koopman.</span>
        <span class="s1">cls.initial_state_cov = np.asfortranarray(</span>
            <span class="s1">np.dot(</span>
                <span class="s1">np.dot(cls.transition[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">cls.initial_state_cov)</span><span class="s2">,</span>
                <span class="s1">cls.transition[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">].T</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">init_filter(cls):</span>
        <span class="s5"># Use the appropriate Statespace model</span>
        <span class="s1">prefix = find_best_blas_type((cls.obs</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">klass = prefix_statespace_map[prefix[</span><span class="s4">0</span><span class="s1">]]</span>

        <span class="s5"># Instantiate the statespace model</span>
        <span class="s1">model = klass(</span>
            <span class="s1">cls.obs</span><span class="s2">, </span><span class="s1">cls.design</span><span class="s2">, </span><span class="s1">cls.obs_intercept</span><span class="s2">, </span><span class="s1">cls.obs_cov</span><span class="s2">,</span>
            <span class="s1">cls.transition</span><span class="s2">, </span><span class="s1">cls.state_intercept</span><span class="s2">, </span><span class="s1">cls.selection</span><span class="s2">,</span>
            <span class="s1">cls.state_cov</span>
        <span class="s1">)</span>
        <span class="s1">model.initialize_known(cls.initial_state</span><span class="s2">, </span><span class="s1">cls.initial_state_cov)</span>

        <span class="s5"># Initialize the appropriate Kalman filter</span>
        <span class="s1">klass = prefix_kalman_filter_map[prefix[</span><span class="s4">0</span><span class="s1">]]</span>
        <span class="s1">kfilter = klass(model</span><span class="s2">, </span><span class="s1">conserve_memory=cls.conserve_memory</span><span class="s2">,</span>
                        <span class="s1">loglikelihood_burn=cls.loglikelihood_burn)</span>

        <span class="s2">return </span><span class="s1">model</span><span class="s2">, </span><span class="s1">kfilter</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">run_filter(cls):</span>
        <span class="s5"># Filter the data</span>
        <span class="s1">cls.filter()</span>

        <span class="s5"># Get results</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s3">'loglike'</span><span class="s1">: </span><span class="s2">lambda </span><span class="s1">burn: np.sum(cls.filter.loglikelihood[burn:])</span><span class="s2">,</span>
            <span class="s3">'state'</span><span class="s1">: np.array(cls.filter.filtered_state)</span><span class="s2">,</span>
        <span class="s1">}</span>

    <span class="s2">def </span><span class="s1">test_loglike(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s5"># self.result['loglike'](self.true['start']),</span>
            <span class="s1">self.result[</span><span class="s3">'loglike'</span><span class="s1">](</span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">self.true[</span><span class="s3">'loglike'</span><span class="s1">]</span><span class="s2">, </span><span class="s4">2</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_filtered_state(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.result[</span><span class="s3">'state'</span><span class="s1">][</span><span class="s4">0</span><span class="s1">][self.true[</span><span class="s3">'start'</span><span class="s1">]:]</span><span class="s2">,</span>
            <span class="s1">self.true_states.iloc[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s4">4</span>
        <span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.result[</span><span class="s3">'state'</span><span class="s1">][</span><span class="s4">1</span><span class="s1">][self.true[</span><span class="s3">'start'</span><span class="s1">]:]</span><span class="s2">,</span>
            <span class="s1">self.true_states.iloc[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">4</span>
        <span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.result[</span><span class="s3">'state'</span><span class="s1">][</span><span class="s4">4</span><span class="s1">][self.true[</span><span class="s3">'start'</span><span class="s1">]:]</span><span class="s2">,</span>
            <span class="s1">self.true_states.iloc[:</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s4">4</span>
        <span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.result[</span><span class="s3">'state'</span><span class="s1">][</span><span class="s4">5</span><span class="s1">][self.true[</span><span class="s3">'start'</span><span class="s1">]:]</span><span class="s2">,</span>
            <span class="s1">self.true_states.iloc[:</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s4">4</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestClark1989(Clark1989):</span>
    <span class="s0">&quot;&quot;&quot; 
    Basic double precision test for the loglikelihood and filtered 
    states with two-dimensional observation vector. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">super(TestClark1989</span><span class="s2">, </span><span class="s1">cls).setup_class(dtype=float</span><span class="s2">, </span><span class="s1">conserve_memory=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">cls.model</span><span class="s2">, </span><span class="s1">cls.filter = cls.init_filter()</span>
        <span class="s1">cls.result = cls.run_filter()</span>


<span class="s2">class </span><span class="s1">TestClark1989Conserve(Clark1989):</span>
    <span class="s0">&quot;&quot;&quot; 
    Memory conservation test for the loglikelihood and filtered states with 
    two-dimensional observation vector. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">super(TestClark1989Conserve</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">dtype=float</span><span class="s2">,</span>
            <span class="s1">conserve_memory=MEMORY_NO_FORECAST | MEMORY_NO_PREDICTED</span>
        <span class="s1">)</span>
        <span class="s1">cls.model</span><span class="s2">, </span><span class="s1">cls.filter = cls.init_filter()</span>
        <span class="s1">cls.result = cls.run_filter()</span>


<span class="s2">class </span><span class="s1">Clark1989Forecast(Clark1989):</span>
    <span class="s0">&quot;&quot;&quot; 
    Memory conservation test for the loglikelihood and filtered states with 
    two-dimensional observation vector. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">dtype=float</span><span class="s2">, </span><span class="s1">nforecast=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">conserve_memory=</span><span class="s4">0</span><span class="s1">):</span>
        <span class="s1">super(Clark1989Forecast</span><span class="s2">, </span><span class="s1">cls).setup_class(dtype</span><span class="s2">, </span><span class="s1">conserve_memory)</span>
        <span class="s1">cls.nforecast = nforecast</span>

        <span class="s5"># Add missing observations to the end (to forecast)</span>
        <span class="s1">cls._obs = cls.obs</span>
        <span class="s1">cls.obs = np.array(</span>
            <span class="s1">np.c_[</span>
                <span class="s1">cls._obs</span><span class="s2">,</span>
                <span class="s1">np.r_[[np.nan</span><span class="s2">, </span><span class="s1">np.nan]*nforecast].reshape(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">nforecast)</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">ndmin=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">&quot;F&quot;</span>
        <span class="s1">)</span>

        <span class="s1">cls.model</span><span class="s2">, </span><span class="s1">cls.filter = cls.init_filter()</span>
        <span class="s1">cls.result = cls.run_filter()</span>

    <span class="s2">def </span><span class="s1">test_filtered_state(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.result[</span><span class="s3">'state'</span><span class="s1">][</span><span class="s4">0</span><span class="s1">][self.true[</span><span class="s3">'start'</span><span class="s1">]:-self.nforecast]</span><span class="s2">,</span>
            <span class="s1">self.true_states.iloc[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s4">4</span>
        <span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.result[</span><span class="s3">'state'</span><span class="s1">][</span><span class="s4">1</span><span class="s1">][self.true[</span><span class="s3">'start'</span><span class="s1">]:-self.nforecast]</span><span class="s2">,</span>
            <span class="s1">self.true_states.iloc[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">4</span>
        <span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.result[</span><span class="s3">'state'</span><span class="s1">][</span><span class="s4">4</span><span class="s1">][self.true[</span><span class="s3">'start'</span><span class="s1">]:-self.nforecast]</span><span class="s2">,</span>
            <span class="s1">self.true_states.iloc[:</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s4">4</span>
        <span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.result[</span><span class="s3">'state'</span><span class="s1">][</span><span class="s4">5</span><span class="s1">][self.true[</span><span class="s3">'start'</span><span class="s1">]:-self.nforecast]</span><span class="s2">,</span>
            <span class="s1">self.true_states.iloc[:</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s4">4</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestClark1989ForecastDouble(Clark1989Forecast):</span>
    <span class="s0">&quot;&quot;&quot; 
    Basic double forecasting test for the loglikelihood and filtered states. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">super(TestClark1989ForecastDouble</span><span class="s2">, </span><span class="s1">cls).setup_class()</span>
        <span class="s1">cls.model</span><span class="s2">, </span><span class="s1">cls.filter = cls.init_filter()</span>
        <span class="s1">cls.result = cls.run_filter()</span>


<span class="s2">class </span><span class="s1">TestClark1989ForecastDoubleComplex(Clark1989Forecast):</span>
    <span class="s0">&quot;&quot;&quot; 
    Basic double complex forecasting test for the loglikelihood and filtered 
    states. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">super(TestClark1989ForecastDoubleComplex</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">dtype=complex</span>
        <span class="s1">)</span>
        <span class="s1">cls.model</span><span class="s2">, </span><span class="s1">cls.filter = cls.init_filter()</span>
        <span class="s1">cls.result = cls.run_filter()</span>


<span class="s2">class </span><span class="s1">TestClark1989ForecastConserve(Clark1989Forecast):</span>
    <span class="s0">&quot;&quot;&quot; 
    Memory conservation forecasting test for the loglikelihood and filtered 
    states. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">super(TestClark1989ForecastConserve</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">dtype=float</span><span class="s2">,</span>
            <span class="s1">conserve_memory=MEMORY_NO_FORECAST | MEMORY_NO_PREDICTED</span>
        <span class="s1">)</span>
        <span class="s1">cls.model</span><span class="s2">, </span><span class="s1">cls.filter = cls.init_filter()</span>
        <span class="s1">cls.result = cls.run_filter()</span>


<span class="s2">class </span><span class="s1">TestClark1989ConserveAll(Clark1989):</span>
    <span class="s0">&quot;&quot;&quot; 
    Memory conservation forecasting test for the loglikelihood and filtered 
    states. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">super(TestClark1989ConserveAll</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">dtype=float</span><span class="s2">, </span><span class="s1">conserve_memory=MEMORY_CONSERVE</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s5"># cls.loglikelihood_burn = cls.true['start']</span>
        <span class="s1">cls.loglikelihood_burn = </span><span class="s4">0</span>
        <span class="s1">cls.model</span><span class="s2">, </span><span class="s1">cls.filter = cls.init_filter()</span>
        <span class="s1">cls.result = cls.run_filter()</span>

    <span class="s2">def </span><span class="s1">test_loglike(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.result[</span><span class="s3">'loglike'</span><span class="s1">](</span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'loglike'</span><span class="s1">]</span><span class="s2">, </span><span class="s4">2</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_filtered_state(self):</span>
        <span class="s1">end = self.true_states.shape[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.result[</span><span class="s3">'state'</span><span class="s1">][</span><span class="s4">0</span><span class="s1">][-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">self.true_states.iloc[end-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s4">4</span>
        <span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.result[</span><span class="s3">'state'</span><span class="s1">][</span><span class="s4">1</span><span class="s1">][-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">self.true_states.iloc[end-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">4</span>
        <span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.result[</span><span class="s3">'state'</span><span class="s1">][</span><span class="s4">4</span><span class="s1">][-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">self.true_states.iloc[end-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s4">4</span>
        <span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.result[</span><span class="s3">'state'</span><span class="s1">][</span><span class="s4">5</span><span class="s1">][-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">self.true_states.iloc[end-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s4">4</span>
        <span class="s1">)</span>


<span class="s2">def </span><span class="s1">check_stationary_initialization_1dim(dtype=float):</span>
    <span class="s1">endog = np.zeros(</span><span class="s4">10</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

    <span class="s5"># 1-dimensional example</span>
    <span class="s1">mod = MLEModel(endog</span><span class="s2">, </span><span class="s1">k_states=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">k_posdef=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">mod.ssm.initialize_stationary()</span>
    <span class="s1">intercept = np.array([</span><span class="s4">2.3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">phi = np.diag([</span><span class="s4">0.9</span><span class="s1">]).astype(dtype)</span>
    <span class="s1">sigma2 = np.diag([</span><span class="s4">1.3</span><span class="s1">]).astype(dtype)</span>

    <span class="s1">mod[</span><span class="s3">'state_intercept'</span><span class="s1">] = intercept</span>
    <span class="s1">mod[</span><span class="s3">'transition'</span><span class="s1">] = phi</span>
    <span class="s1">mod[</span><span class="s3">'selection'</span><span class="s1">] = np.eye(</span><span class="s4">1</span><span class="s1">).astype(dtype)</span>
    <span class="s1">mod[</span><span class="s3">'state_cov'</span><span class="s1">] = sigma2</span>

    <span class="s1">mod.ssm._initialize_filter()</span>
    <span class="s1">mod.ssm._initialize_state()</span>

    <span class="s1">_statespace = mod.ssm._statespace</span>
    <span class="s1">initial_state = np.array(_statespace.initial_state)</span>
    <span class="s1">initial_state_cov = np.array(_statespace.initial_state_cov)</span>
    <span class="s5"># precision reductions only required for float complex case</span>

    <span class="s5"># mean = intercept + phi * mean</span>
    <span class="s5"># intercept = (1 - phi) * mean</span>
    <span class="s5"># mean = intercept / (1 - phi)</span>
    <span class="s1">assert_allclose(initial_state</span><span class="s2">, </span><span class="s1">intercept / (</span><span class="s4">1 </span><span class="s1">- phi[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]))</span>
    <span class="s1">desired = np.linalg.inv(np.eye(</span><span class="s4">1</span><span class="s1">) - phi).dot(intercept)</span>
    <span class="s1">assert_allclose(initial_state</span><span class="s2">, </span><span class="s1">desired)</span>
    <span class="s5"># var = phi**2 var + sigma2</span>
    <span class="s5"># var = sigma2 / (1 - phi**2)</span>
    <span class="s1">assert_allclose(initial_state_cov</span><span class="s2">, </span><span class="s1">sigma2 / (</span><span class="s4">1 </span><span class="s1">- phi**</span><span class="s4">2</span><span class="s1">))</span>
    <span class="s1">assert_allclose(initial_state_cov</span><span class="s2">, </span><span class="s1">solve_discrete_lyapunov(phi</span><span class="s2">, </span><span class="s1">sigma2))</span>


<span class="s2">def </span><span class="s1">check_stationary_initialization_2dim(dtype=float):</span>
    <span class="s1">endog = np.zeros(</span><span class="s4">10</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s5"># 2-dimensional example</span>
    <span class="s1">mod = MLEModel(endog</span><span class="s2">, </span><span class="s1">k_states=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">k_posdef=</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">mod.ssm.initialize_stationary()</span>
    <span class="s1">intercept = np.array([</span><span class="s4">2.3</span><span class="s2">, </span><span class="s1">-</span><span class="s4">10.2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">phi = np.array([[</span><span class="s4">0.8</span><span class="s2">, </span><span class="s4">0.1</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">[-</span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.7</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">sigma2 = np.array([[</span><span class="s4">1.4</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.2</span><span class="s1">]</span><span class="s2">,</span>
                       <span class="s1">[-</span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">4.5</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

    <span class="s1">mod[</span><span class="s3">'state_intercept'</span><span class="s1">] = intercept</span>
    <span class="s1">mod[</span><span class="s3">'transition'</span><span class="s1">] = phi</span>
    <span class="s1">mod[</span><span class="s3">'selection'</span><span class="s1">] = np.eye(</span><span class="s4">2</span><span class="s1">).astype(dtype)</span>
    <span class="s1">mod[</span><span class="s3">'state_cov'</span><span class="s1">] = sigma2</span>

    <span class="s1">mod.ssm._initialize_filter()</span>
    <span class="s1">mod.ssm._initialize_state()</span>

    <span class="s1">_statespace = mod.ssm._statespace</span>
    <span class="s1">initial_state = np.array(_statespace.initial_state)</span>
    <span class="s1">initial_state_cov = np.array(_statespace.initial_state_cov)</span>

    <span class="s1">desired = np.linalg.solve(np.eye(</span><span class="s4">2</span><span class="s1">).astype(dtype) - phi</span><span class="s2">, </span><span class="s1">intercept)</span>
    <span class="s1">assert_allclose(initial_state</span><span class="s2">, </span><span class="s1">desired)</span>
    <span class="s1">desired = solve_discrete_lyapunov(phi</span><span class="s2">, </span><span class="s1">sigma2)</span>
    <span class="s5"># precision reductions only required for single precision float / complex</span>
    <span class="s1">assert_allclose(initial_state_cov</span><span class="s2">, </span><span class="s1">desired</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-5</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_stationary_initialization():</span>
    <span class="s1">check_stationary_initialization_1dim(np.float32)</span>
    <span class="s1">check_stationary_initialization_1dim(np.float64)</span>
    <span class="s1">check_stationary_initialization_1dim(np.complex64)</span>
    <span class="s1">check_stationary_initialization_1dim(np.complex128)</span>

    <span class="s1">check_stationary_initialization_2dim(np.float32)</span>
    <span class="s1">check_stationary_initialization_2dim(np.float64)</span>
    <span class="s1">check_stationary_initialization_2dim(np.complex64)</span>
    <span class="s1">check_stationary_initialization_2dim(np.complex128)</span>
</pre>
</body>
</html>