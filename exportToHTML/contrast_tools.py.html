<html>
<head>
<title>contrast_tools.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
contrast_tools.py</font>
</center></td></tr></table>
<pre><span class="s0">'''functions to work with contrasts for multiple tests 
 
contrast matrices for comparing all pairs, all levels to reference level, ... 
extension to 2-way groups in progress 
 
TwoWay: class for bringing two-way analysis together and try out 
various helper functions 
 
 
Idea for second part 
- get all transformation matrices to move in between different full rank 
  parameterizations 
- standardize to one parameterization to get all interesting effects. 
 
- multivariate normal distribution 
  - exploit or expand what we have in LikelihoodResults, cov_params, f_test, 
    t_test, example: resols_dropf_full.cov_params(C2) 
  - connect to new multiple comparison for contrast matrices, based on 
    multivariate normal or t distribution (Hothorn, Bretz, Westfall) 
 
'''</span>



<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">assert_equal</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s3">#next 3 functions copied from multicomp.py</span>

<span class="s2">def </span><span class="s1">contrast_allpairs(nm):</span>
    <span class="s0">'''contrast or restriction matrix for all pairs of nm variables 
 
    Parameters 
    ---------- 
    nm : int 
 
    Returns 
    ------- 
    contr : ndarray, 2d, (nm*(nm-1)/2, nm) 
       contrast matrix for all pairwise comparisons 
 
    '''</span>
    <span class="s1">contr = []</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(nm):</span>
        <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(i+</span><span class="s4">1</span><span class="s2">, </span><span class="s1">nm):</span>
            <span class="s1">contr_row = np.zeros(nm)</span>
            <span class="s1">contr_row[i] = </span><span class="s4">1</span>
            <span class="s1">contr_row[j] = -</span><span class="s4">1</span>
            <span class="s1">contr.append(contr_row)</span>
    <span class="s2">return </span><span class="s1">np.array(contr)</span>

<span class="s2">def </span><span class="s1">contrast_all_one(nm):</span>
    <span class="s0">'''contrast or restriction matrix for all against first comparison 
 
    Parameters 
    ---------- 
    nm : int 
 
    Returns 
    ------- 
    contr : ndarray, 2d, (nm-1, nm) 
       contrast matrix for all against first comparisons 
 
    '''</span>
    <span class="s1">contr = np.column_stack((np.ones(nm-</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">-np.eye(nm-</span><span class="s4">1</span><span class="s1">)))</span>
    <span class="s2">return </span><span class="s1">contr</span>

<span class="s2">def </span><span class="s1">contrast_diff_mean(nm):</span>
    <span class="s0">'''contrast or restriction matrix for all against mean comparison 
 
    Parameters 
    ---------- 
    nm : int 
 
    Returns 
    ------- 
    contr : ndarray, 2d, (nm-1, nm) 
       contrast matrix for all against mean comparisons 
 
    '''</span>
    <span class="s2">return </span><span class="s1">np.eye(nm) - np.ones((nm</span><span class="s2">,</span><span class="s1">nm))/nm</span>

<span class="s2">def </span><span class="s1">signstr(x</span><span class="s2">, </span><span class="s1">noplus=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s2">if </span><span class="s1">x </span><span class="s2">in </span><span class="s1">[-</span><span class="s4">1</span><span class="s2">,</span><span class="s4">0</span><span class="s2">,</span><span class="s4">1</span><span class="s1">]:</span>
        <span class="s2">if not </span><span class="s1">noplus:</span>
            <span class="s2">return </span><span class="s5">'+' </span><span class="s2">if </span><span class="s1">np.sign(x)&gt;=</span><span class="s4">0 </span><span class="s2">else </span><span class="s5">'-'</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s5">'' </span><span class="s2">if </span><span class="s1">np.sign(x)&gt;=</span><span class="s4">0 </span><span class="s2">else </span><span class="s5">'-'</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">str(x)</span>


<span class="s2">def </span><span class="s1">contrast_labels(contrasts</span><span class="s2">, </span><span class="s1">names</span><span class="s2">, </span><span class="s1">reverse=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s2">if </span><span class="s1">reverse:</span>
        <span class="s1">sl = slice(</span><span class="s2">None, None, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">sl = slice(</span><span class="s2">None</span><span class="s1">)</span>
    <span class="s1">labels = [</span><span class="s5">''</span><span class="s1">.join([</span><span class="s5">'%s%s' </span><span class="s1">% (signstr(c</span><span class="s2">, </span><span class="s1">noplus=</span><span class="s2">True</span><span class="s1">)</span><span class="s2">,</span><span class="s1">v)</span>
                          <span class="s2">for </span><span class="s1">c</span><span class="s2">,</span><span class="s1">v </span><span class="s2">in </span><span class="s1">zip(row</span><span class="s2">, </span><span class="s1">names)[sl] </span><span class="s2">if </span><span class="s1">c != </span><span class="s4">0</span><span class="s1">])</span>
                             <span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">contrasts]</span>
    <span class="s2">return </span><span class="s1">labels</span>

<span class="s2">def </span><span class="s1">contrast_product(names1</span><span class="s2">, </span><span class="s1">names2</span><span class="s2">, </span><span class="s1">intgroup1=</span><span class="s2">None, </span><span class="s1">intgroup2=</span><span class="s2">None, </span><span class="s1">pairs=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">'''build contrast matrices for products of two categorical variables 
 
    this is an experimental script and should be converted to a class 
 
    Parameters 
    ---------- 
    names1, names2 : lists of strings 
        contains the list of level labels for each categorical variable 
    intgroup1, intgroup2 : ndarrays     TODO: this part not tested, finished yet 
        categorical variable 
 
 
    Notes 
    ----- 
    This creates a full rank matrix. It does not do all pairwise comparisons, 
    parameterization is using contrast_all_one to get differences with first 
    level. 
 
    ? does contrast_all_pairs work as a plugin to get all pairs ? 
 
    '''</span>

    <span class="s1">n1 = len(names1)</span>
    <span class="s1">n2 = len(names2)</span>
    <span class="s1">names_prod = [</span><span class="s5">'%s_%s' </span><span class="s1">% (i</span><span class="s2">,</span><span class="s1">j) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">names1 </span><span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">names2]</span>
    <span class="s1">ee1 = np.zeros((</span><span class="s4">1</span><span class="s2">,</span><span class="s1">n1))</span>
    <span class="s1">ee1[</span><span class="s4">0</span><span class="s2">,</span><span class="s4">0</span><span class="s1">] = </span><span class="s4">1</span>
    <span class="s2">if not </span><span class="s1">pairs:</span>
        <span class="s1">dd = np.r_[ee1</span><span class="s2">, </span><span class="s1">-contrast_all_one(n1)]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">dd = np.r_[ee1</span><span class="s2">, </span><span class="s1">-contrast_allpairs(n1)]</span>

    <span class="s1">contrast_prod = np.kron(dd[</span><span class="s4">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">np.eye(n2))</span>
    <span class="s1">names_contrast_prod0 = contrast_labels(contrast_prod</span><span class="s2">, </span><span class="s1">names_prod</span><span class="s2">, </span><span class="s1">reverse=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">names_contrast_prod = [</span><span class="s5">''</span><span class="s1">.join([</span><span class="s5">'%s%s' </span><span class="s1">% (signstr(c</span><span class="s2">, </span><span class="s1">noplus=</span><span class="s2">True</span><span class="s1">)</span><span class="s2">,</span><span class="s1">v)</span>
                              <span class="s2">for </span><span class="s1">c</span><span class="s2">,</span><span class="s1">v </span><span class="s2">in </span><span class="s1">zip(row</span><span class="s2">, </span><span class="s1">names_prod)[::-</span><span class="s4">1</span><span class="s1">] </span><span class="s2">if </span><span class="s1">c != </span><span class="s4">0</span><span class="s1">])</span>
                                 <span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">contrast_prod]</span>

    <span class="s1">ee2 = np.zeros((</span><span class="s4">1</span><span class="s2">,</span><span class="s1">n2))</span>
    <span class="s1">ee2[</span><span class="s4">0</span><span class="s2">,</span><span class="s4">0</span><span class="s1">] = </span><span class="s4">1</span>
    <span class="s3">#dd2 = np.r_[ee2, -contrast_all_one(n2)]</span>
    <span class="s2">if not </span><span class="s1">pairs:</span>
        <span class="s1">dd2 = np.r_[ee2</span><span class="s2">, </span><span class="s1">-contrast_all_one(n2)]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">dd2 = np.r_[ee2</span><span class="s2">, </span><span class="s1">-contrast_allpairs(n2)]</span>

    <span class="s1">contrast_prod2 = np.kron(np.eye(n1)</span><span class="s2">, </span><span class="s1">dd2[</span><span class="s4">1</span><span class="s1">:])</span>
    <span class="s1">names_contrast_prod2 = [</span><span class="s5">''</span><span class="s1">.join([</span><span class="s5">'%s%s' </span><span class="s1">% (signstr(c</span><span class="s2">, </span><span class="s1">noplus=</span><span class="s2">True</span><span class="s1">)</span><span class="s2">,</span><span class="s1">v)</span>
                              <span class="s2">for </span><span class="s1">c</span><span class="s2">,</span><span class="s1">v </span><span class="s2">in </span><span class="s1">zip(row</span><span class="s2">, </span><span class="s1">names_prod)[::-</span><span class="s4">1</span><span class="s1">] </span><span class="s2">if </span><span class="s1">c != </span><span class="s4">0</span><span class="s1">])</span>
                                 <span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">contrast_prod2]</span>

    <span class="s2">if </span><span class="s1">(intgroup1 </span><span class="s2">is not None</span><span class="s1">) </span><span class="s2">and </span><span class="s1">(intgroup1 </span><span class="s2">is not None</span><span class="s1">):</span>
        <span class="s1">d1</span><span class="s2">, </span><span class="s1">_ = dummy_1d(intgroup1)</span>
        <span class="s1">d2</span><span class="s2">, </span><span class="s1">_ = dummy_1d(intgroup2)</span>
        <span class="s1">dummy = dummy_product(d1</span><span class="s2">, </span><span class="s1">d2)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">dummy = </span><span class="s2">None</span>

    <span class="s2">return </span><span class="s1">(names_prod</span><span class="s2">, </span><span class="s1">contrast_prod</span><span class="s2">, </span><span class="s1">names_contrast_prod</span><span class="s2">,</span>
                        <span class="s1">contrast_prod2</span><span class="s2">, </span><span class="s1">names_contrast_prod2</span><span class="s2">, </span><span class="s1">dummy)</span>





<span class="s2">def </span><span class="s1">dummy_1d(x</span><span class="s2">, </span><span class="s1">varname=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">'''dummy variable for id integer groups 
 
    Parameters 
    ---------- 
    x : ndarray, 1d 
        categorical variable, requires integers if varname is None 
    varname : str 
        name of the variable used in labels for category levels 
 
    Returns 
    ------- 
    dummy : ndarray, 2d 
        array of dummy variables, one column for each level of the 
        category (full set) 
    labels : list[str] 
        labels for the columns, i.e. levels of each category 
 
 
    Notes 
    ----- 
    use tools.categorical instead for more more options 
 
    See Also 
    -------- 
    statsmodels.tools.categorical 
 
    Examples 
    -------- 
    &gt;&gt;&gt; x = np.array(['F', 'F', 'M', 'M', 'F', 'F', 'M', 'M', 'F', 'F', 'M', 'M'], 
          dtype='|S1') 
    &gt;&gt;&gt; dummy_1d(x, varname='gender') 
    (array([[1, 0], 
           [1, 0], 
           [0, 1], 
           [0, 1], 
           [1, 0], 
           [1, 0], 
           [0, 1], 
           [0, 1], 
           [1, 0], 
           [1, 0], 
           [0, 1], 
           [0, 1]]), ['gender_F', 'gender_M']) 
 
    '''</span>
    <span class="s2">if </span><span class="s1">varname </span><span class="s2">is None</span><span class="s1">:  </span><span class="s3">#assumes integer</span>
        <span class="s1">labels = [</span><span class="s5">'level_%d' </span><span class="s1">% i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(x.max() + </span><span class="s4">1</span><span class="s1">)]</span>
        <span class="s2">return </span><span class="s1">(x[:</span><span class="s2">,None</span><span class="s1">]==np.arange(x.max()+</span><span class="s4">1</span><span class="s1">)).astype(int)</span><span class="s2">, </span><span class="s1">labels</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">grouplabels = np.unique(x)</span>
        <span class="s1">labels = [varname + </span><span class="s5">'_%s' </span><span class="s1">% str(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">grouplabels]</span>
        <span class="s2">return </span><span class="s1">(x[:</span><span class="s2">,None</span><span class="s1">]==grouplabels).astype(int)</span><span class="s2">, </span><span class="s1">labels</span>


<span class="s2">def </span><span class="s1">dummy_product(d1</span><span class="s2">, </span><span class="s1">d2</span><span class="s2">, </span><span class="s1">method=</span><span class="s5">'full'</span><span class="s1">):</span>
    <span class="s0">'''dummy variable from product of two dummy variables 
 
    Parameters 
    ---------- 
    d1, d2 : ndarray 
        two dummy variables, assumes full set for methods 'drop-last' 
        and 'drop-first' 
    method : {'full', 'drop-last', 'drop-first'} 
        'full' returns the full product, encoding of intersection of 
        categories. 
        The drop methods provide a difference dummy encoding: 
        (constant, main effects, interaction effects). The first or last columns 
        of the dummy variable (i.e. levels) are dropped to get full rank 
        dummy matrix. 
 
    Returns 
    ------- 
    dummy : ndarray 
        dummy variable for product, see method 
 
    '''</span>

    <span class="s2">if </span><span class="s1">method == </span><span class="s5">'full'</span><span class="s1">:</span>
        <span class="s1">dd = (d1[:</span><span class="s2">,</span><span class="s1">:</span><span class="s2">,None</span><span class="s1">]*d2[:</span><span class="s2">,None,</span><span class="s1">:]).reshape(d1.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">method == </span><span class="s5">'drop-last'</span><span class="s1">:  </span><span class="s3">#same as SAS transreg</span>
        <span class="s1">d12rl = dummy_product(d1[:</span><span class="s2">,</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">d2[:</span><span class="s2">,</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">dd = np.column_stack((np.ones(d1.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">int)</span><span class="s2">, </span><span class="s1">d1[:</span><span class="s2">,</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">d2[:</span><span class="s2">,</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span><span class="s1">d12rl))</span>
        <span class="s3">#Note: dtype int should preserve dtype of d1 and d2</span>
    <span class="s2">elif </span><span class="s1">method == </span><span class="s5">'drop-first'</span><span class="s1">:</span>
        <span class="s1">d12r = dummy_product(d1[:</span><span class="s2">,</span><span class="s4">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">d2[:</span><span class="s2">,</span><span class="s4">1</span><span class="s1">:])</span>
        <span class="s1">dd = np.column_stack((np.ones(d1.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">int)</span><span class="s2">, </span><span class="s1">d1[:</span><span class="s2">,</span><span class="s4">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">d2[:</span><span class="s2">,</span><span class="s4">1</span><span class="s1">:]</span><span class="s2">,</span><span class="s1">d12r))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'method not recognized'</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">dd</span>

<span class="s2">def </span><span class="s1">dummy_limits(d):</span>
    <span class="s0">'''start and endpoints of groups in a sorted dummy variable array 
 
    helper function for nested categories 
 
    Examples 
    -------- 
    &gt;&gt;&gt; d1 = np.array([[1, 0, 0], 
                       [1, 0, 0], 
                       [1, 0, 0], 
                       [1, 0, 0], 
                       [0, 1, 0], 
                       [0, 1, 0], 
                       [0, 1, 0], 
                       [0, 1, 0], 
                       [0, 0, 1], 
                       [0, 0, 1], 
                       [0, 0, 1], 
                       [0, 0, 1]]) 
    &gt;&gt;&gt; dummy_limits(d1) 
    (array([0, 4, 8]), array([ 4,  8, 12])) 
 
    get group slices from an array 
 
    &gt;&gt;&gt; [np.arange(d1.shape[0])[b:e] for b,e in zip(*dummy_limits(d1))] 
    [array([0, 1, 2, 3]), array([4, 5, 6, 7]), array([ 8,  9, 10, 11])] 
    &gt;&gt;&gt; [np.arange(d1.shape[0])[b:e] for b,e in zip(*dummy_limits(d1))] 
    [array([0, 1, 2, 3]), array([4, 5, 6, 7]), array([ 8,  9, 10, 11])] 
    '''</span>
    <span class="s1">nobs</span><span class="s2">, </span><span class="s1">nvars = d.shape</span>
    <span class="s1">start1</span><span class="s2">, </span><span class="s1">col1 = np.nonzero(np.diff(d</span><span class="s2">,</span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)==</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">end1</span><span class="s2">, </span><span class="s1">col1_ = np.nonzero(np.diff(d</span><span class="s2">,</span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)==-</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">cc = np.arange(nvars)</span>
    <span class="s3">#print(cc, np.r_[[0], col1], np.r_[col1_, [nvars-1]]</span>
    <span class="s2">if </span><span class="s1">((</span><span class="s2">not </span><span class="s1">(np.r_[[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">col1] == cc).all())</span>
            <span class="s2">or </span><span class="s1">(</span><span class="s2">not </span><span class="s1">(np.r_[col1_</span><span class="s2">, </span><span class="s1">[nvars-</span><span class="s4">1</span><span class="s1">]] == cc).all())):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'dummy variable is not sorted'</span><span class="s1">)</span>

    <span class="s1">start = np.r_[[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">start1+</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">end = np.r_[end1+</span><span class="s4">1</span><span class="s2">, </span><span class="s1">[nobs]]</span>
    <span class="s2">return </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span>



<span class="s2">def </span><span class="s1">dummy_nested(d1</span><span class="s2">, </span><span class="s1">d2</span><span class="s2">, </span><span class="s1">method=</span><span class="s5">'full'</span><span class="s1">):</span>
    <span class="s0">'''unfinished and incomplete mainly copy past dummy_product 
    dummy variable from product of two dummy variables 
 
    Parameters 
    ---------- 
    d1, d2 : ndarray 
        two dummy variables, d2 is assumed to be nested in d1 
        Assumes full set for methods 'drop-last' and 'drop-first'. 
    method : {'full', 'drop-last', 'drop-first'} 
        'full' returns the full product, which in this case is d2. 
        The drop methods provide an effects encoding: 
        (constant, main effects, subgroup effects). The first or last columns 
        of the dummy variable (i.e. levels) are dropped to get full rank 
        encoding. 
 
    Returns 
    ------- 
    dummy : ndarray 
        dummy variable for product, see method 
 
    '''</span>
    <span class="s2">if </span><span class="s1">method == </span><span class="s5">'full'</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">d2</span>

    <span class="s1">start1</span><span class="s2">, </span><span class="s1">end1 = dummy_limits(d1)</span>
    <span class="s1">start2</span><span class="s2">, </span><span class="s1">end2 = dummy_limits(d2)</span>
    <span class="s1">first = np.in1d(start2</span><span class="s2">, </span><span class="s1">start1)</span>
    <span class="s1">last = np.in1d(end2</span><span class="s2">, </span><span class="s1">end1)</span>
    <span class="s1">equal = (first == last)</span>
    <span class="s1">col_dropf = ~first*~equal</span>
    <span class="s1">col_dropl = ~last*~equal</span>


    <span class="s2">if </span><span class="s1">method == </span><span class="s5">'drop-last'</span><span class="s1">:</span>
        <span class="s1">d12rl = dummy_product(d1[:</span><span class="s2">,</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">d2[:</span><span class="s2">,</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">dd = np.column_stack((np.ones(d1.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">int)</span><span class="s2">, </span><span class="s1">d1[:</span><span class="s2">,</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">d2[:</span><span class="s2">,</span><span class="s1">col_dropl]))</span>
        <span class="s3">#Note: dtype int should preserve dtype of d1 and d2</span>
    <span class="s2">elif </span><span class="s1">method == </span><span class="s5">'drop-first'</span><span class="s1">:</span>
        <span class="s1">d12r = dummy_product(d1[:</span><span class="s2">,</span><span class="s4">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">d2[:</span><span class="s2">,</span><span class="s4">1</span><span class="s1">:])</span>
        <span class="s1">dd = np.column_stack((np.ones(d1.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">int)</span><span class="s2">, </span><span class="s1">d1[:</span><span class="s2">,</span><span class="s4">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">d2[:</span><span class="s2">,</span><span class="s1">col_dropf]))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'method not recognized'</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">dd</span><span class="s2">, </span><span class="s1">col_dropf</span><span class="s2">, </span><span class="s1">col_dropl</span>


<span class="s2">class </span><span class="s1">DummyTransform:</span>
    <span class="s0">'''Conversion between full rank dummy encodings 
 
 
    y = X b + u 
    b = C a 
    a = C^{-1} b 
 
    y = X C a + u 
 
    define Z = X C, then 
 
    y = Z a + u 
 
    contrasts: 
 
    R_b b = r 
 
    R_a a = R_b C a = r 
 
    where R_a = R_b C 
 
    Here C is the transform matrix, with dot_left and dot_right as the main 
    methods, and the same for the inverse transform matrix, C^{-1} 
 
    Note: 
     - The class was mainly written to keep left and right straight. 
     - No checking is done. 
     - not sure yet if method names make sense 
 
 
    '''</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">d1</span><span class="s2">, </span><span class="s1">d2):</span>
        <span class="s0">'''C such that d1 C = d2, with d1 = X, d2 = Z 
 
        should be (x, z) in arguments ? 
        '''</span>
        <span class="s1">self.transf_matrix = np.linalg.lstsq(d1</span><span class="s2">, </span><span class="s1">d2</span><span class="s2">, </span><span class="s1">rcond=-</span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">self.invtransf_matrix = np.linalg.lstsq(d2</span><span class="s2">, </span><span class="s1">d1</span><span class="s2">, </span><span class="s1">rcond=-</span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">dot_left(self</span><span class="s2">, </span><span class="s1">a):</span>
        <span class="s0">''' b = C a 
        '''</span>
        <span class="s2">return </span><span class="s1">np.dot(self.transf_matrix</span><span class="s2">, </span><span class="s1">a)</span>

    <span class="s2">def </span><span class="s1">dot_right(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s0">''' z = x C 
        '''</span>
        <span class="s2">return </span><span class="s1">np.dot(x</span><span class="s2">, </span><span class="s1">self.transf_matrix)</span>

    <span class="s2">def </span><span class="s1">inv_dot_left(self</span><span class="s2">, </span><span class="s1">b):</span>
        <span class="s0">''' a = C^{-1} b 
        '''</span>
        <span class="s2">return </span><span class="s1">np.dot(self.invtransf_matrix</span><span class="s2">, </span><span class="s1">b)</span>

    <span class="s2">def </span><span class="s1">inv_dot_right(self</span><span class="s2">, </span><span class="s1">z):</span>
        <span class="s0">''' x = z C^{-1} 
        '''</span>
        <span class="s2">return </span><span class="s1">np.dot(z</span><span class="s2">, </span><span class="s1">self.invtransf_matrix)</span>





<span class="s2">def </span><span class="s1">groupmean_d(x</span><span class="s2">, </span><span class="s1">d):</span>
    <span class="s0">'''groupmeans using dummy variables 
 
    Parameters 
    ---------- 
    x : array_like, ndim 
        data array, tested for 1,2 and 3 dimensions 
    d : ndarray, 1d 
        dummy variable, needs to have the same length 
        as x in axis 0. 
 
    Returns 
    ------- 
    groupmeans : ndarray, ndim-1 
        means for each group along axis 0, the levels 
        of the groups are the last axis 
 
    Notes 
    ----- 
    This will be memory intensive if there are many levels 
    in the categorical variable, i.e. many columns in the 
    dummy variable. In this case it is recommended to use 
    a more efficient version. 
 
    '''</span>
    <span class="s1">x = np.asarray(x)</span>
<span class="s3">##    if x.ndim == 1:</span>
<span class="s3">##        nvars = 1</span>
<span class="s3">##    else:</span>
    <span class="s1">nvars = x.ndim + </span><span class="s4">1</span>
    <span class="s1">sli = [slice(</span><span class="s2">None</span><span class="s1">)] + [</span><span class="s2">None</span><span class="s1">]*(nvars-</span><span class="s4">2</span><span class="s1">) + [slice(</span><span class="s2">None</span><span class="s1">)]</span>
    <span class="s2">return </span><span class="s1">(x[...</span><span class="s2">,None</span><span class="s1">] * d[sli]).sum(</span><span class="s4">0</span><span class="s1">)*</span><span class="s4">1.</span><span class="s1">/d.sum(</span><span class="s4">0</span><span class="s1">)</span>



<span class="s2">class </span><span class="s1">TwoWay:</span>
    <span class="s0">'''a wrapper class for two way anova type of analysis with OLS 
 
 
    currently mainly to bring things together 
 
    Notes 
    ----- 
    unclear: adding multiple test might assume block design or orthogonality 
 
    This estimates the full dummy version with OLS. 
    The drop first dummy representation can be recovered through the 
    transform method. 
 
    TODO: add more methods, tests, pairwise, multiple, marginal effects 
    try out what can be added for userfriendly access. 
 
    missing: ANOVA table 
 
    '''</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">endog</span><span class="s2">, </span><span class="s1">factor1</span><span class="s2">, </span><span class="s1">factor2</span><span class="s2">, </span><span class="s1">varnames=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self.nobs = factor1.shape[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">varnames </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">vname1 = </span><span class="s5">'a'</span>
            <span class="s1">vname2 = </span><span class="s5">'b'</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">vname1</span><span class="s2">, </span><span class="s1">vname1 = varnames</span>

        <span class="s1">self.d1</span><span class="s2">, </span><span class="s1">self.d1_labels = d1</span><span class="s2">, </span><span class="s1">d1_labels = dummy_1d(factor1</span><span class="s2">, </span><span class="s1">vname1)</span>
        <span class="s1">self.d2</span><span class="s2">, </span><span class="s1">self.d2_labels = d2</span><span class="s2">, </span><span class="s1">d2_labels = dummy_1d(factor2</span><span class="s2">, </span><span class="s1">vname2)</span>
        <span class="s1">self.nlevel1 = nlevel1 = d1.shape[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">self.nlevel2 = nlevel2 = d2.shape[</span><span class="s4">1</span><span class="s1">]</span>


        <span class="s3">#get product dummies</span>
        <span class="s1">res = contrast_product(d1_labels</span><span class="s2">, </span><span class="s1">d2_labels)</span>
        <span class="s1">prodlab</span><span class="s2">, </span><span class="s1">C1</span><span class="s2">, </span><span class="s1">C1lab</span><span class="s2">, </span><span class="s1">C2</span><span class="s2">, </span><span class="s1">C2lab</span><span class="s2">, </span><span class="s1">_ = res</span>
        <span class="s1">self.prod_label</span><span class="s2">, </span><span class="s1">self.C1</span><span class="s2">, </span><span class="s1">self.C1_label</span><span class="s2">, </span><span class="s1">self.C2</span><span class="s2">, </span><span class="s1">self.C2_label</span><span class="s2">, </span><span class="s1">_ = res</span>
        <span class="s1">dp_full = dummy_product(d1</span><span class="s2">, </span><span class="s1">d2</span><span class="s2">, </span><span class="s1">method=</span><span class="s5">'full'</span><span class="s1">)</span>
        <span class="s1">dp_dropf = dummy_product(d1</span><span class="s2">, </span><span class="s1">d2</span><span class="s2">, </span><span class="s1">method=</span><span class="s5">'drop-first'</span><span class="s1">)</span>
        <span class="s1">self.transform = DummyTransform(dp_full</span><span class="s2">, </span><span class="s1">dp_dropf)</span>

        <span class="s3">#estimate the model</span>
        <span class="s1">self.nvars = dp_full.shape[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">self.exog = dp_full</span>
        <span class="s1">self.resols = sm.OLS(endog</span><span class="s2">, </span><span class="s1">dp_full).fit()</span>
        <span class="s1">self.params = self.resols.params</span>

        <span class="s3">#get transformed parameters, (constant, main, interaction effect)</span>
        <span class="s1">self.params_dropf = self.transform.inv_dot_left(self.params)</span>
        <span class="s1">self.start_interaction = </span><span class="s4">1 </span><span class="s1">+ (nlevel1 - </span><span class="s4">1</span><span class="s1">) + (nlevel2 - </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.n_interaction = self.nvars - self.start_interaction</span>

    <span class="s3">#convert to cached property</span>
    <span class="s2">def </span><span class="s1">r_nointer(self):</span>
        <span class="s0">'''contrast/restriction matrix for no interaction 
        '''</span>
        <span class="s1">nia = self.n_interaction</span>
        <span class="s1">R_nointer = np.hstack((np.zeros((nia</span><span class="s2">, </span><span class="s1">self.nvars-nia))</span><span class="s2">, </span><span class="s1">np.eye(nia)))</span>
        <span class="s3">#inter_direct = resols_full_dropf.tval[-nia:]</span>
        <span class="s1">R_nointer_transf = self.transform.inv_dot_right(R_nointer)</span>
        <span class="s1">self.R_nointer_transf = R_nointer_transf</span>
        <span class="s2">return </span><span class="s1">R_nointer_transf</span>

    <span class="s2">def </span><span class="s1">ttest_interaction(self):</span>
        <span class="s0">'''ttests for no-interaction terms are zero 
        '''</span>
        <span class="s3">#use self.r_nointer instead</span>
        <span class="s1">nia = self.n_interaction</span>
        <span class="s1">R_nointer = np.hstack((np.zeros((nia</span><span class="s2">, </span><span class="s1">self.nvars-nia))</span><span class="s2">, </span><span class="s1">np.eye(nia)))</span>
        <span class="s3">#inter_direct = resols_full_dropf.tval[-nia:]</span>
        <span class="s1">R_nointer_transf = self.transform.inv_dot_right(R_nointer)</span>
        <span class="s1">self.R_nointer_transf = R_nointer_transf</span>
        <span class="s1">t_res = self.resols.t_test(R_nointer_transf)</span>
        <span class="s2">return </span><span class="s1">t_res</span>

    <span class="s2">def </span><span class="s1">ftest_interaction(self):</span>
        <span class="s0">'''ttests for no-interaction terms are zero 
        '''</span>
        <span class="s1">R_nointer_transf = self.r_nointer()</span>
        <span class="s2">return </span><span class="s1">self.resols.f_test(R_nointer_transf)</span>

    <span class="s2">def </span><span class="s1">ttest_conditional_effect(self</span><span class="s2">, </span><span class="s1">factorind):</span>
        <span class="s2">if </span><span class="s1">factorind == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.resols.t_test(self.C1)</span><span class="s2">, </span><span class="s1">self.C1_label</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.resols.t_test(self.C2)</span><span class="s2">, </span><span class="s1">self.C2_label</span>

    <span class="s2">def </span><span class="s1">summary_coeff(self):</span>
        <span class="s2">from </span><span class="s1">statsmodels.iolib </span><span class="s2">import </span><span class="s1">SimpleTable</span>
        <span class="s1">params_arr = self.params.reshape(self.nlevel1</span><span class="s2">, </span><span class="s1">self.nlevel2)</span>
        <span class="s1">stubs = self.d1_labels</span>
        <span class="s1">headers = self.d2_labels</span>
        <span class="s1">title = </span><span class="s5">'Estimated Coefficients by factors'</span>
        <span class="s1">table_fmt = dict(</span>
            <span class="s1">data_fmts = [</span><span class="s5">&quot;%#10.4g&quot;</span><span class="s1">]*self.nlevel2)</span>
        <span class="s2">return </span><span class="s1">SimpleTable(params_arr</span><span class="s2">, </span><span class="s1">headers</span><span class="s2">, </span><span class="s1">stubs</span><span class="s2">, </span><span class="s1">title=title</span><span class="s2">,</span>
                           <span class="s1">txt_fmt=table_fmt)</span>


<span class="s3"># --------------- tests</span>
<span class="s3"># TODO: several tests still missing, several are in the example with print</span>

<span class="s2">class </span><span class="s1">TestContrastTools:</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self.v1name = [</span><span class="s5">'a0'</span><span class="s2">, </span><span class="s5">'a1'</span><span class="s2">, </span><span class="s5">'a2'</span><span class="s1">]</span>
        <span class="s1">self.v2name = [</span><span class="s5">'b0'</span><span class="s2">, </span><span class="s5">'b1'</span><span class="s1">]</span>
        <span class="s1">self.d1 = np.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]])</span>

    <span class="s2">def </span><span class="s1">test_dummy_1d(self):</span>
        <span class="s1">x = np.array([</span><span class="s5">'F'</span><span class="s2">, </span><span class="s5">'F'</span><span class="s2">, </span><span class="s5">'M'</span><span class="s2">, </span><span class="s5">'M'</span><span class="s2">, </span><span class="s5">'F'</span><span class="s2">, </span><span class="s5">'F'</span><span class="s2">, </span><span class="s5">'M'</span><span class="s2">, </span><span class="s5">'M'</span><span class="s2">, </span><span class="s5">'F'</span><span class="s2">, </span><span class="s5">'F'</span><span class="s2">, </span><span class="s5">'M'</span><span class="s2">, </span><span class="s5">'M'</span><span class="s1">]</span><span class="s2">,</span>
              <span class="s1">dtype=</span><span class="s5">'|S1'</span><span class="s1">)</span>
        <span class="s1">d</span><span class="s2">, </span><span class="s1">labels = (np.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                               <span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                               <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                               <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                               <span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                               <span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                               <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                               <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                               <span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                               <span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                               <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                               <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]])</span><span class="s2">, </span><span class="s1">[</span><span class="s5">'gender_F'</span><span class="s2">, </span><span class="s5">'gender_M'</span><span class="s1">])</span>
        <span class="s1">res_d</span><span class="s2">, </span><span class="s1">res_labels = dummy_1d(x</span><span class="s2">, </span><span class="s1">varname=</span><span class="s5">'gender'</span><span class="s1">)</span>
        <span class="s1">assert_equal(res_d</span><span class="s2">, </span><span class="s1">d)</span>
        <span class="s1">assert_equal(res_labels</span><span class="s2">, </span><span class="s1">labels)</span>

    <span class="s2">def </span><span class="s1">test_contrast_product(self):</span>
        <span class="s1">res_cp = contrast_product(self.v1name</span><span class="s2">, </span><span class="s1">self.v2name)</span>
        <span class="s1">res_t = [</span><span class="s4">0</span><span class="s1">]*</span><span class="s4">6</span>
        <span class="s1">res_t[</span><span class="s4">0</span><span class="s1">] = [</span><span class="s5">'a0_b0'</span><span class="s2">, </span><span class="s5">'a0_b1'</span><span class="s2">, </span><span class="s5">'a1_b0'</span><span class="s2">, </span><span class="s5">'a1_b1'</span><span class="s2">, </span><span class="s5">'a2_b0'</span><span class="s2">, </span><span class="s5">'a2_b1'</span><span class="s1">]</span>
        <span class="s1">res_t[</span><span class="s4">1</span><span class="s1">] = np.array([[-</span><span class="s4">1.</span><span class="s2">,  </span><span class="s4">0.</span><span class="s2">,  </span><span class="s4">1.</span><span class="s2">,  </span><span class="s4">0.</span><span class="s2">,  </span><span class="s4">0.</span><span class="s2">,  </span><span class="s4">0.</span><span class="s1">]</span><span class="s2">,</span>
                           <span class="s1">[ </span><span class="s4">0.</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.</span><span class="s2">,  </span><span class="s4">0.</span><span class="s2">,  </span><span class="s4">1.</span><span class="s2">,  </span><span class="s4">0.</span><span class="s2">,  </span><span class="s4">0.</span><span class="s1">]</span><span class="s2">,</span>
                           <span class="s1">[-</span><span class="s4">1.</span><span class="s2">,  </span><span class="s4">0.</span><span class="s2">,  </span><span class="s4">0.</span><span class="s2">,  </span><span class="s4">0.</span><span class="s2">,  </span><span class="s4">1.</span><span class="s2">,  </span><span class="s4">0.</span><span class="s1">]</span><span class="s2">,</span>
                           <span class="s1">[ </span><span class="s4">0.</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.</span><span class="s2">,  </span><span class="s4">0.</span><span class="s2">,  </span><span class="s4">0.</span><span class="s2">,  </span><span class="s4">0.</span><span class="s2">,  </span><span class="s4">1.</span><span class="s1">]])</span>
        <span class="s1">res_t[</span><span class="s4">2</span><span class="s1">] = [</span><span class="s5">'a1_b0-a0_b0'</span><span class="s2">, </span><span class="s5">'a1_b1-a0_b1'</span><span class="s2">, </span><span class="s5">'a2_b0-a0_b0'</span><span class="s2">, </span><span class="s5">'a2_b1-a0_b1'</span><span class="s1">]</span>
        <span class="s1">res_t[</span><span class="s4">3</span><span class="s1">] =  np.array([[-</span><span class="s4">1.</span><span class="s2">,  </span><span class="s4">1.</span><span class="s2">,  </span><span class="s4">0.</span><span class="s2">,  </span><span class="s4">0.</span><span class="s2">,  </span><span class="s4">0.</span><span class="s2">,  </span><span class="s4">0.</span><span class="s1">]</span><span class="s2">,</span>
                           <span class="s1">[ </span><span class="s4">0.</span><span class="s2">,  </span><span class="s4">0.</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.</span><span class="s2">,  </span><span class="s4">1.</span><span class="s2">,  </span><span class="s4">0.</span><span class="s2">,  </span><span class="s4">0.</span><span class="s1">]</span><span class="s2">,</span>
                           <span class="s1">[ </span><span class="s4">0.</span><span class="s2">,  </span><span class="s4">0.</span><span class="s2">,  </span><span class="s4">0.</span><span class="s2">,  </span><span class="s4">0.</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.</span><span class="s2">,  </span><span class="s4">1.</span><span class="s1">]])</span>
        <span class="s1">res_t[</span><span class="s4">4</span><span class="s1">] = [</span><span class="s5">'a0_b1-a0_b0'</span><span class="s2">, </span><span class="s5">'a1_b1-a1_b0'</span><span class="s2">, </span><span class="s5">'a2_b1-a2_b0'</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">5</span><span class="s1">):</span>
            <span class="s1">np.testing.assert_equal(res_cp[ii]</span><span class="s2">, </span><span class="s1">res_t[ii]</span><span class="s2">, </span><span class="s1">err_msg=str(ii))</span>

    <span class="s2">def </span><span class="s1">test_dummy_limits(self):</span>
        <span class="s1">b</span><span class="s2">,</span><span class="s1">e = dummy_limits(self.d1)</span>
        <span class="s1">assert_equal(b</span><span class="s2">, </span><span class="s1">np.array([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">8</span><span class="s1">]))</span>
        <span class="s1">assert_equal(e</span><span class="s2">, </span><span class="s1">np.array([ </span><span class="s4">4</span><span class="s2">,  </span><span class="s4">8</span><span class="s2">, </span><span class="s4">12</span><span class="s1">]))</span>




<span class="s2">if </span><span class="s1">__name__ == </span><span class="s5">'__main__'</span><span class="s1">:</span>
    <span class="s1">tt = TestContrastTools()</span>
    <span class="s1">tt.test_contrast_product()</span>
    <span class="s1">tt.test_dummy_1d()</span>
    <span class="s1">tt.test_dummy_limits()</span>

    <span class="s2">import </span><span class="s1">statsmodels.api </span><span class="s2">as </span><span class="s1">sm</span>

    <span class="s1">examples = [</span><span class="s5">'small'</span><span class="s2">, </span><span class="s5">'large'</span><span class="s2">, None</span><span class="s1">][</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s1">v1name = [</span><span class="s5">'a0'</span><span class="s2">, </span><span class="s5">'a1'</span><span class="s2">, </span><span class="s5">'a2'</span><span class="s1">]</span>
    <span class="s1">v2name = [</span><span class="s5">'b0'</span><span class="s2">, </span><span class="s5">'b1'</span><span class="s1">]</span>
    <span class="s1">res_cp = contrast_product(v1name</span><span class="s2">, </span><span class="s1">v2name)</span>
    <span class="s1">print(res_cp)</span>

    <span class="s1">y = np.arange(</span><span class="s4">12</span><span class="s1">)</span>
    <span class="s1">x1 = np.arange(</span><span class="s4">12</span><span class="s1">)//</span><span class="s4">4</span>
    <span class="s1">x2 = np.arange(</span><span class="s4">12</span><span class="s1">)//</span><span class="s4">2 </span><span class="s1">% </span><span class="s4">2</span>

    <span class="s2">if </span><span class="s5">'small' </span><span class="s2">in </span><span class="s1">examples:</span>
        <span class="s1">d1</span><span class="s2">, </span><span class="s1">d1_labels = dummy_1d(x1)</span>
        <span class="s1">d2</span><span class="s2">, </span><span class="s1">d2_labels = dummy_1d(x2)</span>


    <span class="s2">if </span><span class="s5">'large' </span><span class="s2">in </span><span class="s1">examples:</span>
        <span class="s1">x1 = np.repeat(x1</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">x2 = np.repeat(x2</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s1">nobs = x1.shape[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">d1</span><span class="s2">, </span><span class="s1">d1_labels = dummy_1d(x1)</span>
    <span class="s1">d2</span><span class="s2">, </span><span class="s1">d2_labels = dummy_1d(x2)</span>

    <span class="s1">dd_full = dummy_product(d1</span><span class="s2">, </span><span class="s1">d2</span><span class="s2">, </span><span class="s1">method=</span><span class="s5">'full'</span><span class="s1">)</span>
    <span class="s1">dd_dropl = dummy_product(d1</span><span class="s2">, </span><span class="s1">d2</span><span class="s2">, </span><span class="s1">method=</span><span class="s5">'drop-last'</span><span class="s1">)</span>
    <span class="s1">dd_dropf = dummy_product(d1</span><span class="s2">, </span><span class="s1">d2</span><span class="s2">, </span><span class="s1">method=</span><span class="s5">'drop-first'</span><span class="s1">)</span>

    <span class="s3">#Note: full parameterization of dummies is orthogonal</span>
    <span class="s3">#np.eye(6)*10 in &quot;large&quot; example</span>
    <span class="s1">print((np.dot(dd_full.T</span><span class="s2">, </span><span class="s1">dd_full) == np.diag(dd_full.sum(</span><span class="s4">0</span><span class="s1">))).all())</span>

    <span class="s3">#check that transforms work</span>
    <span class="s3">#generate 3 data sets with the 3 different parameterizations</span>

    <span class="s1">effect_size = [</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.01</span><span class="s1">][</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">noise_scale = [</span><span class="s4">0.001</span><span class="s2">, </span><span class="s4">0.1</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">noise = noise_scale * np.random.randn(nobs)</span>
    <span class="s1">beta = effect_size * np.arange(</span><span class="s4">1</span><span class="s2">,</span><span class="s4">7</span><span class="s1">)</span>
    <span class="s1">ydata_full = (dd_full * beta).sum(</span><span class="s4">1</span><span class="s1">) + noise</span>
    <span class="s1">ydata_dropl = (dd_dropl * beta).sum(</span><span class="s4">1</span><span class="s1">) + noise</span>
    <span class="s1">ydata_dropf = (dd_dropf * beta).sum(</span><span class="s4">1</span><span class="s1">) + noise</span>

    <span class="s1">resols_full_full = sm.OLS(ydata_full</span><span class="s2">, </span><span class="s1">dd_full).fit()</span>
    <span class="s1">resols_full_dropf = sm.OLS(ydata_full</span><span class="s2">, </span><span class="s1">dd_dropf).fit()</span>
    <span class="s1">params_f_f = resols_full_full.params</span>
    <span class="s1">params_f_df = resols_full_dropf.params</span>

    <span class="s1">resols_dropf_full = sm.OLS(ydata_dropf</span><span class="s2">, </span><span class="s1">dd_full).fit()</span>
    <span class="s1">resols_dropf_dropf = sm.OLS(ydata_dropf</span><span class="s2">, </span><span class="s1">dd_dropf).fit()</span>
    <span class="s1">params_df_f = resols_dropf_full.params</span>
    <span class="s1">params_df_df = resols_dropf_dropf.params</span>


    <span class="s1">tr_of = np.linalg.lstsq(dd_dropf</span><span class="s2">, </span><span class="s1">dd_full</span><span class="s2">, </span><span class="s1">rcond=-</span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">tr_fo = np.linalg.lstsq(dd_full</span><span class="s2">, </span><span class="s1">dd_dropf</span><span class="s2">, </span><span class="s1">rcond=-</span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">print(np.dot(tr_fo</span><span class="s2">, </span><span class="s1">params_df_df) - params_df_f)</span>
    <span class="s1">print(np.dot(tr_of</span><span class="s2">, </span><span class="s1">params_f_f) - params_f_df)</span>

    <span class="s1">transf_f_df = DummyTransform(dd_full</span><span class="s2">, </span><span class="s1">dd_dropf)</span>
    <span class="s1">print(np.max(np.abs((dd_full - transf_f_df.inv_dot_right(dd_dropf)))))</span>
    <span class="s1">print(np.max(np.abs((dd_dropf - transf_f_df.dot_right(dd_full)))))</span>
    <span class="s1">print(np.max(np.abs((params_df_df</span>
                         <span class="s1">- transf_f_df.inv_dot_left(params_df_f)))))</span>
    <span class="s1">np.max(np.abs((params_f_df</span>
                         <span class="s1">- transf_f_df.inv_dot_left(params_f_f))))</span>

    <span class="s1">prodlab</span><span class="s2">, </span><span class="s1">C1</span><span class="s2">, </span><span class="s1">C1lab</span><span class="s2">, </span><span class="s1">C2</span><span class="s2">, </span><span class="s1">C2lab</span><span class="s2">,</span><span class="s1">_ = contrast_product(v1name</span><span class="s2">, </span><span class="s1">v2name)</span>

    <span class="s1">print(</span><span class="s5">'</span><span class="s2">\n</span><span class="s5">tvalues for no effect of factor 1'</span><span class="s1">)</span>
    <span class="s1">print(</span><span class="s5">'each test is conditional on a level of factor 2'</span><span class="s1">)</span>
    <span class="s1">print(C1lab)</span>
    <span class="s1">print(resols_dropf_full.t_test(C1).tvalue)</span>

    <span class="s1">print(</span><span class="s5">'</span><span class="s2">\n</span><span class="s5">tvalues for no effect of factor 2'</span><span class="s1">)</span>
    <span class="s1">print(</span><span class="s5">'each test is conditional on a level of factor 1'</span><span class="s1">)</span>
    <span class="s1">print(C2lab)</span>
    <span class="s1">print(resols_dropf_full.t_test(C2).tvalue)</span>

    <span class="s3">#covariance matrix of restrictions C2, note: orthogonal</span>
    <span class="s1">resols_dropf_full.cov_params(C2)</span>

    <span class="s3">#testing for no interaction effect</span>
    <span class="s1">R_noint = np.hstack((np.zeros((</span><span class="s4">2</span><span class="s2">,</span><span class="s4">4</span><span class="s1">))</span><span class="s2">, </span><span class="s1">np.eye(</span><span class="s4">2</span><span class="s1">)))</span>
    <span class="s1">inter_direct = resols_full_dropf.tvalues[-</span><span class="s4">2</span><span class="s1">:]</span>
    <span class="s1">inter_transf = resols_full_full.t_test(transf_f_df.inv_dot_right(R_noint)).tvalue</span>
    <span class="s1">print(np.max(np.abs((inter_direct - inter_transf))))</span>

    <span class="s3">#now with class version</span>
    <span class="s1">tw = TwoWay(ydata_dropf</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2)</span>
    <span class="s1">print(tw.ttest_interaction().tvalue)</span>
    <span class="s1">print(tw.ttest_interaction().pvalue)</span>
    <span class="s1">print(tw.ftest_interaction().fvalue)</span>
    <span class="s1">print(tw.ftest_interaction().pvalue)</span>
    <span class="s1">print(tw.ttest_conditional_effect(</span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">].tvalue)</span>
    <span class="s1">print(tw.ttest_conditional_effect(</span><span class="s4">2</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">].tvalue)</span>
    <span class="s1">print(tw.summary_coeff())</span>

















<span class="s5">''' documentation for early examples while developing - some have changed already 
&gt;&gt;&gt; y = np.arange(12) 
&gt;&gt;&gt; y 
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11]) 
&gt;&gt;&gt; x1 = np.arange(12)//4 
&gt;&gt;&gt; x1 
array([0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2]) 
&gt;&gt;&gt; x2 = np.arange(12)//2%2 
&gt;&gt;&gt; x2 
array([0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1]) 
 
&gt;&gt;&gt; d1 = dummy_1d(x1) 
&gt;&gt;&gt; d1 
array([[1, 0, 0], 
       [1, 0, 0], 
       [1, 0, 0], 
       [1, 0, 0], 
       [0, 1, 0], 
       [0, 1, 0], 
       [0, 1, 0], 
       [0, 1, 0], 
       [0, 0, 1], 
       [0, 0, 1], 
       [0, 0, 1], 
       [0, 0, 1]]) 
 
&gt;&gt;&gt; d2 = dummy_1d(x2) 
&gt;&gt;&gt; d2 
array([[1, 0], 
       [1, 0], 
       [0, 1], 
       [0, 1], 
       [1, 0], 
       [1, 0], 
       [0, 1], 
       [0, 1], 
       [1, 0], 
       [1, 0], 
       [0, 1], 
       [0, 1]]) 
 
&gt;&gt;&gt; d12 = dummy_product(d1, d2) 
&gt;&gt;&gt; d12 
array([[1, 0, 0, 0, 0, 0], 
       [1, 0, 0, 0, 0, 0], 
       [0, 1, 0, 0, 0, 0], 
       [0, 1, 0, 0, 0, 0], 
       [0, 0, 1, 0, 0, 0], 
       [0, 0, 1, 0, 0, 0], 
       [0, 0, 0, 1, 0, 0], 
       [0, 0, 0, 1, 0, 0], 
       [0, 0, 0, 0, 1, 0], 
       [0, 0, 0, 0, 1, 0], 
       [0, 0, 0, 0, 0, 1], 
       [0, 0, 0, 0, 0, 1]]) 
 
 
&gt;&gt;&gt; d12rl = dummy_product(d1[:,:-1], d2[:,:-1]) 
&gt;&gt;&gt; np.column_stack((np.ones(d1.shape[0]), d1[:,:-1], d2[:,:-1],d12rl)) 
array([[ 1.,  1.,  0.,  1.,  1.,  0.], 
       [ 1.,  1.,  0.,  1.,  1.,  0.], 
       [ 1.,  1.,  0.,  0.,  0.,  0.], 
       [ 1.,  1.,  0.,  0.,  0.,  0.], 
       [ 1.,  0.,  1.,  1.,  0.,  1.], 
       [ 1.,  0.,  1.,  1.,  0.,  1.], 
       [ 1.,  0.,  1.,  0.,  0.,  0.], 
       [ 1.,  0.,  1.,  0.,  0.,  0.], 
       [ 1.,  0.,  0.,  1.,  0.,  0.], 
       [ 1.,  0.,  0.,  1.,  0.,  0.], 
       [ 1.,  0.,  0.,  0.,  0.,  0.], 
       [ 1.,  0.,  0.,  0.,  0.,  0.]]) 
'''</span>




<span class="s3">#nprod = ['%s_%s' % (i,j) for i in ['a0', 'a1', 'a2'] for j in ['b0', 'b1']]</span>
<span class="s3">#&gt;&gt;&gt; [''.join(['%s%s' % (signstr(c),v) for c,v in zip(row, nprod) if c != 0])</span>
<span class="s3">#     for row in np.kron(dd[1:], np.eye(2))]</span>



<span class="s5">''' 
&gt;&gt;&gt; nprod = ['%s_%s' % (i,j) for i in ['a0', 'a1', 'a2'] for j in ['b0', 'b1']] 
&gt;&gt;&gt; nprod 
['a0_b0', 'a0_b1', 'a1_b0', 'a1_b1', 'a2_b0', 'a2_b1'] 
&gt;&gt;&gt; [''.join(['%s%s' % (signstr(c),v) for c,v in zip(row, nprod) if c != 0]) for row in np.kron(dd[1:], np.eye(2))] 
['-a0b0+a1b0', '-a0b1+a1b1', '-a0b0+a2b0', '-a0b1+a2b1'] 
&gt;&gt;&gt; [''.join(['%s%s' % (signstr(c),v) for c,v in zip(row, nprod)[::-1] if c != 0]) for row in np.kron(dd[1:], np.eye(2))] 
['+a1_b0-a0_b0', '+a1_b1-a0_b1', '+a2_b0-a0_b0', '+a2_b1-a0_b1'] 
 
&gt;&gt;&gt; np.r_[[[1,0,0,0,0]],contrast_all_one(5)] 
array([[ 1.,  0.,  0.,  0.,  0.], 
       [ 1., -1.,  0.,  0.,  0.], 
       [ 1.,  0., -1.,  0.,  0.], 
       [ 1.,  0.,  0., -1.,  0.], 
       [ 1.,  0.,  0.,  0., -1.]]) 
 
&gt;&gt;&gt; idxprod = [(i,j) for i in range(3) for j in range(2)] 
&gt;&gt;&gt; idxprod 
[(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)] 
&gt;&gt;&gt; np.array(idxprod).reshape(2,3,2,order='F')[:,:,0] 
array([[0, 1, 2], 
       [0, 1, 2]]) 
&gt;&gt;&gt; np.array(idxprod).reshape(2,3,2,order='F')[:,:,1] 
array([[0, 0, 0], 
       [1, 1, 1]]) 
&gt;&gt;&gt; dd3_ = np.r_[[[0,0,0]],contrast_all_one(3)] 
 
 
 
pairwise contrasts and reparameterization 
 
dd = np.r_[[[1,0,0,0,0]],-contrast_all_one(5)] 
&gt;&gt;&gt; dd 
array([[ 1.,  0.,  0.,  0.,  0.], 
       [-1.,  1.,  0.,  0.,  0.], 
       [-1.,  0.,  1.,  0.,  0.], 
       [-1.,  0.,  0.,  1.,  0.], 
       [-1.,  0.,  0.,  0.,  1.]]) 
&gt;&gt;&gt; np.dot(dd.T, np.arange(5)) 
array([-10.,   1.,   2.,   3.,   4.]) 
&gt;&gt;&gt; np.round(np.linalg.inv(dd.T)).astype(int) 
array([[1, 1, 1, 1, 1], 
       [0, 1, 0, 0, 0], 
       [0, 0, 1, 0, 0], 
       [0, 0, 0, 1, 0], 
       [0, 0, 0, 0, 1]]) 
&gt;&gt;&gt; np.round(np.linalg.inv(dd)).astype(int) 
array([[1, 0, 0, 0, 0], 
       [1, 1, 0, 0, 0], 
       [1, 0, 1, 0, 0], 
       [1, 0, 0, 1, 0], 
       [1, 0, 0, 0, 1]]) 
&gt;&gt;&gt; dd 
array([[ 1.,  0.,  0.,  0.,  0.], 
       [-1.,  1.,  0.,  0.,  0.], 
       [-1.,  0.,  1.,  0.,  0.], 
       [-1.,  0.,  0.,  1.,  0.], 
       [-1.,  0.,  0.,  0.,  1.]]) 
&gt;&gt;&gt; ddinv=np.round(np.linalg.inv(dd.T)).astype(int) 
&gt;&gt;&gt; np.dot(ddinv, np.arange(5)) 
array([10,  1,  2,  3,  4]) 
&gt;&gt;&gt; np.dot(dd, np.arange(5)) 
array([ 0.,  1.,  2.,  3.,  4.]) 
&gt;&gt;&gt; np.dot(dd, 5+np.arange(5)) 
array([ 5.,  1.,  2.,  3.,  4.]) 
&gt;&gt;&gt; ddinv2 = np.round(np.linalg.inv(dd)).astype(int) 
&gt;&gt;&gt; np.dot(ddinv2, np.arange(5)) 
array([0, 1, 2, 3, 4]) 
&gt;&gt;&gt; np.dot(ddinv2, 5+np.arange(5)) 
array([ 5, 11, 12, 13, 14]) 
&gt;&gt;&gt; np.dot(ddinv2, [5, 0, 0 , 1, 2]) 
array([5, 5, 5, 6, 7]) 
&gt;&gt;&gt; np.dot(ddinv2, dd) 
array([[ 1.,  0.,  0.,  0.,  0.], 
       [ 0.,  1.,  0.,  0.,  0.], 
       [ 0.,  0.,  1.,  0.,  0.], 
       [ 0.,  0.,  0.,  1.,  0.], 
       [ 0.,  0.,  0.,  0.,  1.]]) 
 
 
 
&gt;&gt;&gt; dd3 = -np.r_[[[1,0,0]],contrast_all_one(3)] 
&gt;&gt;&gt; dd2 = -np.r_[[[1,0]],contrast_all_one(2)] 
&gt;&gt;&gt; np.kron(np.eye(3), dd2) 
array([[-1.,  0.,  0.,  0.,  0.,  0.], 
       [-1.,  1.,  0.,  0.,  0.,  0.], 
       [ 0.,  0., -1.,  0.,  0.,  0.], 
       [ 0.,  0., -1.,  1.,  0.,  0.], 
       [ 0.,  0.,  0.,  0., -1.,  0.], 
       [ 0.,  0.,  0.,  0., -1.,  1.]]) 
&gt;&gt;&gt; dd2 
array([[-1.,  0.], 
       [-1.,  1.]]) 
&gt;&gt;&gt; np.kron(np.eye(3), dd2[1:]) 
array([[-1.,  1.,  0.,  0.,  0.,  0.], 
       [ 0.,  0., -1.,  1.,  0.,  0.], 
       [ 0.,  0.,  0.,  0., -1.,  1.]]) 
&gt;&gt;&gt; np.kron(dd[1:], np.eye(2)) 
array([[-1.,  0.,  1.,  0.,  0.,  0.], 
       [ 0., -1.,  0.,  1.,  0.,  0.], 
       [-1.,  0.,  0.,  0.,  1.,  0.], 
       [ 0., -1.,  0.,  0.,  0.,  1.]]) 
 
 
 
d_ = np.r_[[[1,0,0,0,0]],contrast_all_one(5)] 
&gt;&gt;&gt; d_ 
array([[ 1.,  0.,  0.,  0.,  0.], 
       [ 1., -1.,  0.,  0.,  0.], 
       [ 1.,  0., -1.,  0.,  0.], 
       [ 1.,  0.,  0., -1.,  0.], 
       [ 1.,  0.,  0.,  0., -1.]]) 
&gt;&gt;&gt; np.round(np.linalg.pinv(d_)).astype(int) 
array([[ 1,  0,  0,  0,  0], 
       [ 1, -1,  0,  0,  0], 
       [ 1,  0, -1,  0,  0], 
       [ 1,  0,  0, -1,  0], 
       [ 1,  0,  0,  0, -1]]) 
&gt;&gt;&gt; np.linalg.inv(d_).astype(int) 
array([[ 1,  0,  0,  0,  0], 
       [ 1, -1,  0,  0,  0], 
       [ 1,  0, -1,  0,  0], 
       [ 1,  0,  0, -1,  0], 
       [ 1,  0,  0,  0, -1]]) 
 
 
group means 
 
&gt;&gt;&gt; sli = [slice(None)] + [None]*(3-2) + [slice(None)] 
&gt;&gt;&gt; (np.column_stack((y, x1, x2))[...,None] * d1[sli]).sum(0)*1./d1.sum(0) 
array([[ 1.5,  5.5,  9.5], 
       [ 0. ,  1. ,  2. ], 
       [ 0.5,  0.5,  0.5]]) 
 
&gt;&gt;&gt; [(z[:,None] * d1).sum(0)*1./d1.sum(0) for z in np.column_stack((y, x1, x2)).T] 
[array([ 1.5,  5.5,  9.5]), array([ 0.,  1.,  2.]), array([ 0.5,  0.5,  0.5])] 
&gt;&gt;&gt; 
 
'''</span>
</pre>
</body>
</html>