<html>
<head>
<title>test__util.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test__util.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">multiprocessing </span><span class="s0">import </span><span class="s1">Pool</span>
<span class="s0">from </span><span class="s1">multiprocessing.pool </span><span class="s0">import </span><span class="s1">Pool </span><span class="s0">as </span><span class="s1">PWL</span>
<span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">import </span><span class="s1">math</span>
<span class="s0">from </span><span class="s1">fractions </span><span class="s0">import </span><span class="s1">Fraction</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">assert_equal</span><span class="s0">, </span><span class="s1">assert_</span>
<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">from </span><span class="s1">pytest </span><span class="s0">import </span><span class="s1">raises </span><span class="s0">as </span><span class="s1">assert_raises</span><span class="s0">, </span><span class="s1">deprecated_call</span>

<span class="s0">import </span><span class="s1">scipy</span>
<span class="s0">from </span><span class="s1">scipy._lib._util </span><span class="s0">import </span><span class="s1">(_aligned_zeros</span><span class="s0">, </span><span class="s1">check_random_state</span><span class="s0">, </span><span class="s1">MapWrapper</span><span class="s0">,</span>
                              <span class="s1">getfullargspec_no_self</span><span class="s0">, </span><span class="s1">FullArgSpec</span><span class="s0">,</span>
                              <span class="s1">rng_integers</span><span class="s0">, </span><span class="s1">_validate_int</span><span class="s0">, </span><span class="s1">_rename_parameter</span><span class="s0">,</span>
                              <span class="s1">_contains_nan</span><span class="s0">, </span><span class="s1">_rng_html_rewrite)</span>


<span class="s0">def </span><span class="s1">test__aligned_zeros():</span>
    <span class="s1">niter = </span><span class="s2">10</span>

    <span class="s0">def </span><span class="s1">check(shape</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">order</span><span class="s0">, </span><span class="s1">align):</span>
        <span class="s1">err_msg = repr((shape</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">order</span><span class="s0">, </span><span class="s1">align))</span>
        <span class="s1">x = _aligned_zeros(shape</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">order</span><span class="s0">, </span><span class="s1">align=align)</span>
        <span class="s0">if </span><span class="s1">align </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">align = np.dtype(dtype).alignment</span>
        <span class="s1">assert_equal(x.__array_interface__[</span><span class="s3">'data'</span><span class="s1">][</span><span class="s2">0</span><span class="s1">] % align</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">hasattr(shape</span><span class="s0">, </span><span class="s3">'__len__'</span><span class="s1">):</span>
            <span class="s1">assert_equal(x.shape</span><span class="s0">, </span><span class="s1">shape</span><span class="s0">, </span><span class="s1">err_msg)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">assert_equal(x.shape</span><span class="s0">, </span><span class="s1">(shape</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">err_msg)</span>
        <span class="s1">assert_equal(x.dtype</span><span class="s0">, </span><span class="s1">dtype)</span>
        <span class="s0">if </span><span class="s1">order == </span><span class="s3">&quot;C&quot;</span><span class="s1">:</span>
            <span class="s1">assert_(x.flags.c_contiguous</span><span class="s0">, </span><span class="s1">err_msg)</span>
        <span class="s0">elif </span><span class="s1">order == </span><span class="s3">&quot;F&quot;</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">x.size &gt; </span><span class="s2">0</span><span class="s1">:</span>
                <span class="s4"># Size-0 arrays get invalid flags on NumPy 1.5</span>
                <span class="s1">assert_(x.flags.f_contiguous</span><span class="s0">, </span><span class="s1">err_msg)</span>
        <span class="s0">elif </span><span class="s1">order </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">assert_(x.flags.c_contiguous</span><span class="s0">, </span><span class="s1">err_msg)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError()</span>

    <span class="s4"># try various alignments</span>
    <span class="s0">for </span><span class="s1">align </span><span class="s0">in </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">16</span><span class="s0">, </span><span class="s2">32</span><span class="s0">, </span><span class="s2">64</span><span class="s0">, None</span><span class="s1">]:</span>
        <span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">11</span><span class="s1">]:</span>
            <span class="s0">for </span><span class="s1">order </span><span class="s0">in </span><span class="s1">[</span><span class="s3">&quot;C&quot;</span><span class="s0">, </span><span class="s3">&quot;F&quot;</span><span class="s0">, None</span><span class="s1">]:</span>
                <span class="s0">for </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">[np.uint8</span><span class="s0">, </span><span class="s1">np.float64]:</span>
                    <span class="s0">for </span><span class="s1">shape </span><span class="s0">in </span><span class="s1">[n</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s1">n)]:</span>
                        <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(niter):</span>
                            <span class="s1">check(shape</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">order</span><span class="s0">, </span><span class="s1">align)</span>


<span class="s0">def </span><span class="s1">test_check_random_state():</span>
    <span class="s4"># If seed is None, return the RandomState singleton used by np.random.</span>
    <span class="s4"># If seed is an int, return a new RandomState instance seeded with seed.</span>
    <span class="s4"># If seed is already a RandomState instance, return it.</span>
    <span class="s4"># Otherwise raise ValueError.</span>
    <span class="s1">rsi = check_random_state(</span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(type(rsi)</span><span class="s0">, </span><span class="s1">np.random.RandomState)</span>
    <span class="s1">rsi = check_random_state(rsi)</span>
    <span class="s1">assert_equal(type(rsi)</span><span class="s0">, </span><span class="s1">np.random.RandomState)</span>
    <span class="s1">rsi = check_random_state(</span><span class="s0">None</span><span class="s1">)</span>
    <span class="s1">assert_equal(type(rsi)</span><span class="s0">, </span><span class="s1">np.random.RandomState)</span>
    <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">check_random_state</span><span class="s0">, </span><span class="s3">'a'</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">hasattr(np.random</span><span class="s0">, </span><span class="s3">'Generator'</span><span class="s1">):</span>
        <span class="s4"># np.random.Generator is only available in NumPy &gt;= 1.17</span>
        <span class="s1">rg = np.random.Generator(np.random.PCG64())</span>
        <span class="s1">rsi = check_random_state(rg)</span>
        <span class="s1">assert_equal(type(rsi)</span><span class="s0">, </span><span class="s1">np.random.Generator)</span>


<span class="s0">def </span><span class="s1">test_getfullargspec_no_self():</span>
    <span class="s1">p = MapWrapper(</span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">argspec = getfullargspec_no_self(p.__init__)</span>
    <span class="s1">assert_equal(argspec</span><span class="s0">, </span><span class="s1">FullArgSpec([</span><span class="s3">'pool'</span><span class="s1">]</span><span class="s0">, None, None, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">,</span>
                                      <span class="s0">None, </span><span class="s1">{}))</span>
    <span class="s1">argspec = getfullargspec_no_self(p.__call__)</span>
    <span class="s1">assert_equal(argspec</span><span class="s0">, </span><span class="s1">FullArgSpec([</span><span class="s3">'func'</span><span class="s0">, </span><span class="s3">'iterable'</span><span class="s1">]</span><span class="s0">, None, None, None,</span>
                                      <span class="s1">[]</span><span class="s0">, None, </span><span class="s1">{}))</span>

    <span class="s0">class </span><span class="s1">_rv_generic:</span>
        <span class="s0">def </span><span class="s1">_rvs(self</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b=</span><span class="s2">2</span><span class="s0">, </span><span class="s1">c=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">size=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
            <span class="s0">return None</span>

    <span class="s1">rv_obj = _rv_generic()</span>
    <span class="s1">argspec = getfullargspec_no_self(rv_obj._rvs)</span>
    <span class="s1">assert_equal(argspec</span><span class="s0">, </span><span class="s1">FullArgSpec([</span><span class="s3">'a'</span><span class="s0">, </span><span class="s3">'b'</span><span class="s0">, </span><span class="s3">'c'</span><span class="s1">]</span><span class="s0">, </span><span class="s3">'args'</span><span class="s0">, </span><span class="s3">'kwargs'</span><span class="s0">,</span>
                                      <span class="s1">(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">'size'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{</span><span class="s3">'size'</span><span class="s1">: </span><span class="s0">None</span><span class="s1">}</span><span class="s0">, </span><span class="s1">{}))</span>


<span class="s0">def </span><span class="s1">test_mapwrapper_serial():</span>
    <span class="s1">in_arg = np.arange(</span><span class="s2">10.</span><span class="s1">)</span>
    <span class="s1">out_arg = np.sin(in_arg)</span>

    <span class="s1">p = MapWrapper(</span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">assert_(p._mapfunc </span><span class="s0">is </span><span class="s1">map)</span>
    <span class="s1">assert_(p.pool </span><span class="s0">is None</span><span class="s1">)</span>
    <span class="s1">assert_(p._own_pool </span><span class="s0">is False</span><span class="s1">)</span>
    <span class="s1">out = list(p(np.sin</span><span class="s0">, </span><span class="s1">in_arg))</span>
    <span class="s1">assert_equal(out</span><span class="s0">, </span><span class="s1">out_arg)</span>

    <span class="s0">with </span><span class="s1">assert_raises(RuntimeError):</span>
        <span class="s1">p = MapWrapper(</span><span class="s2">0</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_pool():</span>
    <span class="s0">with </span><span class="s1">Pool(</span><span class="s2">2</span><span class="s1">) </span><span class="s0">as </span><span class="s1">p:</span>
        <span class="s1">p.map(math.sin</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">test_mapwrapper_parallel():</span>
    <span class="s1">in_arg = np.arange(</span><span class="s2">10.</span><span class="s1">)</span>
    <span class="s1">out_arg = np.sin(in_arg)</span>

    <span class="s0">with </span><span class="s1">MapWrapper(</span><span class="s2">2</span><span class="s1">) </span><span class="s0">as </span><span class="s1">p:</span>
        <span class="s1">out = p(np.sin</span><span class="s0">, </span><span class="s1">in_arg)</span>
        <span class="s1">assert_equal(list(out)</span><span class="s0">, </span><span class="s1">out_arg)</span>

        <span class="s1">assert_(p._own_pool </span><span class="s0">is True</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(p.pool</span><span class="s0">, </span><span class="s1">PWL))</span>
        <span class="s1">assert_(p._mapfunc </span><span class="s0">is not None</span><span class="s1">)</span>

    <span class="s4"># the context manager should've closed the internal pool</span>
    <span class="s4"># check that it has by asking it to calculate again.</span>
    <span class="s0">with </span><span class="s1">assert_raises(Exception) </span><span class="s0">as </span><span class="s1">excinfo:</span>
        <span class="s1">p(np.sin</span><span class="s0">, </span><span class="s1">in_arg)</span>

    <span class="s1">assert_(excinfo.type </span><span class="s0">is </span><span class="s1">ValueError)</span>

    <span class="s4"># can also set a PoolWrapper up with a map-like callable instance</span>
    <span class="s0">with </span><span class="s1">Pool(</span><span class="s2">2</span><span class="s1">) </span><span class="s0">as </span><span class="s1">p:</span>
        <span class="s1">q = MapWrapper(p.map)</span>

        <span class="s1">assert_(q._own_pool </span><span class="s0">is False</span><span class="s1">)</span>
        <span class="s1">q.close()</span>

        <span class="s4"># closing the PoolWrapper shouldn't close the internal pool</span>
        <span class="s4"># because it didn't create it</span>
        <span class="s1">out = p.map(np.sin</span><span class="s0">, </span><span class="s1">in_arg)</span>
        <span class="s1">assert_equal(list(out)</span><span class="s0">, </span><span class="s1">out_arg)</span>


<span class="s4"># get our custom ones and a few from the &quot;import *&quot; cases</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">'key'</span><span class="s0">, </span><span class="s1">(</span><span class="s3">'ifft'</span><span class="s0">, </span><span class="s3">'diag'</span><span class="s0">, </span><span class="s3">'arccos'</span><span class="s0">, </span><span class="s3">'randn'</span><span class="s0">, </span><span class="s3">'rand'</span><span class="s0">, </span><span class="s3">'array'</span><span class="s1">))</span>
<span class="s0">def </span><span class="s1">test_numpy_deprecation(key):</span>
    <span class="s5">&quot;&quot;&quot;Test that 'from numpy import *' functions are deprecated.&quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">(</span><span class="s3">'ifft'</span><span class="s0">, </span><span class="s3">'diag'</span><span class="s0">, </span><span class="s3">'arccos'</span><span class="s1">):</span>
        <span class="s1">arg = [</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.</span><span class="s1">]</span>
    <span class="s0">elif </span><span class="s1">key == </span><span class="s3">'finfo'</span><span class="s1">:</span>
        <span class="s1">arg = float</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">arg = </span><span class="s2">2</span>
    <span class="s1">func = getattr(scipy</span><span class="s0">, </span><span class="s1">key)</span>
    <span class="s1">match = </span><span class="s3">r'scipy\.%s is deprecated.*2\.0\.0' </span><span class="s1">% key</span>
    <span class="s0">with </span><span class="s1">deprecated_call(match=match) </span><span class="s0">as </span><span class="s1">dep:</span>
        <span class="s1">func(arg)  </span><span class="s4"># deprecated</span>
    <span class="s4"># in case we catch more than one dep warning</span>
    <span class="s1">fnames = [os.path.splitext(d.filename)[</span><span class="s2">0</span><span class="s1">] </span><span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">dep.list]</span>
    <span class="s1">basenames = [os.path.basename(fname) </span><span class="s0">for </span><span class="s1">fname </span><span class="s0">in </span><span class="s1">fnames]</span>
    <span class="s0">assert </span><span class="s3">'test__util' </span><span class="s0">in </span><span class="s1">basenames</span>
    <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">(</span><span class="s3">'rand'</span><span class="s0">, </span><span class="s3">'randn'</span><span class="s1">):</span>
        <span class="s1">root = np.random</span>
    <span class="s0">elif </span><span class="s1">key == </span><span class="s3">'ifft'</span><span class="s1">:</span>
        <span class="s1">root = np.fft</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">root = np</span>
    <span class="s1">func_np = getattr(root</span><span class="s0">, </span><span class="s1">key)</span>
    <span class="s1">func_np(arg)  </span><span class="s4"># not deprecated</span>
    <span class="s0">assert </span><span class="s1">func_np </span><span class="s0">is not </span><span class="s1">func</span>
    <span class="s4"># classes should remain classes</span>
    <span class="s0">if </span><span class="s1">isinstance(func_np</span><span class="s0">, </span><span class="s1">type):</span>
        <span class="s0">assert </span><span class="s1">isinstance(func</span><span class="s0">, </span><span class="s1">type)</span>


<span class="s0">def </span><span class="s1">test_numpy_deprecation_functionality():</span>
    <span class="s4"># Check that the deprecation wrappers don't break basic NumPy</span>
    <span class="s4"># functionality</span>
    <span class="s0">with </span><span class="s1">deprecated_call():</span>
        <span class="s1">x = scipy.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=scipy.float64)</span>
        <span class="s0">assert </span><span class="s1">x.dtype == scipy.float64</span>
        <span class="s0">assert </span><span class="s1">x.dtype == np.float64</span>

        <span class="s1">x = scipy.finfo(scipy.float32)</span>
        <span class="s0">assert </span><span class="s1">x.eps == np.finfo(np.float32).eps</span>

        <span class="s0">assert </span><span class="s1">scipy.float64 == np.float64</span>
        <span class="s0">assert </span><span class="s1">issubclass(np.float64</span><span class="s0">, </span><span class="s1">scipy.float64)</span>


<span class="s0">def </span><span class="s1">test_rng_integers():</span>
    <span class="s1">rng = np.random.RandomState()</span>

    <span class="s4"># test that numbers are inclusive of high point</span>
    <span class="s1">arr = rng_integers(rng</span><span class="s0">, </span><span class="s1">low=</span><span class="s2">2</span><span class="s0">, </span><span class="s1">high=</span><span class="s2">5</span><span class="s0">, </span><span class="s1">size=</span><span class="s2">100</span><span class="s0">, </span><span class="s1">endpoint=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">np.max(arr) == </span><span class="s2">5</span>
    <span class="s0">assert </span><span class="s1">np.min(arr) == </span><span class="s2">2</span>
    <span class="s0">assert </span><span class="s1">arr.shape == (</span><span class="s2">100</span><span class="s0">, </span><span class="s1">)</span>

    <span class="s4"># test that numbers are inclusive of high point</span>
    <span class="s1">arr = rng_integers(rng</span><span class="s0">, </span><span class="s1">low=</span><span class="s2">5</span><span class="s0">, </span><span class="s1">size=</span><span class="s2">100</span><span class="s0">, </span><span class="s1">endpoint=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">np.max(arr) == </span><span class="s2">5</span>
    <span class="s0">assert </span><span class="s1">np.min(arr) == </span><span class="s2">0</span>
    <span class="s0">assert </span><span class="s1">arr.shape == (</span><span class="s2">100</span><span class="s0">, </span><span class="s1">)</span>

    <span class="s4"># test that numbers are exclusive of high point</span>
    <span class="s1">arr = rng_integers(rng</span><span class="s0">, </span><span class="s1">low=</span><span class="s2">2</span><span class="s0">, </span><span class="s1">high=</span><span class="s2">5</span><span class="s0">, </span><span class="s1">size=</span><span class="s2">100</span><span class="s0">, </span><span class="s1">endpoint=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">np.max(arr) == </span><span class="s2">4</span>
    <span class="s0">assert </span><span class="s1">np.min(arr) == </span><span class="s2">2</span>
    <span class="s0">assert </span><span class="s1">arr.shape == (</span><span class="s2">100</span><span class="s0">, </span><span class="s1">)</span>

    <span class="s4"># test that numbers are exclusive of high point</span>
    <span class="s1">arr = rng_integers(rng</span><span class="s0">, </span><span class="s1">low=</span><span class="s2">5</span><span class="s0">, </span><span class="s1">size=</span><span class="s2">100</span><span class="s0">, </span><span class="s1">endpoint=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">np.max(arr) == </span><span class="s2">4</span>
    <span class="s0">assert </span><span class="s1">np.min(arr) == </span><span class="s2">0</span>
    <span class="s0">assert </span><span class="s1">arr.shape == (</span><span class="s2">100</span><span class="s0">, </span><span class="s1">)</span>

    <span class="s4"># now try with np.random.Generator</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">rng = np.random.default_rng()</span>
    <span class="s0">except </span><span class="s1">AttributeError:</span>
        <span class="s0">return</span>

    <span class="s4"># test that numbers are inclusive of high point</span>
    <span class="s1">arr = rng_integers(rng</span><span class="s0">, </span><span class="s1">low=</span><span class="s2">2</span><span class="s0">, </span><span class="s1">high=</span><span class="s2">5</span><span class="s0">, </span><span class="s1">size=</span><span class="s2">100</span><span class="s0">, </span><span class="s1">endpoint=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">np.max(arr) == </span><span class="s2">5</span>
    <span class="s0">assert </span><span class="s1">np.min(arr) == </span><span class="s2">2</span>
    <span class="s0">assert </span><span class="s1">arr.shape == (</span><span class="s2">100</span><span class="s0">, </span><span class="s1">)</span>

    <span class="s4"># test that numbers are inclusive of high point</span>
    <span class="s1">arr = rng_integers(rng</span><span class="s0">, </span><span class="s1">low=</span><span class="s2">5</span><span class="s0">, </span><span class="s1">size=</span><span class="s2">100</span><span class="s0">, </span><span class="s1">endpoint=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">np.max(arr) == </span><span class="s2">5</span>
    <span class="s0">assert </span><span class="s1">np.min(arr) == </span><span class="s2">0</span>
    <span class="s0">assert </span><span class="s1">arr.shape == (</span><span class="s2">100</span><span class="s0">, </span><span class="s1">)</span>

    <span class="s4"># test that numbers are exclusive of high point</span>
    <span class="s1">arr = rng_integers(rng</span><span class="s0">, </span><span class="s1">low=</span><span class="s2">2</span><span class="s0">, </span><span class="s1">high=</span><span class="s2">5</span><span class="s0">, </span><span class="s1">size=</span><span class="s2">100</span><span class="s0">, </span><span class="s1">endpoint=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">np.max(arr) == </span><span class="s2">4</span>
    <span class="s0">assert </span><span class="s1">np.min(arr) == </span><span class="s2">2</span>
    <span class="s0">assert </span><span class="s1">arr.shape == (</span><span class="s2">100</span><span class="s0">, </span><span class="s1">)</span>

    <span class="s4"># test that numbers are exclusive of high point</span>
    <span class="s1">arr = rng_integers(rng</span><span class="s0">, </span><span class="s1">low=</span><span class="s2">5</span><span class="s0">, </span><span class="s1">size=</span><span class="s2">100</span><span class="s0">, </span><span class="s1">endpoint=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">np.max(arr) == </span><span class="s2">4</span>
    <span class="s0">assert </span><span class="s1">np.min(arr) == </span><span class="s2">0</span>
    <span class="s0">assert </span><span class="s1">arr.shape == (</span><span class="s2">100</span><span class="s0">, </span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestValidateInt:</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'n'</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s1">np.uint8(</span><span class="s2">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.int16(</span><span class="s2">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.array(</span><span class="s2">4</span><span class="s1">)])</span>
    <span class="s0">def </span><span class="s1">test_validate_int(self</span><span class="s0">, </span><span class="s1">n):</span>
        <span class="s1">n = _validate_int(n</span><span class="s0">, </span><span class="s3">'n'</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">n == </span><span class="s2">4</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'n'</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4.0</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">4</span><span class="s1">])</span><span class="s0">, </span><span class="s1">Fraction(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)])</span>
    <span class="s0">def </span><span class="s1">test_validate_int_bad(self</span><span class="s0">, </span><span class="s1">n):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">'n must be an integer'</span><span class="s1">):</span>
            <span class="s1">_validate_int(n</span><span class="s0">, </span><span class="s3">'n'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_validate_int_below_min(self):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">'n must be an integer not '</span>
                                             <span class="s3">'less than 0'</span><span class="s1">):</span>
            <span class="s1">_validate_int(-</span><span class="s2">1</span><span class="s0">, </span><span class="s3">'n'</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestRenameParameter:</span>
    <span class="s4"># check that wrapper `_rename_parameter` for backward-compatible</span>
    <span class="s4"># keyword renaming works correctly</span>

    <span class="s4"># Example method/function that still accepts keyword `old`</span>
    <span class="s1">@_rename_parameter(</span><span class="s3">&quot;old&quot;</span><span class="s0">, </span><span class="s3">&quot;new&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">old_keyword_still_accepted(self</span><span class="s0">, </span><span class="s1">new):</span>
        <span class="s0">return </span><span class="s1">new</span>

    <span class="s4"># Example method/function for which keyword `old` is deprecated</span>
    <span class="s1">@_rename_parameter(</span><span class="s3">&quot;old&quot;</span><span class="s0">, </span><span class="s3">&quot;new&quot;</span><span class="s0">, </span><span class="s1">dep_version=</span><span class="s3">&quot;1.9.0&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">old_keyword_deprecated(self</span><span class="s0">, </span><span class="s1">new):</span>
        <span class="s0">return </span><span class="s1">new</span>

    <span class="s0">def </span><span class="s1">test_old_keyword_still_accepted(self):</span>
        <span class="s4"># positional argument and both keyword work identically</span>
        <span class="s1">res1 = self.old_keyword_still_accepted(</span><span class="s2">10</span><span class="s1">)</span>
        <span class="s1">res2 = self.old_keyword_still_accepted(new=</span><span class="s2">10</span><span class="s1">)</span>
        <span class="s1">res3 = self.old_keyword_still_accepted(old=</span><span class="s2">10</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">res1 == res2 == res3 == </span><span class="s2">10</span>

        <span class="s4"># unexpected keyword raises an error</span>
        <span class="s1">message = re.escape(</span><span class="s3">&quot;old_keyword_still_accepted() got an unexpected&quot;</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">self.old_keyword_still_accepted(unexpected=</span><span class="s2">10</span><span class="s1">)</span>

        <span class="s4"># multiple values for the same parameter raises an error</span>
        <span class="s1">message = re.escape(</span><span class="s3">&quot;old_keyword_still_accepted() got multiple&quot;</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">self.old_keyword_still_accepted(</span><span class="s2">10</span><span class="s0">, </span><span class="s1">new=</span><span class="s2">10</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">self.old_keyword_still_accepted(</span><span class="s2">10</span><span class="s0">, </span><span class="s1">old=</span><span class="s2">10</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">self.old_keyword_still_accepted(new=</span><span class="s2">10</span><span class="s0">, </span><span class="s1">old=</span><span class="s2">10</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_old_keyword_deprecated(self):</span>
        <span class="s4"># positional argument and both keyword work identically,</span>
        <span class="s4"># but use of old keyword results in DeprecationWarning</span>
        <span class="s1">dep_msg = </span><span class="s3">&quot;Use of keyword argument `old` is deprecated&quot;</span>
        <span class="s1">res1 = self.old_keyword_deprecated(</span><span class="s2">10</span><span class="s1">)</span>
        <span class="s1">res2 = self.old_keyword_deprecated(new=</span><span class="s2">10</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.warns(DeprecationWarning</span><span class="s0">, </span><span class="s1">match=dep_msg):</span>
            <span class="s1">res3 = self.old_keyword_deprecated(old=</span><span class="s2">10</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">res1 == res2 == res3 == </span><span class="s2">10</span>

        <span class="s4"># unexpected keyword raises an error</span>
        <span class="s1">message = re.escape(</span><span class="s3">&quot;old_keyword_deprecated() got an unexpected&quot;</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">self.old_keyword_deprecated(unexpected=</span><span class="s2">10</span><span class="s1">)</span>

        <span class="s4"># multiple values for the same parameter raises an error and,</span>
        <span class="s4"># if old keyword is used, results in DeprecationWarning</span>
        <span class="s1">message = re.escape(</span><span class="s3">&quot;old_keyword_deprecated() got multiple&quot;</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">self.old_keyword_deprecated(</span><span class="s2">10</span><span class="s0">, </span><span class="s1">new=</span><span class="s2">10</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=message)</span><span class="s0">, </span><span class="s1">\</span>
                <span class="s1">pytest.warns(DeprecationWarning</span><span class="s0">, </span><span class="s1">match=dep_msg):</span>
            <span class="s1">self.old_keyword_deprecated(</span><span class="s2">10</span><span class="s0">, </span><span class="s1">old=</span><span class="s2">10</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=message)</span><span class="s0">, </span><span class="s1">\</span>
                <span class="s1">pytest.warns(DeprecationWarning</span><span class="s0">, </span><span class="s1">match=dep_msg):</span>
            <span class="s1">self.old_keyword_deprecated(new=</span><span class="s2">10</span><span class="s0">, </span><span class="s1">old=</span><span class="s2">10</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestContainsNaNTest:</span>

    <span class="s0">def </span><span class="s1">test_policy(self):</span>
        <span class="s1">data = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s1">np.nan])</span>

        <span class="s1">contains_nan</span><span class="s0">, </span><span class="s1">nan_policy = _contains_nan(data</span><span class="s0">, </span><span class="s1">nan_policy=</span><span class="s3">&quot;propagate&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">contains_nan</span>
        <span class="s0">assert </span><span class="s1">nan_policy == </span><span class="s3">&quot;propagate&quot;</span>

        <span class="s1">contains_nan</span><span class="s0">, </span><span class="s1">nan_policy = _contains_nan(data</span><span class="s0">, </span><span class="s1">nan_policy=</span><span class="s3">&quot;omit&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">contains_nan</span>
        <span class="s0">assert </span><span class="s1">nan_policy == </span><span class="s3">&quot;omit&quot;</span>

        <span class="s1">msg = </span><span class="s3">&quot;The input contains nan values&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">_contains_nan(data</span><span class="s0">, </span><span class="s1">nan_policy=</span><span class="s3">&quot;raise&quot;</span><span class="s1">)</span>

        <span class="s1">msg = </span><span class="s3">&quot;nan_policy must be one of&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">_contains_nan(data</span><span class="s0">, </span><span class="s1">nan_policy=</span><span class="s3">&quot;nan&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_contains_nan_1d(self):</span>
        <span class="s1">data1 = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s0">assert not </span><span class="s1">_contains_nan(data1)[</span><span class="s2">0</span><span class="s1">]</span>

        <span class="s1">data2 = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s1">np.nan])</span>
        <span class="s0">assert </span><span class="s1">_contains_nan(data2)[</span><span class="s2">0</span><span class="s1">]</span>

        <span class="s1">data3 = np.array([np.nan</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s1">np.nan])</span>
        <span class="s0">assert </span><span class="s1">_contains_nan(data3)[</span><span class="s2">0</span><span class="s1">]</span>

        <span class="s1">data4 = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s3">&quot;3&quot;</span><span class="s0">, </span><span class="s1">np.nan])  </span><span class="s4"># converted to string &quot;nan&quot;</span>
        <span class="s0">assert not </span><span class="s1">_contains_nan(data4)[</span><span class="s2">0</span><span class="s1">]</span>

        <span class="s1">data5 = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s3">&quot;3&quot;</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s3">'object'</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">_contains_nan(data5)[</span><span class="s2">0</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">test_contains_nan_2d(self):</span>
        <span class="s1">data1 = np.array([[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]])</span>
        <span class="s0">assert not </span><span class="s1">_contains_nan(data1)[</span><span class="s2">0</span><span class="s1">]</span>

        <span class="s1">data2 = np.array([[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s1">np.nan]])</span>
        <span class="s0">assert </span><span class="s1">_contains_nan(data2)[</span><span class="s2">0</span><span class="s1">]</span>

        <span class="s1">data3 = np.array([[</span><span class="s3">&quot;1&quot;</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s1">np.nan]])  </span><span class="s4"># converted to string &quot;nan&quot;</span>
        <span class="s0">assert not </span><span class="s1">_contains_nan(data3)[</span><span class="s2">0</span><span class="s1">]</span>

        <span class="s1">data4 = np.array([[</span><span class="s3">&quot;1&quot;</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s1">np.nan]]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s3">'object'</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">_contains_nan(data4)[</span><span class="s2">0</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">test__rng_html_rewrite():</span>
    <span class="s0">def </span><span class="s1">mock_str():</span>
        <span class="s1">lines = [</span>
            <span class="s3">'np.random.default_rng(8989843)'</span><span class="s0">,</span>
            <span class="s3">'np.random.default_rng(seed)'</span><span class="s0">,</span>
            <span class="s3">'np.random.default_rng(0x9a71b21474694f919882289dc1559ca)'</span><span class="s0">,</span>
            <span class="s3">' bob '</span><span class="s0">,</span>
        <span class="s1">]</span>
        <span class="s0">return </span><span class="s1">lines</span>

    <span class="s1">res = _rng_html_rewrite(mock_str)()</span>
    <span class="s1">ref = [</span>
        <span class="s3">'np.random.default_rng()'</span><span class="s0">,</span>
        <span class="s3">'np.random.default_rng(seed)'</span><span class="s0">,</span>
        <span class="s3">'np.random.default_rng()'</span><span class="s0">,</span>
        <span class="s3">' bob '</span><span class="s0">,</span>
    <span class="s1">]</span>

    <span class="s0">assert </span><span class="s1">res == ref</span>
</pre>
</body>
</html>