<html>
<head>
<title>reference.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #808080;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
reference.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">base64</span>
<span class="s0">import </span><span class="s1">collections</span>
<span class="s0">import </span><span class="s1">io</span>
<span class="s0">import </span><span class="s1">itertools</span>
<span class="s0">import </span><span class="s1">logging</span>
<span class="s0">import </span><span class="s1">math</span>
<span class="s0">import </span><span class="s1">os</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">lru_cache</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">TYPE_CHECKING</span>

<span class="s0">import </span><span class="s1">fsspec.core</span>

<span class="s0">try</span><span class="s1">:</span>
    <span class="s0">import </span><span class="s1">ujson </span><span class="s0">as </span><span class="s1">json</span>
<span class="s0">except </span><span class="s1">ImportError:</span>
    <span class="s0">if not </span><span class="s1">TYPE_CHECKING:</span>
        <span class="s0">import </span><span class="s1">json</span>

<span class="s0">from </span><span class="s1">..asyn </span><span class="s0">import </span><span class="s1">AsyncFileSystem</span>
<span class="s0">from </span><span class="s1">..callbacks </span><span class="s0">import </span><span class="s1">_DEFAULT_CALLBACK</span>
<span class="s0">from </span><span class="s1">..core </span><span class="s0">import </span><span class="s1">filesystem</span><span class="s0">, </span><span class="s1">open</span><span class="s0">, </span><span class="s1">split_protocol</span>
<span class="s0">from </span><span class="s1">..utils </span><span class="s0">import </span><span class="s1">isfilelike</span><span class="s0">, </span><span class="s1">merge_offset_ranges</span><span class="s0">, </span><span class="s1">other_paths</span>

<span class="s1">logger = logging.getLogger(</span><span class="s2">&quot;fsspec.reference&quot;</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">ReferenceNotReachable(RuntimeError):</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">reference</span><span class="s0">, </span><span class="s1">target</span><span class="s0">, </span><span class="s1">*args):</span>
        <span class="s1">super().__init__(*args)</span>
        <span class="s1">self.reference = reference</span>
        <span class="s1">self.target = target</span>

    <span class="s0">def </span><span class="s1">__str__(self):</span>
        <span class="s0">return </span><span class="s2">f'Reference &quot;</span><span class="s0">{</span><span class="s1">self.reference</span><span class="s0">}</span><span class="s2">&quot; failed to fetch target </span><span class="s0">{</span><span class="s1">self.target</span><span class="s0">}</span><span class="s2">'</span>


<span class="s0">def </span><span class="s1">_first(d):</span>
    <span class="s0">return </span><span class="s1">list(d.values())[</span><span class="s3">0</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">_prot_in_references(path</span><span class="s0">, </span><span class="s1">references):</span>
    <span class="s1">ref = references.get(path)</span>
    <span class="s0">if </span><span class="s1">isinstance(ref</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">tuple)):</span>
        <span class="s0">return </span><span class="s1">split_protocol(ref[</span><span class="s3">0</span><span class="s1">])[</span><span class="s3">0</span><span class="s1">] </span><span class="s0">if </span><span class="s1">ref[</span><span class="s3">0</span><span class="s1">] </span><span class="s0">else </span><span class="s1">ref[</span><span class="s3">0</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">_protocol_groups(paths</span><span class="s0">, </span><span class="s1">references):</span>
    <span class="s0">if </span><span class="s1">isinstance(paths</span><span class="s0">, </span><span class="s1">str):</span>
        <span class="s0">return </span><span class="s1">{_prot_in_references(paths</span><span class="s0">, </span><span class="s1">references): [paths]}</span>
    <span class="s1">out = {}</span>
    <span class="s0">for </span><span class="s1">path </span><span class="s0">in </span><span class="s1">paths:</span>
        <span class="s1">protocol = _prot_in_references(path</span><span class="s0">, </span><span class="s1">references)</span>
        <span class="s1">out.setdefault(protocol</span><span class="s0">, </span><span class="s1">[]).append(path)</span>
    <span class="s0">return </span><span class="s1">out</span>


<span class="s0">class </span><span class="s1">RefsValuesView(collections.abc.ValuesView):</span>
    <span class="s0">def </span><span class="s1">__iter__(self):</span>
        <span class="s0">for </span><span class="s1">val </span><span class="s0">in </span><span class="s1">self._mapping.zmetadata.values():</span>
            <span class="s0">yield </span><span class="s1">json.dumps(val).encode()</span>
        <span class="s0">yield from </span><span class="s1">self._mapping._items.values()</span>
        <span class="s0">for </span><span class="s1">field </span><span class="s0">in </span><span class="s1">self._mapping.listdir():</span>
            <span class="s1">chunk_sizes = self._mapping._get_chunk_sizes(field)</span>
            <span class="s0">if </span><span class="s1">len(chunk_sizes) == </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s0">yield </span><span class="s1">self._mapping[field + </span><span class="s2">&quot;/0&quot;</span><span class="s1">]</span>
                <span class="s0">continue</span>
            <span class="s0">yield from </span><span class="s1">self._mapping._generate_all_records(field)</span>


<span class="s0">class </span><span class="s1">RefsItemsView(collections.abc.ItemsView):</span>
    <span class="s0">def </span><span class="s1">__iter__(self):</span>
        <span class="s0">return </span><span class="s1">zip(self._mapping.keys()</span><span class="s0">, </span><span class="s1">self._mapping.values())</span>


<span class="s0">def </span><span class="s1">ravel_multi_index(idx</span><span class="s0">, </span><span class="s1">sizes):</span>
    <span class="s1">val = </span><span class="s3">0</span>
    <span class="s1">mult = </span><span class="s3">1</span>
    <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">s </span><span class="s0">in </span><span class="s1">zip(idx[::-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">sizes[::-</span><span class="s3">1</span><span class="s1">]):</span>
        <span class="s1">val += i * mult</span>
        <span class="s1">mult *= s</span>
    <span class="s0">return </span><span class="s1">val</span>


<span class="s0">class </span><span class="s1">LazyReferenceMapper(collections.abc.MutableMapping):</span>
    <span class="s4">&quot;&quot;&quot;This interface can be used to read/write references from Parquet stores. 
    It is not intended for other types of references. 
    It can be used with Kerchunk's MultiZarrToZarr method to combine 
    references into a parquet store. 
    Examples of this use-case can be found here: 
    https://fsspec.github.io/kerchunk/advanced.html?highlight=parquet#parquet-storage&quot;&quot;&quot;</span>

    <span class="s5"># import is class level to prevent numpy dep requirement for fsspec</span>
    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">np(self):</span>
        <span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

        <span class="s0">return </span><span class="s1">np</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">pd(self):</span>
        <span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>

        <span class="s0">return </span><span class="s1">pd</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">root</span><span class="s0">, </span><span class="s1">fs=</span><span class="s0">None, </span><span class="s1">out_root=</span><span class="s0">None, </span><span class="s1">cache_size=</span><span class="s3">128</span><span class="s0">, </span><span class="s1">categorical_threshold=</span><span class="s3">10</span>
    <span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        root : str 
            Root of parquet store 
        fs : fsspec.AbstractFileSystem 
            fsspec filesystem object, default is local filesystem. 
        cache_size : int, default=128 
            Maximum size of LRU cache, where cache_size*record_size denotes 
            the total number of references that can be loaded in memory at once. 
        categorical_threshold : int 
            Encode urls as pandas.Categorical to reduce memory footprint if the ratio 
            of the number of unique urls to total number of refs for each variable 
            is greater than or equal to this number. (default 10) 
 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.root = root</span>
        <span class="s1">self.chunk_sizes = {}</span>
        <span class="s1">self._items = {}</span>
        <span class="s1">self.dirs = </span><span class="s0">None</span>
        <span class="s1">self.fs = fsspec.filesystem(</span><span class="s2">&quot;file&quot;</span><span class="s1">) </span><span class="s0">if </span><span class="s1">fs </span><span class="s0">is None else </span><span class="s1">fs</span>
        <span class="s1">self._items[</span><span class="s2">&quot;.zmetadata&quot;</span><span class="s1">] = self.fs.cat_file(</span>
            <span class="s2">&quot;/&quot;</span><span class="s1">.join([self.root</span><span class="s0">, </span><span class="s2">&quot;.zmetadata&quot;</span><span class="s1">])</span>
        <span class="s1">)</span>
        <span class="s1">met = json.loads(self._items[</span><span class="s2">&quot;.zmetadata&quot;</span><span class="s1">])</span>
        <span class="s1">self.record_size = met[</span><span class="s2">&quot;record_size&quot;</span><span class="s1">]</span>
        <span class="s1">self.zmetadata = met[</span><span class="s2">&quot;metadata&quot;</span><span class="s1">]</span>
        <span class="s1">self.url = self.root + </span><span class="s2">&quot;/{field}/refs.{record}.parq&quot;</span>
        <span class="s1">self.out_root = out_root </span><span class="s0">or </span><span class="s1">self.root</span>
        <span class="s1">self.cat_thresh = categorical_threshold</span>

        <span class="s5"># Define function to open and decompress refs</span>
        <span class="s1">@lru_cache(maxsize=cache_size)</span>
        <span class="s0">def </span><span class="s1">open_refs(field</span><span class="s0">, </span><span class="s1">record):</span>
            <span class="s4">&quot;&quot;&quot;cached parquet file loader&quot;&quot;&quot;</span>
            <span class="s1">path = self.url.format(field=field</span><span class="s0">, </span><span class="s1">record=record)</span>
            <span class="s1">data = io.BytesIO(self.fs.cat_file(path))</span>
            <span class="s1">df = self.pd.read_parquet(data</span><span class="s0">, </span><span class="s1">engine=</span><span class="s2">&quot;fastparquet&quot;</span><span class="s1">)</span>
            <span class="s1">refs = {c: df[c].values </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">df.columns}</span>
            <span class="s0">return </span><span class="s1">refs</span>

        <span class="s1">self.open_refs = open_refs</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">create(record_size</span><span class="s0">, </span><span class="s1">root</span><span class="s0">, </span><span class="s1">fs</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">met = {</span><span class="s2">&quot;metadata&quot;</span><span class="s1">: {}</span><span class="s0">, </span><span class="s2">&quot;record_size&quot;</span><span class="s1">: record_size}</span>
        <span class="s1">fs.pipe(</span><span class="s2">&quot;/&quot;</span><span class="s1">.join([root</span><span class="s0">, </span><span class="s2">&quot;.zmetadata&quot;</span><span class="s1">])</span><span class="s0">, </span><span class="s1">json.dumps(met).encode())</span>
        <span class="s0">return </span><span class="s1">LazyReferenceMapper(root</span><span class="s0">, </span><span class="s1">fs</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">listdir(self</span><span class="s0">, </span><span class="s1">basename=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot;List top-level directories&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.dirs </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">dirs = [p.split(</span><span class="s2">&quot;/&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">] </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">self.zmetadata]</span>
            <span class="s1">self.dirs = {p </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">dirs </span><span class="s0">if </span><span class="s1">p </span><span class="s0">and not </span><span class="s1">p.startswith(</span><span class="s2">&quot;.&quot;</span><span class="s1">)}</span>
        <span class="s1">listing = self.dirs</span>
        <span class="s0">if </span><span class="s1">basename:</span>
            <span class="s1">listing = [os.path.basename(path) </span><span class="s0">for </span><span class="s1">path </span><span class="s0">in </span><span class="s1">listing]</span>
        <span class="s0">return </span><span class="s1">listing</span>

    <span class="s0">def </span><span class="s1">ls(self</span><span class="s0">, </span><span class="s1">path=</span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s1">detail=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot;Shortcut file listings&quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">path:</span>
            <span class="s1">dirnames = self.listdir()</span>
            <span class="s1">others = set(</span>
                <span class="s1">[</span><span class="s2">&quot;.zmetadata&quot;</span><span class="s1">]</span>
                <span class="s1">+ [name </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self.zmetadata </span><span class="s0">if </span><span class="s2">&quot;/&quot; </span><span class="s0">not in </span><span class="s1">name]</span>
                <span class="s1">+ [name </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self._items </span><span class="s0">if </span><span class="s2">&quot;/&quot; </span><span class="s0">not in </span><span class="s1">name]</span>
            <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">detail </span><span class="s0">is False</span><span class="s1">:</span>
                <span class="s1">others.update(dirnames)</span>
                <span class="s0">return </span><span class="s1">sorted(others)</span>
            <span class="s1">dirinfo = [</span>
                <span class="s1">{</span><span class="s2">&quot;name&quot;</span><span class="s1">: name</span><span class="s0">, </span><span class="s2">&quot;type&quot;</span><span class="s1">: </span><span class="s2">&quot;directory&quot;</span><span class="s0">, </span><span class="s2">&quot;size&quot;</span><span class="s1">: </span><span class="s3">0</span><span class="s1">} </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">dirnames</span>
            <span class="s1">]</span>
            <span class="s1">fileinfo = [</span>
                <span class="s1">{</span>
                    <span class="s2">&quot;name&quot;</span><span class="s1">: name</span><span class="s0">,</span>
                    <span class="s2">&quot;type&quot;</span><span class="s1">: </span><span class="s2">&quot;file&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;size&quot;</span><span class="s1">: len(</span>
                        <span class="s1">json.dumps(self.zmetadata[name])</span>
                        <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self.zmetadata</span>
                        <span class="s0">else </span><span class="s1">self._items[name]</span>
                    <span class="s1">)</span><span class="s0">,</span>
                <span class="s1">}</span>
                <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">others</span>
            <span class="s1">]</span>
            <span class="s0">return </span><span class="s1">sorted(dirinfo + fileinfo</span><span class="s0">, </span><span class="s1">key=</span><span class="s0">lambda </span><span class="s1">s: s[</span><span class="s2">&quot;name&quot;</span><span class="s1">])</span>
        <span class="s1">parts = path.split(</span><span class="s2">&quot;/&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">len(parts) &gt; </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">FileNotFoundError(</span><span class="s2">&quot;Cannot list within directories right now&quot;</span><span class="s1">)</span>
        <span class="s1">field = parts[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">others = set(</span>
            <span class="s1">[name </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self.zmetadata </span><span class="s0">if </span><span class="s1">name.startswith(</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">path</span><span class="s0">}</span><span class="s2">/&quot;</span><span class="s1">)]</span>
            <span class="s1">+ [name </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self._items </span><span class="s0">if </span><span class="s1">name.startswith(</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">path</span><span class="s0">}</span><span class="s2">/&quot;</span><span class="s1">)]</span>
        <span class="s1">)</span>
        <span class="s1">fileinfo = [</span>
            <span class="s1">{</span>
                <span class="s2">&quot;name&quot;</span><span class="s1">: name</span><span class="s0">,</span>
                <span class="s2">&quot;type&quot;</span><span class="s1">: </span><span class="s2">&quot;file&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;size&quot;</span><span class="s1">: len(</span>
                    <span class="s1">json.dumps(self.zmetadata[name])</span>
                    <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self.zmetadata</span>
                    <span class="s0">else </span><span class="s1">self._items[name]</span>
                <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">}</span>
            <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">others</span>
        <span class="s1">]</span>
        <span class="s1">keys = self._keys_in_field(field)</span>

        <span class="s0">if </span><span class="s1">detail </span><span class="s0">is False</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">list(others) + list(keys)</span>
        <span class="s1">recs = self._generate_all_records(field)</span>
        <span class="s1">recinfo = [</span>
            <span class="s1">{</span><span class="s2">&quot;name&quot;</span><span class="s1">: name</span><span class="s0">, </span><span class="s2">&quot;type&quot;</span><span class="s1">: </span><span class="s2">&quot;file&quot;</span><span class="s0">, </span><span class="s2">&quot;size&quot;</span><span class="s1">: rec[-</span><span class="s3">1</span><span class="s1">]}</span>
            <span class="s0">for </span><span class="s1">name</span><span class="s0">, </span><span class="s1">rec </span><span class="s0">in </span><span class="s1">zip(keys</span><span class="s0">, </span><span class="s1">recs)</span>
            <span class="s0">if </span><span class="s1">rec[</span><span class="s3">0</span><span class="s1">]  </span><span class="s5"># filters out path==None, deleted/missing</span>
        <span class="s1">]</span>
        <span class="s0">return </span><span class="s1">fileinfo + recinfo</span>

    <span class="s0">def </span><span class="s1">_load_one_key(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s4">&quot;&quot;&quot;Get the reference for one key 
 
        Returns bytes, one-element list or three-element list. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">self._items:</span>
            <span class="s0">return </span><span class="s1">self._items[key]</span>
        <span class="s0">elif </span><span class="s1">key </span><span class="s0">in </span><span class="s1">self.zmetadata:</span>
            <span class="s0">return </span><span class="s1">json.dumps(self.zmetadata[key]).encode()</span>
        <span class="s0">elif </span><span class="s2">&quot;/&quot; </span><span class="s0">not in </span><span class="s1">key </span><span class="s0">or </span><span class="s1">self._is_meta(key):</span>
            <span class="s0">raise </span><span class="s1">KeyError(key)</span>
        <span class="s1">field</span><span class="s0">, </span><span class="s1">sub_key = key.split(</span><span class="s2">&quot;/&quot;</span><span class="s1">)</span>
        <span class="s1">record</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">_ = self._key_to_record(key)</span>
        <span class="s1">maybe = self._items.get((field</span><span class="s0">, </span><span class="s1">key)</span><span class="s0">, </span><span class="s1">{}).get(sub_key</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">maybe </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s5"># explicitly deleted</span>
            <span class="s0">raise </span><span class="s1">KeyError</span>
        <span class="s0">elif </span><span class="s1">maybe:</span>
            <span class="s0">return </span><span class="s1">maybe</span>

        <span class="s5"># Chunk keys can be loaded from row group and cached in LRU cache</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">record</span><span class="s0">, </span><span class="s1">ri</span><span class="s0">, </span><span class="s1">chunk_size = self._key_to_record(key)</span>
            <span class="s0">if </span><span class="s1">chunk_size == </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s6">b&quot;&quot;</span>
            <span class="s1">refs = self.open_refs(field</span><span class="s0">, </span><span class="s1">record)</span>
        <span class="s0">except </span><span class="s1">(ValueError</span><span class="s0">, </span><span class="s1">TypeError</span><span class="s0">, </span><span class="s1">FileNotFoundError):</span>
            <span class="s0">raise </span><span class="s1">KeyError(key)</span>
        <span class="s1">columns = [</span><span class="s2">&quot;path&quot;</span><span class="s0">, </span><span class="s2">&quot;offset&quot;</span><span class="s0">, </span><span class="s2">&quot;size&quot;</span><span class="s0">, </span><span class="s2">&quot;raw&quot;</span><span class="s1">]</span>
        <span class="s1">selection = [refs[c][ri] </span><span class="s0">if </span><span class="s1">c </span><span class="s0">in </span><span class="s1">refs </span><span class="s0">else None for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">columns]</span>
        <span class="s1">raw = selection[-</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">raw </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">raw</span>
        <span class="s0">if </span><span class="s1">selection[</span><span class="s3">0</span><span class="s1">] </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">KeyError(</span><span class="s2">&quot;This reference has been deleted&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">selection[</span><span class="s3">1</span><span class="s1">:</span><span class="s3">3</span><span class="s1">] == [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]:</span>
            <span class="s5"># URL only</span>
            <span class="s0">return </span><span class="s1">selection[:</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s5"># URL, offset, size</span>
        <span class="s0">return </span><span class="s1">selection[:</span><span class="s3">3</span><span class="s1">]</span>

    <span class="s1">@lru_cache(</span><span class="s3">4096</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">_key_to_record(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s4">&quot;&quot;&quot;Details needed to construct a reference for one key&quot;&quot;&quot;</span>
        <span class="s1">field</span><span class="s0">, </span><span class="s1">chunk = key.split(</span><span class="s2">&quot;/&quot;</span><span class="s1">)</span>
        <span class="s1">chunk_sizes = self._get_chunk_sizes(field)</span>
        <span class="s0">if </span><span class="s1">len(chunk_sizes) == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span>
        <span class="s1">chunk_idx = [int(c) </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">chunk.split(</span><span class="s2">&quot;.&quot;</span><span class="s1">)]</span>
        <span class="s1">chunk_number = ravel_multi_index(chunk_idx</span><span class="s0">, </span><span class="s1">chunk_sizes)</span>
        <span class="s1">record = chunk_number // self.record_size</span>
        <span class="s1">ri = chunk_number % self.record_size</span>
        <span class="s0">return </span><span class="s1">record</span><span class="s0">, </span><span class="s1">ri</span><span class="s0">, </span><span class="s1">len(chunk_sizes)</span>

    <span class="s0">def </span><span class="s1">_get_chunk_sizes(self</span><span class="s0">, </span><span class="s1">field):</span>
        <span class="s4">&quot;&quot;&quot;The number of chunks along each axis for a given field&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">field </span><span class="s0">not in </span><span class="s1">self.chunk_sizes:</span>
            <span class="s1">zarray = self.zmetadata[</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">field</span><span class="s0">}</span><span class="s2">/.zarray&quot;</span><span class="s1">]</span>
            <span class="s1">size_ratio = [</span>
                <span class="s1">math.ceil(s / c) </span><span class="s0">for </span><span class="s1">s</span><span class="s0">, </span><span class="s1">c </span><span class="s0">in </span><span class="s1">zip(zarray[</span><span class="s2">&quot;shape&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">zarray[</span><span class="s2">&quot;chunks&quot;</span><span class="s1">])</span>
            <span class="s1">]</span>
            <span class="s1">self.chunk_sizes[field] = size_ratio</span>
        <span class="s0">return </span><span class="s1">self.chunk_sizes[field]</span>

    <span class="s0">def </span><span class="s1">_generate_record(self</span><span class="s0">, </span><span class="s1">field</span><span class="s0">, </span><span class="s1">record):</span>
        <span class="s4">&quot;&quot;&quot;The references for a given parquet file of a given field&quot;&quot;&quot;</span>
        <span class="s1">refs = self.open_refs(field</span><span class="s0">, </span><span class="s1">record)</span>
        <span class="s1">it = iter(zip(refs.values()))</span>
        <span class="s0">if </span><span class="s1">len(refs) == </span><span class="s3">3</span><span class="s1">:</span>
            <span class="s5"># All urls</span>
            <span class="s0">return </span><span class="s1">(list(t) </span><span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">it)</span>
        <span class="s0">elif </span><span class="s1">len(refs) == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s5"># All raws</span>
            <span class="s0">return </span><span class="s1">refs[</span><span class="s2">&quot;raw&quot;</span><span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s5"># Mix of urls and raws</span>
            <span class="s0">return </span><span class="s1">(list(t[:</span><span class="s3">3</span><span class="s1">]) </span><span class="s0">if not </span><span class="s1">t[</span><span class="s3">3</span><span class="s1">] </span><span class="s0">else </span><span class="s1">t[</span><span class="s3">3</span><span class="s1">] </span><span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">it)</span>

    <span class="s0">def </span><span class="s1">_generate_all_records(self</span><span class="s0">, </span><span class="s1">field):</span>
        <span class="s4">&quot;&quot;&quot;Load all the references within a field by iterating over the parquet files&quot;&quot;&quot;</span>
        <span class="s1">nrec = </span><span class="s3">1</span>
        <span class="s0">for </span><span class="s1">ch </span><span class="s0">in </span><span class="s1">self._get_chunk_sizes(field):</span>
            <span class="s1">nrec *= ch</span>
        <span class="s1">nrec = math.ceil(nrec / self.record_size)</span>
        <span class="s0">for </span><span class="s1">record </span><span class="s0">in </span><span class="s1">range(nrec):</span>
            <span class="s0">yield from </span><span class="s1">self._generate_record(field</span><span class="s0">, </span><span class="s1">record)</span>

    <span class="s0">def </span><span class="s1">values(self):</span>
        <span class="s0">return </span><span class="s1">RefsValuesView(self)</span>

    <span class="s0">def </span><span class="s1">items(self):</span>
        <span class="s0">return </span><span class="s1">RefsItemsView(self)</span>

    <span class="s0">def </span><span class="s1">__hash__(self):</span>
        <span class="s0">return </span><span class="s1">id(self)</span>

    <span class="s1">@lru_cache(</span><span class="s3">20</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s0">return </span><span class="s1">self._load_one_key(key)</span>

    <span class="s0">def </span><span class="s1">__setitem__(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s0">if </span><span class="s2">&quot;/&quot; </span><span class="s0">in </span><span class="s1">key </span><span class="s0">and not </span><span class="s1">self._is_meta(key):</span>
            <span class="s1">field</span><span class="s0">, </span><span class="s1">chunk = key.split(</span><span class="s2">&quot;/&quot;</span><span class="s1">)</span>
            <span class="s1">record</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">_ = self._key_to_record(key)</span>
            <span class="s1">subdict = self._items.setdefault((field</span><span class="s0">, </span><span class="s1">record)</span><span class="s0">, </span><span class="s1">{})</span>
            <span class="s1">subdict[i] = value</span>
            <span class="s0">if </span><span class="s1">len(subdict) == self.record_size:</span>
                <span class="s1">self.write(field</span><span class="s0">, </span><span class="s1">record)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s5"># metadata or top-level</span>
            <span class="s1">self._items[key] = value</span>
            <span class="s1">self.zmetadata[key] = json.loads(</span>
                <span class="s1">value.decode() </span><span class="s0">if </span><span class="s1">isinstance(value</span><span class="s0">, </span><span class="s1">bytes) </span><span class="s0">else </span><span class="s1">value</span>
            <span class="s1">)</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_is_meta(key):</span>
        <span class="s0">return </span><span class="s1">key.startswith(</span><span class="s2">&quot;.z&quot;</span><span class="s1">) </span><span class="s0">or </span><span class="s2">&quot;/.z&quot; </span><span class="s0">in </span><span class="s1">key</span>

    <span class="s0">def </span><span class="s1">__delitem__(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">self._items:</span>
            <span class="s0">del </span><span class="s1">self._items[key]</span>
        <span class="s0">elif </span><span class="s1">key </span><span class="s0">in </span><span class="s1">self.zmetadata:</span>
            <span class="s0">del </span><span class="s1">self.zmetadata[key]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s2">&quot;/&quot; </span><span class="s0">in </span><span class="s1">key </span><span class="s0">and not </span><span class="s1">self._is_meta(key):</span>
                <span class="s1">field</span><span class="s0">, </span><span class="s1">chunk = key.split(</span><span class="s2">&quot;/&quot;</span><span class="s1">)</span>
                <span class="s1">record</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">_ = self._key_to_record(key)</span>
                <span class="s1">subdict = self._items.setdefault((field</span><span class="s0">, </span><span class="s1">record)</span><span class="s0">, </span><span class="s1">{})</span>
                <span class="s1">subdict[chunk] = </span><span class="s0">None</span>
                <span class="s0">if </span><span class="s1">len(subdict) == self.record_size:</span>
                    <span class="s1">self.write(field</span><span class="s0">, </span><span class="s1">record)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s5"># metadata or top-level</span>
                <span class="s1">self._items[key] = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">write(self</span><span class="s0">, </span><span class="s1">field</span><span class="s0">, </span><span class="s1">record</span><span class="s0">, </span><span class="s1">base_url=</span><span class="s0">None, </span><span class="s1">storage_options=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s5"># extra requirements if writing</span>
        <span class="s0">import </span><span class="s1">kerchunk.df</span>
        <span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
        <span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>

        <span class="s5"># TODO: if the dict is incomplete, also load records and merge in</span>
        <span class="s1">partition = self._items[(field</span><span class="s0">, </span><span class="s1">record)]</span>
        <span class="s1">fn = </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">base_url </span><span class="s0">or </span><span class="s1">self.out_root</span><span class="s0">}</span><span class="s2">/</span><span class="s0">{</span><span class="s1">field</span><span class="s0">}</span><span class="s2">/refs.</span><span class="s0">{</span><span class="s1">record</span><span class="s0">}</span><span class="s2">.parq&quot;</span>

        <span class="s5">####</span>
        <span class="s1">paths = np.full(self.record_size</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;O&quot;</span><span class="s1">)</span>
        <span class="s1">offsets = np.zeros(self.record_size</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;int64&quot;</span><span class="s1">)</span>
        <span class="s1">sizes = np.zeros(self.record_size</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;int64&quot;</span><span class="s1">)</span>
        <span class="s1">raws = np.full(self.record_size</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;O&quot;</span><span class="s1">)</span>
        <span class="s1">nraw = </span><span class="s3">0</span>
        <span class="s1">npath = </span><span class="s3">0</span>
        <span class="s0">for </span><span class="s1">j</span><span class="s0">, </span><span class="s1">data </span><span class="s0">in </span><span class="s1">partition.items():</span>
            <span class="s0">if </span><span class="s1">isinstance(data</span><span class="s0">, </span><span class="s1">list):</span>
                <span class="s1">npath += </span><span class="s3">1</span>
                <span class="s1">paths[j] = data[</span><span class="s3">0</span><span class="s1">]</span>
                <span class="s0">if </span><span class="s1">len(data) &gt; </span><span class="s3">1</span><span class="s1">:</span>
                    <span class="s1">offsets[j] = data[</span><span class="s3">1</span><span class="s1">]</span>
                    <span class="s1">sizes[j] = data[</span><span class="s3">2</span><span class="s1">]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">nraw += </span><span class="s3">1</span>
                <span class="s1">raws[j] = kerchunk.df._proc_raw(data)</span>
        <span class="s5"># TODO: only save needed columns</span>
        <span class="s1">df = pd.DataFrame(</span>
            <span class="s1">{</span>
                <span class="s2">&quot;path&quot;</span><span class="s1">: paths</span><span class="s0">,</span>
                <span class="s2">&quot;offset&quot;</span><span class="s1">: offsets</span><span class="s0">,</span>
                <span class="s2">&quot;size&quot;</span><span class="s1">: sizes</span><span class="s0">,</span>
                <span class="s2">&quot;raw&quot;</span><span class="s1">: raws</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">copy=</span><span class="s0">False,</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">df.path.count() / (df.path.nunique() </span><span class="s0">or </span><span class="s3">1</span><span class="s1">) &gt; self.cat_thresh:</span>
            <span class="s1">df[</span><span class="s2">&quot;path&quot;</span><span class="s1">] = df[</span><span class="s2">&quot;path&quot;</span><span class="s1">].astype(</span><span class="s2">&quot;category&quot;</span><span class="s1">)</span>
        <span class="s1">object_encoding = {</span><span class="s2">&quot;raw&quot;</span><span class="s1">: </span><span class="s2">&quot;bytes&quot;</span><span class="s0">, </span><span class="s2">&quot;path&quot;</span><span class="s1">: </span><span class="s2">&quot;utf8&quot;</span><span class="s1">}</span>
        <span class="s1">has_nulls = [</span><span class="s2">&quot;path&quot;</span><span class="s0">, </span><span class="s2">&quot;raw&quot;</span><span class="s1">]</span>

        <span class="s1">self.fs.mkdirs(</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">base_url </span><span class="s0">or </span><span class="s1">self.out_root</span><span class="s0">}</span><span class="s2">/</span><span class="s0">{</span><span class="s1">field</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s0">, </span><span class="s1">exist_ok=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">df.to_parquet(</span>
            <span class="s1">fn</span><span class="s0">,</span>
            <span class="s1">engine=</span><span class="s2">&quot;fastparquet&quot;</span><span class="s0">,</span>
            <span class="s1">storage_options=storage_options</span>
            <span class="s0">or </span><span class="s1">getattr(self.fs</span><span class="s0">, </span><span class="s2">&quot;storage_options&quot;</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">compression=</span><span class="s2">&quot;zstd&quot;</span><span class="s0">,</span>
            <span class="s1">index=</span><span class="s0">False,</span>
            <span class="s1">stats=</span><span class="s0">False,</span>
            <span class="s1">object_encoding=object_encoding</span><span class="s0">,</span>
            <span class="s1">has_nulls=has_nulls</span><span class="s0">,</span>
            <span class="s5"># **kwargs,</span>
        <span class="s1">)</span>
        <span class="s1">partition.clear()</span>
        <span class="s1">self._items.pop((field</span><span class="s0">, </span><span class="s1">record))</span>

    <span class="s0">def </span><span class="s1">flush(self</span><span class="s0">, </span><span class="s1">base_url=</span><span class="s0">None, </span><span class="s1">storage_options=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot;Output any modified or deleted keys 
 
        Parameters 
        ---------- 
        base_url: str 
            Location of the output 
        &quot;&quot;&quot;</span>
        <span class="s5"># write what we have so far and clear sub chunks</span>
        <span class="s0">for </span><span class="s1">thing </span><span class="s0">in </span><span class="s1">list(self._items):</span>
            <span class="s0">if </span><span class="s1">isinstance(thing</span><span class="s0">, </span><span class="s1">tuple):</span>
                <span class="s1">field</span><span class="s0">, </span><span class="s1">record = thing</span>
                <span class="s1">self.write(</span>
                    <span class="s1">field</span><span class="s0">,</span>
                    <span class="s1">record</span><span class="s0">,</span>
                    <span class="s1">base_url=base_url</span><span class="s0">,</span>
                    <span class="s1">storage_options=storage_options</span><span class="s0">,</span>
                <span class="s1">)</span>

        <span class="s5"># gather .zmetadata from self._items and write that too</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">list(self._items):</span>
            <span class="s0">if </span><span class="s1">k != </span><span class="s2">&quot;.zmetadata&quot; </span><span class="s0">and </span><span class="s2">&quot;.z&quot; </span><span class="s0">in </span><span class="s1">k:</span>
                <span class="s1">self.zmetadata[k] = json.loads(self._items.pop(k))</span>
        <span class="s1">met = {</span><span class="s2">&quot;metadata&quot;</span><span class="s1">: self.zmetadata</span><span class="s0">, </span><span class="s2">&quot;record_size&quot;</span><span class="s1">: self.record_size}</span>
        <span class="s1">self._items[</span><span class="s2">&quot;.zmetadata&quot;</span><span class="s1">] = json.dumps(met).encode()</span>
        <span class="s1">self.fs.pipe(</span>
            <span class="s2">&quot;/&quot;</span><span class="s1">.join([base_url </span><span class="s0">or </span><span class="s1">self.out_root</span><span class="s0">, </span><span class="s2">&quot;.zmetadata&quot;</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">self._items[</span><span class="s2">&quot;.zmetadata&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s5"># TODO: only clear those that we wrote to?</span>
        <span class="s1">self.open_refs.cache_clear()</span>

    <span class="s0">def </span><span class="s1">__len__(self):</span>
        <span class="s5"># Caveat: This counts expected references, not actual</span>
        <span class="s1">count = </span><span class="s3">0</span>
        <span class="s0">for </span><span class="s1">field </span><span class="s0">in </span><span class="s1">self.listdir():</span>
            <span class="s0">if </span><span class="s1">field.startswith(</span><span class="s2">&quot;.&quot;</span><span class="s1">):</span>
                <span class="s1">count += </span><span class="s3">1</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">chunk_sizes = self._get_chunk_sizes(field)</span>
                <span class="s1">nchunks = self.np.product(chunk_sizes)</span>
                <span class="s1">count += nchunks</span>
        <span class="s1">count += len(self.zmetadata)  </span><span class="s5"># all metadata keys</span>
        <span class="s1">count += len(self._items)  </span><span class="s5"># the metadata file itself</span>
        <span class="s0">return </span><span class="s1">count</span>

    <span class="s0">def </span><span class="s1">__iter__(self):</span>
        <span class="s5"># Caveat: Note that this generates all expected keys, but does not</span>
        <span class="s5"># account for reference keys that are missing.</span>
        <span class="s1">metas = set(self.zmetadata)</span>
        <span class="s1">metas.update(self._items)</span>
        <span class="s0">for </span><span class="s1">bit </span><span class="s0">in </span><span class="s1">metas:</span>
            <span class="s0">if </span><span class="s1">isinstance(bit</span><span class="s0">, </span><span class="s1">str):</span>
                <span class="s0">yield </span><span class="s1">bit</span>
        <span class="s0">for </span><span class="s1">field </span><span class="s0">in </span><span class="s1">self.listdir():</span>
            <span class="s0">yield from </span><span class="s1">self._keys_in_field(field)</span>

    <span class="s0">def </span><span class="s1">__contains__(self</span><span class="s0">, </span><span class="s1">item):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">self._load_one_key(item)</span>
            <span class="s0">return True</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">_keys_in_field(self</span><span class="s0">, </span><span class="s1">field):</span>
        <span class="s4">&quot;&quot;&quot;List key names in given field 
 
        Produces strings like &quot;field/x.y&quot; appropriate from the chunking of the array 
        &quot;&quot;&quot;</span>
        <span class="s1">chunk_sizes = self._get_chunk_sizes(field)</span>
        <span class="s0">if </span><span class="s1">len(chunk_sizes) == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s0">yield </span><span class="s1">field + </span><span class="s2">&quot;/0&quot;</span>
            <span class="s0">return</span>
        <span class="s1">inds = itertools.product(*(range(i) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">chunk_sizes))</span>
        <span class="s0">for </span><span class="s1">ind </span><span class="s0">in </span><span class="s1">inds:</span>
            <span class="s0">yield </span><span class="s1">field + </span><span class="s2">&quot;/&quot; </span><span class="s1">+ </span><span class="s2">&quot;.&quot;</span><span class="s1">.join([str(c) </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">ind])</span>


<span class="s0">class </span><span class="s1">ReferenceFileSystem(AsyncFileSystem):</span>
    <span class="s4">&quot;&quot;&quot;View byte ranges of some other file as a file system 
    Initial version: single file system target, which must support 
    async, and must allow start and end args in _cat_file. Later versions 
    may allow multiple arbitrary URLs for the targets. 
    This FileSystem is read-only. It is designed to be used with async 
    targets (for now). This FileSystem only allows whole-file access, no 
    ``open``. We do not get original file details from the target FS. 
    Configuration is by passing a dict of references at init, or a URL to 
    a JSON file containing the same; this dict 
    can also contain concrete data for some set of paths. 
    Reference dict format: 
    {path0: bytes_data, path1: (target_url, offset, size)} 
    https://github.com/fsspec/kerchunk/blob/main/README.md 
    &quot;&quot;&quot;</span>

    <span class="s1">protocol = </span><span class="s2">&quot;reference&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">fo</span><span class="s0">,</span>
        <span class="s1">target=</span><span class="s0">None,</span>
        <span class="s1">ref_storage_args=</span><span class="s0">None,</span>
        <span class="s1">target_protocol=</span><span class="s0">None,</span>
        <span class="s1">target_options=</span><span class="s0">None,</span>
        <span class="s1">remote_protocol=</span><span class="s0">None,</span>
        <span class="s1">remote_options=</span><span class="s0">None,</span>
        <span class="s1">fs=</span><span class="s0">None,</span>
        <span class="s1">template_overrides=</span><span class="s0">None,</span>
        <span class="s1">simple_templates=</span><span class="s0">True,</span>
        <span class="s1">max_gap=</span><span class="s3">64_000</span><span class="s0">,</span>
        <span class="s1">max_block=</span><span class="s3">256_000_000</span><span class="s0">,</span>
        <span class="s1">cache_size=</span><span class="s3">128</span><span class="s0">,</span>
        <span class="s1">**kwargs</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        fo : dict or str 
            The set of references to use for this instance, with a structure as above. 
            If str referencing a JSON file, will use fsspec.open, in conjunction 
            with target_options and target_protocol to open and parse JSON at this 
            location. If a directory, then assume references are a set of parquet 
            files to be loaded lazily. 
        target : str 
            For any references having target_url as None, this is the default file 
            target to use 
        ref_storage_args : dict 
            If references is a str, use these kwargs for loading the JSON file. 
            Deprecated: use target_options instead. 
        target_protocol : str 
            Used for loading the reference file, if it is a path. If None, protocol 
            will be derived from the given path 
        target_options : dict 
            Extra FS options for loading the reference file ``fo``, if given as a path 
        remote_protocol : str 
            The protocol of the filesystem on which the references will be evaluated 
            (unless fs is provided). If not given, will be derived from the first 
            URL that has a protocol in the templates or in the references, in that 
            order. 
        remote_options : dict 
            kwargs to go with remote_protocol 
        fs : AbstractFileSystem | dict(str, (AbstractFileSystem | dict)) 
            Directly provide a file system(s): 
                - a single filesystem instance 
                - a dict of protocol:filesystem, where each value is either a filesystem 
                  instance, or a dict of kwargs that can be used to create in 
                  instance for the given protocol 
 
            If this is given, remote_options and remote_protocol are ignored. 
        template_overrides : dict 
            Swap out any templates in the references file with these - useful for 
            testing. 
        simple_templates: bool 
            Whether templates can be processed with simple replace (True) or if 
            jinja  is needed (False, much slower). All reference sets produced by 
            ``kerchunk`` are simple in this sense, but the spec allows for complex. 
        max_gap, max_block: int 
            For merging multiple concurrent requests to the same remote file. 
            Neighboring byte ranges will only be merged when their 
            inter-range gap is &lt;= ``max_gap``. Default is 64KB. Set to 0 
            to only merge when it requires no extra bytes. Pass a negative 
            number to disable merging, appropriate for local target files. 
            Neighboring byte ranges will only be merged when the size of 
            the aggregated range is &lt;= ``max_block``. Default is 256MB. 
        cache_size : int 
            Maximum size of LRU cache, where cache_size*record_size denotes 
            the total number of references that can be loaded in memory at once. 
            Only used for lazily loaded references. 
        kwargs : passed to parent class 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(**kwargs)</span>
        <span class="s1">self.target = target</span>
        <span class="s1">self.template_overrides = template_overrides</span>
        <span class="s1">self.simple_templates = simple_templates</span>
        <span class="s1">self.templates = {}</span>
        <span class="s1">self.fss = {}</span>
        <span class="s1">self._dircache = {}</span>
        <span class="s1">self.max_gap = max_gap</span>
        <span class="s1">self.max_block = max_block</span>
        <span class="s0">if </span><span class="s1">isinstance(fo</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s1">dic = dict(</span>
                <span class="s1">**(ref_storage_args </span><span class="s0">or </span><span class="s1">target_options </span><span class="s0">or </span><span class="s1">{})</span><span class="s0">, </span><span class="s1">protocol=target_protocol</span>
            <span class="s1">)</span>
            <span class="s1">ref_fs</span><span class="s0">, </span><span class="s1">fo2 = fsspec.core.url_to_fs(fo</span><span class="s0">, </span><span class="s1">**dic)</span>
            <span class="s0">if </span><span class="s1">ref_fs.isfile(fo):</span>
                <span class="s5"># text JSON</span>
                <span class="s0">with </span><span class="s1">fsspec.open(fo</span><span class="s0">, </span><span class="s2">&quot;rb&quot;</span><span class="s0">, </span><span class="s1">**dic) </span><span class="s0">as </span><span class="s1">f:</span>
                    <span class="s1">logger.info(</span><span class="s2">&quot;Read reference from URL %s&quot;</span><span class="s0">, </span><span class="s1">fo)</span>
                    <span class="s1">text = json.load(f)</span>
                <span class="s1">self._process_references(text</span><span class="s0">, </span><span class="s1">template_overrides)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s5"># Lazy parquet refs</span>
                <span class="s1">logger.info(</span><span class="s2">&quot;Open lazy reference dict from URL %s&quot;</span><span class="s0">, </span><span class="s1">fo)</span>
                <span class="s1">self.references = LazyReferenceMapper(</span>
                    <span class="s1">fo2</span><span class="s0">,</span>
                    <span class="s1">fs=ref_fs</span><span class="s0">,</span>
                    <span class="s1">cache_size=cache_size</span><span class="s0">,</span>
                <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s5"># dictionaries</span>
            <span class="s1">self._process_references(fo</span><span class="s0">, </span><span class="s1">template_overrides)</span>
        <span class="s0">if </span><span class="s1">isinstance(fs</span><span class="s0">, </span><span class="s1">dict):</span>
            <span class="s1">self.fss = {</span>
                <span class="s1">k: (</span>
                    <span class="s1">fsspec.filesystem(k.split(</span><span class="s2">&quot;:&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">**opts)</span>
                    <span class="s0">if </span><span class="s1">isinstance(opts</span><span class="s0">, </span><span class="s1">dict)</span>
                    <span class="s0">else </span><span class="s1">opts</span>
                <span class="s1">)</span>
                <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">opts </span><span class="s0">in </span><span class="s1">fs.items()</span>
            <span class="s1">}</span>
            <span class="s0">if None not in </span><span class="s1">self.fss:</span>
                <span class="s1">self.fss[</span><span class="s0">None</span><span class="s1">] = filesystem(</span><span class="s2">&quot;file&quot;</span><span class="s1">)</span>
            <span class="s0">return</span>
        <span class="s0">if </span><span class="s1">fs </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s5"># single remote FS</span>
            <span class="s1">remote_protocol = (</span>
                <span class="s1">fs.protocol[</span><span class="s3">0</span><span class="s1">] </span><span class="s0">if </span><span class="s1">isinstance(fs.protocol</span><span class="s0">, </span><span class="s1">tuple) </span><span class="s0">else </span><span class="s1">fs.protocol</span>
            <span class="s1">)</span>
            <span class="s1">self.fss[remote_protocol] = fs</span>

        <span class="s0">if </span><span class="s1">remote_protocol </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s5"># get single protocol from any templates</span>
            <span class="s0">for </span><span class="s1">ref </span><span class="s0">in </span><span class="s1">self.templates.values():</span>
                <span class="s0">if </span><span class="s1">callable(ref):</span>
                    <span class="s1">ref = ref()</span>
                <span class="s1">protocol</span><span class="s0">, </span><span class="s1">_ = fsspec.core.split_protocol(ref)</span>
                <span class="s0">if </span><span class="s1">protocol </span><span class="s0">and </span><span class="s1">protocol </span><span class="s0">not in </span><span class="s1">self.fss:</span>
                    <span class="s1">fs = filesystem(protocol</span><span class="s0">, </span><span class="s1">**(remote_options </span><span class="s0">or </span><span class="s1">{}))</span>
                    <span class="s1">self.fss[protocol] = fs</span>
        <span class="s0">if </span><span class="s1">remote_protocol </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s5"># get single protocol from references</span>
            <span class="s0">for </span><span class="s1">ref </span><span class="s0">in </span><span class="s1">self.references.values():</span>
                <span class="s0">if </span><span class="s1">callable(ref):</span>
                    <span class="s1">ref = ref()</span>
                <span class="s0">if </span><span class="s1">isinstance(ref</span><span class="s0">, </span><span class="s1">list) </span><span class="s0">and </span><span class="s1">ref[</span><span class="s3">0</span><span class="s1">]:</span>
                    <span class="s1">protocol</span><span class="s0">, </span><span class="s1">_ = fsspec.core.split_protocol(ref[</span><span class="s3">0</span><span class="s1">])</span>
                    <span class="s0">if </span><span class="s1">protocol </span><span class="s0">not in </span><span class="s1">self.fss:</span>
                        <span class="s1">fs = filesystem(protocol</span><span class="s0">, </span><span class="s1">**(remote_options </span><span class="s0">or </span><span class="s1">{}))</span>
                        <span class="s1">self.fss[protocol] = fs</span>
                        <span class="s5"># only use first remote URL</span>
                        <span class="s0">break</span>

        <span class="s0">if </span><span class="s1">remote_protocol </span><span class="s0">and </span><span class="s1">remote_protocol </span><span class="s0">not in </span><span class="s1">self.fss:</span>
            <span class="s1">fs = filesystem(remote_protocol</span><span class="s0">, </span><span class="s1">**(remote_options </span><span class="s0">or </span><span class="s1">{}))</span>
            <span class="s1">self.fss[remote_protocol] = fs</span>

        <span class="s1">self.fss[</span><span class="s0">None</span><span class="s1">] = fs </span><span class="s0">or </span><span class="s1">filesystem(</span><span class="s2">&quot;file&quot;</span><span class="s1">)  </span><span class="s5"># default one</span>

    <span class="s0">def </span><span class="s1">_cat_common(self</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">start=</span><span class="s0">None, </span><span class="s1">end=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">path = self._strip_protocol(path)</span>
        <span class="s1">logger.debug(</span><span class="s2">f&quot;cat: </span><span class="s0">{</span><span class="s1">path</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">part = self.references[path]</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s0">raise </span><span class="s1">FileNotFoundError(path)</span>
        <span class="s0">if </span><span class="s1">isinstance(part</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s1">part = part.encode()</span>
        <span class="s0">if </span><span class="s1">isinstance(part</span><span class="s0">, </span><span class="s1">bytes):</span>
            <span class="s1">logger.debug(</span><span class="s2">f&quot;Reference: </span><span class="s0">{</span><span class="s1">path</span><span class="s0">}</span><span class="s2">, type bytes&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">part.startswith(</span><span class="s6">b&quot;base64:&quot;</span><span class="s1">):</span>
                <span class="s1">part = base64.b64decode(part[</span><span class="s3">7</span><span class="s1">:])</span>
            <span class="s0">return </span><span class="s1">part</span><span class="s0">, None, None</span>

        <span class="s0">if </span><span class="s1">len(part) == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">logger.debug(</span><span class="s2">f&quot;Reference: </span><span class="s0">{</span><span class="s1">path</span><span class="s0">}</span><span class="s2">, whole file =&gt; </span><span class="s0">{</span><span class="s1">part</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>
            <span class="s1">url = part[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">start1</span><span class="s0">, </span><span class="s1">end1 = start</span><span class="s0">, </span><span class="s1">end</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">url</span><span class="s0">, </span><span class="s1">start0</span><span class="s0">, </span><span class="s1">size = part</span>
            <span class="s1">logger.debug(</span><span class="s2">f&quot;Reference: </span><span class="s0">{</span><span class="s1">path</span><span class="s0">} </span><span class="s2">=&gt; </span><span class="s0">{</span><span class="s1">url</span><span class="s0">}</span><span class="s2">, offset </span><span class="s0">{</span><span class="s1">start0</span><span class="s0">}</span><span class="s2">, size </span><span class="s0">{</span><span class="s1">size</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>
            <span class="s1">end0 = start0 + size</span>

            <span class="s0">if </span><span class="s1">start </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">start &gt;= </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s1">start1 = start0 + start</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">start1 = end0 + start</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">start1 = start0</span>
            <span class="s0">if </span><span class="s1">end </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">end &gt;= </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s1">end1 = start0 + end</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">end1 = end0 + end</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">end1 = end0</span>
        <span class="s0">if </span><span class="s1">url </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">url = self.target</span>
        <span class="s0">return </span><span class="s1">url</span><span class="s0">, </span><span class="s1">start1</span><span class="s0">, </span><span class="s1">end1</span>

    <span class="s0">async def </span><span class="s1">_cat_file(self</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">start=</span><span class="s0">None, </span><span class="s1">end=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
        <span class="s1">part_or_url</span><span class="s0">, </span><span class="s1">start0</span><span class="s0">, </span><span class="s1">end0 = self._cat_common(path</span><span class="s0">, </span><span class="s1">start=start</span><span class="s0">, </span><span class="s1">end=end)</span>
        <span class="s0">if </span><span class="s1">isinstance(part_or_url</span><span class="s0">, </span><span class="s1">bytes):</span>
            <span class="s0">return </span><span class="s1">part_or_url[start:end]</span>
        <span class="s1">protocol</span><span class="s0">, </span><span class="s1">_ = split_protocol(part_or_url)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">await </span><span class="s1">self.fss[protocol]._cat_file(part_or_url</span><span class="s0">, </span><span class="s1">start=start</span><span class="s0">, </span><span class="s1">end=end)</span>
        <span class="s0">except </span><span class="s1">Exception </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s0">raise </span><span class="s1">ReferenceNotReachable(path</span><span class="s0">, </span><span class="s1">part_or_url) </span><span class="s0">from </span><span class="s1">e</span>

    <span class="s0">def </span><span class="s1">cat_file(self</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">start=</span><span class="s0">None, </span><span class="s1">end=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
        <span class="s1">part_or_url</span><span class="s0">, </span><span class="s1">start0</span><span class="s0">, </span><span class="s1">end0 = self._cat_common(path</span><span class="s0">, </span><span class="s1">start=start</span><span class="s0">, </span><span class="s1">end=end)</span>
        <span class="s0">if </span><span class="s1">isinstance(part_or_url</span><span class="s0">, </span><span class="s1">bytes):</span>
            <span class="s0">return </span><span class="s1">part_or_url[start:end]</span>
        <span class="s1">protocol</span><span class="s0">, </span><span class="s1">_ = split_protocol(part_or_url)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.fss[protocol].cat_file(part_or_url</span><span class="s0">, </span><span class="s1">start=start0</span><span class="s0">, </span><span class="s1">end=end0)</span>
        <span class="s0">except </span><span class="s1">Exception </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s0">raise </span><span class="s1">ReferenceNotReachable(path</span><span class="s0">, </span><span class="s1">part_or_url) </span><span class="s0">from </span><span class="s1">e</span>

    <span class="s0">def </span><span class="s1">pipe_file(self</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">**_):</span>
        <span class="s4">&quot;&quot;&quot;Temporarily add binary data or reference as a file&quot;&quot;&quot;</span>
        <span class="s1">self.references[path] = value</span>

    <span class="s0">async def </span><span class="s1">_get_file(self</span><span class="s0">, </span><span class="s1">rpath</span><span class="s0">, </span><span class="s1">lpath</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">if </span><span class="s1">self.isdir(rpath):</span>
            <span class="s0">return </span><span class="s1">os.makedirs(lpath</span><span class="s0">, </span><span class="s1">exist_ok=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">data = </span><span class="s0">await </span><span class="s1">self._cat_file(rpath)</span>
        <span class="s0">with </span><span class="s1">open(lpath</span><span class="s0">, </span><span class="s2">&quot;wb&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">f:</span>
            <span class="s1">f.write(data)</span>

    <span class="s0">def </span><span class="s1">get_file(self</span><span class="s0">, </span><span class="s1">rpath</span><span class="s0">, </span><span class="s1">lpath</span><span class="s0">, </span><span class="s1">callback=_DEFAULT_CALLBACK</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">if </span><span class="s1">self.isdir(rpath):</span>
            <span class="s0">return </span><span class="s1">os.makedirs(lpath</span><span class="s0">, </span><span class="s1">exist_ok=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">data = self.cat_file(rpath</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">callback.set_size(len(data))</span>
        <span class="s0">if </span><span class="s1">isfilelike(lpath):</span>
            <span class="s1">lpath.write(data)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">with </span><span class="s1">open(lpath</span><span class="s0">, </span><span class="s2">&quot;wb&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">f:</span>
                <span class="s1">f.write(data)</span>
        <span class="s1">callback.absolute_update(len(data))</span>

    <span class="s0">def </span><span class="s1">get(self</span><span class="s0">, </span><span class="s1">rpath</span><span class="s0">, </span><span class="s1">lpath</span><span class="s0">, </span><span class="s1">recursive=</span><span class="s0">False, </span><span class="s1">**kwargs):</span>
        <span class="s0">if </span><span class="s1">recursive:</span>
            <span class="s5"># trigger directory build</span>
            <span class="s1">self.ls(</span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">rpath = self.expand_path(rpath</span><span class="s0">, </span><span class="s1">recursive=recursive)</span>
        <span class="s1">fs = fsspec.filesystem(</span><span class="s2">&quot;file&quot;</span><span class="s0">, </span><span class="s1">auto_mkdir=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">targets = other_paths(rpath</span><span class="s0">, </span><span class="s1">lpath)</span>
        <span class="s0">if </span><span class="s1">recursive:</span>
            <span class="s1">data = self.cat([r </span><span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">rpath </span><span class="s0">if not </span><span class="s1">self.isdir(r)])</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">data = self.cat(rpath)</span>
        <span class="s0">for </span><span class="s1">remote</span><span class="s0">, </span><span class="s1">local </span><span class="s0">in </span><span class="s1">zip(rpath</span><span class="s0">, </span><span class="s1">targets):</span>
            <span class="s0">if </span><span class="s1">remote </span><span class="s0">in </span><span class="s1">data:</span>
                <span class="s1">fs.pipe_file(local</span><span class="s0">, </span><span class="s1">data[remote])</span>

    <span class="s0">def </span><span class="s1">cat(self</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">recursive=</span><span class="s0">False, </span><span class="s1">on_error=</span><span class="s2">&quot;raise&quot;</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">if </span><span class="s1">isinstance(path</span><span class="s0">, </span><span class="s1">str) </span><span class="s0">and </span><span class="s1">recursive:</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError</span>
        <span class="s0">if </span><span class="s1">isinstance(path</span><span class="s0">, </span><span class="s1">list) </span><span class="s0">and </span><span class="s1">(recursive </span><span class="s0">or </span><span class="s1">any(</span><span class="s2">&quot;*&quot; </span><span class="s0">in </span><span class="s1">p </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">path)):</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError</span>
        <span class="s1">proto_dict = _protocol_groups(path</span><span class="s0">, </span><span class="s1">self.references)</span>
        <span class="s1">out = {}</span>
        <span class="s0">for </span><span class="s1">proto</span><span class="s0">, </span><span class="s1">paths </span><span class="s0">in </span><span class="s1">proto_dict.items():</span>
            <span class="s1">fs = self.fss[proto]</span>
            <span class="s1">urls</span><span class="s0">, </span><span class="s1">starts</span><span class="s0">, </span><span class="s1">ends = []</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">[]</span>
            <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">paths:</span>
                <span class="s5"># find references or label not-found. Early exit if any not</span>
                <span class="s5"># found and on_error is &quot;raise&quot;</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">u</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">e = self._cat_common(p)</span>
                    <span class="s1">urls.append(u)</span>
                    <span class="s1">starts.append(s)</span>
                    <span class="s1">ends.append(e)</span>
                <span class="s0">except </span><span class="s1">FileNotFoundError </span><span class="s0">as </span><span class="s1">err:</span>
                    <span class="s0">if </span><span class="s1">on_error == </span><span class="s2">&quot;raise&quot;</span><span class="s1">:</span>
                        <span class="s0">raise</span>
                    <span class="s0">if </span><span class="s1">on_error != </span><span class="s2">&quot;omit&quot;</span><span class="s1">:</span>
                        <span class="s1">out[p] = err</span>

            <span class="s5"># process references into form for merging</span>
            <span class="s1">urls2 = []</span>
            <span class="s1">starts2 = []</span>
            <span class="s1">ends2 = []</span>
            <span class="s1">paths2 = []</span>
            <span class="s1">whole_files = set()</span>
            <span class="s0">for </span><span class="s1">u</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">e</span><span class="s0">, </span><span class="s1">p </span><span class="s0">in </span><span class="s1">zip(urls</span><span class="s0">, </span><span class="s1">starts</span><span class="s0">, </span><span class="s1">ends</span><span class="s0">, </span><span class="s1">paths):</span>
                <span class="s0">if </span><span class="s1">isinstance(u</span><span class="s0">, </span><span class="s1">bytes):</span>
                    <span class="s5"># data</span>
                    <span class="s1">out[p] = u</span>
                <span class="s0">elif </span><span class="s1">s </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s5"># whole file - limits are None, None, but no further</span>
                    <span class="s5"># entries take for this file</span>
                    <span class="s1">whole_files.add(u)</span>
                    <span class="s1">urls2.append(u)</span>
                    <span class="s1">starts2.append(s)</span>
                    <span class="s1">ends2.append(e)</span>
                    <span class="s1">paths2.append(p)</span>
            <span class="s0">for </span><span class="s1">u</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">e</span><span class="s0">, </span><span class="s1">p </span><span class="s0">in </span><span class="s1">zip(urls</span><span class="s0">, </span><span class="s1">starts</span><span class="s0">, </span><span class="s1">ends</span><span class="s0">, </span><span class="s1">paths):</span>
                <span class="s5"># second run to account for files that are to be loaded whole</span>
                <span class="s0">if </span><span class="s1">s </span><span class="s0">is not None and </span><span class="s1">u </span><span class="s0">not in </span><span class="s1">whole_files:</span>
                    <span class="s1">urls2.append(u)</span>
                    <span class="s1">starts2.append(s)</span>
                    <span class="s1">ends2.append(e)</span>
                    <span class="s1">paths2.append(p)</span>

            <span class="s5"># merge and fetch consolidated ranges</span>
            <span class="s1">new_paths</span><span class="s0">, </span><span class="s1">new_starts</span><span class="s0">, </span><span class="s1">new_ends = merge_offset_ranges(</span>
                <span class="s1">list(urls2)</span><span class="s0">,</span>
                <span class="s1">list(starts2)</span><span class="s0">,</span>
                <span class="s1">list(ends2)</span><span class="s0">,</span>
                <span class="s1">sort=</span><span class="s0">True,</span>
                <span class="s1">max_gap=self.max_gap</span><span class="s0">,</span>
                <span class="s1">max_block=self.max_block</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s1">bytes_out = fs.cat_ranges(new_paths</span><span class="s0">, </span><span class="s1">new_starts</span><span class="s0">, </span><span class="s1">new_ends)</span>

            <span class="s5"># unbundle from merged bytes - simple approach</span>
            <span class="s0">for </span><span class="s1">u</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">e</span><span class="s0">, </span><span class="s1">p </span><span class="s0">in </span><span class="s1">zip(urls</span><span class="s0">, </span><span class="s1">starts</span><span class="s0">, </span><span class="s1">ends</span><span class="s0">, </span><span class="s1">paths):</span>
                <span class="s0">if </span><span class="s1">p </span><span class="s0">in </span><span class="s1">out:</span>
                    <span class="s0">continue  </span><span class="s5"># was bytes, already handled</span>
                <span class="s0">for </span><span class="s1">np</span><span class="s0">, </span><span class="s1">ns</span><span class="s0">, </span><span class="s1">ne</span><span class="s0">, </span><span class="s1">b </span><span class="s0">in </span><span class="s1">zip(new_paths</span><span class="s0">, </span><span class="s1">new_starts</span><span class="s0">, </span><span class="s1">new_ends</span><span class="s0">, </span><span class="s1">bytes_out):</span>
                    <span class="s0">if </span><span class="s1">np == u </span><span class="s0">and </span><span class="s1">(ns </span><span class="s0">is None or </span><span class="s1">ne </span><span class="s0">is None</span><span class="s1">):</span>
                        <span class="s0">if </span><span class="s1">isinstance(b</span><span class="s0">, </span><span class="s1">Exception):</span>
                            <span class="s1">out[p] = b</span>
                        <span class="s0">else</span><span class="s1">:</span>
                            <span class="s1">out[p] = b[s:e]</span>
                    <span class="s0">elif </span><span class="s1">np == u </span><span class="s0">and </span><span class="s1">s &gt;= ns </span><span class="s0">and </span><span class="s1">e &lt;= ne:</span>
                        <span class="s0">if </span><span class="s1">isinstance(b</span><span class="s0">, </span><span class="s1">Exception):</span>
                            <span class="s1">out[p] = b</span>
                        <span class="s0">else</span><span class="s1">:</span>
                            <span class="s1">out[p] = b[s - ns : (e - ne) </span><span class="s0">or None</span><span class="s1">]</span>

        <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">out.copy().items():</span>
            <span class="s5"># these were valid references, but fetch failed, so transform exc</span>
            <span class="s0">if </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">Exception) </span><span class="s0">and </span><span class="s1">k </span><span class="s0">in </span><span class="s1">self.references:</span>
                <span class="s1">ex = out[k]</span>
                <span class="s1">new_ex = ReferenceNotReachable(k</span><span class="s0">, </span><span class="s1">self.references[k])</span>
                <span class="s1">new_ex.__cause__ = ex</span>
                <span class="s0">if </span><span class="s1">on_error == </span><span class="s2">&quot;raise&quot;</span><span class="s1">:</span>
                    <span class="s0">raise </span><span class="s1">new_ex</span>
                <span class="s0">elif </span><span class="s1">on_error != </span><span class="s2">&quot;omit&quot;</span><span class="s1">:</span>
                    <span class="s1">out[k] = new_ex</span>

        <span class="s0">if </span><span class="s1">len(out) == </span><span class="s3">1 </span><span class="s0">and </span><span class="s1">isinstance(path</span><span class="s0">, </span><span class="s1">str) </span><span class="s0">and </span><span class="s2">&quot;*&quot; </span><span class="s0">not in </span><span class="s1">path:</span>
            <span class="s0">return </span><span class="s1">_first(out)</span>
        <span class="s0">return </span><span class="s1">out</span>

    <span class="s0">def </span><span class="s1">_process_references(self</span><span class="s0">, </span><span class="s1">references</span><span class="s0">, </span><span class="s1">template_overrides=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">vers = references.get(</span><span class="s2">&quot;version&quot;</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">vers </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self._process_references0(references)</span>
        <span class="s0">elif </span><span class="s1">vers == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">self._process_references1(references</span><span class="s0">, </span><span class="s1">template_overrides=template_overrides)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">f&quot;Unknown reference spec version: </span><span class="s0">{</span><span class="s1">vers</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>
        <span class="s5"># TODO: we make dircache by iterating over all entries, but for Spec &gt;= 1,</span>
        <span class="s5">#  can replace with programmatic. Is it even needed for mapper interface?</span>

    <span class="s0">def </span><span class="s1">_process_references0(self</span><span class="s0">, </span><span class="s1">references):</span>
        <span class="s4">&quot;&quot;&quot;Make reference dict for Spec Version 0&quot;&quot;&quot;</span>
        <span class="s1">self.references = references</span>

    <span class="s0">def </span><span class="s1">_process_references1(self</span><span class="s0">, </span><span class="s1">references</span><span class="s0">, </span><span class="s1">template_overrides=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if not </span><span class="s1">self.simple_templates </span><span class="s0">or </span><span class="s1">self.templates:</span>
            <span class="s0">import </span><span class="s1">jinja2</span>
        <span class="s1">self.references = {}</span>
        <span class="s1">self._process_templates(references.get(</span><span class="s2">&quot;templates&quot;</span><span class="s0">, </span><span class="s1">{}))</span>

        <span class="s1">@lru_cache(</span><span class="s3">1000</span><span class="s1">)</span>
        <span class="s0">def </span><span class="s1">_render_jinja(u):</span>
            <span class="s0">return </span><span class="s1">jinja2.Template(u).render(**self.templates)</span>

        <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">references.get(</span><span class="s2">&quot;refs&quot;</span><span class="s0">, </span><span class="s1">{}).items():</span>
            <span class="s0">if </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">str):</span>
                <span class="s0">if </span><span class="s1">v.startswith(</span><span class="s2">&quot;base64:&quot;</span><span class="s1">):</span>
                    <span class="s1">self.references[k] = base64.b64decode(v[</span><span class="s3">7</span><span class="s1">:])</span>
                <span class="s1">self.references[k] = v</span>
            <span class="s0">elif </span><span class="s1">self.templates:</span>
                <span class="s1">u = v[</span><span class="s3">0</span><span class="s1">]</span>
                <span class="s0">if </span><span class="s2">&quot;{{&quot; </span><span class="s0">in </span><span class="s1">u:</span>
                    <span class="s0">if </span><span class="s1">self.simple_templates:</span>
                        <span class="s1">u = (</span>
                            <span class="s1">u.replace(</span><span class="s2">&quot;{{&quot;</span><span class="s0">, </span><span class="s2">&quot;{&quot;</span><span class="s1">)</span>
                            <span class="s1">.replace(</span><span class="s2">&quot;}}&quot;</span><span class="s0">, </span><span class="s2">&quot;}&quot;</span><span class="s1">)</span>
                            <span class="s1">.format(**self.templates)</span>
                        <span class="s1">)</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">u = _render_jinja(u)</span>
                <span class="s1">self.references[k] = [u] </span><span class="s0">if </span><span class="s1">len(v) == </span><span class="s3">1 </span><span class="s0">else </span><span class="s1">[u</span><span class="s0">, </span><span class="s1">v[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">v[</span><span class="s3">2</span><span class="s1">]]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.references[k] = v</span>
        <span class="s1">self.references.update(self._process_gen(references.get(</span><span class="s2">&quot;gen&quot;</span><span class="s0">, </span><span class="s1">[])))</span>

    <span class="s0">def </span><span class="s1">_process_templates(self</span><span class="s0">, </span><span class="s1">tmp):</span>
        <span class="s1">self.templates = {}</span>
        <span class="s0">if </span><span class="s1">self.template_overrides </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">tmp.update(self.template_overrides)</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">tmp.items():</span>
            <span class="s0">if </span><span class="s2">&quot;{{&quot; </span><span class="s0">in </span><span class="s1">v:</span>
                <span class="s0">import </span><span class="s1">jinja2</span>

                <span class="s1">self.templates[k] = </span><span class="s0">lambda </span><span class="s1">temp=v</span><span class="s0">, </span><span class="s1">**kwargs: jinja2.Template(</span>
                    <span class="s1">temp</span>
                <span class="s1">).render(**kwargs)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.templates[k] = v</span>

    <span class="s0">def </span><span class="s1">_process_gen(self</span><span class="s0">, </span><span class="s1">gens):</span>
        <span class="s1">out = {}</span>
        <span class="s0">for </span><span class="s1">gen </span><span class="s0">in </span><span class="s1">gens:</span>
            <span class="s1">dimension = {</span>
                <span class="s1">k: v</span>
                <span class="s0">if </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">list)</span>
                <span class="s0">else </span><span class="s1">range(v.get(</span><span class="s2">&quot;start&quot;</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">v[</span><span class="s2">&quot;stop&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">v.get(</span><span class="s2">&quot;step&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
                <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">gen[</span><span class="s2">&quot;dimensions&quot;</span><span class="s1">].items()</span>
            <span class="s1">}</span>
            <span class="s1">products = (</span>
                <span class="s1">dict(zip(dimension.keys()</span><span class="s0">, </span><span class="s1">values))</span>
                <span class="s0">for </span><span class="s1">values </span><span class="s0">in </span><span class="s1">itertools.product(*dimension.values())</span>
            <span class="s1">)</span>
            <span class="s0">for </span><span class="s1">pr </span><span class="s0">in </span><span class="s1">products:</span>
                <span class="s0">import </span><span class="s1">jinja2</span>

                <span class="s1">key = jinja2.Template(gen[</span><span class="s2">&quot;key&quot;</span><span class="s1">]).render(**pr</span><span class="s0">, </span><span class="s1">**self.templates)</span>
                <span class="s1">url = jinja2.Template(gen[</span><span class="s2">&quot;url&quot;</span><span class="s1">]).render(**pr</span><span class="s0">, </span><span class="s1">**self.templates)</span>
                <span class="s0">if </span><span class="s1">(</span><span class="s2">&quot;offset&quot; </span><span class="s0">in </span><span class="s1">gen) </span><span class="s0">and </span><span class="s1">(</span><span class="s2">&quot;length&quot; </span><span class="s0">in </span><span class="s1">gen):</span>
                    <span class="s1">offset = int(</span>
                        <span class="s1">jinja2.Template(gen[</span><span class="s2">&quot;offset&quot;</span><span class="s1">]).render(**pr</span><span class="s0">, </span><span class="s1">**self.templates)</span>
                    <span class="s1">)</span>
                    <span class="s1">length = int(</span>
                        <span class="s1">jinja2.Template(gen[</span><span class="s2">&quot;length&quot;</span><span class="s1">]).render(**pr</span><span class="s0">, </span><span class="s1">**self.templates)</span>
                    <span class="s1">)</span>
                    <span class="s1">out[key] = [url</span><span class="s0">, </span><span class="s1">offset</span><span class="s0">, </span><span class="s1">length]</span>
                <span class="s0">elif </span><span class="s1">(</span><span class="s2">&quot;offset&quot; </span><span class="s0">in </span><span class="s1">gen) ^ (</span><span class="s2">&quot;length&quot; </span><span class="s0">in </span><span class="s1">gen):</span>
                    <span class="s0">raise </span><span class="s1">ValueError(</span>
                        <span class="s2">&quot;Both 'offset' and 'length' are required for a &quot;</span>
                        <span class="s2">&quot;reference generator entry if either is provided.&quot;</span>
                    <span class="s1">)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">out[key] = [url]</span>
        <span class="s0">return </span><span class="s1">out</span>

    <span class="s0">def </span><span class="s1">_dircache_from_items(self):</span>
        <span class="s1">self.dircache = {</span><span class="s2">&quot;&quot;</span><span class="s1">: []}</span>
        <span class="s1">it = self.references.items()</span>
        <span class="s0">for </span><span class="s1">path</span><span class="s0">, </span><span class="s1">part </span><span class="s0">in </span><span class="s1">it:</span>
            <span class="s0">if </span><span class="s1">isinstance(part</span><span class="s0">, </span><span class="s1">(bytes</span><span class="s0">, </span><span class="s1">str)):</span>
                <span class="s1">size = len(part)</span>
            <span class="s0">elif </span><span class="s1">len(part) == </span><span class="s3">1</span><span class="s1">:</span>
                <span class="s1">size = </span><span class="s0">None</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">_</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">size = part</span>
            <span class="s1">par = path.rsplit(</span><span class="s2">&quot;/&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">] </span><span class="s0">if </span><span class="s2">&quot;/&quot; </span><span class="s0">in </span><span class="s1">path </span><span class="s0">else </span><span class="s2">&quot;&quot;</span>
            <span class="s1">par0 = par</span>
            <span class="s0">while </span><span class="s1">par0 </span><span class="s0">and </span><span class="s1">par0 </span><span class="s0">not in </span><span class="s1">self.dircache:</span>
                <span class="s5"># build parent directories</span>
                <span class="s1">self.dircache[par0] = []</span>
                <span class="s1">self.dircache.setdefault(</span>
                    <span class="s1">par0.rsplit(</span><span class="s2">&quot;/&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">] </span><span class="s0">if </span><span class="s2">&quot;/&quot; </span><span class="s0">in </span><span class="s1">par0 </span><span class="s0">else </span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s1">[]</span>
                <span class="s1">).append({</span><span class="s2">&quot;name&quot;</span><span class="s1">: par0</span><span class="s0">, </span><span class="s2">&quot;type&quot;</span><span class="s1">: </span><span class="s2">&quot;directory&quot;</span><span class="s0">, </span><span class="s2">&quot;size&quot;</span><span class="s1">: </span><span class="s3">0</span><span class="s1">})</span>
                <span class="s1">par0 = self._parent(par0)</span>

            <span class="s1">self.dircache[par].append({</span><span class="s2">&quot;name&quot;</span><span class="s1">: path</span><span class="s0">, </span><span class="s2">&quot;type&quot;</span><span class="s1">: </span><span class="s2">&quot;file&quot;</span><span class="s0">, </span><span class="s2">&quot;size&quot;</span><span class="s1">: size})</span>

    <span class="s0">def </span><span class="s1">_open(self</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">mode=</span><span class="s2">&quot;rb&quot;</span><span class="s0">, </span><span class="s1">block_size=</span><span class="s0">None, </span><span class="s1">cache_options=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
        <span class="s1">data = self.cat_file(path)  </span><span class="s5"># load whole chunk into memory</span>
        <span class="s0">return </span><span class="s1">io.BytesIO(data)</span>

    <span class="s0">def </span><span class="s1">ls(self</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">detail=</span><span class="s0">True, </span><span class="s1">**kwargs):</span>
        <span class="s1">path = self._strip_protocol(path)</span>
        <span class="s0">if </span><span class="s1">isinstance(self.references</span><span class="s0">, </span><span class="s1">LazyReferenceMapper):</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">self.references.ls(path</span><span class="s0">, </span><span class="s1">detail)</span>
            <span class="s0">except </span><span class="s1">KeyError:</span>
                <span class="s0">pass</span>
            <span class="s0">raise </span><span class="s1">FileNotFoundError(</span><span class="s2">f&quot;'</span><span class="s0">{</span><span class="s1">path</span><span class="s0">}</span><span class="s2">' is not a known key&quot;</span><span class="s1">)</span>
        <span class="s0">if not </span><span class="s1">self.dircache:</span>
            <span class="s1">self._dircache_from_items()</span>
        <span class="s1">out = self._ls_from_cache(path)</span>
        <span class="s0">if </span><span class="s1">out </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">FileNotFoundError(path)</span>
        <span class="s0">if </span><span class="s1">detail:</span>
            <span class="s0">return </span><span class="s1">out</span>
        <span class="s0">return </span><span class="s1">[o[</span><span class="s2">&quot;name&quot;</span><span class="s1">] </span><span class="s0">for </span><span class="s1">o </span><span class="s0">in </span><span class="s1">out]</span>

    <span class="s0">def </span><span class="s1">exists(self</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">**kwargs):  </span><span class="s5"># overwrite auto-sync version</span>
        <span class="s0">return </span><span class="s1">self.isdir(path) </span><span class="s0">or </span><span class="s1">self.isfile(path)</span>

    <span class="s0">def </span><span class="s1">isdir(self</span><span class="s0">, </span><span class="s1">path):  </span><span class="s5"># overwrite auto-sync version</span>
        <span class="s0">if </span><span class="s1">self.dircache:</span>
            <span class="s0">return </span><span class="s1">path </span><span class="s0">in </span><span class="s1">self.dircache</span>
        <span class="s0">elif </span><span class="s1">isinstance(self.references</span><span class="s0">, </span><span class="s1">LazyReferenceMapper):</span>
            <span class="s0">return </span><span class="s1">path </span><span class="s0">in </span><span class="s1">self.references.listdir(</span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s5"># this may be faster than building dircache for single calls, but</span>
            <span class="s5"># by looping will be slow for many calls; could cache it?</span>
            <span class="s0">return </span><span class="s1">any(_.startswith(</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">path</span><span class="s0">}</span><span class="s2">/&quot;</span><span class="s1">) </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">self.references)</span>

    <span class="s0">def </span><span class="s1">isfile(self</span><span class="s0">, </span><span class="s1">path):  </span><span class="s5"># overwrite auto-sync version</span>
        <span class="s0">return </span><span class="s1">path </span><span class="s0">in </span><span class="s1">self.references</span>

    <span class="s0">async def </span><span class="s1">_ls(self</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">detail=</span><span class="s0">True, </span><span class="s1">**kwargs):  </span><span class="s5"># calls fast sync code</span>
        <span class="s0">return </span><span class="s1">self.ls(path</span><span class="s0">, </span><span class="s1">detail</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">find(self</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">maxdepth=</span><span class="s0">None, </span><span class="s1">withdirs=</span><span class="s0">False, </span><span class="s1">detail=</span><span class="s0">False, </span><span class="s1">**kwargs):</span>
        <span class="s0">if </span><span class="s1">withdirs:</span>
            <span class="s0">return </span><span class="s1">super().find(</span>
                <span class="s1">path</span><span class="s0">, </span><span class="s1">maxdepth=maxdepth</span><span class="s0">, </span><span class="s1">withdirs=withdirs</span><span class="s0">, </span><span class="s1">detail=detail</span><span class="s0">, </span><span class="s1">**kwargs</span>
            <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">path:</span>
            <span class="s1">path = self._strip_protocol(path)</span>
            <span class="s1">r = sorted(k </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">self.references </span><span class="s0">if </span><span class="s1">k.startswith(path))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">r = sorted(self.references)</span>
        <span class="s0">if </span><span class="s1">detail:</span>
            <span class="s0">if not </span><span class="s1">self.dircache:</span>
                <span class="s1">self._dircache_from_items()</span>
            <span class="s0">return </span><span class="s1">{k: self._ls_from_cache(k)[</span><span class="s3">0</span><span class="s1">] </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">r}</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">r</span>

    <span class="s0">def </span><span class="s1">info(self</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">out = self.references.get(path)</span>
        <span class="s0">if </span><span class="s1">out </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">isinstance(out</span><span class="s0">, </span><span class="s1">(str</span><span class="s0">, </span><span class="s1">bytes)):</span>
                <span class="s5"># decode base64 here</span>
                <span class="s0">return </span><span class="s1">{</span><span class="s2">&quot;name&quot;</span><span class="s1">: path</span><span class="s0">, </span><span class="s2">&quot;type&quot;</span><span class="s1">: </span><span class="s2">&quot;file&quot;</span><span class="s0">, </span><span class="s2">&quot;size&quot;</span><span class="s1">: len(out)}</span>
            <span class="s0">elif </span><span class="s1">len(out) &gt; </span><span class="s3">1</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">{</span><span class="s2">&quot;name&quot;</span><span class="s1">: path</span><span class="s0">, </span><span class="s2">&quot;type&quot;</span><span class="s1">: </span><span class="s2">&quot;file&quot;</span><span class="s0">, </span><span class="s2">&quot;size&quot;</span><span class="s1">: out[</span><span class="s3">2</span><span class="s1">]}</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">out0 = [{</span><span class="s2">&quot;name&quot;</span><span class="s1">: path</span><span class="s0">, </span><span class="s2">&quot;type&quot;</span><span class="s1">: </span><span class="s2">&quot;file&quot;</span><span class="s0">, </span><span class="s2">&quot;size&quot;</span><span class="s1">: </span><span class="s0">None</span><span class="s1">}]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">out = self.ls(path</span><span class="s0">, True</span><span class="s1">)</span>
            <span class="s1">out0 = [o </span><span class="s0">for </span><span class="s1">o </span><span class="s0">in </span><span class="s1">out </span><span class="s0">if </span><span class="s1">o[</span><span class="s2">&quot;name&quot;</span><span class="s1">] == path]</span>
            <span class="s0">if not </span><span class="s1">out0:</span>
                <span class="s0">return </span><span class="s1">{</span><span class="s2">&quot;name&quot;</span><span class="s1">: path</span><span class="s0">, </span><span class="s2">&quot;type&quot;</span><span class="s1">: </span><span class="s2">&quot;directory&quot;</span><span class="s0">, </span><span class="s2">&quot;size&quot;</span><span class="s1">: </span><span class="s3">0</span><span class="s1">}</span>
        <span class="s0">if </span><span class="s1">out0[</span><span class="s3">0</span><span class="s1">][</span><span class="s2">&quot;size&quot;</span><span class="s1">] </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s5"># if this is a whole remote file, update size using remote FS</span>
            <span class="s1">prot</span><span class="s0">, </span><span class="s1">_ = split_protocol(self.references[path][</span><span class="s3">0</span><span class="s1">])</span>
            <span class="s1">out0[</span><span class="s3">0</span><span class="s1">][</span><span class="s2">&quot;size&quot;</span><span class="s1">] = self.fss[prot].size(self.references[path][</span><span class="s3">0</span><span class="s1">])</span>
        <span class="s0">return </span><span class="s1">out0[</span><span class="s3">0</span><span class="s1">]</span>

    <span class="s0">async def </span><span class="s1">_info(self</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">**kwargs):  </span><span class="s5"># calls fast sync code</span>
        <span class="s0">return </span><span class="s1">self.info(path)</span>

    <span class="s0">async def </span><span class="s1">_rm_file(self</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">self.references.pop(</span>
            <span class="s1">path</span><span class="s0">, None</span>
        <span class="s1">)  </span><span class="s5"># ignores FileNotFound, just as well for directories</span>
        <span class="s1">self.dircache.clear()  </span><span class="s5"># this is a bit heavy handed</span>

    <span class="s0">async def </span><span class="s1">_pipe_file(self</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">data):</span>
        <span class="s5"># can be str or bytes</span>
        <span class="s1">self.references[path] = data</span>
        <span class="s1">self.dircache.clear()  </span><span class="s5"># this is a bit heavy handed</span>

    <span class="s0">async def </span><span class="s1">_put_file(self</span><span class="s0">, </span><span class="s1">lpath</span><span class="s0">, </span><span class="s1">rpath):</span>
        <span class="s5"># puts binary</span>
        <span class="s0">with </span><span class="s1">open(lpath</span><span class="s0">, </span><span class="s2">&quot;rb&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">f:</span>
            <span class="s1">self.references[rpath] = f.read()</span>
        <span class="s1">self.dircache.clear()  </span><span class="s5"># this is a bit heavy handed</span>

    <span class="s0">def </span><span class="s1">save_json(self</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, </span><span class="s1">**storage_options):</span>
        <span class="s4">&quot;&quot;&quot;Write modified references into new location&quot;&quot;&quot;</span>
        <span class="s1">out = {}</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">self.references.items():</span>
            <span class="s0">if </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">bytes):</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">out[k] = v.decode(</span><span class="s2">&quot;ascii&quot;</span><span class="s1">)</span>
                <span class="s0">except </span><span class="s1">UnicodeDecodeError:</span>
                    <span class="s1">out[k] = (</span><span class="s6">b&quot;base64:&quot; </span><span class="s1">+ base64.b64encode(v)).decode()</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">out[k] = v</span>
        <span class="s0">with </span><span class="s1">fsspec.open(url</span><span class="s0">, </span><span class="s2">&quot;wb&quot;</span><span class="s0">, </span><span class="s1">**storage_options) </span><span class="s0">as </span><span class="s1">f:</span>
            <span class="s1">f.write(json.dumps({</span><span class="s2">&quot;version&quot;</span><span class="s1">: </span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;refs&quot;</span><span class="s1">: out}).encode())</span>
</pre>
</body>
</html>