<html>
<head>
<title>test_arrow.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #a5c261;}
.s6 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_arrow.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
This file contains a minimal set of tests for compliance with the extension 
array interface test suite, and should contain no other tests. 
The test suite for the full functionality of the array is located in 
`pandas/tests/arrays/`. 
The tests in this file are inherited from the BaseExtensionTests, and only 
minimal tweaks should be applied to get the tests passing (by overwriting a 
parent method). 
Additional tests should either be added to one of the BaseExtensionTests 
classes (if they are relevant for the extension interface for all dtypes), or 
be added to the array-specific tests in `pandas/tests/arrays/`. 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">from </span><span class="s1">datetime </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">date</span><span class="s2">,</span>
    <span class="s1">datetime</span><span class="s2">,</span>
    <span class="s1">time</span><span class="s2">,</span>
    <span class="s1">timedelta</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">decimal </span><span class="s2">import </span><span class="s1">Decimal</span>
<span class="s2">from </span><span class="s1">io </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">BytesIO</span><span class="s2">,</span>
    <span class="s1">StringIO</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">operator</span>
<span class="s2">import </span><span class="s1">pickle</span>
<span class="s2">import </span><span class="s1">re</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">from </span><span class="s1">pandas._libs </span><span class="s2">import </span><span class="s1">lib</span>
<span class="s2">from </span><span class="s1">pandas._libs.tslibs </span><span class="s2">import </span><span class="s1">timezones</span>
<span class="s2">from </span><span class="s1">pandas.compat </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">PY311</span><span class="s2">,</span>
    <span class="s1">is_ci_environment</span><span class="s2">,</span>
    <span class="s1">is_platform_windows</span><span class="s2">,</span>
    <span class="s1">pa_version_under7p0</span><span class="s2">,</span>
    <span class="s1">pa_version_under8p0</span><span class="s2">,</span>
    <span class="s1">pa_version_under9p0</span><span class="s2">,</span>
    <span class="s1">pa_version_under11p0</span><span class="s2">,</span>
    <span class="s1">pa_version_under13p0</span><span class="s2">,</span>
    <span class="s1">pa_version_under14p0</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">from </span><span class="s1">pandas.core.dtypes.dtypes </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ArrowDtype</span><span class="s2">,</span>
    <span class="s1">CategoricalDtypeType</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">import </span><span class="s1">pandas._testing </span><span class="s2">as </span><span class="s1">tm</span>
<span class="s2">from </span><span class="s1">pandas.api.extensions </span><span class="s2">import </span><span class="s1">no_default</span>
<span class="s2">from </span><span class="s1">pandas.api.types </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">is_bool_dtype</span><span class="s2">,</span>
    <span class="s1">is_float_dtype</span><span class="s2">,</span>
    <span class="s1">is_integer_dtype</span><span class="s2">,</span>
    <span class="s1">is_numeric_dtype</span><span class="s2">,</span>
    <span class="s1">is_signed_integer_dtype</span><span class="s2">,</span>
    <span class="s1">is_string_dtype</span><span class="s2">,</span>
    <span class="s1">is_unsigned_integer_dtype</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.tests.extension </span><span class="s2">import </span><span class="s1">base</span>

<span class="s1">pa = pytest.importorskip(</span><span class="s3">&quot;pyarrow&quot;</span><span class="s2">, </span><span class="s1">minversion=</span><span class="s3">&quot;7.0.0&quot;</span><span class="s1">)</span>

<span class="s2">from </span><span class="s1">pandas.core.arrays.arrow.array </span><span class="s2">import </span><span class="s1">ArrowExtensionArray</span>
<span class="s2">from </span><span class="s1">pandas.core.arrays.arrow.extension_types </span><span class="s2">import </span><span class="s1">ArrowPeriodType</span>


<span class="s2">def </span><span class="s1">_require_timezone_database(request):</span>
    <span class="s2">if </span><span class="s1">is_platform_windows() </span><span class="s2">and </span><span class="s1">is_ci_environment():</span>
        <span class="s1">mark = pytest.mark.xfail(</span>
            <span class="s1">raises=pa.ArrowInvalid</span><span class="s2">,</span>
            <span class="s1">reason=(</span>
                <span class="s3">&quot;TODO: Set ARROW_TIMEZONE_DATABASE environment variable &quot;</span>
                <span class="s3">&quot;on CI to path to the tzdata for pyarrow.&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">request.node.add_marker(mark)</span>


<span class="s1">@pytest.fixture(params=tm.ALL_PYARROW_DTYPES</span><span class="s2">, </span><span class="s1">ids=str)</span>
<span class="s2">def </span><span class="s1">dtype(request):</span>
    <span class="s2">return </span><span class="s1">ArrowDtype(pyarrow_dtype=request.param)</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">data(dtype):</span>
    <span class="s1">pa_dtype = dtype.pyarrow_dtype</span>
    <span class="s2">if </span><span class="s1">pa.types.is_boolean(pa_dtype):</span>
        <span class="s1">data = [</span><span class="s2">True, False</span><span class="s1">] * </span><span class="s4">4 </span><span class="s1">+ [</span><span class="s2">None</span><span class="s1">] + [</span><span class="s2">True, False</span><span class="s1">] * </span><span class="s4">44 </span><span class="s1">+ [</span><span class="s2">None</span><span class="s1">] + [</span><span class="s2">True, False</span><span class="s1">]</span>
    <span class="s2">elif </span><span class="s1">pa.types.is_floating(pa_dtype):</span>
        <span class="s1">data = [</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">] * </span><span class="s4">4 </span><span class="s1">+ [</span><span class="s2">None</span><span class="s1">] + [-</span><span class="s4">2.0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.0</span><span class="s1">] * </span><span class="s4">44 </span><span class="s1">+ [</span><span class="s2">None</span><span class="s1">] + [</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">99.5</span><span class="s1">]</span>
    <span class="s2">elif </span><span class="s1">pa.types.is_signed_integer(pa_dtype):</span>
        <span class="s1">data = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] * </span><span class="s4">4 </span><span class="s1">+ [</span><span class="s2">None</span><span class="s1">] + [-</span><span class="s4">2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">] * </span><span class="s4">44 </span><span class="s1">+ [</span><span class="s2">None</span><span class="s1">] + [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">99</span><span class="s1">]</span>
    <span class="s2">elif </span><span class="s1">pa.types.is_unsigned_integer(pa_dtype):</span>
        <span class="s1">data = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] * </span><span class="s4">4 </span><span class="s1">+ [</span><span class="s2">None</span><span class="s1">] + [</span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">] * </span><span class="s4">44 </span><span class="s1">+ [</span><span class="s2">None</span><span class="s1">] + [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">99</span><span class="s1">]</span>
    <span class="s2">elif </span><span class="s1">pa.types.is_decimal(pa_dtype):</span>
        <span class="s1">data = (</span>
            <span class="s1">[Decimal(</span><span class="s3">&quot;1&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Decimal(</span><span class="s3">&quot;0.0&quot;</span><span class="s1">)] * </span><span class="s4">4</span>
            <span class="s1">+ [</span><span class="s2">None</span><span class="s1">]</span>
            <span class="s1">+ [Decimal(</span><span class="s3">&quot;-2.0&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Decimal(</span><span class="s3">&quot;-1.0&quot;</span><span class="s1">)] * </span><span class="s4">44</span>
            <span class="s1">+ [</span><span class="s2">None</span><span class="s1">]</span>
            <span class="s1">+ [Decimal(</span><span class="s3">&quot;0.5&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Decimal(</span><span class="s3">&quot;33.123&quot;</span><span class="s1">)]</span>
        <span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">pa.types.is_date(pa_dtype):</span>
        <span class="s1">data = (</span>
            <span class="s1">[date(</span><span class="s4">2022</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">date(</span><span class="s4">1999</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s4">31</span><span class="s1">)] * </span><span class="s4">4</span>
            <span class="s1">+ [</span><span class="s2">None</span><span class="s1">]</span>
            <span class="s1">+ [date(</span><span class="s4">2022</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">date(</span><span class="s4">2022</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)] * </span><span class="s4">44</span>
            <span class="s1">+ [</span><span class="s2">None</span><span class="s1">]</span>
            <span class="s1">+ [date(</span><span class="s4">1999</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s4">31</span><span class="s1">)</span><span class="s2">, </span><span class="s1">date(</span><span class="s4">1999</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s4">31</span><span class="s1">)]</span>
        <span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">pa.types.is_timestamp(pa_dtype):</span>
        <span class="s1">data = (</span>
            <span class="s1">[datetime(</span><span class="s4">2020</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s4">1999</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)] * </span><span class="s4">4</span>
            <span class="s1">+ [</span><span class="s2">None</span><span class="s1">]</span>
            <span class="s1">+ [datetime(</span><span class="s4">2020</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s4">1999</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)] * </span><span class="s4">44</span>
            <span class="s1">+ [</span><span class="s2">None</span><span class="s1">]</span>
            <span class="s1">+ [datetime(</span><span class="s4">2020</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s4">1999</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)]</span>
        <span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">pa.types.is_duration(pa_dtype):</span>
        <span class="s1">data = (</span>
            <span class="s1">[timedelta(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">timedelta(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)] * </span><span class="s4">4</span>
            <span class="s1">+ [</span><span class="s2">None</span><span class="s1">]</span>
            <span class="s1">+ [timedelta(-</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">timedelta(</span><span class="s4">0</span><span class="s1">)] * </span><span class="s4">44</span>
            <span class="s1">+ [</span><span class="s2">None</span><span class="s1">]</span>
            <span class="s1">+ [timedelta(-</span><span class="s4">10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">timedelta(</span><span class="s4">10</span><span class="s1">)]</span>
        <span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">pa.types.is_time(pa_dtype):</span>
        <span class="s1">data = (</span>
            <span class="s1">[time(</span><span class="s4">12</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">time(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">12</span><span class="s1">)] * </span><span class="s4">4</span>
            <span class="s1">+ [</span><span class="s2">None</span><span class="s1">]</span>
            <span class="s1">+ [time(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">time(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)] * </span><span class="s4">44</span>
            <span class="s1">+ [</span><span class="s2">None</span><span class="s1">]</span>
            <span class="s1">+ [time(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">time(</span><span class="s4">5</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)]</span>
        <span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">pa.types.is_string(pa_dtype):</span>
        <span class="s1">data = [</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">] * </span><span class="s4">4 </span><span class="s1">+ [</span><span class="s2">None</span><span class="s1">] + [</span><span class="s3">&quot;1&quot;</span><span class="s2">, </span><span class="s3">&quot;2&quot;</span><span class="s1">] * </span><span class="s4">44 </span><span class="s1">+ [</span><span class="s2">None</span><span class="s1">] + [</span><span class="s3">&quot;!&quot;</span><span class="s2">, </span><span class="s3">&quot;&gt;&quot;</span><span class="s1">]</span>
    <span class="s2">elif </span><span class="s1">pa.types.is_binary(pa_dtype):</span>
        <span class="s1">data = [</span><span class="s5">b&quot;a&quot;</span><span class="s2">, </span><span class="s5">b&quot;b&quot;</span><span class="s1">] * </span><span class="s4">4 </span><span class="s1">+ [</span><span class="s2">None</span><span class="s1">] + [</span><span class="s5">b&quot;1&quot;</span><span class="s2">, </span><span class="s5">b&quot;2&quot;</span><span class="s1">] * </span><span class="s4">44 </span><span class="s1">+ [</span><span class="s2">None</span><span class="s1">] + [</span><span class="s5">b&quot;!&quot;</span><span class="s2">, </span><span class="s5">b&quot;&gt;&quot;</span><span class="s1">]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>
    <span class="s2">return </span><span class="s1">pd.array(data</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">data_missing(data):</span>
    <span class="s0">&quot;&quot;&quot;Length-2 array with [NA, Valid]&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">type(data)._from_sequence([</span><span class="s2">None, </span><span class="s1">data[</span><span class="s4">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=data.dtype)</span>


<span class="s1">@pytest.fixture(params=[</span><span class="s3">&quot;data&quot;</span><span class="s2">, </span><span class="s3">&quot;data_missing&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">all_data(request</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">data_missing):</span>
    <span class="s0">&quot;&quot;&quot;Parametrized fixture returning 'data' or 'data_missing' integer arrays. 
 
    Used to test dtype conversion with and without missing values. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">request.param == </span><span class="s3">&quot;data&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">data</span>
    <span class="s2">elif </span><span class="s1">request.param == </span><span class="s3">&quot;data_missing&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">data_missing</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">data_for_grouping(dtype):</span>
    <span class="s0">&quot;&quot;&quot; 
    Data for factorization, grouping, and unique tests. 
 
    Expected to be like [B, B, NA, NA, A, A, B, C] 
 
    Where A &lt; B &lt; C and NA is missing 
    &quot;&quot;&quot;</span>
    <span class="s1">pa_dtype = dtype.pyarrow_dtype</span>
    <span class="s2">if </span><span class="s1">pa.types.is_boolean(pa_dtype):</span>
        <span class="s1">A = </span><span class="s2">False</span>
        <span class="s1">B = </span><span class="s2">True</span>
        <span class="s1">C = </span><span class="s2">True</span>
    <span class="s2">elif </span><span class="s1">pa.types.is_floating(pa_dtype):</span>
        <span class="s1">A = -</span><span class="s4">1.1</span>
        <span class="s1">B = </span><span class="s4">0.0</span>
        <span class="s1">C = </span><span class="s4">1.1</span>
    <span class="s2">elif </span><span class="s1">pa.types.is_signed_integer(pa_dtype):</span>
        <span class="s1">A = -</span><span class="s4">1</span>
        <span class="s1">B = </span><span class="s4">0</span>
        <span class="s1">C = </span><span class="s4">1</span>
    <span class="s2">elif </span><span class="s1">pa.types.is_unsigned_integer(pa_dtype):</span>
        <span class="s1">A = </span><span class="s4">0</span>
        <span class="s1">B = </span><span class="s4">1</span>
        <span class="s1">C = </span><span class="s4">10</span>
    <span class="s2">elif </span><span class="s1">pa.types.is_date(pa_dtype):</span>
        <span class="s1">A = date(</span><span class="s4">1999</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s4">31</span><span class="s1">)</span>
        <span class="s1">B = date(</span><span class="s4">2010</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">C = date(</span><span class="s4">2022</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">pa.types.is_timestamp(pa_dtype):</span>
        <span class="s1">A = datetime(</span><span class="s4">1999</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">B = datetime(</span><span class="s4">2020</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">C = datetime(</span><span class="s4">2020</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">pa.types.is_duration(pa_dtype):</span>
        <span class="s1">A = timedelta(-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">B = timedelta(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">C = timedelta(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">pa.types.is_time(pa_dtype):</span>
        <span class="s1">A = time(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">B = time(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">12</span><span class="s1">)</span>
        <span class="s1">C = time(</span><span class="s4">12</span><span class="s2">, </span><span class="s4">12</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">pa.types.is_string(pa_dtype):</span>
        <span class="s1">A = </span><span class="s3">&quot;a&quot;</span>
        <span class="s1">B = </span><span class="s3">&quot;b&quot;</span>
        <span class="s1">C = </span><span class="s3">&quot;c&quot;</span>
    <span class="s2">elif </span><span class="s1">pa.types.is_binary(pa_dtype):</span>
        <span class="s1">A = </span><span class="s5">b&quot;a&quot;</span>
        <span class="s1">B = </span><span class="s5">b&quot;b&quot;</span>
        <span class="s1">C = </span><span class="s5">b&quot;c&quot;</span>
    <span class="s2">elif </span><span class="s1">pa.types.is_decimal(pa_dtype):</span>
        <span class="s1">A = Decimal(</span><span class="s3">&quot;-1.1&quot;</span><span class="s1">)</span>
        <span class="s1">B = Decimal(</span><span class="s3">&quot;0.0&quot;</span><span class="s1">)</span>
        <span class="s1">C = Decimal(</span><span class="s3">&quot;1.1&quot;</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>
    <span class="s2">return </span><span class="s1">pd.array([B</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, None, None, </span><span class="s1">A</span><span class="s2">, </span><span class="s1">A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">C]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">data_for_sorting(data_for_grouping):</span>
    <span class="s0">&quot;&quot;&quot; 
    Length-3 array with a known sort order. 
 
    This should be three items [B, C, A] with 
    A &lt; B &lt; C 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">type(data_for_grouping)._from_sequence(</span>
        <span class="s1">[data_for_grouping[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">data_for_grouping[</span><span class="s4">7</span><span class="s1">]</span><span class="s2">, </span><span class="s1">data_for_grouping[</span><span class="s4">4</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">dtype=data_for_grouping.dtype</span><span class="s2">,</span>
    <span class="s1">)</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">data_missing_for_sorting(data_for_grouping):</span>
    <span class="s0">&quot;&quot;&quot; 
    Length-3 array with a known sort order. 
 
    This should be three items [B, NA, A] with 
    A &lt; B and NA missing. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">type(data_for_grouping)._from_sequence(</span>
        <span class="s1">[data_for_grouping[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">data_for_grouping[</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">data_for_grouping[</span><span class="s4">4</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">dtype=data_for_grouping.dtype</span><span class="s2">,</span>
    <span class="s1">)</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">data_for_twos(data):</span>
    <span class="s0">&quot;&quot;&quot;Length-100 array in which all the elements are two.&quot;&quot;&quot;</span>
    <span class="s1">pa_dtype = data.dtype.pyarrow_dtype</span>
    <span class="s2">if </span><span class="s1">(</span>
        <span class="s1">pa.types.is_integer(pa_dtype)</span>
        <span class="s2">or </span><span class="s1">pa.types.is_floating(pa_dtype)</span>
        <span class="s2">or </span><span class="s1">pa.types.is_decimal(pa_dtype)</span>
        <span class="s2">or </span><span class="s1">pa.types.is_duration(pa_dtype)</span>
    <span class="s1">):</span>
        <span class="s2">return </span><span class="s1">pd.array([</span><span class="s4">2</span><span class="s1">] * </span><span class="s4">100</span><span class="s2">, </span><span class="s1">dtype=data.dtype)</span>
    <span class="s6"># tests will be xfailed where 2 is not a valid scalar for pa_dtype</span>
    <span class="s2">return </span><span class="s1">data</span>
    <span class="s6"># TODO: skip otherwise?</span>


<span class="s2">class </span><span class="s1">TestBaseCasting(base.BaseCastingTests):</span>
    <span class="s2">def </span><span class="s1">test_astype_str(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">request):</span>
        <span class="s1">pa_dtype = data.dtype.pyarrow_dtype</span>
        <span class="s2">if </span><span class="s1">pa.types.is_binary(pa_dtype):</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">reason=</span><span class="s3">f&quot;For </span><span class="s2">{</span><span class="s1">pa_dtype</span><span class="s2">} </span><span class="s3">.astype(str) decodes.&quot;</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s1">super().test_astype_str(data)</span>


<span class="s2">class </span><span class="s1">TestConstructors(base.BaseConstructorsTests):</span>
    <span class="s2">def </span><span class="s1">test_from_dtype(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">request):</span>
        <span class="s1">pa_dtype = data.dtype.pyarrow_dtype</span>
        <span class="s2">if </span><span class="s1">pa.types.is_string(pa_dtype) </span><span class="s2">or </span><span class="s1">pa.types.is_decimal(pa_dtype):</span>
            <span class="s2">if </span><span class="s1">pa.types.is_string(pa_dtype):</span>
                <span class="s1">reason = </span><span class="s3">&quot;ArrowDtype(pa.string()) != StringDtype('pyarrow')&quot;</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">reason = </span><span class="s3">f&quot;pyarrow.type_for_alias cannot infer </span><span class="s2">{</span><span class="s1">pa_dtype</span><span class="s2">}</span><span class="s3">&quot;</span>

            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">reason=reason</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s1">super().test_from_dtype(data)</span>

    <span class="s2">def </span><span class="s1">test_from_sequence_pa_array(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s6"># https://github.com/pandas-dev/pandas/pull/47034#discussion_r955500784</span>
        <span class="s6"># data._pa_array = pa.ChunkedArray</span>
        <span class="s1">result = type(data)._from_sequence(data._pa_array)</span>
        <span class="s1">tm.assert_extension_array_equal(result</span><span class="s2">, </span><span class="s1">data)</span>
        <span class="s2">assert </span><span class="s1">isinstance(result._pa_array</span><span class="s2">, </span><span class="s1">pa.ChunkedArray)</span>

        <span class="s1">result = type(data)._from_sequence(data._pa_array.combine_chunks())</span>
        <span class="s1">tm.assert_extension_array_equal(result</span><span class="s2">, </span><span class="s1">data)</span>
        <span class="s2">assert </span><span class="s1">isinstance(result._pa_array</span><span class="s2">, </span><span class="s1">pa.ChunkedArray)</span>

    <span class="s2">def </span><span class="s1">test_from_sequence_pa_array_notimplemented(self</span><span class="s2">, </span><span class="s1">request):</span>
        <span class="s2">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Converting strings to&quot;</span><span class="s1">):</span>
            <span class="s1">ArrowExtensionArray._from_sequence_of_strings(</span>
                <span class="s1">[</span><span class="s3">&quot;12-1&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=pa.month_day_nano_interval()</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_from_sequence_of_strings_pa_array(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">request):</span>
        <span class="s1">pa_dtype = data.dtype.pyarrow_dtype</span>
        <span class="s2">if </span><span class="s1">pa.types.is_time64(pa_dtype) </span><span class="s2">and </span><span class="s1">pa_dtype.equals(</span><span class="s3">&quot;time64[ns]&quot;</span><span class="s1">) </span><span class="s2">and not </span><span class="s1">PY311:</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">reason=</span><span class="s3">&quot;Nanosecond time parsing not supported.&quot;</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">pa_version_under11p0 </span><span class="s2">and </span><span class="s1">(</span>
            <span class="s1">pa.types.is_duration(pa_dtype) </span><span class="s2">or </span><span class="s1">pa.types.is_decimal(pa_dtype)</span>
        <span class="s1">):</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">raises=pa.ArrowNotImplementedError</span><span class="s2">,</span>
                    <span class="s1">reason=</span><span class="s3">f&quot;pyarrow doesn't support parsing </span><span class="s2">{</span><span class="s1">pa_dtype</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">pa.types.is_timestamp(pa_dtype) </span><span class="s2">and </span><span class="s1">pa_dtype.tz </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">_require_timezone_database(request)</span>

        <span class="s1">pa_array = data._pa_array.cast(pa.string())</span>
        <span class="s1">result = type(data)._from_sequence_of_strings(pa_array</span><span class="s2">, </span><span class="s1">dtype=data.dtype)</span>
        <span class="s1">tm.assert_extension_array_equal(result</span><span class="s2">, </span><span class="s1">data)</span>

        <span class="s1">pa_array = pa_array.combine_chunks()</span>
        <span class="s1">result = type(data)._from_sequence_of_strings(pa_array</span><span class="s2">, </span><span class="s1">dtype=data.dtype)</span>
        <span class="s1">tm.assert_extension_array_equal(result</span><span class="s2">, </span><span class="s1">data)</span>


<span class="s2">class </span><span class="s1">TestGetitemTests(base.BaseGetitemTests):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestBaseAccumulateTests(base.BaseAccumulateTests):</span>
    <span class="s2">def </span><span class="s1">check_accumulate(self</span><span class="s2">, </span><span class="s1">ser</span><span class="s2">, </span><span class="s1">op_name</span><span class="s2">, </span><span class="s1">skipna):</span>
        <span class="s1">result = getattr(ser</span><span class="s2">, </span><span class="s1">op_name)(skipna=skipna)</span>

        <span class="s1">pa_type = ser.dtype.pyarrow_dtype</span>
        <span class="s2">if </span><span class="s1">pa.types.is_temporal(pa_type):</span>
            <span class="s6"># Just check that we match the integer behavior.</span>
            <span class="s2">if </span><span class="s1">pa_type.bit_width == </span><span class="s4">32</span><span class="s1">:</span>
                <span class="s1">int_type = </span><span class="s3">&quot;int32[pyarrow]&quot;</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">int_type = </span><span class="s3">&quot;int64[pyarrow]&quot;</span>
            <span class="s1">ser = ser.astype(int_type)</span>
            <span class="s1">result = result.astype(int_type)</span>

        <span class="s1">result = result.astype(</span><span class="s3">&quot;Float64&quot;</span><span class="s1">)</span>
        <span class="s1">expected = getattr(ser.astype(</span><span class="s3">&quot;Float64&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">op_name)(skipna=skipna)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">check_dtype=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_supports_accumulation(self</span><span class="s2">, </span><span class="s1">ser: pd.Series</span><span class="s2">, </span><span class="s1">op_name: str) -&gt; bool:</span>
        <span class="s6"># error: Item &quot;dtype[Any]&quot; of &quot;dtype[Any] | ExtensionDtype&quot; has no</span>
        <span class="s6"># attribute &quot;pyarrow_dtype&quot;</span>
        <span class="s1">pa_type = ser.dtype.pyarrow_dtype  </span><span class="s6"># type: ignore[union-attr]</span>

        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">pa.types.is_string(pa_type)</span>
            <span class="s2">or </span><span class="s1">pa.types.is_binary(pa_type)</span>
            <span class="s2">or </span><span class="s1">pa.types.is_decimal(pa_type)</span>
        <span class="s1">):</span>
            <span class="s2">if </span><span class="s1">op_name </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;cumsum&quot;</span><span class="s2">, </span><span class="s3">&quot;cumprod&quot;</span><span class="s2">, </span><span class="s3">&quot;cummax&quot;</span><span class="s2">, </span><span class="s3">&quot;cummin&quot;</span><span class="s1">]:</span>
                <span class="s2">return False</span>
        <span class="s2">elif </span><span class="s1">pa.types.is_boolean(pa_type):</span>
            <span class="s2">if </span><span class="s1">op_name </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;cumprod&quot;</span><span class="s2">, </span><span class="s3">&quot;cummax&quot;</span><span class="s2">, </span><span class="s3">&quot;cummin&quot;</span><span class="s1">]:</span>
                <span class="s2">return False</span>
        <span class="s2">elif </span><span class="s1">pa.types.is_temporal(pa_type):</span>
            <span class="s2">if </span><span class="s1">op_name == </span><span class="s3">&quot;cumsum&quot; </span><span class="s2">and not </span><span class="s1">pa.types.is_duration(pa_type):</span>
                <span class="s2">return False</span>
            <span class="s2">elif </span><span class="s1">op_name == </span><span class="s3">&quot;cumprod&quot;</span><span class="s1">:</span>
                <span class="s2">return False</span>
        <span class="s2">return True</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;skipna&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_accumulate_series(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">all_numeric_accumulations</span><span class="s2">, </span><span class="s1">skipna</span><span class="s2">, </span><span class="s1">request):</span>
        <span class="s1">pa_type = data.dtype.pyarrow_dtype</span>
        <span class="s1">op_name = all_numeric_accumulations</span>
        <span class="s1">ser = pd.Series(data)</span>

        <span class="s2">if not </span><span class="s1">self._supports_accumulation(ser</span><span class="s2">, </span><span class="s1">op_name):</span>
            <span class="s6"># The base class test will check that we raise</span>
            <span class="s2">return </span><span class="s1">super().test_accumulate_series(</span>
                <span class="s1">data</span><span class="s2">, </span><span class="s1">all_numeric_accumulations</span><span class="s2">, </span><span class="s1">skipna</span>
            <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">pa_version_under9p0 </span><span class="s2">or </span><span class="s1">(</span>
            <span class="s1">pa_version_under13p0 </span><span class="s2">and </span><span class="s1">all_numeric_accumulations != </span><span class="s3">&quot;cumsum&quot;</span>
        <span class="s1">):</span>
            <span class="s6"># xfailing takes a long time to run because pytest</span>
            <span class="s6"># renders the exception messages even when not showing them</span>
            <span class="s1">opt = request.config.option</span>
            <span class="s2">if </span><span class="s1">opt.markexpr </span><span class="s2">and </span><span class="s3">&quot;not slow&quot; </span><span class="s2">in </span><span class="s1">opt.markexpr:</span>
                <span class="s1">pytest.skip(</span>
                    <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">all_numeric_accumulations</span><span class="s2">} </span><span class="s3">not implemented for pyarrow &lt; 9&quot;</span>
                <span class="s1">)</span>
            <span class="s1">mark = pytest.mark.xfail(</span>
                <span class="s1">reason=</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">all_numeric_accumulations</span><span class="s2">} </span><span class="s3">not implemented for pyarrow &lt; 9&quot;</span>
            <span class="s1">)</span>
            <span class="s1">request.node.add_marker(mark)</span>

        <span class="s2">elif </span><span class="s1">all_numeric_accumulations == </span><span class="s3">&quot;cumsum&quot; </span><span class="s2">and </span><span class="s1">(</span>
            <span class="s1">pa.types.is_boolean(pa_type) </span><span class="s2">or </span><span class="s1">pa.types.is_decimal(pa_type)</span>
        <span class="s1">):</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">reason=</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">all_numeric_accumulations</span><span class="s2">} </span><span class="s3">not implemented for </span><span class="s2">{</span><span class="s1">pa_type</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s2">,</span>
                    <span class="s1">raises=NotImplementedError</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s1">self.check_accumulate(ser</span><span class="s2">, </span><span class="s1">op_name</span><span class="s2">, </span><span class="s1">skipna)</span>


<span class="s2">class </span><span class="s1">TestReduce(base.BaseReduceTests):</span>
    <span class="s2">def </span><span class="s1">_supports_reduction(self</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">op_name: str) -&gt; bool:</span>
        <span class="s1">dtype = tm.get_dtype(obj)</span>
        <span class="s6"># error: Item &quot;dtype[Any]&quot; of &quot;dtype[Any] | ExtensionDtype&quot; has</span>
        <span class="s6"># no attribute &quot;pyarrow_dtype&quot;</span>
        <span class="s1">pa_dtype = dtype.pyarrow_dtype  </span><span class="s6"># type: ignore[union-attr]</span>
        <span class="s2">if </span><span class="s1">pa.types.is_temporal(pa_dtype) </span><span class="s2">and </span><span class="s1">op_name </span><span class="s2">in </span><span class="s1">[</span>
            <span class="s3">&quot;sum&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;var&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;skew&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;kurt&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;prod&quot;</span><span class="s2">,</span>
        <span class="s1">]:</span>
            <span class="s2">if </span><span class="s1">pa.types.is_duration(pa_dtype) </span><span class="s2">and </span><span class="s1">op_name </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;sum&quot;</span><span class="s1">]:</span>
                <span class="s6"># summing timedeltas is one case that *is* well-defined</span>
                <span class="s2">pass</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return False</span>
        <span class="s2">elif </span><span class="s1">(</span>
            <span class="s1">pa.types.is_string(pa_dtype) </span><span class="s2">or </span><span class="s1">pa.types.is_binary(pa_dtype)</span>
        <span class="s1">) </span><span class="s2">and </span><span class="s1">op_name </span><span class="s2">in </span><span class="s1">[</span>
            <span class="s3">&quot;sum&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;mean&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;median&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;prod&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;std&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;sem&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;var&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;skew&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;kurt&quot;</span><span class="s2">,</span>
        <span class="s1">]:</span>
            <span class="s2">return False</span>

        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">pa.types.is_temporal(pa_dtype)</span>
            <span class="s2">and not </span><span class="s1">pa.types.is_duration(pa_dtype)</span>
            <span class="s2">and </span><span class="s1">op_name </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;any&quot;</span><span class="s2">, </span><span class="s3">&quot;all&quot;</span><span class="s1">]</span>
        <span class="s1">):</span>
            <span class="s6"># xref GH#34479 we support this in our non-pyarrow datetime64 dtypes,</span>
            <span class="s6">#  but it isn't obvious we _should_.  For now, we keep the pyarrow</span>
            <span class="s6">#  behavior which does not support this.</span>
            <span class="s2">return False</span>

        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">check_reduce(self</span><span class="s2">, </span><span class="s1">ser</span><span class="s2">, </span><span class="s1">op_name</span><span class="s2">, </span><span class="s1">skipna):</span>
        <span class="s1">pa_dtype = ser.dtype.pyarrow_dtype</span>
        <span class="s2">if </span><span class="s1">op_name == </span><span class="s3">&quot;count&quot;</span><span class="s1">:</span>
            <span class="s1">result = getattr(ser</span><span class="s2">, </span><span class="s1">op_name)()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">result = getattr(ser</span><span class="s2">, </span><span class="s1">op_name)(skipna=skipna)</span>

        <span class="s2">if </span><span class="s1">pa.types.is_integer(pa_dtype) </span><span class="s2">or </span><span class="s1">pa.types.is_floating(pa_dtype):</span>
            <span class="s1">ser = ser.astype(</span><span class="s3">&quot;Float64&quot;</span><span class="s1">)</span>
        <span class="s6"># TODO: in the opposite case, aren't we testing... nothing?</span>
        <span class="s2">if </span><span class="s1">op_name == </span><span class="s3">&quot;count&quot;</span><span class="s1">:</span>
            <span class="s1">expected = getattr(ser</span><span class="s2">, </span><span class="s1">op_name)()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">expected = getattr(ser</span><span class="s2">, </span><span class="s1">op_name)(skipna=skipna)</span>
        <span class="s1">tm.assert_almost_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;skipna&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_reduce_series_numeric(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">all_numeric_reductions</span><span class="s2">, </span><span class="s1">skipna</span><span class="s2">, </span><span class="s1">request):</span>
        <span class="s1">dtype = data.dtype</span>
        <span class="s1">pa_dtype = dtype.pyarrow_dtype</span>

        <span class="s1">xfail_mark = pytest.mark.xfail(</span>
            <span class="s1">raises=TypeError</span><span class="s2">,</span>
            <span class="s1">reason=(</span>
                <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">all_numeric_reductions</span><span class="s2">} </span><span class="s3">is not implemented in &quot;</span>
                <span class="s3">f&quot;pyarrow=</span><span class="s2">{</span><span class="s1">pa.__version__</span><span class="s2">} </span><span class="s3">for </span><span class="s2">{</span><span class="s1">pa_dtype</span><span class="s2">}</span><span class="s3">&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">all_numeric_reductions </span><span class="s2">in </span><span class="s1">{</span><span class="s3">&quot;skew&quot;</span><span class="s2">, </span><span class="s3">&quot;kurt&quot;</span><span class="s1">} </span><span class="s2">and </span><span class="s1">(</span>
            <span class="s1">dtype._is_numeric </span><span class="s2">or </span><span class="s1">dtype.kind == </span><span class="s3">&quot;b&quot;</span>
        <span class="s1">):</span>
            <span class="s1">request.node.add_marker(xfail_mark)</span>
        <span class="s2">elif </span><span class="s1">(</span>
            <span class="s1">all_numeric_reductions </span><span class="s2">in </span><span class="s1">{</span><span class="s3">&quot;var&quot;</span><span class="s2">, </span><span class="s3">&quot;std&quot;</span><span class="s2">, </span><span class="s3">&quot;median&quot;</span><span class="s1">}</span>
            <span class="s2">and </span><span class="s1">pa_version_under7p0</span>
            <span class="s2">and </span><span class="s1">pa.types.is_decimal(pa_dtype)</span>
        <span class="s1">):</span>
            <span class="s1">request.node.add_marker(xfail_mark)</span>
        <span class="s2">elif </span><span class="s1">(</span>
            <span class="s1">all_numeric_reductions == </span><span class="s3">&quot;sem&quot;</span>
            <span class="s2">and </span><span class="s1">pa_version_under8p0</span>
            <span class="s2">and </span><span class="s1">(dtype._is_numeric </span><span class="s2">or </span><span class="s1">pa.types.is_temporal(pa_dtype))</span>
        <span class="s1">):</span>
            <span class="s1">request.node.add_marker(xfail_mark)</span>

        <span class="s2">elif </span><span class="s1">pa.types.is_boolean(pa_dtype) </span><span class="s2">and </span><span class="s1">all_numeric_reductions </span><span class="s2">in </span><span class="s1">{</span>
            <span class="s3">&quot;sem&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;std&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;var&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;median&quot;</span><span class="s2">,</span>
        <span class="s1">}:</span>
            <span class="s1">request.node.add_marker(xfail_mark)</span>
        <span class="s1">super().test_reduce_series_numeric(data</span><span class="s2">, </span><span class="s1">all_numeric_reductions</span><span class="s2">, </span><span class="s1">skipna)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;skipna&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_reduce_series_boolean(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">all_boolean_reductions</span><span class="s2">, </span><span class="s1">skipna</span><span class="s2">, </span><span class="s1">na_value</span><span class="s2">, </span><span class="s1">request</span>
    <span class="s1">):</span>
        <span class="s1">pa_dtype = data.dtype.pyarrow_dtype</span>
        <span class="s1">xfail_mark = pytest.mark.xfail(</span>
            <span class="s1">raises=TypeError</span><span class="s2">,</span>
            <span class="s1">reason=(</span>
                <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">all_boolean_reductions</span><span class="s2">} </span><span class="s3">is not implemented in &quot;</span>
                <span class="s3">f&quot;pyarrow=</span><span class="s2">{</span><span class="s1">pa.__version__</span><span class="s2">} </span><span class="s3">for </span><span class="s2">{</span><span class="s1">pa_dtype</span><span class="s2">}</span><span class="s3">&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">pa.types.is_string(pa_dtype) </span><span class="s2">or </span><span class="s1">pa.types.is_binary(pa_dtype):</span>
            <span class="s6"># We *might* want to make this behave like the non-pyarrow cases,</span>
            <span class="s6">#  but have not yet decided.</span>
            <span class="s1">request.node.add_marker(xfail_mark)</span>

        <span class="s2">return </span><span class="s1">super().test_reduce_series_boolean(data</span><span class="s2">, </span><span class="s1">all_boolean_reductions</span><span class="s2">, </span><span class="s1">skipna)</span>

    <span class="s2">def </span><span class="s1">_get_expected_reduction_dtype(self</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">, </span><span class="s1">op_name: str):</span>
        <span class="s2">if </span><span class="s1">op_name </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;max&quot;</span><span class="s2">, </span><span class="s3">&quot;min&quot;</span><span class="s1">]:</span>
            <span class="s1">cmp_dtype = arr.dtype</span>
        <span class="s2">elif </span><span class="s1">arr.dtype.name == </span><span class="s3">&quot;decimal128(7, 3)[pyarrow]&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">op_name </span><span class="s2">not in </span><span class="s1">[</span><span class="s3">&quot;median&quot;</span><span class="s2">, </span><span class="s3">&quot;var&quot;</span><span class="s2">, </span><span class="s3">&quot;std&quot;</span><span class="s1">]:</span>
                <span class="s1">cmp_dtype = arr.dtype</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">cmp_dtype = </span><span class="s3">&quot;float64[pyarrow]&quot;</span>
        <span class="s2">elif </span><span class="s1">op_name </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;median&quot;</span><span class="s2">, </span><span class="s3">&quot;var&quot;</span><span class="s2">, </span><span class="s3">&quot;std&quot;</span><span class="s2">, </span><span class="s3">&quot;mean&quot;</span><span class="s2">, </span><span class="s3">&quot;skew&quot;</span><span class="s1">]:</span>
            <span class="s1">cmp_dtype = </span><span class="s3">&quot;float64[pyarrow]&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">cmp_dtype = {</span>
                <span class="s3">&quot;i&quot;</span><span class="s1">: </span><span class="s3">&quot;int64[pyarrow]&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;u&quot;</span><span class="s1">: </span><span class="s3">&quot;uint64[pyarrow]&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;f&quot;</span><span class="s1">: </span><span class="s3">&quot;float64[pyarrow]&quot;</span><span class="s2">,</span>
            <span class="s1">}[arr.dtype.kind]</span>
        <span class="s2">return </span><span class="s1">cmp_dtype</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;skipna&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_reduce_frame(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">all_numeric_reductions</span><span class="s2">, </span><span class="s1">skipna</span><span class="s2">, </span><span class="s1">request):</span>
        <span class="s1">op_name = all_numeric_reductions</span>
        <span class="s2">if </span><span class="s1">op_name == </span><span class="s3">&quot;skew&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">data.dtype._is_numeric:</span>
                <span class="s1">mark = pytest.mark.xfail(reason=</span><span class="s3">&quot;skew not implemented&quot;</span><span class="s1">)</span>
                <span class="s1">request.node.add_marker(mark)</span>
        <span class="s2">return </span><span class="s1">super().test_reduce_frame(data</span><span class="s2">, </span><span class="s1">all_numeric_reductions</span><span class="s2">, </span><span class="s1">skipna)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;typ&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;int64&quot;</span><span class="s2">, </span><span class="s3">&quot;uint64&quot;</span><span class="s2">, </span><span class="s3">&quot;float64&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_median_not_approximate(self</span><span class="s2">, </span><span class="s1">typ):</span>
        <span class="s6"># GH 52679</span>
        <span class="s1">result = pd.Series([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">typ</span><span class="s2">}</span><span class="s3">[pyarrow]&quot;</span><span class="s1">).median()</span>
        <span class="s2">assert </span><span class="s1">result == </span><span class="s4">1.5</span>


<span class="s2">class </span><span class="s1">TestBaseGroupby(base.BaseGroupbyTests):</span>
    <span class="s2">def </span><span class="s1">test_in_numeric_groupby(self</span><span class="s2">, </span><span class="s1">data_for_grouping):</span>
        <span class="s1">dtype = data_for_grouping.dtype</span>
        <span class="s2">if </span><span class="s1">is_string_dtype(dtype):</span>
            <span class="s1">df = pd.DataFrame(</span>
                <span class="s1">{</span>
                    <span class="s3">&quot;A&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s3">&quot;B&quot;</span><span class="s1">: data_for_grouping</span><span class="s2">,</span>
                    <span class="s3">&quot;C&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">}</span>
            <span class="s1">)</span>

            <span class="s1">expected = pd.Index([</span><span class="s3">&quot;C&quot;</span><span class="s1">])</span>
            <span class="s1">msg = re.escape(</span><span class="s3">f&quot;agg function failed [how-&gt;sum,dtype-&gt;</span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
            <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
                <span class="s1">df.groupby(</span><span class="s3">&quot;A&quot;</span><span class="s1">).sum()</span>
            <span class="s1">result = df.groupby(</span><span class="s3">&quot;A&quot;</span><span class="s1">).sum(numeric_only=</span><span class="s2">True</span><span class="s1">).columns</span>
            <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">super().test_in_numeric_groupby(data_for_grouping)</span>


<span class="s2">class </span><span class="s1">TestBaseDtype(base.BaseDtypeTests):</span>
    <span class="s2">def </span><span class="s1">test_construct_from_string_own_name(self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">request):</span>
        <span class="s1">pa_dtype = dtype.pyarrow_dtype</span>
        <span class="s2">if </span><span class="s1">pa.types.is_decimal(pa_dtype):</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">raises=NotImplementedError</span><span class="s2">,</span>
                    <span class="s1">reason=</span><span class="s3">f&quot;pyarrow.type_for_alias cannot infer </span><span class="s2">{</span><span class="s1">pa_dtype</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">pa.types.is_string(pa_dtype):</span>
            <span class="s6"># We still support StringDtype('pyarrow') over ArrowDtype(pa.string())</span>
            <span class="s1">msg = </span><span class="s3">r&quot;string\[pyarrow\] should be constructed by StringDtype&quot;</span>
            <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
                <span class="s1">dtype.construct_from_string(dtype.name)</span>

            <span class="s2">return</span>

        <span class="s1">super().test_construct_from_string_own_name(dtype)</span>

    <span class="s2">def </span><span class="s1">test_is_dtype_from_name(self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">request):</span>
        <span class="s1">pa_dtype = dtype.pyarrow_dtype</span>
        <span class="s2">if </span><span class="s1">pa.types.is_string(pa_dtype):</span>
            <span class="s6"># We still support StringDtype('pyarrow') over ArrowDtype(pa.string())</span>
            <span class="s2">assert not </span><span class="s1">type(dtype).is_dtype(dtype.name)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">pa.types.is_decimal(pa_dtype):</span>
                <span class="s1">request.node.add_marker(</span>
                    <span class="s1">pytest.mark.xfail(</span>
                        <span class="s1">raises=NotImplementedError</span><span class="s2">,</span>
                        <span class="s1">reason=</span><span class="s3">f&quot;pyarrow.type_for_alias cannot infer </span><span class="s2">{</span><span class="s1">pa_dtype</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s2">,</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s1">super().test_is_dtype_from_name(dtype)</span>

    <span class="s2">def </span><span class="s1">test_construct_from_string_another_type_raises(self</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s1">msg = </span><span class="s3">r&quot;'another_type' must end with '\[pyarrow\]'&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">type(dtype).construct_from_string(</span><span class="s3">&quot;another_type&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_get_common_dtype(self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">request):</span>
        <span class="s1">pa_dtype = dtype.pyarrow_dtype</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">pa.types.is_date(pa_dtype)</span>
            <span class="s2">or </span><span class="s1">pa.types.is_time(pa_dtype)</span>
            <span class="s2">or </span><span class="s1">(pa.types.is_timestamp(pa_dtype) </span><span class="s2">and </span><span class="s1">pa_dtype.tz </span><span class="s2">is not None</span><span class="s1">)</span>
            <span class="s2">or </span><span class="s1">pa.types.is_binary(pa_dtype)</span>
            <span class="s2">or </span><span class="s1">pa.types.is_decimal(pa_dtype)</span>
        <span class="s1">):</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">reason=(</span>
                        <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">pa_dtype</span><span class="s2">} </span><span class="s3">does not have associated numpy &quot;</span>
                        <span class="s3">f&quot;dtype findable by find_common_type&quot;</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s1">super().test_get_common_dtype(dtype)</span>

    <span class="s2">def </span><span class="s1">test_is_not_string_type(self</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s1">pa_dtype = dtype.pyarrow_dtype</span>
        <span class="s2">if </span><span class="s1">pa.types.is_string(pa_dtype):</span>
            <span class="s2">assert </span><span class="s1">is_string_dtype(dtype)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">super().test_is_not_string_type(dtype)</span>


<span class="s2">class </span><span class="s1">TestBaseIndex(base.BaseIndexTests):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestBaseInterface(base.BaseInterfaceTests):</span>
    <span class="s1">@pytest.mark.xfail(</span>
        <span class="s1">reason=</span><span class="s3">&quot;GH 45419: pyarrow.ChunkedArray does not support views.&quot;</span><span class="s2">, </span><span class="s1">run=</span><span class="s2">False</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_view(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">super().test_view(data)</span>


<span class="s2">class </span><span class="s1">TestBaseMissing(base.BaseMissingTests):</span>
    <span class="s2">def </span><span class="s1">test_fillna_no_op_returns_copy(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">data = data[~data.isna()]</span>

        <span class="s1">valid = data[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">result = data.fillna(valid)</span>
        <span class="s2">assert </span><span class="s1">result </span><span class="s2">is not </span><span class="s1">data</span>
        <span class="s1">tm.assert_extension_array_equal(result</span><span class="s2">, </span><span class="s1">data)</span>

        <span class="s1">result = data.fillna(method=</span><span class="s3">&quot;backfill&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result </span><span class="s2">is not </span><span class="s1">data</span>
        <span class="s1">tm.assert_extension_array_equal(result</span><span class="s2">, </span><span class="s1">data)</span>


<span class="s2">class </span><span class="s1">TestBasePrinting(base.BasePrintingTests):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestBaseReshaping(base.BaseReshapingTests):</span>
    <span class="s1">@pytest.mark.xfail(</span>
        <span class="s1">reason=</span><span class="s3">&quot;GH 45419: pyarrow.ChunkedArray does not support views&quot;</span><span class="s2">, </span><span class="s1">run=</span><span class="s2">False</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_transpose(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">super().test_transpose(data)</span>


<span class="s2">class </span><span class="s1">TestBaseSetitem(base.BaseSetitemTests):</span>
    <span class="s1">@pytest.mark.xfail(</span>
        <span class="s1">reason=</span><span class="s3">&quot;GH 45419: pyarrow.ChunkedArray does not support views&quot;</span><span class="s2">, </span><span class="s1">run=</span><span class="s2">False</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_setitem_preserves_views(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">super().test_setitem_preserves_views(data)</span>


<span class="s2">class </span><span class="s1">TestBaseParsing(base.BaseParsingTests):</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype_backend&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;pyarrow&quot;</span><span class="s2">, </span><span class="s1">no_default])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;engine&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s3">&quot;python&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_EA_types(self</span><span class="s2">, </span><span class="s1">engine</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">dtype_backend</span><span class="s2">, </span><span class="s1">request):</span>
        <span class="s1">pa_dtype = data.dtype.pyarrow_dtype</span>
        <span class="s2">if </span><span class="s1">pa.types.is_decimal(pa_dtype):</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">raises=NotImplementedError</span><span class="s2">,</span>
                    <span class="s1">reason=</span><span class="s3">f&quot;Parameterized types </span><span class="s2">{</span><span class="s1">pa_dtype</span><span class="s2">} </span><span class="s3">not supported.&quot;</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">pa.types.is_timestamp(pa_dtype) </span><span class="s2">and </span><span class="s1">pa_dtype.unit </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;us&quot;</span><span class="s2">, </span><span class="s3">&quot;ns&quot;</span><span class="s1">):</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">raises=ValueError</span><span class="s2">,</span>
                    <span class="s1">reason=</span><span class="s3">&quot;https://github.com/pandas-dev/pandas/issues/49767&quot;</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">pa.types.is_binary(pa_dtype):</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(reason=</span><span class="s3">&quot;CSV parsers don't correctly handle binary&quot;</span><span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s1">df = pd.DataFrame({</span><span class="s3">&quot;with_dtype&quot;</span><span class="s1">: pd.Series(data</span><span class="s2">, </span><span class="s1">dtype=str(data.dtype))})</span>
        <span class="s1">csv_output = df.to_csv(index=</span><span class="s2">False, </span><span class="s1">na_rep=np.nan)</span>
        <span class="s2">if </span><span class="s1">pa.types.is_binary(pa_dtype):</span>
            <span class="s1">csv_output = BytesIO(csv_output)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">csv_output = StringIO(csv_output)</span>
        <span class="s1">result = pd.read_csv(</span>
            <span class="s1">csv_output</span><span class="s2">,</span>
            <span class="s1">dtype={</span><span class="s3">&quot;with_dtype&quot;</span><span class="s1">: str(data.dtype)}</span><span class="s2">,</span>
            <span class="s1">engine=engine</span><span class="s2">,</span>
            <span class="s1">dtype_backend=dtype_backend</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">expected = df</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">class </span><span class="s1">TestBaseUnaryOps(base.BaseUnaryOpsTests):</span>
    <span class="s2">def </span><span class="s1">test_invert(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">request):</span>
        <span class="s1">pa_dtype = data.dtype.pyarrow_dtype</span>
        <span class="s2">if not </span><span class="s1">(pa.types.is_boolean(pa_dtype) </span><span class="s2">or </span><span class="s1">pa.types.is_integer(pa_dtype)):</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">raises=pa.ArrowNotImplementedError</span><span class="s2">,</span>
                    <span class="s1">reason=</span><span class="s3">f&quot;pyarrow.compute.invert does support </span><span class="s2">{</span><span class="s1">pa_dtype</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s1">super().test_invert(data)</span>


<span class="s2">class </span><span class="s1">TestBaseMethods(base.BaseMethodsTests):</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;periods&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_diff(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">periods</span><span class="s2">, </span><span class="s1">request):</span>
        <span class="s1">pa_dtype = data.dtype.pyarrow_dtype</span>
        <span class="s2">if </span><span class="s1">pa.types.is_unsigned_integer(pa_dtype) </span><span class="s2">and </span><span class="s1">periods == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">raises=pa.ArrowInvalid</span><span class="s2">,</span>
                    <span class="s1">reason=(</span>
                        <span class="s3">f&quot;diff with </span><span class="s2">{</span><span class="s1">pa_dtype</span><span class="s2">} </span><span class="s3">and periods=</span><span class="s2">{</span><span class="s1">periods</span><span class="s2">} </span><span class="s3">will overflow&quot;</span>
                    <span class="s1">)</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s1">super().test_diff(data</span><span class="s2">, </span><span class="s1">periods)</span>

    <span class="s2">def </span><span class="s1">test_value_counts_returns_pyarrow_int64(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s6"># GH 51462</span>
        <span class="s1">data = data[:</span><span class="s4">10</span><span class="s1">]</span>
        <span class="s1">result = data.value_counts()</span>
        <span class="s2">assert </span><span class="s1">result.dtype == ArrowDtype(pa.int64())</span>

    <span class="s2">def </span><span class="s1">test_argmin_argmax(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">data_for_sorting</span><span class="s2">, </span><span class="s1">data_missing_for_sorting</span><span class="s2">, </span><span class="s1">na_value</span><span class="s2">, </span><span class="s1">request</span>
    <span class="s1">):</span>
        <span class="s1">pa_dtype = data_for_sorting.dtype.pyarrow_dtype</span>
        <span class="s2">if </span><span class="s1">pa.types.is_decimal(pa_dtype) </span><span class="s2">and </span><span class="s1">pa_version_under7p0:</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">reason=</span><span class="s3">f&quot;No pyarrow kernel for </span><span class="s2">{</span><span class="s1">pa_dtype</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s2">,</span>
                    <span class="s1">raises=pa.ArrowNotImplementedError</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s1">super().test_argmin_argmax(data_for_sorting</span><span class="s2">, </span><span class="s1">data_missing_for_sorting</span><span class="s2">, </span><span class="s1">na_value)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;op_name, skipna, expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">&quot;idxmax&quot;</span><span class="s2">, True, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;idxmin&quot;</span><span class="s2">, True, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;argmax&quot;</span><span class="s2">, True, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;argmin&quot;</span><span class="s2">, True, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;idxmax&quot;</span><span class="s2">, False, </span><span class="s1">np.nan)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;idxmin&quot;</span><span class="s2">, False, </span><span class="s1">np.nan)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;argmax&quot;</span><span class="s2">, False, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;argmin&quot;</span><span class="s2">, False, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_argreduce_series(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">data_missing_for_sorting</span><span class="s2">, </span><span class="s1">op_name</span><span class="s2">, </span><span class="s1">skipna</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">request</span>
    <span class="s1">):</span>
        <span class="s1">pa_dtype = data_missing_for_sorting.dtype.pyarrow_dtype</span>
        <span class="s2">if </span><span class="s1">pa.types.is_decimal(pa_dtype) </span><span class="s2">and </span><span class="s1">pa_version_under7p0 </span><span class="s2">and </span><span class="s1">skipna:</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">reason=</span><span class="s3">f&quot;No pyarrow kernel for </span><span class="s2">{</span><span class="s1">pa_dtype</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s2">,</span>
                    <span class="s1">raises=pa.ArrowNotImplementedError</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s1">super().test_argreduce_series(</span>
            <span class="s1">data_missing_for_sorting</span><span class="s2">, </span><span class="s1">op_name</span><span class="s2">, </span><span class="s1">skipna</span><span class="s2">, </span><span class="s1">expected</span>
        <span class="s1">)</span>

    <span class="s1">_combine_le_expected_dtype = </span><span class="s3">&quot;bool[pyarrow]&quot;</span>


<span class="s2">class </span><span class="s1">TestBaseArithmeticOps(base.BaseArithmeticOpsTests):</span>
    <span class="s1">divmod_exc = NotImplementedError</span>

    <span class="s2">def </span><span class="s1">get_op_from_name(self</span><span class="s2">, </span><span class="s1">op_name):</span>
        <span class="s1">short_opname = op_name.strip(</span><span class="s3">&quot;_&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">short_opname == </span><span class="s3">&quot;rtruediv&quot;</span><span class="s1">:</span>
            <span class="s6"># use the numpy version that won't raise on division by zero</span>

            <span class="s2">def </span><span class="s1">rtruediv(x</span><span class="s2">, </span><span class="s1">y):</span>
                <span class="s2">return </span><span class="s1">np.divide(y</span><span class="s2">, </span><span class="s1">x)</span>

            <span class="s2">return </span><span class="s1">rtruediv</span>
        <span class="s2">elif </span><span class="s1">short_opname == </span><span class="s3">&quot;rfloordiv&quot;</span><span class="s1">:</span>
            <span class="s2">return lambda </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y: np.floor_divide(y</span><span class="s2">, </span><span class="s1">x)</span>

        <span class="s2">return </span><span class="s1">tm.get_op_from_name(op_name)</span>

    <span class="s2">def </span><span class="s1">_cast_pointwise_result(self</span><span class="s2">, </span><span class="s1">op_name: str</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">pointwise_result):</span>
        <span class="s6"># BaseOpsUtil._combine can upcast expected dtype</span>
        <span class="s6"># (because it generates expected on python scalars)</span>
        <span class="s6"># while ArrowExtensionArray maintains original type</span>
        <span class="s1">expected = pointwise_result</span>

        <span class="s1">was_frame = </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s1">isinstance(expected</span><span class="s2">, </span><span class="s1">pd.DataFrame):</span>
            <span class="s1">was_frame = </span><span class="s2">True</span>
            <span class="s1">expected_data = expected.iloc[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">original_dtype = obj.iloc[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">].dtype</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">expected_data = expected</span>
            <span class="s1">original_dtype = obj.dtype</span>

        <span class="s1">orig_pa_type = original_dtype.pyarrow_dtype</span>
        <span class="s2">if not </span><span class="s1">was_frame </span><span class="s2">and </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">pd.Series):</span>
            <span class="s6"># i.e. test_arith_series_with_array</span>
            <span class="s2">if not </span><span class="s1">(</span>
                <span class="s1">pa.types.is_floating(orig_pa_type)</span>
                <span class="s2">or </span><span class="s1">(</span>
                    <span class="s1">pa.types.is_integer(orig_pa_type)</span>
                    <span class="s2">and </span><span class="s1">op_name </span><span class="s2">not in </span><span class="s1">[</span><span class="s3">&quot;__truediv__&quot;</span><span class="s2">, </span><span class="s3">&quot;__rtruediv__&quot;</span><span class="s1">]</span>
                <span class="s1">)</span>
                <span class="s2">or </span><span class="s1">pa.types.is_duration(orig_pa_type)</span>
                <span class="s2">or </span><span class="s1">pa.types.is_timestamp(orig_pa_type)</span>
                <span class="s2">or </span><span class="s1">pa.types.is_date(orig_pa_type)</span>
                <span class="s2">or </span><span class="s1">pa.types.is_decimal(orig_pa_type)</span>
            <span class="s1">):</span>
                <span class="s6"># base class _combine always returns int64, while</span>
                <span class="s6">#  ArrowExtensionArray does not upcast</span>
                <span class="s2">return </span><span class="s1">expected</span>
        <span class="s2">elif not </span><span class="s1">(</span>
            <span class="s1">(op_name == </span><span class="s3">&quot;__floordiv__&quot; </span><span class="s2">and </span><span class="s1">pa.types.is_integer(orig_pa_type))</span>
            <span class="s2">or </span><span class="s1">pa.types.is_duration(orig_pa_type)</span>
            <span class="s2">or </span><span class="s1">pa.types.is_timestamp(orig_pa_type)</span>
            <span class="s2">or </span><span class="s1">pa.types.is_date(orig_pa_type)</span>
            <span class="s2">or </span><span class="s1">pa.types.is_decimal(orig_pa_type)</span>
        <span class="s1">):</span>
            <span class="s6"># base class _combine always returns int64, while</span>
            <span class="s6">#  ArrowExtensionArray does not upcast</span>
            <span class="s2">return </span><span class="s1">expected</span>

        <span class="s1">pa_expected = pa.array(expected_data._values)</span>

        <span class="s2">if </span><span class="s1">pa.types.is_duration(pa_expected.type):</span>
            <span class="s2">if </span><span class="s1">pa.types.is_date(orig_pa_type):</span>
                <span class="s2">if </span><span class="s1">pa.types.is_date64(orig_pa_type):</span>
                    <span class="s6"># TODO: why is this different vs date32?</span>
                    <span class="s1">unit = </span><span class="s3">&quot;ms&quot;</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">unit = </span><span class="s3">&quot;s&quot;</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s6"># pyarrow sees sequence of datetime/timedelta objects and defaults</span>
                <span class="s6">#  to &quot;us&quot; but the non-pointwise op retains unit</span>
                <span class="s6"># timestamp or duration</span>
                <span class="s1">unit = orig_pa_type.unit</span>
                <span class="s2">if </span><span class="s1">type(other) </span><span class="s2">in </span><span class="s1">[datetime</span><span class="s2">, </span><span class="s1">timedelta] </span><span class="s2">and </span><span class="s1">unit </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s3">&quot;ms&quot;</span><span class="s1">]:</span>
                    <span class="s6"># pydatetime/pytimedelta objects have microsecond reso, so we</span>
                    <span class="s6">#  take the higher reso of the original and microsecond. Note</span>
                    <span class="s6">#  this matches what we would do with DatetimeArray/TimedeltaArray</span>
                    <span class="s1">unit = </span><span class="s3">&quot;us&quot;</span>

            <span class="s1">pa_expected = pa_expected.cast(</span><span class="s3">f&quot;duration[</span><span class="s2">{</span><span class="s1">unit</span><span class="s2">}</span><span class="s3">]&quot;</span><span class="s1">)</span>

        <span class="s2">elif </span><span class="s1">pa.types.is_decimal(pa_expected.type) </span><span class="s2">and </span><span class="s1">pa.types.is_decimal(</span>
            <span class="s1">orig_pa_type</span>
        <span class="s1">):</span>
            <span class="s6"># decimal precision can resize in the result type depending on data</span>
            <span class="s6"># just compare the float values</span>
            <span class="s1">alt = getattr(obj</span><span class="s2">, </span><span class="s1">op_name)(other)</span>
            <span class="s1">alt_dtype = tm.get_dtype(alt)</span>
            <span class="s2">assert </span><span class="s1">isinstance(alt_dtype</span><span class="s2">, </span><span class="s1">ArrowDtype)</span>
            <span class="s2">if </span><span class="s1">op_name == </span><span class="s3">&quot;__pow__&quot; </span><span class="s2">and </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">Decimal):</span>
                <span class="s6"># TODO: would it make more sense to retain Decimal here?</span>
                <span class="s1">alt_dtype = ArrowDtype(pa.float64())</span>
            <span class="s2">elif </span><span class="s1">(</span>
                <span class="s1">op_name == </span><span class="s3">&quot;__pow__&quot;</span>
                <span class="s2">and </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">pd.Series)</span>
                <span class="s2">and </span><span class="s1">other.dtype == original_dtype</span>
            <span class="s1">):</span>
                <span class="s6"># TODO: would it make more sense to retain Decimal here?</span>
                <span class="s1">alt_dtype = ArrowDtype(pa.float64())</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">assert </span><span class="s1">pa.types.is_decimal(alt_dtype.pyarrow_dtype)</span>
            <span class="s2">return </span><span class="s1">expected.astype(alt_dtype)</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">pa_expected = pa_expected.cast(orig_pa_type)</span>

        <span class="s1">pd_expected = type(expected_data._values)(pa_expected)</span>
        <span class="s2">if </span><span class="s1">was_frame:</span>
            <span class="s1">expected = pd.DataFrame(</span>
                <span class="s1">pd_expected</span><span class="s2">, </span><span class="s1">index=expected.index</span><span class="s2">, </span><span class="s1">columns=expected.columns</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">expected = pd.Series(pd_expected)</span>
        <span class="s2">return </span><span class="s1">expected</span>

    <span class="s2">def </span><span class="s1">_is_temporal_supported(self</span><span class="s2">, </span><span class="s1">opname</span><span class="s2">, </span><span class="s1">pa_dtype):</span>
        <span class="s2">return not </span><span class="s1">pa_version_under8p0 </span><span class="s2">and </span><span class="s1">(</span>
            <span class="s1">(</span>
                <span class="s1">opname </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;__add__&quot;</span><span class="s2">, </span><span class="s3">&quot;__radd__&quot;</span><span class="s1">)</span>
                <span class="s2">or </span><span class="s1">(</span>
                    <span class="s1">opname</span>
                    <span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;__truediv__&quot;</span><span class="s2">, </span><span class="s3">&quot;__rtruediv__&quot;</span><span class="s2">, </span><span class="s3">&quot;__floordiv__&quot;</span><span class="s2">, </span><span class="s3">&quot;__rfloordiv__&quot;</span><span class="s1">)</span>
                    <span class="s2">and not </span><span class="s1">pa_version_under14p0</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s2">and </span><span class="s1">pa.types.is_duration(pa_dtype)</span>
            <span class="s2">or </span><span class="s1">opname </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;__sub__&quot;</span><span class="s2">, </span><span class="s3">&quot;__rsub__&quot;</span><span class="s1">)</span>
            <span class="s2">and </span><span class="s1">pa.types.is_temporal(pa_dtype)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_get_expected_exception(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">op_name: str</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">other</span>
    <span class="s1">) -&gt; type[Exception] | </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">op_name </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;__divmod__&quot;</span><span class="s2">, </span><span class="s3">&quot;__rdivmod__&quot;</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">self.divmod_exc</span>

        <span class="s1">dtype = tm.get_dtype(obj)</span>
        <span class="s6"># error: Item &quot;dtype[Any]&quot; of &quot;dtype[Any] | ExtensionDtype&quot; has no</span>
        <span class="s6"># attribute &quot;pyarrow_dtype&quot;</span>
        <span class="s1">pa_dtype = dtype.pyarrow_dtype  </span><span class="s6"># type: ignore[union-attr]</span>

        <span class="s1">arrow_temporal_supported = self._is_temporal_supported(op_name</span><span class="s2">, </span><span class="s1">pa_dtype)</span>
        <span class="s2">if </span><span class="s1">op_name </span><span class="s2">in </span><span class="s1">{</span>
            <span class="s3">&quot;__mod__&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;__rmod__&quot;</span><span class="s2">,</span>
        <span class="s1">}:</span>
            <span class="s1">exc = NotImplementedError</span>
        <span class="s2">elif </span><span class="s1">arrow_temporal_supported:</span>
            <span class="s1">exc = </span><span class="s2">None</span>
        <span class="s2">elif </span><span class="s1">op_name </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;__add__&quot;</span><span class="s2">, </span><span class="s3">&quot;__radd__&quot;</span><span class="s1">] </span><span class="s2">and </span><span class="s1">(</span>
            <span class="s1">pa.types.is_string(pa_dtype) </span><span class="s2">or </span><span class="s1">pa.types.is_binary(pa_dtype)</span>
        <span class="s1">):</span>
            <span class="s1">exc = </span><span class="s2">None</span>
        <span class="s2">elif not </span><span class="s1">(</span>
            <span class="s1">pa.types.is_floating(pa_dtype)</span>
            <span class="s2">or </span><span class="s1">pa.types.is_integer(pa_dtype)</span>
            <span class="s2">or </span><span class="s1">pa.types.is_decimal(pa_dtype)</span>
        <span class="s1">):</span>
            <span class="s6"># TODO: in many of these cases, e.g. non-duration temporal,</span>
            <span class="s6">#  these will *never* be allowed. Would it make more sense to</span>
            <span class="s6">#  re-raise as TypeError, more consistent with non-pyarrow cases?</span>
            <span class="s1">exc = pa.ArrowNotImplementedError</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">exc = </span><span class="s2">None</span>
        <span class="s2">return </span><span class="s1">exc</span>

    <span class="s2">def </span><span class="s1">_get_arith_xfail_marker(self</span><span class="s2">, </span><span class="s1">opname</span><span class="s2">, </span><span class="s1">pa_dtype):</span>
        <span class="s1">mark = </span><span class="s2">None</span>

        <span class="s1">arrow_temporal_supported = self._is_temporal_supported(opname</span><span class="s2">, </span><span class="s1">pa_dtype)</span>

        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">opname == </span><span class="s3">&quot;__rpow__&quot;</span>
            <span class="s2">and </span><span class="s1">(</span>
                <span class="s1">pa.types.is_floating(pa_dtype)</span>
                <span class="s2">or </span><span class="s1">pa.types.is_integer(pa_dtype)</span>
                <span class="s2">or </span><span class="s1">pa.types.is_decimal(pa_dtype)</span>
            <span class="s1">)</span>
            <span class="s2">and not </span><span class="s1">pa_version_under7p0</span>
        <span class="s1">):</span>
            <span class="s1">mark = pytest.mark.xfail(</span>
                <span class="s1">reason=(</span>
                    <span class="s3">f&quot;GH#29997: 1**pandas.NA == 1 while 1**pyarrow.NA == NULL &quot;</span>
                    <span class="s3">f&quot;for </span><span class="s2">{</span><span class="s1">pa_dtype</span><span class="s2">}</span><span class="s3">&quot;</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">arrow_temporal_supported </span><span class="s2">and </span><span class="s1">(</span>
            <span class="s1">pa.types.is_time(pa_dtype)</span>
            <span class="s2">or </span><span class="s1">(</span>
                <span class="s1">opname</span>
                <span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;__truediv__&quot;</span><span class="s2">, </span><span class="s3">&quot;__rtruediv__&quot;</span><span class="s2">, </span><span class="s3">&quot;__floordiv__&quot;</span><span class="s2">, </span><span class="s3">&quot;__rfloordiv__&quot;</span><span class="s1">)</span>
                <span class="s2">and </span><span class="s1">pa.types.is_duration(pa_dtype)</span>
            <span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s1">mark = pytest.mark.xfail(</span>
                <span class="s1">raises=TypeError</span><span class="s2">,</span>
                <span class="s1">reason=(</span>
                    <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">opname</span><span class="s2">} </span><span class="s3">not supported between&quot;</span>
                    <span class="s3">f&quot;pd.NA and </span><span class="s2">{</span><span class="s1">pa_dtype</span><span class="s2">} </span><span class="s3">Python scalar&quot;</span>
                <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">(</span>
            <span class="s1">opname == </span><span class="s3">&quot;__rfloordiv__&quot;</span>
            <span class="s2">and </span><span class="s1">(pa.types.is_integer(pa_dtype) </span><span class="s2">or </span><span class="s1">pa.types.is_decimal(pa_dtype))</span>
            <span class="s2">and not </span><span class="s1">pa_version_under7p0</span>
        <span class="s1">):</span>
            <span class="s1">mark = pytest.mark.xfail(</span>
                <span class="s1">raises=pa.ArrowInvalid</span><span class="s2">,</span>
                <span class="s1">reason=</span><span class="s3">&quot;divide by 0&quot;</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">(</span>
            <span class="s1">opname == </span><span class="s3">&quot;__rtruediv__&quot;</span>
            <span class="s2">and </span><span class="s1">pa.types.is_decimal(pa_dtype)</span>
            <span class="s2">and not </span><span class="s1">pa_version_under7p0</span>
        <span class="s1">):</span>
            <span class="s1">mark = pytest.mark.xfail(</span>
                <span class="s1">raises=pa.ArrowInvalid</span><span class="s2">,</span>
                <span class="s1">reason=</span><span class="s3">&quot;divide by 0&quot;</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">(</span>
            <span class="s1">opname == </span><span class="s3">&quot;__pow__&quot;</span>
            <span class="s2">and </span><span class="s1">pa.types.is_decimal(pa_dtype)</span>
            <span class="s2">and </span><span class="s1">pa_version_under7p0</span>
        <span class="s1">):</span>
            <span class="s1">mark = pytest.mark.xfail(</span>
                <span class="s1">raises=pa.ArrowInvalid</span><span class="s2">,</span>
                <span class="s1">reason=</span><span class="s3">&quot;Invalid decimal function: power_checked&quot;</span><span class="s2">,</span>
            <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">mark</span>

    <span class="s2">def </span><span class="s1">test_arith_series_with_scalar(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">all_arithmetic_operators</span><span class="s2">, </span><span class="s1">request):</span>
        <span class="s1">pa_dtype = data.dtype.pyarrow_dtype</span>

        <span class="s2">if </span><span class="s1">all_arithmetic_operators == </span><span class="s3">&quot;__rmod__&quot; </span><span class="s2">and </span><span class="s1">(</span>
            <span class="s1">pa.types.is_string(pa_dtype) </span><span class="s2">or </span><span class="s1">pa.types.is_binary(pa_dtype)</span>
        <span class="s1">):</span>
            <span class="s1">pytest.skip(</span><span class="s3">&quot;Skip testing Python string formatting&quot;</span><span class="s1">)</span>

        <span class="s1">mark = self._get_arith_xfail_marker(all_arithmetic_operators</span><span class="s2">, </span><span class="s1">pa_dtype)</span>
        <span class="s2">if </span><span class="s1">mark </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">request.node.add_marker(mark)</span>

        <span class="s1">super().test_arith_series_with_scalar(data</span><span class="s2">, </span><span class="s1">all_arithmetic_operators)</span>

    <span class="s2">def </span><span class="s1">test_arith_frame_with_scalar(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">all_arithmetic_operators</span><span class="s2">, </span><span class="s1">request):</span>
        <span class="s1">pa_dtype = data.dtype.pyarrow_dtype</span>

        <span class="s2">if </span><span class="s1">all_arithmetic_operators == </span><span class="s3">&quot;__rmod__&quot; </span><span class="s2">and </span><span class="s1">(</span>
            <span class="s1">pa.types.is_string(pa_dtype) </span><span class="s2">or </span><span class="s1">pa.types.is_binary(pa_dtype)</span>
        <span class="s1">):</span>
            <span class="s1">pytest.skip(</span><span class="s3">&quot;Skip testing Python string formatting&quot;</span><span class="s1">)</span>

        <span class="s1">mark = self._get_arith_xfail_marker(all_arithmetic_operators</span><span class="s2">, </span><span class="s1">pa_dtype)</span>
        <span class="s2">if </span><span class="s1">mark </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">request.node.add_marker(mark)</span>

        <span class="s1">super().test_arith_frame_with_scalar(data</span><span class="s2">, </span><span class="s1">all_arithmetic_operators)</span>

    <span class="s2">def </span><span class="s1">test_arith_series_with_array(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">all_arithmetic_operators</span><span class="s2">, </span><span class="s1">request):</span>
        <span class="s1">pa_dtype = data.dtype.pyarrow_dtype</span>

        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">all_arithmetic_operators</span>
            <span class="s2">in </span><span class="s1">(</span>
                <span class="s3">&quot;__sub__&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;__rsub__&quot;</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s2">and </span><span class="s1">pa.types.is_unsigned_integer(pa_dtype)</span>
            <span class="s2">and not </span><span class="s1">pa_version_under7p0</span>
        <span class="s1">):</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">raises=pa.ArrowInvalid</span><span class="s2">,</span>
                    <span class="s1">reason=(</span>
                        <span class="s3">f&quot;Implemented pyarrow.compute.subtract_checked &quot;</span>
                        <span class="s3">f&quot;which raises on overflow for </span><span class="s2">{</span><span class="s1">pa_dtype</span><span class="s2">}</span><span class="s3">&quot;</span>
                    <span class="s1">)</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s1">mark = self._get_arith_xfail_marker(all_arithmetic_operators</span><span class="s2">, </span><span class="s1">pa_dtype)</span>
        <span class="s2">if </span><span class="s1">mark </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">request.node.add_marker(mark)</span>

        <span class="s1">op_name = all_arithmetic_operators</span>
        <span class="s1">ser = pd.Series(data)</span>
        <span class="s6"># pd.Series([ser.iloc[0]] * len(ser)) may not return ArrowExtensionArray</span>
        <span class="s6"># since ser.iloc[0] is a python scalar</span>
        <span class="s1">other = pd.Series(pd.array([ser.iloc[</span><span class="s4">0</span><span class="s1">]] * len(ser)</span><span class="s2">, </span><span class="s1">dtype=data.dtype))</span>

        <span class="s1">self.check_opname(ser</span><span class="s2">, </span><span class="s1">op_name</span><span class="s2">, </span><span class="s1">other)</span>

    <span class="s2">def </span><span class="s1">test_add_series_with_extension_array(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">request):</span>
        <span class="s1">pa_dtype = data.dtype.pyarrow_dtype</span>

        <span class="s2">if </span><span class="s1">pa_dtype.equals(</span><span class="s3">&quot;int8&quot;</span><span class="s1">):</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">raises=pa.ArrowInvalid</span><span class="s2">,</span>
                    <span class="s1">reason=</span><span class="s3">f&quot;raises on overflow for </span><span class="s2">{</span><span class="s1">pa_dtype</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s1">super().test_add_series_with_extension_array(data)</span>


<span class="s2">class </span><span class="s1">TestBaseComparisonOps(base.BaseComparisonOpsTests):</span>
    <span class="s2">def </span><span class="s1">test_compare_array(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">comparison_op</span><span class="s2">, </span><span class="s1">na_value):</span>
        <span class="s1">ser = pd.Series(data)</span>
        <span class="s6"># pd.Series([ser.iloc[0]] * len(ser)) may not return ArrowExtensionArray</span>
        <span class="s6"># since ser.iloc[0] is a python scalar</span>
        <span class="s1">other = pd.Series(pd.array([ser.iloc[</span><span class="s4">0</span><span class="s1">]] * len(ser)</span><span class="s2">, </span><span class="s1">dtype=data.dtype))</span>
        <span class="s2">if </span><span class="s1">comparison_op.__name__ </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;eq&quot;</span><span class="s2">, </span><span class="s3">&quot;ne&quot;</span><span class="s1">]:</span>
            <span class="s6"># comparison should match point-wise comparisons</span>
            <span class="s1">result = comparison_op(ser</span><span class="s2">, </span><span class="s1">other)</span>
            <span class="s6"># Series.combine does not calculate the NA mask correctly</span>
            <span class="s6"># when comparing over an array</span>
            <span class="s2">assert </span><span class="s1">result[</span><span class="s4">8</span><span class="s1">] </span><span class="s2">is </span><span class="s1">na_value</span>
            <span class="s2">assert </span><span class="s1">result[</span><span class="s4">97</span><span class="s1">] </span><span class="s2">is </span><span class="s1">na_value</span>
            <span class="s1">expected = ser.combine(other</span><span class="s2">, </span><span class="s1">comparison_op)</span>
            <span class="s1">expected[</span><span class="s4">8</span><span class="s1">] = na_value</span>
            <span class="s1">expected[</span><span class="s4">97</span><span class="s1">] = na_value</span>
            <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">super().test_compare_array(data</span><span class="s2">, </span><span class="s1">comparison_op)</span>

    <span class="s2">def </span><span class="s1">test_invalid_other_comp(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">comparison_op):</span>
        <span class="s6"># GH 48833</span>
        <span class="s2">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">NotImplementedError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;.* not implemented for &lt;class 'object'&gt;&quot;</span>
        <span class="s1">):</span>
            <span class="s1">comparison_op(data</span><span class="s2">, </span><span class="s1">object())</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;masked_dtype&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;boolean&quot;</span><span class="s2">, </span><span class="s3">&quot;Int64&quot;</span><span class="s2">, </span><span class="s3">&quot;Float64&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_comp_masked_numpy(self</span><span class="s2">, </span><span class="s1">masked_dtype</span><span class="s2">, </span><span class="s1">comparison_op):</span>
        <span class="s6"># GH 52625</span>
        <span class="s1">data = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, None</span><span class="s1">]</span>
        <span class="s1">ser_masked = pd.Series(data</span><span class="s2">, </span><span class="s1">dtype=masked_dtype)</span>
        <span class="s1">ser_pa = pd.Series(data</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">masked_dtype.lower()</span><span class="s2">}</span><span class="s3">[pyarrow]&quot;</span><span class="s1">)</span>
        <span class="s1">result = comparison_op(ser_pa</span><span class="s2">, </span><span class="s1">ser_masked)</span>
        <span class="s2">if </span><span class="s1">comparison_op </span><span class="s2">in </span><span class="s1">[operator.lt</span><span class="s2">, </span><span class="s1">operator.gt</span><span class="s2">, </span><span class="s1">operator.ne]:</span>
            <span class="s1">exp = [</span><span class="s2">False, False, None</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">exp = [</span><span class="s2">True, True, None</span><span class="s1">]</span>
        <span class="s1">expected = pd.Series(exp</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.bool_()))</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">class </span><span class="s1">TestLogicalOps:</span>
    <span class="s0">&quot;&quot;&quot;Various Series and DataFrame logical ops methods.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">test_kleene_or(self):</span>
        <span class="s1">a = pd.Series([</span><span class="s2">True</span><span class="s1">] * </span><span class="s4">3 </span><span class="s1">+ [</span><span class="s2">False</span><span class="s1">] * </span><span class="s4">3 </span><span class="s1">+ [</span><span class="s2">None</span><span class="s1">] * </span><span class="s4">3</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;boolean[pyarrow]&quot;</span><span class="s1">)</span>
        <span class="s1">b = pd.Series([</span><span class="s2">True, False, None</span><span class="s1">] * </span><span class="s4">3</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;boolean[pyarrow]&quot;</span><span class="s1">)</span>
        <span class="s1">result = a | b</span>
        <span class="s1">expected = pd.Series(</span>
            <span class="s1">[</span><span class="s2">True, True, True, True, False, None, True, None, None</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">dtype=</span><span class="s3">&quot;boolean[pyarrow]&quot;</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = b | a</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s6"># ensure we haven't mutated anything inplace</span>
        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">a</span><span class="s2">,</span>
            <span class="s1">pd.Series([</span><span class="s2">True</span><span class="s1">] * </span><span class="s4">3 </span><span class="s1">+ [</span><span class="s2">False</span><span class="s1">] * </span><span class="s4">3 </span><span class="s1">+ [</span><span class="s2">None</span><span class="s1">] * </span><span class="s4">3</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;boolean[pyarrow]&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">b</span><span class="s2">, </span><span class="s1">pd.Series([</span><span class="s2">True, False, None</span><span class="s1">] * </span><span class="s4">3</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;boolean[pyarrow]&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;other, expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s2">None, </span><span class="s1">[</span><span class="s2">True, None, None</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">(pd.NA</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, None, None</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s2">True, </span><span class="s1">[</span><span class="s2">True, True, True</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">(np.bool_(</span><span class="s2">True</span><span class="s1">)</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, True, True</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s2">False, </span><span class="s1">[</span><span class="s2">True, False, None</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">(np.bool_(</span><span class="s2">False</span><span class="s1">)</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False, None</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_kleene_or_scalar(self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s1">a = pd.Series([</span><span class="s2">True, False, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;boolean[pyarrow]&quot;</span><span class="s1">)</span>
        <span class="s1">result = a | other</span>
        <span class="s1">expected = pd.Series(expected</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;boolean[pyarrow]&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = other | a</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s6"># ensure we haven't mutated anything inplace</span>
        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">a</span><span class="s2">, </span><span class="s1">pd.Series([</span><span class="s2">True, False, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;boolean[pyarrow]&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_kleene_and(self):</span>
        <span class="s1">a = pd.Series([</span><span class="s2">True</span><span class="s1">] * </span><span class="s4">3 </span><span class="s1">+ [</span><span class="s2">False</span><span class="s1">] * </span><span class="s4">3 </span><span class="s1">+ [</span><span class="s2">None</span><span class="s1">] * </span><span class="s4">3</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;boolean[pyarrow]&quot;</span><span class="s1">)</span>
        <span class="s1">b = pd.Series([</span><span class="s2">True, False, None</span><span class="s1">] * </span><span class="s4">3</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;boolean[pyarrow]&quot;</span><span class="s1">)</span>
        <span class="s1">result = a &amp; b</span>
        <span class="s1">expected = pd.Series(</span>
            <span class="s1">[</span><span class="s2">True, False, None, False, False, False, None, False, None</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">dtype=</span><span class="s3">&quot;boolean[pyarrow]&quot;</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = b &amp; a</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s6"># ensure we haven't mutated anything inplace</span>
        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">a</span><span class="s2">,</span>
            <span class="s1">pd.Series([</span><span class="s2">True</span><span class="s1">] * </span><span class="s4">3 </span><span class="s1">+ [</span><span class="s2">False</span><span class="s1">] * </span><span class="s4">3 </span><span class="s1">+ [</span><span class="s2">None</span><span class="s1">] * </span><span class="s4">3</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;boolean[pyarrow]&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">b</span><span class="s2">, </span><span class="s1">pd.Series([</span><span class="s2">True, False, None</span><span class="s1">] * </span><span class="s4">3</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;boolean[pyarrow]&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;other, expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s2">None, </span><span class="s1">[</span><span class="s2">None, False, None</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">(pd.NA</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, False, None</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s2">True, </span><span class="s1">[</span><span class="s2">True, False, None</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s2">False, </span><span class="s1">[</span><span class="s2">False, False, False</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">(np.bool_(</span><span class="s2">True</span><span class="s1">)</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False, None</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">(np.bool_(</span><span class="s2">False</span><span class="s1">)</span><span class="s2">, </span><span class="s1">[</span><span class="s2">False, False, False</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_kleene_and_scalar(self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s1">a = pd.Series([</span><span class="s2">True, False, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;boolean[pyarrow]&quot;</span><span class="s1">)</span>
        <span class="s1">result = a &amp; other</span>
        <span class="s1">expected = pd.Series(expected</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;boolean[pyarrow]&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = other &amp; a</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s6"># ensure we haven't mutated anything inplace</span>
        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">a</span><span class="s2">, </span><span class="s1">pd.Series([</span><span class="s2">True, False, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;boolean[pyarrow]&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_kleene_xor(self):</span>
        <span class="s1">a = pd.Series([</span><span class="s2">True</span><span class="s1">] * </span><span class="s4">3 </span><span class="s1">+ [</span><span class="s2">False</span><span class="s1">] * </span><span class="s4">3 </span><span class="s1">+ [</span><span class="s2">None</span><span class="s1">] * </span><span class="s4">3</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;boolean[pyarrow]&quot;</span><span class="s1">)</span>
        <span class="s1">b = pd.Series([</span><span class="s2">True, False, None</span><span class="s1">] * </span><span class="s4">3</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;boolean[pyarrow]&quot;</span><span class="s1">)</span>
        <span class="s1">result = a ^ b</span>
        <span class="s1">expected = pd.Series(</span>
            <span class="s1">[</span><span class="s2">False, True, None, True, False, None, None, None, None</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">dtype=</span><span class="s3">&quot;boolean[pyarrow]&quot;</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = b ^ a</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s6"># ensure we haven't mutated anything inplace</span>
        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">a</span><span class="s2">,</span>
            <span class="s1">pd.Series([</span><span class="s2">True</span><span class="s1">] * </span><span class="s4">3 </span><span class="s1">+ [</span><span class="s2">False</span><span class="s1">] * </span><span class="s4">3 </span><span class="s1">+ [</span><span class="s2">None</span><span class="s1">] * </span><span class="s4">3</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;boolean[pyarrow]&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">b</span><span class="s2">, </span><span class="s1">pd.Series([</span><span class="s2">True, False, None</span><span class="s1">] * </span><span class="s4">3</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;boolean[pyarrow]&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;other, expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s2">None, </span><span class="s1">[</span><span class="s2">None, None, None</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">(pd.NA</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, None, None</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s2">True, </span><span class="s1">[</span><span class="s2">False, True, None</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">(np.bool_(</span><span class="s2">True</span><span class="s1">)</span><span class="s2">, </span><span class="s1">[</span><span class="s2">False, True, None</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">(np.bool_(</span><span class="s2">False</span><span class="s1">)</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False, None</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_kleene_xor_scalar(self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s1">a = pd.Series([</span><span class="s2">True, False, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;boolean[pyarrow]&quot;</span><span class="s1">)</span>
        <span class="s1">result = a ^ other</span>
        <span class="s1">expected = pd.Series(expected</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;boolean[pyarrow]&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = other ^ a</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s6"># ensure we haven't mutated anything inplace</span>
        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">a</span><span class="s2">, </span><span class="s1">pd.Series([</span><span class="s2">True, False, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;boolean[pyarrow]&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;op, exp&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s3">&quot;__and__&quot;</span><span class="s2">, True</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;__or__&quot;</span><span class="s2">, True</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;__xor__&quot;</span><span class="s2">, False</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_logical_masked_numpy(self</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">exp):</span>
        <span class="s6"># GH 52625</span>
        <span class="s1">data = [</span><span class="s2">True, False, None</span><span class="s1">]</span>
        <span class="s1">ser_masked = pd.Series(data</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;boolean&quot;</span><span class="s1">)</span>
        <span class="s1">ser_pa = pd.Series(data</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;boolean[pyarrow]&quot;</span><span class="s1">)</span>
        <span class="s1">result = getattr(ser_pa</span><span class="s2">, </span><span class="s1">op)(ser_masked)</span>
        <span class="s1">expected = pd.Series([exp</span><span class="s2">, False, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.bool_()))</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;pa_type&quot;</span><span class="s2">, </span><span class="s1">tm.ALL_INT_PYARROW_DTYPES)</span>
<span class="s2">def </span><span class="s1">test_bitwise(pa_type):</span>
    <span class="s6"># GH 54495</span>
    <span class="s1">dtype = ArrowDtype(pa_type)</span>
    <span class="s1">left = pd.Series([</span><span class="s4">1</span><span class="s2">, None, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">right = pd.Series([</span><span class="s2">None, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

    <span class="s1">result = left | right</span>
    <span class="s1">expected = pd.Series([</span><span class="s2">None, None, </span><span class="s4">3 </span><span class="s1">| </span><span class="s4">5</span><span class="s2">, </span><span class="s4">4 </span><span class="s1">| </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">result = left &amp; right</span>
    <span class="s1">expected = pd.Series([</span><span class="s2">None, None, </span><span class="s4">3 </span><span class="s1">&amp; </span><span class="s4">5</span><span class="s2">, </span><span class="s4">4 </span><span class="s1">&amp; </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">result = left ^ right</span>
    <span class="s1">expected = pd.Series([</span><span class="s2">None, None, </span><span class="s4">3 </span><span class="s1">^ </span><span class="s4">5</span><span class="s2">, </span><span class="s4">4 </span><span class="s1">^ </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">result = ~left</span>
    <span class="s1">expected = ~(left.fillna(</span><span class="s4">0</span><span class="s1">).to_numpy())</span>
    <span class="s1">expected = pd.Series(expected</span><span class="s2">, </span><span class="s1">dtype=dtype).mask(left.isnull())</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_arrowdtype_construct_from_string_type_with_unsupported_parameters():</span>
    <span class="s2">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Passing pyarrow type&quot;</span><span class="s1">):</span>
        <span class="s1">ArrowDtype.construct_from_string(</span><span class="s3">&quot;not_a_real_dype[s, tz=UTC][pyarrow]&quot;</span><span class="s1">)</span>

    <span class="s2">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Passing pyarrow type&quot;</span><span class="s1">):</span>
        <span class="s1">ArrowDtype.construct_from_string(</span><span class="s3">&quot;decimal(7, 2)[pyarrow]&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_arrowdtype_construct_from_string_supports_dt64tz():</span>
    <span class="s6"># as of GH#50689, timestamptz is supported</span>
    <span class="s1">dtype = ArrowDtype.construct_from_string(</span><span class="s3">&quot;timestamp[s, tz=UTC][pyarrow]&quot;</span><span class="s1">)</span>
    <span class="s1">expected = ArrowDtype(pa.timestamp(</span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s3">&quot;UTC&quot;</span><span class="s1">))</span>
    <span class="s2">assert </span><span class="s1">dtype == expected</span>


<span class="s2">def </span><span class="s1">test_arrowdtype_construct_from_string_type_only_one_pyarrow():</span>
    <span class="s6"># GH#51225</span>
    <span class="s1">invalid = </span><span class="s3">&quot;int64[pyarrow]foobar[pyarrow]&quot;</span>
    <span class="s1">msg = (</span>
        <span class="s3">r&quot;Passing pyarrow type specific parameters \(\[pyarrow\]\) in the &quot;</span>
        <span class="s3">r&quot;string is not supported\.&quot;</span>
    <span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">pd.Series(range(</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=invalid)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;interpolation&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;linear&quot;</span><span class="s2">, </span><span class="s3">&quot;lower&quot;</span><span class="s2">, </span><span class="s3">&quot;higher&quot;</span><span class="s2">, </span><span class="s3">&quot;nearest&quot;</span><span class="s2">, </span><span class="s3">&quot;midpoint&quot;</span><span class="s1">]</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;quantile&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">]])</span>
<span class="s2">def </span><span class="s1">test_quantile(data</span><span class="s2">, </span><span class="s1">interpolation</span><span class="s2">, </span><span class="s1">quantile</span><span class="s2">, </span><span class="s1">request):</span>
    <span class="s1">pa_dtype = data.dtype.pyarrow_dtype</span>

    <span class="s1">data = data.take([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">ser = pd.Series(data)</span>

    <span class="s2">if </span><span class="s1">(</span>
        <span class="s1">pa.types.is_string(pa_dtype)</span>
        <span class="s2">or </span><span class="s1">pa.types.is_binary(pa_dtype)</span>
        <span class="s2">or </span><span class="s1">pa.types.is_boolean(pa_dtype)</span>
    <span class="s1">):</span>
        <span class="s6"># For string, bytes, and bool, we don't *expect* to have quantile work</span>
        <span class="s6"># Note this matches the non-pyarrow behavior</span>
        <span class="s2">if </span><span class="s1">pa_version_under7p0:</span>
            <span class="s1">msg = </span><span class="s3">r&quot;Function quantile has no kernel matching input types \(.*\)&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s3">r&quot;Function 'quantile' has no kernel matching input types \(.*\)&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(pa.ArrowNotImplementedError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">ser.quantile(q=quantile</span><span class="s2">, </span><span class="s1">interpolation=interpolation)</span>
        <span class="s2">return</span>

    <span class="s2">if </span><span class="s1">(</span>
        <span class="s1">pa.types.is_integer(pa_dtype)</span>
        <span class="s2">or </span><span class="s1">pa.types.is_floating(pa_dtype)</span>
        <span class="s2">or </span><span class="s1">(pa.types.is_decimal(pa_dtype) </span><span class="s2">and not </span><span class="s1">pa_version_under7p0)</span>
    <span class="s1">):</span>
        <span class="s2">pass</span>
    <span class="s2">elif </span><span class="s1">pa.types.is_temporal(data._pa_array.type):</span>
        <span class="s2">pass</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">request.node.add_marker(</span>
            <span class="s1">pytest.mark.xfail(</span>
                <span class="s1">raises=pa.ArrowNotImplementedError</span><span class="s2">,</span>
                <span class="s1">reason=</span><span class="s3">f&quot;quantile not supported by pyarrow for </span><span class="s2">{</span><span class="s1">pa_dtype</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
    <span class="s1">data = data.take([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">ser = pd.Series(data)</span>
    <span class="s1">result = ser.quantile(q=quantile</span><span class="s2">, </span><span class="s1">interpolation=interpolation)</span>

    <span class="s2">if </span><span class="s1">pa.types.is_timestamp(pa_dtype) </span><span class="s2">and </span><span class="s1">interpolation </span><span class="s2">not in </span><span class="s1">[</span><span class="s3">&quot;lower&quot;</span><span class="s2">, </span><span class="s3">&quot;higher&quot;</span><span class="s1">]:</span>
        <span class="s6"># rounding error will make the check below fail</span>
        <span class="s6">#  (e.g. '2020-01-01 01:01:01.000001' vs '2020-01-01 01:01:01.000001024'),</span>
        <span class="s6">#  so we'll check for now that we match the numpy analogue</span>
        <span class="s2">if </span><span class="s1">pa_dtype.tz:</span>
            <span class="s1">pd_dtype = </span><span class="s3">f&quot;M8[</span><span class="s2">{</span><span class="s1">pa_dtype.unit</span><span class="s2">}</span><span class="s3">, </span><span class="s2">{</span><span class="s1">pa_dtype.tz</span><span class="s2">}</span><span class="s3">]&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">pd_dtype = </span><span class="s3">f&quot;M8[</span><span class="s2">{</span><span class="s1">pa_dtype.unit</span><span class="s2">}</span><span class="s3">]&quot;</span>
        <span class="s1">ser_np = ser.astype(pd_dtype)</span>

        <span class="s1">expected = ser_np.quantile(q=quantile</span><span class="s2">, </span><span class="s1">interpolation=interpolation)</span>
        <span class="s2">if </span><span class="s1">quantile == </span><span class="s4">0.5</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">pa_dtype.unit == </span><span class="s3">&quot;us&quot;</span><span class="s1">:</span>
                <span class="s1">expected = expected.to_pydatetime(warn=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s2">assert </span><span class="s1">result == expected</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">pa_dtype.unit == </span><span class="s3">&quot;us&quot;</span><span class="s1">:</span>
                <span class="s1">expected = expected.dt.floor(</span><span class="s3">&quot;us&quot;</span><span class="s1">)</span>
            <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected.astype(data.dtype))</span>
        <span class="s2">return</span>

    <span class="s2">if </span><span class="s1">quantile == </span><span class="s4">0.5</span><span class="s1">:</span>
        <span class="s2">assert </span><span class="s1">result == data[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s6"># Just check the values</span>
        <span class="s1">expected = pd.Series(data.take([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span><span class="s2">, </span><span class="s1">index=[</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">])</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">pa.types.is_integer(pa_dtype)</span>
            <span class="s2">or </span><span class="s1">pa.types.is_floating(pa_dtype)</span>
            <span class="s2">or </span><span class="s1">pa.types.is_decimal(pa_dtype)</span>
        <span class="s1">):</span>
            <span class="s1">expected = expected.astype(</span><span class="s3">&quot;float64[pyarrow]&quot;</span><span class="s1">)</span>
            <span class="s1">result = result.astype(</span><span class="s3">&quot;float64[pyarrow]&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;take_idx, exp_idx&quot;</span><span class="s2">,</span>
    <span class="s1">[[[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">[[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s1">]]]</span><span class="s2">,</span>
    <span class="s1">ids=[</span><span class="s3">&quot;multi_mode&quot;</span><span class="s2">, </span><span class="s3">&quot;single_mode&quot;</span><span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_mode_dropna_true(data_for_grouping</span><span class="s2">, </span><span class="s1">take_idx</span><span class="s2">, </span><span class="s1">exp_idx):</span>
    <span class="s1">data = data_for_grouping.take(take_idx)</span>
    <span class="s1">ser = pd.Series(data)</span>
    <span class="s1">result = ser.mode(dropna=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">expected = pd.Series(data_for_grouping.take(exp_idx))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_mode_dropna_false_mode_na(data):</span>
    <span class="s6"># GH 50982</span>
    <span class="s1">more_nans = pd.Series([</span><span class="s2">None, None, </span><span class="s1">data[</span><span class="s4">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=data.dtype)</span>
    <span class="s1">result = more_nans.mode(dropna=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">expected = pd.Series([</span><span class="s2">None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=data.dtype)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">expected = pd.Series([data[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=data.dtype)</span>
    <span class="s1">result = expected.mode(dropna=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;arrow_dtype, expected_type&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">[pa.binary()</span><span class="s2">, </span><span class="s1">bytes]</span><span class="s2">,</span>
        <span class="s1">[pa.binary(</span><span class="s4">16</span><span class="s1">)</span><span class="s2">, </span><span class="s1">bytes]</span><span class="s2">,</span>
        <span class="s1">[pa.large_binary()</span><span class="s2">, </span><span class="s1">bytes]</span><span class="s2">,</span>
        <span class="s1">[pa.large_string()</span><span class="s2">, </span><span class="s1">str]</span><span class="s2">,</span>
        <span class="s1">[pa.list_(pa.int64())</span><span class="s2">, </span><span class="s1">list]</span><span class="s2">,</span>
        <span class="s1">[pa.large_list(pa.int64())</span><span class="s2">, </span><span class="s1">list]</span><span class="s2">,</span>
        <span class="s1">[pa.map_(pa.string()</span><span class="s2">, </span><span class="s1">pa.int64())</span><span class="s2">, </span><span class="s1">list]</span><span class="s2">,</span>
        <span class="s1">[pa.struct([(</span><span class="s3">&quot;f1&quot;</span><span class="s2">, </span><span class="s1">pa.int8())</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;f2&quot;</span><span class="s2">, </span><span class="s1">pa.string())])</span><span class="s2">, </span><span class="s1">dict]</span><span class="s2">,</span>
        <span class="s1">[pa.dictionary(pa.int64()</span><span class="s2">, </span><span class="s1">pa.int64())</span><span class="s2">, </span><span class="s1">CategoricalDtypeType]</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_arrow_dtype_type(arrow_dtype</span><span class="s2">, </span><span class="s1">expected_type):</span>
    <span class="s6"># GH 51845</span>
    <span class="s6"># TODO: Redundant with test_getitem_scalar once arrow_dtype exists in data fixture</span>
    <span class="s2">assert </span><span class="s1">ArrowDtype(arrow_dtype).type == expected_type</span>


<span class="s2">def </span><span class="s1">test_is_bool_dtype():</span>
    <span class="s6"># GH 22667</span>
    <span class="s1">data = ArrowExtensionArray(pa.array([</span><span class="s2">True, False, True</span><span class="s1">]))</span>
    <span class="s2">assert </span><span class="s1">is_bool_dtype(data)</span>
    <span class="s2">assert </span><span class="s1">pd.core.common.is_bool_indexer(data)</span>
    <span class="s1">s = pd.Series(range(len(data)))</span>
    <span class="s1">result = s[data]</span>
    <span class="s1">expected = s[np.asarray(data)]</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_is_numeric_dtype(data):</span>
    <span class="s6"># GH 50563</span>
    <span class="s1">pa_type = data.dtype.pyarrow_dtype</span>
    <span class="s2">if </span><span class="s1">(</span>
        <span class="s1">pa.types.is_floating(pa_type)</span>
        <span class="s2">or </span><span class="s1">pa.types.is_integer(pa_type)</span>
        <span class="s2">or </span><span class="s1">pa.types.is_decimal(pa_type)</span>
    <span class="s1">):</span>
        <span class="s2">assert </span><span class="s1">is_numeric_dtype(data)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">assert not </span><span class="s1">is_numeric_dtype(data)</span>


<span class="s2">def </span><span class="s1">test_is_integer_dtype(data):</span>
    <span class="s6"># GH 50667</span>
    <span class="s1">pa_type = data.dtype.pyarrow_dtype</span>
    <span class="s2">if </span><span class="s1">pa.types.is_integer(pa_type):</span>
        <span class="s2">assert </span><span class="s1">is_integer_dtype(data)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">assert not </span><span class="s1">is_integer_dtype(data)</span>


<span class="s2">def </span><span class="s1">test_is_signed_integer_dtype(data):</span>
    <span class="s1">pa_type = data.dtype.pyarrow_dtype</span>
    <span class="s2">if </span><span class="s1">pa.types.is_signed_integer(pa_type):</span>
        <span class="s2">assert </span><span class="s1">is_signed_integer_dtype(data)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">assert not </span><span class="s1">is_signed_integer_dtype(data)</span>


<span class="s2">def </span><span class="s1">test_is_unsigned_integer_dtype(data):</span>
    <span class="s1">pa_type = data.dtype.pyarrow_dtype</span>
    <span class="s2">if </span><span class="s1">pa.types.is_unsigned_integer(pa_type):</span>
        <span class="s2">assert </span><span class="s1">is_unsigned_integer_dtype(data)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">assert not </span><span class="s1">is_unsigned_integer_dtype(data)</span>


<span class="s2">def </span><span class="s1">test_is_float_dtype(data):</span>
    <span class="s1">pa_type = data.dtype.pyarrow_dtype</span>
    <span class="s2">if </span><span class="s1">pa.types.is_floating(pa_type):</span>
        <span class="s2">assert </span><span class="s1">is_float_dtype(data)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">assert not </span><span class="s1">is_float_dtype(data)</span>


<span class="s2">def </span><span class="s1">test_pickle_roundtrip(data):</span>
    <span class="s6"># GH 42600</span>
    <span class="s1">expected = pd.Series(data)</span>
    <span class="s1">expected_sliced = expected.head(</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">full_pickled = pickle.dumps(expected)</span>
    <span class="s1">sliced_pickled = pickle.dumps(expected_sliced)</span>

    <span class="s2">assert </span><span class="s1">len(full_pickled) &gt; len(sliced_pickled)</span>

    <span class="s1">result = pickle.loads(full_pickled)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">result_sliced = pickle.loads(sliced_pickled)</span>
    <span class="s1">tm.assert_series_equal(result_sliced</span><span class="s2">, </span><span class="s1">expected_sliced)</span>


<span class="s2">def </span><span class="s1">test_astype_from_non_pyarrow(data):</span>
    <span class="s6"># GH49795</span>
    <span class="s1">pd_array = data._pa_array.to_pandas().array</span>
    <span class="s1">result = pd_array.astype(data.dtype)</span>
    <span class="s2">assert not </span><span class="s1">isinstance(pd_array.dtype</span><span class="s2">, </span><span class="s1">ArrowDtype)</span>
    <span class="s2">assert </span><span class="s1">isinstance(result.dtype</span><span class="s2">, </span><span class="s1">ArrowDtype)</span>
    <span class="s1">tm.assert_extension_array_equal(result</span><span class="s2">, </span><span class="s1">data)</span>


<span class="s2">def </span><span class="s1">test_astype_float_from_non_pyarrow_str():</span>
    <span class="s6"># GH50430</span>
    <span class="s1">ser = pd.Series([</span><span class="s3">&quot;1.0&quot;</span><span class="s1">])</span>
    <span class="s1">result = ser.astype(</span><span class="s3">&quot;float64[pyarrow]&quot;</span><span class="s1">)</span>
    <span class="s1">expected = pd.Series([</span><span class="s4">1.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;float64[pyarrow]&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_to_numpy_with_defaults(data):</span>
    <span class="s6"># GH49973</span>
    <span class="s1">result = data.to_numpy()</span>

    <span class="s1">pa_type = data._pa_array.type</span>
    <span class="s2">if </span><span class="s1">(</span>
        <span class="s1">pa.types.is_duration(pa_type)</span>
        <span class="s2">or </span><span class="s1">pa.types.is_timestamp(pa_type)</span>
        <span class="s2">or </span><span class="s1">pa.types.is_date(pa_type)</span>
    <span class="s1">):</span>
        <span class="s1">expected = np.array(list(data))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">expected = np.array(data._pa_array)</span>

    <span class="s2">if </span><span class="s1">data._hasna:</span>
        <span class="s1">expected = expected.astype(object)</span>
        <span class="s1">expected[pd.isna(data)] = pd.NA</span>

    <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_to_numpy_int_with_na():</span>
    <span class="s6"># GH51227: ensure to_numpy does not convert int to float</span>
    <span class="s1">data = [</span><span class="s4">1</span><span class="s2">, None</span><span class="s1">]</span>
    <span class="s1">arr = pd.array(data</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;int64[pyarrow]&quot;</span><span class="s1">)</span>
    <span class="s1">result = arr.to_numpy()</span>
    <span class="s1">expected = np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s1">pd.NA]</span><span class="s2">, </span><span class="s1">dtype=object)</span>
    <span class="s2">assert </span><span class="s1">isinstance(result[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">int)</span>
    <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;na_val, exp&quot;</span><span class="s2">, </span><span class="s1">[(lib.no_default</span><span class="s2">, </span><span class="s1">np.nan)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)])</span>
<span class="s2">def </span><span class="s1">test_to_numpy_null_array(na_val</span><span class="s2">, </span><span class="s1">exp):</span>
    <span class="s6"># GH#52443</span>
    <span class="s1">arr = pd.array([pd.NA</span><span class="s2">, </span><span class="s1">pd.NA]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;null[pyarrow]&quot;</span><span class="s1">)</span>
    <span class="s1">result = arr.to_numpy(dtype=</span><span class="s3">&quot;float64&quot;</span><span class="s2">, </span><span class="s1">na_value=na_val)</span>
    <span class="s1">expected = np.array([exp] * </span><span class="s4">2</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;float64&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_to_numpy_null_array_no_dtype():</span>
    <span class="s6"># GH#52443</span>
    <span class="s1">arr = pd.array([pd.NA</span><span class="s2">, </span><span class="s1">pd.NA]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;null[pyarrow]&quot;</span><span class="s1">)</span>
    <span class="s1">result = arr.to_numpy(dtype=</span><span class="s2">None</span><span class="s1">)</span>
    <span class="s1">expected = np.array([pd.NA] * </span><span class="s4">2</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;object&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_setitem_null_slice(data):</span>
    <span class="s6"># GH50248</span>
    <span class="s1">orig = data.copy()</span>

    <span class="s1">result = orig.copy()</span>
    <span class="s1">result[:] = data[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">expected = ArrowExtensionArray._from_sequence(</span>
        <span class="s1">[data[</span><span class="s4">0</span><span class="s1">]] * len(data)</span><span class="s2">,</span>
        <span class="s1">dtype=data._pa_array.type</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_extension_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">result = orig.copy()</span>
    <span class="s1">result[:] = data[::-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">expected = data[::-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">tm.assert_extension_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">result = orig.copy()</span>
    <span class="s1">result[:] = data.tolist()</span>
    <span class="s1">expected = data</span>
    <span class="s1">tm.assert_extension_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_setitem_invalid_dtype(data):</span>
    <span class="s6"># GH50248</span>
    <span class="s1">pa_type = data._pa_array.type</span>
    <span class="s2">if </span><span class="s1">pa.types.is_string(pa_type) </span><span class="s2">or </span><span class="s1">pa.types.is_binary(pa_type):</span>
        <span class="s1">fill_value = </span><span class="s4">123</span>
        <span class="s1">err = TypeError</span>
        <span class="s1">msg = </span><span class="s3">&quot;Invalid value '123' for dtype&quot;</span>
    <span class="s2">elif </span><span class="s1">(</span>
        <span class="s1">pa.types.is_integer(pa_type)</span>
        <span class="s2">or </span><span class="s1">pa.types.is_floating(pa_type)</span>
        <span class="s2">or </span><span class="s1">pa.types.is_boolean(pa_type)</span>
    <span class="s1">):</span>
        <span class="s1">fill_value = </span><span class="s3">&quot;foo&quot;</span>
        <span class="s1">err = pa.ArrowInvalid</span>
        <span class="s1">msg = </span><span class="s3">&quot;Could not convert&quot;</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">fill_value = </span><span class="s3">&quot;foo&quot;</span>
        <span class="s1">err = TypeError</span>
        <span class="s1">msg = </span><span class="s3">&quot;Invalid value 'foo' for dtype&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(err</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">data[:] = fill_value</span>


<span class="s1">@pytest.mark.skipif(pa_version_under8p0</span><span class="s2">, </span><span class="s1">reason=</span><span class="s3">&quot;returns object with 7.0&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_from_arrow_respecting_given_dtype():</span>
    <span class="s1">date_array = pa.array(</span>
        <span class="s1">[pd.Timestamp(</span><span class="s3">&quot;2019-12-31&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">pd.Timestamp(</span><span class="s3">&quot;2019-12-31&quot;</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">type=pa.date32()</span>
    <span class="s1">)</span>
    <span class="s1">result = date_array.to_pandas(</span>
        <span class="s1">types_mapper={pa.date32(): ArrowDtype(pa.date64())}.get</span>
    <span class="s1">)</span>
    <span class="s1">expected = pd.Series(</span>
        <span class="s1">[pd.Timestamp(</span><span class="s3">&quot;2019-12-31&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">pd.Timestamp(</span><span class="s3">&quot;2019-12-31&quot;</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s1">dtype=ArrowDtype(pa.date64())</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.skipif(pa_version_under8p0</span><span class="s2">, </span><span class="s1">reason=</span><span class="s3">&quot;doesn't raise with 7&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_from_arrow_respecting_given_dtype_unsafe():</span>
    <span class="s1">array = pa.array([</span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">2.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">type=pa.float64())</span>
    <span class="s2">with </span><span class="s1">pytest.raises(pa.ArrowInvalid</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Float value 1.5 was truncated&quot;</span><span class="s1">):</span>
        <span class="s1">array.to_pandas(types_mapper={pa.float64(): ArrowDtype(pa.int64())}.get)</span>


<span class="s2">def </span><span class="s1">test_round():</span>
    <span class="s1">dtype = </span><span class="s3">&quot;float64[pyarrow]&quot;</span>

    <span class="s1">ser = pd.Series([</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">1.23</span><span class="s2">, </span><span class="s4">2.56</span><span class="s2">, </span><span class="s1">pd.NA]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">result = ser.round(</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">expected = pd.Series([</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">1.2</span><span class="s2">, </span><span class="s4">2.6</span><span class="s2">, </span><span class="s1">pd.NA]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">ser = pd.Series([</span><span class="s4">123.4</span><span class="s2">, </span><span class="s1">pd.NA</span><span class="s2">, </span><span class="s4">56.78</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">result = ser.round(-</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">expected = pd.Series([</span><span class="s4">120.0</span><span class="s2">, </span><span class="s1">pd.NA</span><span class="s2">, </span><span class="s4">60.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_searchsorted_with_na_raises(data_for_sorting</span><span class="s2">, </span><span class="s1">as_series):</span>
    <span class="s6"># GH50447</span>
    <span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">a = data_for_sorting</span>
    <span class="s1">arr = data_for_sorting.take([</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])  </span><span class="s6"># to get [a, b, c]</span>
    <span class="s1">arr[-</span><span class="s4">1</span><span class="s1">] = pd.NA</span>

    <span class="s2">if </span><span class="s1">as_series:</span>
        <span class="s1">arr = pd.Series(arr)</span>

    <span class="s1">msg = (</span>
        <span class="s3">&quot;searchsorted requires array to be sorted, &quot;</span>
        <span class="s3">&quot;which is impossible with NAs present.&quot;</span>
    <span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">arr.searchsorted(b)</span>


<span class="s2">def </span><span class="s1">test_sort_values_dictionary():</span>
    <span class="s1">df = pd.DataFrame(</span>
        <span class="s1">{</span>
            <span class="s3">&quot;a&quot;</span><span class="s1">: pd.Series(</span>
                <span class="s1">[</span><span class="s3">&quot;x&quot;</span><span class="s2">, </span><span class="s3">&quot;y&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.dictionary(pa.int32()</span><span class="s2">, </span><span class="s1">pa.string()))</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;b&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">expected = df.copy()</span>
    <span class="s1">result = df.sort_values(by=[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;pat&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;abc&quot;</span><span class="s2">, </span><span class="s3">&quot;a[a-z]{2}&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_str_count(pat):</span>
    <span class="s1">ser = pd.Series([</span><span class="s3">&quot;abc&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">result = ser.str.count(pat)</span>
    <span class="s1">expected = pd.Series([</span><span class="s4">1</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.int32()))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_str_count_flags_unsupported():</span>
    <span class="s1">ser = pd.Series([</span><span class="s3">&quot;abc&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s2">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;count not&quot;</span><span class="s1">):</span>
        <span class="s1">ser.str.count(</span><span class="s3">&quot;abc&quot;</span><span class="s2">, </span><span class="s1">flags=</span><span class="s4">1</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;side, str_func&quot;</span><span class="s2">, </span><span class="s1">[[</span><span class="s3">&quot;left&quot;</span><span class="s2">, </span><span class="s3">&quot;rjust&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;right&quot;</span><span class="s2">, </span><span class="s3">&quot;ljust&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;both&quot;</span><span class="s2">, </span><span class="s3">&quot;center&quot;</span><span class="s1">]]</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_str_pad(side</span><span class="s2">, </span><span class="s1">str_func):</span>
    <span class="s1">ser = pd.Series([</span><span class="s3">&quot;a&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">result = ser.str.pad(width=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">side=side</span><span class="s2">, </span><span class="s1">fillchar=</span><span class="s3">&quot;x&quot;</span><span class="s1">)</span>
    <span class="s1">expected = pd.Series(</span>
        <span class="s1">[getattr(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s1">str_func)(</span><span class="s4">3</span><span class="s2">, </span><span class="s3">&quot;x&quot;</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string())</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_str_pad_invalid_side():</span>
    <span class="s1">ser = pd.Series([</span><span class="s3">&quot;a&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Invalid side: foo&quot;</span><span class="s1">):</span>
        <span class="s1">ser.str.pad(</span><span class="s4">3</span><span class="s2">, </span><span class="s3">&quot;foo&quot;</span><span class="s2">, </span><span class="s3">&quot;x&quot;</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;pat, case, na, regex, exp&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">[</span><span class="s3">&quot;ab&quot;</span><span class="s2">, False, None, False, </span><span class="s1">[</span><span class="s2">True, None</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;Ab&quot;</span><span class="s2">, True, None, False, </span><span class="s1">[</span><span class="s2">False, None</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;ab&quot;</span><span class="s2">, False, True, False, </span><span class="s1">[</span><span class="s2">True, True</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;a[a-z]{1}&quot;</span><span class="s2">, False, None, True, </span><span class="s1">[</span><span class="s2">True, None</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;A[a-z]{1}&quot;</span><span class="s2">, True, None, True, </span><span class="s1">[</span><span class="s2">False, None</span><span class="s1">]]</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_str_contains(pat</span><span class="s2">, </span><span class="s1">case</span><span class="s2">, </span><span class="s1">na</span><span class="s2">, </span><span class="s1">regex</span><span class="s2">, </span><span class="s1">exp):</span>
    <span class="s1">ser = pd.Series([</span><span class="s3">&quot;abc&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">result = ser.str.contains(pat</span><span class="s2">, </span><span class="s1">case=case</span><span class="s2">, </span><span class="s1">na=na</span><span class="s2">, </span><span class="s1">regex=regex)</span>
    <span class="s1">expected = pd.Series(exp</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.bool_()))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_str_contains_flags_unsupported():</span>
    <span class="s1">ser = pd.Series([</span><span class="s3">&quot;abc&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s2">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;contains not&quot;</span><span class="s1">):</span>
        <span class="s1">ser.str.contains(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s1">flags=</span><span class="s4">1</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;side, pat, na, exp&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">[</span><span class="s3">&quot;startswith&quot;</span><span class="s2">, </span><span class="s3">&quot;ab&quot;</span><span class="s2">, None, </span><span class="s1">[</span><span class="s2">True, None</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;startswith&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, False, </span><span class="s1">[</span><span class="s2">False, False</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;endswith&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, True, </span><span class="s1">[</span><span class="s2">False, True</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;endswith&quot;</span><span class="s2">, </span><span class="s3">&quot;bc&quot;</span><span class="s2">, None, </span><span class="s1">[</span><span class="s2">True, None</span><span class="s1">]]</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_str_start_ends_with(side</span><span class="s2">, </span><span class="s1">pat</span><span class="s2">, </span><span class="s1">na</span><span class="s2">, </span><span class="s1">exp):</span>
    <span class="s1">ser = pd.Series([</span><span class="s3">&quot;abc&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">result = getattr(ser.str</span><span class="s2">, </span><span class="s1">side)(pat</span><span class="s2">, </span><span class="s1">na=na)</span>
    <span class="s1">expected = pd.Series(exp</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.bool_()))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;arg_name, arg&quot;</span><span class="s2">,</span>
    <span class="s1">[[</span><span class="s3">&quot;pat&quot;</span><span class="s2">, </span><span class="s1">re.compile(</span><span class="s3">&quot;b&quot;</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;repl&quot;</span><span class="s2">, </span><span class="s1">str]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;case&quot;</span><span class="s2">, False</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;flags&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_str_replace_unsupported(arg_name</span><span class="s2">, </span><span class="s1">arg):</span>
    <span class="s1">ser = pd.Series([</span><span class="s3">&quot;abc&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">kwargs = {</span><span class="s3">&quot;pat&quot;</span><span class="s1">: </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;repl&quot;</span><span class="s1">: </span><span class="s3">&quot;x&quot;</span><span class="s2">, </span><span class="s3">&quot;regex&quot;</span><span class="s1">: </span><span class="s2">True</span><span class="s1">}</span>
    <span class="s1">kwargs[arg_name] = arg</span>
    <span class="s2">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;replace is not supported&quot;</span><span class="s1">):</span>
        <span class="s1">ser.str.replace(**kwargs)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;pat, repl, n, regex, exp&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;x&quot;</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, False, </span><span class="s1">[</span><span class="s3">&quot;xbxc&quot;</span><span class="s2">, None</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;x&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, False, </span><span class="s1">[</span><span class="s3">&quot;xbac&quot;</span><span class="s2">, None</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;[a-b]&quot;</span><span class="s2">, </span><span class="s3">&quot;x&quot;</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, True, </span><span class="s1">[</span><span class="s3">&quot;xxxc&quot;</span><span class="s2">, None</span><span class="s1">]]</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_str_replace(pat</span><span class="s2">, </span><span class="s1">repl</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">regex</span><span class="s2">, </span><span class="s1">exp):</span>
    <span class="s1">ser = pd.Series([</span><span class="s3">&quot;abac&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">result = ser.str.replace(pat</span><span class="s2">, </span><span class="s1">repl</span><span class="s2">, </span><span class="s1">n=n</span><span class="s2">, </span><span class="s1">regex=regex)</span>
    <span class="s1">expected = pd.Series(exp</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_str_repeat_unsupported():</span>
    <span class="s1">ser = pd.Series([</span><span class="s3">&quot;abc&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s2">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;repeat is not&quot;</span><span class="s1">):</span>
        <span class="s1">ser.str.repeat([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])</span>


<span class="s1">@pytest.mark.xfail(</span>
    <span class="s1">pa_version_under7p0</span><span class="s2">,</span>
    <span class="s1">reason=</span><span class="s3">&quot;Unsupported for pyarrow &lt; 7&quot;</span><span class="s2">,</span>
    <span class="s1">raises=NotImplementedError</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_str_repeat():</span>
    <span class="s1">ser = pd.Series([</span><span class="s3">&quot;abc&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">result = ser.str.repeat(</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">expected = pd.Series([</span><span class="s3">&quot;abcabc&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;pat, case, na, exp&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">[</span><span class="s3">&quot;ab&quot;</span><span class="s2">, False, None, </span><span class="s1">[</span><span class="s2">True, None</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;Ab&quot;</span><span class="s2">, True, None, </span><span class="s1">[</span><span class="s2">False, None</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;bc&quot;</span><span class="s2">, True, None, </span><span class="s1">[</span><span class="s2">False, None</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;ab&quot;</span><span class="s2">, False, True, </span><span class="s1">[</span><span class="s2">True, True</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;a[a-z]{1}&quot;</span><span class="s2">, False, None, </span><span class="s1">[</span><span class="s2">True, None</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;A[a-z]{1}&quot;</span><span class="s2">, True, None, </span><span class="s1">[</span><span class="s2">False, None</span><span class="s1">]]</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_str_match(pat</span><span class="s2">, </span><span class="s1">case</span><span class="s2">, </span><span class="s1">na</span><span class="s2">, </span><span class="s1">exp):</span>
    <span class="s1">ser = pd.Series([</span><span class="s3">&quot;abc&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">result = ser.str.match(pat</span><span class="s2">, </span><span class="s1">case=case</span><span class="s2">, </span><span class="s1">na=na)</span>
    <span class="s1">expected = pd.Series(exp</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.bool_()))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;pat, case, na, exp&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">[</span><span class="s3">&quot;abc&quot;</span><span class="s2">, False, None, </span><span class="s1">[</span><span class="s2">True, None</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;Abc&quot;</span><span class="s2">, True, None, </span><span class="s1">[</span><span class="s2">False, None</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;bc&quot;</span><span class="s2">, True, None, </span><span class="s1">[</span><span class="s2">False, None</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;ab&quot;</span><span class="s2">, False, True, </span><span class="s1">[</span><span class="s2">True, True</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;a[a-z]{2}&quot;</span><span class="s2">, False, None, </span><span class="s1">[</span><span class="s2">True, None</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;A[a-z]{1}&quot;</span><span class="s2">, True, None, </span><span class="s1">[</span><span class="s2">False, None</span><span class="s1">]]</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_str_fullmatch(pat</span><span class="s2">, </span><span class="s1">case</span><span class="s2">, </span><span class="s1">na</span><span class="s2">, </span><span class="s1">exp):</span>
    <span class="s1">ser = pd.Series([</span><span class="s3">&quot;abc&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">result = ser.str.match(pat</span><span class="s2">, </span><span class="s1">case=case</span><span class="s2">, </span><span class="s1">na=na)</span>
    <span class="s1">expected = pd.Series(exp</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.bool_()))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;sub, start, end, exp, exp_typ&quot;</span><span class="s2">,</span>
    <span class="s1">[[</span><span class="s3">&quot;ab&quot;</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, None, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pa.int32()]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;bc&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pa.int64()]]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_str_find(sub</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">exp</span><span class="s2">, </span><span class="s1">exp_typ):</span>
    <span class="s1">ser = pd.Series([</span><span class="s3">&quot;abc&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">result = ser.str.find(sub</span><span class="s2">, </span><span class="s1">start=start</span><span class="s2">, </span><span class="s1">end=end)</span>
    <span class="s1">expected = pd.Series(exp</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(exp_typ))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_str_find_notimplemented():</span>
    <span class="s1">ser = pd.Series([</span><span class="s3">&quot;abc&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s2">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;find not implemented&quot;</span><span class="s1">):</span>
        <span class="s1">ser.str.find(</span><span class="s3">&quot;ab&quot;</span><span class="s2">, </span><span class="s1">start=</span><span class="s4">1</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;i, exp&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;e&quot;</span><span class="s2">, None</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">[-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s3">&quot;e&quot;</span><span class="s2">, None</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;c&quot;</span><span class="s2">, None, None</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">[-</span><span class="s4">3</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, None, None</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s4">4</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, None, None</span><span class="s1">]]</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_str_get(i</span><span class="s2">, </span><span class="s1">exp):</span>
    <span class="s1">ser = pd.Series([</span><span class="s3">&quot;abc&quot;</span><span class="s2">, </span><span class="s3">&quot;de&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">result = ser.str.get(i)</span>
    <span class="s1">expected = pd.Series(exp</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.xfail(</span>
    <span class="s1">reason=</span><span class="s3">&quot;TODO: StringMethods._validate should support Arrow list types&quot;</span><span class="s2">,</span>
    <span class="s1">raises=AttributeError</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_str_join():</span>
    <span class="s1">ser = pd.Series(ArrowExtensionArray(pa.array([list(</span><span class="s3">&quot;abc&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">list(</span><span class="s3">&quot;123&quot;</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">])))</span>
    <span class="s1">result = ser.str.join(</span><span class="s3">&quot;=&quot;</span><span class="s1">)</span>
    <span class="s1">expected = pd.Series([</span><span class="s3">&quot;a=b=c&quot;</span><span class="s2">, </span><span class="s3">&quot;1=2=3&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_str_join_string_type():</span>
    <span class="s1">ser = pd.Series(ArrowExtensionArray(pa.array([</span><span class="s3">&quot;abc&quot;</span><span class="s2">, </span><span class="s3">&quot;123&quot;</span><span class="s2">, None</span><span class="s1">])))</span>
    <span class="s1">result = ser.str.join(</span><span class="s3">&quot;=&quot;</span><span class="s1">)</span>
    <span class="s1">expected = pd.Series([</span><span class="s3">&quot;a=b=c&quot;</span><span class="s2">, </span><span class="s3">&quot;1=2=3&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;start, stop, step, exp&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">[</span><span class="s2">None, </span><span class="s4">2</span><span class="s2">, None, </span><span class="s1">[</span><span class="s3">&quot;ab&quot;</span><span class="s2">, None</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s2">None, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;ab&quot;</span><span class="s2">, None</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;bc&quot;</span><span class="s2">, None</span><span class="s1">]]</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_str_slice(start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">step</span><span class="s2">, </span><span class="s1">exp):</span>
    <span class="s1">ser = pd.Series([</span><span class="s3">&quot;abcd&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">result = ser.str.slice(start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">step)</span>
    <span class="s1">expected = pd.Series(exp</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;start, stop, repl, exp&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s3">&quot;x&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;axcd&quot;</span><span class="s2">, None</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s2">None, </span><span class="s4">2</span><span class="s2">, </span><span class="s3">&quot;x&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;xcd&quot;</span><span class="s2">, None</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s2">None, </span><span class="s4">2</span><span class="s2">, None, </span><span class="s1">[</span><span class="s3">&quot;cd&quot;</span><span class="s2">, None</span><span class="s1">]]</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_str_slice_replace(start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">repl</span><span class="s2">, </span><span class="s1">exp):</span>
    <span class="s1">ser = pd.Series([</span><span class="s3">&quot;abcd&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">result = ser.str.slice_replace(start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">repl)</span>
    <span class="s1">expected = pd.Series(exp</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;value, method, exp&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">[</span><span class="s3">&quot;a1c&quot;</span><span class="s2">, </span><span class="s3">&quot;isalnum&quot;</span><span class="s2">, True</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;!|,&quot;</span><span class="s2">, </span><span class="s3">&quot;isalnum&quot;</span><span class="s2">, False</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;aaa&quot;</span><span class="s2">, </span><span class="s3">&quot;isalpha&quot;</span><span class="s2">, True</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;!!!&quot;</span><span class="s2">, </span><span class="s3">&quot;isalpha&quot;</span><span class="s2">, False</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;٠&quot;</span><span class="s2">, </span><span class="s3">&quot;isdecimal&quot;</span><span class="s2">, True</span><span class="s1">]</span><span class="s2">,  </span><span class="s6"># noqa: RUF001</span>
        <span class="s1">[</span><span class="s3">&quot;~!&quot;</span><span class="s2">, </span><span class="s3">&quot;isdecimal&quot;</span><span class="s2">, False</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;2&quot;</span><span class="s2">, </span><span class="s3">&quot;isdigit&quot;</span><span class="s2">, True</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;~&quot;</span><span class="s2">, </span><span class="s3">&quot;isdigit&quot;</span><span class="s2">, False</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;aaa&quot;</span><span class="s2">, </span><span class="s3">&quot;islower&quot;</span><span class="s2">, True</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;aaA&quot;</span><span class="s2">, </span><span class="s3">&quot;islower&quot;</span><span class="s2">, False</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;123&quot;</span><span class="s2">, </span><span class="s3">&quot;isnumeric&quot;</span><span class="s2">, True</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;11I&quot;</span><span class="s2">, </span><span class="s3">&quot;isnumeric&quot;</span><span class="s2">, False</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot; &quot;</span><span class="s2">, </span><span class="s3">&quot;isspace&quot;</span><span class="s2">, True</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s3">&quot;isspace&quot;</span><span class="s2">, False</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;The That&quot;</span><span class="s2">, </span><span class="s3">&quot;istitle&quot;</span><span class="s2">, True</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;the That&quot;</span><span class="s2">, </span><span class="s3">&quot;istitle&quot;</span><span class="s2">, False</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;AAA&quot;</span><span class="s2">, </span><span class="s3">&quot;isupper&quot;</span><span class="s2">, True</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;AAc&quot;</span><span class="s2">, </span><span class="s3">&quot;isupper&quot;</span><span class="s2">, False</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_str_is_functions(value</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">exp):</span>
    <span class="s1">ser = pd.Series([value</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">result = getattr(ser.str</span><span class="s2">, </span><span class="s1">method)()</span>
    <span class="s1">expected = pd.Series([exp</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.bool_()))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;method, exp&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">[</span><span class="s3">&quot;capitalize&quot;</span><span class="s2">, </span><span class="s3">&quot;Abc def&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;title&quot;</span><span class="s2">, </span><span class="s3">&quot;Abc Def&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;swapcase&quot;</span><span class="s2">, </span><span class="s3">&quot;AbC Def&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;lower&quot;</span><span class="s2">, </span><span class="s3">&quot;abc def&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;upper&quot;</span><span class="s2">, </span><span class="s3">&quot;ABC DEF&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;casefold&quot;</span><span class="s2">, </span><span class="s3">&quot;abc def&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_str_transform_functions(method</span><span class="s2">, </span><span class="s1">exp):</span>
    <span class="s1">ser = pd.Series([</span><span class="s3">&quot;aBc dEF&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">result = getattr(ser.str</span><span class="s2">, </span><span class="s1">method)()</span>
    <span class="s1">expected = pd.Series([exp</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_str_len():</span>
    <span class="s1">ser = pd.Series([</span><span class="s3">&quot;abcd&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">result = ser.str.len()</span>
    <span class="s1">expected = pd.Series([</span><span class="s4">4</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.int32()))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;method, to_strip, val&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">[</span><span class="s3">&quot;strip&quot;</span><span class="s2">, None, </span><span class="s3">&quot; abc &quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;strip&quot;</span><span class="s2">, </span><span class="s3">&quot;x&quot;</span><span class="s2">, </span><span class="s3">&quot;xabcx&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;lstrip&quot;</span><span class="s2">, None, </span><span class="s3">&quot; abc&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;lstrip&quot;</span><span class="s2">, </span><span class="s3">&quot;x&quot;</span><span class="s2">, </span><span class="s3">&quot;xabc&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;rstrip&quot;</span><span class="s2">, None, </span><span class="s3">&quot;abc &quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;rstrip&quot;</span><span class="s2">, </span><span class="s3">&quot;x&quot;</span><span class="s2">, </span><span class="s3">&quot;abcx&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_str_strip(method</span><span class="s2">, </span><span class="s1">to_strip</span><span class="s2">, </span><span class="s1">val):</span>
    <span class="s1">ser = pd.Series([val</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">result = getattr(ser.str</span><span class="s2">, </span><span class="s1">method)(to_strip=to_strip)</span>
    <span class="s1">expected = pd.Series([</span><span class="s3">&quot;abc&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;val&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;abc123&quot;</span><span class="s2">, </span><span class="s3">&quot;abc&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_str_removesuffix(val):</span>
    <span class="s1">ser = pd.Series([val</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">result = ser.str.removesuffix(</span><span class="s3">&quot;123&quot;</span><span class="s1">)</span>
    <span class="s1">expected = pd.Series([</span><span class="s3">&quot;abc&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;val&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;123abc&quot;</span><span class="s2">, </span><span class="s3">&quot;abc&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_str_removeprefix(val):</span>
    <span class="s1">ser = pd.Series([val</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">result = ser.str.removeprefix(</span><span class="s3">&quot;123&quot;</span><span class="s1">)</span>
    <span class="s1">expected = pd.Series([</span><span class="s3">&quot;abc&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;errors&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s3">&quot;strict&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;encoding, exp&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">[</span><span class="s3">&quot;utf8&quot;</span><span class="s2">, </span><span class="s5">b&quot;abc&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;utf32&quot;</span><span class="s2">, </span><span class="s5">b&quot;</span><span class="s2">\xff\xfe\x00\x00</span><span class="s5">a</span><span class="s2">\x00\x00\x00</span><span class="s5">b</span><span class="s2">\x00\x00\x00</span><span class="s5">c</span><span class="s2">\x00\x00\x00</span><span class="s5">&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_str_encode(errors</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">exp):</span>
    <span class="s1">ser = pd.Series([</span><span class="s3">&quot;abc&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">result = ser.str.encode(encoding</span><span class="s2">, </span><span class="s1">errors)</span>
    <span class="s1">expected = pd.Series([exp</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.binary()))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;flags&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_str_findall(flags):</span>
    <span class="s1">ser = pd.Series([</span><span class="s3">&quot;abc&quot;</span><span class="s2">, </span><span class="s3">&quot;efg&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">result = ser.str.findall(</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s1">flags=flags)</span>
    <span class="s1">expected = pd.Series([[</span><span class="s3">&quot;b&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.list_(pa.string())))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;method&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;index&quot;</span><span class="s2">, </span><span class="s3">&quot;rindex&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;start, end&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">[</span><span class="s4">0</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_str_r_index(method</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end):</span>
    <span class="s1">ser = pd.Series([</span><span class="s3">&quot;abcba&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">result = getattr(ser.str</span><span class="s2">, </span><span class="s1">method)(</span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end)</span>
    <span class="s1">expected = pd.Series([</span><span class="s4">2</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.int64()))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;substring not found&quot;</span><span class="s1">):</span>
        <span class="s1">getattr(ser.str</span><span class="s2">, </span><span class="s1">method)(</span><span class="s3">&quot;foo&quot;</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;form&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;NFC&quot;</span><span class="s2">, </span><span class="s3">&quot;NFKC&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_str_normalize(form):</span>
    <span class="s1">ser = pd.Series([</span><span class="s3">&quot;abc&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">result = ser.str.normalize(form)</span>
    <span class="s1">expected = ser.copy()</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;start, end&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">[</span><span class="s4">0</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_str_rfind(start</span><span class="s2">, </span><span class="s1">end):</span>
    <span class="s1">ser = pd.Series([</span><span class="s3">&quot;abcba&quot;</span><span class="s2">, </span><span class="s3">&quot;foo&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">result = ser.str.rfind(</span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end)</span>
    <span class="s1">expected = pd.Series([</span><span class="s4">2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.int64()))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_str_translate():</span>
    <span class="s1">ser = pd.Series([</span><span class="s3">&quot;abcba&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">result = ser.str.translate({</span><span class="s4">97</span><span class="s1">: </span><span class="s3">&quot;b&quot;</span><span class="s1">})</span>
    <span class="s1">expected = pd.Series([</span><span class="s3">&quot;bbcbb&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_str_wrap():</span>
    <span class="s1">ser = pd.Series([</span><span class="s3">&quot;abcba&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">result = ser.str.wrap(</span><span class="s4">3</span><span class="s1">)</span>
    <span class="s1">expected = pd.Series([</span><span class="s3">&quot;abc</span><span class="s2">\n</span><span class="s3">ba&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_get_dummies():</span>
    <span class="s1">ser = pd.Series([</span><span class="s3">&quot;a|b&quot;</span><span class="s2">, None, </span><span class="s3">&quot;a|c&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">result = ser.str.get_dummies()</span>
    <span class="s1">expected = pd.DataFrame(</span>
        <span class="s1">[[</span><span class="s2">True, True, False</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s2">False, False, False</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False, True</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">dtype=ArrowDtype(pa.bool_())</span><span class="s2">,</span>
        <span class="s1">columns=[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_str_partition():</span>
    <span class="s1">ser = pd.Series([</span><span class="s3">&quot;abcba&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">result = ser.str.partition(</span><span class="s3">&quot;b&quot;</span><span class="s1">)</span>
    <span class="s1">expected = pd.DataFrame(</span>
        <span class="s1">[[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;cba&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, None, None</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string())</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">result = ser.str.partition(</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s1">expand=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">expected = pd.Series(ArrowExtensionArray(pa.array([[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;cba&quot;</span><span class="s1">]</span><span class="s2">, None</span><span class="s1">])))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">result = ser.str.rpartition(</span><span class="s3">&quot;b&quot;</span><span class="s1">)</span>
    <span class="s1">expected = pd.DataFrame(</span>
        <span class="s1">[[</span><span class="s3">&quot;abc&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;a&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, None, None</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string())</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">result = ser.str.rpartition(</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s1">expand=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">expected = pd.Series(ArrowExtensionArray(pa.array([[</span><span class="s3">&quot;abc&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;a&quot;</span><span class="s1">]</span><span class="s2">, None</span><span class="s1">])))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_str_split():</span>
    <span class="s6"># GH 52401</span>
    <span class="s1">ser = pd.Series([</span><span class="s3">&quot;a1cbcb&quot;</span><span class="s2">, </span><span class="s3">&quot;a2cbcb&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">result = ser.str.split(</span><span class="s3">&quot;c&quot;</span><span class="s1">)</span>
    <span class="s1">expected = pd.Series(</span>
        <span class="s1">ArrowExtensionArray(pa.array([[</span><span class="s3">&quot;a1&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;a2&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">]</span><span class="s2">, None</span><span class="s1">]))</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">result = ser.str.split(</span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s1">n=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">expected = pd.Series(</span>
        <span class="s1">ArrowExtensionArray(pa.array([[</span><span class="s3">&quot;a1&quot;</span><span class="s2">, </span><span class="s3">&quot;bcb&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;a2&quot;</span><span class="s2">, </span><span class="s3">&quot;bcb&quot;</span><span class="s1">]</span><span class="s2">, None</span><span class="s1">]))</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">result = ser.str.split(</span><span class="s3">&quot;[1-2]&quot;</span><span class="s2">, </span><span class="s1">regex=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">expected = pd.Series(</span>
        <span class="s1">ArrowExtensionArray(pa.array([[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;cbcb&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;cbcb&quot;</span><span class="s1">]</span><span class="s2">, None</span><span class="s1">]))</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">result = ser.str.split(</span><span class="s3">&quot;[1-2]&quot;</span><span class="s2">, </span><span class="s1">regex=</span><span class="s2">True, </span><span class="s1">expand=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">expected = pd.DataFrame(</span>
        <span class="s1">{</span>
            <span class="s4">0</span><span class="s1">: ArrowExtensionArray(pa.array([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;a&quot;</span><span class="s2">, None</span><span class="s1">]))</span><span class="s2">,</span>
            <span class="s4">1</span><span class="s1">: ArrowExtensionArray(pa.array([</span><span class="s3">&quot;cbcb&quot;</span><span class="s2">, </span><span class="s3">&quot;cbcb&quot;</span><span class="s2">, None</span><span class="s1">]))</span><span class="s2">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">result = ser.str.split(</span><span class="s3">&quot;1&quot;</span><span class="s2">, </span><span class="s1">expand=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">expected = pd.DataFrame(</span>
        <span class="s1">{</span>
            <span class="s4">0</span><span class="s1">: ArrowExtensionArray(pa.array([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;a2cbcb&quot;</span><span class="s2">, None</span><span class="s1">]))</span><span class="s2">,</span>
            <span class="s4">1</span><span class="s1">: ArrowExtensionArray(pa.array([</span><span class="s3">&quot;cbcb&quot;</span><span class="s2">, None, None</span><span class="s1">]))</span><span class="s2">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_str_rsplit():</span>
    <span class="s6"># GH 52401</span>
    <span class="s1">ser = pd.Series([</span><span class="s3">&quot;a1cbcb&quot;</span><span class="s2">, </span><span class="s3">&quot;a2cbcb&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">result = ser.str.rsplit(</span><span class="s3">&quot;c&quot;</span><span class="s1">)</span>
    <span class="s1">expected = pd.Series(</span>
        <span class="s1">ArrowExtensionArray(pa.array([[</span><span class="s3">&quot;a1&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;a2&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">]</span><span class="s2">, None</span><span class="s1">]))</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">result = ser.str.rsplit(</span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s1">n=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">expected = pd.Series(</span>
        <span class="s1">ArrowExtensionArray(pa.array([[</span><span class="s3">&quot;a1cb&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;a2cb&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">]</span><span class="s2">, None</span><span class="s1">]))</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">result = ser.str.rsplit(</span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s1">n=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">expand=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">expected = pd.DataFrame(</span>
        <span class="s1">{</span>
            <span class="s4">0</span><span class="s1">: ArrowExtensionArray(pa.array([</span><span class="s3">&quot;a1cb&quot;</span><span class="s2">, </span><span class="s3">&quot;a2cb&quot;</span><span class="s2">, None</span><span class="s1">]))</span><span class="s2">,</span>
            <span class="s4">1</span><span class="s1">: ArrowExtensionArray(pa.array([</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, None</span><span class="s1">]))</span><span class="s2">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">result = ser.str.rsplit(</span><span class="s3">&quot;1&quot;</span><span class="s2">, </span><span class="s1">expand=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">expected = pd.DataFrame(</span>
        <span class="s1">{</span>
            <span class="s4">0</span><span class="s1">: ArrowExtensionArray(pa.array([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;a2cbcb&quot;</span><span class="s2">, None</span><span class="s1">]))</span><span class="s2">,</span>
            <span class="s4">1</span><span class="s1">: ArrowExtensionArray(pa.array([</span><span class="s3">&quot;cbcb&quot;</span><span class="s2">, None, None</span><span class="s1">]))</span><span class="s2">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_str_unsupported_extract():</span>
    <span class="s1">ser = pd.Series([</span><span class="s3">&quot;abc&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s2">with </span><span class="s1">pytest.raises(</span>
        <span class="s1">NotImplementedError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;str.extract not supported with pd.ArrowDtype&quot;</span>
    <span class="s1">):</span>
        <span class="s1">ser.str.extract(</span><span class="s3">r&quot;[ab](\d)&quot;</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;unit&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;ns&quot;</span><span class="s2">, </span><span class="s3">&quot;us&quot;</span><span class="s2">, </span><span class="s3">&quot;ms&quot;</span><span class="s2">, </span><span class="s3">&quot;s&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_duration_from_strings_with_nat(unit):</span>
    <span class="s6"># GH51175</span>
    <span class="s1">strings = [</span><span class="s3">&quot;1000&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]</span>
    <span class="s1">pa_type = pa.duration(unit)</span>
    <span class="s1">result = ArrowExtensionArray._from_sequence_of_strings(strings</span><span class="s2">, </span><span class="s1">dtype=pa_type)</span>
    <span class="s1">expected = ArrowExtensionArray(pa.array([</span><span class="s4">1000</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">type=pa_type))</span>
    <span class="s1">tm.assert_extension_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_unsupported_dt(data):</span>
    <span class="s1">pa_dtype = data.dtype.pyarrow_dtype</span>
    <span class="s2">if not </span><span class="s1">pa.types.is_temporal(pa_dtype):</span>
        <span class="s2">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">AttributeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Can only use .dt accessor with datetimelike values&quot;</span>
        <span class="s1">):</span>
            <span class="s1">pd.Series(data).dt</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;prop, expected&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">[</span><span class="s3">&quot;year&quot;</span><span class="s2">, </span><span class="s4">2023</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;day&quot;</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;day_of_week&quot;</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;dayofweek&quot;</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;weekday&quot;</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;day_of_year&quot;</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;dayofyear&quot;</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;hour&quot;</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;minute&quot;</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">pytest.param(</span>
            <span class="s3">&quot;is_leap_year&quot;</span><span class="s2">,</span>
            <span class="s2">False,</span>
            <span class="s1">marks=pytest.mark.xfail(</span>
                <span class="s1">pa_version_under8p0</span><span class="s2">,</span>
                <span class="s1">raises=NotImplementedError</span><span class="s2">,</span>
                <span class="s1">reason=</span><span class="s3">&quot;is_leap_year not implemented for pyarrow &lt; 8.0&quot;</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;microsecond&quot;</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;month&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;nanosecond&quot;</span><span class="s2">, </span><span class="s4">6</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;quarter&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;second&quot;</span><span class="s2">, </span><span class="s4">7</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;date&quot;</span><span class="s2">, </span><span class="s1">date(</span><span class="s4">2023</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;time&quot;</span><span class="s2">, </span><span class="s1">time(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)]</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_dt_properties(prop</span><span class="s2">, </span><span class="s1">expected):</span>
    <span class="s1">ser = pd.Series(</span>
        <span class="s1">[</span>
            <span class="s1">pd.Timestamp(</span>
                <span class="s1">year=</span><span class="s4">2023</span><span class="s2">,</span>
                <span class="s1">month=</span><span class="s4">1</span><span class="s2">,</span>
                <span class="s1">day=</span><span class="s4">2</span><span class="s2">,</span>
                <span class="s1">hour=</span><span class="s4">3</span><span class="s2">,</span>
                <span class="s1">minute=</span><span class="s4">4</span><span class="s2">,</span>
                <span class="s1">second=</span><span class="s4">7</span><span class="s2">,</span>
                <span class="s1">microsecond=</span><span class="s4">5</span><span class="s2">,</span>
                <span class="s1">nanosecond=</span><span class="s4">6</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s2">None,</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">dtype=ArrowDtype(pa.timestamp(</span><span class="s3">&quot;ns&quot;</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">result = getattr(ser.dt</span><span class="s2">, </span><span class="s1">prop)</span>
    <span class="s1">exp_type = </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">isinstance(expected</span><span class="s2">, </span><span class="s1">date):</span>
        <span class="s1">exp_type = pa.date32()</span>
    <span class="s2">elif </span><span class="s1">isinstance(expected</span><span class="s2">, </span><span class="s1">time):</span>
        <span class="s1">exp_type = pa.time64(</span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span>
    <span class="s1">expected = pd.Series(ArrowExtensionArray(pa.array([expected</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">type=exp_type)))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_dt_is_month_start_end():</span>
    <span class="s1">ser = pd.Series(</span>
        <span class="s1">[</span>
            <span class="s1">datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">12</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">hour=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">hour=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">31</span><span class="s2">, </span><span class="s1">hour=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s2">None,</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">dtype=ArrowDtype(pa.timestamp(</span><span class="s3">&quot;us&quot;</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">result = ser.dt.is_month_start</span>
    <span class="s1">expected = pd.Series([</span><span class="s2">False, True, False, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.bool_()))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">result = ser.dt.is_month_end</span>
    <span class="s1">expected = pd.Series([</span><span class="s2">False, False, True, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.bool_()))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_dt_is_year_start_end():</span>
    <span class="s1">ser = pd.Series(</span>
        <span class="s1">[</span>
            <span class="s1">datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">12</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">31</span><span class="s2">, </span><span class="s1">hour=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">hour=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">31</span><span class="s2">, </span><span class="s1">hour=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s2">None,</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">dtype=ArrowDtype(pa.timestamp(</span><span class="s3">&quot;us&quot;</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">result = ser.dt.is_year_start</span>
    <span class="s1">expected = pd.Series([</span><span class="s2">False, True, False, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.bool_()))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">result = ser.dt.is_year_end</span>
    <span class="s1">expected = pd.Series([</span><span class="s2">True, False, False, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.bool_()))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_dt_is_quarter_start_end():</span>
    <span class="s1">ser = pd.Series(</span>
        <span class="s1">[</span>
            <span class="s1">datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">11</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">30</span><span class="s2">, </span><span class="s1">hour=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">hour=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">31</span><span class="s2">, </span><span class="s1">hour=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s2">None,</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">dtype=ArrowDtype(pa.timestamp(</span><span class="s3">&quot;us&quot;</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">result = ser.dt.is_quarter_start</span>
    <span class="s1">expected = pd.Series([</span><span class="s2">False, True, False, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.bool_()))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">result = ser.dt.is_quarter_end</span>
    <span class="s1">expected = pd.Series([</span><span class="s2">False, False, True, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.bool_()))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;method&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;days_in_month&quot;</span><span class="s2">, </span><span class="s3">&quot;daysinmonth&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_dt_days_in_month(method):</span>
    <span class="s1">ser = pd.Series(</span>
        <span class="s1">[</span>
            <span class="s1">datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">30</span><span class="s2">, </span><span class="s1">hour=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">4</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">hour=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">hour=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s2">None,</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">dtype=ArrowDtype(pa.timestamp(</span><span class="s3">&quot;us&quot;</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">result = getattr(ser.dt</span><span class="s2">, </span><span class="s1">method)</span>
    <span class="s1">expected = pd.Series([</span><span class="s4">31</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s4">28</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.int64()))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_dt_normalize():</span>
    <span class="s1">ser = pd.Series(</span>
        <span class="s1">[</span>
            <span class="s1">datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">30</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">4</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">hour=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">hour=</span><span class="s4">23</span><span class="s2">, </span><span class="s1">minute=</span><span class="s4">59</span><span class="s2">, </span><span class="s1">second=</span><span class="s4">59</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s2">None,</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">dtype=ArrowDtype(pa.timestamp(</span><span class="s3">&quot;us&quot;</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">result = ser.dt.normalize()</span>
    <span class="s1">expected = pd.Series(</span>
        <span class="s1">[</span>
            <span class="s1">datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">30</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">4</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s2">None,</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">dtype=ArrowDtype(pa.timestamp(</span><span class="s3">&quot;us&quot;</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;unit&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;us&quot;</span><span class="s2">, </span><span class="s3">&quot;ns&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_dt_time_preserve_unit(unit):</span>
    <span class="s1">ser = pd.Series(</span>
        <span class="s1">[datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">hour=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">dtype=ArrowDtype(pa.timestamp(unit))</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">ser.dt.unit == unit</span>

    <span class="s1">result = ser.dt.time</span>
    <span class="s1">expected = pd.Series(</span>
        <span class="s1">ArrowExtensionArray(pa.array([time(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">type=pa.time64(unit)))</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;tz&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s3">&quot;UTC&quot;</span><span class="s2">, </span><span class="s3">&quot;US/Pacific&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_dt_tz(tz):</span>
    <span class="s1">ser = pd.Series(</span>
        <span class="s1">[datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">hour=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">dtype=ArrowDtype(pa.timestamp(</span><span class="s3">&quot;ns&quot;</span><span class="s2">, </span><span class="s1">tz=tz))</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">result = ser.dt.tz</span>
    <span class="s2">assert </span><span class="s1">result == timezones.maybe_get_tz(tz)</span>


<span class="s2">def </span><span class="s1">test_dt_isocalendar():</span>
    <span class="s1">ser = pd.Series(</span>
        <span class="s1">[datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">hour=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">dtype=ArrowDtype(pa.timestamp(</span><span class="s3">&quot;ns&quot;</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">result = ser.dt.isocalendar()</span>
    <span class="s1">expected = pd.DataFrame(</span>
        <span class="s1">[[</span><span class="s4">2023</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">columns=[</span><span class="s3">&quot;year&quot;</span><span class="s2">, </span><span class="s3">&quot;week&quot;</span><span class="s2">, </span><span class="s3">&quot;day&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">dtype=</span><span class="s3">&quot;int64[pyarrow]&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;method, exp&quot;</span><span class="s2">, </span><span class="s1">[[</span><span class="s3">&quot;day_name&quot;</span><span class="s2">, </span><span class="s3">&quot;Sunday&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;month_name&quot;</span><span class="s2">, </span><span class="s3">&quot;January&quot;</span><span class="s1">]]</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_dt_day_month_name(method</span><span class="s2">, </span><span class="s1">exp</span><span class="s2">, </span><span class="s1">request):</span>
    <span class="s6"># GH 52388</span>
    <span class="s1">_require_timezone_database(request)</span>

    <span class="s1">ser = pd.Series([datetime(</span><span class="s4">2023</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.timestamp(</span><span class="s3">&quot;ms&quot;</span><span class="s1">)))</span>
    <span class="s1">result = getattr(ser.dt</span><span class="s2">, </span><span class="s1">method)()</span>
    <span class="s1">expected = pd.Series([exp</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string()))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_dt_strftime(request):</span>
    <span class="s1">_require_timezone_database(request)</span>

    <span class="s1">ser = pd.Series(</span>
        <span class="s1">[datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">hour=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">dtype=ArrowDtype(pa.timestamp(</span><span class="s3">&quot;ns&quot;</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">result = ser.dt.strftime(</span><span class="s3">&quot;%Y-%m-%dT%H:%M:%S&quot;</span><span class="s1">)</span>
    <span class="s1">expected = pd.Series(</span>
        <span class="s1">[</span><span class="s3">&quot;2023-01-02T03:00:00.000000000&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.string())</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;method&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;ceil&quot;</span><span class="s2">, </span><span class="s3">&quot;floor&quot;</span><span class="s2">, </span><span class="s3">&quot;round&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_dt_roundlike_tz_options_not_supported(method):</span>
    <span class="s1">ser = pd.Series(</span>
        <span class="s1">[datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">hour=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">dtype=ArrowDtype(pa.timestamp(</span><span class="s3">&quot;ns&quot;</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;ambiguous is not supported.&quot;</span><span class="s1">):</span>
        <span class="s1">getattr(ser.dt</span><span class="s2">, </span><span class="s1">method)(</span><span class="s3">&quot;1H&quot;</span><span class="s2">, </span><span class="s1">ambiguous=</span><span class="s3">&quot;NaT&quot;</span><span class="s1">)</span>

    <span class="s2">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;nonexistent is not supported.&quot;</span><span class="s1">):</span>
        <span class="s1">getattr(ser.dt</span><span class="s2">, </span><span class="s1">method)(</span><span class="s3">&quot;1H&quot;</span><span class="s2">, </span><span class="s1">nonexistent=</span><span class="s3">&quot;NaT&quot;</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;method&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;ceil&quot;</span><span class="s2">, </span><span class="s3">&quot;floor&quot;</span><span class="s2">, </span><span class="s3">&quot;round&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_dt_roundlike_unsupported_freq(method):</span>
    <span class="s1">ser = pd.Series(</span>
        <span class="s1">[datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">hour=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">dtype=ArrowDtype(pa.timestamp(</span><span class="s3">&quot;ns&quot;</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;freq='1B' is not supported&quot;</span><span class="s1">):</span>
        <span class="s1">getattr(ser.dt</span><span class="s2">, </span><span class="s1">method)(</span><span class="s3">&quot;1B&quot;</span><span class="s1">)</span>

    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Must specify a valid frequency: None&quot;</span><span class="s1">):</span>
        <span class="s1">getattr(ser.dt</span><span class="s2">, </span><span class="s1">method)(</span><span class="s2">None</span><span class="s1">)</span>


<span class="s1">@pytest.mark.xfail(</span>
    <span class="s1">pa_version_under7p0</span><span class="s2">, </span><span class="s1">reason=</span><span class="s3">&quot;Methods not supported for pyarrow &lt; 7.0&quot;</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;freq&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s3">&quot;H&quot;</span><span class="s2">, </span><span class="s3">&quot;T&quot;</span><span class="s2">, </span><span class="s3">&quot;S&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;U&quot;</span><span class="s2">, </span><span class="s3">&quot;N&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;method&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;ceil&quot;</span><span class="s2">, </span><span class="s3">&quot;floor&quot;</span><span class="s2">, </span><span class="s3">&quot;round&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_dt_ceil_year_floor(freq</span><span class="s2">, </span><span class="s1">method):</span>
    <span class="s1">ser = pd.Series(</span>
        <span class="s1">[datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">pa_dtype = ArrowDtype(pa.timestamp(</span><span class="s3">&quot;ns&quot;</span><span class="s1">))</span>
    <span class="s1">expected = getattr(ser.dt</span><span class="s2">, </span><span class="s1">method)(</span><span class="s3">f&quot;1</span><span class="s2">{</span><span class="s1">freq</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">).astype(pa_dtype)</span>
    <span class="s1">result = getattr(ser.astype(pa_dtype).dt</span><span class="s2">, </span><span class="s1">method)(</span><span class="s3">f&quot;1</span><span class="s2">{</span><span class="s1">freq</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_dt_to_pydatetime():</span>
    <span class="s6"># GH 51859</span>
    <span class="s1">data = [datetime(</span><span class="s4">2022</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s4">2023</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)]</span>
    <span class="s1">ser = pd.Series(data</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.timestamp(</span><span class="s3">&quot;ns&quot;</span><span class="s1">)))</span>

    <span class="s1">msg = </span><span class="s3">&quot;The behavior of ArrowTemporalProperties.to_pydatetime is deprecated&quot;</span>
    <span class="s2">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">result = ser.dt.to_pydatetime()</span>
    <span class="s1">expected = np.array(data</span><span class="s2">, </span><span class="s1">dtype=object)</span>
    <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
    <span class="s2">assert </span><span class="s1">all(type(res) </span><span class="s2">is </span><span class="s1">datetime </span><span class="s2">for </span><span class="s1">res </span><span class="s2">in </span><span class="s1">result)</span>

    <span class="s1">msg = </span><span class="s3">&quot;The behavior of DatetimeProperties.to_pydatetime is deprecated&quot;</span>
    <span class="s2">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">expected = ser.astype(</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s1">).dt.to_pydatetime()</span>
    <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;date_type&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">32</span><span class="s2">, </span><span class="s4">64</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_dt_to_pydatetime_date_error(date_type):</span>
    <span class="s6"># GH 52812</span>
    <span class="s1">ser = pd.Series(</span>
        <span class="s1">[date(</span><span class="s4">2022</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s4">31</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s1">dtype=ArrowDtype(getattr(pa</span><span class="s2">, </span><span class="s3">f&quot;date</span><span class="s2">{</span><span class="s1">date_type</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)())</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">msg = </span><span class="s3">&quot;The behavior of ArrowTemporalProperties.to_pydatetime is deprecated&quot;</span>
    <span class="s2">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;to_pydatetime cannot be called with&quot;</span><span class="s1">):</span>
            <span class="s1">ser.dt.to_pydatetime()</span>


<span class="s2">def </span><span class="s1">test_dt_tz_localize_unsupported_tz_options():</span>
    <span class="s1">ser = pd.Series(</span>
        <span class="s1">[datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">hour=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">dtype=ArrowDtype(pa.timestamp(</span><span class="s3">&quot;ns&quot;</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;ambiguous='NaT' is not supported&quot;</span><span class="s1">):</span>
        <span class="s1">ser.dt.tz_localize(</span><span class="s3">&quot;UTC&quot;</span><span class="s2">, </span><span class="s1">ambiguous=</span><span class="s3">&quot;NaT&quot;</span><span class="s1">)</span>

    <span class="s2">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;nonexistent='NaT' is not supported&quot;</span><span class="s1">):</span>
        <span class="s1">ser.dt.tz_localize(</span><span class="s3">&quot;UTC&quot;</span><span class="s2">, </span><span class="s1">nonexistent=</span><span class="s3">&quot;NaT&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_dt_tz_localize_none():</span>
    <span class="s1">ser = pd.Series(</span>
        <span class="s1">[datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">hour=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">dtype=ArrowDtype(pa.timestamp(</span><span class="s3">&quot;ns&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Pacific&quot;</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">result = ser.dt.tz_localize(</span><span class="s2">None</span><span class="s1">)</span>
    <span class="s1">expected = pd.Series(</span>
        <span class="s1">[datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">hour=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">dtype=ArrowDtype(pa.timestamp(</span><span class="s3">&quot;ns&quot;</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;unit&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;us&quot;</span><span class="s2">, </span><span class="s3">&quot;ns&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_dt_tz_localize(unit</span><span class="s2">, </span><span class="s1">request):</span>
    <span class="s1">_require_timezone_database(request)</span>

    <span class="s1">ser = pd.Series(</span>
        <span class="s1">[datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">hour=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">dtype=ArrowDtype(pa.timestamp(unit))</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">result = ser.dt.tz_localize(</span><span class="s3">&quot;US/Pacific&quot;</span><span class="s1">)</span>
    <span class="s1">exp_data = pa.array(</span>
        <span class="s1">[datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">hour=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">type=pa.timestamp(unit)</span>
    <span class="s1">)</span>
    <span class="s1">exp_data = pa.compute.assume_timezone(exp_data</span><span class="s2">, </span><span class="s3">&quot;US/Pacific&quot;</span><span class="s1">)</span>
    <span class="s1">expected = pd.Series(ArrowExtensionArray(exp_data))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;nonexistent, exp_date&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">[</span><span class="s3">&quot;shift_forward&quot;</span><span class="s2">, </span><span class="s1">datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">12</span><span class="s2">, </span><span class="s1">hour=</span><span class="s4">3</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;shift_backward&quot;</span><span class="s2">, </span><span class="s1">pd.Timestamp(</span><span class="s3">&quot;2023-03-12 01:59:59.999999999&quot;</span><span class="s1">)]</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_dt_tz_localize_nonexistent(nonexistent</span><span class="s2">, </span><span class="s1">exp_date</span><span class="s2">, </span><span class="s1">request):</span>
    <span class="s1">_require_timezone_database(request)</span>

    <span class="s1">ser = pd.Series(</span>
        <span class="s1">[datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">12</span><span class="s2">, </span><span class="s1">hour=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">minute=</span><span class="s4">30</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">dtype=ArrowDtype(pa.timestamp(</span><span class="s3">&quot;ns&quot;</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">result = ser.dt.tz_localize(</span><span class="s3">&quot;US/Pacific&quot;</span><span class="s2">, </span><span class="s1">nonexistent=nonexistent)</span>
    <span class="s1">exp_data = pa.array([exp_date</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">type=pa.timestamp(</span><span class="s3">&quot;ns&quot;</span><span class="s1">))</span>
    <span class="s1">exp_data = pa.compute.assume_timezone(exp_data</span><span class="s2">, </span><span class="s3">&quot;US/Pacific&quot;</span><span class="s1">)</span>
    <span class="s1">expected = pd.Series(ArrowExtensionArray(exp_data))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_dt_tz_convert_not_tz_raises():</span>
    <span class="s1">ser = pd.Series(</span>
        <span class="s1">[datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">hour=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">dtype=ArrowDtype(pa.timestamp(</span><span class="s3">&quot;ns&quot;</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Cannot convert tz-naive timestamps&quot;</span><span class="s1">):</span>
        <span class="s1">ser.dt.tz_convert(</span><span class="s3">&quot;UTC&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_dt_tz_convert_none():</span>
    <span class="s1">ser = pd.Series(</span>
        <span class="s1">[datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">hour=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">dtype=ArrowDtype(pa.timestamp(</span><span class="s3">&quot;ns&quot;</span><span class="s2">, </span><span class="s3">&quot;US/Pacific&quot;</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">result = ser.dt.tz_convert(</span><span class="s2">None</span><span class="s1">)</span>
    <span class="s1">expected = pd.Series(</span>
        <span class="s1">[datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">hour=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">dtype=ArrowDtype(pa.timestamp(</span><span class="s3">&quot;ns&quot;</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;unit&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;us&quot;</span><span class="s2">, </span><span class="s3">&quot;ns&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_dt_tz_convert(unit):</span>
    <span class="s1">ser = pd.Series(</span>
        <span class="s1">[datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">hour=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">dtype=ArrowDtype(pa.timestamp(unit</span><span class="s2">, </span><span class="s3">&quot;US/Pacific&quot;</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">result = ser.dt.tz_convert(</span><span class="s3">&quot;US/Eastern&quot;</span><span class="s1">)</span>
    <span class="s1">expected = pd.Series(</span>
        <span class="s1">[datetime(year=</span><span class="s4">2023</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">hour=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">dtype=ArrowDtype(pa.timestamp(unit</span><span class="s2">, </span><span class="s3">&quot;US/Eastern&quot;</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;skipna&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_boolean_reduce_series_all_null(all_boolean_reductions</span><span class="s2">, </span><span class="s1">skipna):</span>
    <span class="s6"># GH51624</span>
    <span class="s1">ser = pd.Series([</span><span class="s2">None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;float64[pyarrow]&quot;</span><span class="s1">)</span>
    <span class="s1">result = getattr(ser</span><span class="s2">, </span><span class="s1">all_boolean_reductions)(skipna=skipna)</span>
    <span class="s2">if </span><span class="s1">skipna:</span>
        <span class="s1">expected = all_boolean_reductions == </span><span class="s3">&quot;all&quot;</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">expected = pd.NA</span>
    <span class="s2">assert </span><span class="s1">result </span><span class="s2">is </span><span class="s1">expected</span>


<span class="s2">def </span><span class="s1">test_from_sequence_of_strings_boolean():</span>
    <span class="s1">true_strings = [</span><span class="s3">&quot;true&quot;</span><span class="s2">, </span><span class="s3">&quot;TRUE&quot;</span><span class="s2">, </span><span class="s3">&quot;True&quot;</span><span class="s2">, </span><span class="s3">&quot;1&quot;</span><span class="s2">, </span><span class="s3">&quot;1.0&quot;</span><span class="s1">]</span>
    <span class="s1">false_strings = [</span><span class="s3">&quot;false&quot;</span><span class="s2">, </span><span class="s3">&quot;FALSE&quot;</span><span class="s2">, </span><span class="s3">&quot;False&quot;</span><span class="s2">, </span><span class="s3">&quot;0&quot;</span><span class="s2">, </span><span class="s3">&quot;0.0&quot;</span><span class="s1">]</span>
    <span class="s1">nulls = [</span><span class="s2">None</span><span class="s1">]</span>
    <span class="s1">strings = true_strings + false_strings + nulls</span>
    <span class="s1">bools = (</span>
        <span class="s1">[</span><span class="s2">True</span><span class="s1">] * len(true_strings) + [</span><span class="s2">False</span><span class="s1">] * len(false_strings) + [</span><span class="s2">None</span><span class="s1">] * len(nulls)</span>
    <span class="s1">)</span>

    <span class="s1">result = ArrowExtensionArray._from_sequence_of_strings(strings</span><span class="s2">, </span><span class="s1">dtype=pa.bool_())</span>
    <span class="s1">expected = pd.array(bools</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;boolean[pyarrow]&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_extension_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">strings = [</span><span class="s3">&quot;True&quot;</span><span class="s2">, </span><span class="s3">&quot;foo&quot;</span><span class="s1">]</span>
    <span class="s2">with </span><span class="s1">pytest.raises(pa.ArrowInvalid</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Failed to parse&quot;</span><span class="s1">):</span>
        <span class="s1">ArrowExtensionArray._from_sequence_of_strings(strings</span><span class="s2">, </span><span class="s1">dtype=pa.bool_())</span>


<span class="s2">def </span><span class="s1">test_concat_empty_arrow_backed_series(dtype):</span>
    <span class="s6"># GH#51734</span>
    <span class="s1">ser = pd.Series([]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">expected = ser.copy()</span>
    <span class="s1">result = pd.concat([ser[np.array([]</span><span class="s2">, </span><span class="s1">dtype=np.bool_)]])</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;string&quot;</span><span class="s2">, </span><span class="s3">&quot;string[pyarrow]&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_series_from_string_array(dtype):</span>
    <span class="s1">arr = pa.array(</span><span class="s3">&quot;the quick brown fox&quot;</span><span class="s1">.split())</span>
    <span class="s1">ser = pd.Series(arr</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">expected = pd.Series(ArrowExtensionArray(arr)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">tm.assert_series_equal(ser</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s6"># _data was renamed to _pa_data</span>
<span class="s2">class </span><span class="s1">OldArrowExtensionArray(ArrowExtensionArray):</span>
    <span class="s2">def </span><span class="s1">__getstate__(self):</span>
        <span class="s1">state = super().__getstate__()</span>
        <span class="s1">state[</span><span class="s3">&quot;_data&quot;</span><span class="s1">] = state.pop(</span><span class="s3">&quot;_pa_array&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">state</span>


<span class="s2">def </span><span class="s1">test_pickle_old_arrowextensionarray():</span>
    <span class="s1">data = pa.array([</span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">expected = OldArrowExtensionArray(data)</span>
    <span class="s1">result = pickle.loads(pickle.dumps(expected))</span>
    <span class="s1">tm.assert_extension_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
    <span class="s2">assert </span><span class="s1">result._pa_array == pa.chunked_array(data)</span>
    <span class="s2">assert not </span><span class="s1">hasattr(result</span><span class="s2">, </span><span class="s3">&quot;_data&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_setitem_boolean_replace_with_mask_segfault():</span>
    <span class="s6"># GH#52059</span>
    <span class="s1">N = </span><span class="s4">145_000</span>
    <span class="s1">arr = ArrowExtensionArray(pa.chunked_array([np.ones((N</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.bool_)]))</span>
    <span class="s1">expected = arr.copy()</span>
    <span class="s1">arr[np.zeros((N</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.bool_)] = </span><span class="s2">False</span>
    <span class="s2">assert </span><span class="s1">arr._pa_array == expected._pa_array</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;data, arrow_dtype&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">([</span><span class="s5">b&quot;a&quot;</span><span class="s2">, </span><span class="s5">b&quot;b&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pa.large_binary())</span><span class="s2">,</span>
        <span class="s1">([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pa.large_string())</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_conversion_large_dtypes_from_numpy_array(data</span><span class="s2">, </span><span class="s1">arrow_dtype):</span>
    <span class="s1">dtype = ArrowDtype(arrow_dtype)</span>
    <span class="s1">result = pd.array(np.array(data)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">expected = pd.array(data</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">tm.assert_extension_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_concat_null_array():</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s3">&quot;a&quot;</span><span class="s1">: [</span><span class="s2">None, None</span><span class="s1">]}</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.null()))</span>
    <span class="s1">df2 = pd.DataFrame({</span><span class="s3">&quot;a&quot;</span><span class="s1">: [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]}</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;int64[pyarrow]&quot;</span><span class="s1">)</span>

    <span class="s1">result = pd.concat([df</span><span class="s2">, </span><span class="s1">df2]</span><span class="s2">, </span><span class="s1">ignore_index=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">expected = pd.DataFrame({</span><span class="s3">&quot;a&quot;</span><span class="s1">: [</span><span class="s2">None, None, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]}</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;int64[pyarrow]&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;pa_type&quot;</span><span class="s2">, </span><span class="s1">tm.ALL_INT_PYARROW_DTYPES + tm.FLOAT_PYARROW_DTYPES)</span>
<span class="s2">def </span><span class="s1">test_describe_numeric_data(pa_type):</span>
    <span class="s6"># GH 52470</span>
    <span class="s1">data = pd.Series([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa_type))</span>
    <span class="s1">result = data.describe()</span>
    <span class="s1">expected = pd.Series(</span>
        <span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">2.5</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">dtype=ArrowDtype(pa.float64())</span><span class="s2">,</span>
        <span class="s1">index=[</span><span class="s3">&quot;count&quot;</span><span class="s2">, </span><span class="s3">&quot;mean&quot;</span><span class="s2">, </span><span class="s3">&quot;std&quot;</span><span class="s2">, </span><span class="s3">&quot;min&quot;</span><span class="s2">, </span><span class="s3">&quot;25%&quot;</span><span class="s2">, </span><span class="s3">&quot;50%&quot;</span><span class="s2">, </span><span class="s3">&quot;75%&quot;</span><span class="s2">, </span><span class="s3">&quot;max&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;pa_type&quot;</span><span class="s2">, </span><span class="s1">tm.TIMEDELTA_PYARROW_DTYPES)</span>
<span class="s2">def </span><span class="s1">test_describe_timedelta_data(pa_type):</span>
    <span class="s6"># GH53001</span>
    <span class="s1">data = pd.Series(range(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa_type))</span>
    <span class="s1">result = data.describe()</span>
    <span class="s1">expected = pd.Series(</span>
        <span class="s1">[</span><span class="s4">9</span><span class="s1">] + pd.to_timedelta([</span><span class="s4">5</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">9</span><span class="s1">]</span><span class="s2">, </span><span class="s1">unit=pa_type.unit).tolist()</span><span class="s2">,</span>
        <span class="s1">dtype=object</span><span class="s2">,</span>
        <span class="s1">index=[</span><span class="s3">&quot;count&quot;</span><span class="s2">, </span><span class="s3">&quot;mean&quot;</span><span class="s2">, </span><span class="s3">&quot;std&quot;</span><span class="s2">, </span><span class="s3">&quot;min&quot;</span><span class="s2">, </span><span class="s3">&quot;25%&quot;</span><span class="s2">, </span><span class="s3">&quot;50%&quot;</span><span class="s2">, </span><span class="s3">&quot;75%&quot;</span><span class="s2">, </span><span class="s3">&quot;max&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;pa_type&quot;</span><span class="s2">, </span><span class="s1">tm.DATETIME_PYARROW_DTYPES)</span>
<span class="s2">def </span><span class="s1">test_describe_datetime_data(pa_type):</span>
    <span class="s6"># GH53001</span>
    <span class="s1">data = pd.Series(range(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa_type))</span>
    <span class="s1">result = data.describe()</span>
    <span class="s1">expected = pd.Series(</span>
        <span class="s1">[</span><span class="s4">9</span><span class="s1">]</span>
        <span class="s1">+ [</span>
            <span class="s1">pd.Timestamp(v</span><span class="s2">, </span><span class="s1">tz=pa_type.tz</span><span class="s2">, </span><span class="s1">unit=pa_type.unit)</span>
            <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">[</span><span class="s4">5</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">9</span><span class="s1">]</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">dtype=object</span><span class="s2">,</span>
        <span class="s1">index=[</span><span class="s3">&quot;count&quot;</span><span class="s2">, </span><span class="s3">&quot;mean&quot;</span><span class="s2">, </span><span class="s3">&quot;min&quot;</span><span class="s2">, </span><span class="s3">&quot;25%&quot;</span><span class="s2">, </span><span class="s3">&quot;50%&quot;</span><span class="s2">, </span><span class="s3">&quot;75%&quot;</span><span class="s2">, </span><span class="s3">&quot;max&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;pa_type&quot;</span><span class="s2">, </span><span class="s1">tm.DATETIME_PYARROW_DTYPES + tm.TIMEDELTA_PYARROW_DTYPES</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_quantile_temporal(pa_type):</span>
    <span class="s6"># GH52678</span>
    <span class="s1">data = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span>
    <span class="s1">ser = pd.Series(data</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa_type))</span>
    <span class="s1">result = ser.quantile(</span><span class="s4">0.1</span><span class="s1">)</span>
    <span class="s1">expected = ser[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s2">assert </span><span class="s1">result == expected</span>


<span class="s2">def </span><span class="s1">test_date32_repr():</span>
    <span class="s6"># GH48238</span>
    <span class="s1">arrow_dt = pa.array([date.fromisoformat(</span><span class="s3">&quot;2020-01-01&quot;</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">type=pa.date32())</span>
    <span class="s1">ser = pd.Series(arrow_dt</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(arrow_dt.type))</span>
    <span class="s2">assert </span><span class="s1">repr(ser) == </span><span class="s3">&quot;0    2020-01-01</span><span class="s2">\n</span><span class="s3">dtype: date32[day][pyarrow]&quot;</span>


<span class="s1">@pytest.mark.xfail(</span>
    <span class="s1">pa_version_under8p0</span><span class="s2">,</span>
    <span class="s1">reason=</span><span class="s3">&quot;Function 'add_checked' has no kernel matching input types&quot;</span><span class="s2">,</span>
    <span class="s1">raises=pa.ArrowNotImplementedError</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_duration_overflow_from_ndarray_containing_nat():</span>
    <span class="s6"># GH52843</span>
    <span class="s1">data_ts = pd.to_datetime([</span><span class="s4">1</span><span class="s2">, None</span><span class="s1">])</span>
    <span class="s1">data_td = pd.to_timedelta([</span><span class="s4">1</span><span class="s2">, None</span><span class="s1">])</span>
    <span class="s1">ser_ts = pd.Series(data_ts</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.timestamp(</span><span class="s3">&quot;ns&quot;</span><span class="s1">)))</span>
    <span class="s1">ser_td = pd.Series(data_td</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.duration(</span><span class="s3">&quot;ns&quot;</span><span class="s1">)))</span>
    <span class="s1">result = ser_ts + ser_td</span>
    <span class="s1">expected = pd.Series([</span><span class="s4">2</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.timestamp(</span><span class="s3">&quot;ns&quot;</span><span class="s1">)))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_infer_dtype_pyarrow_dtype(data</span><span class="s2">, </span><span class="s1">request):</span>
    <span class="s1">res = lib.infer_dtype(data)</span>
    <span class="s2">assert </span><span class="s1">res != </span><span class="s3">&quot;unknown-array&quot;</span>

    <span class="s2">if </span><span class="s1">data._hasna </span><span class="s2">and </span><span class="s1">res </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;floating&quot;</span><span class="s2">, </span><span class="s3">&quot;datetime64&quot;</span><span class="s2">, </span><span class="s3">&quot;timedelta64&quot;</span><span class="s1">]:</span>
        <span class="s1">mark = pytest.mark.xfail(</span>
            <span class="s1">reason=</span><span class="s3">&quot;in infer_dtype pd.NA is not ignored in these cases &quot;</span>
            <span class="s3">&quot;even with skipna=True in the list(data) check below&quot;</span>
        <span class="s1">)</span>
        <span class="s1">request.node.add_marker(mark)</span>

    <span class="s2">assert </span><span class="s1">res == lib.infer_dtype(list(data)</span><span class="s2">, </span><span class="s1">skipna=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;pa_type&quot;</span><span class="s2">, </span><span class="s1">tm.DATETIME_PYARROW_DTYPES + tm.TIMEDELTA_PYARROW_DTYPES</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_from_sequence_temporal(pa_type):</span>
    <span class="s6"># GH 53171</span>
    <span class="s1">val = </span><span class="s4">3</span>
    <span class="s1">unit = pa_type.unit</span>
    <span class="s2">if </span><span class="s1">pa.types.is_duration(pa_type):</span>
        <span class="s1">seq = [pd.Timedelta(val</span><span class="s2">, </span><span class="s1">unit=unit).as_unit(unit)]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">seq = [pd.Timestamp(val</span><span class="s2">, </span><span class="s1">unit=unit</span><span class="s2">, </span><span class="s1">tz=pa_type.tz).as_unit(unit)]</span>

    <span class="s1">result = ArrowExtensionArray._from_sequence(seq</span><span class="s2">, </span><span class="s1">dtype=pa_type)</span>
    <span class="s1">expected = ArrowExtensionArray(pa.array([val]</span><span class="s2">, </span><span class="s1">type=pa_type))</span>
    <span class="s1">tm.assert_extension_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;pa_type&quot;</span><span class="s2">, </span><span class="s1">tm.DATETIME_PYARROW_DTYPES + tm.TIMEDELTA_PYARROW_DTYPES</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_setitem_temporal(pa_type):</span>
    <span class="s6"># GH 53171</span>
    <span class="s1">unit = pa_type.unit</span>
    <span class="s2">if </span><span class="s1">pa.types.is_duration(pa_type):</span>
        <span class="s1">val = pd.Timedelta(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">unit=unit).as_unit(unit)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">val = pd.Timestamp(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">unit=unit</span><span class="s2">, </span><span class="s1">tz=pa_type.tz).as_unit(unit)</span>

    <span class="s1">arr = ArrowExtensionArray(pa.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">type=pa_type))</span>

    <span class="s1">result = arr.copy()</span>
    <span class="s1">result[:] = val</span>
    <span class="s1">expected = ArrowExtensionArray(pa.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">type=pa_type))</span>
    <span class="s1">tm.assert_extension_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;pa_type&quot;</span><span class="s2">, </span><span class="s1">tm.DATETIME_PYARROW_DTYPES + tm.TIMEDELTA_PYARROW_DTYPES</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_arithmetic_temporal(pa_type</span><span class="s2">, </span><span class="s1">request):</span>
    <span class="s6"># GH 53171</span>
    <span class="s2">if </span><span class="s1">pa_version_under8p0 </span><span class="s2">and </span><span class="s1">pa.types.is_duration(pa_type):</span>
        <span class="s1">mark = pytest.mark.xfail(</span>
            <span class="s1">raises=pa.ArrowNotImplementedError</span><span class="s2">,</span>
            <span class="s1">reason=</span><span class="s3">&quot;Function 'subtract_checked' has no kernel matching input types&quot;</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">request.node.add_marker(mark)</span>

    <span class="s1">arr = ArrowExtensionArray(pa.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">type=pa_type))</span>
    <span class="s1">unit = pa_type.unit</span>
    <span class="s1">result = arr - pd.Timedelta(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">unit=unit).as_unit(unit)</span>
    <span class="s1">expected = ArrowExtensionArray(pa.array([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">type=pa_type))</span>
    <span class="s1">tm.assert_extension_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;pa_type&quot;</span><span class="s2">, </span><span class="s1">tm.DATETIME_PYARROW_DTYPES + tm.TIMEDELTA_PYARROW_DTYPES</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_comparison_temporal(pa_type):</span>
    <span class="s6"># GH 53171</span>
    <span class="s1">unit = pa_type.unit</span>
    <span class="s2">if </span><span class="s1">pa.types.is_duration(pa_type):</span>
        <span class="s1">val = pd.Timedelta(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">unit=unit).as_unit(unit)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">val = pd.Timestamp(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">unit=unit</span><span class="s2">, </span><span class="s1">tz=pa_type.tz).as_unit(unit)</span>

    <span class="s1">arr = ArrowExtensionArray(pa.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">type=pa_type))</span>

    <span class="s1">result = arr &gt; val</span>
    <span class="s1">expected = ArrowExtensionArray(pa.array([</span><span class="s2">False, True, True</span><span class="s1">]</span><span class="s2">, </span><span class="s1">type=pa.bool_()))</span>
    <span class="s1">tm.assert_extension_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;pa_type&quot;</span><span class="s2">, </span><span class="s1">tm.DATETIME_PYARROW_DTYPES + tm.TIMEDELTA_PYARROW_DTYPES</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_getitem_temporal(pa_type):</span>
    <span class="s6"># GH 53326</span>
    <span class="s1">arr = ArrowExtensionArray(pa.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">type=pa_type))</span>
    <span class="s1">result = arr[</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s2">if </span><span class="s1">pa.types.is_duration(pa_type):</span>
        <span class="s1">expected = pd.Timedelta(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">unit=pa_type.unit).as_unit(pa_type.unit)</span>
        <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">pd.Timedelta)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">expected = pd.Timestamp(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">unit=pa_type.unit</span><span class="s2">, </span><span class="s1">tz=pa_type.tz).as_unit(</span>
            <span class="s1">pa_type.unit</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">pd.Timestamp)</span>
    <span class="s2">assert </span><span class="s1">result.unit == expected.unit</span>
    <span class="s2">assert </span><span class="s1">result == expected</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;pa_type&quot;</span><span class="s2">, </span><span class="s1">tm.DATETIME_PYARROW_DTYPES + tm.TIMEDELTA_PYARROW_DTYPES</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_iter_temporal(pa_type):</span>
    <span class="s6"># GH 53326</span>
    <span class="s1">arr = ArrowExtensionArray(pa.array([</span><span class="s4">1</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">type=pa_type))</span>
    <span class="s1">result = list(arr)</span>
    <span class="s2">if </span><span class="s1">pa.types.is_duration(pa_type):</span>
        <span class="s1">expected = [</span>
            <span class="s1">pd.Timedelta(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">unit=pa_type.unit).as_unit(pa_type.unit)</span><span class="s2">,</span>
            <span class="s1">pd.NA</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s2">assert </span><span class="s1">isinstance(result[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pd.Timedelta)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">expected = [</span>
            <span class="s1">pd.Timestamp(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">unit=pa_type.unit</span><span class="s2">, </span><span class="s1">tz=pa_type.tz).as_unit(pa_type.unit)</span><span class="s2">,</span>
            <span class="s1">pd.NA</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s2">assert </span><span class="s1">isinstance(result[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pd.Timestamp)</span>
    <span class="s2">assert </span><span class="s1">result[</span><span class="s4">0</span><span class="s1">].unit == expected[</span><span class="s4">0</span><span class="s1">].unit</span>
    <span class="s2">assert </span><span class="s1">result == expected</span>


<span class="s2">def </span><span class="s1">test_groupby_series_size_returns_pa_int(data):</span>
    <span class="s6"># GH 54132</span>
    <span class="s1">ser = pd.Series(data[:</span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">])</span>
    <span class="s1">result = ser.groupby(level=</span><span class="s4">0</span><span class="s1">).size()</span>
    <span class="s1">expected = pd.Series([</span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;int64[pyarrow]&quot;</span><span class="s2">, </span><span class="s1">index=[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;pa_type&quot;</span><span class="s2">, </span><span class="s1">tm.DATETIME_PYARROW_DTYPES + tm.TIMEDELTA_PYARROW_DTYPES</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_to_numpy_temporal(pa_type):</span>
    <span class="s6"># GH 53326</span>
    <span class="s1">arr = ArrowExtensionArray(pa.array([</span><span class="s4">1</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">type=pa_type))</span>
    <span class="s1">result = arr.to_numpy()</span>
    <span class="s2">if </span><span class="s1">pa.types.is_duration(pa_type):</span>
        <span class="s1">expected = [</span>
            <span class="s1">pd.Timedelta(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">unit=pa_type.unit).as_unit(pa_type.unit)</span><span class="s2">,</span>
            <span class="s1">pd.NA</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s2">assert </span><span class="s1">isinstance(result[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pd.Timedelta)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">expected = [</span>
            <span class="s1">pd.Timestamp(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">unit=pa_type.unit</span><span class="s2">, </span><span class="s1">tz=pa_type.tz).as_unit(pa_type.unit)</span><span class="s2">,</span>
            <span class="s1">pd.NA</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s2">assert </span><span class="s1">isinstance(result[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pd.Timestamp)</span>
    <span class="s1">expected = np.array(expected</span><span class="s2">, </span><span class="s1">dtype=object)</span>
    <span class="s2">assert </span><span class="s1">result[</span><span class="s4">0</span><span class="s1">].unit == expected[</span><span class="s4">0</span><span class="s1">].unit</span>
    <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_groupby_count_return_arrow_dtype(data_missing):</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s3">&quot;A&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">: data_missing</span><span class="s2">, </span><span class="s3">&quot;C&quot;</span><span class="s1">: data_missing})</span>
    <span class="s1">result = df.groupby(</span><span class="s3">&quot;A&quot;</span><span class="s1">).count()</span>
    <span class="s1">expected = pd.DataFrame(</span>
        <span class="s1">[[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">index=pd.Index([</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;A&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">columns=[</span><span class="s3">&quot;B&quot;</span><span class="s2">, </span><span class="s3">&quot;C&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">dtype=</span><span class="s3">&quot;int64[pyarrow]&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_fixed_size_list():</span>
    <span class="s6"># GH#55000</span>
    <span class="s1">ser = pd.Series(</span>
        <span class="s1">[[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa.list_(pa.int64()</span><span class="s2">, </span><span class="s1">list_size=</span><span class="s4">2</span><span class="s1">))</span>
    <span class="s1">)</span>
    <span class="s1">result = ser.dtype.type</span>
    <span class="s2">assert </span><span class="s1">result == list</span>


<span class="s2">def </span><span class="s1">test_arrowextensiondtype_dataframe_repr():</span>
    <span class="s6"># GH 54062</span>
    <span class="s1">df = pd.DataFrame(</span>
        <span class="s1">pd.period_range(</span><span class="s3">&quot;2012&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">columns=[</span><span class="s3">&quot;col&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">dtype=ArrowDtype(ArrowPeriodType(</span><span class="s3">&quot;D&quot;</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">result = repr(df)</span>
    <span class="s6"># TODO: repr value may not be expected; address how</span>
    <span class="s6"># pyarrow.ExtensionType values are displayed</span>
    <span class="s1">expected = </span><span class="s3">&quot;     col</span><span class="s2">\n</span><span class="s3">0  15340</span><span class="s2">\n</span><span class="s3">1  15341</span><span class="s2">\n</span><span class="s3">2  15342&quot;</span>
    <span class="s2">assert </span><span class="s1">result == expected</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;pa_type&quot;</span><span class="s2">, </span><span class="s1">tm.TIMEDELTA_PYARROW_DTYPES)</span>
<span class="s2">def </span><span class="s1">test_duration_fillna_numpy(pa_type):</span>
    <span class="s6"># GH 54707</span>
    <span class="s1">ser1 = pd.Series([</span><span class="s2">None, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa_type))</span>
    <span class="s1">ser2 = pd.Series(np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">f&quot;m8[</span><span class="s2">{</span><span class="s1">pa_type.unit</span><span class="s2">}</span><span class="s3">]&quot;</span><span class="s1">))</span>
    <span class="s1">result = ser1.fillna(ser2)</span>
    <span class="s1">expected = pd.Series([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=ArrowDtype(pa_type))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_comparison_not_propagating_arrow_error():</span>
    <span class="s6"># GH#54944</span>
    <span class="s1">a = pd.Series([</span><span class="s4">1 </span><span class="s1">&lt;&lt; </span><span class="s4">63</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;uint64[pyarrow]&quot;</span><span class="s1">)</span>
    <span class="s1">b = pd.Series([</span><span class="s2">None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;int64[pyarrow]&quot;</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(pa.lib.ArrowInvalid</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Integer value&quot;</span><span class="s1">):</span>
        <span class="s1">a &lt; b</span>


<span class="s2">def </span><span class="s1">test_factorize_chunked_dictionary():</span>
    <span class="s6"># GH 54844</span>
    <span class="s1">pa_array = pa.chunked_array(</span>
        <span class="s1">[pa.array([</span><span class="s3">&quot;a&quot;</span><span class="s1">]).dictionary_encode()</span><span class="s2">, </span><span class="s1">pa.array([</span><span class="s3">&quot;b&quot;</span><span class="s1">]).dictionary_encode()]</span>
    <span class="s1">)</span>
    <span class="s1">ser = pd.Series(ArrowExtensionArray(pa_array))</span>
    <span class="s1">res_indices</span><span class="s2">, </span><span class="s1">res_uniques = ser.factorize()</span>
    <span class="s1">exp_indicies = np.array([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=np.intp)</span>
    <span class="s1">exp_uniques = pd.Index(ArrowExtensionArray(pa_array.combine_chunks()))</span>
    <span class="s1">tm.assert_numpy_array_equal(res_indices</span><span class="s2">, </span><span class="s1">exp_indicies)</span>
    <span class="s1">tm.assert_index_equal(res_uniques</span><span class="s2">, </span><span class="s1">exp_uniques)</span>


<span class="s2">def </span><span class="s1">test_arrow_floordiv():</span>
    <span class="s6"># GH 55561</span>
    <span class="s1">a = pd.Series([-</span><span class="s4">7</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;int64[pyarrow]&quot;</span><span class="s1">)</span>
    <span class="s1">b = pd.Series([</span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;int64[pyarrow]&quot;</span><span class="s1">)</span>
    <span class="s1">expected = pd.Series([-</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;int64[pyarrow]&quot;</span><span class="s1">)</span>
    <span class="s1">result = a // b</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
</pre>
</body>
</html>