<html>
<head>
<title>test_dbscan.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_dbscan.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Tests for DBSCAN clustering algorithm 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">pickle</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pytest</span>
<span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">sparse</span>
<span class="s2">from </span><span class="s1">scipy.spatial </span><span class="s2">import </span><span class="s1">distance</span>

<span class="s2">from </span><span class="s1">sklearn.cluster </span><span class="s2">import </span><span class="s1">DBSCAN</span><span class="s2">, </span><span class="s1">dbscan</span>
<span class="s2">from </span><span class="s1">sklearn.cluster.tests.common </span><span class="s2">import </span><span class="s1">generate_clustered_data</span>
<span class="s2">from </span><span class="s1">sklearn.metrics.pairwise </span><span class="s2">import </span><span class="s1">pairwise_distances</span>
<span class="s2">from </span><span class="s1">sklearn.neighbors </span><span class="s2">import </span><span class="s1">NearestNeighbors</span>
<span class="s2">from </span><span class="s1">sklearn.utils._testing </span><span class="s2">import </span><span class="s1">assert_array_equal</span>

<span class="s1">n_clusters = </span><span class="s3">3</span>
<span class="s1">X = generate_clustered_data(n_clusters=n_clusters)</span>


<span class="s2">def </span><span class="s1">test_dbscan_similarity():</span>
    <span class="s4"># Tests the DBSCAN algorithm with a similarity array.</span>
    <span class="s4"># Parameters chosen specifically for this task.</span>
    <span class="s1">eps = </span><span class="s3">0.15</span>
    <span class="s1">min_samples = </span><span class="s3">10</span>
    <span class="s4"># Compute similarities</span>
    <span class="s1">D = distance.squareform(distance.pdist(X))</span>
    <span class="s1">D /= np.max(D)</span>
    <span class="s4"># Compute DBSCAN</span>
    <span class="s1">core_samples</span><span class="s2">, </span><span class="s1">labels = dbscan(</span>
        <span class="s1">D</span><span class="s2">, </span><span class="s1">metric=</span><span class="s5">&quot;precomputed&quot;</span><span class="s2">, </span><span class="s1">eps=eps</span><span class="s2">, </span><span class="s1">min_samples=min_samples</span>
    <span class="s1">)</span>
    <span class="s4"># number of clusters, ignoring noise if present</span>
    <span class="s1">n_clusters_1 = len(set(labels)) - (</span><span class="s3">1 </span><span class="s2">if </span><span class="s1">-</span><span class="s3">1 </span><span class="s2">in </span><span class="s1">labels </span><span class="s2">else </span><span class="s3">0</span><span class="s1">)</span>

    <span class="s2">assert </span><span class="s1">n_clusters_1 == n_clusters</span>

    <span class="s1">db = DBSCAN(metric=</span><span class="s5">&quot;precomputed&quot;</span><span class="s2">, </span><span class="s1">eps=eps</span><span class="s2">, </span><span class="s1">min_samples=min_samples)</span>
    <span class="s1">labels = db.fit(D).labels_</span>

    <span class="s1">n_clusters_2 = len(set(labels)) - int(-</span><span class="s3">1 </span><span class="s2">in </span><span class="s1">labels)</span>
    <span class="s2">assert </span><span class="s1">n_clusters_2 == n_clusters</span>


<span class="s2">def </span><span class="s1">test_dbscan_feature():</span>
    <span class="s4"># Tests the DBSCAN algorithm with a feature vector array.</span>
    <span class="s4"># Parameters chosen specifically for this task.</span>
    <span class="s4"># Different eps to other test, because distance is not normalised.</span>
    <span class="s1">eps = </span><span class="s3">0.8</span>
    <span class="s1">min_samples = </span><span class="s3">10</span>
    <span class="s1">metric = </span><span class="s5">&quot;euclidean&quot;</span>
    <span class="s4"># Compute DBSCAN</span>
    <span class="s4"># parameters chosen for task</span>
    <span class="s1">core_samples</span><span class="s2">, </span><span class="s1">labels = dbscan(X</span><span class="s2">, </span><span class="s1">metric=metric</span><span class="s2">, </span><span class="s1">eps=eps</span><span class="s2">, </span><span class="s1">min_samples=min_samples)</span>

    <span class="s4"># number of clusters, ignoring noise if present</span>
    <span class="s1">n_clusters_1 = len(set(labels)) - int(-</span><span class="s3">1 </span><span class="s2">in </span><span class="s1">labels)</span>
    <span class="s2">assert </span><span class="s1">n_clusters_1 == n_clusters</span>

    <span class="s1">db = DBSCAN(metric=metric</span><span class="s2">, </span><span class="s1">eps=eps</span><span class="s2">, </span><span class="s1">min_samples=min_samples)</span>
    <span class="s1">labels = db.fit(X).labels_</span>

    <span class="s1">n_clusters_2 = len(set(labels)) - int(-</span><span class="s3">1 </span><span class="s2">in </span><span class="s1">labels)</span>
    <span class="s2">assert </span><span class="s1">n_clusters_2 == n_clusters</span>


<span class="s2">def </span><span class="s1">test_dbscan_sparse():</span>
    <span class="s1">core_sparse</span><span class="s2">, </span><span class="s1">labels_sparse = dbscan(sparse.lil_matrix(X)</span><span class="s2">, </span><span class="s1">eps=</span><span class="s3">0.8</span><span class="s2">, </span><span class="s1">min_samples=</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">core_dense</span><span class="s2">, </span><span class="s1">labels_dense = dbscan(X</span><span class="s2">, </span><span class="s1">eps=</span><span class="s3">0.8</span><span class="s2">, </span><span class="s1">min_samples=</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">assert_array_equal(core_dense</span><span class="s2">, </span><span class="s1">core_sparse)</span>
    <span class="s1">assert_array_equal(labels_dense</span><span class="s2">, </span><span class="s1">labels_sparse)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;include_self&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">False, True</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_dbscan_sparse_precomputed(include_self):</span>
    <span class="s1">D = pairwise_distances(X)</span>
    <span class="s1">nn = NearestNeighbors(radius=</span><span class="s3">0.9</span><span class="s1">).fit(X)</span>
    <span class="s1">X_ = X </span><span class="s2">if </span><span class="s1">include_self </span><span class="s2">else None</span>
    <span class="s1">D_sparse = nn.radius_neighbors_graph(X=X_</span><span class="s2">, </span><span class="s1">mode=</span><span class="s5">&quot;distance&quot;</span><span class="s1">)</span>
    <span class="s4"># Ensure it is sparse not merely on diagonals:</span>
    <span class="s2">assert </span><span class="s1">D_sparse.nnz &lt; D.shape[</span><span class="s3">0</span><span class="s1">] * (D.shape[</span><span class="s3">0</span><span class="s1">] - </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">core_sparse</span><span class="s2">, </span><span class="s1">labels_sparse = dbscan(</span>
        <span class="s1">D_sparse</span><span class="s2">, </span><span class="s1">eps=</span><span class="s3">0.8</span><span class="s2">, </span><span class="s1">min_samples=</span><span class="s3">10</span><span class="s2">, </span><span class="s1">metric=</span><span class="s5">&quot;precomputed&quot;</span>
    <span class="s1">)</span>
    <span class="s1">core_dense</span><span class="s2">, </span><span class="s1">labels_dense = dbscan(D</span><span class="s2">, </span><span class="s1">eps=</span><span class="s3">0.8</span><span class="s2">, </span><span class="s1">min_samples=</span><span class="s3">10</span><span class="s2">, </span><span class="s1">metric=</span><span class="s5">&quot;precomputed&quot;</span><span class="s1">)</span>
    <span class="s1">assert_array_equal(core_dense</span><span class="s2">, </span><span class="s1">core_sparse)</span>
    <span class="s1">assert_array_equal(labels_dense</span><span class="s2">, </span><span class="s1">labels_sparse)</span>


<span class="s2">def </span><span class="s1">test_dbscan_sparse_precomputed_different_eps():</span>
    <span class="s4"># test that precomputed neighbors graph is filtered if computed with</span>
    <span class="s4"># a radius larger than DBSCAN's eps.</span>
    <span class="s1">lower_eps = </span><span class="s3">0.2</span>
    <span class="s1">nn = NearestNeighbors(radius=lower_eps).fit(X)</span>
    <span class="s1">D_sparse = nn.radius_neighbors_graph(X</span><span class="s2">, </span><span class="s1">mode=</span><span class="s5">&quot;distance&quot;</span><span class="s1">)</span>
    <span class="s1">dbscan_lower = dbscan(D_sparse</span><span class="s2">, </span><span class="s1">eps=lower_eps</span><span class="s2">, </span><span class="s1">metric=</span><span class="s5">&quot;precomputed&quot;</span><span class="s1">)</span>

    <span class="s1">higher_eps = lower_eps + </span><span class="s3">0.7</span>
    <span class="s1">nn = NearestNeighbors(radius=higher_eps).fit(X)</span>
    <span class="s1">D_sparse = nn.radius_neighbors_graph(X</span><span class="s2">, </span><span class="s1">mode=</span><span class="s5">&quot;distance&quot;</span><span class="s1">)</span>
    <span class="s1">dbscan_higher = dbscan(D_sparse</span><span class="s2">, </span><span class="s1">eps=lower_eps</span><span class="s2">, </span><span class="s1">metric=</span><span class="s5">&quot;precomputed&quot;</span><span class="s1">)</span>

    <span class="s1">assert_array_equal(dbscan_lower[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dbscan_higher[</span><span class="s3">0</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(dbscan_lower[</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dbscan_higher[</span><span class="s3">1</span><span class="s1">])</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;use_sparse&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;metric&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s5">&quot;precomputed&quot;</span><span class="s2">, </span><span class="s5">&quot;minkowski&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_dbscan_input_not_modified(use_sparse</span><span class="s2">, </span><span class="s1">metric):</span>
    <span class="s4"># test that the input is not modified by dbscan</span>
    <span class="s1">X = np.random.RandomState(</span><span class="s3">0</span><span class="s1">).rand(</span><span class="s3">10</span><span class="s2">, </span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">X = sparse.csr_matrix(X) </span><span class="s2">if </span><span class="s1">use_sparse </span><span class="s2">else </span><span class="s1">X</span>
    <span class="s1">X_copy = X.copy()</span>
    <span class="s1">dbscan(X</span><span class="s2">, </span><span class="s1">metric=metric)</span>

    <span class="s2">if </span><span class="s1">use_sparse:</span>
        <span class="s1">assert_array_equal(X.toarray()</span><span class="s2">, </span><span class="s1">X_copy.toarray())</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">assert_array_equal(X</span><span class="s2">, </span><span class="s1">X_copy)</span>


<span class="s2">def </span><span class="s1">test_dbscan_no_core_samples():</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">X = rng.rand(</span><span class="s3">40</span><span class="s2">, </span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">X[X &lt; </span><span class="s3">0.8</span><span class="s1">] = </span><span class="s3">0</span>

    <span class="s2">for </span><span class="s1">X_ </span><span class="s2">in </span><span class="s1">[X</span><span class="s2">, </span><span class="s1">sparse.csr_matrix(X)]:</span>
        <span class="s1">db = DBSCAN(min_samples=</span><span class="s3">6</span><span class="s1">).fit(X_)</span>
        <span class="s1">assert_array_equal(db.components_</span><span class="s2">, </span><span class="s1">np.empty((</span><span class="s3">0</span><span class="s2">, </span><span class="s1">X_.shape[</span><span class="s3">1</span><span class="s1">])))</span>
        <span class="s1">assert_array_equal(db.labels_</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">db.core_sample_indices_.shape == (</span><span class="s3">0</span><span class="s2">,</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_dbscan_callable():</span>
    <span class="s4"># Tests the DBSCAN algorithm with a callable metric.</span>
    <span class="s4"># Parameters chosen specifically for this task.</span>
    <span class="s4"># Different eps to other test, because distance is not normalised.</span>
    <span class="s1">eps = </span><span class="s3">0.8</span>
    <span class="s1">min_samples = </span><span class="s3">10</span>
    <span class="s4"># metric is the function reference, not the string key.</span>
    <span class="s1">metric = distance.euclidean</span>
    <span class="s4"># Compute DBSCAN</span>
    <span class="s4"># parameters chosen for task</span>
    <span class="s1">core_samples</span><span class="s2">, </span><span class="s1">labels = dbscan(</span>
        <span class="s1">X</span><span class="s2">, </span><span class="s1">metric=metric</span><span class="s2">, </span><span class="s1">eps=eps</span><span class="s2">, </span><span class="s1">min_samples=min_samples</span><span class="s2">, </span><span class="s1">algorithm=</span><span class="s5">&quot;ball_tree&quot;</span>
    <span class="s1">)</span>

    <span class="s4"># number of clusters, ignoring noise if present</span>
    <span class="s1">n_clusters_1 = len(set(labels)) - int(-</span><span class="s3">1 </span><span class="s2">in </span><span class="s1">labels)</span>
    <span class="s2">assert </span><span class="s1">n_clusters_1 == n_clusters</span>

    <span class="s1">db = DBSCAN(metric=metric</span><span class="s2">, </span><span class="s1">eps=eps</span><span class="s2">, </span><span class="s1">min_samples=min_samples</span><span class="s2">, </span><span class="s1">algorithm=</span><span class="s5">&quot;ball_tree&quot;</span><span class="s1">)</span>
    <span class="s1">labels = db.fit(X).labels_</span>

    <span class="s1">n_clusters_2 = len(set(labels)) - int(-</span><span class="s3">1 </span><span class="s2">in </span><span class="s1">labels)</span>
    <span class="s2">assert </span><span class="s1">n_clusters_2 == n_clusters</span>


<span class="s2">def </span><span class="s1">test_dbscan_metric_params():</span>
    <span class="s4"># Tests that DBSCAN works with the metrics_params argument.</span>
    <span class="s1">eps = </span><span class="s3">0.8</span>
    <span class="s1">min_samples = </span><span class="s3">10</span>
    <span class="s1">p = </span><span class="s3">1</span>

    <span class="s4"># Compute DBSCAN with metric_params arg</span>

    <span class="s2">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s2">True</span><span class="s1">) </span><span class="s2">as </span><span class="s1">warns:</span>
        <span class="s1">db = DBSCAN(</span>
            <span class="s1">metric=</span><span class="s5">&quot;minkowski&quot;</span><span class="s2">,</span>
            <span class="s1">metric_params={</span><span class="s5">&quot;p&quot;</span><span class="s1">: p}</span><span class="s2">,</span>
            <span class="s1">eps=eps</span><span class="s2">,</span>
            <span class="s1">p=</span><span class="s2">None,</span>
            <span class="s1">min_samples=min_samples</span><span class="s2">,</span>
            <span class="s1">algorithm=</span><span class="s5">&quot;ball_tree&quot;</span><span class="s2">,</span>
        <span class="s1">).fit(X)</span>
    <span class="s2">assert not </span><span class="s1">warns</span><span class="s2">, </span><span class="s1">warns[</span><span class="s3">0</span><span class="s1">].message</span>
    <span class="s1">core_sample_1</span><span class="s2">, </span><span class="s1">labels_1 = db.core_sample_indices_</span><span class="s2">, </span><span class="s1">db.labels_</span>

    <span class="s4"># Test that sample labels are the same as passing Minkowski 'p' directly</span>
    <span class="s1">db = DBSCAN(</span>
        <span class="s1">metric=</span><span class="s5">&quot;minkowski&quot;</span><span class="s2">, </span><span class="s1">eps=eps</span><span class="s2">, </span><span class="s1">min_samples=min_samples</span><span class="s2">, </span><span class="s1">algorithm=</span><span class="s5">&quot;ball_tree&quot;</span><span class="s2">, </span><span class="s1">p=p</span>
    <span class="s1">).fit(X)</span>
    <span class="s1">core_sample_2</span><span class="s2">, </span><span class="s1">labels_2 = db.core_sample_indices_</span><span class="s2">, </span><span class="s1">db.labels_</span>

    <span class="s1">assert_array_equal(core_sample_1</span><span class="s2">, </span><span class="s1">core_sample_2)</span>
    <span class="s1">assert_array_equal(labels_1</span><span class="s2">, </span><span class="s1">labels_2)</span>

    <span class="s4"># Minkowski with p=1 should be equivalent to Manhattan distance</span>
    <span class="s1">db = DBSCAN(</span>
        <span class="s1">metric=</span><span class="s5">&quot;manhattan&quot;</span><span class="s2">, </span><span class="s1">eps=eps</span><span class="s2">, </span><span class="s1">min_samples=min_samples</span><span class="s2">, </span><span class="s1">algorithm=</span><span class="s5">&quot;ball_tree&quot;</span>
    <span class="s1">).fit(X)</span>
    <span class="s1">core_sample_3</span><span class="s2">, </span><span class="s1">labels_3 = db.core_sample_indices_</span><span class="s2">, </span><span class="s1">db.labels_</span>

    <span class="s1">assert_array_equal(core_sample_1</span><span class="s2">, </span><span class="s1">core_sample_3)</span>
    <span class="s1">assert_array_equal(labels_1</span><span class="s2">, </span><span class="s1">labels_3)</span>

    <span class="s2">with </span><span class="s1">pytest.warns(</span>
        <span class="s1">SyntaxWarning</span><span class="s2">,</span>
        <span class="s1">match=(</span>
            <span class="s5">&quot;Parameter p is found in metric_params. &quot;</span>
            <span class="s5">&quot;The corresponding parameter from __init__ &quot;</span>
            <span class="s5">&quot;is ignored.&quot;</span>
        <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s4"># Test that checks p is ignored in favor of metric_params={'p': &lt;val&gt;}</span>
        <span class="s1">db = DBSCAN(</span>
            <span class="s1">metric=</span><span class="s5">&quot;minkowski&quot;</span><span class="s2">,</span>
            <span class="s1">metric_params={</span><span class="s5">&quot;p&quot;</span><span class="s1">: p}</span><span class="s2">,</span>
            <span class="s1">eps=eps</span><span class="s2">,</span>
            <span class="s1">p=p + </span><span class="s3">1</span><span class="s2">,</span>
            <span class="s1">min_samples=min_samples</span><span class="s2">,</span>
            <span class="s1">algorithm=</span><span class="s5">&quot;ball_tree&quot;</span><span class="s2">,</span>
        <span class="s1">).fit(X)</span>
        <span class="s1">core_sample_4</span><span class="s2">, </span><span class="s1">labels_4 = db.core_sample_indices_</span><span class="s2">, </span><span class="s1">db.labels_</span>

    <span class="s1">assert_array_equal(core_sample_1</span><span class="s2">, </span><span class="s1">core_sample_4)</span>
    <span class="s1">assert_array_equal(labels_1</span><span class="s2">, </span><span class="s1">labels_4)</span>


<span class="s2">def </span><span class="s1">test_dbscan_balltree():</span>
    <span class="s4"># Tests the DBSCAN algorithm with balltree for neighbor calculation.</span>
    <span class="s1">eps = </span><span class="s3">0.8</span>
    <span class="s1">min_samples = </span><span class="s3">10</span>

    <span class="s1">D = pairwise_distances(X)</span>
    <span class="s1">core_samples</span><span class="s2">, </span><span class="s1">labels = dbscan(</span>
        <span class="s1">D</span><span class="s2">, </span><span class="s1">metric=</span><span class="s5">&quot;precomputed&quot;</span><span class="s2">, </span><span class="s1">eps=eps</span><span class="s2">, </span><span class="s1">min_samples=min_samples</span>
    <span class="s1">)</span>

    <span class="s4"># number of clusters, ignoring noise if present</span>
    <span class="s1">n_clusters_1 = len(set(labels)) - int(-</span><span class="s3">1 </span><span class="s2">in </span><span class="s1">labels)</span>
    <span class="s2">assert </span><span class="s1">n_clusters_1 == n_clusters</span>

    <span class="s1">db = DBSCAN(p=</span><span class="s3">2.0</span><span class="s2">, </span><span class="s1">eps=eps</span><span class="s2">, </span><span class="s1">min_samples=min_samples</span><span class="s2">, </span><span class="s1">algorithm=</span><span class="s5">&quot;ball_tree&quot;</span><span class="s1">)</span>
    <span class="s1">labels = db.fit(X).labels_</span>

    <span class="s1">n_clusters_2 = len(set(labels)) - int(-</span><span class="s3">1 </span><span class="s2">in </span><span class="s1">labels)</span>
    <span class="s2">assert </span><span class="s1">n_clusters_2 == n_clusters</span>

    <span class="s1">db = DBSCAN(p=</span><span class="s3">2.0</span><span class="s2">, </span><span class="s1">eps=eps</span><span class="s2">, </span><span class="s1">min_samples=min_samples</span><span class="s2">, </span><span class="s1">algorithm=</span><span class="s5">&quot;kd_tree&quot;</span><span class="s1">)</span>
    <span class="s1">labels = db.fit(X).labels_</span>

    <span class="s1">n_clusters_3 = len(set(labels)) - int(-</span><span class="s3">1 </span><span class="s2">in </span><span class="s1">labels)</span>
    <span class="s2">assert </span><span class="s1">n_clusters_3 == n_clusters</span>

    <span class="s1">db = DBSCAN(p=</span><span class="s3">1.0</span><span class="s2">, </span><span class="s1">eps=eps</span><span class="s2">, </span><span class="s1">min_samples=min_samples</span><span class="s2">, </span><span class="s1">algorithm=</span><span class="s5">&quot;ball_tree&quot;</span><span class="s1">)</span>
    <span class="s1">labels = db.fit(X).labels_</span>

    <span class="s1">n_clusters_4 = len(set(labels)) - int(-</span><span class="s3">1 </span><span class="s2">in </span><span class="s1">labels)</span>
    <span class="s2">assert </span><span class="s1">n_clusters_4 == n_clusters</span>

    <span class="s1">db = DBSCAN(leaf_size=</span><span class="s3">20</span><span class="s2">, </span><span class="s1">eps=eps</span><span class="s2">, </span><span class="s1">min_samples=min_samples</span><span class="s2">, </span><span class="s1">algorithm=</span><span class="s5">&quot;ball_tree&quot;</span><span class="s1">)</span>
    <span class="s1">labels = db.fit(X).labels_</span>

    <span class="s1">n_clusters_5 = len(set(labels)) - int(-</span><span class="s3">1 </span><span class="s2">in </span><span class="s1">labels)</span>
    <span class="s2">assert </span><span class="s1">n_clusters_5 == n_clusters</span>


<span class="s2">def </span><span class="s1">test_input_validation():</span>
    <span class="s4"># DBSCAN.fit should accept a list of lists.</span>
    <span class="s1">X = [[</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">2.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">3.0</span><span class="s2">, </span><span class="s3">4.0</span><span class="s1">]]</span>
    <span class="s1">DBSCAN().fit(X)  </span><span class="s4"># must not raise exception</span>


<span class="s2">def </span><span class="s1">test_pickle():</span>
    <span class="s1">obj = DBSCAN()</span>
    <span class="s1">s = pickle.dumps(obj)</span>
    <span class="s2">assert </span><span class="s1">type(pickle.loads(s)) == obj.__class__</span>


<span class="s2">def </span><span class="s1">test_boundaries():</span>
    <span class="s4"># ensure min_samples is inclusive of core point</span>
    <span class="s1">core</span><span class="s2">, </span><span class="s1">_ = dbscan([[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">eps=</span><span class="s3">2</span><span class="s2">, </span><span class="s1">min_samples=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s3">0 </span><span class="s2">in </span><span class="s1">core</span>
    <span class="s4"># ensure eps is inclusive of circumference</span>
    <span class="s1">core</span><span class="s2">, </span><span class="s1">_ = dbscan([[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">eps=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">min_samples=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s3">0 </span><span class="s2">in </span><span class="s1">core</span>
    <span class="s1">core</span><span class="s2">, </span><span class="s1">_ = dbscan([[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">eps=</span><span class="s3">0.99</span><span class="s2">, </span><span class="s1">min_samples=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s3">0 </span><span class="s2">not in </span><span class="s1">core</span>


<span class="s2">def </span><span class="s1">test_weighted_dbscan(global_random_seed):</span>
    <span class="s4"># ensure sample_weight is validated</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">dbscan([[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">sample_weight=[</span><span class="s3">2</span><span class="s1">])</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">dbscan([[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">sample_weight=[</span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s1">])</span>

    <span class="s4"># ensure sample_weight has an effect</span>
    <span class="s1">assert_array_equal([]</span><span class="s2">, </span><span class="s1">dbscan([[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">sample_weight=</span><span class="s2">None, </span><span class="s1">min_samples=</span><span class="s3">6</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">])</span>
    <span class="s1">assert_array_equal([]</span><span class="s2">, </span><span class="s1">dbscan([[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">sample_weight=[</span><span class="s3">5</span><span class="s2">, </span><span class="s3">5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">min_samples=</span><span class="s3">6</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">])</span>
    <span class="s1">assert_array_equal([</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dbscan([[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">sample_weight=[</span><span class="s3">6</span><span class="s2">, </span><span class="s3">5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">min_samples=</span><span class="s3">6</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(</span>
        <span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dbscan([[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">sample_weight=[</span><span class="s3">6</span><span class="s2">, </span><span class="s3">6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">min_samples=</span><span class="s3">6</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">)</span>

    <span class="s4"># points within eps of each other:</span>
    <span class="s1">assert_array_equal(</span>
        <span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dbscan([[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">eps=</span><span class="s3">1.5</span><span class="s2">, </span><span class="s1">sample_weight=[</span><span class="s3">5</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">min_samples=</span><span class="s3">6</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s4"># and effect of non-positive and non-integer sample_weight:</span>
    <span class="s1">assert_array_equal(</span>
        <span class="s1">[]</span><span class="s2">, </span><span class="s1">dbscan([[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">sample_weight=[</span><span class="s3">5</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">eps=</span><span class="s3">1.5</span><span class="s2">, </span><span class="s1">min_samples=</span><span class="s3">6</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">assert_array_equal(</span>
        <span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dbscan([[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">sample_weight=[</span><span class="s3">5.9</span><span class="s2">, </span><span class="s3">0.1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">eps=</span><span class="s3">1.5</span><span class="s2">, </span><span class="s1">min_samples=</span><span class="s3">6</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">assert_array_equal(</span>
        <span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dbscan([[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">sample_weight=[</span><span class="s3">6</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">eps=</span><span class="s3">1.5</span><span class="s2">, </span><span class="s1">min_samples=</span><span class="s3">6</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">assert_array_equal(</span>
        <span class="s1">[]</span><span class="s2">, </span><span class="s1">dbscan([[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">sample_weight=[</span><span class="s3">6</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">eps=</span><span class="s3">1.5</span><span class="s2">, </span><span class="s1">min_samples=</span><span class="s3">6</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">)</span>

    <span class="s4"># for non-negative sample_weight, cores should be identical to repetition</span>
    <span class="s1">rng = np.random.RandomState(global_random_seed)</span>
    <span class="s1">sample_weight = rng.randint(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s1">X.shape[</span><span class="s3">0</span><span class="s1">])</span>
    <span class="s1">core1</span><span class="s2">, </span><span class="s1">label1 = dbscan(X</span><span class="s2">, </span><span class="s1">sample_weight=sample_weight)</span>
    <span class="s2">assert </span><span class="s1">len(label1) == len(X)</span>

    <span class="s1">X_repeated = np.repeat(X</span><span class="s2">, </span><span class="s1">sample_weight</span><span class="s2">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">core_repeated</span><span class="s2">, </span><span class="s1">label_repeated = dbscan(X_repeated)</span>
    <span class="s1">core_repeated_mask = np.zeros(X_repeated.shape[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=bool)</span>
    <span class="s1">core_repeated_mask[core_repeated] = </span><span class="s2">True</span>
    <span class="s1">core_mask = np.zeros(X.shape[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=bool)</span>
    <span class="s1">core_mask[core1] = </span><span class="s2">True</span>
    <span class="s1">assert_array_equal(np.repeat(core_mask</span><span class="s2">, </span><span class="s1">sample_weight)</span><span class="s2">, </span><span class="s1">core_repeated_mask)</span>

    <span class="s4"># sample_weight should work with precomputed distance matrix</span>
    <span class="s1">D = pairwise_distances(X)</span>
    <span class="s1">core3</span><span class="s2">, </span><span class="s1">label3 = dbscan(D</span><span class="s2">, </span><span class="s1">sample_weight=sample_weight</span><span class="s2">, </span><span class="s1">metric=</span><span class="s5">&quot;precomputed&quot;</span><span class="s1">)</span>
    <span class="s1">assert_array_equal(core1</span><span class="s2">, </span><span class="s1">core3)</span>
    <span class="s1">assert_array_equal(label1</span><span class="s2">, </span><span class="s1">label3)</span>

    <span class="s4"># sample_weight should work with estimator</span>
    <span class="s1">est = DBSCAN().fit(X</span><span class="s2">, </span><span class="s1">sample_weight=sample_weight)</span>
    <span class="s1">core4 = est.core_sample_indices_</span>
    <span class="s1">label4 = est.labels_</span>
    <span class="s1">assert_array_equal(core1</span><span class="s2">, </span><span class="s1">core4)</span>
    <span class="s1">assert_array_equal(label1</span><span class="s2">, </span><span class="s1">label4)</span>

    <span class="s1">est = DBSCAN()</span>
    <span class="s1">label5 = est.fit_predict(X</span><span class="s2">, </span><span class="s1">sample_weight=sample_weight)</span>
    <span class="s1">core5 = est.core_sample_indices_</span>
    <span class="s1">assert_array_equal(core1</span><span class="s2">, </span><span class="s1">core5)</span>
    <span class="s1">assert_array_equal(label1</span><span class="s2">, </span><span class="s1">label5)</span>
    <span class="s1">assert_array_equal(label1</span><span class="s2">, </span><span class="s1">est.labels_)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;algorithm&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s5">&quot;brute&quot;</span><span class="s2">, </span><span class="s5">&quot;kd_tree&quot;</span><span class="s2">, </span><span class="s5">&quot;ball_tree&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_dbscan_core_samples_toy(algorithm):</span>
    <span class="s1">X = [[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">8</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">10</span><span class="s1">]]</span>
    <span class="s1">n_samples = len(X)</span>

    <span class="s4"># Degenerate case: every sample is a core sample, either with its own</span>
    <span class="s4"># cluster or including other close core samples.</span>
    <span class="s1">core_samples</span><span class="s2">, </span><span class="s1">labels = dbscan(X</span><span class="s2">, </span><span class="s1">algorithm=algorithm</span><span class="s2">, </span><span class="s1">eps=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">min_samples=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_array_equal(core_samples</span><span class="s2">, </span><span class="s1">np.arange(n_samples))</span>
    <span class="s1">assert_array_equal(labels</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s1">])</span>

    <span class="s4"># With eps=1 and min_samples=2 only the 3 samples from the denser area</span>
    <span class="s4"># are core samples. All other points are isolated and considered noise.</span>
    <span class="s1">core_samples</span><span class="s2">, </span><span class="s1">labels = dbscan(X</span><span class="s2">, </span><span class="s1">algorithm=algorithm</span><span class="s2">, </span><span class="s1">eps=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">min_samples=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">assert_array_equal(core_samples</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(labels</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">])</span>

    <span class="s4"># Only the sample in the middle of the dense area is core. Its two</span>
    <span class="s4"># neighbors are edge samples. Remaining samples are noise.</span>
    <span class="s1">core_samples</span><span class="s2">, </span><span class="s1">labels = dbscan(X</span><span class="s2">, </span><span class="s1">algorithm=algorithm</span><span class="s2">, </span><span class="s1">eps=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">min_samples=</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">assert_array_equal(core_samples</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(labels</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">])</span>

    <span class="s4"># It's no longer possible to extract core samples with eps=1:</span>
    <span class="s4"># everything is noise.</span>
    <span class="s1">core_samples</span><span class="s2">, </span><span class="s1">labels = dbscan(X</span><span class="s2">, </span><span class="s1">algorithm=algorithm</span><span class="s2">, </span><span class="s1">eps=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">min_samples=</span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">assert_array_equal(core_samples</span><span class="s2">, </span><span class="s1">[])</span>
    <span class="s1">assert_array_equal(labels</span><span class="s2">, </span><span class="s1">np.full(n_samples</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1.0</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">test_dbscan_precomputed_metric_with_degenerate_input_arrays():</span>
    <span class="s4"># see https://github.com/scikit-learn/scikit-learn/issues/4641 for</span>
    <span class="s4"># more details</span>
    <span class="s1">X = np.eye(</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">labels = DBSCAN(eps=</span><span class="s3">0.5</span><span class="s2">, </span><span class="s1">metric=</span><span class="s5">&quot;precomputed&quot;</span><span class="s1">).fit(X).labels_</span>
    <span class="s2">assert </span><span class="s1">len(set(labels)) == </span><span class="s3">1</span>

    <span class="s1">X = np.zeros((</span><span class="s3">10</span><span class="s2">, </span><span class="s3">10</span><span class="s1">))</span>
    <span class="s1">labels = DBSCAN(eps=</span><span class="s3">0.5</span><span class="s2">, </span><span class="s1">metric=</span><span class="s5">&quot;precomputed&quot;</span><span class="s1">).fit(X).labels_</span>
    <span class="s2">assert </span><span class="s1">len(set(labels)) == </span><span class="s3">1</span>


<span class="s2">def </span><span class="s1">test_dbscan_precomputed_metric_with_initial_rows_zero():</span>
    <span class="s4"># sample matrix with initial two row all zero</span>
    <span class="s1">ar = np.array(</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.3</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.1</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.3</span><span class="s2">, </span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">matrix = sparse.csr_matrix(ar)</span>
    <span class="s1">labels = DBSCAN(eps=</span><span class="s3">0.2</span><span class="s2">, </span><span class="s1">metric=</span><span class="s5">&quot;precomputed&quot;</span><span class="s2">, </span><span class="s1">min_samples=</span><span class="s3">2</span><span class="s1">).fit(matrix).labels_</span>
    <span class="s1">assert_array_equal(labels</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>
</pre>
</body>
</html>