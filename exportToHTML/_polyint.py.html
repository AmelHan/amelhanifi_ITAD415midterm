<html>
<head>
<title>_polyint.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_polyint.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">scipy.special </span><span class="s0">import </span><span class="s1">factorial</span>
<span class="s0">from </span><span class="s1">scipy._lib._util </span><span class="s0">import </span><span class="s1">_asarray_validated</span><span class="s0">, </span><span class="s1">float_factorial</span>


<span class="s1">__all__ = [</span><span class="s2">&quot;KroghInterpolator&quot;</span><span class="s0">, </span><span class="s2">&quot;krogh_interpolate&quot;</span><span class="s0">, </span><span class="s2">&quot;BarycentricInterpolator&quot;</span><span class="s0">,</span>
           <span class="s2">&quot;barycentric_interpolate&quot;</span><span class="s0">, </span><span class="s2">&quot;approximate_taylor_polynomial&quot;</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">_isscalar(x):</span>
    <span class="s3">&quot;&quot;&quot;Check whether x is if a scalar type, or 0-dim&quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">np.isscalar(x) </span><span class="s0">or </span><span class="s1">hasattr(x</span><span class="s0">, </span><span class="s2">'shape'</span><span class="s1">) </span><span class="s0">and </span><span class="s1">x.shape == ()</span>


<span class="s0">class </span><span class="s1">_Interpolator1D:</span>
    <span class="s3">&quot;&quot;&quot; 
    Common features in univariate interpolation 
 
    Deal with input data type and interpolation axis rolling. The 
    actual interpolator can assume the y-data is of shape (n, r) where 
    `n` is the number of x-points, and `r` the number of variables, 
    and use self.dtype as the y-data type. 
 
    Attributes 
    ---------- 
    _y_axis 
        Axis along which the interpolation goes in the original array 
    _y_extra_shape 
        Additional trailing shape of the input arrays, excluding 
        the interpolation axis. 
    dtype 
        Dtype of the y-data arrays. Can be set via _set_dtype, which 
        forces it to be float or complex. 
 
    Methods 
    ------- 
    __call__ 
    _prepare_x 
    _finish_y 
    _reshape_yi 
    _set_yi 
    _set_dtype 
    _evaluate 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = (</span><span class="s2">'_y_axis'</span><span class="s0">, </span><span class="s2">'_y_extra_shape'</span><span class="s0">, </span><span class="s2">'dtype'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">xi=</span><span class="s0">None, </span><span class="s1">yi=</span><span class="s0">None, </span><span class="s1">axis=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">self._y_axis = axis</span>
        <span class="s1">self._y_extra_shape = </span><span class="s0">None</span>
        <span class="s1">self.dtype = </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">yi </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self._set_yi(yi</span><span class="s0">, </span><span class="s1">xi=xi</span><span class="s0">, </span><span class="s1">axis=axis)</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s3">&quot;&quot;&quot; 
        Evaluate the interpolant 
 
        Parameters 
        ---------- 
        x : array_like 
            Points to evaluate the interpolant at. 
 
        Returns 
        ------- 
        y : array_like 
            Interpolated values. Shape is determined by replacing 
            the interpolation axis in the original array with the shape of x. 
 
        Notes 
        ----- 
        Input values `x` must be convertible to `float` values like `int` 
        or `float`. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">x</span><span class="s0">, </span><span class="s1">x_shape = self._prepare_x(x)</span>
        <span class="s1">y = self._evaluate(x)</span>
        <span class="s0">return </span><span class="s1">self._finish_y(y</span><span class="s0">, </span><span class="s1">x_shape)</span>

    <span class="s0">def </span><span class="s1">_evaluate(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s3">&quot;&quot;&quot; 
        Actually evaluate the value of the interpolator. 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s0">def </span><span class="s1">_prepare_x(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s3">&quot;&quot;&quot;Reshape input x array to 1-D&quot;&quot;&quot;</span>
        <span class="s1">x = _asarray_validated(x</span><span class="s0">, </span><span class="s1">check_finite=</span><span class="s0">False, </span><span class="s1">as_inexact=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">x_shape = x.shape</span>
        <span class="s0">return </span><span class="s1">x.ravel()</span><span class="s0">, </span><span class="s1">x_shape</span>

    <span class="s0">def </span><span class="s1">_finish_y(self</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">x_shape):</span>
        <span class="s3">&quot;&quot;&quot;Reshape interpolated y back to an N-D array similar to initial y&quot;&quot;&quot;</span>
        <span class="s1">y = y.reshape(x_shape + self._y_extra_shape)</span>
        <span class="s0">if </span><span class="s1">self._y_axis != </span><span class="s4">0 </span><span class="s0">and </span><span class="s1">x_shape != ():</span>
            <span class="s1">nx = len(x_shape)</span>
            <span class="s1">ny = len(self._y_extra_shape)</span>
            <span class="s1">s = (list(range(nx</span><span class="s0">, </span><span class="s1">nx + self._y_axis))</span>
                 <span class="s1">+ list(range(nx)) + list(range(nx+self._y_axis</span><span class="s0">, </span><span class="s1">nx+ny)))</span>
            <span class="s1">y = y.transpose(s)</span>
        <span class="s0">return </span><span class="s1">y</span>

    <span class="s0">def </span><span class="s1">_reshape_yi(self</span><span class="s0">, </span><span class="s1">yi</span><span class="s0">, </span><span class="s1">check=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s1">yi = np.moveaxis(np.asarray(yi)</span><span class="s0">, </span><span class="s1">self._y_axis</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">check </span><span class="s0">and </span><span class="s1">yi.shape[</span><span class="s4">1</span><span class="s1">:] != self._y_extra_shape:</span>
            <span class="s1">ok_shape = </span><span class="s2">&quot;{!r} + (N,) + {!r}&quot;</span><span class="s1">.format(self._y_extra_shape[-self._y_axis:]</span><span class="s0">,</span>
                                           <span class="s1">self._y_extra_shape[:-self._y_axis])</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Data must be of shape %s&quot; </span><span class="s1">% ok_shape)</span>
        <span class="s0">return </span><span class="s1">yi.reshape((yi.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">_set_yi(self</span><span class="s0">, </span><span class="s1">yi</span><span class="s0">, </span><span class="s1">xi=</span><span class="s0">None, </span><span class="s1">axis=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">axis = self._y_axis</span>
        <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;no interpolation axis specified&quot;</span><span class="s1">)</span>

        <span class="s1">yi = np.asarray(yi)</span>

        <span class="s1">shape = yi.shape</span>
        <span class="s0">if </span><span class="s1">shape == ():</span>
            <span class="s1">shape = (</span><span class="s4">1</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">xi </span><span class="s0">is not None and </span><span class="s1">shape[axis] != len(xi):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;x and y arrays must be equal in length along &quot;</span>
                             <span class="s2">&quot;interpolation axis.&quot;</span><span class="s1">)</span>

        <span class="s1">self._y_axis = (axis % yi.ndim)</span>
        <span class="s1">self._y_extra_shape = yi.shape[:self._y_axis]+yi.shape[self._y_axis+</span><span class="s4">1</span><span class="s1">:]</span>
        <span class="s1">self.dtype = </span><span class="s0">None</span>
        <span class="s1">self._set_dtype(yi.dtype)</span>

    <span class="s0">def </span><span class="s1">_set_dtype(self</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">union=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">np.issubdtype(dtype</span><span class="s0">, </span><span class="s1">np.complexfloating) \</span>
               <span class="s0">or </span><span class="s1">np.issubdtype(self.dtype</span><span class="s0">, </span><span class="s1">np.complexfloating):</span>
            <span class="s1">self.dtype = np.complex_</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">union </span><span class="s0">or </span><span class="s1">self.dtype != np.complex_:</span>
                <span class="s1">self.dtype = np.float_</span>


<span class="s0">class </span><span class="s1">_Interpolator1DWithDerivatives(_Interpolator1D):</span>
    <span class="s0">def </span><span class="s1">derivatives(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">der=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Evaluate many derivatives of the polynomial at the point x 
 
        Produce an array of all derivative values at the point x. 
 
        Parameters 
        ---------- 
        x : array_like 
            Point or points at which to evaluate the derivatives 
        der : int or None, optional 
            How many derivatives to extract; None for all potentially 
            nonzero derivatives (that is a number equal to the number 
            of points). This number includes the function value as 0th 
            derivative. 
 
        Returns 
        ------- 
        d : ndarray 
            Array with derivatives; d[j] contains the jth derivative. 
            Shape of d[j] is determined by replacing the interpolation 
            axis in the original array with the shape of x. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; from scipy.interpolate import KroghInterpolator 
        &gt;&gt;&gt; KroghInterpolator([0,0,0],[1,2,3]).derivatives(0) 
        array([1.0,2.0,3.0]) 
        &gt;&gt;&gt; KroghInterpolator([0,0,0],[1,2,3]).derivatives([0,0]) 
        array([[1.0,1.0], 
               [2.0,2.0], 
               [3.0,3.0]]) 
 
        &quot;&quot;&quot;</span>
        <span class="s1">x</span><span class="s0">, </span><span class="s1">x_shape = self._prepare_x(x)</span>
        <span class="s1">y = self._evaluate_derivatives(x</span><span class="s0">, </span><span class="s1">der)</span>

        <span class="s1">y = y.reshape((y.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">,</span><span class="s1">) + x_shape + self._y_extra_shape)</span>
        <span class="s0">if </span><span class="s1">self._y_axis != </span><span class="s4">0 </span><span class="s0">and </span><span class="s1">x_shape != ():</span>
            <span class="s1">nx = len(x_shape)</span>
            <span class="s1">ny = len(self._y_extra_shape)</span>
            <span class="s1">s = ([</span><span class="s4">0</span><span class="s1">] + list(range(nx+</span><span class="s4">1</span><span class="s0">, </span><span class="s1">nx + self._y_axis+</span><span class="s4">1</span><span class="s1">))</span>
                 <span class="s1">+ list(range(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">nx+</span><span class="s4">1</span><span class="s1">)) +</span>
                 <span class="s1">list(range(nx+</span><span class="s4">1</span><span class="s1">+self._y_axis</span><span class="s0">, </span><span class="s1">nx+ny+</span><span class="s4">1</span><span class="s1">)))</span>
            <span class="s1">y = y.transpose(s)</span>
        <span class="s0">return </span><span class="s1">y</span>

    <span class="s0">def </span><span class="s1">derivative(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">der=</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Evaluate one derivative of the polynomial at the point x 
 
        Parameters 
        ---------- 
        x : array_like 
            Point or points at which to evaluate the derivatives 
 
        der : integer, optional 
            Which derivative to extract. This number includes the 
            function value as 0th derivative. 
 
        Returns 
        ------- 
        d : ndarray 
            Derivative interpolated at the x-points. Shape of d is 
            determined by replacing the interpolation axis in the 
            original array with the shape of x. 
 
        Notes 
        ----- 
        This is computed by evaluating all derivatives up to the desired 
        one (using self.derivatives()) and then discarding the rest. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">x</span><span class="s0">, </span><span class="s1">x_shape = self._prepare_x(x)</span>
        <span class="s1">y = self._evaluate_derivatives(x</span><span class="s0">, </span><span class="s1">der+</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self._finish_y(y[der]</span><span class="s0">, </span><span class="s1">x_shape)</span>


<span class="s0">class </span><span class="s1">KroghInterpolator(_Interpolator1DWithDerivatives):</span>
    <span class="s3">&quot;&quot;&quot; 
    Interpolating polynomial for a set of points. 
 
    The polynomial passes through all the pairs (xi,yi). One may 
    additionally specify a number of derivatives at each point xi; 
    this is done by repeating the value xi and specifying the 
    derivatives as successive yi values. 
 
    Allows evaluation of the polynomial and all its derivatives. 
    For reasons of numerical stability, this function does not compute 
    the coefficients of the polynomial, although they can be obtained 
    by evaluating all the derivatives. 
 
    Parameters 
    ---------- 
    xi : array_like, shape (npoints, ) 
        Known x-coordinates. Must be sorted in increasing order. 
    yi : array_like, shape (..., npoints, ...) 
        Known y-coordinates. When an xi occurs two or more times in 
        a row, the corresponding yi's represent derivative values. The length of `yi` 
        along the interpolation axis must be equal to the length of `xi`. Use the 
        `axis` parameter to select the correct axis. 
    axis : int, optional 
        Axis in the `yi` array corresponding to the x-coordinate values. Defaults to 
        ``axis=0``. 
 
    Notes 
    ----- 
    Be aware that the algorithms implemented here are not necessarily 
    the most numerically stable known. Moreover, even in a world of 
    exact computation, unless the x coordinates are chosen very 
    carefully - Chebyshev zeros (e.g., cos(i*pi/n)) are a good choice - 
    polynomial interpolation itself is a very ill-conditioned process 
    due to the Runge phenomenon. In general, even with well-chosen 
    x values, degrees higher than about thirty cause problems with 
    numerical instability in this code. 
 
    Based on [1]_. 
 
    References 
    ---------- 
    .. [1] Krogh, &quot;Efficient Algorithms for Polynomial Interpolation 
        and Numerical Differentiation&quot;, 1970. 
 
    Examples 
    -------- 
    To produce a polynomial that is zero at 0 and 1 and has 
    derivative 2 at 0, call 
 
    &gt;&gt;&gt; from scipy.interpolate import KroghInterpolator 
    &gt;&gt;&gt; KroghInterpolator([0,0,1],[0,2,0]) 
 
    This constructs the quadratic 2*X**2-2*X. The derivative condition 
    is indicated by the repeated zero in the xi array; the corresponding 
    yi values are 0, the function value, and 2, the derivative value. 
 
    For another example, given xi, yi, and a derivative ypi for each 
    point, appropriate arrays can be constructed as: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; xi = np.linspace(0, 1, 5) 
    &gt;&gt;&gt; yi, ypi = rng.random((2, 5)) 
    &gt;&gt;&gt; xi_k, yi_k = np.repeat(xi, 2), np.ravel(np.dstack((yi,ypi))) 
    &gt;&gt;&gt; KroghInterpolator(xi_k, yi_k) 
 
    To produce a vector-valued polynomial, supply a higher-dimensional 
    array for yi: 
 
    &gt;&gt;&gt; KroghInterpolator([0,1],[[2,3],[4,5]]) 
 
    This constructs a linear polynomial giving (2,3) at 0 and (4,5) at 1. 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">xi</span><span class="s0">, </span><span class="s1">yi</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">):</span>
        <span class="s1">_Interpolator1DWithDerivatives.__init__(self</span><span class="s0">, </span><span class="s1">xi</span><span class="s0">, </span><span class="s1">yi</span><span class="s0">, </span><span class="s1">axis)</span>

        <span class="s1">self.xi = np.asarray(xi)</span>
        <span class="s1">self.yi = self._reshape_yi(yi)</span>
        <span class="s1">self.n</span><span class="s0">, </span><span class="s1">self.r = self.yi.shape</span>

        <span class="s0">if </span><span class="s1">(deg := self.xi.size) &gt; </span><span class="s4">30</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">deg</span><span class="s0">} </span><span class="s2">degrees provided, degrees higher than about&quot;</span>
                          <span class="s2">&quot; thirty cause problems with numerical instability &quot;</span>
                          <span class="s2">&quot;with 'KroghInterpolator'&quot;</span><span class="s0">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">)</span>

        <span class="s1">c = np.zeros((self.n+</span><span class="s4">1</span><span class="s0">, </span><span class="s1">self.r)</span><span class="s0">, </span><span class="s1">dtype=self.dtype)</span>
        <span class="s1">c[</span><span class="s4">0</span><span class="s1">] = self.yi[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">Vk = np.zeros((self.n</span><span class="s0">, </span><span class="s1">self.r)</span><span class="s0">, </span><span class="s1">dtype=self.dtype)</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">self.n):</span>
            <span class="s1">s = </span><span class="s4">0</span>
            <span class="s0">while </span><span class="s1">s &lt;= k </span><span class="s0">and </span><span class="s1">xi[k-s] == xi[k]:</span>
                <span class="s1">s += </span><span class="s4">1</span>
            <span class="s1">s -= </span><span class="s4">1</span>
            <span class="s1">Vk[</span><span class="s4">0</span><span class="s1">] = self.yi[k]/float_factorial(s)</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(k-s):</span>
                <span class="s0">if </span><span class="s1">xi[i] == xi[k]:</span>
                    <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Elements if `xi` can't be equal.&quot;</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">s == </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s1">Vk[i+</span><span class="s4">1</span><span class="s1">] = (c[i]-Vk[i])/(xi[i]-xi[k])</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">Vk[i+</span><span class="s4">1</span><span class="s1">] = (Vk[i+</span><span class="s4">1</span><span class="s1">]-Vk[i])/(xi[i]-xi[k])</span>
            <span class="s1">c[k] = Vk[k-s]</span>
        <span class="s1">self.c = c</span>

    <span class="s0">def </span><span class="s1">_evaluate(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s1">pi = </span><span class="s4">1</span>
        <span class="s1">p = np.zeros((len(x)</span><span class="s0">, </span><span class="s1">self.r)</span><span class="s0">, </span><span class="s1">dtype=self.dtype)</span>
        <span class="s1">p += self.c[</span><span class="s4">0</span><span class="s0">,</span><span class="s1">np.newaxis</span><span class="s0">,</span><span class="s1">:]</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">self.n):</span>
            <span class="s1">w = x - self.xi[k-</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">pi = w*pi</span>
            <span class="s1">p += pi[:</span><span class="s0">,</span><span class="s1">np.newaxis] * self.c[k]</span>
        <span class="s0">return </span><span class="s1">p</span>

    <span class="s0">def </span><span class="s1">_evaluate_derivatives(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">der=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">n = self.n</span>
        <span class="s1">r = self.r</span>

        <span class="s0">if </span><span class="s1">der </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">der = self.n</span>
        <span class="s1">pi = np.zeros((n</span><span class="s0">, </span><span class="s1">len(x)))</span>
        <span class="s1">w = np.zeros((n</span><span class="s0">, </span><span class="s1">len(x)))</span>
        <span class="s1">pi[</span><span class="s4">0</span><span class="s1">] = </span><span class="s4">1</span>
        <span class="s1">p = np.zeros((len(x)</span><span class="s0">, </span><span class="s1">self.r)</span><span class="s0">, </span><span class="s1">dtype=self.dtype)</span>
        <span class="s1">p += self.c[</span><span class="s4">0</span><span class="s0">, </span><span class="s1">np.newaxis</span><span class="s0">, </span><span class="s1">:]</span>

        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">n):</span>
            <span class="s1">w[k-</span><span class="s4">1</span><span class="s1">] = x - self.xi[k-</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">pi[k] = w[k-</span><span class="s4">1</span><span class="s1">] * pi[k-</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">p += pi[k</span><span class="s0">, </span><span class="s1">:</span><span class="s0">, </span><span class="s1">np.newaxis] * self.c[k]</span>

        <span class="s1">cn = np.zeros((max(der</span><span class="s0">, </span><span class="s1">n+</span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">len(x)</span><span class="s0">, </span><span class="s1">r)</span><span class="s0">, </span><span class="s1">dtype=self.dtype)</span>
        <span class="s1">cn[:n+</span><span class="s4">1</span><span class="s0">, </span><span class="s1">:</span><span class="s0">, </span><span class="s1">:] += self.c[:n+</span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.newaxis</span><span class="s0">, </span><span class="s1">:]</span>
        <span class="s1">cn[</span><span class="s4">0</span><span class="s1">] = p</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">n):</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">n-k+</span><span class="s4">1</span><span class="s1">):</span>
                <span class="s1">pi[i] = w[k+i-</span><span class="s4">1</span><span class="s1">]*pi[i-</span><span class="s4">1</span><span class="s1">] + pi[i]</span>
                <span class="s1">cn[k] = cn[k] + pi[i</span><span class="s0">, </span><span class="s1">:</span><span class="s0">, </span><span class="s1">np.newaxis]*cn[k+i]</span>
            <span class="s1">cn[k] *= float_factorial(k)</span>

        <span class="s1">cn[n</span><span class="s0">, </span><span class="s1">:</span><span class="s0">, </span><span class="s1">:] = </span><span class="s4">0</span>
        <span class="s0">return </span><span class="s1">cn[:der]</span>


<span class="s0">def </span><span class="s1">krogh_interpolate(xi</span><span class="s0">, </span><span class="s1">yi</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">der=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Convenience function for polynomial interpolation. 
 
    See `KroghInterpolator` for more details. 
 
    Parameters 
    ---------- 
    xi : array_like 
        Known x-coordinates. 
    yi : array_like 
        Known y-coordinates, of shape ``(xi.size, R)``. Interpreted as 
        vectors of length R, or scalars if R=1. 
    x : array_like 
        Point or points at which to evaluate the derivatives. 
    der : int or list, optional 
        How many derivatives to extract; None for all potentially 
        nonzero derivatives (that is a number equal to the number 
        of points), or a list of derivatives to extract. This number 
        includes the function value as 0th derivative. 
    axis : int, optional 
        Axis in the yi array corresponding to the x-coordinate values. 
 
    Returns 
    ------- 
    d : ndarray 
        If the interpolator's values are R-D then the 
        returned array will be the number of derivatives by N by R. 
        If `x` is a scalar, the middle dimension will be dropped; if 
        the `yi` are scalars then the last dimension will be dropped. 
 
    See Also 
    -------- 
    KroghInterpolator : Krogh interpolator 
 
    Notes 
    ----- 
    Construction of the interpolating polynomial is a relatively expensive 
    process. If you want to evaluate it repeatedly consider using the class 
    KroghInterpolator (which is what this function uses). 
 
    Examples 
    -------- 
    We can interpolate 2D observed data using krogh interpolation: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from scipy.interpolate import krogh_interpolate 
    &gt;&gt;&gt; x_observed = np.linspace(0.0, 10.0, 11) 
    &gt;&gt;&gt; y_observed = np.sin(x_observed) 
    &gt;&gt;&gt; x = np.linspace(min(x_observed), max(x_observed), num=100) 
    &gt;&gt;&gt; y = krogh_interpolate(x_observed, y_observed, x) 
    &gt;&gt;&gt; plt.plot(x_observed, y_observed, &quot;o&quot;, label=&quot;observation&quot;) 
    &gt;&gt;&gt; plt.plot(x, y, label=&quot;krogh interpolation&quot;) 
    &gt;&gt;&gt; plt.legend() 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">P = KroghInterpolator(xi</span><span class="s0">, </span><span class="s1">yi</span><span class="s0">, </span><span class="s1">axis=axis)</span>
    <span class="s0">if </span><span class="s1">der == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">P(x)</span>
    <span class="s0">elif </span><span class="s1">_isscalar(der):</span>
        <span class="s0">return </span><span class="s1">P.derivative(x</span><span class="s0">,</span><span class="s1">der=der)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">P.derivatives(x</span><span class="s0">,</span><span class="s1">der=np.amax(der)+</span><span class="s4">1</span><span class="s1">)[der]</span>


<span class="s0">def </span><span class="s1">approximate_taylor_polynomial(f</span><span class="s0">,</span><span class="s1">x</span><span class="s0">,</span><span class="s1">degree</span><span class="s0">,</span><span class="s1">scale</span><span class="s0">,</span><span class="s1">order=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Estimate the Taylor polynomial of f at x by polynomial fitting. 
 
    Parameters 
    ---------- 
    f : callable 
        The function whose Taylor polynomial is sought. Should accept 
        a vector of `x` values. 
    x : scalar 
        The point at which the polynomial is to be evaluated. 
    degree : int 
        The degree of the Taylor polynomial 
    scale : scalar 
        The width of the interval to use to evaluate the Taylor polynomial. 
        Function values spread over a range this wide are used to fit the 
        polynomial. Must be chosen carefully. 
    order : int or None, optional 
        The order of the polynomial to be used in the fitting; `f` will be 
        evaluated ``order+1`` times. If None, use `degree`. 
 
    Returns 
    ------- 
    p : poly1d instance 
        The Taylor polynomial (translated to the origin, so that 
        for example p(0)=f(x)). 
 
    Notes 
    ----- 
    The appropriate choice of &quot;scale&quot; is a trade-off; too large and the 
    function differs from its Taylor polynomial too much to get a good 
    answer, too small and round-off errors overwhelm the higher-order terms. 
    The algorithm used becomes numerically unstable around order 30 even 
    under ideal circumstances. 
 
    Choosing order somewhat larger than degree may improve the higher-order 
    terms. 
 
    Examples 
    -------- 
    We can calculate Taylor approximation polynomials of sin function with 
    various degrees: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from scipy.interpolate import approximate_taylor_polynomial 
    &gt;&gt;&gt; x = np.linspace(-10.0, 10.0, num=100) 
    &gt;&gt;&gt; plt.plot(x, np.sin(x), label=&quot;sin curve&quot;) 
    &gt;&gt;&gt; for degree in np.arange(1, 15, step=2): 
    ...     sin_taylor = approximate_taylor_polynomial(np.sin, 0, degree, 1, 
    ...                                                order=degree + 2) 
    ...     plt.plot(x, sin_taylor(x), label=f&quot;degree={degree}&quot;) 
    &gt;&gt;&gt; plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left', 
    ...            borderaxespad=0.0, shadow=True) 
    &gt;&gt;&gt; plt.tight_layout() 
    &gt;&gt;&gt; plt.axis([-10, 10, -10, 10]) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">order </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">order = degree</span>

    <span class="s1">n = order+</span><span class="s4">1</span>
    <span class="s5"># Choose n points that cluster near the endpoints of the interval in</span>
    <span class="s5"># a way that avoids the Runge phenomenon. Ensure, by including the</span>
    <span class="s5"># endpoint or not as appropriate, that one point always falls at x</span>
    <span class="s5"># exactly.</span>
    <span class="s1">xs = scale*np.cos(np.linspace(</span><span class="s4">0</span><span class="s0">,</span><span class="s1">np.pi</span><span class="s0">,</span><span class="s1">n</span><span class="s0">,</span><span class="s1">endpoint=n % </span><span class="s4">1</span><span class="s1">)) + x</span>

    <span class="s1">P = KroghInterpolator(xs</span><span class="s0">, </span><span class="s1">f(xs))</span>
    <span class="s1">d = P.derivatives(x</span><span class="s0">,</span><span class="s1">der=degree+</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">np.poly1d((d/factorial(np.arange(degree+</span><span class="s4">1</span><span class="s1">)))[::-</span><span class="s4">1</span><span class="s1">])</span>


<span class="s0">class </span><span class="s1">BarycentricInterpolator(_Interpolator1D):</span>
    <span class="s3">&quot;&quot;&quot;The interpolating polynomial for a set of points 
 
    Constructs a polynomial that passes through a given set of points. 
    Allows evaluation of the polynomial, efficient changing of the y 
    values to be interpolated, and updating by adding more x values. 
    For reasons of numerical stability, this function does not compute 
    the coefficients of the polynomial. 
 
    The values yi need to be provided before the function is 
    evaluated, but none of the preprocessing depends on them, so rapid 
    updates are possible. 
 
    Parameters 
    ---------- 
    xi : array_like, shape (npoints, ) 
        1-D array of x coordinates of the points the polynomial 
        should pass through 
    yi : array_like, shape (..., npoints, ...), optional 
        N-D array of y coordinates of the points the polynomial should pass through. 
        If None, the y values will be supplied later via the `set_y` method. 
        The length of `yi` along the interpolation axis must be equal to the length 
        of `xi`. Use the ``axis`` parameter to select correct axis. 
    axis : int, optional 
        Axis in the yi array corresponding to the x-coordinate values. Defaults 
        to ``axis=0``. 
 
    Notes 
    ----- 
    This class uses a &quot;barycentric interpolation&quot; method that treats 
    the problem as a special case of rational function interpolation. 
    This algorithm is quite stable, numerically, but even in a world of 
    exact computation, unless the x coordinates are chosen very 
    carefully - Chebyshev zeros (e.g., cos(i*pi/n)) are a good choice - 
    polynomial interpolation itself is a very ill-conditioned process 
    due to the Runge phenomenon. 
 
    Based on Berrut and Trefethen 2004, &quot;Barycentric Lagrange Interpolation&quot;. 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">xi</span><span class="s0">, </span><span class="s1">yi=</span><span class="s0">None, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">):</span>
        <span class="s1">_Interpolator1D.__init__(self</span><span class="s0">, </span><span class="s1">xi</span><span class="s0">, </span><span class="s1">yi</span><span class="s0">, </span><span class="s1">axis)</span>

        <span class="s1">self.xi = np.asfarray(xi)</span>
        <span class="s1">self.set_yi(yi)</span>
        <span class="s1">self.n = len(self.xi)</span>

        <span class="s5"># See page 510 of Berrut and Trefethen 2004 for an explanation of the</span>
        <span class="s5"># capacity scaling and the suggestion of using a random permutation of</span>
        <span class="s5"># the input factors.</span>
        <span class="s5"># At the moment, the permutation is not performed for xi that are</span>
        <span class="s5"># appended later through the add_xi interface. It's not clear to me how</span>
        <span class="s5"># to implement that and it seems that most situations that require</span>
        <span class="s5"># these numerical stability improvements will be able to provide all</span>
        <span class="s5"># the points to the constructor.</span>
        <span class="s1">self._inv_capacity = </span><span class="s4">4.0 </span><span class="s1">/ (np.max(self.xi) - np.min(self.xi))</span>
        <span class="s1">permute = np.random.permutation(self.n)</span>
        <span class="s1">inv_permute = np.zeros(self.n</span><span class="s0">, </span><span class="s1">dtype=np.int32)</span>
        <span class="s1">inv_permute[permute] = np.arange(self.n)</span>

        <span class="s1">self.wi = np.zeros(self.n)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(self.n):</span>
            <span class="s1">dist = self._inv_capacity * (self.xi[i] - self.xi[permute])</span>
            <span class="s1">dist[inv_permute[i]] = </span><span class="s4">1.0</span>
            <span class="s1">self.wi[i] = </span><span class="s4">1.0 </span><span class="s1">/ np.prod(dist)</span>

    <span class="s0">def </span><span class="s1">set_yi(self</span><span class="s0">, </span><span class="s1">yi</span><span class="s0">, </span><span class="s1">axis=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Update the y values to be interpolated 
 
        The barycentric interpolation algorithm requires the calculation 
        of weights, but these depend only on the xi. The yi can be changed 
        at any time. 
 
        Parameters 
        ---------- 
        yi : array_like 
            The y coordinates of the points the polynomial should pass through. 
            If None, the y values will be supplied later. 
        axis : int, optional 
            Axis in the yi array corresponding to the x-coordinate values. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">yi </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self.yi = </span><span class="s0">None</span>
            <span class="s0">return</span>
        <span class="s1">self._set_yi(yi</span><span class="s0">, </span><span class="s1">xi=self.xi</span><span class="s0">, </span><span class="s1">axis=axis)</span>
        <span class="s1">self.yi = self._reshape_yi(yi)</span>
        <span class="s1">self.n</span><span class="s0">, </span><span class="s1">self.r = self.yi.shape</span>

    <span class="s0">def </span><span class="s1">add_xi(self</span><span class="s0">, </span><span class="s1">xi</span><span class="s0">, </span><span class="s1">yi=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Add more x values to the set to be interpolated 
 
        The barycentric interpolation algorithm allows easy updating by 
        adding more points for the polynomial to pass through. 
 
        Parameters 
        ---------- 
        xi : array_like 
            The x coordinates of the points that the polynomial should pass 
            through. 
        yi : array_like, optional 
            The y coordinates of the points the polynomial should pass through. 
            Should have shape ``(xi.size, R)``; if R &gt; 1 then the polynomial is 
            vector-valued. 
            If `yi` is not given, the y values will be supplied later. `yi` 
            should be given if and only if the interpolator has y values 
            specified. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">yi </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.yi </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;No previous yi value to update!&quot;</span><span class="s1">)</span>
            <span class="s1">yi = self._reshape_yi(yi</span><span class="s0">, </span><span class="s1">check=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">self.yi = np.vstack((self.yi</span><span class="s0">,</span><span class="s1">yi))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.yi </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;No update to yi provided!&quot;</span><span class="s1">)</span>
        <span class="s1">old_n = self.n</span>
        <span class="s1">self.xi = np.concatenate((self.xi</span><span class="s0">,</span><span class="s1">xi))</span>
        <span class="s1">self.n = len(self.xi)</span>
        <span class="s1">self.wi **= -</span><span class="s4">1</span>
        <span class="s1">old_wi = self.wi</span>
        <span class="s1">self.wi = np.zeros(self.n)</span>
        <span class="s1">self.wi[:old_n] = old_wi</span>
        <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(old_n</span><span class="s0">, </span><span class="s1">self.n):</span>
            <span class="s1">self.wi[:j] *= self._inv_capacity * (self.xi[j]-self.xi[:j])</span>
            <span class="s1">self.wi[j] = np.multiply.reduce(</span>
                <span class="s1">self._inv_capacity * (self.xi[:j]-self.xi[j])</span>
            <span class="s1">)</span>
        <span class="s1">self.wi **= -</span><span class="s4">1</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s3">&quot;&quot;&quot;Evaluate the interpolating polynomial at the points x 
 
        Parameters 
        ---------- 
        x : array_like 
            Points to evaluate the interpolant at. 
 
        Returns 
        ------- 
        y : array_like 
            Interpolated values. Shape is determined by replacing 
            the interpolation axis in the original array with the shape of x. 
 
        Notes 
        ----- 
        Currently the code computes an outer product between x and the 
        weights, that is, it constructs an intermediate array of size 
        N by len(x), where N is the degree of the polynomial. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">_Interpolator1D.__call__(self</span><span class="s0">, </span><span class="s1">x)</span>

    <span class="s0">def </span><span class="s1">_evaluate(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">if </span><span class="s1">x.size == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">p = np.zeros((</span><span class="s4">0</span><span class="s0">, </span><span class="s1">self.r)</span><span class="s0">, </span><span class="s1">dtype=self.dtype)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">c = x[...</span><span class="s0">, </span><span class="s1">np.newaxis] - self.xi</span>
            <span class="s1">z = c == </span><span class="s4">0</span>
            <span class="s1">c[z] = </span><span class="s4">1</span>
            <span class="s1">c = self.wi/c</span>
            <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s2">'ignore'</span><span class="s1">):</span>
                <span class="s1">p = np.dot(c</span><span class="s0">, </span><span class="s1">self.yi) / np.sum(c</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s4">1</span><span class="s1">)[...</span><span class="s0">, </span><span class="s1">np.newaxis]</span>
            <span class="s5"># Now fix where x==some xi</span>
            <span class="s1">r = np.nonzero(z)</span>
            <span class="s0">if </span><span class="s1">len(r) == </span><span class="s4">1</span><span class="s1">:  </span><span class="s5"># evaluation at a scalar</span>
                <span class="s0">if </span><span class="s1">len(r[</span><span class="s4">0</span><span class="s1">]) &gt; </span><span class="s4">0</span><span class="s1">:  </span><span class="s5"># equals one of the points</span>
                    <span class="s1">p = self.yi[r[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">p[r[:-</span><span class="s4">1</span><span class="s1">]] = self.yi[r[-</span><span class="s4">1</span><span class="s1">]]</span>
        <span class="s0">return </span><span class="s1">p</span>


<span class="s0">def </span><span class="s1">barycentric_interpolate(xi</span><span class="s0">, </span><span class="s1">yi</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Convenience function for polynomial interpolation. 
 
    Constructs a polynomial that passes through a given set of points, 
    then evaluates the polynomial. For reasons of numerical stability, 
    this function does not compute the coefficients of the polynomial. 
 
    This function uses a &quot;barycentric interpolation&quot; method that treats 
    the problem as a special case of rational function interpolation. 
    This algorithm is quite stable, numerically, but even in a world of 
    exact computation, unless the `x` coordinates are chosen very 
    carefully - Chebyshev zeros (e.g., cos(i*pi/n)) are a good choice - 
    polynomial interpolation itself is a very ill-conditioned process 
    due to the Runge phenomenon. 
 
    Parameters 
    ---------- 
    xi : array_like 
        1-D array of x coordinates of the points the polynomial should 
        pass through 
    yi : array_like 
        The y coordinates of the points the polynomial should pass through. 
    x : scalar or array_like 
        Points to evaluate the interpolator at. 
    axis : int, optional 
        Axis in the yi array corresponding to the x-coordinate values. 
 
    Returns 
    ------- 
    y : scalar or array_like 
        Interpolated values. Shape is determined by replacing 
        the interpolation axis in the original array with the shape of x. 
 
    See Also 
    -------- 
    BarycentricInterpolator : Bary centric interpolator 
 
    Notes 
    ----- 
    Construction of the interpolation weights is a relatively slow process. 
    If you want to call this many times with the same xi (but possibly 
    varying yi or x) you should use the class `BarycentricInterpolator`. 
    This is what this function uses internally. 
 
    Examples 
    -------- 
    We can interpolate 2D observed data using barycentric interpolation: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from scipy.interpolate import barycentric_interpolate 
    &gt;&gt;&gt; x_observed = np.linspace(0.0, 10.0, 11) 
    &gt;&gt;&gt; y_observed = np.sin(x_observed) 
    &gt;&gt;&gt; x = np.linspace(min(x_observed), max(x_observed), num=100) 
    &gt;&gt;&gt; y = barycentric_interpolate(x_observed, y_observed, x) 
    &gt;&gt;&gt; plt.plot(x_observed, y_observed, &quot;o&quot;, label=&quot;observation&quot;) 
    &gt;&gt;&gt; plt.plot(x, y, label=&quot;barycentric interpolation&quot;) 
    &gt;&gt;&gt; plt.legend() 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">BarycentricInterpolator(xi</span><span class="s0">, </span><span class="s1">yi</span><span class="s0">, </span><span class="s1">axis=axis)(x)</span>
</pre>
</body>
</html>