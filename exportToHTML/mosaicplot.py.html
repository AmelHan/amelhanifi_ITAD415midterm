<html>
<head>
<title>mosaicplot.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
mosaicplot.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Create a mosaic plot from a contingency table. 
 
It allows to visualize multivariate categorical data in a rigorous 
and informative way. 
 
see the docstring of the mosaic function for more informations. 
&quot;&quot;&quot;</span>
<span class="s2"># Author: Enrico Giampieri - 21 Jan 2013</span>

<span class="s3">from </span><span class="s1">statsmodels.compat.python </span><span class="s3">import </span><span class="s1">lrange</span><span class="s3">, </span><span class="s1">lzip</span>

<span class="s3">from </span><span class="s1">itertools </span><span class="s3">import </span><span class="s1">product</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">numpy </span><span class="s3">import </span><span class="s1">array</span><span class="s3">, </span><span class="s1">cumsum</span><span class="s3">, </span><span class="s1">iterable</span><span class="s3">, </span><span class="s1">r_</span>
<span class="s3">from </span><span class="s1">pandas </span><span class="s3">import </span><span class="s1">DataFrame</span>

<span class="s3">from </span><span class="s1">statsmodels.graphics </span><span class="s3">import </span><span class="s1">utils</span>

<span class="s1">__all__ = [</span><span class="s4">&quot;mosaic&quot;</span><span class="s1">]</span>


<span class="s3">def </span><span class="s1">_normalize_split(proportion):</span>
    <span class="s0">&quot;&quot;&quot; 
    return a list of proportions of the available space given the division 
    if only a number is given, it will assume a split in two pieces 
    &quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s1">iterable(proportion):</span>
        <span class="s3">if </span><span class="s1">proportion == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">proportion = array([</span><span class="s5">0.0</span><span class="s3">, </span><span class="s5">1.0</span><span class="s1">])</span>
        <span class="s3">elif </span><span class="s1">proportion &gt;= </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">proportion = array([</span><span class="s5">1.0</span><span class="s3">, </span><span class="s5">0.0</span><span class="s1">])</span>
        <span class="s3">elif </span><span class="s1">proportion &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;proportions should be positive,&quot;</span>
                              <span class="s4">&quot;given value: {}&quot;</span><span class="s1">.format(proportion))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">proportion = array([proportion</span><span class="s3">, </span><span class="s5">1.0 </span><span class="s1">- proportion])</span>
    <span class="s1">proportion = np.asarray(proportion</span><span class="s3">, </span><span class="s1">dtype=float)</span>
    <span class="s3">if </span><span class="s1">np.any(proportion &lt; </span><span class="s5">0</span><span class="s1">):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;proportions should be positive,&quot;</span>
                          <span class="s4">&quot;given value: {}&quot;</span><span class="s1">.format(proportion))</span>
    <span class="s3">if </span><span class="s1">np.allclose(proportion</span><span class="s3">, </span><span class="s5">0</span><span class="s1">):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;at least one proportion should be &quot;</span>
                          <span class="s4">&quot;greater than zero&quot;</span><span class="s1">.format(proportion))</span>
    <span class="s2"># ok, data are meaningful, so go on</span>
    <span class="s3">if </span><span class="s1">len(proportion) &lt; </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">array([</span><span class="s5">0.0</span><span class="s3">, </span><span class="s5">1.0</span><span class="s1">])</span>
    <span class="s1">left = r_[</span><span class="s5">0</span><span class="s3">, </span><span class="s1">cumsum(proportion)]</span>
    <span class="s1">left /= left[-</span><span class="s5">1</span><span class="s1">] * </span><span class="s5">1.0</span>
    <span class="s3">return </span><span class="s1">left</span>


<span class="s3">def </span><span class="s1">_split_rect(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">width</span><span class="s3">, </span><span class="s1">height</span><span class="s3">, </span><span class="s1">proportion</span><span class="s3">, </span><span class="s1">horizontal=</span><span class="s3">True, </span><span class="s1">gap=</span><span class="s5">0.05</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Split the given rectangle in n segments whose proportion is specified 
    along the given axis if a gap is inserted, they will be separated by a 
    certain amount of space, retaining the relative proportion between them 
    a gap of 1 correspond to a plot that is half void and the remaining half 
    space is proportionally divided among the pieces. 
    &quot;&quot;&quot;</span>
    <span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">h = float(x)</span><span class="s3">, </span><span class="s1">float(y)</span><span class="s3">, </span><span class="s1">float(width)</span><span class="s3">, </span><span class="s1">float(height)</span>
    <span class="s3">if </span><span class="s1">(w &lt; </span><span class="s5">0</span><span class="s1">) </span><span class="s3">or </span><span class="s1">(h &lt; </span><span class="s5">0</span><span class="s1">):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;dimension of the square less than&quot;</span>
                          <span class="s4">&quot;zero w={} h=()&quot;</span><span class="s1">.format(w</span><span class="s3">, </span><span class="s1">h))</span>
    <span class="s1">proportions = _normalize_split(proportion)</span>

    <span class="s2"># extract the starting point and the dimension of each subdivision</span>
    <span class="s2"># in respect to the unit square</span>
    <span class="s1">starting = proportions[:-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">amplitude = proportions[</span><span class="s5">1</span><span class="s1">:] - starting</span>

    <span class="s2"># how much each extrema is going to be displaced due to gaps</span>
    <span class="s1">starting += gap * np.arange(len(proportions) - </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s2"># how much the squares plus the gaps are extended</span>
    <span class="s1">extension = starting[-</span><span class="s5">1</span><span class="s1">] + amplitude[-</span><span class="s5">1</span><span class="s1">] - starting[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s2"># normalize everything for fit again in the original dimension</span>
    <span class="s1">starting /= extension</span>
    <span class="s1">amplitude /= extension</span>

    <span class="s2"># bring everything to the original square</span>
    <span class="s1">starting = (x </span><span class="s3">if </span><span class="s1">horizontal </span><span class="s3">else </span><span class="s1">y) + starting * (w </span><span class="s3">if </span><span class="s1">horizontal </span><span class="s3">else </span><span class="s1">h)</span>
    <span class="s1">amplitude = amplitude * (w </span><span class="s3">if </span><span class="s1">horizontal </span><span class="s3">else </span><span class="s1">h)</span>

    <span class="s2"># create each 4-tuple for each new block</span>
    <span class="s1">results = [(s</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">h) </span><span class="s3">if </span><span class="s1">horizontal </span><span class="s3">else </span><span class="s1">(x</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">a)</span>
                <span class="s3">for </span><span class="s1">s</span><span class="s3">, </span><span class="s1">a </span><span class="s3">in </span><span class="s1">zip(starting</span><span class="s3">, </span><span class="s1">amplitude)]</span>
    <span class="s3">return </span><span class="s1">results</span>


<span class="s3">def </span><span class="s1">_reduce_dict(count_dict</span><span class="s3">, </span><span class="s1">partial_key):</span>
    <span class="s0">&quot;&quot;&quot; 
    Make partial sum on a counter dict. 
    Given a match for the beginning of the category, it will sum each value. 
    &quot;&quot;&quot;</span>
    <span class="s1">L = len(partial_key)</span>
    <span class="s1">count = sum(v </span><span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">count_dict.items() </span><span class="s3">if </span><span class="s1">k[:L] == partial_key)</span>
    <span class="s3">return </span><span class="s1">count</span>


<span class="s3">def </span><span class="s1">_key_splitting(rect_dict</span><span class="s3">, </span><span class="s1">keys</span><span class="s3">, </span><span class="s1">values</span><span class="s3">, </span><span class="s1">key_subset</span><span class="s3">, </span><span class="s1">horizontal</span><span class="s3">, </span><span class="s1">gap):</span>
    <span class="s0">&quot;&quot;&quot; 
    Given a dictionary where each entry  is a rectangle, a list of key and 
    value (count of elements in each category) it split each rect accordingly, 
    as long as the key start with the tuple key_subset.  The other keys are 
    returned without modification. 
    &quot;&quot;&quot;</span>
    <span class="s1">result = {}</span>
    <span class="s1">L = len(key_subset)</span>
    <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">h) </span><span class="s3">in </span><span class="s1">rect_dict.items():</span>
        <span class="s3">if </span><span class="s1">key_subset == name[:L]:</span>
            <span class="s2"># split base on the values given</span>
            <span class="s1">divisions = _split_rect(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">h</span><span class="s3">, </span><span class="s1">values</span><span class="s3">, </span><span class="s1">horizontal</span><span class="s3">, </span><span class="s1">gap)</span>
            <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">rect </span><span class="s3">in </span><span class="s1">zip(keys</span><span class="s3">, </span><span class="s1">divisions):</span>
                <span class="s1">result[name + (key</span><span class="s3">,</span><span class="s1">)] = rect</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">result[name] = (x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">h)</span>
    <span class="s3">return </span><span class="s1">result</span>


<span class="s3">def </span><span class="s1">_tuplify(obj):</span>
    <span class="s0">&quot;&quot;&quot;convert an object in a tuple of strings (even if it is not iterable, 
    like a single integer number, but keep the string healthy) 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">np.iterable(obj) </span><span class="s3">and not </span><span class="s1">isinstance(obj</span><span class="s3">, </span><span class="s1">str):</span>
        <span class="s1">res = tuple(str(o) </span><span class="s3">for </span><span class="s1">o </span><span class="s3">in </span><span class="s1">obj)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">res = (str(obj)</span><span class="s3">,</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">res</span>


<span class="s3">def </span><span class="s1">_categories_level(keys):</span>
    <span class="s0">&quot;&quot;&quot;use the Ordered dict to implement a simple ordered set 
    return each level of each category 
    [[key_1_level_1,key_2_level_1],[key_1_level_2,key_2_level_2]] 
    &quot;&quot;&quot;</span>
    <span class="s1">res = []</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">zip(*(keys)):</span>
        <span class="s1">tuplefied = _tuplify(i)</span>
        <span class="s1">res.append(list(dict([(j</span><span class="s3">, None</span><span class="s1">) </span><span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">tuplefied])))</span>
    <span class="s3">return </span><span class="s1">res</span>


<span class="s3">def </span><span class="s1">_hierarchical_split(count_dict</span><span class="s3">, </span><span class="s1">horizontal=</span><span class="s3">True, </span><span class="s1">gap=</span><span class="s5">0.05</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Split a square in a hierarchical way given a contingency table. 
 
    Hierarchically split the unit square in alternate directions 
    in proportion to the subdivision contained in the contingency table 
    count_dict.  This is the function that actually perform the tiling 
    for the creation of the mosaic plot.  If the gap array has been specified 
    it will insert a corresponding amount of space (proportional to the 
    unit length), while retaining the proportionality of the tiles. 
 
    Parameters 
    ---------- 
    count_dict : dict 
        Dictionary containing the contingency table. 
        Each category should contain a non-negative number 
        with a tuple as index.  It expects that all the combination 
        of keys to be represents; if that is not true, will 
        automatically consider the missing values as 0 
    horizontal : bool 
        The starting direction of the split (by default along 
        the horizontal axis) 
    gap : float or array of floats 
        The list of gaps to be applied on each subdivision. 
        If the length of the given array is less of the number 
        of subcategories (or if it's a single number) it will extend 
        it with exponentially decreasing gaps 
 
    Returns 
    ------- 
    base_rect : dict 
        A dictionary containing the result of the split. 
        To each key is associated a 4-tuple of coordinates 
        that are required to create the corresponding rectangle: 
 
            0 - x position of the lower left corner 
            1 - y position of the lower left corner 
            2 - width of the rectangle 
            3 - height of the rectangle 
    &quot;&quot;&quot;</span>
    <span class="s2"># this is the unit square that we are going to divide</span>
    <span class="s1">base_rect = dict([(tuple()</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">))])</span>
    <span class="s2"># get the list of each possible value for each level</span>
    <span class="s1">categories_levels = _categories_level(list(count_dict.keys()))</span>
    <span class="s1">L = len(categories_levels)</span>

    <span class="s2"># recreate the gaps vector starting from an int</span>
    <span class="s3">if not </span><span class="s1">np.iterable(gap):</span>
        <span class="s1">gap = [gap / </span><span class="s5">1.5 </span><span class="s1">** idx </span><span class="s3">for </span><span class="s1">idx </span><span class="s3">in </span><span class="s1">range(L)]</span>
    <span class="s2"># extend if it's too short</span>
    <span class="s3">if </span><span class="s1">len(gap) &lt; L:</span>
        <span class="s1">last = gap[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">gap = list(*gap) + [last / </span><span class="s5">1.5 </span><span class="s1">** idx </span><span class="s3">for </span><span class="s1">idx </span><span class="s3">in </span><span class="s1">range(L)]</span>
    <span class="s2"># trim if it's too long</span>
    <span class="s1">gap = gap[:L]</span>
    <span class="s2"># put the count dictionay in order for the keys</span>
    <span class="s2"># this will allow some code simplification</span>
    <span class="s1">count_ordered = dict([(k</span><span class="s3">, </span><span class="s1">count_dict[k])</span>
                        <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list(product(*categories_levels))])</span>
    <span class="s3">for </span><span class="s1">cat_idx</span><span class="s3">, </span><span class="s1">cat_enum </span><span class="s3">in </span><span class="s1">enumerate(categories_levels):</span>
        <span class="s2"># get the partial key up to the actual level</span>
        <span class="s1">base_keys = list(product(*categories_levels[:cat_idx]))</span>
        <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">base_keys:</span>
            <span class="s2"># for each partial and each value calculate how many</span>
            <span class="s2"># observation we have in the counting dictionary</span>
            <span class="s1">part_count = [_reduce_dict(count_ordered</span><span class="s3">, </span><span class="s1">key + (partial</span><span class="s3">,</span><span class="s1">))</span>
                            <span class="s3">for </span><span class="s1">partial </span><span class="s3">in </span><span class="s1">cat_enum]</span>
            <span class="s2"># reduce the gap for subsequents levels</span>
            <span class="s1">new_gap = gap[cat_idx]</span>
            <span class="s2"># split the given subkeys in the rectangle dictionary</span>
            <span class="s1">base_rect = _key_splitting(base_rect</span><span class="s3">, </span><span class="s1">cat_enum</span><span class="s3">, </span><span class="s1">part_count</span><span class="s3">, </span><span class="s1">key</span><span class="s3">,</span>
                                       <span class="s1">horizontal</span><span class="s3">, </span><span class="s1">new_gap)</span>
        <span class="s1">horizontal = </span><span class="s3">not </span><span class="s1">horizontal</span>
    <span class="s3">return </span><span class="s1">base_rect</span>


<span class="s3">def </span><span class="s1">_single_hsv_to_rgb(hsv):</span>
    <span class="s0">&quot;&quot;&quot;Transform a color from the hsv space to the rgb.&quot;&quot;&quot;</span>
    <span class="s3">from </span><span class="s1">matplotlib.colors </span><span class="s3">import </span><span class="s1">hsv_to_rgb</span>
    <span class="s3">return </span><span class="s1">hsv_to_rgb(array(hsv).reshape(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)).reshape(</span><span class="s5">3</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">_create_default_properties(data):</span>
    <span class="s0">&quot;&quot;&quot;&quot;Create the default properties of the mosaic given the data 
    first it will varies the color hue (first category) then the color 
    saturation (second category) and then the color value 
    (third category).  If a fourth category is found, it will put 
    decoration on the rectangle.  Does not manage more than four 
    level of categories 
    &quot;&quot;&quot;</span>
    <span class="s1">categories_levels = _categories_level(list(data.keys()))</span>
    <span class="s1">Nlevels = len(categories_levels)</span>
    <span class="s2"># first level, the hue</span>
    <span class="s1">L = len(categories_levels[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s2"># hue = np.linspace(1.0, 0.0, L+1)[:-1]</span>
    <span class="s1">hue = np.linspace(</span><span class="s5">0.0</span><span class="s3">, </span><span class="s5">1.0</span><span class="s3">, </span><span class="s1">L + </span><span class="s5">2</span><span class="s1">)[:-</span><span class="s5">2</span><span class="s1">]</span>
    <span class="s2"># second level, the saturation</span>
    <span class="s1">L = len(categories_levels[</span><span class="s5">1</span><span class="s1">]) </span><span class="s3">if </span><span class="s1">Nlevels &gt; </span><span class="s5">1 </span><span class="s3">else </span><span class="s5">1</span>
    <span class="s1">saturation = np.linspace(</span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">1.0</span><span class="s3">, </span><span class="s1">L + </span><span class="s5">1</span><span class="s1">)[:-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s2"># third level, the value</span>
    <span class="s1">L = len(categories_levels[</span><span class="s5">2</span><span class="s1">]) </span><span class="s3">if </span><span class="s1">Nlevels &gt; </span><span class="s5">2 </span><span class="s3">else </span><span class="s5">1</span>
    <span class="s1">value = np.linspace(</span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">1.0</span><span class="s3">, </span><span class="s1">L + </span><span class="s5">1</span><span class="s1">)[:-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s2"># fourth level, the hatch</span>
    <span class="s1">L = len(categories_levels[</span><span class="s5">3</span><span class="s1">]) </span><span class="s3">if </span><span class="s1">Nlevels &gt; </span><span class="s5">3 </span><span class="s3">else </span><span class="s5">1</span>
    <span class="s1">hatch = [</span><span class="s4">''</span><span class="s3">, </span><span class="s4">'/'</span><span class="s3">, </span><span class="s4">'-'</span><span class="s3">, </span><span class="s4">'|'</span><span class="s3">, </span><span class="s4">'+'</span><span class="s1">][:L + </span><span class="s5">1</span><span class="s1">]</span>
    <span class="s2"># convert in list and merge with the levels</span>
    <span class="s1">hue = lzip(list(hue)</span><span class="s3">, </span><span class="s1">categories_levels[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s1">saturation = lzip(list(saturation)</span><span class="s3">,</span>
                     <span class="s1">categories_levels[</span><span class="s5">1</span><span class="s1">] </span><span class="s3">if </span><span class="s1">Nlevels &gt; </span><span class="s5">1 </span><span class="s3">else </span><span class="s1">[</span><span class="s4">''</span><span class="s1">])</span>
    <span class="s1">value = lzip(list(value)</span><span class="s3">,</span>
                     <span class="s1">categories_levels[</span><span class="s5">2</span><span class="s1">] </span><span class="s3">if </span><span class="s1">Nlevels &gt; </span><span class="s5">2 </span><span class="s3">else </span><span class="s1">[</span><span class="s4">''</span><span class="s1">])</span>
    <span class="s1">hatch = lzip(list(hatch)</span><span class="s3">,</span>
                     <span class="s1">categories_levels[</span><span class="s5">3</span><span class="s1">] </span><span class="s3">if </span><span class="s1">Nlevels &gt; </span><span class="s5">3 </span><span class="s3">else </span><span class="s1">[</span><span class="s4">''</span><span class="s1">])</span>
    <span class="s2"># create the properties dictionary</span>
    <span class="s1">properties = {}</span>
    <span class="s3">for </span><span class="s1">h</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">v</span><span class="s3">, </span><span class="s1">t </span><span class="s3">in </span><span class="s1">product(hue</span><span class="s3">, </span><span class="s1">saturation</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">hatch):</span>
        <span class="s1">hv</span><span class="s3">, </span><span class="s1">hn = h</span>
        <span class="s1">sv</span><span class="s3">, </span><span class="s1">sn = s</span>
        <span class="s1">vv</span><span class="s3">, </span><span class="s1">vn = v</span>
        <span class="s1">tv</span><span class="s3">, </span><span class="s1">tn = t</span>
        <span class="s1">level = (hn</span><span class="s3">,</span><span class="s1">) + ((sn</span><span class="s3">,</span><span class="s1">) </span><span class="s3">if </span><span class="s1">sn </span><span class="s3">else </span><span class="s1">tuple())</span>
        <span class="s1">level = level + ((vn</span><span class="s3">,</span><span class="s1">) </span><span class="s3">if </span><span class="s1">vn </span><span class="s3">else </span><span class="s1">tuple())</span>
        <span class="s1">level = level + ((tn</span><span class="s3">,</span><span class="s1">) </span><span class="s3">if </span><span class="s1">tn </span><span class="s3">else </span><span class="s1">tuple())</span>
        <span class="s1">hsv = array([hv</span><span class="s3">, </span><span class="s1">sv</span><span class="s3">, </span><span class="s1">vv])</span>
        <span class="s1">prop = {</span><span class="s4">'color'</span><span class="s1">: _single_hsv_to_rgb(hsv)</span><span class="s3">, </span><span class="s4">'hatch'</span><span class="s1">: tv</span><span class="s3">, </span><span class="s4">'lw'</span><span class="s1">: </span><span class="s5">0</span><span class="s1">}</span>
        <span class="s1">properties[level] = prop</span>
    <span class="s3">return </span><span class="s1">properties</span>


<span class="s3">def </span><span class="s1">_normalize_data(data</span><span class="s3">, </span><span class="s1">index):</span>
    <span class="s0">&quot;&quot;&quot;normalize the data to a dict with tuples of strings as keys 
    right now it works with: 
 
        0 - dictionary (or equivalent mappable) 
        1 - pandas.Series with simple or hierarchical indexes 
        2 - numpy.ndarrays 
        3 - everything that can be converted to a numpy array 
        4 - pandas.DataFrame (via the _normalize_dataframe function) 
    &quot;&quot;&quot;</span>
    <span class="s2"># if data is a dataframe we need to take a completely new road</span>
    <span class="s2"># before coming back here. Use the hasattr to avoid importing</span>
    <span class="s2"># pandas explicitly</span>
    <span class="s3">if </span><span class="s1">hasattr(data</span><span class="s3">, </span><span class="s4">'pivot'</span><span class="s1">) </span><span class="s3">and </span><span class="s1">hasattr(data</span><span class="s3">, </span><span class="s4">'groupby'</span><span class="s1">):</span>
        <span class="s1">data = _normalize_dataframe(data</span><span class="s3">, </span><span class="s1">index)</span>
        <span class="s1">index = </span><span class="s3">None</span>
    <span class="s2"># can it be used as a dictionary?</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">items = list(data.items())</span>
    <span class="s3">except </span><span class="s1">AttributeError:</span>
        <span class="s2"># ok, I cannot use the data as a dictionary</span>
        <span class="s2"># Try to convert it to a numpy array, or die trying</span>
        <span class="s1">data = np.asarray(data)</span>
        <span class="s1">temp = {}</span>
        <span class="s3">for </span><span class="s1">idx </span><span class="s3">in </span><span class="s1">np.ndindex(data.shape):</span>
            <span class="s1">name = tuple(i </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">idx)</span>
            <span class="s1">temp[name] = data[idx]</span>
        <span class="s1">data = temp</span>
        <span class="s1">items = list(data.items())</span>
    <span class="s2"># make all the keys a tuple, even if simple numbers</span>
    <span class="s1">data = dict([_tuplify(k)</span><span class="s3">, </span><span class="s1">v] </span><span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">items)</span>
    <span class="s1">categories_levels = _categories_level(list(data.keys()))</span>
    <span class="s2"># fill the void in the counting dictionary</span>
    <span class="s1">indexes = product(*categories_levels)</span>
    <span class="s1">contingency = dict([(k</span><span class="s3">, </span><span class="s1">data.get(k</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)) </span><span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">indexes])</span>
    <span class="s1">data = contingency</span>
    <span class="s2"># reorder the keys order according to the one specified by the user</span>
    <span class="s2"># or if the index is None convert it into a simple list</span>
    <span class="s2"># right now it does not do any check, but can be modified in the future</span>
    <span class="s1">index = lrange(len(categories_levels)) </span><span class="s3">if </span><span class="s1">index </span><span class="s3">is None else </span><span class="s1">index</span>
    <span class="s1">contingency = {}</span>
    <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">data.items():</span>
        <span class="s1">new_key = tuple(key[i] </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">index)</span>
        <span class="s1">contingency[new_key] = value</span>
    <span class="s1">data = contingency</span>
    <span class="s3">return </span><span class="s1">data</span>


<span class="s3">def </span><span class="s1">_normalize_dataframe(dataframe</span><span class="s3">, </span><span class="s1">index):</span>
    <span class="s0">&quot;&quot;&quot;Take a pandas DataFrame and count the element present in the 
    given columns, return a hierarchical index on those columns 
    &quot;&quot;&quot;</span>
    <span class="s2">#groupby the given keys, extract the same columns and count the element</span>
    <span class="s2"># then collapse them with a mean</span>
    <span class="s1">data = dataframe[index].dropna()</span>
    <span class="s1">grouped = data.groupby(index</span><span class="s3">, </span><span class="s1">sort=</span><span class="s3">False, </span><span class="s1">observed=</span><span class="s3">False</span><span class="s1">)</span>
    <span class="s1">counted = grouped[index].count()</span>
    <span class="s1">averaged = counted.mean(axis=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s2"># Fill empty missing with 0, see GH5639</span>
    <span class="s1">averaged = averaged.fillna(</span><span class="s5">0.0</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">averaged</span>


<span class="s3">def </span><span class="s1">_statistical_coloring(data):</span>
    <span class="s0">&quot;&quot;&quot;evaluate colors from the indipendence properties of the matrix 
    It will encounter problem if one category has all zeros 
    &quot;&quot;&quot;</span>
    <span class="s1">data = _normalize_data(data</span><span class="s3">, None</span><span class="s1">)</span>
    <span class="s1">categories_levels = _categories_level(list(data.keys()))</span>
    <span class="s1">Nlevels = len(categories_levels)</span>
    <span class="s1">total = </span><span class="s5">1.0 </span><span class="s1">* sum(v </span><span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">data.values())</span>
    <span class="s2"># count the proportion of observation</span>
    <span class="s2"># for each level that has the given name</span>
    <span class="s2"># at each level</span>
    <span class="s1">levels_count = []</span>
    <span class="s3">for </span><span class="s1">level_idx </span><span class="s3">in </span><span class="s1">range(Nlevels):</span>
        <span class="s1">proportion = {}</span>
        <span class="s3">for </span><span class="s1">level </span><span class="s3">in </span><span class="s1">categories_levels[level_idx]:</span>
            <span class="s1">proportion[level] = </span><span class="s5">0.0</span>
            <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">data.items():</span>
                <span class="s3">if </span><span class="s1">level == key[level_idx]:</span>
                    <span class="s1">proportion[level] += value</span>
            <span class="s1">proportion[level] /= total</span>
        <span class="s1">levels_count.append(proportion)</span>
    <span class="s2"># for each key I obtain the expected value</span>
    <span class="s2"># and it's standard deviation from a binomial distribution</span>
    <span class="s2"># under the hipothesys of independence</span>
    <span class="s1">expected = {}</span>
    <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">data.items():</span>
        <span class="s1">base = </span><span class="s5">1.0</span>
        <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">k </span><span class="s3">in </span><span class="s1">enumerate(key):</span>
            <span class="s1">base *= levels_count[i][k]</span>
        <span class="s1">expected[key] = base * total</span><span class="s3">, </span><span class="s1">np.sqrt(total * base * (</span><span class="s5">1.0 </span><span class="s1">- base))</span>
    <span class="s2"># now we have the standard deviation of distance from the</span>
    <span class="s2"># expected value for each tile. We create the colors from this</span>
    <span class="s1">sigmas = dict((k</span><span class="s3">, </span><span class="s1">(data[k] - m) / s) </span><span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">(m</span><span class="s3">, </span><span class="s1">s) </span><span class="s3">in </span><span class="s1">expected.items())</span>
    <span class="s1">props = {}</span>
    <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">dev </span><span class="s3">in </span><span class="s1">sigmas.items():</span>
        <span class="s1">red = </span><span class="s5">0.0 </span><span class="s3">if </span><span class="s1">dev &lt; </span><span class="s5">0 </span><span class="s3">else </span><span class="s1">(dev / (</span><span class="s5">1 </span><span class="s1">+ dev))</span>
        <span class="s1">blue = </span><span class="s5">0.0 </span><span class="s3">if </span><span class="s1">dev &gt; </span><span class="s5">0 </span><span class="s3">else </span><span class="s1">(dev / (-</span><span class="s5">1 </span><span class="s1">+ dev))</span>
        <span class="s1">green = (</span><span class="s5">1.0 </span><span class="s1">- red - blue) / </span><span class="s5">2.0</span>
        <span class="s1">hatch = </span><span class="s4">'x' </span><span class="s3">if </span><span class="s1">dev &gt; </span><span class="s5">2 </span><span class="s3">else </span><span class="s4">'o' </span><span class="s3">if </span><span class="s1">dev &lt; -</span><span class="s5">2 </span><span class="s3">else </span><span class="s4">''</span>
        <span class="s1">props[key] = {</span><span class="s4">'color'</span><span class="s1">: [red</span><span class="s3">, </span><span class="s1">green</span><span class="s3">, </span><span class="s1">blue]</span><span class="s3">, </span><span class="s4">'hatch'</span><span class="s1">: hatch}</span>
    <span class="s3">return </span><span class="s1">props</span>


<span class="s3">def </span><span class="s1">_get_position(x</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">h</span><span class="s3">, </span><span class="s1">W):</span>
    <span class="s3">if </span><span class="s1">W == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">x</span>
    <span class="s3">return </span><span class="s1">(x + w / </span><span class="s5">2.0</span><span class="s1">) * w * h / W</span>


<span class="s3">def </span><span class="s1">_create_labels(rects</span><span class="s3">, </span><span class="s1">horizontal</span><span class="s3">, </span><span class="s1">ax</span><span class="s3">, </span><span class="s1">rotation):</span>
    <span class="s0">&quot;&quot;&quot;find the position of the label for each value of each category 
 
    right now it supports only up to the four categories 
 
    ax: the axis on which the label should be applied 
    rotation: the rotation list for each side 
    &quot;&quot;&quot;</span>
    <span class="s1">categories = _categories_level(list(rects.keys()))</span>
    <span class="s3">if </span><span class="s1">len(categories) &gt; </span><span class="s5">4</span><span class="s1">:</span>
        <span class="s1">msg = (</span><span class="s4">&quot;maximum of 4 level supported for axes labeling... and 4&quot;</span>
               <span class="s4">&quot;is already a lot of levels, are you sure you need them all?&quot;</span><span class="s1">)</span>
        <span class="s3">raise </span><span class="s1">ValueError(msg)</span>
    <span class="s1">labels = {}</span>
    <span class="s2">#keep it fixed as will be used a lot of times</span>
    <span class="s1">items = list(rects.items())</span>
    <span class="s1">vertical = </span><span class="s3">not </span><span class="s1">horizontal</span>

    <span class="s2">#get the axis ticks and labels locator to put the correct values!</span>
    <span class="s1">ax2 = ax.twinx()</span>
    <span class="s1">ax3 = ax.twiny()</span>
    <span class="s2">#this is the order of execution for horizontal disposition</span>
    <span class="s1">ticks_pos = [ax.set_xticks</span><span class="s3">, </span><span class="s1">ax.set_yticks</span><span class="s3">, </span><span class="s1">ax3.set_xticks</span><span class="s3">, </span><span class="s1">ax2.set_yticks]</span>
    <span class="s1">ticks_lab = [ax.set_xticklabels</span><span class="s3">, </span><span class="s1">ax.set_yticklabels</span><span class="s3">,</span>
                 <span class="s1">ax3.set_xticklabels</span><span class="s3">, </span><span class="s1">ax2.set_yticklabels]</span>
    <span class="s2">#for the vertical one, rotate it by one</span>
    <span class="s3">if </span><span class="s1">vertical:</span>
        <span class="s1">ticks_pos = ticks_pos[</span><span class="s5">1</span><span class="s1">:] + ticks_pos[:</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">ticks_lab = ticks_lab[</span><span class="s5">1</span><span class="s1">:] + ticks_lab[:</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s2">#clean them</span>
    <span class="s3">for </span><span class="s1">pos</span><span class="s3">, </span><span class="s1">lab </span><span class="s3">in </span><span class="s1">zip(ticks_pos</span><span class="s3">, </span><span class="s1">ticks_lab):</span>
        <span class="s1">pos([])</span>
        <span class="s1">lab([])</span>
    <span class="s2">#for each level, for each value in the level, take the mean of all</span>
    <span class="s2">#the sublevel that correspond to that partial key</span>
    <span class="s3">for </span><span class="s1">level_idx</span><span class="s3">, </span><span class="s1">level </span><span class="s3">in </span><span class="s1">enumerate(categories):</span>
        <span class="s2">#this dictionary keep the labels only for this level</span>
        <span class="s1">level_ticks = dict()</span>
        <span class="s3">for </span><span class="s1">value </span><span class="s3">in </span><span class="s1">level:</span>
            <span class="s2">#to which level it should refer to get the preceding</span>
            <span class="s2">#values of labels? it's rather a tricky question...</span>
            <span class="s2">#this is dependent on the side. It's a very crude management</span>
            <span class="s2">#but I couldn't think a more general way...</span>
            <span class="s3">if </span><span class="s1">horizontal:</span>
                <span class="s3">if </span><span class="s1">level_idx == </span><span class="s5">3</span><span class="s1">:</span>
                    <span class="s1">index_select = [-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">index_select = [+</span><span class="s5">0</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">level_idx == </span><span class="s5">3</span><span class="s1">:</span>
                    <span class="s1">index_select = [+</span><span class="s5">0</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">+</span><span class="s5">0</span><span class="s1">]</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">index_select = [-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s2">#now I create the base key name and append the current value</span>
            <span class="s2">#It will search on all the rects to find the corresponding one</span>
            <span class="s2">#and use them to evaluate the mean position</span>
            <span class="s1">basekey = tuple(categories[i][index_select[i]]</span>
                            <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(level_idx))</span>
            <span class="s1">basekey = basekey + (value</span><span class="s3">,</span><span class="s1">)</span>
            <span class="s1">subset = dict((k</span><span class="s3">, </span><span class="s1">v) </span><span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">items</span>
                          <span class="s3">if </span><span class="s1">basekey == k[:level_idx + </span><span class="s5">1</span><span class="s1">])</span>
            <span class="s2">#now I extract the center of all the tiles and make a weighted</span>
            <span class="s2">#mean of all these center on the area of the tile</span>
            <span class="s2">#this should give me the (more or less) correct position</span>
            <span class="s2">#of the center of the category</span>

            <span class="s1">vals = list(subset.values())</span>
            <span class="s1">W = sum(w * h </span><span class="s3">for </span><span class="s1">(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">h) </span><span class="s3">in </span><span class="s1">vals)</span>
            <span class="s1">x_lab = sum(_get_position(x</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">h</span><span class="s3">, </span><span class="s1">W) </span><span class="s3">for </span><span class="s1">(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">h) </span><span class="s3">in </span><span class="s1">vals)</span>
            <span class="s1">y_lab = sum(_get_position(y</span><span class="s3">, </span><span class="s1">h</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">W) </span><span class="s3">for </span><span class="s1">(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">h) </span><span class="s3">in </span><span class="s1">vals)</span>
            <span class="s2">#now base on the ordering, select which position to keep</span>
            <span class="s2">#needs to be written in a more general form of 4 level are enough?</span>
            <span class="s2">#should give also the horizontal and vertical alignment</span>
            <span class="s1">side = (level_idx + vertical) % </span><span class="s5">4</span>
            <span class="s1">level_ticks[value] = y_lab </span><span class="s3">if </span><span class="s1">side % </span><span class="s5">2 </span><span class="s3">else </span><span class="s1">x_lab</span>
        <span class="s2">#now we add the labels of this level to the correct axis</span>

        <span class="s1">ticks_pos[level_idx](list(level_ticks.values()))</span>
        <span class="s1">ticks_lab[level_idx](list(level_ticks.keys())</span><span class="s3">,</span>
                             <span class="s1">rotation=rotation[level_idx])</span>
    <span class="s3">return </span><span class="s1">labels</span>


<span class="s3">def </span><span class="s1">mosaic(data</span><span class="s3">, </span><span class="s1">index=</span><span class="s3">None, </span><span class="s1">ax=</span><span class="s3">None, </span><span class="s1">horizontal=</span><span class="s3">True, </span><span class="s1">gap=</span><span class="s5">0.005</span><span class="s3">,</span>
           <span class="s1">properties=</span><span class="s3">lambda </span><span class="s1">key: </span><span class="s3">None, </span><span class="s1">labelizer=</span><span class="s3">None,</span>
           <span class="s1">title=</span><span class="s4">''</span><span class="s3">, </span><span class="s1">statistic=</span><span class="s3">False, </span><span class="s1">axes_label=</span><span class="s3">True,</span>
           <span class="s1">label_rotation=</span><span class="s5">0.0</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Create a mosaic plot from a contingency table. 
 
    It allows to visualize multivariate categorical data in a rigorous 
    and informative way. 
 
    Parameters 
    ---------- 
    data : {dict, Series, ndarray, DataFrame} 
        The contingency table that contains the data. 
        Each category should contain a non-negative number 
        with a tuple as index.  It expects that all the combination 
        of keys to be represents; if that is not true, will 
        automatically consider the missing values as 0.  The order 
        of the keys will be the same as the one of insertion. 
        If a dict of a Series (or any other dict like object) 
        is used, it will take the keys as labels.  If a 
        np.ndarray is provided, it will generate a simple 
        numerical labels. 
    index : list, optional 
        Gives the preferred order for the category ordering. If not specified 
        will default to the given order.  It does not support named indexes 
        for hierarchical Series.  If a DataFrame is provided, it expects 
        a list with the name of the columns. 
    ax : Axes, optional 
        The graph where display the mosaic. If not given, will 
        create a new figure 
    horizontal : bool, optional 
        The starting direction of the split (by default along 
        the horizontal axis) 
    gap : {float, sequence[float]} 
        The list of gaps to be applied on each subdivision. 
        If the length of the given array is less of the number 
        of subcategories (or if it's a single number) it will extend 
        it with exponentially decreasing gaps 
    properties : dict[str, callable], optional 
        A function that for each tile in the mosaic take the key 
        of the tile and returns the dictionary of properties 
        of the generated Rectangle, like color, hatch or similar. 
        A default properties set will be provided fot the keys whose 
        color has not been defined, and will use color variation to help 
        visually separates the various categories. It should return None 
        to indicate that it should use the default property for the tile. 
        A dictionary of the properties for each key can be passed, 
        and it will be internally converted to the correct function 
    labelizer : dict[str, callable], optional 
        A function that generate the text to display at the center of 
        each tile base on the key of that tile 
    title : str, optional 
        The title of the axis 
    statistic : bool, optional 
        If true will use a crude statistical model to give colors to the plot. 
        If the tile has a constraint that is more than 2 standard deviation 
        from the expected value under independence hypothesis, it will 
        go from green to red (for positive deviations, blue otherwise) and 
        will acquire an hatching when crosses the 3 sigma. 
    axes_label : bool, optional 
        Show the name of each value of each category 
        on the axis (default) or hide them. 
    label_rotation : {float, list[float]} 
        The rotation of the axis label (if present). If a list is given 
        each axis can have a different rotation 
 
    Returns 
    ------- 
    fig : Figure 
        The figure containing the plot. 
    rects : dict 
        A dictionary that has the same keys of the original 
        dataset, that holds a reference to the coordinates of the 
        tile and the Rectangle that represent it. 
 
    References 
    ---------- 
    A Brief History of the Mosaic Display 
        Michael Friendly, York University, Psychology Department 
        Journal of Computational and Graphical Statistics, 2001 
 
    Mosaic Displays for Loglinear Models. 
        Michael Friendly, York University, Psychology Department 
        Proceedings of the Statistical Graphics Section, 1992, 61-68. 
 
    Mosaic displays for multi-way contingency tables. 
        Michael Friendly, York University, Psychology Department 
        Journal of the american statistical association 
        March 1994, Vol. 89, No. 425, Theory and Methods 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import pandas as pd 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from statsmodels.graphics.mosaicplot import mosaic 
 
    The most simple use case is to take a dictionary and plot the result 
 
    &gt;&gt;&gt; data = {'a': 10, 'b': 15, 'c': 16} 
    &gt;&gt;&gt; mosaic(data, title='basic dictionary') 
    &gt;&gt;&gt; plt.show() 
 
    A more useful example is given by a dictionary with multiple indices. 
    In this case we use a wider gap to a better visual separation of the 
    resulting plot 
 
    &gt;&gt;&gt; data = {('a', 'b'): 1, ('a', 'c'): 2, ('d', 'b'): 3, ('d', 'c'): 4} 
    &gt;&gt;&gt; mosaic(data, gap=0.05, title='complete dictionary') 
    &gt;&gt;&gt; plt.show() 
 
    The same data can be given as a simple or hierarchical indexed Series 
 
    &gt;&gt;&gt; rand = np.random.random 
    &gt;&gt;&gt; from itertools import product 
    &gt;&gt;&gt; tuples = list(product(['bar', 'baz', 'foo', 'qux'], ['one', 'two'])) 
    &gt;&gt;&gt; index = pd.MultiIndex.from_tuples(tuples, names=['first', 'second']) 
    &gt;&gt;&gt; data = pd.Series(rand(8), index=index) 
    &gt;&gt;&gt; mosaic(data, title='hierarchical index series') 
    &gt;&gt;&gt; plt.show() 
 
    The third accepted data structure is the np array, for which a 
    very simple index will be created. 
 
    &gt;&gt;&gt; rand = np.random.random 
    &gt;&gt;&gt; data = 1+rand((2,2)) 
    &gt;&gt;&gt; mosaic(data, title='random non-labeled array') 
    &gt;&gt;&gt; plt.show() 
 
    If you need to modify the labeling and the coloring you can give 
    a function tocreate the labels and one with the graphical properties 
    starting from the key tuple 
 
    &gt;&gt;&gt; data = {'a': 10, 'b': 15, 'c': 16} 
    &gt;&gt;&gt; props = lambda key: {'color': 'r' if 'a' in key else 'gray'} 
    &gt;&gt;&gt; labelizer = lambda k: {('a',): 'first', ('b',): 'second', 
    ...                        ('c',): 'third'}[k] 
    &gt;&gt;&gt; mosaic(data, title='colored dictionary', properties=props, 
    ...        labelizer=labelizer) 
    &gt;&gt;&gt; plt.show() 
 
    Using a DataFrame as source, specifying the name of the columns of interest 
 
    &gt;&gt;&gt; gender = ['male', 'male', 'male', 'female', 'female', 'female'] 
    &gt;&gt;&gt; pet = ['cat', 'dog', 'dog', 'cat', 'dog', 'cat'] 
    &gt;&gt;&gt; data = pd.DataFrame({'gender': gender, 'pet': pet}) 
    &gt;&gt;&gt; mosaic(data, ['pet', 'gender'], title='DataFrame as Source') 
    &gt;&gt;&gt; plt.show() 
 
    .. plot :: plots/graphics_mosaicplot_mosaic.py 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">isinstance(data</span><span class="s3">, </span><span class="s1">DataFrame) </span><span class="s3">and </span><span class="s1">index </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;You must pass an index if data is a DataFrame.&quot;</span>
                         <span class="s4">&quot; See examples.&quot;</span><span class="s1">)</span>

    <span class="s3">from </span><span class="s1">matplotlib.patches </span><span class="s3">import </span><span class="s1">Rectangle</span>

    <span class="s2">#from pylab import Rectangle</span>
    <span class="s1">fig</span><span class="s3">, </span><span class="s1">ax = utils.create_mpl_ax(ax)</span>
    <span class="s2"># normalize the data to a dict with tuple of strings as keys</span>
    <span class="s1">data = _normalize_data(data</span><span class="s3">, </span><span class="s1">index)</span>
    <span class="s2"># split the graph into different areas</span>
    <span class="s1">rects = _hierarchical_split(data</span><span class="s3">, </span><span class="s1">horizontal=horizontal</span><span class="s3">, </span><span class="s1">gap=gap)</span>
    <span class="s2"># if there is no specified way to create the labels</span>
    <span class="s2"># create a default one</span>
    <span class="s3">if </span><span class="s1">labelizer </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">labelizer = </span><span class="s3">lambda </span><span class="s1">k: </span><span class="s4">&quot;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">.join(k)</span>
    <span class="s3">if </span><span class="s1">statistic:</span>
        <span class="s1">default_props = _statistical_coloring(data)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">default_props = _create_default_properties(data)</span>
    <span class="s3">if </span><span class="s1">isinstance(properties</span><span class="s3">, </span><span class="s1">dict):</span>
        <span class="s1">color_dict = properties</span>
        <span class="s1">properties = </span><span class="s3">lambda </span><span class="s1">key: color_dict.get(key</span><span class="s3">, None</span><span class="s1">)</span>
    <span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">rects.items():</span>
        <span class="s2"># create each rectangle and put a label on it</span>
        <span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">h = v</span>
        <span class="s1">conf = properties(k)</span>
        <span class="s1">props = conf </span><span class="s3">if </span><span class="s1">conf </span><span class="s3">else </span><span class="s1">default_props[k]</span>
        <span class="s1">text = labelizer(k)</span>
        <span class="s1">Rect = Rectangle((x</span><span class="s3">, </span><span class="s1">y)</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">h</span><span class="s3">, </span><span class="s1">label=text</span><span class="s3">, </span><span class="s1">**props)</span>
        <span class="s1">ax.add_patch(Rect)</span>
        <span class="s1">ax.text(x + w / </span><span class="s5">2</span><span class="s3">, </span><span class="s1">y + h / </span><span class="s5">2</span><span class="s3">, </span><span class="s1">text</span><span class="s3">, </span><span class="s1">ha=</span><span class="s4">'center'</span><span class="s3">,</span>
                 <span class="s1">va=</span><span class="s4">'center'</span><span class="s3">, </span><span class="s1">size=</span><span class="s4">'smaller'</span><span class="s1">)</span>
    <span class="s2">#creating the labels on the axis</span>
    <span class="s2">#o clearing it</span>
    <span class="s3">if </span><span class="s1">axes_label:</span>
        <span class="s3">if </span><span class="s1">np.iterable(label_rotation):</span>
            <span class="s1">rotation = label_rotation</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">rotation = [label_rotation] * </span><span class="s5">4</span>
        <span class="s1">labels = _create_labels(rects</span><span class="s3">, </span><span class="s1">horizontal</span><span class="s3">, </span><span class="s1">ax</span><span class="s3">, </span><span class="s1">rotation)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">ax.set_xticks([])</span>
        <span class="s1">ax.set_xticklabels([])</span>
        <span class="s1">ax.set_yticks([])</span>
        <span class="s1">ax.set_yticklabels([])</span>
    <span class="s1">ax.set_title(title)</span>
    <span class="s3">return </span><span class="s1">fig</span><span class="s3">, </span><span class="s1">rects</span>
</pre>
</body>
</html>