<html>
<head>
<title>_dual_annealing.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_dual_annealing.py</font>
</center></td></tr></table>
<pre><span class="s0"># Dual Annealing implementation.</span>
<span class="s0"># Copyright (c) 2018 Sylvain Gubian &lt;sylvain.gubian@pmi.com&gt;,</span>
<span class="s0"># Yang Xiang &lt;yang.xiang@pmi.com&gt;</span>
<span class="s0"># Author: Sylvain Gubian, Yang Xiang, PMP S.A.</span>

<span class="s2">&quot;&quot;&quot; 
A Dual Annealing global optimization algorithm 
&quot;&quot;&quot;</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">scipy.optimize </span><span class="s3">import </span><span class="s1">OptimizeResult</span>
<span class="s3">from </span><span class="s1">scipy.optimize </span><span class="s3">import </span><span class="s1">minimize</span><span class="s3">, </span><span class="s1">Bounds</span>
<span class="s3">from </span><span class="s1">scipy.special </span><span class="s3">import </span><span class="s1">gammaln</span>
<span class="s3">from </span><span class="s1">scipy._lib._util </span><span class="s3">import </span><span class="s1">check_random_state</span>
<span class="s3">from </span><span class="s1">scipy.optimize._constraints </span><span class="s3">import </span><span class="s1">new_bounds_to_old</span>

<span class="s1">__all__ = [</span><span class="s4">'dual_annealing'</span><span class="s1">]</span>


<span class="s3">class </span><span class="s1">VisitingDistribution:</span>
    <span class="s2">&quot;&quot;&quot; 
    Class used to generate new coordinates based on the distorted 
    Cauchy-Lorentz distribution. Depending on the steps within the strategy 
    chain, the class implements the strategy for generating new location 
    changes. 
 
    Parameters 
    ---------- 
    lb : array_like 
        A 1-D NumPy ndarray containing lower bounds of the generated 
        components. Neither NaN or inf are allowed. 
    ub : array_like 
        A 1-D NumPy ndarray containing upper bounds for the generated 
        components. Neither NaN or inf are allowed. 
    visiting_param : float 
        Parameter for visiting distribution. Default value is 2.62. 
        Higher values give the visiting distribution a heavier tail, this 
        makes the algorithm jump to a more distant region. 
        The value range is (1, 3]. Its value is fixed for the life of the 
        object. 
    rand_gen : {`~numpy.random.RandomState`, `~numpy.random.Generator`} 
        A `~numpy.random.RandomState`, `~numpy.random.Generator` object 
        for using the current state of the created random generator container. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">TAIL_LIMIT = </span><span class="s5">1.e8</span>
    <span class="s1">MIN_VISIT_BOUND = </span><span class="s5">1.e-10</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">lb</span><span class="s3">, </span><span class="s1">ub</span><span class="s3">, </span><span class="s1">visiting_param</span><span class="s3">, </span><span class="s1">rand_gen):</span>
        <span class="s0"># if you wish to make _visiting_param adjustable during the life of</span>
        <span class="s0"># the object then _factor2, _factor3, _factor5, _d1, _factor6 will</span>
        <span class="s0"># have to be dynamically calculated in `visit_fn`. They're factored</span>
        <span class="s0"># out here so they don't need to be recalculated all the time.</span>
        <span class="s1">self._visiting_param = visiting_param</span>
        <span class="s1">self.rand_gen = rand_gen</span>
        <span class="s1">self.lower = lb</span>
        <span class="s1">self.upper = ub</span>
        <span class="s1">self.bound_range = ub - lb</span>

        <span class="s0"># these are invariant numbers unless visiting_param changes</span>
        <span class="s1">self._factor2 = np.exp((</span><span class="s5">4.0 </span><span class="s1">- self._visiting_param) * np.log(</span>
            <span class="s1">self._visiting_param - </span><span class="s5">1.0</span><span class="s1">))</span>
        <span class="s1">self._factor3 = np.exp((</span><span class="s5">2.0 </span><span class="s1">- self._visiting_param) * np.log(</span><span class="s5">2.0</span><span class="s1">)</span>
                               <span class="s1">/ (self._visiting_param - </span><span class="s5">1.0</span><span class="s1">))</span>
        <span class="s1">self._factor4_p = np.sqrt(np.pi) * self._factor2 / (self._factor3 * (</span>
            <span class="s5">3.0 </span><span class="s1">- self._visiting_param))</span>

        <span class="s1">self._factor5 = </span><span class="s5">1.0 </span><span class="s1">/ (self._visiting_param - </span><span class="s5">1.0</span><span class="s1">) - </span><span class="s5">0.5</span>
        <span class="s1">self._d1 = </span><span class="s5">2.0 </span><span class="s1">- self._factor5</span>
        <span class="s1">self._factor6 = np.pi * (</span><span class="s5">1.0 </span><span class="s1">- self._factor5) / np.sin(</span>
            <span class="s1">np.pi * (</span><span class="s5">1.0 </span><span class="s1">- self._factor5)) / np.exp(gammaln(self._d1))</span>

    <span class="s3">def </span><span class="s1">visiting(self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">step</span><span class="s3">, </span><span class="s1">temperature):</span>
        <span class="s2">&quot;&quot;&quot; Based on the step in the strategy chain, new coordinates are 
        generated by changing all components is the same time or only 
        one of them, the new values are computed with visit_fn method 
        &quot;&quot;&quot;</span>
        <span class="s1">dim = x.size</span>
        <span class="s3">if </span><span class="s1">step &lt; dim:</span>
            <span class="s0"># Changing all coordinates with a new visiting value</span>
            <span class="s1">visits = self.visit_fn(temperature</span><span class="s3">, </span><span class="s1">dim)</span>
            <span class="s1">upper_sample</span><span class="s3">, </span><span class="s1">lower_sample = self.rand_gen.uniform(size=</span><span class="s5">2</span><span class="s1">)</span>
            <span class="s1">visits[visits &gt; self.TAIL_LIMIT] = self.TAIL_LIMIT * upper_sample</span>
            <span class="s1">visits[visits &lt; -self.TAIL_LIMIT] = -self.TAIL_LIMIT * lower_sample</span>
            <span class="s1">x_visit = visits + x</span>
            <span class="s1">a = x_visit - self.lower</span>
            <span class="s1">b = np.fmod(a</span><span class="s3">, </span><span class="s1">self.bound_range) + self.bound_range</span>
            <span class="s1">x_visit = np.fmod(b</span><span class="s3">, </span><span class="s1">self.bound_range) + self.lower</span>
            <span class="s1">x_visit[np.fabs(</span>
                <span class="s1">x_visit - self.lower) &lt; self.MIN_VISIT_BOUND] += </span><span class="s5">1.e-10</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># Changing only one coordinate at a time based on strategy</span>
            <span class="s0"># chain step</span>
            <span class="s1">x_visit = np.copy(x)</span>
            <span class="s1">visit = self.visit_fn(temperature</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">visit &gt; self.TAIL_LIMIT:</span>
                <span class="s1">visit = self.TAIL_LIMIT * self.rand_gen.uniform()</span>
            <span class="s3">elif </span><span class="s1">visit &lt; -self.TAIL_LIMIT:</span>
                <span class="s1">visit = -self.TAIL_LIMIT * self.rand_gen.uniform()</span>
            <span class="s1">index = step - dim</span>
            <span class="s1">x_visit[index] = visit + x[index]</span>
            <span class="s1">a = x_visit[index] - self.lower[index]</span>
            <span class="s1">b = np.fmod(a</span><span class="s3">, </span><span class="s1">self.bound_range[index]) + self.bound_range[index]</span>
            <span class="s1">x_visit[index] = np.fmod(b</span><span class="s3">, </span><span class="s1">self.bound_range[</span>
                <span class="s1">index]) + self.lower[index]</span>
            <span class="s3">if </span><span class="s1">np.fabs(x_visit[index] - self.lower[</span>
                    <span class="s1">index]) &lt; self.MIN_VISIT_BOUND:</span>
                <span class="s1">x_visit[index] += self.MIN_VISIT_BOUND</span>
        <span class="s3">return </span><span class="s1">x_visit</span>

    <span class="s3">def </span><span class="s1">visit_fn(self</span><span class="s3">, </span><span class="s1">temperature</span><span class="s3">, </span><span class="s1">dim):</span>
        <span class="s2">&quot;&quot;&quot; Formula Visita from p. 405 of reference [2] &quot;&quot;&quot;</span>
        <span class="s1">x</span><span class="s3">, </span><span class="s1">y = self.rand_gen.normal(size=(dim</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)).T</span>

        <span class="s1">factor1 = np.exp(np.log(temperature) / (self._visiting_param - </span><span class="s5">1.0</span><span class="s1">))</span>
        <span class="s1">factor4 = self._factor4_p * factor1</span>

        <span class="s0"># sigmax</span>
        <span class="s1">x *= np.exp(-(self._visiting_param - </span><span class="s5">1.0</span><span class="s1">) * np.log(</span>
            <span class="s1">self._factor6 / factor4) / (</span><span class="s5">3.0 </span><span class="s1">- self._visiting_param))</span>

        <span class="s1">den = np.exp((self._visiting_param - </span><span class="s5">1.0</span><span class="s1">) * np.log(np.fabs(y)) /</span>
                     <span class="s1">(</span><span class="s5">3.0 </span><span class="s1">- self._visiting_param))</span>

        <span class="s3">return </span><span class="s1">x / den</span>


<span class="s3">class </span><span class="s1">EnergyState:</span>
    <span class="s2">&quot;&quot;&quot; 
    Class used to record the energy state. At any time, it knows what is the 
    currently used coordinates and the most recent best location. 
 
    Parameters 
    ---------- 
    lower : array_like 
        A 1-D NumPy ndarray containing lower bounds for generating an initial 
        random components in the `reset` method. 
    upper : array_like 
        A 1-D NumPy ndarray containing upper bounds for generating an initial 
        random components in the `reset` method 
        components. Neither NaN or inf are allowed. 
    callback : callable, ``callback(x, f, context)``, optional 
        A callback function which will be called for all minima found. 
        ``x`` and ``f`` are the coordinates and function value of the 
        latest minimum found, and `context` has value in [0, 1, 2] 
    &quot;&quot;&quot;</span>
    <span class="s0"># Maximum number of trials for generating a valid starting point</span>
    <span class="s1">MAX_REINIT_COUNT = </span><span class="s5">1000</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">lower</span><span class="s3">, </span><span class="s1">upper</span><span class="s3">, </span><span class="s1">callback=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">self.ebest = </span><span class="s3">None</span>
        <span class="s1">self.current_energy = </span><span class="s3">None</span>
        <span class="s1">self.current_location = </span><span class="s3">None</span>
        <span class="s1">self.xbest = </span><span class="s3">None</span>
        <span class="s1">self.lower = lower</span>
        <span class="s1">self.upper = upper</span>
        <span class="s1">self.callback = callback</span>

    <span class="s3">def </span><span class="s1">reset(self</span><span class="s3">, </span><span class="s1">func_wrapper</span><span class="s3">, </span><span class="s1">rand_gen</span><span class="s3">, </span><span class="s1">x0=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Initialize current location is the search domain. If `x0` is not 
        provided, a random location within the bounds is generated. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">x0 </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.current_location = rand_gen.uniform(self.lower</span><span class="s3">, </span><span class="s1">self.upper</span><span class="s3">,</span>
                                                     <span class="s1">size=len(self.lower))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.current_location = np.copy(x0)</span>
        <span class="s1">init_error = </span><span class="s3">True</span>
        <span class="s1">reinit_counter = </span><span class="s5">0</span>
        <span class="s3">while </span><span class="s1">init_error:</span>
            <span class="s1">self.current_energy = func_wrapper.fun(self.current_location)</span>
            <span class="s3">if </span><span class="s1">self.current_energy </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'Objective function is returning None'</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">not </span><span class="s1">np.isfinite(self.current_energy) </span><span class="s3">or </span><span class="s1">np.isnan(</span>
                    <span class="s1">self.current_energy)):</span>
                <span class="s3">if </span><span class="s1">reinit_counter &gt;= EnergyState.MAX_REINIT_COUNT:</span>
                    <span class="s1">init_error = </span><span class="s3">False</span>
                    <span class="s1">message = (</span>
                        <span class="s4">'Stopping algorithm because function '</span>
                        <span class="s4">'create NaN or (+/-) infinity values even with '</span>
                        <span class="s4">'trying new random parameters'</span>
                    <span class="s1">)</span>
                    <span class="s3">raise </span><span class="s1">ValueError(message)</span>
                <span class="s1">self.current_location = rand_gen.uniform(self.lower</span><span class="s3">,</span>
                                                         <span class="s1">self.upper</span><span class="s3">,</span>
                                                         <span class="s1">size=self.lower.size)</span>
                <span class="s1">reinit_counter += </span><span class="s5">1</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">init_error = </span><span class="s3">False</span>
            <span class="s0"># If first time reset, initialize ebest and xbest</span>
            <span class="s3">if </span><span class="s1">self.ebest </span><span class="s3">is None and </span><span class="s1">self.xbest </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">self.ebest = self.current_energy</span>
                <span class="s1">self.xbest = np.copy(self.current_location)</span>
            <span class="s0"># Otherwise, we keep them in case of reannealing reset</span>

    <span class="s3">def </span><span class="s1">update_best(self</span><span class="s3">, </span><span class="s1">e</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">context):</span>
        <span class="s1">self.ebest = e</span>
        <span class="s1">self.xbest = np.copy(x)</span>
        <span class="s3">if </span><span class="s1">self.callback </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">val = self.callback(x</span><span class="s3">, </span><span class="s1">e</span><span class="s3">, </span><span class="s1">context)</span>
            <span class="s3">if </span><span class="s1">val </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">val:</span>
                    <span class="s3">return </span><span class="s1">(</span><span class="s4">'Callback function requested to stop early by '</span>
                           <span class="s4">'returning True'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">update_current(self</span><span class="s3">, </span><span class="s1">e</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s1">self.current_energy = e</span>
        <span class="s1">self.current_location = np.copy(x)</span>


<span class="s3">class </span><span class="s1">StrategyChain:</span>
    <span class="s2">&quot;&quot;&quot; 
    Class that implements within a Markov chain the strategy for location 
    acceptance and local search decision making. 
 
    Parameters 
    ---------- 
    acceptance_param : float 
        Parameter for acceptance distribution. It is used to control the 
        probability of acceptance. The lower the acceptance parameter, the 
        smaller the probability of acceptance. Default value is -5.0 with 
        a range (-1e4, -5]. 
    visit_dist : VisitingDistribution 
        Instance of `VisitingDistribution` class. 
    func_wrapper : ObjectiveFunWrapper 
        Instance of `ObjectiveFunWrapper` class. 
    minimizer_wrapper: LocalSearchWrapper 
        Instance of `LocalSearchWrapper` class. 
    rand_gen : {None, int, `numpy.random.Generator`, 
                `numpy.random.RandomState`}, optional 
 
        If `seed` is None (or `np.random`), the `numpy.random.RandomState` 
        singleton is used. 
        If `seed` is an int, a new ``RandomState`` instance is used, 
        seeded with `seed`. 
        If `seed` is already a ``Generator`` or ``RandomState`` instance then 
        that instance is used. 
    energy_state: EnergyState 
        Instance of `EnergyState` class. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">acceptance_param</span><span class="s3">, </span><span class="s1">visit_dist</span><span class="s3">, </span><span class="s1">func_wrapper</span><span class="s3">,</span>
                 <span class="s1">minimizer_wrapper</span><span class="s3">, </span><span class="s1">rand_gen</span><span class="s3">, </span><span class="s1">energy_state):</span>
        <span class="s0"># Local strategy chain minimum energy and location</span>
        <span class="s1">self.emin = energy_state.current_energy</span>
        <span class="s1">self.xmin = np.array(energy_state.current_location)</span>
        <span class="s0"># Global optimizer state</span>
        <span class="s1">self.energy_state = energy_state</span>
        <span class="s0"># Acceptance parameter</span>
        <span class="s1">self.acceptance_param = acceptance_param</span>
        <span class="s0"># Visiting distribution instance</span>
        <span class="s1">self.visit_dist = visit_dist</span>
        <span class="s0"># Wrapper to objective function</span>
        <span class="s1">self.func_wrapper = func_wrapper</span>
        <span class="s0"># Wrapper to the local minimizer</span>
        <span class="s1">self.minimizer_wrapper = minimizer_wrapper</span>
        <span class="s1">self.not_improved_idx = </span><span class="s5">0</span>
        <span class="s1">self.not_improved_max_idx = </span><span class="s5">1000</span>
        <span class="s1">self._rand_gen = rand_gen</span>
        <span class="s1">self.temperature_step = </span><span class="s5">0</span>
        <span class="s1">self.K = </span><span class="s5">100 </span><span class="s1">* len(energy_state.current_location)</span>

    <span class="s3">def </span><span class="s1">accept_reject(self</span><span class="s3">, </span><span class="s1">j</span><span class="s3">, </span><span class="s1">e</span><span class="s3">, </span><span class="s1">x_visit):</span>
        <span class="s1">r = self._rand_gen.uniform()</span>
        <span class="s1">pqv_temp = </span><span class="s5">1.0 </span><span class="s1">- ((</span><span class="s5">1.0 </span><span class="s1">- self.acceptance_param) *</span>
            <span class="s1">(e - self.energy_state.current_energy) / self.temperature_step)</span>
        <span class="s3">if </span><span class="s1">pqv_temp &lt;= </span><span class="s5">0.</span><span class="s1">:</span>
            <span class="s1">pqv = </span><span class="s5">0.</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">pqv = np.exp(np.log(pqv_temp) / (</span>
                <span class="s5">1. </span><span class="s1">- self.acceptance_param))</span>

        <span class="s3">if </span><span class="s1">r &lt;= pqv:</span>
            <span class="s0"># We accept the new location and update state</span>
            <span class="s1">self.energy_state.update_current(e</span><span class="s3">, </span><span class="s1">x_visit)</span>
            <span class="s1">self.xmin = np.copy(self.energy_state.current_location)</span>

        <span class="s0"># No improvement for a long time</span>
        <span class="s3">if </span><span class="s1">self.not_improved_idx &gt;= self.not_improved_max_idx:</span>
            <span class="s3">if </span><span class="s1">j == </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">self.energy_state.current_energy &lt; self.emin:</span>
                <span class="s1">self.emin = self.energy_state.current_energy</span>
                <span class="s1">self.xmin = np.copy(self.energy_state.current_location)</span>

    <span class="s3">def </span><span class="s1">run(self</span><span class="s3">, </span><span class="s1">step</span><span class="s3">, </span><span class="s1">temperature):</span>
        <span class="s1">self.temperature_step = temperature / float(step + </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">self.not_improved_idx += </span><span class="s5">1</span>
        <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range(self.energy_state.current_location.size * </span><span class="s5">2</span><span class="s1">):</span>
            <span class="s3">if </span><span class="s1">j == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">step == </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s1">self.energy_state_improved = </span><span class="s3">True</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">self.energy_state_improved = </span><span class="s3">False</span>
            <span class="s1">x_visit = self.visit_dist.visiting(</span>
                <span class="s1">self.energy_state.current_location</span><span class="s3">, </span><span class="s1">j</span><span class="s3">, </span><span class="s1">temperature)</span>
            <span class="s0"># Calling the objective function</span>
            <span class="s1">e = self.func_wrapper.fun(x_visit)</span>
            <span class="s3">if </span><span class="s1">e &lt; self.energy_state.current_energy:</span>
                <span class="s0"># We have got a better energy value</span>
                <span class="s1">self.energy_state.update_current(e</span><span class="s3">, </span><span class="s1">x_visit)</span>
                <span class="s3">if </span><span class="s1">e &lt; self.energy_state.ebest:</span>
                    <span class="s1">val = self.energy_state.update_best(e</span><span class="s3">, </span><span class="s1">x_visit</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
                    <span class="s3">if </span><span class="s1">val </span><span class="s3">is not None</span><span class="s1">:</span>
                        <span class="s3">if </span><span class="s1">val:</span>
                            <span class="s3">return </span><span class="s1">val</span>
                    <span class="s1">self.energy_state_improved = </span><span class="s3">True</span>
                    <span class="s1">self.not_improved_idx = </span><span class="s5">0</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s0"># We have not improved but do we accept the new location?</span>
                <span class="s1">self.accept_reject(j</span><span class="s3">, </span><span class="s1">e</span><span class="s3">, </span><span class="s1">x_visit)</span>
            <span class="s3">if </span><span class="s1">self.func_wrapper.nfev &gt;= self.func_wrapper.maxfun:</span>
                <span class="s3">return </span><span class="s1">(</span><span class="s4">'Maximum number of function call reached '</span>
                        <span class="s4">'during annealing'</span><span class="s1">)</span>
        <span class="s0"># End of StrategyChain loop</span>

    <span class="s3">def </span><span class="s1">local_search(self):</span>
        <span class="s0"># Decision making for performing a local search</span>
        <span class="s0"># based on strategy chain results</span>
        <span class="s0"># If energy has been improved or no improvement since too long,</span>
        <span class="s0"># performing a local search with the best strategy chain location</span>
        <span class="s3">if </span><span class="s1">self.energy_state_improved:</span>
            <span class="s0"># Global energy has improved, let's see if LS improves further</span>
            <span class="s1">e</span><span class="s3">, </span><span class="s1">x = self.minimizer_wrapper.local_search(self.energy_state.xbest</span><span class="s3">,</span>
                                                       <span class="s1">self.energy_state.ebest)</span>
            <span class="s3">if </span><span class="s1">e &lt; self.energy_state.ebest:</span>
                <span class="s1">self.not_improved_idx = </span><span class="s5">0</span>
                <span class="s1">val = self.energy_state.update_best(e</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
                <span class="s3">if </span><span class="s1">val </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s3">if </span><span class="s1">val:</span>
                        <span class="s3">return </span><span class="s1">val</span>
                <span class="s1">self.energy_state.update_current(e</span><span class="s3">, </span><span class="s1">x)</span>
            <span class="s3">if </span><span class="s1">self.func_wrapper.nfev &gt;= self.func_wrapper.maxfun:</span>
                <span class="s3">return </span><span class="s1">(</span><span class="s4">'Maximum number of function call reached '</span>
                        <span class="s4">'during local search'</span><span class="s1">)</span>
        <span class="s0"># Check probability of a need to perform a LS even if no improvement</span>
        <span class="s1">do_ls = </span><span class="s3">False</span>
        <span class="s3">if </span><span class="s1">self.K &lt; </span><span class="s5">90 </span><span class="s1">* len(self.energy_state.current_location):</span>
            <span class="s1">pls = np.exp(self.K * (</span>
                <span class="s1">self.energy_state.ebest - self.energy_state.current_energy) /</span>
                <span class="s1">self.temperature_step)</span>
            <span class="s3">if </span><span class="s1">pls &gt;= self._rand_gen.uniform():</span>
                <span class="s1">do_ls = </span><span class="s3">True</span>
        <span class="s0"># Global energy not improved, let's see what LS gives</span>
        <span class="s0"># on the best strategy chain location</span>
        <span class="s3">if </span><span class="s1">self.not_improved_idx &gt;= self.not_improved_max_idx:</span>
            <span class="s1">do_ls = </span><span class="s3">True</span>
        <span class="s3">if </span><span class="s1">do_ls:</span>
            <span class="s1">e</span><span class="s3">, </span><span class="s1">x = self.minimizer_wrapper.local_search(self.xmin</span><span class="s3">, </span><span class="s1">self.emin)</span>
            <span class="s1">self.xmin = np.copy(x)</span>
            <span class="s1">self.emin = e</span>
            <span class="s1">self.not_improved_idx = </span><span class="s5">0</span>
            <span class="s1">self.not_improved_max_idx = self.energy_state.current_location.size</span>
            <span class="s3">if </span><span class="s1">e &lt; self.energy_state.ebest:</span>
                <span class="s1">val = self.energy_state.update_best(</span>
                    <span class="s1">self.emin</span><span class="s3">, </span><span class="s1">self.xmin</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span>
                <span class="s3">if </span><span class="s1">val </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s3">if </span><span class="s1">val:</span>
                        <span class="s3">return </span><span class="s1">val</span>
                <span class="s1">self.energy_state.update_current(e</span><span class="s3">, </span><span class="s1">x)</span>
            <span class="s3">if </span><span class="s1">self.func_wrapper.nfev &gt;= self.func_wrapper.maxfun:</span>
                <span class="s3">return </span><span class="s1">(</span><span class="s4">'Maximum number of function call reached '</span>
                        <span class="s4">'during dual annealing'</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">ObjectiveFunWrapper:</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">maxfun=</span><span class="s5">1e7</span><span class="s3">, </span><span class="s1">*args):</span>
        <span class="s1">self.func = func</span>
        <span class="s1">self.args = args</span>
        <span class="s0"># Number of objective function evaluations</span>
        <span class="s1">self.nfev = </span><span class="s5">0</span>
        <span class="s0"># Number of gradient function evaluation if used</span>
        <span class="s1">self.ngev = </span><span class="s5">0</span>
        <span class="s0"># Number of hessian of the objective function if used</span>
        <span class="s1">self.nhev = </span><span class="s5">0</span>
        <span class="s1">self.maxfun = maxfun</span>

    <span class="s3">def </span><span class="s1">fun(self</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s1">self.nfev += </span><span class="s5">1</span>
        <span class="s3">return </span><span class="s1">self.func(x</span><span class="s3">, </span><span class="s1">*self.args)</span>


<span class="s3">class </span><span class="s1">LocalSearchWrapper:</span>
    <span class="s2">&quot;&quot;&quot; 
    Class used to wrap around the minimizer used for local search 
    Default local minimizer is SciPy minimizer L-BFGS-B 
    &quot;&quot;&quot;</span>

    <span class="s1">LS_MAXITER_RATIO = </span><span class="s5">6</span>
    <span class="s1">LS_MAXITER_MIN = </span><span class="s5">100</span>
    <span class="s1">LS_MAXITER_MAX = </span><span class="s5">1000</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">search_bounds</span><span class="s3">, </span><span class="s1">func_wrapper</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s1">self.func_wrapper = func_wrapper</span>
        <span class="s1">self.kwargs = kwargs</span>
        <span class="s1">self.jac = self.kwargs.get(</span><span class="s4">'jac'</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">self.minimizer = minimize</span>
        <span class="s1">bounds_list = list(zip(*search_bounds))</span>
        <span class="s1">self.lower = np.array(bounds_list[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s1">self.upper = np.array(bounds_list[</span><span class="s5">1</span><span class="s1">])</span>

        <span class="s0"># If no minimizer specified, use SciPy minimize with 'L-BFGS-B' method</span>
        <span class="s3">if not </span><span class="s1">self.kwargs:</span>
            <span class="s1">n = len(self.lower)</span>
            <span class="s1">ls_max_iter = min(max(n * self.LS_MAXITER_RATIO</span><span class="s3">,</span>
                                  <span class="s1">self.LS_MAXITER_MIN)</span><span class="s3">,</span>
                              <span class="s1">self.LS_MAXITER_MAX)</span>
            <span class="s1">self.kwargs[</span><span class="s4">'method'</span><span class="s1">] = </span><span class="s4">'L-BFGS-B'</span>
            <span class="s1">self.kwargs[</span><span class="s4">'options'</span><span class="s1">] = {</span>
                <span class="s4">'maxiter'</span><span class="s1">: ls_max_iter</span><span class="s3">,</span>
            <span class="s1">}</span>
            <span class="s1">self.kwargs[</span><span class="s4">'bounds'</span><span class="s1">] = list(zip(self.lower</span><span class="s3">, </span><span class="s1">self.upper))</span>
        <span class="s3">elif </span><span class="s1">callable(self.jac):</span>
            <span class="s3">def </span><span class="s1">wrapped_jac(x):</span>
                <span class="s3">return </span><span class="s1">self.jac(x</span><span class="s3">, </span><span class="s1">*args)</span>
            <span class="s1">self.kwargs[</span><span class="s4">'jac'</span><span class="s1">] = wrapped_jac</span>

    <span class="s3">def </span><span class="s1">local_search(self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">e):</span>
        <span class="s0"># Run local search from the given x location where energy value is e</span>
        <span class="s1">x_tmp = np.copy(x)</span>
        <span class="s1">mres = self.minimizer(self.func_wrapper.fun</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">**self.kwargs)</span>
        <span class="s3">if </span><span class="s4">'njev' </span><span class="s3">in </span><span class="s1">mres:</span>
            <span class="s1">self.func_wrapper.ngev += mres.njev</span>
        <span class="s3">if </span><span class="s4">'nhev' </span><span class="s3">in </span><span class="s1">mres:</span>
            <span class="s1">self.func_wrapper.nhev += mres.nhev</span>
        <span class="s0"># Check if is valid value</span>
        <span class="s1">is_finite = np.all(np.isfinite(mres.x)) </span><span class="s3">and </span><span class="s1">np.isfinite(mres.fun)</span>
        <span class="s1">in_bounds = np.all(mres.x &gt;= self.lower) </span><span class="s3">and </span><span class="s1">np.all(</span>
            <span class="s1">mres.x &lt;= self.upper)</span>
        <span class="s1">is_valid = is_finite </span><span class="s3">and </span><span class="s1">in_bounds</span>

        <span class="s0"># Use the new point only if it is valid and return a better results</span>
        <span class="s3">if </span><span class="s1">is_valid </span><span class="s3">and </span><span class="s1">mres.fun &lt; e:</span>
            <span class="s3">return </span><span class="s1">mres.fun</span><span class="s3">, </span><span class="s1">mres.x</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">e</span><span class="s3">, </span><span class="s1">x_tmp</span>


<span class="s3">def </span><span class="s1">dual_annealing(func</span><span class="s3">, </span><span class="s1">bounds</span><span class="s3">, </span><span class="s1">args=()</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s5">1000</span><span class="s3">,</span>
                   <span class="s1">minimizer_kwargs=</span><span class="s3">None, </span><span class="s1">initial_temp=</span><span class="s5">5230.</span><span class="s3">,</span>
                   <span class="s1">restart_temp_ratio=</span><span class="s5">2.e-5</span><span class="s3">, </span><span class="s1">visit=</span><span class="s5">2.62</span><span class="s3">, </span><span class="s1">accept=-</span><span class="s5">5.0</span><span class="s3">,</span>
                   <span class="s1">maxfun=</span><span class="s5">1e7</span><span class="s3">, </span><span class="s1">seed=</span><span class="s3">None, </span><span class="s1">no_local_search=</span><span class="s3">False,</span>
                   <span class="s1">callback=</span><span class="s3">None, </span><span class="s1">x0=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Find the global minimum of a function using Dual Annealing. 
 
    Parameters 
    ---------- 
    func : callable 
        The objective function to be minimized. Must be in the form 
        ``f(x, *args)``, where ``x`` is the argument in the form of a 1-D array 
        and ``args`` is a  tuple of any additional fixed parameters needed to 
        completely specify the function. 
    bounds : sequence or `Bounds` 
        Bounds for variables. There are two ways to specify the bounds: 
 
        1. Instance of `Bounds` class. 
        2. Sequence of ``(min, max)`` pairs for each element in `x`. 
 
    args : tuple, optional 
        Any additional fixed parameters needed to completely specify the 
        objective function. 
    maxiter : int, optional 
        The maximum number of global search iterations. Default value is 1000. 
    minimizer_kwargs : dict, optional 
        Extra keyword arguments to be passed to the local minimizer 
        (`minimize`). Some important options could be: 
        ``method`` for the minimizer method to use and ``args`` for 
        objective function additional arguments. 
    initial_temp : float, optional 
        The initial temperature, use higher values to facilitates a wider 
        search of the energy landscape, allowing dual_annealing to escape 
        local minima that it is trapped in. Default value is 5230. Range is 
        (0.01, 5.e4]. 
    restart_temp_ratio : float, optional 
        During the annealing process, temperature is decreasing, when it 
        reaches ``initial_temp * restart_temp_ratio``, the reannealing process 
        is triggered. Default value of the ratio is 2e-5. Range is (0, 1). 
    visit : float, optional 
        Parameter for visiting distribution. Default value is 2.62. Higher 
        values give the visiting distribution a heavier tail, this makes 
        the algorithm jump to a more distant region. The value range is (1, 3]. 
    accept : float, optional 
        Parameter for acceptance distribution. It is used to control the 
        probability of acceptance. The lower the acceptance parameter, the 
        smaller the probability of acceptance. Default value is -5.0 with 
        a range (-1e4, -5]. 
    maxfun : int, optional 
        Soft limit for the number of objective function calls. If the 
        algorithm is in the middle of a local search, this number will be 
        exceeded, the algorithm will stop just after the local search is 
        done. Default value is 1e7. 
    seed : {None, int, `numpy.random.Generator`, `numpy.random.RandomState`}, optional 
        If `seed` is None (or `np.random`), the `numpy.random.RandomState` 
        singleton is used. 
        If `seed` is an int, a new ``RandomState`` instance is used, 
        seeded with `seed`. 
        If `seed` is already a ``Generator`` or ``RandomState`` instance then 
        that instance is used. 
        Specify `seed` for repeatable minimizations. The random numbers 
        generated with this seed only affect the visiting distribution function 
        and new coordinates generation. 
    no_local_search : bool, optional 
        If `no_local_search` is set to True, a traditional Generalized 
        Simulated Annealing will be performed with no local search 
        strategy applied. 
    callback : callable, optional 
        A callback function with signature ``callback(x, f, context)``, 
        which will be called for all minima found. 
        ``x`` and ``f`` are the coordinates and function value of the 
        latest minimum found, and ``context`` has value in [0, 1, 2], with the 
        following meaning: 
 
            - 0: minimum detected in the annealing process. 
            - 1: detection occurred in the local search process. 
            - 2: detection done in the dual annealing process. 
 
        If the callback implementation returns True, the algorithm will stop. 
    x0 : ndarray, shape(n,), optional 
        Coordinates of a single N-D starting point. 
 
    Returns 
    ------- 
    res : OptimizeResult 
        The optimization result represented as a `OptimizeResult` object. 
        Important attributes are: ``x`` the solution array, ``fun`` the value 
        of the function at the solution, and ``message`` which describes the 
        cause of the termination. 
        See `OptimizeResult` for a description of other attributes. 
 
    Notes 
    ----- 
    This function implements the Dual Annealing optimization. This stochastic 
    approach derived from [3]_ combines the generalization of CSA (Classical 
    Simulated Annealing) and FSA (Fast Simulated Annealing) [1]_ [2]_ coupled 
    to a strategy for applying a local search on accepted locations [4]_. 
    An alternative implementation of this same algorithm is described in [5]_ 
    and benchmarks are presented in [6]_. This approach introduces an advanced 
    method to refine the solution found by the generalized annealing 
    process. This algorithm uses a distorted Cauchy-Lorentz visiting 
    distribution, with its shape controlled by the parameter :math:`q_{v}` 
 
    .. math:: 
 
        g_{q_{v}}(\\Delta x(t)) \\propto \\frac{ \\ 
        \\left[T_{q_{v}}(t) \\right]^{-\\frac{D}{3-q_{v}}}}{ \\ 
        \\left[{1+(q_{v}-1)\\frac{(\\Delta x(t))^{2}} { \\ 
        \\left[T_{q_{v}}(t)\\right]^{\\frac{2}{3-q_{v}}}}}\\right]^{ \\ 
        \\frac{1}{q_{v}-1}+\\frac{D-1}{2}}} 
 
    Where :math:`t` is the artificial time. This visiting distribution is used 
    to generate a trial jump distance :math:`\\Delta x(t)` of variable 
    :math:`x(t)` under artificial temperature :math:`T_{q_{v}}(t)`. 
 
    From the starting point, after calling the visiting distribution 
    function, the acceptance probability is computed as follows: 
 
    .. math:: 
 
        p_{q_{a}} = \\min{\\{1,\\left[1-(1-q_{a}) \\beta \\Delta E \\right]^{ \\ 
        \\frac{1}{1-q_{a}}}\\}} 
 
    Where :math:`q_{a}` is a acceptance parameter. For :math:`q_{a}&lt;1`, zero 
    acceptance probability is assigned to the cases where 
 
    .. math:: 
 
        [1-(1-q_{a}) \\beta \\Delta E] &lt; 0 
 
    The artificial temperature :math:`T_{q_{v}}(t)` is decreased according to 
 
    .. math:: 
 
        T_{q_{v}}(t) = T_{q_{v}}(1) \\frac{2^{q_{v}-1}-1}{\\left( \\ 
        1 + t\\right)^{q_{v}-1}-1} 
 
    Where :math:`q_{v}` is the visiting parameter. 
 
    .. versionadded:: 1.2.0 
 
    References 
    ---------- 
    .. [1] Tsallis C. Possible generalization of Boltzmann-Gibbs 
        statistics. Journal of Statistical Physics, 52, 479-487 (1998). 
    .. [2] Tsallis C, Stariolo DA. Generalized Simulated Annealing. 
        Physica A, 233, 395-406 (1996). 
    .. [3] Xiang Y, Sun DY, Fan W, Gong XG. Generalized Simulated 
        Annealing Algorithm and Its Application to the Thomson Model. 
        Physics Letters A, 233, 216-220 (1997). 
    .. [4] Xiang Y, Gong XG. Efficiency of Generalized Simulated 
        Annealing. Physical Review E, 62, 4473 (2000). 
    .. [5] Xiang Y, Gubian S, Suomela B, Hoeng J. Generalized 
        Simulated Annealing for Efficient Global Optimization: the GenSA 
        Package for R. The R Journal, Volume 5/1 (2013). 
    .. [6] Mullen, K. Continuous Global Optimization in R. Journal of 
        Statistical Software, 60(6), 1 - 45, (2014). 
        :doi:`10.18637/jss.v060.i06` 
 
    Examples 
    -------- 
    The following example is a 10-D problem, with many local minima. 
    The function involved is called Rastrigin 
    (https://en.wikipedia.org/wiki/Rastrigin_function) 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.optimize import dual_annealing 
    &gt;&gt;&gt; func = lambda x: np.sum(x*x - 10*np.cos(2*np.pi*x)) + 10*np.size(x) 
    &gt;&gt;&gt; lw = [-5.12] * 10 
    &gt;&gt;&gt; up = [5.12] * 10 
    &gt;&gt;&gt; ret = dual_annealing(func, bounds=list(zip(lw, up))) 
    &gt;&gt;&gt; ret.x 
    array([-4.26437714e-09, -3.91699361e-09, -1.86149218e-09, -3.97165720e-09, 
           -6.29151648e-09, -6.53145322e-09, -3.93616815e-09, -6.55623025e-09, 
           -6.05775280e-09, -5.00668935e-09]) # random 
    &gt;&gt;&gt; ret.fun 
    0.000000 
 
    &quot;&quot;&quot;</span>

    <span class="s3">if </span><span class="s1">isinstance(bounds</span><span class="s3">, </span><span class="s1">Bounds):</span>
        <span class="s1">bounds = new_bounds_to_old(bounds.lb</span><span class="s3">, </span><span class="s1">bounds.ub</span><span class="s3">, </span><span class="s1">len(bounds.lb))</span>

    <span class="s0"># noqa: E501</span>
    <span class="s3">if </span><span class="s1">x0 </span><span class="s3">is not None and not </span><span class="s1">len(x0) == len(bounds):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'Bounds size does not match x0'</span><span class="s1">)</span>

    <span class="s1">lu = list(zip(*bounds))</span>
    <span class="s1">lower = np.array(lu[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s1">upper = np.array(lu[</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s0"># Check that restart temperature ratio is correct</span>
    <span class="s3">if </span><span class="s1">restart_temp_ratio &lt;= </span><span class="s5">0. </span><span class="s3">or </span><span class="s1">restart_temp_ratio &gt;= </span><span class="s5">1.</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'Restart temperature ratio has to be in range (0, 1)'</span><span class="s1">)</span>
    <span class="s0"># Checking bounds are valid</span>
    <span class="s3">if </span><span class="s1">(np.any(np.isinf(lower)) </span><span class="s3">or </span><span class="s1">np.any(np.isinf(upper)) </span><span class="s3">or </span><span class="s1">np.any(</span>
            <span class="s1">np.isnan(lower)) </span><span class="s3">or </span><span class="s1">np.any(np.isnan(upper))):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'Some bounds values are inf values or nan values'</span><span class="s1">)</span>
    <span class="s0"># Checking that bounds are consistent</span>
    <span class="s3">if not </span><span class="s1">np.all(lower &lt; upper):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'Bounds are not consistent min &lt; max'</span><span class="s1">)</span>
    <span class="s0"># Checking that bounds are the same length</span>
    <span class="s3">if not </span><span class="s1">len(lower) == len(upper):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'Bounds do not have the same dimensions'</span><span class="s1">)</span>

    <span class="s0"># Wrapper for the objective function</span>
    <span class="s1">func_wrapper = ObjectiveFunWrapper(func</span><span class="s3">, </span><span class="s1">maxfun</span><span class="s3">, </span><span class="s1">*args)</span>

    <span class="s0"># minimizer_kwargs has to be a dict, not None</span>
    <span class="s1">minimizer_kwargs = minimizer_kwargs </span><span class="s3">or </span><span class="s1">{}</span>

    <span class="s1">minimizer_wrapper = LocalSearchWrapper(</span>
        <span class="s1">bounds</span><span class="s3">, </span><span class="s1">func_wrapper</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**minimizer_kwargs)</span>

    <span class="s0"># Initialization of random Generator for reproducible runs if seed provided</span>
    <span class="s1">rand_state = check_random_state(seed)</span>
    <span class="s0"># Initialization of the energy state</span>
    <span class="s1">energy_state = EnergyState(lower</span><span class="s3">, </span><span class="s1">upper</span><span class="s3">, </span><span class="s1">callback)</span>
    <span class="s1">energy_state.reset(func_wrapper</span><span class="s3">, </span><span class="s1">rand_state</span><span class="s3">, </span><span class="s1">x0)</span>
    <span class="s0"># Minimum value of annealing temperature reached to perform</span>
    <span class="s0"># re-annealing</span>
    <span class="s1">temperature_restart = initial_temp * restart_temp_ratio</span>
    <span class="s0"># VisitingDistribution instance</span>
    <span class="s1">visit_dist = VisitingDistribution(lower</span><span class="s3">, </span><span class="s1">upper</span><span class="s3">, </span><span class="s1">visit</span><span class="s3">, </span><span class="s1">rand_state)</span>
    <span class="s0"># Strategy chain instance</span>
    <span class="s1">strategy_chain = StrategyChain(accept</span><span class="s3">, </span><span class="s1">visit_dist</span><span class="s3">, </span><span class="s1">func_wrapper</span><span class="s3">,</span>
                                   <span class="s1">minimizer_wrapper</span><span class="s3">, </span><span class="s1">rand_state</span><span class="s3">, </span><span class="s1">energy_state)</span>
    <span class="s1">need_to_stop = </span><span class="s3">False</span>
    <span class="s1">iteration = </span><span class="s5">0</span>
    <span class="s1">message = []</span>
    <span class="s0"># OptimizeResult object to be returned</span>
    <span class="s1">optimize_res = OptimizeResult()</span>
    <span class="s1">optimize_res.success = </span><span class="s3">True</span>
    <span class="s1">optimize_res.status = </span><span class="s5">0</span>

    <span class="s1">t1 = np.exp((visit - </span><span class="s5">1</span><span class="s1">) * np.log(</span><span class="s5">2.0</span><span class="s1">)) - </span><span class="s5">1.0</span>
    <span class="s0"># Run the search loop</span>
    <span class="s3">while not </span><span class="s1">need_to_stop:</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(maxiter):</span>
            <span class="s0"># Compute temperature for this step</span>
            <span class="s1">s = float(i) + </span><span class="s5">2.0</span>
            <span class="s1">t2 = np.exp((visit - </span><span class="s5">1</span><span class="s1">) * np.log(s)) - </span><span class="s5">1.0</span>
            <span class="s1">temperature = initial_temp * t1 / t2</span>
            <span class="s3">if </span><span class="s1">iteration &gt;= maxiter:</span>
                <span class="s1">message.append(</span><span class="s4">&quot;Maximum number of iteration reached&quot;</span><span class="s1">)</span>
                <span class="s1">need_to_stop = </span><span class="s3">True</span>
                <span class="s3">break</span>
            <span class="s0"># Need a re-annealing process?</span>
            <span class="s3">if </span><span class="s1">temperature &lt; temperature_restart:</span>
                <span class="s1">energy_state.reset(func_wrapper</span><span class="s3">, </span><span class="s1">rand_state)</span>
                <span class="s3">break</span>
            <span class="s0"># starting strategy chain</span>
            <span class="s1">val = strategy_chain.run(i</span><span class="s3">, </span><span class="s1">temperature)</span>
            <span class="s3">if </span><span class="s1">val </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">message.append(val)</span>
                <span class="s1">need_to_stop = </span><span class="s3">True</span>
                <span class="s1">optimize_res.success = </span><span class="s3">False</span>
                <span class="s3">break</span>
            <span class="s0"># Possible local search at the end of the strategy chain</span>
            <span class="s3">if not </span><span class="s1">no_local_search:</span>
                <span class="s1">val = strategy_chain.local_search()</span>
                <span class="s3">if </span><span class="s1">val </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s1">message.append(val)</span>
                    <span class="s1">need_to_stop = </span><span class="s3">True</span>
                    <span class="s1">optimize_res.success = </span><span class="s3">False</span>
                    <span class="s3">break</span>
            <span class="s1">iteration += </span><span class="s5">1</span>

    <span class="s0"># Setting the OptimizeResult values</span>
    <span class="s1">optimize_res.x = energy_state.xbest</span>
    <span class="s1">optimize_res.fun = energy_state.ebest</span>
    <span class="s1">optimize_res.nit = iteration</span>
    <span class="s1">optimize_res.nfev = func_wrapper.nfev</span>
    <span class="s1">optimize_res.njev = func_wrapper.ngev</span>
    <span class="s1">optimize_res.nhev = func_wrapper.nhev</span>
    <span class="s1">optimize_res.message = message</span>
    <span class="s3">return </span><span class="s1">optimize_res</span>
</pre>
</body>
</html>